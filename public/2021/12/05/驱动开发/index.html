<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zeroko14.gitee.io","root":"/blog/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="驱动开发准备工作环境配置参考">
<meta property="og:type" content="article">
<meta property="og:title" content="驱动开发">
<meta property="og:url" content="http://zeroko14.gitee.io/blog/2021/12/05/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/index.html">
<meta property="og:site_name" content="ZEROKO14的个人博客">
<meta property="og:description" content="驱动开发准备工作环境配置参考">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20210825204301335.png">
<meta property="og:image" content="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20210825204450485.png">
<meta property="og:image" content="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20210825212547927.png">
<meta property="og:image" content="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20211109133128464.png">
<meta property="og:image" content="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20210826200052881.png">
<meta property="og:image" content="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20210826200052881.png">
<meta property="og:image" content="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20210828154104796.png">
<meta property="og:image" content="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20210828154124934.png">
<meta property="og:image" content="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20210828154334924.png">
<meta property="og:image" content="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20210827111116147.png">
<meta property="og:image" content="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20210829163134914.png">
<meta property="og:image" content="https://gitee.com/ZEROKO14/blog-img/raw/master/img/sdsad.jpeg">
<meta property="og:image" content="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20210827114410752.png">
<meta property="og:image" content="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20210829212010210.png">
<meta property="og:image" content="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20210829212159461.png">
<meta property="og:image" content="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20210830211435935.png">
<meta property="article:published_time" content="2021-12-05T06:15:09.000Z">
<meta property="article:modified_time" content="2021-11-12T13:58:23.000Z">
<meta property="article:author" content="ZEROKO14">
<meta property="article:tag" content="内核相关">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20210825204301335.png">

<link rel="canonical" href="http://zeroko14.gitee.io/blog/2021/12/05/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>驱动开发 | ZEROKO14的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ZEROKO14的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">zeroko14's blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zeroko14.gitee.io/blog/2021/12/05/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="ZEROKO14">
      <meta itemprop="description" content="你好，欢迎来到ZEROKO14的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZEROKO14的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          驱动开发
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-05 14:15:09" itemprop="dateCreated datePublished" datetime="2021-12-05T14:15:09+08:00">2021-12-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-12 21:58:23" itemprop="dateModified" datetime="2021-11-12T21:58:23+08:00">2021-11-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="驱动开发"><a href="#驱动开发" class="headerlink" title="驱动开发"></a>驱动开发</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/newnewman80/article/details/90754999">环境配置参考</a></p>
<span id="more"></span>

<p>创建<strong>Empty WDM Driver</strong>项目，生成的Driver Files文件中的<strong>inf后缀文件</strong>可以直接删除</p>
<p>在源文件中添加的必须是.c后缀的C语言文件。</p>
<p>项目配置中：</p>
<ol>
<li>属性-C/C++中<code>将警告视为错误</code>选项设置为否</li>
<li>属性-链接器中<code>将链接器警告视为错误</code>设为否</li>
</ol>
<p>由于使用的是windowsXP作为开发环境，所以要<strong>针对windowsXP进行项目配置，参考链接</strong>：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Kwansy/article/details/111051265">开发各平台驱动的设置参考</a></p>
<p><strong>驱动的开发流程：</strong></p>
<p>编写代码-&gt;生成.sys文件-&gt;部署-&gt;启动-&gt;停止-&gt;卸载</p>
<p>驱动程序的测试最好在<strong>虚拟机中</strong>测试，因为一出问题就蓝屏</p>
<p><strong>DebugView</strong>软件监视选项中要选上<strong>监视核心</strong></p>
<p>驱动开发的调试：双机调试</p>
<h2 id="PDB（Program-Debug-Database）"><a href="#PDB（Program-Debug-Database）" class="headerlink" title="PDB（Program Debug Database）"></a>PDB（Program Debug Database）</h2><p>什么是PDB文件？</p>
<ol>
<li>PDB文件是在我们编译工程的时候产生的，它是和对应的模块(exe或dll)一起生成出来的。</li>
<li>每个模块编译的时候都可以生成自己的PDB文件。比如.exe/.dll/.sys等等。</li>
</ol>
<p>PDB文件对应上了位置和函数名。</p>
<p><strong>windbg如何找到PDB文件？</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SRV*D:\Symbols\XP*http://msdl.microsoft.com/download/symbols</span><br><span class="line">;上面可以在后面添加;继续添加本地地址，比如SRV*D:\Symbols\XP*http://msdl.microsoft.com/download/symbols；D:\Symbols</span><br><span class="line">;D:\Symbols\XP是本地路径，</span><br><span class="line">;http://msdl.microsoft.com/download/symbols是网络路径</span><br><span class="line">kd&gt;.reload</span><br><span class="line">;让windbg重新加载PDB</span><br></pre></td></tr></table></figure>

<p><strong>MSB8040错误</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error MSB8040: 此项目需要缓解了 Spectre 漏洞的库。</span><br></pre></td></tr></table></figure>

<p>在属性-常规-输出目录-宏中搜索14：</p>
<p><img src="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20210825204301335.png" alt="image-20210825204301335"></p>
<p>确定需要的是14.29版本</p>
<p><img src="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20210825204450485.png" alt="image-20210825204450485"></p>
<p>Visual Studio Installer的单个组件中搜索14.29，将黄标全部勾选，点击修改。问题解决！</p>
<h2 id="第一个驱动程序"><a href="#第一个驱动程序" class="headerlink" title="第一个驱动程序"></a>第一个驱动程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//卸载函数</span></span><br><span class="line"><span class="function">VOID <span class="title">DriverUnload</span><span class="params">(PDRIVER_OBJECT driver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DbgPrint(<span class="string">&quot;停止运行了\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入口函数，相当于main函数</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT pdriver, PUNICODE_STRING pReg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//驱动程序的入口</span></span><br><span class="line">	DbgPrint(<span class="string">&quot;hello world!\n&quot;</span>);</span><br><span class="line">	DbgPrint(<span class="string">&quot;pdriver:%wZ\r\n&quot;</span>,pReg);</span><br><span class="line">	DbgPrint(<span class="string">&quot;pReg:%X\r\n&quot;</span>,pdriver);</span><br><span class="line">	<span class="comment">//设置一个卸载函数，用于退出</span></span><br><span class="line">	pdriver-&gt;DriverUnload = DriverUnload;</span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20210825212547927.png" alt="image-20210825212547927"></p>
<p>windbg中可以使用dt命令查看对应数据结构的数据</p>
<h2 id="内核编程基础"><a href="#内核编程基础" class="headerlink" title="内核编程基础"></a>内核编程基础</h2><h3 id="内核API的使用"><a href="#内核API的使用" class="headerlink" title="内核API的使用"></a>内核API的使用</h3><ol>
<li>在应用层编程我们可以使用WINDOWS提供的各种API函数，只要导入头文件&lt;windows.h&gt;就可以了，但是在内核编程的时候，我们不能像Ring3那样直接使用。微软为内核提供了专门的API，只要在程序中包含相应的头文件就可以使用了，如：#include&lt;ntddk.h&gt;(假设你已经正确安装了WDK)</li>
<li>在应用层编程的时候，我们通过MSDN来了解函数的详细信息，在内核编程的时候，要使用WDK自己的帮助文档。</li>
</ol>
<h3 id="未导出函数的使用"><a href="#未导出函数的使用" class="headerlink" title="未导出函数的使用"></a>未导出函数的使用</h3><p>内核函数有三种</p>
<ol>
<li>有一些是文档有写，也导出了的函数</li>
<li>有一些是文档没写，但导出了的函数</li>
<li>还有一些是文档没写，也没导出的函数，通过自己特征码定位CALL的位置，手动调用</li>
</ol>
<p>WDK说明文档只包含了内核模块导出的函数，对于未导出的函数，则不能直接使用</p>
<p>如果要使用未导出的函数，只要自己定义一个函数指针，并且为函数指针提供正确的函数地址就可以使用了。有两种办法都可以获取为导出的函数地址：</p>
<ol>
<li>特征码搜索</li>
<li>解析内核PDB文件</li>
</ol>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>在内核编程的时候，强烈建议大家遵守WDK的编码习惯，不要这么写：unsigned long length；</p>
<p>习惯使用WDK自己的类型：</p>
<table>
<thead>
<tr>
<th>WDK的类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ULONG</td>
<td>unsigned long</td>
</tr>
<tr>
<td>PULONG</td>
<td>unsigned long*</td>
</tr>
<tr>
<td>UCHAR</td>
<td>unsigned char</td>
</tr>
<tr>
<td>PUCHAR</td>
<td>unsigned char*</td>
</tr>
<tr>
<td>UINT</td>
<td>unsigned int</td>
</tr>
<tr>
<td>PUNIT</td>
<td>unsigned int*</td>
</tr>
<tr>
<td>VOID</td>
<td>void</td>
</tr>
<tr>
<td>PVOID</td>
<td>void*</td>
</tr>
</tbody></table>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>大部分内核函数的返回值都是NTSTATUS类型，如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">PsCreateSystemThread</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">NTSTATUS <span class="title">ZwOpenProcess</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">NTSTATUS <span class="title">ZwOpenEvent</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个值能说明函数执行的结果，比如：</p>
<table>
<thead>
<tr>
<th>返回宏</th>
<th>代表数值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>STATUS_SUCCESS</td>
<td>0x00000000</td>
<td>成功</td>
</tr>
<tr>
<td>STATUS_INVALID_PARAMETER</td>
<td>0xC000000D</td>
<td>参数无效(这个错误出现往往代表出现了很多错误，因此不代表任何意义)</td>
</tr>
<tr>
<td>STATUS_BUFFER_OVERFLOW</td>
<td>0x80000005</td>
<td>缓冲区长度不够</td>
</tr>
<tr>
<td>STATUS_PENDING</td>
<td></td>
<td>不能算作一个错误，只是文件传输请求未决(异步)</td>
</tr>
<tr>
<td>STATUS_INSUFFICIENT_RESOURCES</td>
<td></td>
<td>资源调用错误</td>
</tr>
</tbody></table>
<p>当你调用的内核函数，如果返回的结果不是STATUS_SUCCESS，就说明函数执行中遇到了问题，具体是什么问题，可以在ntstatus.h文件中查看。</p>
<h3 id="内核函数中的异常处理"><a href="#内核函数中的异常处理" class="headerlink" title="内核函数中的异常处理"></a>内核函数中的异常处理</h3><p><strong>意义不大，该蓝屏还是蓝屏</strong></p>
<p>在内核中，一个小小的错误就可能导致蓝屏，比如：读写一个无效的内存地址。为了让自己的内核程序更加健壮，强烈建议大家在编写内核程序时，使用异常处。</p>
<p>Windows提供了机构化异常处理机制，一般的编译器都是支持的，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__try&#123;</span><br><span class="line">    <span class="comment">//可能出错的代码</span></span><br><span class="line">&#125;</span><br><span class="line">__except(filter_value)&#123;</span><br><span class="line">    <span class="comment">//出错时要执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>出现异常时，可根据filter_value的值来决定程序该如何执行，当filter_value的值为：</p>
<table>
<thead>
<tr>
<th>filter_value</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>EXCEPTION_EXECUTE_HANDLER(1)</td>
<td>代码进入except块</td>
</tr>
<tr>
<td>EXCEPTION_CONTINUE_SEARCH(0)</td>
<td>不处理异常，由上一层调用函数处理</td>
</tr>
<tr>
<td>EXCEPTION_CONTINUE_EXECUTION(-1)</td>
<td>回去继续执行错误处的代码(基本用不到)</td>
</tr>
</tbody></table>
<h3 id="常用的内核内存函数"><a href="#常用的内核内存函数" class="headerlink" title="常用的内核内存函数"></a>常用的内核内存函数</h3><p>对内核的使用，主要就是：申请，设置，拷贝以及释放。</p>
<table>
<thead>
<tr>
<th>C语言</th>
<th>内核中</th>
</tr>
</thead>
<tbody><tr>
<td>malloc</td>
<td>ExAllocatePool</td>
</tr>
<tr>
<td>memset(内核可用)</td>
<td>RtlFillMemory</td>
</tr>
<tr>
<td>memcpy(内核可用)</td>
<td>RtlMoveMemory</td>
</tr>
<tr>
<td>free</td>
<td>ExFreePool</td>
</tr>
</tbody></table>
<p>ExAllocatePool已被淘汰，取而代之的是<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/nf-wdm-exallocatepoolwithtag">ExAllocatePoolWithTag</a></p>
<p>后又在 Windows 10 版本 2004 中被弃用，并已被<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/nf-wdm-exallocatepool2">ExAllocatePool2</a>取代</p>
<h3 id="内核字符串种类"><a href="#内核字符串种类" class="headerlink" title="内核字符串种类"></a>内核字符串种类</h3><ul>
<li>CHAR（char）</li>
<li>WCHAR（wchar_t）</li>
<li>ANSI_STRING</li>
<li>UNICODE_STRING</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ANSI_STRING字符串：</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">STRING</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    USHORT Length;<span class="comment">//当前字符串的长度</span></span><br><span class="line">    USHORT MaximumLength;<span class="comment">//最大长度</span></span><br><span class="line">    PCHAR Buffer;<span class="comment">//指针</span></span><br><span class="line">&#125;STRING;</span><br><span class="line"></span><br><span class="line"><span class="comment">//UNICODE_STRING字符串：</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    USHORT Length;</span><br><span class="line">    USHORT MaximumLength;</span><br><span class="line">    PWCHAR Buffer;</span><br><span class="line">&#125;UNICODE_STRING;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">UNICODE_STRING abc=RTL_CONSTANT_STRING(<span class="string">L&quot;Hello World!&quot;</span>);<span class="comment">//要放在全局</span></span><br><span class="line">DbgPrint(<span class="string">&quot;%wZ&quot;</span>,&amp;abc);</span><br></pre></td></tr></table></figure>

<p>内核中字符串尽量用ANSI_STRING字符串和UNICODE_STRING字符串，通过这种方法能避免使用0结尾，读字符串的时候读Length个字符就可以了，防止访问0蓝屏。</p>
<p>内核字符串常用函数</p>
<table>
<thead>
<tr>
<th>ANSI_STRING字符串</th>
<th>UNICODE_STRING字符串</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>RtlInitAnsiString</td>
<td>RtlInitUnicodeString</td>
<td>创建字符串</td>
</tr>
<tr>
<td>RtlCopyString</td>
<td>RtlCopyUnicodeString</td>
<td>复制字符串</td>
</tr>
<tr>
<td>RtlCpmpareString</td>
<td>RtlCpmpareUnicodeString</td>
<td>比较字符串</td>
</tr>
<tr>
<td>RtlAnsiStringToUnicodeString</td>
<td>RtlUnicodeStringToAnsiString</td>
<td>字符串转换</td>
</tr>
<tr>
<td>RtlAppendStringToString</td>
<td>RtlAppendUnicodeToString/RtlAppendUnicodeStringToString</td>
<td>字符串拼接</td>
</tr>
<tr>
<td>RtlFreeAnsiString</td>
<td>RtlFreeUnicodeString</td>
<td>销毁字符串</td>
</tr>
<tr>
<td>RtlUpperString</td>
<td>RtlUpcaseUnicodeString</td>
<td>转换成大写</td>
</tr>
<tr>
<td>RtlEqualString</td>
<td>RtlEqualUnicodeString</td>
<td>字符串是否相等</td>
</tr>
</tbody></table>
<p>DbgPrint函数打印字符串：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>格式说明符</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>%c, %lc</td>
<td>ANSI字符</td>
<td>char</td>
</tr>
<tr>
<td>%C, %wc</td>
<td>宽字符</td>
<td>wchar_t</td>
</tr>
<tr>
<td>%d, %i</td>
<td>十进制有符号整数</td>
<td>int</td>
</tr>
<tr>
<td>%D</td>
<td>十进制_int64</td>
<td>_int64</td>
</tr>
<tr>
<td>%L</td>
<td>十六进制的LARGE_INTEGER</td>
<td>LARGE_INTEGER</td>
</tr>
<tr>
<td>%s, %ls</td>
<td>NULL终止的ANSI字符串</td>
<td>char*</td>
</tr>
<tr>
<td>%S, %ws</td>
<td>NULL终止的宽字符串</td>
<td>wchar_t*</td>
</tr>
<tr>
<td>%Z</td>
<td>ANSI_STRING字符串</td>
<td></td>
</tr>
<tr>
<td>%wZ</td>
<td>UNICODE_STRING字符串</td>
<td></td>
</tr>
<tr>
<td>%u</td>
<td>十进制的ULONG</td>
<td>ULONG</td>
</tr>
<tr>
<td>%x</td>
<td>小写字符十六进制的ULONG</td>
<td>ULONG</td>
</tr>
<tr>
<td>%X</td>
<td>大写字符十六进制的ULONG</td>
<td>ULONG</td>
</tr>
<tr>
<td>%p</td>
<td>指针Pointer 32/64位</td>
<td></td>
</tr>
</tbody></table>
<p>根据DDK上说明,Unicode格式(%C, %S, %lc, %ls, %wc, %ws, and %wZ)只能在 IRQL = PASSIVE_LEVEL时才能使用.</p>
<h3 id="常用的其他内核API函数"><a href="#常用的其他内核API函数" class="headerlink" title="常用的其他内核API函数"></a>常用的其他内核API函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ExAcquireFastMutex</td>
<td>获取一个快速互斥体，用于多线程环境下的同步</td>
</tr>
<tr>
<td>ExReleaseFastMutex</td>
<td>快速释放一个互斥体</td>
</tr>
<tr>
<td>ExRaiseStatus</td>
<td>抛出一个异常，带有一个status值的，代码很深的地方直接报错</td>
</tr>
<tr>
<td>ZwCreateFile</td>
<td>创建文件</td>
</tr>
<tr>
<td>ZwWriteFile</td>
<td>写入文件</td>
</tr>
<tr>
<td>ZwReadFile</td>
<td>读取文件</td>
</tr>
<tr>
<td>ZwQueryDirctory</td>
<td>查询目录文件</td>
</tr>
<tr>
<td>ZwDeviceIoControlFile</td>
<td>创建设备io文件</td>
</tr>
<tr>
<td>ZwCreateKey</td>
<td>创建注册表的键</td>
</tr>
<tr>
<td>ZwQueryValueKey</td>
<td>创建注册表的键值</td>
</tr>
<tr>
<td>IoCreateFile</td>
<td>创建文件，比ZwCreateFile更加底层</td>
</tr>
<tr>
<td>IoCreateDevice</td>
<td>创建设备</td>
</tr>
<tr>
<td>IoCallDriver</td>
<td>发送一个请求，实际上这个函数可能是由IofCallDriver别名</td>
</tr>
<tr>
<td>IoCompleteRequest</td>
<td>完成请求</td>
</tr>
<tr>
<td>IoCopyCurrentIrpStackLocationToNext</td>
<td>将当前IRP请求的栈空间拷贝到下一个栈空间</td>
</tr>
<tr>
<td>IoSkipCurrentIrpStackLocationToNext</td>
<td>跳过当前IRP栈空间</td>
</tr>
<tr>
<td>IoGetCurrentIrpStackLocation</td>
<td>获得当前IRP栈空间指针</td>
</tr>
</tbody></table>
<h3 id="IRQL中断请求级别"><a href="#IRQL中断请求级别" class="headerlink" title="IRQL中断请求级别"></a>IRQL中断请求级别</h3><p>处理器在一个IRQL上执行线程代码。IRQL是帮助决定线程如何被中断的。<strong>在同一处理器上，线程只能被更高级别IRQL的线程能中断</strong>。每个处理器都有自己的中断IRQL。我们经常遇见的有四种IRQL级别。“Passive”, “APC”, “Dispatch” and “DIRQL”.</p>
<p>“DriverEntry”将会在PASSIVE_LEVEL被调用。</p>
<p><img src="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20211109133128464.png" alt="image-20211109133128464"></p>
<ul>
<li><p><strong>PASSIVE_LEVEL</strong></p>
<p>IRQL最低级别,没有被屏蔽的中断，在这个级别上，线程执行用户模式，可以访问分页内存。</p>
</li>
<li><p><strong>APC_LEVEL</strong></p>
<p>在这个级别上,只有APC级别的中断被屏蔽，可以访问分页内存。当有APC发生时，处理器提升到APC级别，这样，就屏蔽掉其它APC，为了和APC执行 一些同步，驱动程序可以手动提升到这个级别。比如，如果提升到这个级别，APC就不能调用。在这个级别，APC被禁止了，导致禁止一些I/O完成APC， 所以有一些API不能调用。</p>
<p><strong>阻止响应任何APC，而且线程不能被挂起（suspend），为什么不能被挂起？因为操作系统实现线程挂起的方式，就是递交 APC</strong></p>
</li>
<li><p><strong>DISPATCH_LEVEL</strong></p>
<p>这个级别，DPC(延迟过程) 和更低的中断被屏蔽，不能访问分页内存，所有的被访问的内存不能分页。因为只能处理分页内存，所以在这个级别，能够访问的Api大大减少。</p>
</li>
<li><p><strong>DIRQL (Device IRQL)</strong></p>
<p>通常处于高层次的驱动程序不会使用这个IRQL等级，在这个等级上所有的中断都会被忽略。这是IRQL的最高等级。通常使用这个来判断设备的优先级。<br>一般的，更高级的驱动在这个级别上不处理IRQL，但是几乎所有的中断被屏蔽，这实际上是IRQL的一个范围，这是一个决定某个驱动有更高的优先级的方法。</p>
</li>
</ul>
<h3 id="驱动内核框架"><a href="#驱动内核框架" class="headerlink" title="驱动内核框架"></a>驱动内核框架</h3><h4 id="Windows的驱动开发模型变迁"><a href="#Windows的驱动开发模型变迁" class="headerlink" title="Windows的驱动开发模型变迁"></a>Windows的驱动开发模型变迁</h4><ul>
<li>vxd(windows98)</li>
<li>kdm(windows98~windows2000)</li>
<li>wdm(再之后)</li>
<li>wdf(进一步原有基础上封装了一套更简单的API，现在)</li>
</ul>
<h4 id="内核编程的主要调用源："><a href="#内核编程的主要调用源：" class="headerlink" title="内核编程的主要调用源："></a>内核编程的主要调用源：</h4><ol>
<li>入口函数 DriverEntry 和 卸载函数 DriverUnload（单线程环境）</li>
<li>各种分发函数（多线程环境，可以和DriverUnload并发，无法和DriverEntry并发）</li>
<li>处理请求时设置的完成函数（多线程环境）</li>
<li>其他回调函数  ndis（网络相关）（多线程环境）</li>
</ol>
<h4 id="函数的多线程安全性"><a href="#函数的多线程安全性" class="headerlink" title="函数的多线程安全性"></a>函数的多线程安全性</h4><ol>
<li>可能运行于多线程环境的函数，必须是多线程安全的，只运行于单线程环境的函数，则不需要多线程安全性</li>
<li>如果函数A的所有调用源只运行于同一单线程环境，则函数A也是只运行在单线程环境下。</li>
<li>如果函数A的其中一个调用源是可能运行在多线程环境下的，或者多个调用源可能运行于不同的可并发的多线程环境，而且调用路径上没有采取多线程序列化成单线程的强制措施，则函数A也是可能运行在多线程环境的。</li>
<li>如果函数A所有可能运行于多线程环境的调用路径上，都有多线程序列化成单线程的强制措施，则函数A是运行于单线程环境的。</li>
<li>只使用函数内部资源的，完全不使用全局变量，静态变量或其他全局性资源的函数是多线程安全的。</li>
<li>如果对某个全局变量或者静态变量的所有访问都被强制的同步手段限制为同一时刻只有一个线程访问，则即使使用了这些全局变量或静态变量，对函数的多线程安全性也是没有影响的。</li>
</ol>
<table>
<thead>
<tr>
<th>调用源</th>
<th>运行环境</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td>DriverEntry/DriverUnload</td>
<td>单线程</td>
<td>这两个函数由系统集成的单一线程调用。不会出现多线程同时调用的情况</td>
</tr>
<tr>
<td>各种分发函数</td>
<td>多线程</td>
<td>没有任何文档保证分发函数是不会被多线程同时调用的。此外，分发函数是不会和DriverEntry并发，但可能和DriverUnload并发</td>
</tr>
<tr>
<td>完成函数</td>
<td>多线程</td>
<td>完成函数随时可能被未知的线程调用</td>
</tr>
<tr>
<td>各种NDIS回调函数</td>
<td>多线程</td>
<td>同上</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="代码的中断级"><a href="#代码的中断级" class="headerlink" title="代码的中断级"></a>代码的中断级</h4><p>win32编程是没有中断级这个概念的，但是在内核编程中是有中断级的概念的，我们的程序好像是并发的，但其实是有优先级的，就是中断级</p>
<ul>
<li>passive</li>
<li>dispatch</li>
</ul>
<p>规则：</p>
<ol>
<li>如果在调用路径上没有特殊情况（导致中断级的提高或降低），则一个函数执行时的中断和它的调用源的中断级相同</li>
<li>如果在调用路径上有获取自旋锁，则中断级随之升高；如果调用路径上有释放自旋锁，则中断级随之下降。</li>
</ol>
<table>
<thead>
<tr>
<th>调用源</th>
<th>一般运行中断级</th>
</tr>
</thead>
<tbody><tr>
<td>DriverUnload/DriverEntry</td>
<td>Passive级</td>
</tr>
<tr>
<td>各种分发函数</td>
<td>Passive级</td>
</tr>
<tr>
<td>完成函数</td>
<td>Dispatch级</td>
</tr>
<tr>
<td>各种NDIS回调函数</td>
<td>Dispatch级</td>
</tr>
</tbody></table>
<h4 id="WDK中出现的特殊代码"><a href="#WDK中出现的特殊代码" class="headerlink" title="WDK中出现的特殊代码"></a>WDK中出现的特殊代码</h4><h5 id="IN和OUT"><a href="#IN和OUT" class="headerlink" title="IN和OUT"></a>IN和OUT</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OUT</span></span><br></pre></td></tr></table></figure>

<p>空定义，只是作为提示函数中参数时输入还是输出的</p>
<h5 id="pragma-alloc-text"><a href="#pragma-alloc-text" class="headerlink" title="#pragma alloc_text"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/analogous_love/article/details/47274559">#pragma alloc_text</a></h5><p>有时，驱动程序的某些部分必须驻留内存而另一些可以被分页，这就需要一种能控制代码和数据是否分页的方法。通过指导编译器的段分配可以实现这个目的。</p>
<p>#pragma alloc_text：<strong>把驱动程序的单独例程放到特定段中。</strong></p>
<p>使编译器把代码放到特定段的传统方法是使用alloc_text编译指示。但不是每种编译器都支持这个编译指示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> alloc_text(PAGE, a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> alloc_text(PAGE, b)</span></span><br><span class="line"><span class="comment">//表示函数a和b都运行在分页内存中，就是有可能被交换到分页池中，程序中一些高等级，例如dispatch 级别的代码当然不能运行在分页内存，这样往往出现BSOD</span></span><br><span class="line"><span class="comment">//如果没有上述指令，则默认位于PAGELK这个节，即不会把内存放入硬盘。</span></span><br></pre></td></tr></table></figure>

<p><strong>#pragma alloc_text使用注意</strong></p>
<ol>
<li>该编译指示必须跟在函数声明后面而不能在前面。你可以把驱动程序中的所有函数集中到一个头文件中，并在包含该头文件的源文件中，在#include语句的后面使用alloc_text。</li>
<li>该编译指示仅能用于有C连接形式的函数。即，它不能用于类成员函数或 C++源文件中未用extern “C”声明的函数。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> alloc_text(INIT,DriverEntry)<span class="comment">//某些代码在驱动程序完成初始化后不再需要，可以直接把它插入到INIT段。</span></span></span><br></pre></td></tr></table></figure>









<h2 id="内核空间与内核模块"><a href="#内核空间与内核模块" class="headerlink" title="内核空间与内核模块"></a>内核空间与内核模块</h2><h3 id="内核空间"><a href="#内核空间" class="headerlink" title="内核空间"></a>内核空间</h3><p><img src="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20210826200052881.png" alt="image-20210826200041917"></p>
<p><strong>内核空间中的地址在各个进程中都是一样的。</strong></p>
<p>内核模块定义全局变量：可在不同进程中查看</p>
<p><strong>windbg进入对应进程的进程空间</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kd&gt;!process <span class="number">0</span> <span class="number">0</span><span class="comment">//罗列出来的进程信息枚举，将PROCESS后接的地址放入下面的命令</span></span><br><span class="line">kd&gt;.<span class="function">process <span class="title">XXXXXXXX</span><span class="params">(上面获取到的地址)</span></span></span><br><span class="line"><span class="function"><span class="comment">//转到了对应进程的内存空间</span></span></span><br></pre></td></tr></table></figure>

<h3 id="内核模块"><a href="#内核模块" class="headerlink" title="内核模块"></a>内核模块</h3><p><img src="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20210826200052881.png" alt="image-20210826200052881"></p>
<ol>
<li>硬件种类繁多，不可能做一个兼容所有硬件的内核，所以，微软提供规定的接口格式，让硬件驱动人员按照规定的格式编写“驱动程序”。</li>
<li>这些驱动程序每一个都是一个模块，称为“内核模块”，都可以加载到内核中，<strong>都遵守PE结构</strong>。本质上讲，任意一个.sys文件与内核文件没有区别。</li>
</ol>
<h4 id="DRIVER-OBJECT结构体"><a href="#DRIVER-OBJECT结构体" class="headerlink" title="DRIVER_OBJECT结构体"></a>DRIVER_OBJECT结构体</h4><p>定义在wdm.h中。</p>
<p>每个内核模块都有一个对应的结构体，来描述这个模块在内核中的各种信息：位置、大小、名称等等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _DRIVER_OBJECT</span><br><span class="line">nt!_DRIVER_OBJECT</span><br><span class="line">   +<span class="number">0x000</span> Type             : Int2B<span class="comment">//类型</span></span><br><span class="line">   +<span class="number">0x002</span> Size             : Int2B<span class="comment">//大小</span></span><br><span class="line">   +<span class="number">0x004</span> DeviceObject     : Ptr32 _DEVICE_OBJECT<span class="comment">//设备对象，这里实际上是一个设备对象的链表的开始。因为DeviceObject中有相关链表信息</span></span><br><span class="line">   +<span class="number">0x008</span> Flags            : Uint4B</span><br><span class="line">   +<span class="number">0x00c</span> DriverStart      : Ptr32 Void<span class="comment">//驱动被加载到什么地方了，即内核模块的起始地址</span></span><br><span class="line">   +<span class="number">0x010</span> DriverSize       : Uint4B<span class="comment">//该驱动内核模块的大小</span></span><br><span class="line">   +<span class="number">0x014</span> DriverSection    : Ptr32 Void<span class="comment">//指向当前驱动的_LDR_DATA_TABLE_ENTRY结构体的指针</span></span><br><span class="line">   +<span class="number">0x018</span> DriverExtension  : Ptr32 _DRIVER_EXTENSION<span class="comment">//热拔插会用到的相关信息</span></span><br><span class="line">   +<span class="number">0x01c</span> DriverName       : _UNICODE_STRING<span class="comment">//驱动的名字</span></span><br><span class="line">   +<span class="number">0x024</span> HardwareDatabase : Ptr32 _UNICODE_STRING<span class="comment">//注册表</span></span><br><span class="line">   +<span class="number">0x028</span> FastIoDispatch   : Ptr32 _FAST_IO_DISPATCH<span class="comment">//某派遣函数，快速IO分发函数</span></span><br><span class="line">   +<span class="number">0x02c</span> DriverInit       : Ptr32     <span class="keyword">long</span> <span class="comment">//初始化派遣函数</span></span><br><span class="line">   +<span class="number">0x030</span> DriverStartIo    : Ptr32     <span class="keyword">void</span> <span class="comment">//某派遣函数</span></span><br><span class="line">   +<span class="number">0x034</span> DriverUnload     : Ptr32     <span class="keyword">void</span> <span class="comment">//驱动卸载派遣函数</span></span><br><span class="line">   +<span class="number">0x038</span> MajorFunction    : [<span class="number">28</span>] Ptr32     <span class="keyword">long</span> <span class="comment">//包含28个派遣函数地址</span></span><br><span class="line">       <span class="comment">//0编号的IRP对应的派遣函数的地址就存在MajorFunction[0]的位置。</span></span><br><span class="line"><span class="comment">////////////////////////////////_DRIVER_EXTENSION///////////////////////////</span></span><br><span class="line">ntdll!_DRIVER_EXTENSION<span class="comment">//热拔插驱动相关的</span></span><br><span class="line">   +<span class="number">0x000</span> DriverObject     : Ptr32 _DRIVER_OBJECT</span><br><span class="line">   +<span class="number">0x004</span> AddDevice        : Ptr32     <span class="keyword">long</span> </span><br><span class="line">   +<span class="number">0x008</span> Count            : Uint4B</span><br><span class="line">   +<span class="number">0x00c</span> ServiceKeyName   : _UNICODE_STRING</span><br><span class="line">   +<span class="number">0x014</span> ClientDriverExtension : Ptr32 _IO_CLIENT_EXTENSION</span><br><span class="line">   +<span class="number">0x018</span> FsFilterCallbacks : Ptr32 _FS_FILTER_CALLBACKS</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20210828154104796.png" alt="image-20210828154104796"></p>
<p><img src="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20210828154124934.png" alt="image-20210828154124934"></p>
<p>Type，Flags，MajorFunction等等，因为他们是固有特征，尽可能隐藏特征，因为内核文件已经加载到内存里了，所以即使修改了，也不影响正常运行。</p>
<h4 id="LDR-DATA-TABLE-ENTRY结构体"><a href="#LDR-DATA-TABLE-ENTRY结构体" class="headerlink" title="_LDR_DATA_TABLE_ENTRY结构体"></a>_LDR_DATA_TABLE_ENTRY结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//所有内核模块的双向链表</span></span><br><span class="line">kd&gt; dt _LDR_DATA_TABLE_ENTRY</span><br><span class="line">nt!_LDR_DATA_TABLE_ENTRY</span><br><span class="line">   +<span class="number">0x000</span> InLoadOrderLinks : _LIST_ENTRY<span class="comment">//初始化顺序双向链表</span></span><br><span class="line">   +<span class="number">0x008</span> InMemoryOrderLinks : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x010</span> InInitializationOrderLinks : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x018</span> DllBase          : Ptr32 Void<span class="comment">//内核模块的起始地址</span></span><br><span class="line">   +<span class="number">0x01c</span> EntryPoint       : Ptr32 Void</span><br><span class="line">   +<span class="number">0x020</span> SizeOfImage      : Uint4B<span class="comment">//内核模块的大小</span></span><br><span class="line">   +<span class="number">0x024</span> FullDllName      : _UNICODE_STRING<span class="comment">//完整的内核模块名，实际上就是全路径</span></span><br><span class="line">   +<span class="number">0x02c</span> BaseDllName      : _UNICODE_STRING<span class="comment">//只有内核模块名，如：xxx.sys</span></span><br><span class="line">   +<span class="number">0x034</span> Flags            : Uint4B</span><br><span class="line">   +<span class="number">0x038</span> LoadCount        : Uint2B</span><br><span class="line">   +<span class="number">0x03a</span> TlsIndex         : Uint2B</span><br><span class="line">   +<span class="number">0x03c</span> HashLinks        : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x03c</span> SectionPointer   : Ptr32 Void</span><br><span class="line">   +<span class="number">0x040</span> CheckSum         : Uint4B<span class="comment">//校验和</span></span><br><span class="line">   +<span class="number">0x044</span> TimeDateStamp    : Uint4B</span><br><span class="line">   +<span class="number">0x044</span> LoadedImports    : Ptr32 Void</span><br><span class="line">   +<span class="number">0x048</span> EntryPointActivationContext : Ptr32 Void</span><br><span class="line">   +<span class="number">0x04c</span> PatchInformation : Ptr32 Void</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20210828154334924.png" alt="image-20210828154334924"></p>
<p>_DRIVER_OBJECT结构可以通过DriverSection找到记录所有内核模块简单信息的双向链表，但双向链表没法找回_DRIVER_OBJECT结构。因此即使是在双向链表中将目标驱动断链了，对于pchunter也依然能找到内核对象，原因是因为pchunter是通过特征码直接索引到_DRIVER_OBJECT结构来遍历所有内核模块，而非通过该双向链表</p>
<h3 id="遍历内核模块作业"><a href="#遍历内核模块作业" class="headerlink" title="遍历内核模块作业"></a>遍历内核模块作业</h3><p><strong>驱动对象遍历，模块隐藏（断链）</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> OldDriverSection= <span class="number">0</span>;<span class="comment">//保存原DriverSection</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//卸载函数</span></span><br><span class="line"><span class="function">VOID <span class="title">DriverUnload</span><span class="params">(PDRIVER_OBJECT driver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//恢复原链和原DriverSection</span></span><br><span class="line">	<span class="keyword">if</span> (OldDriverSection != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//恢复原DriverSection</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> DriverSectionAddr = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)driver + <span class="number">0x014</span>;</span><br><span class="line">		*(<span class="keyword">unsigned</span> <span class="keyword">int</span>*)DriverSectionAddr = OldDriverSection;</span><br><span class="line">		<span class="comment">//恢复原链</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> currentIndex = *(<span class="keyword">unsigned</span> <span class="keyword">int</span>*)DriverSectionAddr;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> lastIndex = *(<span class="keyword">unsigned</span> <span class="keyword">int</span>*)(currentIndex + <span class="number">0x4</span>);</span><br><span class="line">		*(<span class="keyword">unsigned</span> <span class="keyword">int</span>*)lastIndex = currentIndex;</span><br><span class="line">		*(<span class="keyword">unsigned</span> <span class="keyword">int</span>*)(*(<span class="keyword">unsigned</span> <span class="keyword">int</span>*)(currentIndex)+<span class="number">0x4</span>) = currentIndex;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	DbgPrint(<span class="string">&quot;停止运行了\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内核对象链表遍历</span></span><br><span class="line"><span class="function">VOID <span class="title">forEachDriverChain</span><span class="params">(PDRIVER_OBJECT pdriver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> DriverSection = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)pdriver + <span class="number">0x014</span>;</span><br><span class="line">	<span class="comment">//DbgPrint(&quot;DriverSection:%X\n&quot;, DriverSection);</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> beginIndex = *(<span class="keyword">unsigned</span> <span class="keyword">int</span>*)DriverSection;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> currentIndex = beginIndex;</span><br><span class="line">	DbgPrint(<span class="string">&quot;----------------------------------------\r\n&quot;</span>);</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		PUNICODE_STRING BaseDllName = (PUNICODE_STRING)(currentIndex + <span class="number">0x02c</span>);</span><br><span class="line">		DbgPrint(<span class="string">&quot;%wZ\r\n&quot;</span>, BaseDllName);</span><br><span class="line">		currentIndex=*(<span class="keyword">unsigned</span> <span class="keyword">int</span>*)currentIndex;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">while</span> (currentIndex != beginIndex);</span><br><span class="line">	DbgPrint(<span class="string">&quot;----------------------------------------\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//内核对象链表断链</span></span><br><span class="line"><span class="function">VOID <span class="title">BreakDriverChain</span><span class="params">(PDRIVER_OBJECT pdriver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> DriverSectionAddr = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)pdriver + <span class="number">0x014</span>;</span><br><span class="line">	<span class="comment">//DbgPrint(&quot;DriverSection:%X\n&quot;, DriverSection);</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> currentIndex = *(<span class="keyword">unsigned</span> <span class="keyword">int</span>*)DriverSectionAddr;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> lastIndex = *(<span class="keyword">unsigned</span> <span class="keyword">int</span>*)(currentIndex +<span class="number">0x4</span>);</span><br><span class="line">	*(<span class="keyword">unsigned</span> <span class="keyword">int</span>*)lastIndex = *(<span class="keyword">unsigned</span> <span class="keyword">int</span>*)(currentIndex);</span><br><span class="line">	*(<span class="keyword">unsigned</span> <span class="keyword">int</span>*)(*(<span class="keyword">unsigned</span> <span class="keyword">int</span>*)(currentIndex)+<span class="number">0x4</span>) = lastIndex;</span><br><span class="line">	<span class="comment">//修正原PDRIVER_OBJECT中的DriverSection指向前一个链表</span></span><br><span class="line">	OldDriverSection = *(<span class="keyword">unsigned</span> <span class="keyword">int</span>*)DriverSectionAddr;</span><br><span class="line">	*(<span class="keyword">unsigned</span> <span class="keyword">int</span>*)DriverSectionAddr = lastIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入口函数，相当于main函数</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT pdriver, PUNICODE_STRING pReg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//驱动程序的入口</span></span><br><span class="line">	DbgPrint(<span class="string">&quot;hello world!\n&quot;</span>);</span><br><span class="line">	DbgPrint(<span class="string">&quot;pdriver:%wZ\r\n&quot;</span>,pReg);</span><br><span class="line">	DbgPrint(<span class="string">&quot;pReg:%p\r\n&quot;</span>,pdriver);</span><br><span class="line">	DbgPrint(<span class="string">&quot;hello world!\n&quot;</span>);</span><br><span class="line">	DbgPrint(<span class="string">&quot;===============断链前==============\n&quot;</span>);</span><br><span class="line">	forEachDriverChain(pdriver);</span><br><span class="line">	BreakDriverChain(pdriver);</span><br><span class="line">	DbgPrint(<span class="string">&quot;===============断链后==============\n&quot;</span>);</span><br><span class="line">	forEachDriverChain(pdriver);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置一个卸载函数，用于退出</span></span><br><span class="line">	pdriver-&gt;DriverUnload = DriverUnload;</span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br></pre></td><td class="code"><pre><span class="line">hello world!</span><br><span class="line">pdriver:\REGISTRY\MACHINE\SYSTEM\ControlSet002\Services\HelloWorld</span><br><span class="line">pReg:<span class="number">81</span>DDCD18</span><br><span class="line">hello world!</span><br><span class="line">===============断链前==============</span><br><span class="line">----------------------------------------</span><br><span class="line">HelloWorld.sys</span><br><span class="line">(null)</span><br><span class="line">ntoskrnl.exe</span><br><span class="line">hal.dll</span><br><span class="line">kdcom.dll</span><br><span class="line">BOOTVID.dll</span><br><span class="line">ACPI.sys</span><br><span class="line">WMILIB.SYS</span><br><span class="line">pci.sys</span><br><span class="line">isapnp.sys</span><br><span class="line">compbatt.sys</span><br><span class="line">BATTC.SYS</span><br><span class="line">intelide.sys</span><br><span class="line">PCIIDEX.SYS</span><br><span class="line">MountMgr.sys</span><br><span class="line">ftdisk.sys</span><br><span class="line">dmload.sys</span><br><span class="line">dmio.sys</span><br><span class="line">PartMgr.sys</span><br><span class="line">vmci.sys</span><br><span class="line">VolSnap.sys</span><br><span class="line">vsock.sys</span><br><span class="line">atapi.sys</span><br><span class="line">disk.sys</span><br><span class="line">CLASSPNP.SYS</span><br><span class="line">fltMgr.sys</span><br><span class="line">sr.sys</span><br><span class="line">KSecDD.sys</span><br><span class="line">Ntfs.sys</span><br><span class="line">NDIS.sys</span><br><span class="line">Mup.sys</span><br><span class="line">agp440.sys</span><br><span class="line">i8042prt.sys</span><br><span class="line">kbdclass.sys</span><br><span class="line">vmmouse.sys</span><br><span class="line">mouclass.sys</span><br><span class="line">serial.sys</span><br><span class="line">serenum.sys</span><br><span class="line">imapi.sys</span><br><span class="line">cdrom.sys</span><br><span class="line">redbook.sys</span><br><span class="line">ks.sys</span><br><span class="line">vmx_svga.sys</span><br><span class="line">VIDEOPRT.SYS</span><br><span class="line">usbuhci.sys</span><br><span class="line">USBPORT.SYS</span><br><span class="line">vmxnet.sys</span><br><span class="line">es1371mp.sys</span><br><span class="line">portcls.sys</span><br><span class="line">drmk.sys</span><br><span class="line">usbehci.sys</span><br><span class="line">CmBatt.sys</span><br><span class="line">intelppm.sys</span><br><span class="line">fsvga.sys</span><br><span class="line">audstub.sys</span><br><span class="line">rasl2tp.sys</span><br><span class="line">ndistapi.sys</span><br><span class="line">ndiswan.sys</span><br><span class="line">raspppoe.sys</span><br><span class="line">raspptp.sys</span><br><span class="line">TDI.SYS</span><br><span class="line">psched.sys</span><br><span class="line">msgpc.sys</span><br><span class="line">ptilink.sys</span><br><span class="line">raspti.sys</span><br><span class="line">rdpdr.sys</span><br><span class="line">termdd.sys</span><br><span class="line">swenum.sys</span><br><span class="line">update.sys</span><br><span class="line">mssmbios.sys</span><br><span class="line">NDProxy.SYS</span><br><span class="line">usbhub.sys</span><br><span class="line">USBD.SYS</span><br><span class="line">gameenum.sys</span><br><span class="line">Fs_Rec.SYS</span><br><span class="line">Null.SYS</span><br><span class="line">Beep.SYS</span><br><span class="line">vga.sys</span><br><span class="line">mnmdd.SYS</span><br><span class="line">RDPCDD.sys</span><br><span class="line">Msfs.SYS</span><br><span class="line">Npfs.SYS</span><br><span class="line">rasacd.sys</span><br><span class="line">ipsec.sys</span><br><span class="line">tcpip.sys</span><br><span class="line">netbt.sys</span><br><span class="line">ws2ifsl.sys</span><br><span class="line">afd.sys</span><br><span class="line">netbios.sys</span><br><span class="line">vmhgfs.sys</span><br><span class="line">rdbss.sys</span><br><span class="line">mrxsmb.sys</span><br><span class="line">Fips.SYS</span><br><span class="line">ipnat.sys</span><br><span class="line">Cdfs.SYS</span><br><span class="line">wanarp.sys</span><br><span class="line">usbccgp.sys</span><br><span class="line">hidusb.sys</span><br><span class="line">HIDCLASS.SYS</span><br><span class="line">HIDPARSE.SYS</span><br><span class="line">BTHUSB.sys</span><br><span class="line">bthport.sys</span><br><span class="line">mouhid.sys</span><br><span class="line">vmusbmouse.sys</span><br><span class="line">dump_atapi.sys</span><br><span class="line">dump_WMILIB.SYS</span><br><span class="line">win32k.sys</span><br><span class="line">Dxapi.sys</span><br><span class="line">watchdog.sys</span><br><span class="line">dxg.sys</span><br><span class="line">dxgthk.sys</span><br><span class="line">vmx_fb.dll</span><br><span class="line">rfcomm.sys</span><br><span class="line">BthEnum.sys</span><br><span class="line">bthpan.sys</span><br><span class="line">ndisuio.sys</span><br><span class="line">wdmaud.sys</span><br><span class="line">sysaudio.sys</span><br><span class="line">mrxdav.sys</span><br><span class="line">vmmemctl.sys</span><br><span class="line">srv.sys</span><br><span class="line">HTTP.sys</span><br><span class="line">Dbgv.sys</span><br><span class="line">----------------------------------------</span><br><span class="line">===============断链后==============</span><br><span class="line">----------------------------------------</span><br><span class="line">Dbgv.sys</span><br><span class="line">(null)</span><br><span class="line">ntoskrnl.exe</span><br><span class="line">hal.dll</span><br><span class="line">kdcom.dll</span><br><span class="line">BOOTVID.dll</span><br><span class="line">ACPI.sys</span><br><span class="line">WMILIB.SYS</span><br><span class="line">pci.sys</span><br><span class="line">isapnp.sys</span><br><span class="line">compbatt.sys</span><br><span class="line">BATTC.SYS</span><br><span class="line">intelide.sys</span><br><span class="line">PCIIDEX.SYS</span><br><span class="line">MountMgr.sys</span><br><span class="line">ftdisk.sys</span><br><span class="line">dmload.sys</span><br><span class="line">dmio.sys</span><br><span class="line">PartMgr.sys</span><br><span class="line">vmci.sys</span><br><span class="line">VolSnap.sys</span><br><span class="line">vsock.sys</span><br><span class="line">atapi.sys</span><br><span class="line">disk.sys</span><br><span class="line">CLASSPNP.SYS</span><br><span class="line">fltMgr.sys</span><br><span class="line">sr.sys</span><br><span class="line">KSecDD.sys</span><br><span class="line">Ntfs.sys</span><br><span class="line">NDIS.sys</span><br><span class="line">Mup.sys</span><br><span class="line">agp440.sys</span><br><span class="line">i8042prt.sys</span><br><span class="line">kbdclass.sys</span><br><span class="line">vmmouse.sys</span><br><span class="line">mouclass.sys</span><br><span class="line">serial.sys</span><br><span class="line">serenum.sys</span><br><span class="line">imapi.sys</span><br><span class="line">cdrom.sys</span><br><span class="line">redbook.sys</span><br><span class="line">ks.sys</span><br><span class="line">vmx_svga.sys</span><br><span class="line">VIDEOPRT.SYS</span><br><span class="line">usbuhci.sys</span><br><span class="line">USBPORT.SYS</span><br><span class="line">vmxnet.sys</span><br><span class="line">es1371mp.sys</span><br><span class="line">portcls.sys</span><br><span class="line">drmk.sys</span><br><span class="line">usbehci.sys</span><br><span class="line">CmBatt.sys</span><br><span class="line">intelppm.sys</span><br><span class="line">fsvga.sys</span><br><span class="line">audstub.sys</span><br><span class="line">rasl2tp.sys</span><br><span class="line">ndistapi.sys</span><br><span class="line">ndiswan.sys</span><br><span class="line">raspppoe.sys</span><br><span class="line">raspptp.sys</span><br><span class="line">TDI.SYS</span><br><span class="line">psched.sys</span><br><span class="line">msgpc.sys</span><br><span class="line">ptilink.sys</span><br><span class="line">raspti.sys</span><br><span class="line">rdpdr.sys</span><br><span class="line">termdd.sys</span><br><span class="line">swenum.sys</span><br><span class="line">update.sys</span><br><span class="line">mssmbios.sys</span><br><span class="line">NDProxy.SYS</span><br><span class="line">usbhub.sys</span><br><span class="line">USBD.SYS</span><br><span class="line">gameenum.sys</span><br><span class="line">Fs_Rec.SYS</span><br><span class="line">Null.SYS</span><br><span class="line">Beep.SYS</span><br><span class="line">vga.sys</span><br><span class="line">mnmdd.SYS</span><br><span class="line">RDPCDD.sys</span><br><span class="line">Msfs.SYS</span><br><span class="line">Npfs.SYS</span><br><span class="line">rasacd.sys</span><br><span class="line">ipsec.sys</span><br><span class="line">tcpip.sys</span><br><span class="line">netbt.sys</span><br><span class="line">ws2ifsl.sys</span><br><span class="line">afd.sys</span><br><span class="line">netbios.sys</span><br><span class="line">vmhgfs.sys</span><br><span class="line">rdbss.sys</span><br><span class="line">mrxsmb.sys</span><br><span class="line">Fips.SYS</span><br><span class="line">ipnat.sys</span><br><span class="line">Cdfs.SYS</span><br><span class="line">wanarp.sys</span><br><span class="line">usbccgp.sys</span><br><span class="line">hidusb.sys</span><br><span class="line">HIDCLASS.SYS</span><br><span class="line">HIDPARSE.SYS</span><br><span class="line">BTHUSB.sys</span><br><span class="line">bthport.sys</span><br><span class="line">mouhid.sys</span><br><span class="line">vmusbmouse.sys</span><br><span class="line">dump_atapi.sys</span><br><span class="line">dump_WMILIB.SYS</span><br><span class="line">win32k.sys</span><br><span class="line">Dxapi.sys</span><br><span class="line">watchdog.sys</span><br><span class="line">dxg.sys</span><br><span class="line">dxgthk.sys</span><br><span class="line">vmx_fb.dll</span><br><span class="line">rfcomm.sys</span><br><span class="line">BthEnum.sys</span><br><span class="line">bthpan.sys</span><br><span class="line">ndisuio.sys</span><br><span class="line">wdmaud.sys</span><br><span class="line">sysaudio.sys</span><br><span class="line">mrxdav.sys</span><br><span class="line">vmmemctl.sys</span><br><span class="line">srv.sys</span><br><span class="line">HTTP.sys</span><br><span class="line">----------------------------------------</span><br><span class="line">停止运行了</span><br></pre></td></tr></table></figure>

<p>由上面打印可知HelloWorld.sys成功被隐藏，但pchunter依然可以查找到我们的驱动</p>
<p><strong>真隐藏（pchunter无法找到）</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LDR_DATA_TABLE_ENTRY</span> &#123;</span></span><br><span class="line">	LIST_ENTRY InLoadOrderLinks;</span><br><span class="line">	LIST_ENTRY InMemoryOrderLinks;</span><br><span class="line">	LIST_ENTRY InInitializationOrderLinks;</span><br><span class="line">	PVOID DllBase;</span><br><span class="line">	PVOID EntryPoint;</span><br><span class="line">	ULONG SizeOfImage;</span><br><span class="line">	UNICODE_STRING FullDllName;</span><br><span class="line">	UNICODE_STRING BaseDllName;</span><br><span class="line">	ULONG Flags;</span><br><span class="line">	USHORT LoadCount;</span><br><span class="line">	USHORT TlsIndex;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		LIST_ENTRY HashLinks;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			PVOID SectionPointer;</span><br><span class="line">			ULONG CheckSum;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			ULONG TimeDateStamp;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			PVOID LoadedImports;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">ACTIVATION_CONTEXT</span> * <span class="title">EntryPointActivationContext</span>;</span></span><br><span class="line"></span><br><span class="line">	PVOID PatchInformation;</span><br><span class="line"></span><br><span class="line">&#125; LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;</span><br><span class="line"></span><br><span class="line">HANDLE hThread;</span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">DriverUnload</span><span class="params">(PDRIVER_OBJECT pDriver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	KdPrint((<span class="string">&quot;卸载的了&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">threadRun</span><span class="params">(_In_ PVOID StartContext)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	KdPrint((<span class="string">&quot;开始执行1\n&quot;</span>));</span><br><span class="line">	LARGE_INTEGER times;</span><br><span class="line">	times.QuadPart = <span class="number">-30</span> * <span class="number">1000</span> * <span class="number">1000</span>;</span><br><span class="line">	KeDelayExecutionThread(KernelMode, FALSE, &amp;times);</span><br><span class="line">	PDRIVER_OBJECT pDriver = (PDRIVER_OBJECT)StartContext;</span><br><span class="line">	<span class="comment">//抹除特征</span></span><br><span class="line">    pDriver-&gt;DriverSize = <span class="number">0</span>;</span><br><span class="line">	pDriver-&gt;DriverSection = <span class="literal">NULL</span>;</span><br><span class="line">	pDriver-&gt;DriverExtension = <span class="literal">NULL</span>;</span><br><span class="line">	pDriver-&gt;DriverStart = <span class="literal">NULL</span>;</span><br><span class="line">	pDriver-&gt;DriverInit = <span class="literal">NULL</span>;</span><br><span class="line">	pDriver-&gt;FastIoDispatch = <span class="literal">NULL</span>;</span><br><span class="line">	pDriver-&gt;DriverStartIo = <span class="literal">NULL</span>;</span><br><span class="line">	ZwClose(hThread);</span><br><span class="line">	KdPrint((<span class="string">&quot;执行结束1\n&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT pDriver, PUNICODE_STRING pReg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	KdPrint((<span class="string">&quot;驱动被加载\n&quot;</span>));</span><br><span class="line">	PLDR_DATA_TABLE_ENTRY pList = (PLDR_DATA_TABLE_ENTRY)pDriver-&gt;DriverSection;</span><br><span class="line">	PLDR_DATA_TABLE_ENTRY pCur = pList;</span><br><span class="line">	pList = pList-&gt;InLoadOrderLinks.Flink;</span><br><span class="line"></span><br><span class="line">	pList-&gt;InLoadOrderLinks.Blink = pCur-&gt;InLoadOrderLinks.Blink;</span><br><span class="line">	pCur-&gt;InLoadOrderLinks.Flink = pList;</span><br><span class="line"></span><br><span class="line">	pDriver-&gt;DriverUnload = DriverUnload;</span><br><span class="line"></span><br><span class="line">	PsCreateSystemThread(&amp;hThread, GENERIC_ALL, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, threadRun, pDriver);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码可让pchunter也找不到驱动，但此代码只做了抹特征隐藏，却并未恢复特征或手动调用函数卸载驱动。停止驱动的时候会因为信息缺失直接蓝屏。需要一个时间点做恢复特征（不可以在DriverUnload中，因为是还没到该函数就蓝屏了）。</p>
<p>64位下不能直接断链(PG的原因)</p>
<p>MiProcessLoaderEntry，第一个参数是当前链表，第二个参数false表示卸载，true表示插入。该函数模块从链表上移除了，但没有释放内存。</p>
<p>64位用这个函数不会触发PG，不会蓝屏。PG可以理解成就是保护全局变量bu不被直接修改。</p>
<p><strong>KdPrint和DbgPrint的区别：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DBG</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> KdPrint(_x_) DbgPrint _x_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> KdPrint(_x_)<span class="comment">//把KdPrint(_x_)宏替换成什么也没有</span></span></span><br><span class="line"><span class="comment">//即如下两句在debug模式下含义相同:</span></span><br><span class="line">KdPrint((<span class="string">&quot;hello World!\n&quot;</span>));</span><br><span class="line">DbgPrint(<span class="string">&quot;hello World!\n&quot;</span>);</span><br><span class="line"><span class="comment">//但在release模式下，KdPrint不会打印。</span></span><br></pre></td></tr></table></figure>

<h3 id="驱动键鼠过滤"><a href="#驱动键鼠过滤" class="headerlink" title="驱动键鼠过滤"></a>驱动键鼠过滤</h3><p>IoAttachDevice绑定设备</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS</span></span><br><span class="line"><span class="function"><span class="title">IoAttachDevice</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">IN PDEVICE_OBJECT SourceDevice,<span class="comment">//生成的设备对象</span></span></span></span><br><span class="line"><span class="params"><span class="function">IN PUNICODE_STRING TargetDevice,<span class="comment">//目标串口设备名称</span></span></span></span><br><span class="line"><span class="params"><span class="function">OUT PDEVICE_OBJECT *AttachedDevice<span class="comment">//【返回被绑定设备指针】的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UNICODE_STRING com_name = RLT_CONSTANT_STRING(<span class="string">L&quot;\\Device\\Serial0&quot;</span>);</span><br><span class="line">NTSTATUS status = IoAttachDevice(com_filter_device,&amp;com_device_name,&amp;attached_device);</span><br></pre></td></tr></table></figure>









<h2 id="零环与三环通信-常规方式"><a href="#零环与三环通信-常规方式" class="headerlink" title="零环与三环通信(常规方式)"></a>零环与三环通信(常规方式)</h2><p>常规方式表示微软提供的正常通信方式，还有非常规通信。正常通信方式受到一定限制。</p>
<p><strong>设备对象</strong></p>
<p>我们在开发窗口程序的时候，消息被封装成一个结构体：MSG，<strong>在内核开发时，消息被封装成另外一个结构体：IRP</strong>（I/O Request Package输入输出请求包）</p>
<p>在窗口程序中，能够接受消息的只能是窗口对象。在内核中，能够接收IRP消息的只能是设备对象</p>
<p><img src="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20210827111116147.png" alt="image-20210827111116147"></p>
<ul>
<li><strong>驱动对象</strong>（DRIVER_OBJECT）生成多个设备对象，</li>
<li><strong>设备对象</strong>（DEVICE_OBJECT）可以是硬件（硬盘等），也可以是软件，比如NTFS文件系统。它们都属于设备对象。</li>
</ul>
<p><img src="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20210829163134914.png" alt="image-20210829163134914"></p>
<p><img src="https://gitee.com/ZEROKO14/blog-img/raw/master/img/sdsad.jpeg" alt="sdsad"></p>
<h3 id="创建设备对象"><a href="#创建设备对象" class="headerlink" title="创建设备对象"></a><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/nf-wdm-iocreatedevice">创建设备对象</a></h3><h4 id="设备对象结构"><a href="#设备对象结构" class="headerlink" title="设备对象结构"></a>设备对象结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> struct <span class="title">DECLSPEC_ALIGN</span><span class="params">(MEMORY_ALLOCATION_ALIGNMENT)</span> _DEVICE_OBJECT</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CSHORT Type;<span class="comment">//类型</span></span><br><span class="line">    USHORT Size;<span class="comment">//大小</span></span><br><span class="line">    LONG ReferenceCount;<span class="comment">//引用计数</span></span><br><span class="line">    <span class="comment">/*指向驱动程序中驱动对象的指针*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">DRIVER_OBJECT</span> *<span class="title">DriverObject</span>;</span><span class="comment">//设备所属的驱动对象</span></span><br><span class="line">    <span class="comment">/*指向下一个设备对象的指针*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">DEVICE_OBJECT</span> *<span class="title">NextDevice</span>;</span><span class="comment">//下一个设备对象，在一个驱动对象中有N个设备，这些设备用这个指针连接起来作为一个单向的链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">DEVICE_OBJECT</span> *<span class="title">AttachedDevice</span>;</span></span><br><span class="line">    <span class="comment">/*当前IRP结构*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IRP</span> *<span class="title">CurrentIrp</span>;</span></span><br><span class="line">    PIO_TIMER Timer;</span><br><span class="line">    <span class="comment">/*设备对象的特性标志*/</span></span><br><span class="line">    ULONG Flags;</span><br><span class="line">    ULONG Characteristics;</span><br><span class="line">    _volatile PVPB Vpb;</span><br><span class="line">    <span class="comment">/*指向设备扩展对象的指针*/</span></span><br><span class="line">    PVOID DeviceExtension;</span><br><span class="line">    <span class="comment">/*指明设备类型*/</span></span><br><span class="line">    DEVICE_TYPE DeviceType;</span><br><span class="line">    <span class="comment">/*堆栈的最小层数*/</span></span><br><span class="line">    CCHAR StackSize;<span class="comment">//IRP栈的大小,用于存放参数的</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        LIST_ENTRY ListEntry;</span><br><span class="line">        WAIT_CONTEXT_BLOCK Wcb;</span><br><span class="line">    &#125; Queue;</span><br><span class="line">    <span class="comment">/*内存对齐*/</span></span><br><span class="line">    ULONG AlignmentRequirement;</span><br><span class="line">    KDEVICE_QUEUE DeviceQueue;</span><br><span class="line">    KDPC Dpc;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *下列成员用于支持文件系统的互斥操作</span></span><br><span class="line"><span class="comment">    *以便对文件系统处理线程使用设备的计数保持跟踪</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    ULONG ActiveThreadCount;</span><br><span class="line">    PSECURITY_DESCRIPTOR SecurityDescriptor;</span><br><span class="line">    KEVENT DeviceLock;</span><br><span class="line"> </span><br><span class="line">    USHORT SectorSize;</span><br><span class="line">    USHORT Spare1;</span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">DEVOBJ_EXTENSION</span>  *<span class="title">DeviceObjectExtension</span>;</span></span><br><span class="line">    PVOID  Reserved;</span><br><span class="line"> </span><br><span class="line">&#125; DEVICE_OBJECT;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DEVICE_OBJECT</span> *<span class="title">PDEVICE_OBJECT</span>;</span></span><br></pre></td></tr></table></figure>

<h4 id="IoCreateDevice"><a href="#IoCreateDevice" class="headerlink" title="IoCreateDevice"></a>IoCreateDevice</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">IoCreateDevice</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  PDRIVER_OBJECT  DriverObject,<span class="comment">//驱动对象指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">  ULONG           DeviceExtensionSize,<span class="comment">//指定要为设备对象的设备扩展分配的驱动程序确定的字节数；设备扩展内存的大小，你可以在这申请一块非分页内存，只要设备还在，就都可以用，可以用它代替全局变量。</span></span></span></span><br><span class="line"><span class="params"><span class="function">  PUNICODE_STRING DeviceName,<span class="comment">//可选地指向一个缓冲区，该缓冲区包含一个以空字符结尾的 Unicode 字符串，用于命名设备对象。该字符串必须是完整路径名。</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DEVICE_TYPE     DeviceType,<span class="comment">//一般用FILE_DEVICE_UNKNOWN，#define FILE_DEVICE_UNKNOWN             0x00000022</span></span></span></span><br><span class="line"><span class="params"><span class="function">  ULONG           DeviceCharacteristics,<span class="comment">//基本就是填FILE_DEVICE_SECURE_OPEN</span></span></span></span><br><span class="line"><span class="params"><span class="function">  BOOLEAN         Exclusive,<span class="comment">//TRUE代表设备是独占的，FALSE代表该设备是共享的；独享可以防止前面的驱动拦截后面的驱动的派遣函数处理</span></span></span></span><br><span class="line"><span class="params"><span class="function">  PDEVICE_OBJECT  *DeviceObject<span class="comment">//【out】二级指针，目的是返回设备对象指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给某个设备发送IRP请求</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">MyDispath</span><span class="params">(PDEVICE_OBJECT device,PIRP irp)</span></span>;</span><br></pre></td></tr></table></figure>

<p>实例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建设备名称</span></span><br><span class="line">UNICODE_STRING Devicename;</span><br><span class="line">RtlInitUnicodeString(&amp;Devicename,<span class="string">L&quot;\\Device\\MyDevice&quot;</span>);<span class="comment">//\\Device尽量不要改，为了让驱动文件同一个树结构下，方便统一。该名字是给零环用的，三环通过这个名字是找不到该设备对象的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设备对象指针，用于接受</span></span><br><span class="line">PDEVICE_OBJECT pDeviceObj = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//创建设备</span></span><br><span class="line">status = IoCreateDevice(</span><br><span class="line">pDriver,				<span class="comment">//当前设备所属的驱动对象</span></span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">&amp;Devicename,			<span class="comment">//设备对象的名称</span></span><br><span class="line">FILE_DEVICE_UNKNOWN,<span class="comment">//不知道什么类型</span></span><br><span class="line">FILE_DEVICE_SECURE_OPEN,</span><br><span class="line">TRUE,</span><br><span class="line">&amp;pDeviceObj			<span class="comment">//【out】设备对象指针</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">if</span>(!NT_SUCCESS(status))<span class="comment">//NT_SUCCESS,微软提供的，实际上就是判断status是否大于等于0</span></span><br><span class="line">&#123;</span><br><span class="line">    DbgPrint(<span class="string">&quot;创建设备失败!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除设备对象"><a href="#删除设备对象" class="headerlink" title="删除设备对象"></a>删除设备对象</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IoDeleteDevice(pDeviceObj);<span class="comment">//删除设备</span></span><br></pre></td></tr></table></figure>

<h3 id="设置交互数据的方式"><a href="#设置交互数据的方式" class="headerlink" title="设置交互数据的方式"></a>设置交互数据的方式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果前面创建设备对象成功，就设置交互数据的方式</span></span><br><span class="line">pDeviceObj-&gt;Flags |= DO_BUFFERED_IO;</span><br></pre></td></tr></table></figure>

<ul>
<li>**缓冲区方式读写(DO_BUFFERED_IO)**：操作系统将应用程序提供缓冲区的数据复制到内核模式下的地址中。(效率不高，适合小规模数据)</li>
<li>**直接方式读写(DO_DIRECT_IO)**：操作系统会将用户模式下的缓冲区锁住。然后操作系统将这段缓冲区在内核模式地址再次映射一遍。这样，用户模式的缓冲区和内核模式的缓冲区指向的是同一区域的物理内存。缺点就是要单独占用物理页面。(适合大规模数据，比较浪费物理页)</li>
<li><strong>其他方式读写</strong>(在调用IoCreateDevice创建设备后对pDevObj-&gt;Flags即不设置DO_BUFFERED_IO，也不设置DO_DIRECT_IO，此时就是其他方式)：在使用其他方式读写设备时，派遣函数直接读写应用程序提供的缓冲区地址。在驱动程序中，直接操作应用程序的缓冲区地址是很危险的。<strong>只有驱动程序与应用程序运行在相同线程上下文的情况下，才能使用这种方式</strong>。</li>
</ul>
<h3 id="创建与卸载符号链接"><a href="#创建与卸载符号链接" class="headerlink" title="创建与卸载符号链接"></a>创建与卸载符号链接</h3><p>就是设置一个名字，让三环可以通过这个名字找到设备对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建符号链接名称</span></span><br><span class="line">UNICODE_STRING SymbolicLinkName;</span><br><span class="line">RtlInitUnicodeString(&amp;SymbolicLinkName,<span class="string">L&quot;\\??\\MyTestDriver&quot;</span>);</span><br><span class="line"><span class="comment">//两个问号代表根目录</span></span><br><span class="line"><span class="comment">//Ring3用CreateFile打开设备时，用&quot;\\\\.\\MyTestDriver&quot;(实际上就是地址要\\.\开始，但是要转义，所以为\\\\.\\)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建符号链接</span></span><br><span class="line">status = IoCreateSymbolicLink(&amp;SymbolicLinkName,&amp;Devicename);</span><br><span class="line"><span class="keyword">if</span>(status!=STATUS_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">    DbgPrint(<span class="string">&quot;创建符号链接失败!\n&quot;</span>);</span><br><span class="line">    IoDeleteDevice(pDeviceObj);<span class="comment">//删除设备</span></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//卸载符号链接</span></span><br><span class="line">IoDeleteSymbolicLink(&amp;SymbolicLinkName);</span><br></pre></td></tr></table></figure>

<p>特别说明：</p>
<ol>
<li>设备名称的作用是给内核对象用的，如果要在Ring3访问，必须要有符号链接，其实就是一个别名，没有这个别名，在Ring3不可见</li>
<li><strong>内核模式下，符号链接是以”??&quot;开头的，如C盘就是”??\C:”</strong></li>
<li><strong>用户模式下，则是以”\\.\&quot;开头的，如C盘就是”\\.\C:”</strong></li>
</ol>
<h3 id="IRP与派遣函数"><a href="#IRP与派遣函数" class="headerlink" title="IRP与派遣函数"></a>IRP与派遣函数</h3><p><img src="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20210827114410752.png" alt="image-20210827114410752"></p>
<p>驱动程序与I/O管理器通信，使用的是IRP，即<strong>I/O请求包</strong>。</p>
<h4 id="IRP类型"><a href="#IRP类型" class="headerlink" title="IRP类型"></a>IRP类型</h4><ol>
<li><p>当应用层通过CreateFile，ReadFile，WriteFile，CloseHandle等函数打开，从设备读取数据，向设备写入数据，关闭设备的时候，会使操作系统分别产生出IRP_MJ_CREATE,IRP_MJ_READ,IRP_MJ_WRITE,IRP_MJ_CLOSE等不同的IRP。</p>
</li>
<li><p>其他类型的IRP</p>
<table>
<thead>
<tr>
<th>IRP类型</th>
<th>来源</th>
</tr>
</thead>
<tbody><tr>
<td><strong>IRP_MJ_DEVICE_CONTROL</strong></td>
<td>DeviceIoControl函数会产生此IRP</td>
</tr>
<tr>
<td>IRP_MJ_POWER</td>
<td>在操作系统处理电源信息时，产生此IRP</td>
</tr>
<tr>
<td>IRP_MJ_SHUTDOWN</td>
<td>关闭系统前会产生此IRP</td>
</tr>
<tr>
<td>IRP_MJ_CREATE</td>
<td>生成请求</td>
</tr>
<tr>
<td>IRP_MJ_QUERY_INFORMATION</td>
<td>查询请求</td>
</tr>
<tr>
<td>IRP_MJ_CLOSE</td>
<td>关闭请求</td>
</tr>
<tr>
<td>IRP_MJ_SET_INFORMATION</td>
<td>设置请求</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/irp-major-function-codes">还有很多。。。</a></td>
<td>。。。</td>
</tr>
</tbody></table>
<p>IRP_MJ_DEVICE_CONTROL是我们用的最多的一种方式，比较灵活。可以拿到三环传过来的消息码，自己设定怎么处理(通过消息码确定)。</p>
</li>
</ol>
<h4 id="派遣函数"><a href="#派遣函数" class="headerlink" title="派遣函数"></a>派遣函数</h4><h5 id="派遣函数在哪里注册呢？"><a href="#派遣函数在哪里注册呢？" class="headerlink" title="派遣函数在哪里注册呢？"></a>派遣函数在哪里注册呢？</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _DRIVER_OBJECT</span><br><span class="line">nt!_DRIVER_OBJECT</span><br><span class="line">   +<span class="number">0x000</span> Type             : Int2B</span><br><span class="line">   +<span class="number">0x002</span> Size             : Int2B</span><br><span class="line">   +<span class="number">0x004</span> DeviceObject     : Ptr32 _DEVICE_OBJECT</span><br><span class="line">   +<span class="number">0x008</span> Flags            : Uint4B</span><br><span class="line">   +<span class="number">0x00c</span> DriverStart      : Ptr32 Void</span><br><span class="line">   +<span class="number">0x010</span> DriverSize       : Uint4B</span><br><span class="line">....</span><br><span class="line">   +<span class="number">0x030</span> DriverStartIo    : Ptr32     <span class="keyword">void</span> </span><br><span class="line">   +<span class="number">0x034</span> DriverUnload     : Ptr32     <span class="keyword">void</span> 		<span class="comment">//卸载函数</span></span><br><span class="line">   +<span class="number">0x038</span> MajorFunction    : [<span class="number">28</span>] Ptr32     <span class="keyword">long</span> 	<span class="comment">//派遣函数</span></span><br><span class="line">   <span class="comment">//0编号的IRP对应的派遣函数的地址就存在MajorFunction[0]的位置。</span></span><br></pre></td></tr></table></figure>

<p>0编号的IRP对应的派遣函数的地址就存在MajorFunction[0]的位置。</p>
<h5 id="注册派遣函数"><a href="#注册派遣函数" class="headerlink" title="注册派遣函数"></a>注册派遣函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">( 。。。。)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="comment">//设置卸载函数   </span></span><br><span class="line">    pDriverObject-&gt;DriverUnload = 卸载函数;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//设置派遣函数   </span></span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_CREATE] 	= 派遣函数<span class="number">1</span>;  </span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_CLOSE] 	= 派遣函数<span class="number">2</span>;  </span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_WRITE] 	= 派遣函数<span class="number">3</span>;  </span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_READ] 	= 派遣函数<span class="number">4</span>;  </span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_CLEANUP] 	= 派遣函数<span class="number">5</span>;  </span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_SET_INFORMATION] 	= 派遣函数<span class="number">6</span>;  </span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] 	= 派遣函数<span class="number">7</span>;  </span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_SHUTDOWN] 		= 派遣函数<span class="number">8</span>;  </span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_SYSTEM_CONTROL] 	= 派遣函数<span class="number">9</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>IRP_MJ_MAXIMUM_FUNCTION  派遣函数的最大值宏</p>
<h4 id="派遣函数的格式"><a href="#派遣函数的格式" class="headerlink" title="派遣函数的格式"></a>派遣函数的格式</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">MyDispatchFunction</span><span class="params">(PDEVICE_OBJECT pDevObj, PIRP pIrp)</span><span class="comment">//PIRP为IRP报文数据结构指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//处理自己的业务...</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置返回状态,返回状态如果不设置，Ring3返回的是失败</span></span><br><span class="line">	pIrp-&gt;IoStatus.Status = STATUS_SUCCESS;	<span class="comment">//  三环getlasterror()得到的就是这个值</span></span><br><span class="line">	pIrp-&gt;IoStatus.Information = <span class="number">0</span>;		<span class="comment">//  返回给3环多少个字节的数据 没有填0</span></span><br><span class="line">	IoCompleteRequest(pIrp, IO_NO_INCREMENT);<span class="comment">//表示调用方已完成所有I/O请求处理操作，并将给定的 IRP 返回给 I/O 管理器。将IRP往下派发</span></span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ns-wdm-_irp">IRP结构详解</a></p>
<h5 id="IRP-MJ-DEVICE-CONTROL的派遣函数"><a href="#IRP-MJ-DEVICE-CONTROL的派遣函数" class="headerlink" title="IRP_MJ_DEVICE_CONTROL的派遣函数"></a><strong>IRP_MJ_DEVICE_CONTROL的派遣函数</strong></h5><h6 id="CTL操作码"><a href="#CTL操作码" class="headerlink" title="CTL操作码"></a>CTL操作码</h6><p>IRP_MJ_DEVICE_CONTROL用到的操作码是个复合数据，微软提供了一个<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/d4drvif/nf-d4drvif-ctl_code">宏CTL_CODE</a>来组合这个复合数据，如下定义方式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该宏的定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CTL_CODE( DeviceType, Function, Method, Access ) (                 \</span></span><br><span class="line"><span class="meta">    ((DeviceType) &lt;&lt; 16) | ((Access) &lt;&lt; 14) | ((Function) &lt;&lt; 2) | (Method) \</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="comment">//是个宏，按照函数讲解每个参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CTL_CODE</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">   DeviceType,<span class="comment">//驱动种类，一般是FILE_DEVICE_UNKNOWN</span></span></span></span><br><span class="line"><span class="params"><span class="function">   Function,<span class="comment">//提供一个数值，标识其独特性</span></span></span></span><br><span class="line"><span class="params"><span class="function">   Method,<span class="comment">//交互数据的方式(要与前面设定的一致)，METHOD_BUFFERED或METHOD_IN_DIRECT或METHOD_OUT_DIRECT或METHOD_NEITHER</span></span></span></span><br><span class="line"><span class="params"><span class="function">   Access<span class="comment">//权限，FILE_ANY_ACCESS表示全部权限，或FILE_READ_ACCESS或FILE_WRITE_ACCESS</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//定义实例：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE_READ CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,METHOD_BUFFERED,FILE_ANY_ACCESS)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE_WRITE CTL_CODE(FILE_DEVICE_UNKNOWN,0x900,METHOD_BUFFERED,FILE_ANY_ACCESS)</span></span><br></pre></td></tr></table></figure>

<h6 id="IRP-MJ-DEVICE-CONTROL的派遣函数编写"><a href="#IRP-MJ-DEVICE-CONTROL的派遣函数编写" class="headerlink" title="IRP_MJ_DEVICE_CONTROL的派遣函数编写"></a>IRP_MJ_DEVICE_CONTROL的派遣函数编写</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">ControlCallBack</span><span class="params">(PDEVICE_OBJECT pDevObj, PIRP pIrp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PIO_STACK_LOCATION psl = IoGetCurrentIrpStackLocation(pIrp);</span><br><span class="line">    ULONG code = psl-&gt;Parameters.DeviceIoControl.IoControlCode;<span class="comment">//获取派遣过来的CTL操作码</span></span><br><span class="line">    PVOID systemBuf = pIrp-&gt;AssociatedIrp.SystemBuffer;<span class="comment">//获取缓存地址(输入输出都靠这个地址)</span></span><br><span class="line">    ULONG inLen = psl-&gt;Parameters.DeviceIoControl.InputBufferLength;<span class="comment">//获取输入长度</span></span><br><span class="line">    ULONG outLen = psl-&gt;Parameters.DeviceIoControl.OutputBufferLength;<span class="comment">//获取输出长度</span></span><br><span class="line">    <span class="comment">//根据不同的CTL操作码做不同的处理</span></span><br><span class="line">    <span class="keyword">switch</span>(code)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> CODE_READ:<span class="comment">//注意是以三环视角来看其含义，三环想要读</span></span><br><span class="line">            <span class="comment">//执行想做的事情</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> CODE_WRITE:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    IoCompleteRequest(pIrp, IO_NO_INCREMENT);<span class="comment">//表示调用方已完成所有I/O请求处理操作，并将给定的 IRP 返回给 I/O 管理器。将IRP往下派发</span></span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-iogetcurrentirpstacklocation">IoGetCurrentIrpStackLocation详解</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ns-wdm-_io_stack_location">PIO_STACK_LOCATION结构详解</a></li>
</ul>
<h6 id="三环写法"><a href="#三环写法" class="headerlink" title="三环写法"></a>三环写法</h6><p><strong><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a>函数结构</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">DeviceIoControl</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE       hDevice,<span class="comment">//设备句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD        dwIoControlCode,<span class="comment">//CTL操作码</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPVOID       lpInBuffer,<span class="comment">//读到哪(三环读零环)</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD        nInBufferSize,<span class="comment">//读多少</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPVOID       lpOutBuffer,<span class="comment">//写到哪(三环写零环)</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD        nOutBufferSize,<span class="comment">//写多少</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPDWORD      lpBytesReturned,<span class="comment">//实际多少</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPOVERLAPPED lpOverlapped<span class="comment">//异步相关，一般填NULL，略</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>内核通信，需要头文件#include &lt;WinIoCtl.h&gt;</p>
<p>并且<strong>WinIoCtl.h必须定义到Windows.h的后面</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE_READ CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,METHOD_BUFFERED,FILE_ANY_ACCESS)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE_WRITE CTL_CODE(FILE_DEVICE_UNKNOWN,0x900,METHOD_BUFFERED,FILE_ANY_ACCESS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打开设备</span></span><br><span class="line"><span class="function">BOOLEAN <span class="title">openDevice</span><span class="params">(HANDLE *handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE _handle = CreateFileA(<span class="string">&quot;\\\\.\\MyTestDriver&quot;</span>,GENERIC_READ|GENERIC_WRITE,<span class="number">0</span>,<span class="literal">NULL</span>,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,<span class="literal">NULL</span>);<span class="comment">//打开设备对象句柄</span></span><br><span class="line">    *handle=_handle;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">int</span>)_handle&gt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭设备</span></span><br><span class="line">CloseHandle(handle);</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送IRP_MJ_DEVICE_CONTROL</span></span><br><span class="line"><span class="function">BOOLEAN <span class="title">sendCode</span><span class="params">(HANDLE hDevice,DWORD code,PVOID inData,ULONG Inlen,PVOID outData,ULONG outLen,LPDWORD resultLen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DeviceIoControl(hDevice,code,inData,Inlen,outData,outLen,resultLen,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>0-3环常规通信框架：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE_CHANGE CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,METHOD_BUFFERED,FILE_ANY_ACCESS)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE_RESUME CTL_CODE(FILE_DEVICE_UNKNOWN,0x900,METHOD_BUFFERED,FILE_ANY_ACCESS)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE_READ CTL_CODE(FILE_DEVICE_UNKNOWN,0x1000,METHOD_BUFFERED,FILE_ANY_ACCESS)</span></span><br><span class="line">UNICODE_STRING SymbolicLinkName;</span><br><span class="line"></span><br><span class="line"><span class="comment">//卸载函数</span></span><br><span class="line"><span class="function">VOID <span class="title">DriverUnload</span><span class="params">(PDRIVER_OBJECT driver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DbgPrint(<span class="string">&quot;停止运行了\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">MyCreateDispatchFunction</span><span class="params">(PDEVICE_OBJECT pDevObj, PIRP pIrp)</span><span class="comment">//PIRP为IRP报文数据结构指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//处理自己的业务...</span></span><br><span class="line">	DbgPrint(<span class="string">&quot;三环连接成功\n&quot;</span>);</span><br><span class="line">	<span class="comment">//设置返回状态,返回状态如果不设置，Ring3返回的是失败</span></span><br><span class="line">	pIrp-&gt;IoStatus.Status = STATUS_SUCCESS;	<span class="comment">//  三环getlasterror()得到的就是这个值</span></span><br><span class="line">	pIrp-&gt;IoStatus.Information = <span class="number">0</span>;		<span class="comment">//  返回给3环多少个字节的数据 没有填0</span></span><br><span class="line">	IoCompleteRequest(pIrp, IO_NO_INCREMENT);<span class="comment">//表示调用方已完成所有I/O请求处理操作，并将给定的 IRP 返回给 I/O 管理器。将IRP往下派发</span></span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">NTSTATUS <span class="title">MyCloseDispatchFunction</span><span class="params">(PDEVICE_OBJECT pDevObj, PIRP pIrp)</span><span class="comment">//PIRP为IRP报文数据结构指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//处理自己的业务...</span></span><br><span class="line">	DbgPrint(<span class="string">&quot;三环断开连接成功\n&quot;</span>);</span><br><span class="line">	<span class="comment">//设置返回状态,返回状态如果不设置，Ring3返回的是失败</span></span><br><span class="line">	pIrp-&gt;IoStatus.Status = STATUS_SUCCESS;	<span class="comment">//  三环getlasterror()得到的就是这个值</span></span><br><span class="line">	pIrp-&gt;IoStatus.Information = <span class="number">0</span>;		<span class="comment">//  返回给3环多少个字节的数据 没有填0</span></span><br><span class="line">	IoCompleteRequest(pIrp, IO_NO_INCREMENT);<span class="comment">//表示调用方已完成所有I/O请求处理操作，并将给定的 IRP 返回给 I/O 管理器。将IRP往下派发</span></span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ULONG current = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">ControlCallBack</span><span class="params">(PDEVICE_OBJECT pDevObj, PIRP pIrp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	PIO_STACK_LOCATION psl = IoGetCurrentIrpStackLocation(pIrp);</span><br><span class="line">	ULONG code = psl-&gt;Parameters.DeviceIoControl.IoControlCode;<span class="comment">//获取派遣过来的CTL操作码</span></span><br><span class="line">	PVOID systemBuf = pIrp-&gt;AssociatedIrp.SystemBuffer;<span class="comment">//获取缓存地址(输入输出都靠这个地址)</span></span><br><span class="line">	ULONG inLen = psl-&gt;Parameters.DeviceIoControl.InputBufferLength;<span class="comment">//获取输入长度</span></span><br><span class="line">	ULONG outLen = psl-&gt;Parameters.DeviceIoControl.OutputBufferLength;<span class="comment">//获取输出长度</span></span><br><span class="line">	<span class="comment">//根据不同的CTL操作码做不同的处理</span></span><br><span class="line">	<span class="keyword">switch</span> (code)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> CODE_CHANGE:<span class="comment">//注意是以三环视角来看其含义，初始化</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> CODE_RESUME:<span class="comment">//三环想要反初始化</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> CODE_READ:</span><br><span class="line"></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	IoCompleteRequest(pIrp, IO_NO_INCREMENT);<span class="comment">//表示调用方已完成所有I/O请求处理操作，并将给定的 IRP 返回给 I/O 管理器。将IRP往下派发</span></span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//入口函数，相当于main函数</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT pdriver, PUNICODE_STRING pReg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//设置一个卸载函数，用于退出</span></span><br><span class="line">	pdriver-&gt;DriverUnload = DriverUnload;</span><br><span class="line">	<span class="comment">//创建设备名称</span></span><br><span class="line">	UNICODE_STRING Devicename;</span><br><span class="line">	RtlInitUnicodeString(&amp;Devicename, <span class="string">L&quot;\\Device\\MyDevice&quot;</span>);</span><br><span class="line">	<span class="comment">//设备对象指针，用于接受</span></span><br><span class="line">	PDEVICE_OBJECT pDeviceObj = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//创建设备</span></span><br><span class="line">	NTSTATUS status = IoCreateDevice(pdriver,<span class="number">0</span>,&amp;Devicename,FILE_DEVICE_UNKNOWN,FILE_DEVICE_SECURE_OPEN,TRUE,&amp;pDeviceObj	);</span><br><span class="line">	<span class="keyword">if</span> (!NT_SUCCESS(status))<span class="comment">//NT_SUCCESS,微软提供的，实际上就是判断status是否大于等于0</span></span><br><span class="line">	&#123;</span><br><span class="line">		DbgPrint(<span class="string">&quot;创建设备失败!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> status;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果前面创建设备对象成功，就设置交互数据的方式</span></span><br><span class="line">	pDeviceObj-&gt;Flags |= DO_BUFFERED_IO;</span><br><span class="line">	<span class="comment">//创建符号链接名称</span></span><br><span class="line">	RtlInitUnicodeString(&amp;SymbolicLinkName, <span class="string">L&quot;\\??\\MyTestDriver&quot;</span>);</span><br><span class="line">	status = IoCreateSymbolicLink(&amp;SymbolicLinkName, &amp;Devicename);</span><br><span class="line">	<span class="keyword">if</span> (!NT_SUCCESS(status))</span><br><span class="line">	&#123;</span><br><span class="line">		DbgPrint(<span class="string">&quot;创建符号链接失败!\n&quot;</span>);</span><br><span class="line">		IoDeleteDevice(pDeviceObj);<span class="comment">//删除设备</span></span><br><span class="line">		<span class="keyword">return</span> status;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置派遣函数   </span></span><br><span class="line">	pdriver-&gt;MajorFunction[IRP_MJ_CREATE] = MyCreateDispatchFunction;</span><br><span class="line">	pdriver-&gt;MajorFunction[IRP_MJ_CLOSE] = MyCloseDispatchFunction;</span><br><span class="line">	pdriver-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = ControlCallBack;</span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="通过IRP-MJ-DEVICE-CONTROL交互数据实验"><a href="#通过IRP-MJ-DEVICE-CONTROL交互数据实验" class="headerlink" title="通过IRP_MJ_DEVICE_CONTROL交互数据实验"></a>通过IRP_MJ_DEVICE_CONTROL交互数据实验</h3><h4 id="R0代码："><a href="#R0代码：" class="headerlink" title="R0代码："></a>R0代码：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE_READ CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,METHOD_BUFFERED,FILE_ANY_ACCESS)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE_WRITE CTL_CODE(FILE_DEVICE_UNKNOWN,0x900,METHOD_BUFFERED,FILE_ANY_ACCESS)</span></span><br><span class="line">UNICODE_STRING SymbolicLinkName;</span><br><span class="line"></span><br><span class="line"><span class="comment">//卸载函数</span></span><br><span class="line"><span class="function">VOID <span class="title">DriverUnload</span><span class="params">(PDRIVER_OBJECT driver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//删除设备对象</span></span><br><span class="line">	<span class="keyword">if</span> (driver-&gt;DeviceObject)</span><br><span class="line">	&#123;</span><br><span class="line">		IoDeleteDevice(driver-&gt;DeviceObject);<span class="comment">//设备对象已挂载在driver中</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (SymbolicLinkName.Length&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		IoDeleteSymbolicLink(&amp;SymbolicLinkName);</span><br><span class="line">	&#125;</span><br><span class="line">	DbgPrint(<span class="string">&quot;停止运行了\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">MyCreateDispatchFunction</span><span class="params">(PDEVICE_OBJECT pDevObj, PIRP pIrp)</span><span class="comment">//PIRP为IRP报文数据结构指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//处理自己的业务...</span></span><br><span class="line">	DbgPrint(<span class="string">&quot;三环连接成功\n&quot;</span>);</span><br><span class="line">	<span class="comment">//设置返回状态,返回状态如果不设置，Ring3返回的是失败</span></span><br><span class="line">	pIrp-&gt;IoStatus.Status = STATUS_SUCCESS;	<span class="comment">//  三环getlasterror()得到的就是这个值</span></span><br><span class="line">	pIrp-&gt;IoStatus.Information = <span class="number">0</span>;		<span class="comment">//  返回给3环多少个字节的数据 没有填0</span></span><br><span class="line">	IoCompleteRequest(pIrp, IO_NO_INCREMENT);<span class="comment">//表示调用方已完成所有I/O请求处理操作，并将给定的 IRP 返回给 I/O 管理器。将IRP往下派发</span></span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">NTSTATUS <span class="title">MyCloseDispatchFunction</span><span class="params">(PDEVICE_OBJECT pDevObj, PIRP pIrp)</span><span class="comment">//PIRP为IRP报文数据结构指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//处理自己的业务...</span></span><br><span class="line">	DbgPrint(<span class="string">&quot;三环断开连接成功\n&quot;</span>);</span><br><span class="line">	<span class="comment">//设置返回状态,返回状态如果不设置，Ring3返回的是失败</span></span><br><span class="line">	pIrp-&gt;IoStatus.Status = STATUS_SUCCESS;	<span class="comment">//  三环getlasterror()得到的就是这个值</span></span><br><span class="line">	pIrp-&gt;IoStatus.Information = <span class="number">0</span>;		<span class="comment">//  返回给3环多少个字节的数据 没有填0</span></span><br><span class="line">	IoCompleteRequest(pIrp, IO_NO_INCREMENT);<span class="comment">//表示调用方已完成所有I/O请求处理操作，并将给定的 IRP 返回给 I/O 管理器。将IRP往下派发</span></span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">ControlCallBack</span><span class="params">(PDEVICE_OBJECT pDevObj, PIRP pIrp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	PIO_STACK_LOCATION psl = IoGetCurrentIrpStackLocation(pIrp);</span><br><span class="line">	ULONG code = psl-&gt;Parameters.DeviceIoControl.IoControlCode;<span class="comment">//获取派遣过来的CTL操作码</span></span><br><span class="line">	PVOID systemBuf = pIrp-&gt;AssociatedIrp.SystemBuffer;<span class="comment">//获取缓存地址(输入输出都靠这个地址)</span></span><br><span class="line">	ULONG inLen = psl-&gt;Parameters.DeviceIoControl.InputBufferLength;<span class="comment">//获取输入长度</span></span><br><span class="line">	ULONG outLen = psl-&gt;Parameters.DeviceIoControl.OutputBufferLength;<span class="comment">//获取输出长度</span></span><br><span class="line">	<span class="comment">//根据不同的CTL操作码做不同的处理</span></span><br><span class="line">	<span class="keyword">switch</span> (code)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> CODE_READ:<span class="comment">//注意是以三环视角来看其含义，三环想要读</span></span><br><span class="line">		<span class="comment">//把1234567传给三环读</span></span><br><span class="line">		<span class="built_in">memcpy</span>(systemBuf, <span class="string">&quot;1234567&quot;</span>, <span class="keyword">sizeof</span>(<span class="string">&quot;1234567&quot;</span>));</span><br><span class="line">		<span class="comment">//把零环写入的长度传给三环</span></span><br><span class="line">		pIrp-&gt;IoStatus.Information = <span class="keyword">sizeof</span>(<span class="string">&quot;1234567&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> CODE_WRITE:</span><br><span class="line">		<span class="comment">//打印三环写入的信息</span></span><br><span class="line">		DbgPrint(<span class="string">&quot;派遣函数:三环传入的信息：%s\n&quot;</span>,<span class="comment">/*(char*)*/</span>systemBuf);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	IoCompleteRequest(pIrp, IO_NO_INCREMENT);<span class="comment">//表示调用方已完成所有I/O请求处理操作，并将给定的 IRP 返回给 I/O 管理器。将IRP往下派发</span></span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入口函数，相当于main函数</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT pdriver, PUNICODE_STRING pReg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//设置一个卸载函数，用于退出</span></span><br><span class="line">	pdriver-&gt;DriverUnload = DriverUnload;</span><br><span class="line">	<span class="comment">//创建设备名称</span></span><br><span class="line">	UNICODE_STRING Devicename;</span><br><span class="line">	RtlInitUnicodeString(&amp;Devicename, <span class="string">L&quot;\\Device\\MyDevice&quot;</span>);</span><br><span class="line">	<span class="comment">//设备对象指针，用于接受</span></span><br><span class="line">	PDEVICE_OBJECT pDeviceObj = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//创建设备</span></span><br><span class="line">	NTSTATUS status = IoCreateDevice(pdriver,<span class="number">0</span>,&amp;Devicename,FILE_DEVICE_UNKNOWN,FILE_DEVICE_SECURE_OPEN,TRUE,&amp;pDeviceObj	);</span><br><span class="line">	<span class="keyword">if</span> (!NT_SUCCESS(status))<span class="comment">//NT_SUCCESS,微软提供的，实际上就是判断status是否大于等于0</span></span><br><span class="line">	&#123;</span><br><span class="line">		DbgPrint(<span class="string">&quot;创建设备失败!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> status;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果前面创建设备对象成功，就设置交互数据的方式</span></span><br><span class="line">	pDeviceObj-&gt;Flags |= DO_BUFFERED_IO;</span><br><span class="line">	<span class="comment">//创建符号链接名称</span></span><br><span class="line">	RtlInitUnicodeString(&amp;SymbolicLinkName, <span class="string">L&quot;\\??\\MyTestDriver&quot;</span>);</span><br><span class="line">	status = IoCreateSymbolicLink(&amp;SymbolicLinkName, &amp;Devicename);</span><br><span class="line">	<span class="keyword">if</span> (!NT_SUCCESS(status))</span><br><span class="line">	&#123;</span><br><span class="line">		DbgPrint(<span class="string">&quot;创建符号链接失败!\n&quot;</span>);</span><br><span class="line">		IoDeleteDevice(pDeviceObj);<span class="comment">//删除设备</span></span><br><span class="line">		<span class="keyword">return</span> status;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置派遣函数   </span></span><br><span class="line">	pdriver-&gt;MajorFunction[IRP_MJ_CREATE] = MyCreateDispatchFunction;</span><br><span class="line">	pdriver-&gt;MajorFunction[IRP_MJ_CLOSE] = MyCloseDispatchFunction;</span><br><span class="line">	pdriver-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = ControlCallBack;</span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="R3代码："><a href="#R3代码：" class="headerlink" title="R3代码："></a>R3代码：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;WinIoCtl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE_READ CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,METHOD_BUFFERED,FILE_ANY_ACCESS)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE_WRITE CTL_CODE(FILE_DEVICE_UNKNOWN,0x900,METHOD_BUFFERED,FILE_ANY_ACCESS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打开设备</span></span><br><span class="line"><span class="function">BOOLEAN <span class="title">openDevice</span><span class="params">(HANDLE *handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HANDLE _handle = CreateFileA(<span class="string">&quot;\\\\.\\MyTestDriver&quot;</span>, GENERIC_READ | GENERIC_WRITE, <span class="number">0</span>, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);<span class="comment">//打开设备对象句柄</span></span><br><span class="line">	*handle = _handle;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">int</span>)_handle &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//发送IRP_MJ_DEVICE_CONTROL</span></span><br><span class="line"><span class="function">BOOLEAN <span class="title">sendCode</span><span class="params">(HANDLE hDevice, DWORD code, PVOID inData, ULONG Inlen, PVOID outData, ULONG outLen, LPDWORD resultLen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> DeviceIoControl(hDevice, code, inData, Inlen, outData, outLen, resultLen, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HANDLE hDevice;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">30</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	DWORD realReaded = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!openDevice(&amp;hDevice))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;打开设备对象失败!\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//写数据给R0！！！！！！！！！！！！！！！！！！！！！！</span></span><br><span class="line">	<span class="built_in">memcpy</span>(buf,<span class="string">&quot;i am R3&quot;</span>,<span class="keyword">sizeof</span>(<span class="string">&quot;i am R3&quot;</span>));</span><br><span class="line">	sendCode(hDevice, CODE_WRITE, buf, <span class="number">30</span>, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;realReaded);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//读R0数据	！！！！！！！！！！！！！！！！！！！！！！</span></span><br><span class="line">	<span class="comment">//sendCode(hDevice, CODE_READ, NULL, 0, buf, 30, &amp;realReaded);</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;读到：%s\r\n&quot;</span>, buf);</span><br><span class="line">	CloseHandle(hDevice);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写数据结果如图：</p>
<p><img src="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20210829212010210.png" alt="image-20210829212010210"></p>
<p>将<code>写数据给R0</code>代码注释，放开<code>读R0数据</code>的代码，结果如图：</p>
<p><img src="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20210829212159461.png" alt="image-20210829212159461"></p>
<h2 id="驱动加载"><a href="#驱动加载" class="headerlink" title="驱动加载"></a>驱动加载</h2><h3 id="驱动注册-安装"><a href="#驱动注册-安装" class="headerlink" title="驱动注册/安装"></a>驱动注册/安装</h3><h4 id="OpenSCManagerA函数"><a href="#OpenSCManagerA函数" class="headerlink" title="OpenSCManagerA函数"></a><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/win32/api/winsvc/nf-winsvc-openscmanagera">OpenSCManagerA函数</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果函数成功，则返回值是指定服务控制管理器数据库的句柄。</span></span><br><span class="line"><span class="comment">//如果函数失败，则返回值为 NULL。</span></span><br><span class="line"><span class="comment">//打开服务管理器</span></span><br><span class="line"><span class="function">SC_HANDLE <span class="title">OpenSCManagerA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR lpMachineName,<span class="comment">//目标计算机的名称。如果指针为 NULL 或指向空字符串，则该函数连接到本地计算机上的服务控制管理器。</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR lpDatabaseName,<span class="comment">//服务控制管理器数据库的名称。此参数应设置为 SERVICES_ACTIVE_DATABASE。如果为 NULL，则默认打开 SERVICES_ACTIVE_DATABASE 数据库。</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD  dwDesiredAccess<span class="comment">//权限，SC_MANAGER_ALL_ACCESS 表示所有权限</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="创建服务CreateServiceA函数"><a href="#创建服务CreateServiceA函数" class="headerlink" title="创建服务CreateServiceA函数"></a>创建服务<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/win32/api/winsvc/nf-winsvc-createservicea">CreateServiceA函数</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果函数成功，则返回值是服务的句柄。</span></span><br><span class="line"><span class="comment">//如果函数失败，则返回值为 NULL。</span></span><br><span class="line"><span class="function">SC_HANDLE <span class="title">CreateServiceA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  SC_HANDLE hSCManager,<span class="comment">//服务管理器句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR    lpServiceName,<span class="comment">//这个服务的名字</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR    lpDisplayName,<span class="comment">//显示给别人看的名字</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD     dwDesiredAccess,<span class="comment">//访问权限，SERVICE_ALL_ACCESS表示所有权限</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD     dwServiceType,<span class="comment">//什么服务类型，SERVICE_KERNEL_DRIVER表示内核驱动服务</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD     dwStartType,<span class="comment">//启动类型，SERVICE_BOOT_START开机启动服务，SERVICE_AUTO_START自动启动服务，SERVICE_DEMAND_START按需启动，即当进程调用StartService函数时由服务控制管理器启动的服务 。</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD     dwErrorControl,<span class="comment">//如果此服务无法启动，则错误的严重性以及采取的措施。SERVICE_ERROR_NORMAL表示启动程序在事件日志中记录错误，但继续启动操作。</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR    lpBinaryPathName,<span class="comment">//服务二进制文件的完全限定路径。</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">//后面都为NULL就可以了</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR    lpLoadOrderGroup,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPDWORD   lpdwTagId,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR    lpDependencies,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR    lpServiceStartName,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR    lpPassword</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>关闭服务句柄</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CloseServiceHandle(serviceHandle);<span class="comment">//serviceHandle为某服务的句柄</span></span><br><span class="line"><span class="comment">//也可以直接调用CloseHandle(serviceHandle);CloseServiceHandle还是会调用CloseHandle</span></span><br></pre></td></tr></table></figure>

<h3 id="驱动启动"><a href="#驱动启动" class="headerlink" title="驱动启动"></a>驱动启动</h3><h4 id="打开服务OpenServiceA函数"><a href="#打开服务OpenServiceA函数" class="headerlink" title="打开服务OpenServiceA函数"></a>打开服务<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/win32/api/winsvc/nf-winsvc-openservicea">OpenServiceA函数</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SC_HANDLE <span class="title">OpenServiceA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  SC_HANDLE hSCManager,<span class="comment">//服务管理器句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR    lpServiceName,<span class="comment">//服务名字，根据这个服务名字找服务</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD     dwDesiredAccess<span class="comment">//权限，SC_MANAGER_ALL_ACCESS表示所有权限</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="开始服务StartServiceA函数"><a href="#开始服务StartServiceA函数" class="headerlink" title="开始服务StartServiceA函数"></a>开始服务<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/winsvc/nf-winsvc-startservicea">StartServiceA函数</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果函数成功，则返回值非零。</span></span><br><span class="line"><span class="comment">//如果函数失败，则返回值为零。</span></span><br><span class="line"><span class="function">BOOL <span class="title">StartServiceA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  SC_HANDLE hService,<span class="comment">//服务句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">//服务函数的参数相关</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD     dwNumServiceArgs,<span class="comment">//参数字节数，没有填0</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR    *lpServiceArgVectors<span class="comment">//如果没有参数，则此参数可以为 NULL。</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="停止驱动"><a href="#停止驱动" class="headerlink" title="停止驱动"></a>停止驱动</h3><p>OpenServiceA后ControlService</p>
<h4 id="控制服务ControlService函数"><a href="#控制服务ControlService函数" class="headerlink" title="控制服务ControlService函数"></a>控制服务<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/winsvc/nf-winsvc-controlservice">ControlService函数</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果函数成功，则返回值非零。</span></span><br><span class="line"><span class="comment">//如果函数失败，则返回值为零。</span></span><br><span class="line"><span class="function">BOOL <span class="title">ControlService</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  SC_HANDLE        hService,<span class="comment">//服务句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD            dwControl,<span class="comment">//控制码，其中SERVICE_CONTROL_STOP表示停止服务的控制码</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPSERVICE_STATUS lpServiceStatus<span class="comment">//指向SERVICE_STATUS结构的指针，该结构接收最新的服务状态信息。返回的信息反映了服务向服务控制管理器报告的最新状态。仅当GetLastError返回以下错误代码之一时，服务控制管理器才会填充结构 ：NO_ERROR、ERROR_INVALID_SERVICE_CONTROL、 ERROR_SERVICE_CANNOT_ACCEPT_CTRL或 ERROR_SERVICE_NOT_ACTIVE。否则，不填充结构。</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="卸载驱动"><a href="#卸载驱动" class="headerlink" title="卸载驱动"></a>卸载驱动</h3><p>OpenServiceA后DeleteService</p>
<p>删除服务<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/winsvc/nf-winsvc-deleteservice">DeleteService函数</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果函数成功，则返回值非零。</span></span><br><span class="line"><span class="comment">//如果函数失败，则返回值为零。</span></span><br><span class="line"><span class="function">BOOL <span class="title">DeleteService</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  SC_HANDLE hService<span class="comment">//服务句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="全局监听API实验"><a href="#全局监听API实验" class="headerlink" title="全局监听API实验"></a>全局监听API实验</h2><ol>
<li>自己加载驱动</li>
<li>写拷贝(段页知识)</li>
<li>R3,R0通信</li>
<li>写HOOK</li>
<li>ShellCode</li>
</ol>
<p>写拷贝的本来流程：</p>
<blockquote>
<p>当写一个内存的时候先判断到内存是否可写(R/W位是否为1)，若为0，则表示该内存不可写，进入异常，在异常中通过VAD进一步判断其到底是写拷贝还是只读，如果是只读报错；如果是写拷贝，则映射一份新物理页将原内容复制过来，直接写到新物理页上，不影响原物理页。因此你HOOK了一个API只影响你自己的进程，而无法影响别的进程是因为别的进程还是原物理页，并未被你修改。解决方法很简单，找到要hook API的地方将R/W位置1，根本不进异常直接hook原物理页，规避触发写拷贝。</p>
</blockquote>
<p>下面代码针对2-9-9-12分页，并且事后未复原。</p>
<h3 id="R0代码"><a href="#R0代码" class="headerlink" title="R0代码"></a>R0代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE_CHANGE CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,METHOD_BUFFERED,FILE_ANY_ACCESS)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE_RESUME CTL_CODE(FILE_DEVICE_UNKNOWN,0x900,METHOD_BUFFERED,FILE_ANY_ACCESS)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE_READ CTL_CODE(FILE_DEVICE_UNKNOWN,0x1000,METHOD_BUFFERED,FILE_ANY_ACCESS)</span></span><br><span class="line">UNICODE_STRING SymbolicLinkName;</span><br><span class="line"></span><br><span class="line"><span class="comment">//卸载函数</span></span><br><span class="line"><span class="function">VOID <span class="title">DriverUnload</span><span class="params">(PDRIVER_OBJECT driver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//删除设备对象</span></span><br><span class="line">	<span class="keyword">if</span> (driver-&gt;DeviceObject)</span><br><span class="line">	&#123;</span><br><span class="line">		IoDeleteDevice(driver-&gt;DeviceObject);<span class="comment">//设备对象已挂载在driver中</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (SymbolicLinkName.Length&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		IoDeleteSymbolicLink(&amp;SymbolicLinkName);</span><br><span class="line">	&#125;</span><br><span class="line">	DbgPrint(<span class="string">&quot;停止运行了\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">MyCreateDispatchFunction</span><span class="params">(PDEVICE_OBJECT pDevObj, PIRP pIrp)</span><span class="comment">//PIRP为IRP报文数据结构指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//处理自己的业务...</span></span><br><span class="line">	DbgPrint(<span class="string">&quot;三环连接成功\n&quot;</span>);</span><br><span class="line">	<span class="comment">//设置返回状态,返回状态如果不设置，Ring3返回的是失败</span></span><br><span class="line">	pIrp-&gt;IoStatus.Status = STATUS_SUCCESS;	<span class="comment">//  三环getlasterror()得到的就是这个值</span></span><br><span class="line">	pIrp-&gt;IoStatus.Information = <span class="number">0</span>;		<span class="comment">//  返回给3环多少个字节的数据 没有填0</span></span><br><span class="line">	IoCompleteRequest(pIrp, IO_NO_INCREMENT);<span class="comment">//表示调用方已完成所有I/O请求处理操作，并将给定的 IRP 返回给 I/O 管理器。将IRP往下派发</span></span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">NTSTATUS <span class="title">MyCloseDispatchFunction</span><span class="params">(PDEVICE_OBJECT pDevObj, PIRP pIrp)</span><span class="comment">//PIRP为IRP报文数据结构指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//处理自己的业务...</span></span><br><span class="line">	DbgPrint(<span class="string">&quot;三环断开连接成功\n&quot;</span>);</span><br><span class="line">	<span class="comment">//设置返回状态,返回状态如果不设置，Ring3返回的是失败</span></span><br><span class="line">	pIrp-&gt;IoStatus.Status = STATUS_SUCCESS;	<span class="comment">//  三环getlasterror()得到的就是这个值</span></span><br><span class="line">	pIrp-&gt;IoStatus.Information = <span class="number">0</span>;		<span class="comment">//  返回给3环多少个字节的数据 没有填0</span></span><br><span class="line">	IoCompleteRequest(pIrp, IO_NO_INCREMENT);<span class="comment">//表示调用方已完成所有I/O请求处理操作，并将给定的 IRP 返回给 I/O 管理器。将IRP往下派发</span></span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ULONG param[<span class="number">5</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//ULONG getESP = 0;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//shellcode写到这里</span></span><br><span class="line"><span class="keyword">void</span> __declspec(naked) interruptGate()</span><br><span class="line">&#123;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//通过ESP获取MessageBoxA的参数</span></span><br><span class="line">		pushfd;</span><br><span class="line">		pushad;</span><br><span class="line">		mov eax, dword ptr ds : [esp + <span class="number">0x24</span> + <span class="number">0xC</span>] ;<span class="comment">//获取三环esp</span></span><br><span class="line">		<span class="comment">//mov dword ptr ds : [getESP] , eax;</span></span><br><span class="line">		lea ecx, param;</span><br><span class="line">		add eax, <span class="number">4</span>;<span class="comment">//跳过call的返回地址</span></span><br><span class="line">		<span class="comment">//获取四个参数填入param全局数组中。</span></span><br><span class="line">		mov ebx, dword ptr ds : [eax] ;</span><br><span class="line">		mov dword ptr ds : [ecx] , ebx;</span><br><span class="line">		mov ebx, dword ptr ds : [eax+<span class="number">4</span>] ;</span><br><span class="line">		mov dword ptr ds : [ecx+<span class="number">4</span>] , ebx;</span><br><span class="line">		mov ebx, dword ptr ds : [eax+<span class="number">8</span>] ;</span><br><span class="line">		mov dword ptr ds : [ecx+<span class="number">8</span>] , ebx;</span><br><span class="line">		mov ebx, dword ptr ds : [eax + <span class="number">0xC</span>] ;</span><br><span class="line">		mov dword ptr ds : [ecx + <span class="number">0xC</span>] , ebx;</span><br><span class="line">		add dword ptr ds : [ecx + <span class="number">0x10</span>],<span class="number">1</span></span><br><span class="line">		popad;</span><br><span class="line">		popfd;</span><br><span class="line">		iretd;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ULONG current = <span class="number">0</span>;<span class="comment">//为了防止打印重复</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">ControlCallBack</span><span class="params">(PDEVICE_OBJECT pDevObj, PIRP pIrp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	PIO_STACK_LOCATION psl = IoGetCurrentIrpStackLocation(pIrp);</span><br><span class="line">	ULONG code = psl-&gt;Parameters.DeviceIoControl.IoControlCode;<span class="comment">//获取派遣过来的CTL操作码</span></span><br><span class="line">	PVOID systemBuf = pIrp-&gt;AssociatedIrp.SystemBuffer;<span class="comment">//获取缓存地址(输入输出都靠这个地址)</span></span><br><span class="line">	ULONG inLen = psl-&gt;Parameters.DeviceIoControl.InputBufferLength;<span class="comment">//获取输入长度</span></span><br><span class="line">	ULONG outLen = psl-&gt;Parameters.DeviceIoControl.OutputBufferLength;<span class="comment">//获取输出长度</span></span><br><span class="line">	UCHAR IDT[<span class="number">6</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	UCHAR GDT[<span class="number">6</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	ULONG IDT_BASE = <span class="number">0</span>;</span><br><span class="line">	ULONG GDT_BASE = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//根据不同的CTL操作码做不同的处理</span></span><br><span class="line">	<span class="keyword">switch</span> (code)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> CODE_CHANGE:<span class="comment">//注意是以三环视角来看其含义，初始化</span></span><br><span class="line">		<span class="comment">//填充中断门描述符</span></span><br><span class="line">		__asm sidt IDT;</span><br><span class="line">		IDT_BASE = *(PULONG)(&amp;IDT[<span class="number">2</span>]); </span><br><span class="line">		DbgPrint(<span class="string">&quot;shellCode地址为:%p\n&quot;</span>, interruptGate);</span><br><span class="line">		ULONG firstPart = (((ULONG)interruptGate) &amp; <span class="number">0xFFFF0000</span>) | <span class="number">0x0000EE00</span>;</span><br><span class="line">		ULONG secondPart = (((ULONG)interruptGate) &amp; <span class="number">0x0000FFFF</span>) | <span class="number">0x00080000</span>;</span><br><span class="line">		DbgPrint(<span class="string">&quot;中断门描述符:%p`%p\n&quot;</span>, firstPart, secondPart);</span><br><span class="line">		*(PULONG)(IDT_BASE + <span class="number">32</span> * <span class="number">8</span>) = secondPart;</span><br><span class="line">		*(PULONG)(IDT_BASE + <span class="number">32</span> * <span class="number">8</span> + <span class="number">4</span>) = firstPart;</span><br><span class="line">		<span class="comment">//填充调用门</span></span><br><span class="line">		__asm sgdt GDT;</span><br><span class="line">		GDT_BASE = *(PULONG)(&amp;GDT[<span class="number">2</span>]);</span><br><span class="line">		ULONG targetAddress = *(ULONG*)systemBuf;<span class="comment">//获取三环传过来的要跳转的函数地址</span></span><br><span class="line">		DbgPrint(<span class="string">&quot;targetAddress:%p\n&quot;</span>, targetAddress);</span><br><span class="line">		ULONG firstPart_gdt = (((ULONG)targetAddress) &amp; <span class="number">0xFFFF0000</span>) | <span class="number">0x0000EC00</span>;</span><br><span class="line">		ULONG secondPart_gdt = (((ULONG)targetAddress) &amp; <span class="number">0x0000FFFF</span>) | <span class="number">0x00080000</span>;</span><br><span class="line">		DbgPrint(<span class="string">&quot;调用门描述符:%p`%p\n&quot;</span>, firstPart_gdt, secondPart_gdt);</span><br><span class="line">		*(PULONG)(GDT_BASE + <span class="number">9</span> * <span class="number">8</span>) = secondPart_gdt;</span><br><span class="line">		*(PULONG)(GDT_BASE + <span class="number">9</span> * <span class="number">8</span> + <span class="number">4</span>) = firstPart_gdt;</span><br><span class="line"><span class="comment">//下面代码想在驱动中修改PTE却发现PTE是0。</span></span><br><span class="line">		<span class="comment">//改变messageBox所在的物理页属性R/W为1</span></span><br><span class="line">		<span class="comment">//判断systemBuf中是否有内容</span></span><br><span class="line">		<span class="comment">//ULONG targetAddress = *(ULONG*)systemBuf;//获取三环传过来的函数地址</span></span><br><span class="line">		<span class="comment">//DbgPrint(&quot;MessageBoxA地址为:%p\n&quot;, messageBoxAAddr);</span></span><br><span class="line">		<span class="comment">//ULONG PDI = (messageBoxAAddr &gt;&gt; 21) &amp; 0x1FF;</span></span><br><span class="line">		<span class="comment">////读取PDE</span></span><br><span class="line">		<span class="comment">//ULONG lowPDE = *(ULONG*)(0xC0601000 + 8 * PDI);</span></span><br><span class="line">		<span class="comment">//ULONG highPDE = *(ULONG*)(0xC0601000 + 8 * PDI +4);</span></span><br><span class="line">		<span class="comment">//DbgPrint(&quot;PDE为:%p`%p\n&quot;, highPDE,lowPDE);</span></span><br><span class="line">		<span class="comment">////读取PTE</span></span><br><span class="line">		<span class="comment">//ULONG PTI= (messageBoxAAddr &gt;&gt; 12)&amp; 0x1FF;</span></span><br><span class="line">		<span class="comment">//ULONG lowPTE = *(ULONG*)(0xC0000000 + 0x1000 * PDI + PTI * 8);</span></span><br><span class="line">		<span class="comment">//ULONG highPTE = *(ULONG*)(0xC0000000+ 0x1000 * PDI + PTI * 8 + 4);</span></span><br><span class="line">		<span class="comment">//DbgPrint(&quot;PTE为:%p`%p\n&quot;, highPTE, lowPTE);</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> CODE_RESUME:<span class="comment">//三环想要反初始化</span></span><br><span class="line">		<span class="comment">//恢复原样</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> CODE_READ:</span><br><span class="line">		<span class="comment">/*DbgPrint(&quot;current ESP:%p\n&quot;, getESP);</span></span><br><span class="line"><span class="comment">		DbgPrint(&quot;param:%p,%p,%p,%p,%p\n&quot;, param[0], param[1], param[2], param[3], param[4]);*/</span></span><br><span class="line">		<span class="keyword">if</span>(param[<span class="number">4</span>]!= current)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">memcpy</span>(systemBuf, param, <span class="number">20</span>);</span><br><span class="line">			pIrp-&gt;IoStatus.Information = <span class="number">20</span>;</span><br><span class="line">			current++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			pIrp-&gt;IoStatus.Information = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	IoCompleteRequest(pIrp, IO_NO_INCREMENT);<span class="comment">//表示调用方已完成所有I/O请求处理操作，并将给定的 IRP 返回给 I/O 管理器。将IRP往下派发</span></span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//入口函数，相当于main函数</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT pdriver, PUNICODE_STRING pReg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//设置一个卸载函数，用于退出</span></span><br><span class="line">	pdriver-&gt;DriverUnload = DriverUnload;</span><br><span class="line">	<span class="comment">//创建设备名称</span></span><br><span class="line">	UNICODE_STRING Devicename;</span><br><span class="line">	RtlInitUnicodeString(&amp;Devicename, <span class="string">L&quot;\\Device\\MyDevice&quot;</span>);</span><br><span class="line">	<span class="comment">//设备对象指针，用于接受</span></span><br><span class="line">	PDEVICE_OBJECT pDeviceObj = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//创建设备</span></span><br><span class="line">	NTSTATUS status = IoCreateDevice(pdriver,<span class="number">0</span>,&amp;Devicename,FILE_DEVICE_UNKNOWN,FILE_DEVICE_SECURE_OPEN,TRUE,&amp;pDeviceObj	);</span><br><span class="line">	<span class="keyword">if</span> (!NT_SUCCESS(status))<span class="comment">//NT_SUCCESS,微软提供的，实际上就是判断status是否大于等于0</span></span><br><span class="line">	&#123;</span><br><span class="line">		DbgPrint(<span class="string">&quot;创建设备失败!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> status;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果前面创建设备对象成功，就设置交互数据的方式</span></span><br><span class="line">	pDeviceObj-&gt;Flags |= DO_BUFFERED_IO;</span><br><span class="line">	<span class="comment">//创建符号链接名称</span></span><br><span class="line">	RtlInitUnicodeString(&amp;SymbolicLinkName, <span class="string">L&quot;\\??\\MyTestDriver&quot;</span>);</span><br><span class="line">	status = IoCreateSymbolicLink(&amp;SymbolicLinkName, &amp;Devicename);</span><br><span class="line">	<span class="keyword">if</span> (!NT_SUCCESS(status))</span><br><span class="line">	&#123;</span><br><span class="line">		DbgPrint(<span class="string">&quot;创建符号链接失败!\n&quot;</span>);</span><br><span class="line">		IoDeleteDevice(pDeviceObj);<span class="comment">//删除设备</span></span><br><span class="line">		<span class="keyword">return</span> status;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置派遣函数   </span></span><br><span class="line">	pdriver-&gt;MajorFunction[IRP_MJ_CREATE] = MyCreateDispatchFunction;</span><br><span class="line">	pdriver-&gt;MajorFunction[IRP_MJ_CLOSE] = MyCloseDispatchFunction;</span><br><span class="line">	pdriver-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = ControlCallBack;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="R3代码"><a href="#R3代码" class="headerlink" title="R3代码"></a>R3代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;WinIoCtl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE_CHANGE CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,METHOD_BUFFERED,FILE_ANY_ACCESS)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE_RESUME CTL_CODE(FILE_DEVICE_UNKNOWN,0x900,METHOD_BUFFERED,FILE_ANY_ACCESS)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE_READ CTL_CODE(FILE_DEVICE_UNKNOWN,0x1000,METHOD_BUFFERED,FILE_ANY_ACCESS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打开设备</span></span><br><span class="line"><span class="function">BOOLEAN <span class="title">openDevice</span><span class="params">(HANDLE *handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HANDLE _handle = CreateFileA(<span class="string">&quot;\\\\.\\MyTestDriver&quot;</span>, GENERIC_READ | GENERIC_WRITE, <span class="number">0</span>, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);<span class="comment">//打开设备对象句柄</span></span><br><span class="line">	*handle = _handle;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">int</span>)_handle &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送IRP_MJ_DEVICE_CONTROL</span></span><br><span class="line"><span class="function">BOOLEAN <span class="title">sendCode</span><span class="params">(HANDLE hDevice, DWORD code, PVOID inData, ULONG Inlen, PVOID outData, ULONG outLen, LPDWORD resultLen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> DeviceIoControl(hDevice, code, inData, Inlen, outData, outLen, resultLen, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DWORD lowPDE,lowPTE;</span><br><span class="line">DWORD highPDE,highPTE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __declspec(naked) callGate()</span><br><span class="line">&#123;</span><br><span class="line">	_asm</span><br><span class="line">	&#123;</span><br><span class="line">		pushfd;</span><br><span class="line">		pushad;</span><br><span class="line">		mov ecx,dword ptr ds:[MessageBoxA];</span><br><span class="line">		<span class="comment">//get pde</span></span><br><span class="line">		mov eax,ecx;</span><br><span class="line">		shr eax,<span class="number">21</span>;</span><br><span class="line">		<span class="keyword">and</span> eax,<span class="number">0x1FF</span>;</span><br><span class="line">		shl eax,<span class="number">3</span>;</span><br><span class="line">		mov edx,dword ptr ds:[<span class="number">0xC0601000</span>+eax];</span><br><span class="line">		mov dword ptr ds:[lowPDE],edx;</span><br><span class="line">		mov edx,dword ptr ds:[<span class="number">0xC0601000</span>+eax+<span class="number">4</span>];</span><br><span class="line">		mov dword ptr ds:[highPDE],edx;</span><br><span class="line">		<span class="comment">//get pte</span></span><br><span class="line">		mov eax,ecx;</span><br><span class="line">		shr eax,<span class="number">12</span>;</span><br><span class="line">		<span class="keyword">and</span> eax,<span class="number">0xFFFFF</span>;</span><br><span class="line">		shl eax,<span class="number">3</span>;</span><br><span class="line">		mov edi,dword ptr ds:[<span class="number">0xC0000000</span>+eax];</span><br><span class="line">		mov dword ptr ds:[lowPTE],edi;</span><br><span class="line">		mov edx,dword ptr ds:[<span class="number">0xC0000000</span>+eax+<span class="number">4</span>];</span><br><span class="line">		mov dword ptr ds:[highPTE],edx;</span><br><span class="line">		<span class="comment">//change R/W in PDE</span></span><br><span class="line">		<span class="keyword">or</span> edi,<span class="number">0x2</span>;</span><br><span class="line">		mov dword ptr ds:[<span class="number">0xC0000000</span>+eax],edi</span><br><span class="line">		popad;</span><br><span class="line">		popfd;</span><br><span class="line">		retf;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// MessageBoxA 挂物理页，不这样操作，MessageBoxA的PTE可能是无效的</span></span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		mov eax, dword ptr ds:[MessageBoxA];</span><br><span class="line">		mov eax,[eax];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;MessageBoxA address:%p\n&quot;</span>,MessageBoxA);</span><br><span class="line">	HANDLE hDevice;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">30</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	DWORD realReaded = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!openDevice(&amp;hDevice))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;打开设备对象失败!\r\n&quot;</span>);</span><br><span class="line">		system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	*(DWORD*)buf=(DWORD)callGate;</span><br><span class="line">	sendCode(hDevice, CODE_CHANGE, buf, <span class="number">30</span>, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;realReaded);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;callGate address:%p\n&quot;</span>,callGate);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">char</span> callCallgate[<span class="number">6</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x48</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	_asm</span><br><span class="line">	&#123;</span><br><span class="line">		call fword ptr[callCallgate];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;PDE:%p`%p\n&quot;</span>,highPDE,lowPDE);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;PTE:%p`%p\n&quot;</span>,highPTE,lowPTE);</span><br><span class="line">	<span class="comment">//hook MessageBoxA</span></span><br><span class="line">	<span class="keyword">char</span> hookContent[<span class="number">2</span>]=&#123;<span class="number">0xCD</span>,<span class="number">0x20</span>&#125;;</span><br><span class="line">	<span class="built_in">memcpy</span>(MessageBoxA,hookContent,<span class="number">2</span>);</span><br><span class="line">	<span class="comment">//hook succeed!</span></span><br><span class="line">	<span class="comment">//get R0 info from MessageBoxA</span></span><br><span class="line">	DWORD current=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		sendCode(hDevice, CODE_READ, <span class="literal">NULL</span>, <span class="number">0</span>, buf, <span class="number">30</span>, &amp;realReaded);</span><br><span class="line">		DWORD* p=(DWORD*)buf;</span><br><span class="line">		<span class="keyword">if</span>(realReaded&gt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;No.%d MessageBoxA(%p,%p,%p,%p)\n&quot;</span>,p[<span class="number">4</span>],p[<span class="number">0</span>],p[<span class="number">1</span>],p[<span class="number">2</span>],p[<span class="number">3</span>]);</span><br><span class="line">			current++;</span><br><span class="line">		&#125;</span><br><span class="line">		Sleep(<span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	CloseHandle(hDevice);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成功监听MessageBoxA结果：</p>
<p><img src="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20210830211435935.png" alt="image-20210830211435935"></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41875267/article/details/109692389">别人的代码参考</a></p>
<h3 id="重难点"><a href="#重难点" class="headerlink" title="重难点"></a>重难点</h3><ul>
<li>跟界面相关的API永远都是<strong>懒加载</strong>的，即没调用不加载，物理页不会挂上去。</li>
<li>但是OpenProcess这种，他自己事先就加载好了，挂上了物理页。</li>
</ul>
<h2 id="Inline-Hook"><a href="#Inline-Hook" class="headerlink" title="Inline Hook"></a>Inline Hook</h2><p>与R3的Inline Hook完全一样</p>
<p>位置的选择：</p>
<ol>
<li>JMP/CALL指令至少占用5个字节</li>
<li>绕开全局变量（每次的全局变量位置是不确定，因为模块加载的顺序不一致）</li>
<li>根据业务来决定在哪里HOOK，过滤参数？修改返回结果？</li>
</ol>
<p>思考：</p>
<ol>
<li>正在hook的瞬间，如何保证多核切换的稳定性</li>
<li>如何绕过硬编码校验检测内联HOOK</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/blog/tags/%E5%86%85%E6%A0%B8%E7%9B%B8%E5%85%B3/" rel="tag"># 内核相关</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/blog/2020/12/23/C%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/" rel="prev" title="C语言入门">
      <i class="fa fa-chevron-left"></i> C语言入门
    </a></div>
      <div class="post-nav-item">
    <a href="/blog/2021/12/05/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/" rel="next" title="进程与线程">
      进程与线程 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91"><span class="nav-number">1.</span> <span class="nav-text">驱动开发</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="nav-number">1.1.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PDB%EF%BC%88Program-Debug-Database%EF%BC%89"><span class="nav-number">1.2.</span> <span class="nav-text">PDB（Program Debug Database）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.3.</span> <span class="nav-text">第一个驱动程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="nav-number">1.4.</span> <span class="nav-text">内核编程基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8API%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.4.1.</span> <span class="nav-text">内核API的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AA%E5%AF%BC%E5%87%BA%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.4.2.</span> <span class="nav-text">未导出函数的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.4.3.</span> <span class="nav-text">基本数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">1.4.4.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">1.4.5.</span> <span class="nav-text">内核函数中的异常处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E5%86%85%E6%A0%B8%E5%86%85%E5%AD%98%E5%87%BD%E6%95%B0"><span class="nav-number">1.4.6.</span> <span class="nav-text">常用的内核内存函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%A7%8D%E7%B1%BB"><span class="nav-number">1.4.7.</span> <span class="nav-text">内核字符串种类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E5%85%B6%E4%BB%96%E5%86%85%E6%A0%B8API%E5%87%BD%E6%95%B0"><span class="nav-number">1.4.8.</span> <span class="nav-text">常用的其他内核API函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IRQL%E4%B8%AD%E6%96%AD%E8%AF%B7%E6%B1%82%E7%BA%A7%E5%88%AB"><span class="nav-number">1.4.9.</span> <span class="nav-text">IRQL中断请求级别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A9%B1%E5%8A%A8%E5%86%85%E6%A0%B8%E6%A1%86%E6%9E%B6"><span class="nav-number">1.4.10.</span> <span class="nav-text">驱动内核框架</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Windows%E7%9A%84%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B%E5%8F%98%E8%BF%81"><span class="nav-number">1.4.10.1.</span> <span class="nav-text">Windows的驱动开发模型变迁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%BB%E8%A6%81%E8%B0%83%E7%94%A8%E6%BA%90%EF%BC%9A"><span class="nav-number">1.4.10.2.</span> <span class="nav-text">内核编程的主要调用源：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7"><span class="nav-number">1.4.10.3.</span> <span class="nav-text">函数的多线程安全性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B8%AD%E6%96%AD%E7%BA%A7"><span class="nav-number">1.4.10.4.</span> <span class="nav-text">代码的中断级</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WDK%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E7%89%B9%E6%AE%8A%E4%BB%A3%E7%A0%81"><span class="nav-number">1.4.10.5.</span> <span class="nav-text">WDK中出现的特殊代码</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#IN%E5%92%8COUT"><span class="nav-number">1.4.10.5.1.</span> <span class="nav-text">IN和OUT</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#pragma-alloc-text"><span class="nav-number">1.4.10.5.2.</span> <span class="nav-text">#pragma alloc_text</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97"><span class="nav-number">1.5.</span> <span class="nav-text">内核空间与内核模块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4"><span class="nav-number">1.5.1.</span> <span class="nav-text">内核空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97"><span class="nav-number">1.5.2.</span> <span class="nav-text">内核模块</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#DRIVER-OBJECT%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">DRIVER_OBJECT结构体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LDR-DATA-TABLE-ENTRY%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">_LDR_DATA_TABLE_ENTRY结构体</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E4%BD%9C%E4%B8%9A"><span class="nav-number">1.5.3.</span> <span class="nav-text">遍历内核模块作业</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A9%B1%E5%8A%A8%E9%94%AE%E9%BC%A0%E8%BF%87%E6%BB%A4"><span class="nav-number">1.5.4.</span> <span class="nav-text">驱动键鼠过滤</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%B6%E7%8E%AF%E4%B8%8E%E4%B8%89%E7%8E%AF%E9%80%9A%E4%BF%A1-%E5%B8%B8%E8%A7%84%E6%96%B9%E5%BC%8F"><span class="nav-number">1.6.</span> <span class="nav-text">零环与三环通信(常规方式)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%AE%BE%E5%A4%87%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.6.1.</span> <span class="nav-text">创建设备对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">设备对象结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IoCreateDevice"><span class="nav-number">1.6.1.2.</span> <span class="nav-text">IoCreateDevice</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E8%AE%BE%E5%A4%87%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.6.2.</span> <span class="nav-text">删除设备对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E4%BA%A4%E4%BA%92%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">1.6.3.</span> <span class="nav-text">设置交互数据的方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%8D%B8%E8%BD%BD%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5"><span class="nav-number">1.6.4.</span> <span class="nav-text">创建与卸载符号链接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IRP%E4%B8%8E%E6%B4%BE%E9%81%A3%E5%87%BD%E6%95%B0"><span class="nav-number">1.6.5.</span> <span class="nav-text">IRP与派遣函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#IRP%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.6.5.1.</span> <span class="nav-text">IRP类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B4%BE%E9%81%A3%E5%87%BD%E6%95%B0"><span class="nav-number">1.6.5.2.</span> <span class="nav-text">派遣函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B4%BE%E9%81%A3%E5%87%BD%E6%95%B0%E5%9C%A8%E5%93%AA%E9%87%8C%E6%B3%A8%E5%86%8C%E5%91%A2%EF%BC%9F"><span class="nav-number">1.6.5.2.1.</span> <span class="nav-text">派遣函数在哪里注册呢？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C%E6%B4%BE%E9%81%A3%E5%87%BD%E6%95%B0"><span class="nav-number">1.6.5.2.2.</span> <span class="nav-text">注册派遣函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B4%BE%E9%81%A3%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="nav-number">1.6.5.3.</span> <span class="nav-text">派遣函数的格式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#IRP-MJ-DEVICE-CONTROL%E7%9A%84%E6%B4%BE%E9%81%A3%E5%87%BD%E6%95%B0"><span class="nav-number">1.6.5.3.1.</span> <span class="nav-text">IRP_MJ_DEVICE_CONTROL的派遣函数</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#CTL%E6%93%8D%E4%BD%9C%E7%A0%81"><span class="nav-number">1.6.5.3.1.1.</span> <span class="nav-text">CTL操作码</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#IRP-MJ-DEVICE-CONTROL%E7%9A%84%E6%B4%BE%E9%81%A3%E5%87%BD%E6%95%B0%E7%BC%96%E5%86%99"><span class="nav-number">1.6.5.3.1.2.</span> <span class="nav-text">IRP_MJ_DEVICE_CONTROL的派遣函数编写</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%89%E7%8E%AF%E5%86%99%E6%B3%95"><span class="nav-number">1.6.5.3.1.3.</span> <span class="nav-text">三环写法</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87IRP-MJ-DEVICE-CONTROL%E4%BA%A4%E4%BA%92%E6%95%B0%E6%8D%AE%E5%AE%9E%E9%AA%8C"><span class="nav-number">1.6.6.</span> <span class="nav-text">通过IRP_MJ_DEVICE_CONTROL交互数据实验</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#R0%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="nav-number">1.6.6.1.</span> <span class="nav-text">R0代码：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#R3%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="nav-number">1.6.6.2.</span> <span class="nav-text">R3代码：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A9%B1%E5%8A%A8%E5%8A%A0%E8%BD%BD"><span class="nav-number">1.7.</span> <span class="nav-text">驱动加载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A9%B1%E5%8A%A8%E6%B3%A8%E5%86%8C-%E5%AE%89%E8%A3%85"><span class="nav-number">1.7.1.</span> <span class="nav-text">驱动注册&#x2F;安装</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#OpenSCManagerA%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.1.1.</span> <span class="nav-text">OpenSCManagerA函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%9C%8D%E5%8A%A1CreateServiceA%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.1.2.</span> <span class="nav-text">创建服务CreateServiceA函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A9%B1%E5%8A%A8%E5%90%AF%E5%8A%A8"><span class="nav-number">1.7.2.</span> <span class="nav-text">驱动启动</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%93%E5%BC%80%E6%9C%8D%E5%8A%A1OpenServiceA%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.2.1.</span> <span class="nav-text">打开服务OpenServiceA函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%80%E5%A7%8B%E6%9C%8D%E5%8A%A1StartServiceA%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.2.2.</span> <span class="nav-text">开始服务StartServiceA函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%81%9C%E6%AD%A2%E9%A9%B1%E5%8A%A8"><span class="nav-number">1.7.3.</span> <span class="nav-text">停止驱动</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E6%9C%8D%E5%8A%A1ControlService%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.3.1.</span> <span class="nav-text">控制服务ControlService函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%B8%E8%BD%BD%E9%A9%B1%E5%8A%A8"><span class="nav-number">1.7.4.</span> <span class="nav-text">卸载驱动</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E7%9B%91%E5%90%ACAPI%E5%AE%9E%E9%AA%8C"><span class="nav-number">1.8.</span> <span class="nav-text">全局监听API实验</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#R0%E4%BB%A3%E7%A0%81"><span class="nav-number">1.8.1.</span> <span class="nav-text">R0代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#R3%E4%BB%A3%E7%A0%81"><span class="nav-number">1.8.2.</span> <span class="nav-text">R3代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E9%9A%BE%E7%82%B9"><span class="nav-number">1.8.3.</span> <span class="nav-text">重难点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Inline-Hook"><span class="nav-number">1.9.</span> <span class="nav-text">Inline Hook</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ZEROKO14</p>
  <div class="site-description" itemprop="description">你好，欢迎来到ZEROKO14的个人博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZEROKO14</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>-->

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/muse.js"></script>


<script src="/blog/js/next-boot.js"></script>


  <script defer src="/blog/lib/three/three.min.js"></script>
    <script defer src="/blog/lib/three/three-waves.min.js"></script>


  















  

  

</body>
</html>
