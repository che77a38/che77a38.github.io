<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zeroko14.gitee.io","root":"/blog/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="32位游戏逆向经验">
<meta property="og:type" content="article">
<meta property="og:title" content="32位逆向">
<meta property="og:url" content="http://zeroko14.gitee.io/blog/2021/12/05/32%E4%BD%8D%E9%80%86%E5%90%91/index.html">
<meta property="og:site_name" content="ZEROKO14的个人博客">
<meta property="og:description" content="32位游戏逆向经验">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200603164550546.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200603164753061.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200603170343620.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200603172032838.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200603172228215.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200604134014792.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200609152105778.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200609161113905.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200606165410225.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200609164617116.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200609171928839.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200610115440267.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200610140531244.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200610144038590.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200619203613803.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200612142353797.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200612142702850.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200612162228639.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200612162542084.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200612163010995.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200616114841882.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200616121616564.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200616121652661.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200616123037380.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200616124233780.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200616125251278.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200617140130766.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200617123047040.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200617130410963.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200617173409222.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200618105542581.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200618124459759.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200618121851520.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200618121807662.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200618121940617.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200618150730099.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200618150751691.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200618151416145.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200619200502840.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200618174812697.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200619114555309.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200619121515351.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200619143158127.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200619190705774.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200619191343990.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200619191918680.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200619193746843.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200619200020569.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200527130037272.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200527131220102.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200527132100884.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200527135319069.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200527140538839.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200527142213922.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200527154018241.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200527170418581.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200528140218927.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200530123037751.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200530123208857.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200530124227755.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200530124751654.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200530131542117.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200617150015519.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200623115813014.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200623125915308.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200623134251855.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200628115800117.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200628120134118.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200629131032241.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200629151827052.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200629171419862.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200629180635247.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200629181014255.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200629181034665.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200630180024957.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200630183041901.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200630190413663.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200701142941429.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200701145906136.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200701151102938.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200701154135148.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200701164710276.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200703123124781.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200703123901382.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200703133334276.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200703134009568.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200703134243403.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200703134336551.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200703134417594.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200703134645865.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200703134718333.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200703134929816.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200703135805836.png">
<meta property="article:published_time" content="2021-12-05T06:15:09.000Z">
<meta property="article:modified_time" content="2022-03-26T14:11:44.518Z">
<meta property="article:author" content="ZEROKO14">
<meta property="article:tag" content="逆向">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200603164550546.png">

<link rel="canonical" href="http://zeroko14.gitee.io/blog/2021/12/05/32%E4%BD%8D%E9%80%86%E5%90%91/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>32位逆向 | ZEROKO14的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ZEROKO14的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">zeroko14's blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zeroko14.gitee.io/blog/2021/12/05/32%E4%BD%8D%E9%80%86%E5%90%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="ZEROKO14">
      <meta itemprop="description" content="你好，欢迎来到ZEROKO14的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZEROKO14的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          32位逆向
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-05 14:15:09" itemprop="dateCreated datePublished" datetime="2021-12-05T14:15:09+08:00">2021-12-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-26 22:11:44" itemprop="dateModified" datetime="2022-03-26T22:11:44+08:00">2022-03-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>32位游戏逆向经验</p>
<span id="more"></span>

<h1 id="口袋西游实战"><a href="#口袋西游实战" class="headerlink" title="口袋西游实战"></a>口袋西游实战</h1><h2 id="数组：追背包数量"><a href="#数组：追背包数量" class="headerlink" title="数组：追背包数量"></a>数组：追背包数量</h2><p>背包小血药地址：2A935D64</p>
<p>小血药数量地址=[[eax+ebx*4]+14]</p>
<p>此处继续追eax，ebx==5表示背包中第六个格子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0048580F  |.  8B7424 1C     mov     esi, dword ptr [esp+1C]          ;  小血药数量地址=[[[[esp+1c]+C]+5*4]+14]</span><br></pre></td></tr></table></figure>



<p>小血药数量地址=[[[[ecx+AD8]+C]+5*4]+14]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">006522D1  |.  8B4C85 1C     |mov     ecx, dword ptr [ebp+eax*4+1C]   ;  小血药数量地址=[[[[[[ebp+eax*4+1C]+8]+28]+0AD8]+C]+5*4]+14</span><br></pre></td></tr></table></figure>

<p>此处eax为某种数组</p>
<p>小血药数量地址=[[[[[[[[[[ecx+1c]+68]+4]+8]+1<em>4+1C]+8]+28]+0AD8]+C]+5</em>4]+14</p>
<p>ecx==00D11A50(是个基地址)</p>
<h2 id="万能控件call"><a href="#万能控件call" class="headerlink" title="万能控件call"></a>万能控件call</h2><h6 id="背包开关状态内存地址"><a href="#背包开关状态内存地址" class="headerlink" title="背包开关状态内存地址:"></a>背包开关状态内存地址:</h6><p>14411820</p>
<h6 id="改写代码："><a href="#改写代码：" class="headerlink" title="改写代码："></a>改写代码：</h6><p>008DC7FE - C6 86 90000000 01 - mov byte ptr [esi+00000090],01<br>008DC83B - C6 86 90000000 00 - mov byte ptr [esi+00000090],00</p>
<p>调用堆栈：     主线程<br>地址       堆栈       函数过程 / 参数                       调用来自                      结构<br>0019EFD8   00903DA3   ? ELEMENTC.008DC600                   ELEMENTC.00903D9E</p>
<h6 id="万能控件call位置"><a href="#万能控件call位置" class="headerlink" title="万能控件call位置"></a>万能控件call位置</h6><p>0062968E   &gt; \53            push    ebx                         ;  a 001E0001 s 001f0001  d 00200001 i 00170001 o 00180001  b 002F0001<br>0062968F   .  55            push    ebp                         ;  41大写A键码  61小写a键码<br>00629690   .  50            push    eax                         ;  00000100按下标志  102弹起标志<br>00629691   .  8BCE          mov     ecx, esi                    ;  24B76E98 里：00BF84AC  1563B300（追上去疑似二叉树）<br>00629693   .  E8 58000000   call    006296F0                    ;  万能控件call</p>
<h6 id="万能控件call-1"><a href="#万能控件call-1" class="headerlink" title="万能控件call"></a>万能控件call</h6><p>push 002F0001<br>push 42<br>push 100<br>mov ecx,24B76E98<br>call 006296F0</p>
<p>push  002F0001<br>push 42<br>push 102<br>mov ecx,24B76E98<br>call 006296F0</p>
<p>00E76804</p>
<h1 id="创建带对话框的MFC-DLL"><a href="#创建带对话框的MFC-DLL" class="headerlink" title="创建带对话框的MFC DLL"></a>创建带对话框的MFC DLL</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">CMydllApp theApp;</span><br><span class="line">MainDialog a;<span class="comment">//新建的MainDialog类，继承自CDialog</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CMydllApp 初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> WINAPI <span class="title">ShowDialog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">AFX_MANAGE_STATE</span>(<span class="built_in">AfxGetStaticModuleState</span>());</span><br><span class="line">	<span class="built_in">OutputDebugStringA</span>(<span class="string">&quot;测试，Mydll准备显示窗口&quot;</span>);</span><br><span class="line">	a.<span class="built_in">DoModal</span>();</span><br><span class="line">	<span class="built_in">OutputDebugStringA</span>(<span class="string">&quot;测试，Mydll准备退出自身dll&quot;</span>);</span><br><span class="line">	<span class="built_in">FreeLibraryAndExitThread</span>(theApp.m_hInstance,<span class="number">123456</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">CMydllApp::InitInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CWinApp::<span class="built_in">InitInstance</span>();</span><br><span class="line">	<span class="built_in">OutputDebugStringA</span>(<span class="string">&quot;测试，Mydll在运作创建线程&quot;</span>);</span><br><span class="line">	::<span class="built_in">CreateThread</span>(<span class="number">0</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)ShowDialog, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="幻想神域"><a href="#幻想神域" class="headerlink" title="幻想神域"></a>幻想神域</h1><h2 id="追血量数据来源找人物对象数组"><a href="#追血量数据来源找人物对象数组" class="headerlink" title="追血量数据来源找人物对象数组"></a>追血量数据来源找人物对象数组</h2><p>CE寻到血量地址为：15A0D808  000001F4</p>
<p>下访问断，打开人物对话框，断下位置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">009A389E    8378 08 00      cmp dword ptr ds:[eax+0x8],0x0           ; 血量地址==eax+0x8</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>向上追：</p>
<p> 追到此处发现:</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200603164550546.png" alt="image-20200603164550546"></p>
<p>血量地址==[eax+0c]+0x8，这里的eax为call 00665847的返回值，追参数来源如图</p>
<p>代码注入器如下代码可获得血量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov ecx,[0F84B74]</span><br><span class="line">mov eax,[ecx+40c]</span><br><span class="line">add ecx,410</span><br><span class="line">push eax</span><br><span class="line">call 00665870</span><br><span class="line">mov eax,[eax+0c]</span><br><span class="line">mov eax,[eax+0x8]</span><br><span class="line">mov [00178004],eax</span><br></pre></td></tr></table></figure>

<p>00178004地址确实是血的结果如下：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200603164753061.png" alt="image-20200603164753061"></p>
<p>继续进该call追，发现问题所在</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200603170343620.png" alt="image-20200603170343620"></p>
<p>ebp-4表示局部变量，局部变量在本层call中未改变，说明ebp-4来源于内部call中，经单步观察是来源于0066588b地址这个call中。内部call想改变外部call只可能是通过指针的方式传进去内部call改变</p>
<p>简单分析：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200603172032838.png" alt="image-20200603172032838"></p>
<p>call内继续往上追：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200603172228215.png" alt="image-20200603172228215"></p>
<p>追到一个循环结构，应该是某种数据结构。然后发现该循环结构只是决定于ebx套几层循环，事实上是ebx不做任何改变也能dd出血地址，因此直接略过该循环结构。</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200604134014792.png" alt="image-20200604134014792"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">008A555B  |.  8B5CD8 04     mov     ebx, dword ptr [eax+ebx*8+4]     ;  血量地址==[[[eax+ebx*8+4]+0c]+0c]+8==15A0D808</span><br></pre></td></tr></table></figure>

<p>此时，ebx为数组下标，此处ebx==4E或ebx==34都可以dd出血地址，此处的ebx并不是连续的，因此此处的ebx疑似加密的数组下标</p>
<p>一路向上追，最终结果是：<br>$$<br>血量地址==[[[[[0F84B74]+424]+34*8+4]+0c]+0c]+8<br>$$<br>回到前面的ebx出继续追加密数组下标来源：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">加密数组下标EBX==([[[0F84B74]+40C]*41+[[0F84B74]+40C]/4+9e3779b9]&amp;[[0F84B74]+410+20])*2</span><br></pre></td></tr></table></figure>

<p>因为血量地址==[[[[[0F84B74]+424]+34*8+4]+0c]+0c]+8</p>
<p>通过ce设置区间搜索发现其他数据结构分析：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200609152105778.png" alt="image-20200609152105778"></p>
<p>对象+8   ID<br>[对象+C]+8     血量<br>[对象+C]+10    当前等级<br>[对象+C]+18    移动速度<br>[对象+C]+24     最大血量<br>[对象+C]+30     暴击伤害<br>[对象+C]+34     命中率<br>[对象+C]+38     治疗比例<br>[对象+C]+68     经验<br>[对象+C]+27C    剩余攻击点数<br>[对象+C]+280     剩余防御点数<br>[对象+10]+154    X<br>[对象+10]+158    Y<br>[对象+10]+15C    Z</p>
<p>读取人物信息代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">__try</span><br><span class="line">&#123;</span><br><span class="line">	DWORD 人物对象 = <span class="number">0</span>;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		mov ecx, <span class="number">0x0F84B74</span></span><br><span class="line">		mov ecx, [ecx]</span><br><span class="line">			mov eax, [ecx + <span class="number">0x40c</span>]</span><br><span class="line">			add ecx, <span class="number">0x410</span></span><br><span class="line">			push eax</span><br><span class="line">			mov eax, <span class="number">0x00665870</span></span><br><span class="line">			call eax</span><br><span class="line">			mov 人物对象, eax</span><br><span class="line">	&#125;</span><br><span class="line">	DWORD 人物属性 = *(DWORD *)(人物对象 + <span class="number">0x0c</span>);</span><br><span class="line">	d血量 = *(DWORD *)(人物属性 + <span class="number">0x8</span>);</span><br><span class="line">	d最大血量 = *(DWORD *)(人物属性 + <span class="number">0x24</span>);</span><br><span class="line">	d当前等级 = *(DWORD *)(人物属性 + <span class="number">0x10</span>);</span><br><span class="line">	DWORD 坐标信息 = *(DWORD *)(人物对象 + <span class="number">0x10</span>);</span><br><span class="line">	fX = *(FLOAT *)(坐标信息 + <span class="number">0x154</span>);</span><br><span class="line">	fY = *(FLOAT *)(坐标信息 + <span class="number">0x158</span>);</span><br><span class="line">	fZ = *(FLOAT *)(坐标信息 + <span class="number">0x15c</span>);</span><br><span class="line">&#125;</span><br><span class="line">__except (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	Call_输出调试信息(<span class="string">&quot;幻想神域   读取人物信息出错！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h3><p>因为数组为EBX*8，可知这个数组每项隔8</p>
<p>分析可知，[[0F84B74]+424为数组头指针</p>
<p>数组的开始结束标志位一般是数组头指针的+4偏移地址里存的数组尾，od中观察确实[[0F84B74]+424与[[0F84B74]+428地址中存的是比较接近的一个地址。</p>
<p>发现部分情况下数组当前项对象有时候会为0，if判断跳过这些情况</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">T数组信息遍历 t;</span><br><span class="line">	t.初始化对象信息();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;(<span class="keyword">int</span>)t.d数量;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Call_输出调试信息(<span class="string">&quot;幻想神域    血量:%d/%d   当前等级:%d   坐标：（%f，%f，%f）&quot;</span>, t.对象信息[i].d血量, t.对象信息[i].d最大血量, t.对象信息[i].d当前等级, t.对象信息[i].fX, t.对象信息[i].fY, t.对象信息[i].fZ);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> T数组信息遍历::初始化对象信息()</span><br><span class="line">&#123;</span><br><span class="line">	__try</span><br><span class="line">	&#123;</span><br><span class="line">		DWORD 基地址中 = *(DWORD*)<span class="number">0x0F84B74</span>;</span><br><span class="line">		DWORD 数组头 = *(DWORD*)(基地址中 + <span class="number">0x424</span>);</span><br><span class="line">		DWORD 数组尾 = *(DWORD*)(基地址中 + <span class="number">0x428</span>);</span><br><span class="line">		d数量 = (数组尾 - 数组头)/<span class="number">8</span>;</span><br><span class="line">		<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;d数量;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			DWORD 当前数组项= *(DWORD*)(数组头 + i*<span class="number">8</span>+<span class="number">4</span>);</span><br><span class="line">			DWORD 当前对象= *(DWORD*)(当前数组项 +<span class="number">0x0c</span>);</span><br><span class="line">			<span class="keyword">if</span> (当前对象!=<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				sum++;</span><br><span class="line">				DWORD 人物属性 = *(DWORD *)(当前对象 + <span class="number">0x0c</span>);</span><br><span class="line">				对象信息[i].d血量 = *(DWORD *)(人物属性 + <span class="number">0x8</span>);</span><br><span class="line">				对象信息[i].d最大血量 = *(DWORD *)(人物属性 + <span class="number">0x24</span>);</span><br><span class="line">				对象信息[i].d当前等级 = *(DWORD *)(人物属性 + <span class="number">0x10</span>);</span><br><span class="line">				DWORD 坐标信息 = *(DWORD *)(当前对象 + <span class="number">0x10</span>);</span><br><span class="line">				对象信息[i].fX = *(FLOAT *)(坐标信息 + <span class="number">0x154</span>);</span><br><span class="line">				对象信息[i].fY = *(FLOAT *)(坐标信息 + <span class="number">0x158</span>);</span><br><span class="line">				对象信息[i].fZ = *(FLOAT *)(坐标信息 + <span class="number">0x15c</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		d数量 = sum;</span><br><span class="line">	&#125;</span><br><span class="line">	__except (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Call_输出调试信息(<span class="string">&quot;幻想神域   数组信息遍历出错！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调试效果如下：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200609161113905.png" alt="image-20200609161113905"></p>
<p>无法确定这个数组是存的什么数据。。。</p>
<h2 id="追血量来源找对象结构链表"><a href="#追血量来源找对象结构链表" class="headerlink" title="追血量来源找对象结构链表"></a>追血量来源找对象结构链表</h2><p>上面是打开人物属性对话框断下的位置，此处通过选中自身访问自己的血量来断下血量数据内存上下的访问断。因为选中单位这个cal涉及到所有对象，因此t通过过这个找到的血量基地址加偏移应该蕴含对象结构的关系。</p>
<p>依然是先用ce找到血量地址：307CD808  000003B1</p>
<p>断下好几个位置，反复运行发现只要一直选中自己就一直断下一个位置上，即此处：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00669A1A  |.  DB40 08       fild    dword ptr [eax+8]  ;  </span><br></pre></td></tr></table></figure>

<p>往上追到了一个数据结构处，如下：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200606165410225.png" alt="image-20200606165410225"></p>
<p>可以发现这是一个链表，循环多少次决定了要把esi换成几层[esi]。</p>
<p>在未进循环之前dd每种情况发现本人的血地址只要套一层[esi]即可跳出循环，</p>
<p>继续向上追得到基地址加偏移：<br>$$<br>血地址==[[[[[[0F84B74]+410+8]]]+0c]+0c]+8<br>$$<br>分析结构：</p>
<p>$$<br>[[[0F84B74]+410+8]]=链表头<br>$$<br>链表入口套几层[]，代表不同的对象，其中[链表头]代表本人对象</p>
<p>找出口分析如下：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200609164617116.png" alt="image-20200609164617116"><br>$$<br>当前链表=[[[0F84B74]+410+8]]套几层循环==[[0F84B74]+410+8]的时候跳出循环<br>$$<br>遍历链表代码如下：</p>
<p>调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">T链表信息遍历 t;</span><br><span class="line">	t.初始化对象信息();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)t.d数量; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Call_输出调试信息(<span class="string">&quot;幻想神域    血量:%d/%d   当前等级:%d   坐标：（%f，%f，%f）&quot;</span>, t.对象信息[i].d血量, t.对象信息[i].d最大血量, t.对象信息[i].d当前等级, t.对象信息[i].fX, t.对象信息[i].fY, t.对象信息[i].fZ);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>结构：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T</span>链表信息遍历</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	T人物信息 对象信息[<span class="number">1000</span>];</span><br><span class="line">	DWORD d数量;</span><br><span class="line">	<span class="keyword">void</span> 初始化对象信息();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结构中初始化函数的实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> T链表信息遍历::初始化对象信息()</span><br><span class="line">&#123;</span><br><span class="line">	__try</span><br><span class="line">	&#123;</span><br><span class="line">		DWORD 基地址中 = *(DWORD*)<span class="number">0x0F84B74</span>;</span><br><span class="line">		DWORD tmp = *(DWORD*)(基地址中 + <span class="number">0x418</span>);</span><br><span class="line">		DWORD 链表头 = *(DWORD*)(tmp);</span><br><span class="line">		DWORD 当前链表 = *(DWORD*)(tmp);</span><br><span class="line">		<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (; 当前链表!=tmp; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			DWORD 当前对象 = *(DWORD*)(当前链表+<span class="number">0x0c</span>);</span><br><span class="line"></span><br><span class="line">			DWORD 人物属性 = *(DWORD *)(当前对象 + <span class="number">0x0c</span>);</span><br><span class="line">			对象信息[i].d血量 = *(DWORD *)(人物属性 + <span class="number">0x8</span>);</span><br><span class="line">			对象信息[i].d最大血量 = *(DWORD *)(人物属性 + <span class="number">0x24</span>);</span><br><span class="line">			对象信息[i].d当前等级 = *(DWORD *)(人物属性 + <span class="number">0x10</span>);</span><br><span class="line">			DWORD 坐标信息 = *(DWORD *)(当前对象 + <span class="number">0x10</span>);</span><br><span class="line">			对象信息[i].fX = *(FLOAT *)(坐标信息 + <span class="number">0x154</span>);</span><br><span class="line">			对象信息[i].fY = *(FLOAT *)(坐标信息 + <span class="number">0x158</span>);</span><br><span class="line">			对象信息[i].fZ = *(FLOAT *)(坐标信息 + <span class="number">0x15c</span>);</span><br><span class="line"></span><br><span class="line">			当前链表 = *(DWORD*)(当前链表);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		d数量 = i;</span><br><span class="line">	&#125;</span><br><span class="line">	__except (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Call_输出调试信息(<span class="string">&quot;幻想神域   数组信息遍历出错！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调试输出：（很明显是生物链表，包含自己）</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200609171928839.png" alt="image-20200609171928839"></p>
<h3 id="找名称"><a href="#找名称" class="headerlink" title="找名称"></a>找名称</h3><p>中文会有不同的编码问题，但是若起名为英文字母+数字，则只需要看ASCII和UNICODE来判断。</p>
<p>我们的名称本身是英文+数字的组合，因此直接上我们找到的对象属性中去寻找。</p>
<p>od中dd [[[[[[0F84B74]+410+8]]]+0c]+0c]（链表中的人物属性），直接发现了自己的名字</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200610115440267.png" alt="image-20200610115440267"></p>
<p>由此确定：<br>$$<br>名称地址=[[[[[[0F84B74]+410+8]]]+0c]+0c]+100<br>$$<br>因此： [对象+C]+100表示对象名称</p>
<p>在找到的名称处下访问断，断下的地方观察跳转，编译器会为字符串提供一个区间，字符串长度大于该区间则存为指针，若小于等于则直接存名字内容</p>
<p>名字下访问断断下分析：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200610140531244.png" alt="image-20200610140531244"></p>
<p>由上图分析得知 [对象+C]+114表示对象名称长度</p>
<p>编写代码为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DWORD 名称长度 = *(DWORD *)(人物属性 + <span class="number">0x114</span>);</span><br><span class="line">				<span class="keyword">if</span> (名称长度 &lt;= <span class="number">0x10</span>)<span class="comment">//地址中直接是字符串</span></span><br><span class="line">				&#123;</span><br><span class="line">					对象信息[i].p名字 = (<span class="keyword">char</span> *)(人物属性 + <span class="number">0x100</span>);</span><br><span class="line">					<span class="built_in">strcpy</span>(对象信息[i].cGBK名字, 对象信息[i].p名字);</span><br><span class="line">					<span class="built_in">BIG52GBK</span>(对象信息[i].cGBK名字);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span><span class="comment">//地址中还要进一层</span></span><br><span class="line">				&#123;</span><br><span class="line">					对象信息[i].p名字 = (<span class="keyword">char</span>*)*(DWORD *)(人物属性 + <span class="number">0x100</span>);</span><br><span class="line">					<span class="built_in">strcpy</span>(对象信息[i].cGBK名字, 对象信息[i].p名字);</span><br><span class="line">					<span class="built_in">BIG52GBK</span>(对象信息[i].cGBK名字);</span><br><span class="line">				&#125;</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200610144038590.png" alt="image-20200610144038590"></p>
<p>不知道为什么区域恶霸显示是这样的？可能是%s 放前面的原因，放在后面就没问题了。</p>
<p>将id也打印出来，效果如下:</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200619203613803.png" alt="image-20200619203613803"></p>
<h2 id="追背包中物品数量找背包数据结构二叉树"><a href="#追背包中物品数量找背包数据结构二叉树" class="headerlink" title="追背包中物品数量找背包数据结构二叉树"></a>追背包中物品数量找背包数据结构二叉树</h2><h3 id="找背包数据结构二叉树"><a href="#找背包数据结构二叉树" class="headerlink" title="找背包数据结构二叉树"></a>找背包数据结构二叉树</h3><p>先用ce找到背包第六格小血瓶数量</p>
<p>4字节搜到：111E18C0，每当打开背包，更改的数值被重置。根据地址下访问断，断下位置向上追，追到结果为如下：</p>
<p>我的人物对象==[[[[0F84B74]+410+8]]+0c]</p>
<p>[[[[[[[[我的人物对象+0C]+3C0]+4]+4]+10]+8]+ecx<em>4]+28]==背包物品数量<br>$$<br>word\ ptr\ [[[[[[[[[[[[0F84B74]+410+8]]+0c]+0C]+3C0]+4]+4]+10]+8]+ecx</em>4]+28]==我的背包物品数量<br>$$<br>上面式子中，ecx代表背包格子序号，由零开始。</p>
<p>但并没有发现二叉树结构</p>
<p>进行分析，每当打开背包或关闭背包，更改的数值被修正，这种修正只有两种可能，第一种可能就是被本地数据修正，第二种可能是被服务器修正，而正常的一个游戏打开背包关闭背包不应该发送封包的，因此极大概率是本地修正，若是本地修正也说明我们现在找到的只是个假地址，还有一个真正的地址是用来存本地真正的背包数量的。因此我们要找到本地修正的那个地址。由于4字节搜索只搜到一个，因此尝试搜索其他类型。</p>
<p>搜索二字节找到两个数据，有一个和前面找到那个是同一个地址，即那个假地址，因此排除。另外一个地址更改其中数值发现不会影响开关背包数据。</p>
<p>改地址为：212517A8;</p>
<p>下word访问断点，只断到此处：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">009602EA  |.  0FB756 28     ||movzx   edx, word ptr [esi+28]         ;  [esi+28]==背包物品数量 esi+28==背包物品数量地址</span><br></pre></td></tr></table></figure>

<p>向上追一条追到数组结构：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200612142353797.png" alt="image-20200612142353797"></p>
<p>此处又发现了数组结构，并且通过执行断点，发现数组结构中的下标ecx是分段式连续的，从0-1d，0-13。从1d进入下一段的时候eax发生变化，eax有两种情况。结合游戏：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200612142702850.png" alt="image-20200612142702850"></p>
<p>游戏自带的基本背包格子数是30个，16进制为1e，0-1d正好是1e个序号，而现在身上只装了如图的一个背包，该背包能提供20个额外的格子，16进制为14，也正好对应0-13的序号范围。这样也就看出来了此时这里是两个数组，ecx代表背包内的格子序号，而eax代表背包对象，相当于有几个背包则有几个背包格子数组。eax遍历每个背包，ecx遍历背包中每个格子，继续向上追背包对象的来源。</p>
<p>追此数据发现直接是追上次数据的中间位置。</p>
<p>继续向上追：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200612162228639.png" alt="image-20200612162228639"></p>
<p>追到此处发现：eax来源于图中的call，该call的esi参数断下后传入的依次是0-5，结合游戏有5个妆效背包的位置和原有的默认初始提供的30格空间，相当于6个背包，正好是0-5表示序号。即可确定该call是背包对象的来源。进入：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200612162542084.png" alt="image-20200612162542084"></p>
<p>call中除了调了一个call外啥也没做，并且该call的eax参数依然是装背包的位置的格子序号，显然要继续进call：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200612163010995.png" alt="image-20200612163010995"></p>
<p>继续逆向，发现追到[ebp-4],而[ebp-4]来源于圈起来的call中。断下多次dd发现[ebp-4]只有两种变化，正对应现在只带了一个额外背包的情况，因此要继续进call追。</p>
<p>[[[[0F84B74]+410+8]]+0c]</p>
<p>[[[[[[[[0F84B74]+410+8]]+0c]+0C]+3C0]+4]+4]为二叉树根节点</p>
<p>[[[[[[[[0F84B74]+410+8]]+0c]+0C]+3C0]+4]+4]为二叉树根节点，+0]为左子树,+8]为右子树</p>
<p>跳出二叉树的标志位为：byte ptr [[[[[[[[[0F84B74]+410+8]]+0c]+0C]+3C0]+4]+4]+15]，当标志位不等于0时表示该二叉树没有子项了。</p>
<p> 背包序号地址=二叉树节点+C</p>
<p> 每个二叉树背包节点下挂个物品格子数组：</p>
<p>物品格子数组的开始地址=[二叉树节点+10]+8</p>
<p>物品格子数组的结束地址=[二叉树节点+10]+0c</p>
<p>物品格子数组项地址=[[二叉树节点+10]+8]+ecx*4(ecx表示格子序号)</p>
<p>物品数量地址(word)= [物品格子数组项]+28</p>
<p>物品最大数量地址(word)= [物品格子数组项]+2A</p>
<p>[[[[[[[[[[[[0F84B74]+410+8]]+0c]+0C]+3C0]+4]+4]+10]+8]+ecx*4]+28]== 初始背包物品数量</p>
<img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200616114841882.png" alt="image-20200616114841882"  />

<p>代码如下：</p>
<p>结构代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">T</span>背包信息</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	DWORD dID;</span><br><span class="line">	DWORD d数量;</span><br><span class="line">	DWORD d最大数量;</span><br><span class="line">	DWORD d位置;</span><br><span class="line">	DWORD d所在背包;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">T</span>遍历背包信息</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	T背包信息 背包列表[<span class="number">1000</span>];</span><br><span class="line">	DWORD d数量;</span><br><span class="line">	<span class="keyword">void</span> 初始化背包信息();</span><br><span class="line">	<span class="keyword">void</span> 递归遍历二叉树信息(DWORD);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>函数实现代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> g_背包列表下标=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">void</span> T遍历背包信息::初始化背包信息()</span><br><span class="line">&#123;</span><br><span class="line">	__try</span><br><span class="line">	&#123;</span><br><span class="line">		g_背包列表下标 = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//[[[[[[[[0F84B74]+410+8]]+0c]+0C]+3C0]+4]+4]为二叉树根节点</span></span><br><span class="line">		T人物信息 me;</span><br><span class="line">		me.初始化人物信息();</span><br><span class="line">		DWORD 本人对象= *(DWORD*)(me.d对象 +<span class="number">0x0c</span>);</span><br><span class="line">		DWORD tmp = *(DWORD*)(本人对象 + <span class="number">0x3c0</span>);</span><br><span class="line">		tmp = *(DWORD*)(tmp + <span class="number">0x4</span>);</span><br><span class="line">		DWORD 背包二叉树根节点 = *(DWORD*)(tmp + <span class="number">0x4</span>);</span><br><span class="line">		递归遍历二叉树信息(背包二叉树根节点);</span><br><span class="line">		d数量 = g_背包列表下标;</span><br><span class="line">	&#125;</span><br><span class="line">	__except (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Call_输出调试信息(<span class="string">&quot;幻想神域   背包二叉树出错！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> T遍历背包信息::递归遍历二叉树信息(DWORD 背包二叉树根节点)</span><br><span class="line">&#123;</span><br><span class="line">	BYTE 标志位= *(BYTE*)(背包二叉树根节点 + <span class="number">0x15</span>);</span><br><span class="line">	DWORD 左节点 = *(DWORD*)(背包二叉树根节点 + <span class="number">0x0</span>);</span><br><span class="line">	DWORD 右节点 = *(DWORD*)(背包二叉树根节点 + <span class="number">0x8</span>);</span><br><span class="line">	<span class="keyword">if</span> (标志位==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		DWORD 背包对象= *(DWORD*)(背包二叉树根节点 + <span class="number">0x10</span>);</span><br><span class="line">		DWORD 背包序号 = *(WORD*)(背包二叉树根节点 + <span class="number">0x0C</span>);</span><br><span class="line">		</span><br><span class="line">		DWORD 数组开始地址= *(DWORD*)(背包对象 + <span class="number">0x8</span>);</span><br><span class="line">		DWORD 数组结束地址 = *(DWORD*)(背包对象 + <span class="number">0x0c</span>);</span><br><span class="line">		DWORD 数组长度 = (数组结束地址 - 数组开始地址) / <span class="number">4</span>;</span><br><span class="line">		d数量 = 数组长度;</span><br><span class="line">		Call_输出调试信息(<span class="string">&quot;幻想神域   背包序号：%d   背包对象:%X   背包长度：%d\r\n   &quot;</span>, 背包序号, 背包对象, d数量);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;数组长度;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			DWORD 物品信息 = *(DWORD*)(数组开始地址 + i * <span class="number">0x4</span>);</span><br><span class="line">			DWORD ID=*(DWORD*)(物品信息);</span><br><span class="line">			<span class="keyword">if</span> (ID!=<span class="number">0</span>)<span class="comment">//背包格子中有东西</span></span><br><span class="line">			&#123;</span><br><span class="line">				背包列表[g_背包列表下标].dID = ID;</span><br><span class="line">				背包列表[g_背包列表下标].d数量 = *(WORD*)(物品信息 + <span class="number">0x28</span>);</span><br><span class="line">				背包列表[g_背包列表下标].d最大数量 = *(WORD*)(物品信息 + <span class="number">0x2a</span>);</span><br><span class="line">				背包列表[g_背包列表下标].d所在背包 = 背包序号;</span><br><span class="line">				背包列表[g_背包列表下标].d位置 = i;</span><br><span class="line">				g_背包列表下标++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		递归遍历二叉树信息(左节点);</span><br><span class="line">		递归遍历二叉树信息(右节点);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">T遍历背包信息 t;</span><br><span class="line">	t.初始化背包信息();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)t.d数量; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Call_输出调试信息(<span class="string">&quot;幻想神域   物品id：%x   物品数量:%d/%d   所在背包序号:%d   位置序号：%d&quot;</span>, t.背包列表[i].dID, t.背包列表[i].d数量, t.背包列表[i].d最大数量, t.背包列表[i].d所在背包, t.背包列表[i].d位置);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h3 id="分析物品名称"><a href="#分析物品名称" class="headerlink" title="分析物品名称"></a>分析物品名称</h3><p>物品遍历以后未发现物品名称，因此还需要单独找物品名称。</p>
<p>由于游戏是繁体字，并且是BIG5编码</p>
<p>打开big5转换工具</p>
<p>搜狗拼音输入法设置为繁体通用，输入如下</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200616121616564.png" alt="image-20200616121616564"></p>
<p>然后点击GBK到BIG5 ，变为如下图：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200616121652661.png" alt="image-20200616121652661"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BB B4 AB AC 48 50 C3 C4 A4 F4 00</span><br></pre></td></tr></table></figure>

<p>用CE字节集扫描搜索：BB B4 AB AC 48 50 C3 C4 A4 F4 00（00结尾的目的是不让他跟别的字符串）</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200616123037380.png" alt="image-20200616123037380"></p>
<p>找到5个结果，逐个修改，发现只有一个有效，即地址为：0A2536FC</p>
<p>并且发现更改了名字后所有同id的物品名字都变了，这说明很有可能有一个物品库，用物品id获取物品名字。od附近，dd 09E536FC，下硬件访问断点。</p>
<p>断在线标明位置：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200616124233780.png" alt="image-20200616124233780"></p>
<p>因为是硬件断，所以实际的物品名称为[esi+ecx*4-8],此处断下时ecx==2，追esi。</p>
<p>因为是字符串，尝试跳出最底层堆栈。</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200616125251278.png" alt="image-20200616125251278"></p>
<p>找到此处为该call第三个参数，跳过去。</p>
<p>继续分析：找到字符串处理分叉：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200617140130766.png" alt="image-20200617140130766"></p>
<p>继续向上追，追eax追到eax来源于这个call，发现这个call的参数是物品id，可以直接调用这个call获取eax返回值，该call应该是通过物品id取物品对象的call。</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200617123047040.png" alt="image-20200617123047040"></p>
<p>该call类似于通过id汉化物品名字</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200617130410963.png" alt="image-20200617130410963"></p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> T遍历背包信息::递归遍历二叉树信息(DWORD 背包二叉树根节点)</span><br><span class="line">&#123;</span><br><span class="line">	BYTE 标志位= *(BYTE*)(背包二叉树根节点 + <span class="number">0x15</span>);</span><br><span class="line">	DWORD 左节点 = *(DWORD*)(背包二叉树根节点 + <span class="number">0x0</span>);</span><br><span class="line">	DWORD 右节点 = *(DWORD*)(背包二叉树根节点 + <span class="number">0x8</span>);</span><br><span class="line">	<span class="keyword">if</span> (标志位==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		DWORD 背包对象= *(DWORD*)(背包二叉树根节点 + <span class="number">0x10</span>);</span><br><span class="line">		DWORD 背包序号 = *(WORD*)(背包二叉树根节点 + <span class="number">0x0C</span>);</span><br><span class="line">		</span><br><span class="line">		DWORD 数组开始地址= *(DWORD*)(背包对象 + <span class="number">0x8</span>);</span><br><span class="line">		DWORD 数组结束地址 = *(DWORD*)(背包对象 + <span class="number">0x0c</span>);</span><br><span class="line">		DWORD 数组长度 = (数组结束地址 - 数组开始地址) / <span class="number">4</span>;</span><br><span class="line">		d数量 = 数组长度;</span><br><span class="line">		Call_输出调试信息(<span class="string">&quot;幻想神域   背包序号：%d   背包对象:%X   背包长度：%d\r\n   &quot;</span>, 背包序号, 背包对象, d数量);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;数组长度;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			DWORD 物品信息 = *(DWORD*)(数组开始地址 + i * <span class="number">0x4</span>);</span><br><span class="line">			DWORD ID=*(DWORD*)(物品信息);</span><br><span class="line">			<span class="keyword">if</span> (ID!=<span class="number">0</span>)<span class="comment">//背包格子中有东西</span></span><br><span class="line">			&#123;</span><br><span class="line">				背包列表[g_背包列表下标].dID = ID;</span><br><span class="line">				背包列表[g_背包列表下标].d数量 = *(WORD*)(物品信息 + <span class="number">0x28</span>);</span><br><span class="line">				背包列表[g_背包列表下标].d最大数量 = *(WORD*)(物品信息 + <span class="number">0x2a</span>);</span><br><span class="line">				背包列表[g_背包列表下标].d所在背包 = 背包序号;</span><br><span class="line">				背包列表[g_背包列表下标].d位置 = i;</span><br><span class="line">				<span class="comment">//取物品名称</span></span><br><span class="line">				DWORD 名称对象;</span><br><span class="line">				DWORD temp;</span><br><span class="line">				背包列表[g_背包列表下标].p名字 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">				__asm</span><br><span class="line">				&#123;</span><br><span class="line">					mov ecx,<span class="number">0x1789168</span></span><br><span class="line">					mov ecx,[ecx]</span><br><span class="line">					mov eax,[ecx]</span><br><span class="line">					push ID</span><br><span class="line">					mov edx,[eax+<span class="number">0x0A8</span>]</span><br><span class="line">					call edx</span><br><span class="line">					mov 名称对象,eax</span><br><span class="line">				&#125;</span><br><span class="line">				DWORD  名称长度 = *(DWORD*)(名称对象 + <span class="number">0x0F8</span> + <span class="number">0x018</span>);</span><br><span class="line">				<span class="keyword">if</span> (名称长度&gt;=<span class="number">0x10</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					temp = *(DWORD*)(名称对象 + <span class="number">0x0fc</span>);</span><br><span class="line">					背包列表[g_背包列表下标].p名字 = (<span class="keyword">char</span>*)temp;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					背包列表[g_背包列表下标].p名字 =(<span class="keyword">char</span>*)(名称对象 + <span class="number">0x0fc</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="built_in">strcpy</span>(背包列表[g_背包列表下标].cGBK名字, 背包列表[g_背包列表下标].p名字);</span><br><span class="line">				<span class="built_in">BIG52GBK</span>(背包列表[g_背包列表下标].cGBK名字);</span><br><span class="line">				g_背包列表下标++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		递归遍历二叉树信息(左节点);</span><br><span class="line">		递归遍历二叉树信息(右节点);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="找技能数据结构"><a href="#找技能数据结构" class="headerlink" title="找技能数据结构"></a>找技能数据结构</h2><p>通过技能cd来找技能结构。</p>
<p>找一个比较长cd的技能，使用后cd开始倒计时用ce先搜未知初始值，再用ce搜减少的。</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200617173409222.png" alt="image-20200617173409222"></p>
<p>显然，比对游戏内显示，2D3132B0最像CD的秒数。</p>
<p>cd结束后发现该位置被清空Nan。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00ABF638  |.  D851 10       ||fcom    dword ptr [ecx+10]             ;  断在此处，ecx疑是进入cd的技能对象，当没有技能处在cd中时该代码不执行</span><br></pre></td></tr></table></figure>

<p>向上追，追到链表结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">00ABF5C0  /$  55             push    ebp                              ;  [[[[[17EA2B0]+30]+4+0c*0+4]]+10]+10==进入cd的技能的冷却时间的地址</span><br><span class="line">00ABF5C1  |.  8BEC           mov     ebp, esp                         ;  [[[[17EA2B0]+30]+4+0c*0+4]]表示技能链表头 +4]取下一个技能  +10]+10表示cd倒数秒数的地址</span><br><span class="line">00ABF5C3  |.  83EC 1C        sub     esp, 1C</span><br><span class="line">00ABF5C6  |.  53             push    ebx</span><br><span class="line">00ABF5C7  |.  56             push    esi</span><br><span class="line">00ABF5C8  |.  57             push    edi</span><br><span class="line">00ABF5C9  |.  8D59 04        lea     ebx, dword ptr [ecx+4]           ;  [[[ecx+4+0c*n+4]]+10]+10==进入cd的技能的冷却时间的地址   当前链表项目==[[[17EA2B0]+30]+4+n*0c+4]时候跳出链表</span><br><span class="line">00ABF5CC  |.  C745 FC 070000&gt;mov     dword ptr [ebp-4], 7</span><br><span class="line">00ABF5D3  |&gt;  837B 08 00     /cmp     dword ptr [ebx+8], 0            ;  这个循环可忽略，因为不变的eax已经在其内了</span><br><span class="line">00ABF5D7  |.  0F84 E2000000  |je      00ABF6BF</span><br><span class="line">00ABF5DD  |.  8B43 04        |mov     eax, dword ptr [ebx+4]          ;  [[[ebx+4]]+10]+10==进入cd的技能的冷却时间的地址</span><br><span class="line">00ABF5E0  |.  8B38           |mov     edi, dword ptr [eax]            ;  [[eax]+10]+10==进入cd的技能的冷却时间的地址 此处两个技能cd状态eax不变化</span><br><span class="line">00ABF5E2  |.  8BF3           |mov     esi, ebx</span><br><span class="line">00ABF5E4  |.  897D F8        |mov     dword ptr [ebp-8], edi          ;  [edi+10]+10==进入cd的技能的冷却时间的地址  [[edi+4]+10]+10==进入cd的技能的冷却时间的地址</span><br><span class="line">00ABF5E7  |.  8975 F4        |mov     dword ptr [ebp-C], esi</span><br><span class="line">00ABF5EA  |.  8D9B 00000000  |lea     ebx, dword ptr [ebx]</span><br><span class="line">00ABF5F0  |&gt;  85F6           |/test    esi, esi</span><br><span class="line">00ABF5F2  |.  8B4B 04        ||mov     ecx, dword ptr [ebx+4]         ;  当前链表项目==[ebx+4]时候跳出链表</span><br><span class="line">00ABF5F5  |.  894D F0        ||mov     dword ptr [ebp-10], ecx        ;  当前链表项目==ecx时候跳出链表</span><br><span class="line">00ABF5F8  |.  74 04          ||je      short 00ABF5FE</span><br><span class="line">00ABF5FA  |.  3BF3           ||cmp     esi, ebx</span><br><span class="line">00ABF5FC  |.  74 05          ||je      short 00ABF603</span><br><span class="line">00ABF5FE  |&gt;  E8 28AE95FF    ||call    0041A42B</span><br><span class="line">00ABF603  |&gt;  3B7D F0        ||cmp     edi, dword ptr [ebp-10]        ;  当前链表项目==[ebp-10]时候跳出链表</span><br><span class="line">00ABF606  |.  0F84 B3000000  ||je      00ABF6BF</span><br><span class="line">00ABF60C  |.  85F6           ||test    esi, esi</span><br><span class="line">00ABF60E  |.  75 05          ||jnz     short 00ABF615</span><br><span class="line">00ABF610  |.  E8 16AE95FF    ||call    0041A42B</span><br><span class="line">00ABF615  |&gt;  3B7E 04        ||cmp     edi, dword ptr [esi+4]</span><br><span class="line">00ABF618  |.  75 05          ||jnz     short 00ABF61F</span><br><span class="line">00ABF61A  |.  E8 0CAE95FF    ||call    0041A42B</span><br><span class="line">00ABF61F  |&gt;  8B4F 10        ||mov     ecx, dword ptr [edi+10]        ;  [edi+10]+10==进入cd的技能的冷却时间的地址  此处edi还是多技能在走这代码</span><br><span class="line">00ABF622  |.  85C9           ||test    ecx, ecx</span><br><span class="line">00ABF624  |.  75 10          ||jnz     short 00ABF636</span><br><span class="line">00ABF626  |.  8D4D F4        ||lea     ecx, dword ptr [ebp-C]         ;  不断</span><br><span class="line">00ABF629  |.  E8 5212CEFF    ||call    007A0880</span><br><span class="line">00ABF62E  |.  8B7D F8        ||mov     edi, dword ptr [ebp-8]</span><br><span class="line">00ABF631  |.  8B75 F4        ||mov     esi, dword ptr [ebp-C]</span><br><span class="line">00ABF634  |.^ EB BA          ||jmp     short 00ABF5F0                 ;  循环尾部1</span><br><span class="line">00ABF636  |&gt;  D9EE           ||fldz</span><br><span class="line">00ABF638  |.  D851 10        ||fcom    dword ptr [ecx+10]             ;  断在此处，ecx疑是进入cd的技能对象，当没有技能处在cd中时该代码不执行  [ecx+10]==进入cd的技能的冷却时间</span><br><span class="line">00ABF63B  |.  DFE0           ||fstsw   ax</span><br><span class="line">00ABF63D  |.  F6C4 01        ||test    ah, 1</span><br><span class="line">00ABF640  |.  75 28          ||jnz     short 00ABF66A</span><br><span class="line">00ABF642  |.  51             ||push    ecx</span><br><span class="line">00ABF643  |.  DDD8           ||fstp    st</span><br><span class="line">00ABF645  |.  E8 D64695FF    ||call    00413D20</span><br><span class="line">00ABF64A  |.  83C4 04        ||add     esp, 4</span><br><span class="line">00ABF64D  |.  8D4D F4        ||lea     ecx, dword ptr [ebp-C]</span><br><span class="line">00ABF650  |.  E8 2B12CEFF    ||call    007A0880</span><br><span class="line">00ABF655  |.  57             ||push    edi</span><br><span class="line">00ABF656  |.  56             ||push    esi</span><br><span class="line">00ABF657  |.  8D55 E4        ||lea     edx, dword ptr [ebp-1C]</span><br><span class="line">00ABF65A  |.  52             ||push    edx</span><br><span class="line">00ABF65B  |.  8BCB           ||mov     ecx, ebx</span><br><span class="line">00ABF65D  |.  E8 5E60DEFF    ||call    008A56C0</span><br><span class="line">00ABF662  |.  8B7D F8        ||mov     edi, dword ptr [ebp-8]</span><br><span class="line">00ABF665  |.  8B75 F4        ||mov     esi, dword ptr [ebp-C]</span><br><span class="line">00ABF668  |.^ EB 86          ||jmp     short 00ABF5F0                 ;  循环尾部2</span><br><span class="line">00ABF66A  |&gt;  D941 0C        ||fld     dword ptr [ecx+C]</span><br><span class="line">00ABF66D  |.  D841 08        ||fadd    dword ptr [ecx+8]</span><br><span class="line">00ABF670  |.  D945 08        ||fld     dword ptr [ebp+8]</span><br><span class="line">00ABF673  |.  D8D1           ||fcom    st(1)</span><br><span class="line">00ABF675  |.  DFE0           ||fstsw   ax</span><br><span class="line">00ABF677  |.  F6C4 01        ||test    ah, 1</span><br><span class="line">00ABF67A  |.  75 09          ||jnz     short 00ABF685</span><br><span class="line">00ABF67C  |.  DDD9           ||fstp    st(1)</span><br><span class="line">00ABF67E  |.  DDD8           ||fstp    st</span><br><span class="line">00ABF680  |.  D951 10        ||fst     dword ptr [ecx+10]</span><br><span class="line">00ABF683  |.  EB 05          ||jmp     short 00ABF68A</span><br><span class="line">00ABF685  |&gt;  DEE9           ||fsubp   st(1), st</span><br><span class="line">00ABF687  |.  D959 10        ||fstp    dword ptr [ecx+10]</span><br><span class="line">00ABF68A  |&gt;  D851 10        ||fcom    dword ptr [ecx+10]</span><br><span class="line">00ABF68D  |.  DFE0           ||fstsw   ax</span><br><span class="line">00ABF68F  |.  F6C4 41        ||test    ah, 41</span><br><span class="line">00ABF692  |.  75 16          ||jnz     short 00ABF6AA</span><br><span class="line">00ABF694  |.  D959 10        ||fstp    dword ptr [ecx+10]</span><br><span class="line">00ABF697  |.  8D4D F4        ||lea     ecx, dword ptr [ebp-C]</span><br><span class="line">00ABF69A  |.  E8 E111CEFF    ||call    007A0880</span><br><span class="line">00ABF69F  |.  8B7D F8        ||mov     edi, dword ptr [ebp-8]</span><br><span class="line">00ABF6A2  |.  8B75 F4        ||mov     esi, dword ptr [ebp-C]</span><br><span class="line">00ABF6A5  |.^ E9 46FFFFFF    ||jmp     00ABF5F0                       ;  循环尾部3</span><br><span class="line">00ABF6AA  |&gt;  8D4D F4        ||lea     ecx, dword ptr [ebp-C]         ;  ecx+4==ebp-8  [[[ebp-8]+4]+10]+10==进入cd的技能的冷却时间的地址</span><br><span class="line">00ABF6AD  |.  DDD8           ||fstp    st</span><br><span class="line">00ABF6AF  |.  E8 CC11CEFF    ||call    007A0880                       ;  [ebp-8]来源于这个call  [[[ecx+4]+4]+10]+10==进入cd的技能的冷却时间的地址</span><br><span class="line">00ABF6B4  |.  8B7D F8        ||mov     edi, dword ptr [ebp-8]         ;  [[ebp-8]+10]+10==进入cd的技能的冷却时间的地址</span><br><span class="line">00ABF6B7  |.  8B75 F4        ||mov     esi, dword ptr [ebp-C]</span><br><span class="line">00ABF6BA  |.^ E9 31FFFFFF    |\jmp     00ABF5F0                       ;  循环尾部4</span><br><span class="line">00ABF6BF  |&gt;  83C3 0C        |add     ebx, 0C                         ;  [[[ebx+0c+4]]+10]+10==进入cd的技能的冷却时间的地址   ebx+0c*n的数组   当前链表项目==[ebx+n*0c+4]时候跳出链表</span><br><span class="line">00ABF6C2  |.  836D FC 01     |sub     dword ptr [ebp-4], 1</span><br><span class="line">00ABF6C6  |.^ 0F85 07FFFFFF  \jnz     00ABF5D3                        ;  [[[ebx+4]]+10]+10==进入cd的技能的冷却时间的地址</span><br><span class="line">00ABF6CC  |.  5F             pop     edi</span><br><span class="line">00ABF6CD  |.  5E             pop     esi</span><br><span class="line">00ABF6CE  |.  5B             pop     ebx</span><br><span class="line">00ABF6CF  |.  8BE5           mov     esp, ebp</span><br><span class="line">00ABF6D1  |.  5D             pop     ebp</span><br><span class="line">00ABF6D2  \.  C2 0400        retn    4</span><br></pre></td></tr></table></figure>

<p>分析如下：</p>
<p>[[[[[17EA2B0]+30]+4+0c*0+4]]+10]+10==进入cd的技能的冷却时间的地址 </p>
<p>[[[[17EA2B0]+30]+4+0c*0+4]]表示技能链表头          +4]取下一个技能                +10]+10表示cd倒数秒数的地址</p>
<p>当前链表项目==[[[17EA2B0]+30]+4+0*0c+4]时候链表结束</p>
<p>CE附加发现并不是链表。</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200618105542581.png" alt="image-20200618105542581"></p>
<p>由于此处分析过于复杂，尝试下访问断跳转分析位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00ABF61F  |&gt; \8B4F 10       ||mov     ecx, dword ptr [edi+10]        ;  [edi+10]+10==进入cd的技能的冷却时间的地址  此处edi还是多技能在走这代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此处dd edi下访问断。此处访问断是下给edi里面的地址对应的值有没有人访问。断到的位置为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0084CC3C  |.  8B00          |mov     eax, dword ptr [eax]            ;  [eax+10]+10==进入cd的技能的冷却时间的地址   此处eax变化种类数为进入cd技能数量 eax==35873300</span><br></pre></td></tr></table></figure>

<p>由于下断的是[edi]，下的是访问断，因此是把[edi]换成[eax]，即edi换成eax</p>
<p>继续往上追，到了二叉树结构。</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200618124459759.png" alt="image-20200618124459759"></p>
<p>分析如下：</p>
<p>cd中技能二叉树根节点==[[[[17EA2B0]+30]+0*4+4+4]+4]  </p>
<p>+0]表示左子树</p>
<p>+8]表示右子树</p>
<p>+0c]表示技能id</p>
<p>+15]（byte）！=0表示到头了</p>
<p>[二叉树项+10]+10 表示技能cd倒数秒数</p>
<p>CE分析：</p>
<p>没放技能的时候：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200618121851520.png" alt="image-20200618121851520"></p>
<p>两个技能时候：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200618121807662.png" alt="image-20200618121807662"></p>
<p>放三个技能时候：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200618121940617.png" alt="image-20200618121940617"></p>
<p>代码：</p>
<p>结构代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">TCD</span>中技能信息</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	DWORD dID;</span><br><span class="line">	<span class="keyword">float</span> fCD;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">T</span>遍历<span class="title">CD</span>中技能信息</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	TCD中技能信息 技能列表[<span class="number">1000</span>];</span><br><span class="line">	DWORD d数量;</span><br><span class="line">	<span class="keyword">void</span> 初始化CD中技能信息();</span><br><span class="line">	<span class="keyword">void</span> 递归遍历二叉树信息(DWORD);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>函数实现代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">DWORD g_冷却技能数量 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">void</span> T遍历CD中技能信息::递归遍历二叉树信息(DWORD 根节点)</span><br><span class="line">&#123;</span><br><span class="line">	BYTE 标志位 = *(BYTE*)(根节点 + <span class="number">0x15</span>);</span><br><span class="line">	DWORD 左子树 = *(DWORD*)(根节点 + <span class="number">0x0</span>);</span><br><span class="line">	DWORD 右子树 = *(DWORD*)(根节点 + <span class="number">0x8</span>);</span><br><span class="line">	<span class="keyword">if</span> (标志位==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		技能列表[g_冷却技能数量].dID= *(DWORD*)(根节点 + <span class="number">0x0c</span>);</span><br><span class="line">		g_冷却技能数量++;</span><br><span class="line">		递归遍历二叉树信息(左子树);</span><br><span class="line">		递归遍历二叉树信息(右子树);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> T遍历CD中技能信息::初始化CD中技能信息()</span><br><span class="line">&#123;</span><br><span class="line">	__try</span><br><span class="line">	&#123;</span><br><span class="line">		g_冷却技能数量 = <span class="number">0</span>;</span><br><span class="line">		DWORD tmp = *(DWORD*)(<span class="number">0x17ea2b0</span>);</span><br><span class="line">		tmp = *(DWORD*)(tmp+<span class="number">0x30</span>);</span><br><span class="line">		tmp = *(DWORD*)(tmp + <span class="number">0x8</span>);</span><br><span class="line">		DWORD 二叉树根节点 = *(DWORD*)(tmp + <span class="number">0x4</span>);</span><br><span class="line">		递归遍历二叉树信息(二叉树根节点);</span><br><span class="line">		d数量 = g_冷却技能数量;</span><br><span class="line">		Call_输出调试信息(<span class="string">&quot;幻想神域   技能冷却数量:%d\r\n&quot;</span>,d数量);</span><br><span class="line">	&#125;</span><br><span class="line">	__except (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Call_输出调试信息(<span class="string">&quot;幻想神域   初始化CD中技能信息出错！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">T遍历CD中技能信息 t;</span><br><span class="line">t.初始化CD中技能信息();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;t.d数量;i++)</span><br><span class="line">&#123;</span><br><span class="line">	Call_输出调试信息(<span class="string">&quot;幻想神域   冷却技能id：%X\r\n &quot;</span>,t.技能列表[i].dID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="找技能名"><a href="#找技能名" class="headerlink" title="找技能名"></a>找技能名</h3><p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200618150730099.png" alt="image-20200618150730099"></p>
<p>转成BIG5：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200618150751691.png" alt="image-20200618150751691"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B6 C2 AA A2 B3 B4 A8 C0 00</span><br></pre></td></tr></table></figure>

<p>上ce搜索：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200618151416145.png" alt="image-20200618151416145"></p>
<p>对半修改筛选，最终定位到唯一一个地址：0C77CF04</p>
<p>od附加dd下访问断，尽量断技能栏的访问，若断到快捷栏的访问可能会断到技能快捷栏相关的东西</p>
<p>追到此处,找到了取技能对象call:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">008EFF36  |.  8B45 10       mov     eax, dword ptr [ebp+10]</span><br><span class="line">008EFF39  |.  8B92 C4000000 mov     edx, dword ptr [edx+C4]</span><br><span class="line">008EFF3F  |.  50            push    eax                              ;  传进技能对象</span><br><span class="line">008EFF40  |.  89B5 3CFFFFFF mov     dword ptr [ebp-C4], esi</span><br><span class="line">008EFF46  |.  FFD2          call    edx                              ;  eax来源于该call 传进技能id传出技能名称  edx==[[[1789168]]+0c4]</span><br><span class="line">008EFF48  |.  8BF0          mov     esi, eax                         ;  技能名称地址==eax+100+4==0C77CF04  +10(WORD)疑似表示放在技能格子的位置</span><br></pre></td></tr></table></figure>

<p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">DWORD g_冷却技能数量 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">void</span> T遍历CD中技能信息::递归遍历二叉树信息(DWORD 根节点)</span><br><span class="line">&#123;</span><br><span class="line">	BYTE 标志位 = *(BYTE*)(根节点 + <span class="number">0x15</span>);</span><br><span class="line">	DWORD 左子树 = *(DWORD*)(根节点 + <span class="number">0x0</span>);</span><br><span class="line">	DWORD 右子树 = *(DWORD*)(根节点 + <span class="number">0x8</span>);</span><br><span class="line">	<span class="keyword">if</span> (标志位==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		技能列表[g_冷却技能数量].dID= *(DWORD*)(根节点 + <span class="number">0x0c</span>);</span><br><span class="line">		DWORD fCD = *(DWORD*)(根节点 + <span class="number">0x10</span>);</span><br><span class="line">		技能列表[g_冷却技能数量].fCD = *(FLOAT*)(fCD + <span class="number">0x10</span>);</span><br><span class="line">		技能列表[g_冷却技能数量].p名字 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">		DWORD ID = 技能列表[g_冷却技能数量].dID;</span><br><span class="line">		DWORD 名称对象;</span><br><span class="line">		DWORD Temp;</span><br><span class="line">		__asm </span><br><span class="line">		&#123;</span><br><span class="line">			mov ecx,<span class="number">0x1789168</span></span><br><span class="line">			mov ecx,[ecx]</span><br><span class="line">			mov edx,[ecx]</span><br><span class="line">			push ID</span><br><span class="line">			mov edx,[edx+<span class="number">0x0c4</span>]</span><br><span class="line">			call edx</span><br><span class="line">			mov 名称对象,eax</span><br><span class="line">		&#125;</span><br><span class="line">		DWORD 名称长度 = *(DWORD*)(名称对象 + <span class="number">0x100</span> + <span class="number">0x18</span>);</span><br><span class="line">		<span class="keyword">if</span> (名称长度&gt;=<span class="number">0x10</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			Temp = *(DWORD*)(名称对象 + <span class="number">0x104</span>);</span><br><span class="line">			技能列表[g_冷却技能数量].p名字 = (<span class="keyword">char</span>*)Temp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			技能列表[g_冷却技能数量].p名字 = (<span class="keyword">char</span>*)名称对象 + <span class="number">0x104</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">strcpy</span>(技能列表[g_冷却技能数量].cGBK名字, 技能列表[g_冷却技能数量].p名字);</span><br><span class="line">		<span class="built_in">BIG52GBK</span>(技能列表[g_冷却技能数量].cGBK名字);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		g_冷却技能数量++;</span><br><span class="line">		递归遍历二叉树信息(左子树);</span><br><span class="line">		递归遍历二叉树信息(右子树);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> T遍历CD中技能信息::初始化CD中技能信息()</span><br><span class="line">&#123;</span><br><span class="line">	__try</span><br><span class="line">	&#123;</span><br><span class="line">		g_冷却技能数量 = <span class="number">0</span>;</span><br><span class="line">		DWORD tmp = *(DWORD*)(<span class="number">0x17ea2b0</span>);</span><br><span class="line">		tmp = *(DWORD*)(tmp+<span class="number">0x30</span>);</span><br><span class="line">		tmp = *(DWORD*)(tmp + <span class="number">0x8</span>);</span><br><span class="line">		DWORD 二叉树根节点 = *(DWORD*)(tmp + <span class="number">0x4</span>);</span><br><span class="line">		递归遍历二叉树信息(二叉树根节点);</span><br><span class="line">		d数量 = g_冷却技能数量;</span><br><span class="line">		Call_输出调试信息(<span class="string">&quot;幻想神域   技能冷却数量:%d\r\n&quot;</span>,d数量);</span><br><span class="line">	&#125;</span><br><span class="line">	__except (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Call_输出调试信息(<span class="string">&quot;幻想神域   初始化CD中技能信息出错！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">T遍历CD中技能信息 t;</span><br><span class="line">	t.初始化CD中技能信息();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;t.d数量;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Call_输出调试信息(<span class="string">&quot;幻想神域   冷却技能id：%X   剩余冷却时间：%f秒   技能名称:%s\r\n &quot;</span>,t.技能列表[i].dID, t.技能列表[i].fCD, t.技能列表[i].cGBK名字);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>调试效果如下：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200619200502840.png" alt="image-20200619200502840"></p>
<p>针对前面找到的cd中技能二叉树进行分析：</p>
<p>cd中技能二叉树根节点==[[[[17EA2B0]+30]+ecx*4+4+4]+4]，此处的ecx位置明显是个数组</p>
<p>dd [[17EA2B0]+30]这个位置，观察数组项进行分析：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200618174812697.png" alt="image-20200618174812697"></p>
<p>015E9BEC 人物cd中技能数</p>
<p>015E9BF8 cd中道具数</p>
<p>015E9C04 未知</p>
<p>0E519C10 宠物技能cd数</p>
<p>，，，底下的也暂时未知</p>
<p>可以得出结论这里的全是各种冷却二叉树结构！</p>
<h2 id="全技能遍历"><a href="#全技能遍历" class="headerlink" title="全技能遍历"></a>全技能遍历</h2><h3 id="第一·次找全技能，结果找到鼠标坐标call"><a href="#第一·次找全技能，结果找到鼠标坐标call" class="headerlink" title="第一·次找全技能，结果找到鼠标坐标call"></a>第一·次找全技能，结果找到鼠标坐标call</h3><p>寻找全技能遍历的突破口。之前，通过技能名称找到的是名称库，通过技能释放剩下的cd秒数找到的是冷却中的技能结构。尝试通过技能id找全技能结构。</p>
<p>到通过技能id获取技能对象call的位置继续往上追其参数。</p>
<p>追到此处：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">008FA35F  |.  8B4D 10       mov     ecx, dword ptr [ebp+10]          ;  技能id==[ebp+10]</span><br></pre></td></tr></table></figure>

<p>此处准备出call，若鼠标指向快捷栏中断下则出别的地方，处的那个地方再指向技能列表中发现不会再断，由于跟随技能快捷栏很容易追到ui结构中去。因此我们选择指向技能列表中的技能断下。</p>
<p>追到这：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00CB3019  |.  56            push    esi                              ;  技能id==[esi+1C8]==0CAC1 此处开始在ui上胡乱断了</span><br></pre></td></tr></table></figure>

<p>此时因为已经开始胡乱断了，验证方法是od窗口压在游戏窗口上方，是鼠标移出去位置正好对应技能位置，如下：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200619114555309.png" alt="image-20200619114555309"></p>
<p>从而避免别的UI干扰，得以验证对错。</p>
<p>继续向上追，追到此处：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00CC292C  |.  8B4E 3C       mov     ecx, dword ptr [esi+3C]          ;  技能id==[[esi+3c]+1C8]==0CAC1  此处不能通过完美验证法，需要追[esi+3c]的整体</span><br></pre></td></tr></table></figure>

<p>新知识点！！完美验证法！！</p>
<p>继续向上追：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200619121515351.png" alt="image-20200619121515351"></p>
<p>eax来源于上图箭头指向的call，此时发现该call的参数进一层是鼠标x，y相对于游戏窗口的坐标。</p>
<p>到此说明追技能结构失败，此处已经与技能结构没有关系了，而是一个类似于所有ui界面的一个遍历。</p>
<h3 id="第二次找全技能结构失败，找到了已使用过的技能结构"><a href="#第二次找全技能结构失败，找到了已使用过的技能结构" class="headerlink" title="第二次找全技能结构失败，找到了已使用过的技能结构"></a>第二次找全技能结构失败，找到了已使用过的技能结构</h3><p>既然第一次尝试失败了，找别的突破口。比如说从释放技能call作为突破口</p>
<p>用ce找到同一个技能的所有技能id，每个到od中下访问断，通过断到的位置和之前找过的代码是否相同或访问技能是否断下来做判断进行排除法。</p>
<p> 技能id到ce中搜索：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200619143158127.png" alt="image-20200619143158127"></p>
<p>由下往上排除：</p>
<p>结果第一个访问断就断到了一个新的二叉树：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">006E001D  |   8D49 00       lea     ecx, dword ptr [ecx]</span><br><span class="line">006E0020  |&gt;  66:3970 0C    /cmp     word ptr [eax+C], si            ;  断在此处  二叉树结构   eax+0]左子树  eax+8]右子树  eax+11]！=0跳出循环  eax+0c]为技能id地址  [EAX+0C]==0CAC1</span><br><span class="line">006E0024  |.  73 05         |jnb     short 006E002B</span><br><span class="line">006E0026  |.  8B40 08       |mov     eax, dword ptr [eax+8]</span><br><span class="line">006E0029  |.  EB 04         |jmp     short 006E002F</span><br><span class="line">006E002B  |&gt;  8BD0          |mov     edx, eax</span><br><span class="line">006E002D  |.  8B00          |mov     eax, dword ptr [eax]</span><br><span class="line">006E002F  |&gt;  8078 11 00    |cmp     byte ptr [eax+11], 0</span><br><span class="line">006E0033  |.^ 74 EB         \je      short 006E0020</span><br><span class="line">006E0035  |&gt;  3B51 04       cmp     edx, dword ptr [ecx+4]</span><br><span class="line">006E0038  |.  8BFA          mov     edi, edx</span><br></pre></td></tr></table></figure>

<p>分析如下：</p>
<p>二叉树根节点：[[[[链表项+0C]+2C]+70+4]+4]</p>
<p>+0]左子树    +8]右子树</p>
<p>二叉树节点+11]（byte）!=0表示跳出循环</p>
<p>再往上找，此处有个链表结构：该链表就是以前找到的遍历所有角色对象的链表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">006D7D5A  |&gt; \8B4E 0C       |mov     ecx, dword ptr [esi+C]          ;  血量地址==[[esi+0c]+0c]+8==307CD808    技能id==[[[[[[ESI+0C]+2C]+70+4]+4]]+0C]==0CAC1</span><br></pre></td></tr></table></figure>

<p>技能id==[[[[[[链表项+0C]+2C]+70+4]+4]]+0C]==0CAC1</p>
<p>ESI链表头=[[[0F84B74]+410+8]]，esi可以套n层[]，</p>
<p>[[[0F84B74]+410+8]]套几层[]表示当前链表项==[[0F84B74]+410+8] 时候跳出链表</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> T遍历自己的技能信息::初始化技能信息()</span><br><span class="line">&#123;</span><br><span class="line">	__try</span><br><span class="line">	&#123;</span><br><span class="line">		g_冷却技能数量 = <span class="number">0</span>;</span><br><span class="line">		DWORD 人物对象 = <span class="number">0</span>;</span><br><span class="line">		__asm</span><br><span class="line">		&#123;</span><br><span class="line">			mov ecx, <span class="number">0x0F84B74</span></span><br><span class="line">			mov ecx, [ecx]</span><br><span class="line">			mov eax, [ecx + <span class="number">0x40c</span>]</span><br><span class="line">			add ecx, <span class="number">0x410</span></span><br><span class="line">			push eax</span><br><span class="line">			mov eax, <span class="number">0x00665870</span></span><br><span class="line">			call eax</span><br><span class="line">			mov 人物对象, eax</span><br><span class="line">		&#125;</span><br><span class="line">		DWORD 二叉树根节点= *(DWORD*)(人物对象 + <span class="number">0x2c</span>);</span><br><span class="line">		二叉树根节点 = *(DWORD*)(二叉树根节点 + <span class="number">0x74</span>);</span><br><span class="line">		二叉树根节点 = *(DWORD*)(二叉树根节点 + <span class="number">0x4</span>);</span><br><span class="line">		递归遍历二叉树信息(二叉树根节点);</span><br><span class="line">		d数量 = g_冷却技能数量;</span><br><span class="line">		Call_输出调试信息(<span class="string">&quot;幻想神域   已使用过的技能数量:%d\r\n&quot;</span>, d数量);</span><br><span class="line">	&#125;</span><br><span class="line">	__except (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Call_输出调试信息(<span class="string">&quot;幻想神域   初始化技能信息出错！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> T遍历自己的技能信息::递归遍历二叉树信息(DWORD 根节点)</span><br><span class="line">&#123;</span><br><span class="line">	BYTE 标志位 = *(BYTE*)(根节点 + <span class="number">0x11</span>);</span><br><span class="line">	DWORD 左子树 = *(DWORD*)(根节点 + <span class="number">0x0</span>);</span><br><span class="line">	DWORD 右子树 = *(DWORD*)(根节点 + <span class="number">0x8</span>);</span><br><span class="line">	<span class="keyword">if</span> (标志位 == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		技能列表[g_冷却技能数量].dID = *(DWORD*)(根节点 + <span class="number">0x0c</span>);</span><br><span class="line">		技能列表[g_冷却技能数量].p名字 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">		DWORD ID = 技能列表[g_冷却技能数量].dID;</span><br><span class="line">		DWORD 名称对象;</span><br><span class="line">		DWORD Temp;</span><br><span class="line">		__asm</span><br><span class="line">		&#123;</span><br><span class="line">			mov ecx, <span class="number">0x1789168</span></span><br><span class="line">			mov ecx, [ecx]</span><br><span class="line">				mov edx, [ecx]</span><br><span class="line">				push ID</span><br><span class="line">				mov edx, [edx + <span class="number">0x0c4</span>]</span><br><span class="line">				call edx</span><br><span class="line">				mov 名称对象, eax</span><br><span class="line">		&#125;</span><br><span class="line">		DWORD 名称长度 = *(DWORD*)(名称对象 + <span class="number">0x100</span> + <span class="number">0x18</span>);</span><br><span class="line">		<span class="keyword">if</span> (名称长度 &gt;= <span class="number">0x10</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			Temp = *(DWORD*)(名称对象 + <span class="number">0x104</span>);</span><br><span class="line">			技能列表[g_冷却技能数量].p名字 = (<span class="keyword">char</span>*)Temp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			技能列表[g_冷却技能数量].p名字 = (<span class="keyword">char</span>*)名称对象 + <span class="number">0x104</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">strcpy</span>(技能列表[g_冷却技能数量].cGBK名字, 技能列表[g_冷却技能数量].p名字);</span><br><span class="line">		<span class="built_in">BIG52GBK</span>(技能列表[g_冷却技能数量].cGBK名字);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		g_冷却技能数量++;</span><br><span class="line">		递归遍历二叉树信息(左子树);</span><br><span class="line">		递归遍历二叉树信息(右子树);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调试过程如下：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200619190705774.png" alt="image-20200619190705774"></p>
<p>实际跑的时候发现该结构存的并非全技能，而是类似于用过的技能结构。使用过就能遍历出来，未使用就不存在于这个结构。</p>
<h3 id="第三次找全技能"><a href="#第三次找全技能" class="headerlink" title="第三次找全技能"></a>第三次找全技能</h3><p>继续在ce找技能id筛除：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200619191343990.png" alt="image-20200619191343990"></p>
<p>逐个用od来dd地址下访问断，0的表示查看和释放技能都不断的，找到了能断下的，并且是一个二叉树结构。</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200619191918680.png" alt="image-20200619191918680"></p>
<p>断下的位置向上追找到二叉树：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0070790A  |.  8D9B 00000000 lea     ebx, dword ptr [ebx]</span><br><span class="line">00707910  |&gt;  66:3970 0C    /cmp     word ptr [eax+C], si            ;  [eax+0c]==0CAC1==技能id   二叉树结构  二叉树根节点=[[[人物对象+0c]+444+4]+4]    +0]左子树  +8]右子树  +21]!=0跳出二叉树</span><br><span class="line">00707914  |.  73 05         |jnb     short 0070791B</span><br><span class="line">00707916  |.  8B40 08       |mov     eax, dword ptr [eax+8]</span><br><span class="line">00707919  |.  EB 04         |jmp     short 0070791F</span><br><span class="line">0070791B  |&gt;  8BD0          |mov     edx, eax</span><br><span class="line">0070791D  |.  8B00          |mov     eax, dword ptr [eax]</span><br><span class="line">0070791F  |&gt;  8078 21 00    |cmp     byte ptr [eax+21], 0</span><br><span class="line">00707923  |.^ 74 EB         \je      short 00707910</span><br><span class="line">00707925  |&gt;  8B41 04       mov     eax, dword ptr [ecx+4]</span><br></pre></td></tr></table></figure>

<p>向上追到二叉树根节点来源于该call：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200619193746843.png" alt="image-20200619193746843"></p>
<p>分析得：</p>
<p>二叉树根节点=[[[人物对象+0c]+444+4]+4]</p>
<p>+0]左子树     +8]右子树       +21]!=0跳出循环</p>
<p>调试过程中发现了一个严重的bug，上面所有的技能id取值的时候实际上应该取的是WORD，而非DWORD，用DWORD可能崩溃。</p>
<p>改过之后没事了。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> T遍历我的技能信息::初始化我的技能信息()</span><br><span class="line">&#123;</span><br><span class="line">	__try</span><br><span class="line">	&#123;</span><br><span class="line">		g_冷却技能数量 = <span class="number">0</span>;</span><br><span class="line">		DWORD 人物对象 = <span class="number">0</span>;</span><br><span class="line">		__asm</span><br><span class="line">		&#123;</span><br><span class="line">			mov ecx, <span class="number">0x0F84B74</span></span><br><span class="line">			mov ecx, [ecx]</span><br><span class="line">			mov eax, [ecx + <span class="number">0x40c</span>]</span><br><span class="line">			add ecx, <span class="number">0x410</span></span><br><span class="line">			push eax</span><br><span class="line">			mov eax, <span class="number">0x00665870</span></span><br><span class="line">			call eax</span><br><span class="line">			mov 人物对象, eax</span><br><span class="line">		&#125;</span><br><span class="line">		DWORD 二叉树根节点 = *(DWORD*)(人物对象 + <span class="number">0x0c</span>);</span><br><span class="line">		二叉树根节点 = *(DWORD*)(二叉树根节点 + <span class="number">0x448</span>);</span><br><span class="line">		二叉树根节点 = *(DWORD*)(二叉树根节点 + <span class="number">0x4</span>);</span><br><span class="line">		递归遍历二叉树信息(二叉树根节点);</span><br><span class="line">		d数量 = g_冷却技能数量;</span><br><span class="line">		Call_输出调试信息(<span class="string">&quot;幻想神域   我的技能数量:%d\r\n&quot;</span>, d数量);</span><br><span class="line">	&#125;</span><br><span class="line">	__except (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Call_输出调试信息(<span class="string">&quot;幻想神域   初始化我的技能信息出错！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> T遍历我的技能信息::递归遍历二叉树信息(DWORD 根节点)</span><br><span class="line">&#123;</span><br><span class="line">	BYTE 标志位 = *(BYTE*)(根节点 + <span class="number">0x21</span>);</span><br><span class="line">	DWORD 左子树 = *(DWORD*)(根节点 + <span class="number">0x0</span>);</span><br><span class="line">	DWORD 右子树 = *(DWORD*)(根节点 + <span class="number">0x8</span>);</span><br><span class="line">	<span class="keyword">if</span> (标志位 == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//bug位置，下面的WORD原来为DWORD时候有错！</span></span><br><span class="line">		技能列表[g_冷却技能数量].dID = *(WORD*)(根节点 + <span class="number">0x0c</span>);</span><br><span class="line">		技能列表[g_冷却技能数量].p名字 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">		DWORD ID = 技能列表[g_冷却技能数量].dID;</span><br><span class="line">		DWORD 名称对象;</span><br><span class="line">		DWORD Temp;</span><br><span class="line">		__asm</span><br><span class="line">		&#123;</span><br><span class="line">			mov ecx, <span class="number">0x1789168</span></span><br><span class="line">			mov ecx, [ecx]</span><br><span class="line">				mov edx, [ecx]</span><br><span class="line">				push ID</span><br><span class="line">				mov edx, [edx + <span class="number">0x0c4</span>]</span><br><span class="line">				call edx</span><br><span class="line">				mov 名称对象, eax</span><br><span class="line">		&#125;</span><br><span class="line">		DWORD 名称长度 = *(DWORD*)(名称对象 + <span class="number">0x100</span> + <span class="number">0x18</span>);</span><br><span class="line">		<span class="keyword">if</span> (名称长度 &gt;= <span class="number">0x10</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			Temp = *(DWORD*)(名称对象 + <span class="number">0x104</span>);</span><br><span class="line">			技能列表[g_冷却技能数量].p名字 = (<span class="keyword">char</span>*)Temp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			技能列表[g_冷却技能数量].p名字 = (<span class="keyword">char</span>*)名称对象 + <span class="number">0x104</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">strcpy</span>(技能列表[g_冷却技能数量].cGBK名字, 技能列表[g_冷却技能数量].p名字);</span><br><span class="line">		<span class="built_in">BIG52GBK</span>(技能列表[g_冷却技能数量].cGBK名字);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		g_冷却技能数量++;</span><br><span class="line">		递归遍历二叉树信息(左子树);</span><br><span class="line">		递归遍历二叉树信息(右子树);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>调试结果：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200619200020569.png" alt="image-20200619200020569"></p>
<p>终于成功找到了全技能遍历！</p>
<h2 id="找明文封包call"><a href="#找明文封包call" class="headerlink" title="找明文封包call"></a>找明文封包call</h2><h3 id="确定有无crc检测？"><a href="#确定有无crc检测？" class="headerlink" title="确定有无crc检测？"></a>确定有无crc检测？</h3><p>给代码下访问断点，发现没有访问代码，说明没有crc检测</p>
<h3 id="判断是哪种发包？"><a href="#判断是哪种发包？" class="headerlink" title="判断是哪种发包？"></a>判断是哪种发包？</h3><p>WSASend断下，判断是WSASend发包</p>
<h3 id="判断是否线程发包？"><a href="#判断是否线程发包？" class="headerlink" title="判断是否线程发包？"></a>判断是否线程发包？</h3><p>喊话的调用堆栈如下：</p>
<p>调用堆栈：     主线程<br>地址       堆栈       函数过程 / 参数                       调用来自                      结构<br>0019FB8C   00B921B6   ws2_32.WSASend                        game.00B921B0                 0019FBDC<br>0019FB90   00000A74     Socket = A74<br>0019FB94   0019FBC0     pBuffers = 0019FBC0<br>0019FB98   00000001     nBuffers = 1<br>0019FB9C   0019FBBC     pBytesSent = 0019FBBC<br>0019FBA0   00000000     Flags = 0<br>0019FBA4   00000000     pOverlapped = NULL<br>0019FBA8   00000000     Callback = NULL<br>0019FBD0   008861A0   game.00B91FA0                         game.0088619B                 0019FBDC<br>0019FBE0   00B90F27   包含game.008861A0                       game.00B90F25                 0019FBDC<br>0019FBF0   76EA5CAB   包含game.00B90F27                       user32.76EA5CA9               0019FC18<br>0019FC1C   76E967BC   user32.76EA5C80                       user32.76E967B7               0019FC18<br>0019FD00   76E958FB   user32.76E96410                       user32.76E958F6               0019FCFC<br>0019FD74   76E956D0   user32.76E956E0                       user32.76E956CB               0019FD70<br>0019FD80   00504E2D   user32.DispatchMessageW               game.00504E27                 0019FD7C<br>0019FD84   0019FE9C     pMsg = MSG(9C40) hw = C07DA (“192.<br>0019FEDC   00416EF9   ? game.00504AD0                       game.00416EF4                 0019FED8</p>
<p>走路的调用堆栈如下：</p>
<p>调用堆栈：     主线程<br>地址       堆栈       函数过程 / 参数                       调用来自                      结构<br>0019FB8C   00B921B6   ws2_32.WSASend                        game.00B921B0                 0019FBDC<br>0019FB90   00000A74     Socket = A74<br>0019FB94   0019FBC0     pBuffers = 0019FBC0<br>0019FB98   00000001     nBuffers = 1<br>0019FB9C   0019FBBC     pBytesSent = 0019FBBC<br>0019FBA0   00000000     Flags = 0<br>0019FBA4   00000000     pOverlapped = NULL<br>0019FBA8   00000000     Callback = NULL<br>0019FBD0   008861A0   game.00B91FA0                         game.0088619B                 0019FBDC<br>0019FBE0   00B90F27   包含game.008861A0                       game.00B90F25                 0019FBDC<br>0019FBF0   76EA5CAB   包含game.00B90F27                       user32.76EA5CA9               0019FC18<br>0019FC1C   76E967BC   user32.76EA5C80                       user32.76E967B7               0019FC18<br>0019FD00   76E958FB   user32.76E96410                       user32.76E958F6               0019FCFC<br>0019FD74   76E956D0   user32.76E956E0                       user32.76E956CB               0019FD70<br>0019FD80   00504E2D   user32.DispatchMessageW               game.00504E27                 0019FD7C<br>0019FD84   0019FE9C     pMsg = MSG(9C40) hw = C07DA (“192.<br>0019FEDC   00416EF9   ? game.00504AD0                       game.00416EF4                 0019FED8</p>
<p>由上可以发现喊话和走路的调用堆栈完全一样，因此可知极大概率是线程发包</p>
<h3 id="跳出线程发包"><a href="#跳出线程发包" class="headerlink" title="跳出线程发包"></a>跳出线程发包</h3><h5 id="判断该线程发包是否地址不变？变的话向上追来源，找到不变的一层地址即为跳出线程发包的突破口。"><a href="#判断该线程发包是否地址不变？变的话向上追来源，找到不变的一层地址即为跳出线程发包的突破口。" class="headerlink" title="判断该线程发包是否地址不变？变的话向上追来源，找到不变的一层地址即为跳出线程发包的突破口。"></a>判断该线程发包是否地址不变？变的话向上追来源，找到不变的一层地址即为跳出线程发包的突破口。</h5><p>WSASend多次下断找到包内容地址并不相同，说明需要向上追内容来源找到不变的包内容地址作为跳出线程发包的地址。</p>
<p>向上追来源</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200527130037272.png" alt="image-20200527130037272"></p>
<p>[该call第二个参数+4]为包地址</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200527131220102.png" alt="image-20200527131220102"></p>
<p>此处edx+esi由于多次下断edx均为0，直接视edx为0，继续追esi。</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200527132100884.png" alt="image-20200527132100884"></p>
<p>任何主动行为都是edi==0D64200C一直不变，某个心跳包会出现edi==2986f00c</p>
<p>edi+2888追到此</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200527135319069.png" alt="image-20200527135319069"></p>
<p>或者直接给edi+2888的地址下写入断点，发现一次是在发包call之后的清零操作，一次就是上图这次的赋值操作。</p>
<p>此时在上图处下断会发现（下断后观察调用堆栈得出）还是在线程发包的调用流程中。</p>
<p>因此继续往上追</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200527140538839.png" alt="image-20200527140538839"></p>
<p>任何主动行为都是edx==2169A7D0，但心跳包偶尔会出现edx==34DC97B0</p>
<p>edx下写入断</p>
<p>断下两处位置，观察调用堆栈得出两次位置均已跳出发包线程，两处断下一次为赋值操作，不同行为赋不同值，另一个断点为设置其值为自身地址的清零操作。</p>
<p>跳出线程后位置：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200527142213922.png" alt="image-20200527142213922"></p>
<p>同时下断WSASend处和上图处观察包内容是否一致来验证逆向追来源是否依然正确？</p>
<p>验证后得知 [[ebp+8]+4]==包地址 该表达式正确！</p>
<p>通过调用堆栈那观察是否有喊话call判断是否真正跳出线程发包。由此确定已跳出线程。</p>
<h3 id="找明文封包call-1"><a href="#找明文封包call-1" class="headerlink" title="找明文封包call"></a>找明文封包call</h3><p>跳出线程位置下断逐层分析。发现跳出一层就已经是铭文包了，利用喊话来寻找明文。发现该call的[edi+4]为明文地址</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200527154018241.png" alt="image-20200527154018241"></p>
<p>喊话一长串1断下后找到313131313131的长串字符，并且该call无论是走路还是喊话都会断下，说明返回一层的call就是明文封包call。</p>
<h2 id="找加密call"><a href="#找加密call" class="headerlink" title="找加密call"></a>找加密call</h2><p>由此可知该明文封包call内到线程发包跳出点之间一定有加密call，并且发现明文所在地址和密文所在地址为同一个地址，即不改存位置，直接在原地址加密。因此断下单步执行观察明文何时变成密文直接确定加密call位置。</p>
<p>确定加密call位置，分析如下：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200527170418581.png" alt="image-20200527170418581"></p>
<p>逆向寻找密钥来源：</p>
<p>$$<br>疑似指向密钥的指针==[[[[[0F84BA4]]+4]+0c+8]]+54<br>$$<br>p.s.该加密call的ecx无用，因为call内第一句有关ecx的代码是用别的值覆盖ecx。</p>
<p>代码注入器测试加密call：(12345678会崩溃，实际上要找一个无用的地址)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">push 12345678</span><br><span class="line">push 12345678</span><br><span class="line">push 11</span><br><span class="line">mov ecx,[00F84BA4]</span><br><span class="line">mov ecx,[ecx]</span><br><span class="line">mov ecx,[ecx+4]</span><br><span class="line">mov ecx,[ecx+14]</span><br><span class="line">mov ecx,[ecx]</span><br><span class="line">lea ecx,[ecx+54]</span><br><span class="line">push ecx</span><br><span class="line">call 00B94700</span><br><span class="line">add esp,10</span><br></pre></td></tr></table></figure>

<p>7E 00 00 00 00 02 00 31 31 FF FF FF FF 00 00 00 00 00 00 00</p>
<p>p.s.</p>
<p>包地址开始处：</p>
<p>30A72F40  007E0016  game.007E0016<br>30A72F44  07000000<br>30A72F48  31313100<br>30A72F4C  31313131<br>30A72F50  FFFFFFFF<br>30A72F54  00000000</p>
<p>加密开始处：</p>
<p>30A72F3E  00160000<br>30A72F42  0000007E<br>30A72F46  31000700<br>30A72F4A  31313131<br>30A72F4E  FFFF3131<br>30A72F52  0000FFFF<br>30A72F56  00000000</p>
<p>测试加密前：</p>
<p>12345678  0000007E<br>1234567C  31000200<br>12345680  FFFFFF31<br>12345684  000000FF<br>12345688  00000000</p>
<p>测试加密后：</p>
<p>12345678  6BA1F264<br>1234567C  0E5FA901<br>12345680  6DD87FAF<br>12345684  16781C93<br>12345688  0000009A</p>
<h3 id="vs借用游戏代码实现喊话功能"><a href="#vs借用游戏代码实现喊话功能" class="headerlink" title="vs借用游戏代码实现喊话功能"></a>vs借用游戏代码实现喊话功能</h3><p>逆向得到socket套接字如下：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200528140218927.png" alt="image-20200528140218927"></p>
<p>socket套接字的地址为：GetWindowLongW的返回值+38<br>$$<br>套接字为socket套接字=[GetWindowLongW的返回值+38]<br>$$<br>vs代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">byte 包内容[<span class="number">100</span>] = &#123;<span class="number">0x11</span>,<span class="number">0x00</span>,<span class="number">0x7E</span>,<span class="number">0x00</span>,</span><br><span class="line">		<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x02</span>,</span><br><span class="line">		<span class="number">0x00</span>,<span class="number">0x31</span>,<span class="number">0x31</span>,<span class="number">0xFF</span>,</span><br><span class="line">		<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0x00</span>,</span><br><span class="line">		<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">		<span class="number">0x00</span>,<span class="number">0x00</span>&#125;;</span><br><span class="line">	DWORD 包长 = <span class="number">0x13</span>;</span><br><span class="line">	DWORD 加密长 = (DWORD)包长 - <span class="number">2</span>;</span><br><span class="line">	DWORD 加密地址 = (DWORD)包内容 + <span class="number">2</span>;</span><br><span class="line">	<span class="comment">//用游戏本身的call来加密</span></span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		push 加密地址</span><br><span class="line">		push 加密地址</span><br><span class="line">		push 加密长</span><br><span class="line">		mov ecx, <span class="number">0x00F84BA4</span></span><br><span class="line">		mov ecx,[ecx]</span><br><span class="line">		mov ecx, [ecx]</span><br><span class="line">		mov ecx, [ecx + <span class="number">0x4</span>]</span><br><span class="line">		mov ecx, [ecx + <span class="number">0x14</span>]</span><br><span class="line">		mov ecx, [ecx]</span><br><span class="line">		lea ecx, [ecx + <span class="number">0x54</span>]</span><br><span class="line">		push ecx</span><br><span class="line">		mov eax, <span class="number">0x00B94700</span></span><br><span class="line">		call eax</span><br><span class="line">		add esp, <span class="number">0x10</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取socket</span></span><br><span class="line">	HWND hwnd = (HWND)<span class="built_in">FindWindowA</span>(<span class="string">&quot;Lapis Network Class&quot;</span>, <span class="number">0</span>);</span><br><span class="line">	DWORD socket = <span class="built_in">GetWindowLongW</span>(hwnd, GWL_USERDATA);</span><br><span class="line">	socket = *(DWORD*)(socket + <span class="number">0x38</span>);</span><br><span class="line">	<span class="comment">//调用发包函数</span></span><br><span class="line">	<span class="built_in">send</span>(socket, (<span class="keyword">const</span> <span class="keyword">char</span>*)包内容, 包长, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h3 id="偷功能（不走游戏代码）"><a href="#偷功能（不走游戏代码）" class="headerlink" title="偷功能（不走游戏代码）"></a>偷功能（不走游戏代码）</h3><p>加密call全部汇编如下：（该范围内所有跳转不会跳出这个范围，说明这是完整的加密call）（内部无其他call）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line">00B94700  /$  55            push    ebp</span><br><span class="line">00B94701  |.  53            push    ebx</span><br><span class="line">00B94702  |.  56            push    esi</span><br><span class="line">00B94703  |.  57            push    edi</span><br><span class="line">00B94704  |.  8B7C24 14     mov     edi, dword ptr [esp+14]</span><br><span class="line">00B94708  |.  8B5424 18     mov     edx, dword ptr [esp+18]</span><br><span class="line">00B9470C  |.  8B7424 1C     mov     esi, dword ptr [esp+1C]</span><br><span class="line">00B94710  |.  8B6C24 20     mov     ebp, dword ptr [esp+20]</span><br><span class="line">00B94714  |.  31C0          xor     eax, eax</span><br><span class="line">00B94716  |.  31DB          xor     ebx, ebx</span><br><span class="line">00B94718  |.  83FA 00       cmp     edx, 0</span><br><span class="line">00B9471B  |.  0F84 56010000 je      00B94877</span><br><span class="line">00B94721  |.  8A07          mov     al, byte ptr [edi]</span><br><span class="line">00B94723  |.  8A5F 04       mov     bl, byte ptr [edi+4]</span><br><span class="line">00B94726  |.  83C7 08       add     edi, 8</span><br><span class="line">00B94729  |.  8D0C16        lea     ecx, dword ptr [esi+edx]</span><br><span class="line">00B9472C  |.  29F5          sub     ebp, esi</span><br><span class="line">00B9472E  |.  894C24 18     mov     dword ptr [esp+18], ecx</span><br><span class="line">00B94732  |.  FEC0          inc     al</span><br><span class="line">00B94734  |.  83BF 00010000&gt;cmp     dword ptr [edi+100], -1</span><br><span class="line">00B9473B  |.  0F84 FF000000 je      00B94840</span><br><span class="line">00B94741  |.  8B0C87        mov     ecx, dword ptr [edi+eax*4]</span><br><span class="line">00B94744  |.  83E2 FC       and     edx, FFFFFFFC</span><br><span class="line">00B94747  |.  0F84 B3000000 je      00B94800</span><br><span class="line">00B9474D  |.  8D5416 FC     lea     edx, dword ptr [esi+edx-4]</span><br><span class="line">00B94751  |.  895424 1C     mov     dword ptr [esp+1C], edx</span><br><span class="line">00B94755  |.  896C24 20     mov     dword ptr [esp+20], ebp</span><br><span class="line">00B94759  |.  90            nop</span><br><span class="line">00B9475A  |.  90            nop</span><br><span class="line">00B9475B  |.  90            nop</span><br><span class="line">00B9475C  |.  90            nop</span><br><span class="line">00B9475D  |.  90            nop</span><br><span class="line">00B9475E  |.  90            nop</span><br><span class="line">00B9475F  |.  90            nop</span><br><span class="line">00B94760  |&gt;  00CB          /add     bl, cl</span><br><span class="line">00B94762  |.  8B149F        |mov     edx, dword ptr [edi+ebx*4]</span><br><span class="line">00B94765  |.  890C9F        |mov     dword ptr [edi+ebx*4], ecx</span><br><span class="line">00B94768  |.  891487        |mov     dword ptr [edi+eax*4], edx</span><br><span class="line">00B9476B  |.  01CA          |add     edx, ecx</span><br><span class="line">00B9476D  |.  FEC0          |inc     al</span><br><span class="line">00B9476F  |.  81E2 FF000000 |and     edx, 0FF</span><br><span class="line">00B94775  |.  8B0C87        |mov     ecx, dword ptr [edi+eax*4]</span><br><span class="line">00B94778  |.  8B2C97        |mov     ebp, dword ptr [edi+edx*4]</span><br><span class="line">00B9477B  |.  00CB          |add     bl, cl</span><br><span class="line">00B9477D  |.  8B149F        |mov     edx, dword ptr [edi+ebx*4]</span><br><span class="line">00B94780  |.  890C9F        |mov     dword ptr [edi+ebx*4], ecx</span><br><span class="line">00B94783  |.  891487        |mov     dword ptr [edi+eax*4], edx</span><br><span class="line">00B94786  |.  01CA          |add     edx, ecx</span><br><span class="line">00B94788  |.  FEC0          |inc     al</span><br><span class="line">00B9478A  |.  81E2 FF000000 |and     edx, 0FF</span><br><span class="line">00B94790  |.  C1CD 08       |ror     ebp, 8</span><br><span class="line">00B94793  |.  8B0C87        |mov     ecx, dword ptr [edi+eax*4]</span><br><span class="line">00B94796  |.  0B2C97        |or      ebp, dword ptr [edi+edx*4]</span><br><span class="line">00B94799  |.  00CB          |add     bl, cl</span><br><span class="line">00B9479B  |.  8B149F        |mov     edx, dword ptr [edi+ebx*4]</span><br><span class="line">00B9479E  |.  890C9F        |mov     dword ptr [edi+ebx*4], ecx</span><br><span class="line">00B947A1  |.  891487        |mov     dword ptr [edi+eax*4], edx</span><br><span class="line">00B947A4  |.  01CA          |add     edx, ecx</span><br><span class="line">00B947A6  |.  FEC0          |inc     al</span><br><span class="line">00B947A8  |.  81E2 FF000000 |and     edx, 0FF</span><br><span class="line">00B947AE  |.  C1CD 08       |ror     ebp, 8</span><br><span class="line">00B947B1  |.  8B0C87        |mov     ecx, dword ptr [edi+eax*4]</span><br><span class="line">00B947B4  |.  0B2C97        |or      ebp, dword ptr [edi+edx*4]</span><br><span class="line">00B947B7  |.  00CB          |add     bl, cl</span><br><span class="line">00B947B9  |.  8B149F        |mov     edx, dword ptr [edi+ebx*4]</span><br><span class="line">00B947BC  |.  890C9F        |mov     dword ptr [edi+ebx*4], ecx</span><br><span class="line">00B947BF  |.  891487        |mov     dword ptr [edi+eax*4], edx</span><br><span class="line">00B947C2  |.  01CA          |add     edx, ecx</span><br><span class="line">00B947C4  |.  FEC0          |inc     al</span><br><span class="line">00B947C6  |.  81E2 FF000000 |and     edx, 0FF</span><br><span class="line">00B947CC  |.  C1CD 08       |ror     ebp, 8</span><br><span class="line">00B947CF  |.  8B4C24 20     |mov     ecx, dword ptr [esp+20]</span><br><span class="line">00B947D3  |.  0B2C97        |or      ebp, dword ptr [edi+edx*4]</span><br><span class="line">00B947D6  |.  C1CD 08       |ror     ebp, 8</span><br><span class="line">00B947D9  |.  332E          |xor     ebp, dword ptr [esi]</span><br><span class="line">00B947DB  |.  3B7424 1C     |cmp     esi, dword ptr [esp+1C]</span><br><span class="line">00B947DF  |.  892C31        |mov     dword ptr [ecx+esi], ebp</span><br><span class="line">00B947E2  |.  8D76 04       |lea     esi, dword ptr [esi+4]</span><br><span class="line">00B947E5  |.  8B0C87        |mov     ecx, dword ptr [edi+eax*4]</span><br><span class="line">00B947E8  |.^ 0F82 72FFFFFF \jb      00B94760</span><br><span class="line">00B947EE  |.  3B7424 18     cmp     esi, dword ptr [esp+18]</span><br><span class="line">00B947F2  |.  0F84 77000000 je      00B9486F</span><br><span class="line">00B947F8  |.  8B6C24 20     mov     ebp, dword ptr [esp+20]</span><br><span class="line">00B947FC  |.  90            nop</span><br><span class="line">00B947FD  |.  90            nop</span><br><span class="line">00B947FE  |.  90            nop</span><br><span class="line">00B947FF  |.  90            nop</span><br><span class="line">00B94800  |&gt;  00CB          /add     bl, cl</span><br><span class="line">00B94802  |.  8B149F        |mov     edx, dword ptr [edi+ebx*4]</span><br><span class="line">00B94805  |.  890C9F        |mov     dword ptr [edi+ebx*4], ecx</span><br><span class="line">00B94808  |.  891487        |mov     dword ptr [edi+eax*4], edx</span><br><span class="line">00B9480B  |.  01CA          |add     edx, ecx</span><br><span class="line">00B9480D  |.  FEC0          |inc     al</span><br><span class="line">00B9480F  |.  81E2 FF000000 |and     edx, 0FF</span><br><span class="line">00B94815  |.  8B1497        |mov     edx, dword ptr [edi+edx*4]</span><br><span class="line">00B94818  |.  3216          |xor     dl, byte ptr [esi]</span><br><span class="line">00B9481A  |.  8D76 01       |lea     esi, dword ptr [esi+1]</span><br><span class="line">00B9481D  |.  8B0C87        |mov     ecx, dword ptr [edi+eax*4]</span><br><span class="line">00B94820  |.  3B7424 18     |cmp     esi, dword ptr [esp+18]</span><br><span class="line">00B94824  |.  885435 FF     |mov     byte ptr [ebp+esi-1], dl</span><br><span class="line">00B94828  |.^ 0F82 D2FFFFFF \jb      00B94800</span><br><span class="line">00B9482E  |.  E9 3C000000   jmp     00B9486F</span><br><span class="line">00B94833  |   90            nop</span><br><span class="line">00B94834  |   90            nop</span><br><span class="line">00B94835  |   90            nop</span><br><span class="line">00B94836  |   90            nop</span><br><span class="line">00B94837  |   90            nop</span><br><span class="line">00B94838  |   90            nop</span><br><span class="line">00B94839  |   90            nop</span><br><span class="line">00B9483A  |   90            nop</span><br><span class="line">00B9483B  |   90            nop</span><br><span class="line">00B9483C  |   90            nop</span><br><span class="line">00B9483D  |   90            nop</span><br><span class="line">00B9483E  |   90            nop</span><br><span class="line">00B9483F  |   90            nop</span><br><span class="line">00B94840  |&gt;  0FB60C07      movzx   ecx, byte ptr [edi+eax]</span><br><span class="line">00B94844  |&gt;  00CB          /add     bl, cl</span><br><span class="line">00B94846  |.  0FB6141F      |movzx   edx, byte ptr [edi+ebx]</span><br><span class="line">00B9484A  |.  880C1F        |mov     byte ptr [edi+ebx], cl</span><br><span class="line">00B9484D  |.  881407        |mov     byte ptr [edi+eax], dl</span><br><span class="line">00B94850  |.  00CA          |add     dl, cl</span><br><span class="line">00B94852  |.  0FB61417      |movzx   edx, byte ptr [edi+edx]</span><br><span class="line">00B94856  |.  04 01         |add     al, 1</span><br><span class="line">00B94858  |.  3216          |xor     dl, byte ptr [esi]</span><br><span class="line">00B9485A  |.  8D76 01       |lea     esi, dword ptr [esi+1]</span><br><span class="line">00B9485D  |.  0FB60C07      |movzx   ecx, byte ptr [edi+eax]</span><br><span class="line">00B94861  |.  3B7424 18     |cmp     esi, dword ptr [esp+18]</span><br><span class="line">00B94865  |.  885435 FF     |mov     byte ptr [ebp+esi-1], dl</span><br><span class="line">00B94869  |.^ 0F82 D5FFFFFF \jb      00B94844</span><br><span class="line">00B9486F  |&gt;  FEC8          dec     al</span><br><span class="line">00B94871  |.  885F FC       mov     byte ptr [edi-4], bl</span><br><span class="line">00B94874  |.  8847 F8       mov     byte ptr [edi-8], al</span><br><span class="line">00B94877  |&gt;  5F            pop     edi</span><br><span class="line">00B94878  |.  5E            pop     esi</span><br><span class="line">00B94879  |.  5B            pop     ebx</span><br><span class="line">00B9487A  |.  5D            pop     ebp</span><br><span class="line">00B9487B  \.  C3            retn；</span><br></pre></td></tr></table></figure>

<p>处理步骤：</p>
<ol>
<li>十进制转换为十六进制</li>
<li>mov exx，[基地址]这种情况需要处理</li>
<li>跳转处理</li>
</ol>
<p>处理后的代码封装成加密call函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line">__declspec(naked) <span class="keyword">void</span> 加密<span class="built_in">call</span>(DWORD 密钥, DWORD 加密长度, DWORD 加密地址, DWORD 加密地址<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		push    ebp</span><br><span class="line">		push    ebx</span><br><span class="line">			push    esi</span><br><span class="line">			push    edi</span><br><span class="line">			mov     edi, dword ptr[esp + <span class="number">0x14</span>]</span><br><span class="line">			mov     edx, dword ptr[esp + <span class="number">0x18</span>]</span><br><span class="line">			mov     esi, dword ptr[esp + <span class="number">0x1C</span>]</span><br><span class="line">			mov     ebp, dword ptr[esp + <span class="number">0x20</span>]</span><br><span class="line">			<span class="keyword">xor</span> eax, eax</span><br><span class="line">			<span class="keyword">xor</span>     ebx, ebx</span><br><span class="line">			cmp     edx, <span class="number">0</span></span><br><span class="line">			je      label1</span><br><span class="line">			mov     al, byte ptr[edi]</span><br><span class="line">			mov     bl, byte ptr[edi + <span class="number">4</span>]</span><br><span class="line">			add     edi, <span class="number">8</span></span><br><span class="line">			lea     ecx, dword ptr[esi + edx]</span><br><span class="line">			sub     ebp, esi</span><br><span class="line">			mov     dword ptr[esp + <span class="number">0x18</span>], ecx</span><br><span class="line">			inc     al</span><br><span class="line">			cmp     dword ptr[edi + <span class="number">0x100</span>], <span class="number">-1</span></span><br><span class="line">			je      label2</span><br><span class="line">			mov     ecx, dword ptr[edi + eax * <span class="number">4</span>]</span><br><span class="line">			<span class="keyword">and</span> edx, <span class="number">0xFFFFFFFC</span></span><br><span class="line">			je      label3</span><br><span class="line">			lea     edx, dword ptr[esi + edx - <span class="number">4</span>]</span><br><span class="line">			mov     dword ptr[esp + <span class="number">0x1C</span>], edx</span><br><span class="line">			mov     dword ptr[esp + <span class="number">0x20</span>], ebp</span><br><span class="line">			nop</span><br><span class="line">			nop</span><br><span class="line">			nop</span><br><span class="line">			nop</span><br><span class="line">			nop</span><br><span class="line">			nop</span><br><span class="line">			nop</span><br><span class="line">			label4 :</span><br><span class="line">		add     bl, cl</span><br><span class="line">			mov     edx, dword ptr[edi + ebx * <span class="number">4</span>]</span><br><span class="line">			mov     dword ptr[edi + ebx * <span class="number">4</span>], ecx</span><br><span class="line">			mov     dword ptr[edi + eax * <span class="number">4</span>], edx</span><br><span class="line">			add     edx, ecx</span><br><span class="line">			inc     al</span><br><span class="line">			<span class="keyword">and</span>     edx, <span class="number">0x0FF</span></span><br><span class="line">			mov     ecx, dword ptr[edi + eax * <span class="number">4</span>]</span><br><span class="line">			mov     ebp, dword ptr[edi + edx * <span class="number">4</span>]</span><br><span class="line">			add     bl, cl</span><br><span class="line">			mov     edx, dword ptr[edi + ebx * <span class="number">4</span>]</span><br><span class="line">			mov     dword ptr[edi + ebx * <span class="number">4</span>], ecx</span><br><span class="line">			mov     dword ptr[edi + eax * <span class="number">4</span>], edx</span><br><span class="line">			add     edx, ecx</span><br><span class="line">			inc     al</span><br><span class="line">			<span class="keyword">and</span>     edx, <span class="number">0x0FF</span></span><br><span class="line">			ror     ebp, <span class="number">8</span></span><br><span class="line">			mov     ecx, dword ptr[edi + eax * <span class="number">4</span>]</span><br><span class="line">			<span class="keyword">or</span> ebp, dword ptr[edi + edx * <span class="number">4</span>]</span><br><span class="line">			add     bl, cl</span><br><span class="line">			mov     edx, dword ptr[edi + ebx * <span class="number">4</span>]</span><br><span class="line">			mov     dword ptr[edi + ebx * <span class="number">4</span>], ecx</span><br><span class="line">			mov     dword ptr[edi + eax * <span class="number">4</span>], edx</span><br><span class="line">			add     edx, ecx</span><br><span class="line">			inc     al</span><br><span class="line">			<span class="keyword">and</span>     edx, <span class="number">0x0FF</span></span><br><span class="line">			ror     ebp, <span class="number">8</span></span><br><span class="line">			mov     ecx, dword ptr[edi + eax * <span class="number">4</span>]</span><br><span class="line">			<span class="keyword">or</span> ebp, dword ptr[edi + edx * <span class="number">4</span>]</span><br><span class="line">			add     bl, cl</span><br><span class="line">			mov     edx, dword ptr[edi + ebx * <span class="number">4</span>]</span><br><span class="line">			mov     dword ptr[edi + ebx * <span class="number">4</span>], ecx</span><br><span class="line">			mov     dword ptr[edi + eax * <span class="number">4</span>], edx</span><br><span class="line">			add     edx, ecx</span><br><span class="line">			inc     al</span><br><span class="line">			<span class="keyword">and</span>     edx, <span class="number">0x0FF</span></span><br><span class="line">			ror     ebp, <span class="number">8</span></span><br><span class="line">			mov     ecx, dword ptr[esp + <span class="number">0x20</span>]</span><br><span class="line">			<span class="keyword">or</span> ebp, dword ptr[edi + edx * <span class="number">4</span>]</span><br><span class="line">			ror     ebp, <span class="number">8</span></span><br><span class="line">			<span class="keyword">xor</span> ebp, dword ptr[esi]</span><br><span class="line">			cmp     esi, dword ptr[esp + <span class="number">0x1C</span>]</span><br><span class="line">			mov     dword ptr[ecx + esi], ebp</span><br><span class="line">			lea     esi, dword ptr[esi + <span class="number">4</span>]</span><br><span class="line">			mov     ecx, dword ptr[edi + eax * <span class="number">4</span>]</span><br><span class="line">			jb      label4</span><br><span class="line">			cmp     esi, dword ptr[esp + <span class="number">0x18</span>]</span><br><span class="line">			je      label5</span><br><span class="line">			mov     ebp, dword ptr[esp + <span class="number">0x20</span>]</span><br><span class="line">			nop</span><br><span class="line">			nop</span><br><span class="line">			nop</span><br><span class="line">			nop</span><br><span class="line">			label3 :</span><br><span class="line">		add     bl, cl</span><br><span class="line">			mov     edx, dword ptr[edi + ebx * <span class="number">4</span>]</span><br><span class="line">			mov     dword ptr[edi + ebx * <span class="number">4</span>], ecx</span><br><span class="line">			mov     dword ptr[edi + eax * <span class="number">4</span>], edx</span><br><span class="line">			add     edx, ecx</span><br><span class="line">			inc     al</span><br><span class="line">			<span class="keyword">and</span>     edx, <span class="number">0x0FF</span></span><br><span class="line">			mov     edx, dword ptr[edi + edx * <span class="number">4</span>]</span><br><span class="line">			<span class="keyword">xor</span> dl, byte ptr[esi]</span><br><span class="line">			lea     esi, dword ptr[esi + <span class="number">1</span>]</span><br><span class="line">			mov     ecx, dword ptr[edi + eax * <span class="number">4</span>]</span><br><span class="line">			cmp     esi, dword ptr[esp + <span class="number">0x18</span>]</span><br><span class="line">			mov     byte ptr[ebp + esi - <span class="number">1</span>], dl</span><br><span class="line">			jb      label3</span><br><span class="line">			jmp     label5</span><br><span class="line">			nop</span><br><span class="line">			nop</span><br><span class="line">			nop</span><br><span class="line">			nop</span><br><span class="line">			nop</span><br><span class="line">			nop</span><br><span class="line">			nop</span><br><span class="line">			nop</span><br><span class="line">			nop</span><br><span class="line">			nop</span><br><span class="line">			nop</span><br><span class="line">			nop</span><br><span class="line">			nop</span><br><span class="line">			label2 :</span><br><span class="line">		movzx   ecx, byte ptr[edi + eax]</span><br><span class="line">			label6 :</span><br><span class="line">			add     bl, cl</span><br><span class="line">			movzx   edx, byte ptr[edi + ebx]</span><br><span class="line">			mov     byte ptr[edi + ebx], cl</span><br><span class="line">			mov     byte ptr[edi + eax], dl</span><br><span class="line">			add     dl, cl</span><br><span class="line">			movzx   edx, byte ptr[edi + edx]</span><br><span class="line">			add     al, <span class="number">1</span></span><br><span class="line">			<span class="keyword">xor</span> dl, byte ptr[esi]</span><br><span class="line">			lea     esi, dword ptr[esi + <span class="number">1</span>]</span><br><span class="line">			movzx   ecx, byte ptr[edi + eax]</span><br><span class="line">			cmp     esi, dword ptr[esp + <span class="number">0x18</span>]</span><br><span class="line">			mov     byte ptr[ebp + esi - <span class="number">1</span>], dl</span><br><span class="line">			jb      label6</span><br><span class="line">			label5 :</span><br><span class="line">		dec     al</span><br><span class="line">			mov     byte ptr[edi - <span class="number">4</span>], bl</span><br><span class="line">			mov     byte ptr[edi - <span class="number">8</span>], al</span><br><span class="line">			label1 :</span><br><span class="line">		pop     edi</span><br><span class="line">			pop     esi</span><br><span class="line">			pop     ebx</span><br><span class="line">			pop     ebp</span><br><span class="line">			retn</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不走游戏代码实现喊话：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">byte 包内容[<span class="number">100</span>] = &#123; <span class="number">0x11</span>,<span class="number">0x00</span>,<span class="number">0x7E</span>,<span class="number">0x00</span>,</span><br><span class="line">		<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x02</span>,</span><br><span class="line">		<span class="number">0x00</span>,<span class="number">0x31</span>,<span class="number">0x31</span>,<span class="number">0xFF</span>,</span><br><span class="line">		<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0x00</span>,</span><br><span class="line">		<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">		<span class="number">0x00</span>,<span class="number">0x00</span> &#125;;</span><br><span class="line">	DWORD 包长 = <span class="number">0x13</span>;</span><br><span class="line">	DWORD 加密长 = (DWORD)包长 - <span class="number">2</span>;</span><br><span class="line">	DWORD 加密地址 = (DWORD)包内容 + <span class="number">2</span>;</span><br><span class="line">	DWORD 密钥=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">//读密钥</span></span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		mov ecx, <span class="number">0x00F84BA4</span></span><br><span class="line">		mov ecx, [ecx]</span><br><span class="line">		mov ecx, [ecx]</span><br><span class="line">		mov ecx, [ecx + <span class="number">0x4</span>]</span><br><span class="line">		mov ecx, [ecx + <span class="number">0x14</span>]</span><br><span class="line">		mov ecx, [ecx]</span><br><span class="line">		lea ecx, [ecx + <span class="number">0x54</span>]</span><br><span class="line">		mov 密钥,ecx</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//偷游戏代码自己来加密</span></span><br><span class="line">	加密<span class="built_in">call</span>(密钥, 加密长, 加密地址, 加密地址);</span><br><span class="line">	<span class="comment">//获取socket</span></span><br><span class="line">	HWND hwnd = (HWND)<span class="built_in">FindWindowA</span>(<span class="string">&quot;Lapis Network Class&quot;</span>, <span class="number">0</span>);</span><br><span class="line">	DWORD socket = <span class="built_in">GetWindowLongW</span>(hwnd, GWL_USERDATA);</span><br><span class="line">	socket = *(DWORD*)(socket + <span class="number">0x38</span>);</span><br><span class="line">	<span class="comment">//调用发包函数</span></span><br><span class="line">	<span class="built_in">send</span>(socket, (<span class="keyword">const</span> <span class="keyword">char</span>*)包内容, 包长, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h2 id="找明文收包"><a href="#找明文收包" class="headerlink" title="找明文收包"></a>找明文收包</h2><p>判断是哪种收包，下断能断发现是WSARecv.</p>
<p>结合api分析：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200530123037751.png" alt="image-20200530123037751"></p>
<p>收包内容地址固定，在比较远的位置下硬件访问断来断下我们的超长文本收包，然后到游戏中喊话一大段1111……（如图位置下断避开其他包的干扰）（喊话既发包，也收包）。此处访问断断下的位置要么是解密call，要么是位置迁移（此处下软件断会崩溃）</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200530123208857.png" alt="image-20200530123208857"></p>
<p>断在此处：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0041608A   .  F3:A5         rep     movs dword ptr es:[edi], dword ptr [esi]     ;  收包内容从缓存区取出位置</span><br></pre></td></tr></table></figure>

<p>保持断下状态，删除硬件断点再在edi指向位置下硬件访问断（断下位置依然要么是位置迁移，要么是解密）</p>
<p>又断下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00B947DB  |.  3B7424 1C     |cmp     esi, dword ptr [esp+1C]                           ;  解密中位置</span><br></pre></td></tr></table></figure>

<p>此时发现数据区如下：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200530124227755.png" alt="image-20200530124227755"></p>
<p>其中出现明文，可知此处是正在解密中的位置，ctrl+f9返回上一层即解密call</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200530124751654.png" alt="image-20200530124751654"></p>
<p>由此发现，此处找到的解密call和上面找到的加密call为同一个call，说明该加密为对称性加密，此call为加解密call。</p>
<p>分析:</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200530131542117.png" alt="image-20200530131542117"></p>
<p>由此可知，ebx为明文收包</p>
<h2 id="HOOK明文发包"><a href="#HOOK明文发包" class="headerlink" title="HOOK明文发包"></a>HOOK明文发包</h2><p>hook此处：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00B92C82  |&gt; \8B46 08       mov     eax, dword ptr [esi+8]</span><br><span class="line">00B92C85  |.  2BC1          sub     eax, ecx</span><br></pre></td></tr></table></figure>

<h4 id="不用改的工具函数如下"><a href="#不用改的工具函数如下" class="headerlink" title="不用改的工具函数如下"></a>不用改的工具函数如下</h4><p>提升权限函数代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//OpenProcess失败的时候用</span></span><br><span class="line">BOOL Call_提升权限(BOOL bEnable)</span><br><span class="line">&#123;</span><br><span class="line">	BOOL foK = FALSE;</span><br><span class="line">	HANDLE hToken;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">OpenProcessToken</span>(<span class="built_in">GetCurrentProcess</span>(),TOKEN_ADJUST_PRIVILEGES,&amp;hToken))<span class="comment">//打开进程访问令牌</span></span><br><span class="line">	&#123;</span><br><span class="line">		TOKEN_PRIVILEGES tp;</span><br><span class="line">		tp.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">LookupPrivilegeValue</span>(<span class="literal">NULL</span>, SE_DEBUG_NAME, &amp;tp.Privileges[<span class="number">0</span>].Luid);</span><br><span class="line">		tp.Privileges[<span class="number">0</span>].Attributes = bEnable ? SE_PRIVILEGE_ENABLED : <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">AdjustTokenPrivileges</span>(hToken, FALSE, &amp;tp, <span class="built_in"><span class="keyword">sizeof</span></span>(tp), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">		foK = (<span class="built_in">GetLastError</span>() == ERROR_SUCCESS);</span><br><span class="line">		<span class="built_in">CloseHandle</span>(hToken);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> foK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将调试信息输出到debug view上的函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出调试信息函数</span></span><br><span class="line"><span class="keyword">void</span> Call_输出调试信息(<span class="keyword">char</span>* pszFormat, ...)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">	<span class="keyword">char</span> szbufFormat[<span class="number">0x1000</span>];</span><br><span class="line">	<span class="keyword">char</span> szbufFormat_Game[<span class="number">0x1100</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	va_list arglst;<span class="comment">//指向参数列表的指针</span></span><br><span class="line">	<span class="comment">//参数列表初始化，vp指向pszFormat后第一个可变参数</span></span><br><span class="line">	<span class="built_in">va_start</span>(arglst, pszFormat);</span><br><span class="line">	<span class="built_in">vsprintf_s</span>(szbufFormat,pszFormat, arglst);</span><br><span class="line">	<span class="built_in">strcat_s</span>(szbufFormat_Game, szbufFormat);</span><br><span class="line">	<span class="built_in">OutputDebugStringA</span>(szbufFormat_Game);</span><br><span class="line">	<span class="built_in">va_end</span>(arglst);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="hook需要改动的函数如下"><a href="#hook需要改动的函数如下" class="headerlink" title="hook需要改动的函数如下"></a>hook需要改动的函数如下</h4><p>用内存的方式找窗口句柄：（通过spy++配合ce搜索找基地址）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不用findwindow找窗口句柄，而是用基地址的方式找到存窗口句柄的位置</span></span><br><span class="line">HWND Call_获取窗口句柄()</span><br><span class="line">&#123;</span><br><span class="line">	HWND hGame;</span><br><span class="line">	hGame = *(HWND*)<span class="number">0x00F7BFB0</span>;</span><br><span class="line">	<span class="keyword">return</span> hGame;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HOOK跳转目标的子函数的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hook目标子函数</span></span><br><span class="line">__declspec(naked) <span class="keyword">void</span> 明文包<span class="built_in">HOOKcalll</span>()</span><br><span class="line">&#123;</span><br><span class="line">	__asm </span><br><span class="line">	&#123;</span><br><span class="line">		pushad</span><br><span class="line">		mov ecx, [esi + <span class="number">4</span>]</span><br><span class="line">		mov eax, [esi + <span class="number">8</span>]</span><br><span class="line">		mov g_包地址, ecx</span><br><span class="line">		sub eax, ecx</span><br><span class="line">		mov g_包长, eax</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//openprocess失败的时候用这个提升exe权限</span></span><br><span class="line">	Call_提升权限(TRUE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过窗口句柄获取进程id</span></span><br><span class="line">	<span class="built_in">GetWindowThreadProcessId</span>(Call_获取窗口句柄(), &amp;pid);</span><br><span class="line">	<span class="comment">//通过进程id获取进程句柄</span></span><br><span class="line">	hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line"></span><br><span class="line">	 p = <span class="keyword">new</span> byte[g_包长];</span><br><span class="line">	 <span class="comment">//p是封包字节集指针</span></span><br><span class="line">	 <span class="built_in">ReadProcessMemory</span>(hProcess, (LPCVOID)g_包地址,p, g_包长, <span class="number">0</span>);</span><br><span class="line">	 <span class="comment">//补上游戏需要的包长</span></span><br><span class="line">	 *(WORD*)p = g_包长 - <span class="number">2</span>;</span><br><span class="line">	 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	 <span class="comment">//将封包字节集中的字符按照一个字节一个字节的方式存到a里</span></span><br><span class="line">	 <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)g_包长;i++)</span><br><span class="line">	 &#123;</span><br><span class="line">		 <span class="built_in">sprintf</span>(s, <span class="string">&quot;%02X&quot;</span>, p[i]);</span><br><span class="line">		 <span class="built_in">strcat_s</span>(a, s);</span><br><span class="line"></span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="comment">//在debug view中输出调试信息</span></span><br><span class="line">	 Call_输出调试信息(<span class="string">&quot;幻想神域   包长：%x   包地址%x    包内容:%s\r\n&quot;</span>, g_包长, g_包地址,a);</span><br><span class="line">	 <span class="comment">//将a清零</span></span><br><span class="line">	 <span class="built_in">sprintf</span>(a, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">	 <span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line">	__asm </span><br><span class="line">	&#123;</span><br><span class="line">		popad</span><br><span class="line">		mov eax,[esi+<span class="number">8</span>]</span><br><span class="line">		sub eax,ecx</span><br><span class="line">		retn</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>p.s.补上游戏需要的包长的意思是，由于我们在游戏中hook的位置是游戏本身补上包长之前，因此手动补上</p>
<p>hook代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hook明文发包</span></span><br><span class="line">DWORD Hook地址 = <span class="number">0x00B92C82</span>;</span><br><span class="line">DWORD Hook子程序指针 = (DWORD)明文包HOOKcalll;</span><br><span class="line">DWORD 跳转值 = Hook子程序指针 - Hook地址 - <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DWORD old = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//修改内存属性为可读可写(修改地址起始地址，长度，修改为什么属性，保存原有的属性)</span></span><br><span class="line"><span class="built_in">VirtualProtect</span>((PVOID)<span class="number">0x00B92C82</span>, <span class="number">100</span>, PAGE_EXECUTE_READWRITE, &amp;old);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//改写hook位置 (call 跳转值)</span></span><br><span class="line">*(BYTE*)<span class="number">0x00B92C82</span> = <span class="number">0xE8</span>;</span><br><span class="line">*(DWORD*)(<span class="number">0x00B92C82</span>+<span class="number">1</span>) = 跳转值;</span><br><span class="line"></span><br><span class="line"><span class="comment">//还原页面属性</span></span><br><span class="line"><span class="built_in">VirtualProtect</span>((PVOID)<span class="number">0x00B92C82</span>, <span class="number">100</span>, old, &amp;old);</span><br></pre></td></tr></table></figure>

<p>还原hook代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DWORD old = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//修改内存属性为可读可写(修改地址起始地址，长度，修改为什么属性，保存原有的属性)</span></span><br><span class="line"><span class="built_in">VirtualProtect</span>((PVOID)<span class="number">0x00B92C82</span>, <span class="number">100</span>, PAGE_EXECUTE_READWRITE, &amp;old);</span><br><span class="line"></span><br><span class="line"><span class="comment">//写回原来的值</span></span><br><span class="line">*(BYTE*)<span class="number">0x00B92C82</span> = <span class="number">0x8B</span>;</span><br><span class="line">*(DWORD*)(<span class="number">0x00B92C82</span> + <span class="number">1</span>) = <span class="number">0xC12B0846</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//还原页面属性</span></span><br><span class="line"><span class="built_in">VirtualProtect</span>((PVOID)<span class="number">0x00B92C82</span>, <span class="number">100</span>, old, &amp;old);</span><br></pre></td></tr></table></figure>

<h2 id="HOOK明文收包"><a href="#HOOK明文收包" class="headerlink" title="HOOK明文收包"></a>HOOK明文收包</h2><p>hook此处</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00B92931  |.  8BAE 74280000     |mov     ebp, dword ptr [esi+2874]</span><br></pre></td></tr></table></figure>

<p>hook代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">DWORD g_收包地址=<span class="number">0</span>;</span><br><span class="line">DWORD g_收包包长 =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> 明文收包通用解决办法()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//openprocess失败的时候用这个提升exe权限</span></span><br><span class="line">	Call_提升权限(TRUE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过窗口句柄获取进程id</span></span><br><span class="line">	<span class="built_in">GetWindowThreadProcessId</span>(Call_获取窗口句柄(), &amp;pid);</span><br><span class="line"></span><br><span class="line">	p = <span class="keyword">new</span> byte[g_收包包长];</span><br><span class="line">	<span class="comment">//通过进程id获取进程句柄</span></span><br><span class="line">	hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line">	<span class="comment">//p是封包字节集指针</span></span><br><span class="line">	BOOL isok=<span class="built_in">ReadProcessMemory</span>(hProcess, (LPCVOID)g_收包地址, p, g_收包包长, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (isok)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//将封包字节集中的字符按照一个字节一个字节的方式存到a里</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)g_收包包长; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">sprintf</span>(s, <span class="string">&quot;%02X&quot;</span>, p[i]);</span><br><span class="line">			<span class="built_in">strcat_s</span>(a, s);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//在debug view中输出调试信息</span></span><br><span class="line">		Call_输出调试信息(<span class="string">&quot;幻想神域   收包地址%x   收包包长:%x  收包内容:%s\r\n&quot;</span>, g_收包地址, g_收包包长, a);</span><br><span class="line">		<span class="comment">//将a清零</span></span><br><span class="line">		<span class="built_in">sprintf</span>(a, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		Call_输出调试信息(<span class="string">&quot;幻想神域   错误码:%d&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">__declspec(naked) <span class="keyword">void</span> 明文收包<span class="built_in">HOOKcalll</span>()</span><br><span class="line">&#123;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		pushad</span><br><span class="line">		mov edi,[edi]</span><br><span class="line">		mov ecx,[edi+<span class="number">4</span>]</span><br><span class="line">		mov g_收包地址,ecx</span><br><span class="line">		mov eax,[edi+<span class="number">8</span>]</span><br><span class="line">		sub eax,ecx</span><br><span class="line">		mov g_收包包长, eax</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	明文收包通用解决办法();</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		popad</span><br><span class="line">		mov ebp,[esi+<span class="number">0x2874</span>]</span><br><span class="line">		retn</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//hook明文收包</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyDialog::OnBnClickedButton6</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">	DWORD Hook地址 = <span class="number">0x00B92931</span>;</span><br><span class="line">	DWORD Hook子程序指针 = (DWORD)明文收包HOOKcalll;</span><br><span class="line">	DWORD 跳转值 = Hook子程序指针 - Hook地址 - <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	DWORD old = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//修改内存属性为可读可写(修改地址起始地址，长度，修改为什么属性，保存原有的属性)</span></span><br><span class="line">	<span class="built_in">VirtualProtect</span>((PVOID)<span class="number">0x00B92931</span>, <span class="number">100</span>, PAGE_EXECUTE_READWRITE, &amp;old);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//改写hook位置 (call 跳转值)</span></span><br><span class="line">	*(BYTE*)<span class="number">0x00B92931</span> = <span class="number">0xE8</span>;</span><br><span class="line">	*(DWORD*)(<span class="number">0x00B92931</span> + <span class="number">1</span>) = 跳转值;</span><br><span class="line">	*(BYTE*)(<span class="number">0x00B92931</span>+<span class="number">5</span>) = <span class="number">0x90</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//还原页面属性</span></span><br><span class="line">	<span class="built_in">VirtualProtect</span>((PVOID)<span class="number">0x00B92931</span>, <span class="number">100</span>, old, &amp;old);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//还原HOOK明文收包</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyDialog::OnBnClickedButton7</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">	DWORD old = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//修改内存属性为可读可写(修改地址起始地址，长度，修改为什么属性，保存原有的属性)</span></span><br><span class="line">	<span class="built_in">VirtualProtect</span>((PVOID)<span class="number">0x00B92931</span>, <span class="number">100</span>, PAGE_EXECUTE_READWRITE, &amp;old);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//写回原来的值</span></span><br><span class="line">	*(WORD*)<span class="number">0x00B92931</span> = <span class="number">0xAE8B</span>;</span><br><span class="line">	*(DWORD*)(<span class="number">0x00B92931</span> + <span class="number">2</span>) = <span class="number">0x00002874</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//还原页面属性</span></span><br><span class="line">	<span class="built_in">VirtualProtect</span>((PVOID)<span class="number">0x00B92931</span>, <span class="number">100</span>, old, &amp;old);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>明文收包通用解决办法函数是为了解决不明所以的问题，不嵌套这层函数游戏会崩溃。</p>
<p>至于为什么，不能理解。</p>
<h2 id="发送封包实现任意功能"><a href="#发送封包实现任意功能" class="headerlink" title="发送封包实现任意功能"></a>发送封包实现任意功能</h2><p>单个封包的功能是很单一的，比方说让他打怪就一定不会有走路</p>
<h3 id="工具函数如下"><a href="#工具函数如下" class="headerlink" title="工具函数如下:"></a>工具函数如下:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2字符转Bytes(工具函数)</span></span><br><span class="line">BYTE Call_2字符转<span class="built_in">Byte</span>(<span class="keyword">char</span> ch1, <span class="keyword">char</span> ch2)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> S;</span><br><span class="line">	<span class="comment">//数字</span></span><br><span class="line">	<span class="keyword">if</span> ((ch1&gt;=<span class="number">48</span>)&amp;&amp;(ch1&lt;=<span class="number">57</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		S = ch1 - <span class="number">48</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//A-F</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> ((ch1 &gt;= <span class="number">65</span>) &amp;&amp; (ch1 &lt;= <span class="number">70</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		S = ch1 - <span class="number">65</span> + <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((ch2 &gt;= <span class="number">48</span>) &amp;&amp; (ch2 &lt;= <span class="number">57</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> S * <span class="number">16</span> + ch2 - <span class="number">48</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> ((ch2 &gt;= <span class="number">65</span>) &amp;&amp; (ch2 &lt;= <span class="number">70</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> S * <span class="number">16</span> + ch2 - <span class="number">65</span> + <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="发送封包函数如下："><a href="#发送封包函数如下：" class="headerlink" title="发送封包函数如下："></a>发送封包函数如下：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送封包</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyDialog::OnBnClickedButton8</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">	<span class="comment">//字符串转回字节数组start------------------------------------------------</span></span><br><span class="line">	<span class="comment">//编辑框内容赋值给变量</span></span><br><span class="line">	<span class="built_in">UpdateData</span>(TRUE);</span><br><span class="line">	CString 输入的待发包长 = EditKitsize;</span><br><span class="line">	CString 输入的待发包内容 = EditKitContent;</span><br><span class="line">	<span class="keyword">int</span> 待发包长 = <span class="built_in">strtol</span>((<span class="keyword">const</span> <span class="keyword">char</span>*)<span class="built_in">CW2A</span>(输入的待发包长.<span class="built_in">GetBuffer</span>(<span class="number">0</span>)),<span class="literal">NULL</span>,<span class="number">16</span>);</span><br><span class="line">	string str = <span class="built_in">CW2A</span>(输入的待发包内容.<span class="built_in">GetString</span>());</span><br><span class="line">	byte 待发包内容[<span class="number">0x200</span>];</span><br><span class="line">	<span class="keyword">int</span> len = str.<span class="built_in">size</span>() / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		待发包内容[i] = Call_2字符转<span class="built_in">Byte</span>(str[<span class="number">2</span> * i], str[<span class="number">2</span> * i + <span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//字符串转回字节数组end------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	DWORD 加密长 = (DWORD)待发包长 - <span class="number">2</span>;</span><br><span class="line">	DWORD 加密地址 = (DWORD)待发包内容 + <span class="number">2</span>;</span><br><span class="line">	DWORD 密钥 = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//读密钥</span></span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		mov ecx, <span class="number">0x00F84BA4</span></span><br><span class="line">		mov ecx, [ecx]</span><br><span class="line">			mov ecx, [ecx]</span><br><span class="line">			mov ecx, [ecx + <span class="number">0x4</span>]</span><br><span class="line">			mov ecx, [ecx + <span class="number">0x14</span>]</span><br><span class="line">			mov ecx, [ecx]</span><br><span class="line">			lea ecx, [ecx + <span class="number">0x54</span>]</span><br><span class="line">			mov 密钥, ecx</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//偷游戏代码自己来加密</span></span><br><span class="line">	加密<span class="built_in">call</span>(密钥, 加密长, 加密地址, 加密地址);</span><br><span class="line">	<span class="comment">//获取socket</span></span><br><span class="line">	HWND hwnd = (HWND)<span class="built_in">FindWindowA</span>(<span class="string">&quot;Lapis Network Class&quot;</span>, <span class="number">0</span>);</span><br><span class="line">	DWORD socket = <span class="built_in">GetWindowLongW</span>(hwnd, GWL_USERDATA);</span><br><span class="line">	socket = *(DWORD*)(socket + <span class="number">0x38</span>);</span><br><span class="line">	<span class="comment">//调用发包函数</span></span><br><span class="line">	<span class="built_in">send</span>(socket, (<span class="keyword">const</span> <span class="keyword">char</span>*)待发包内容, 待发包长, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试发现，此处在测试框发包只能发大写才有效，小写字母无法识别。</p>
<h3 id="吃药封包call"><a href="#吃药封包call" class="headerlink" title="吃药封包call"></a>吃药封包call</h3><p>通用功能函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Call_发送封包(DWORD 待发包长,DWORD 待发包内容)</span><br><span class="line">&#123;</span><br><span class="line">	DWORD 加密长 = (DWORD)待发包长 - <span class="number">2</span>;</span><br><span class="line">	DWORD 加密地址 = (DWORD)待发包内容 + <span class="number">2</span>;</span><br><span class="line">	DWORD 密钥 = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//读密钥</span></span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		mov ecx, <span class="number">0x00F84BA4</span></span><br><span class="line">		mov ecx, [ecx]</span><br><span class="line">			mov ecx, [ecx]</span><br><span class="line">			mov ecx, [ecx + <span class="number">0x4</span>]</span><br><span class="line">			mov ecx, [ecx + <span class="number">0x14</span>]</span><br><span class="line">			mov ecx, [ecx]</span><br><span class="line">			lea ecx, [ecx + <span class="number">0x54</span>]</span><br><span class="line">			mov 密钥, ecx</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//偷游戏代码自己来加密</span></span><br><span class="line">	加密<span class="built_in">call</span>(密钥, 加密长, 加密地址, 加密地址);</span><br><span class="line">	<span class="comment">//获取socket</span></span><br><span class="line">	HWND hwnd = (HWND)<span class="built_in">FindWindowA</span>(<span class="string">&quot;Lapis Network Class&quot;</span>, <span class="number">0</span>);</span><br><span class="line">	DWORD socket = <span class="built_in">GetWindowLongW</span>(hwnd, GWL_USERDATA);</span><br><span class="line">	socket = *(DWORD*)(socket + <span class="number">0x38</span>);</span><br><span class="line">	<span class="comment">//调用发包函数</span></span><br><span class="line">	<span class="built_in">send</span>(socket, (<span class="keyword">const</span> <span class="keyword">char</span>*)待发包内容, 待发包长, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析明文发包发现:</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200617150015519.png" alt="image-20200617150015519"></p>
<p>实现吃药封包call</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Call_吃药封包(<span class="keyword">char</span>* 药品名称)</span><br><span class="line">&#123;</span><br><span class="line">	byte b[<span class="number">0x16</span>] = &#123; <span class="number">0x14</span>,<span class="number">00</span>,<span class="number">0x4f</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span> ,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span> ,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span> ,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span> &#125;;</span><br><span class="line">	T遍历背包信息 t;</span><br><span class="line">	t.初始化背包信息();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.d数量;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(药品名称,t.背包列表[i].cGBK名字)==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			*(WORD*)(b + <span class="number">6</span>) = t.背包列表[i].d所在背包;</span><br><span class="line">			*(WORD*)(b + <span class="number">8</span>) = t.背包列表[i].d位置;</span><br><span class="line">			Call_发送封包(<span class="number">0x16</span>, (DWORD)b); </span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用吃药封包call</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Call_吃药封包(<span class="string">&quot;輕型HP藥水&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="自动吃药"><a href="#自动吃药" class="headerlink" title="自动吃药"></a>自动吃药</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">DWORD g_自动吃药开关标志 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">void</span> 自动吃药线程函数()</span><br><span class="line">&#123;</span><br><span class="line">	T人物信息 t;</span><br><span class="line">	<span class="keyword">while</span> (g_自动吃药开关标志)</span><br><span class="line">	&#123;</span><br><span class="line">		t.初始化人物信息();</span><br><span class="line">		<span class="keyword">if</span> (t.d对象&lt;t.d最大血量*<span class="number">0.8</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			Call_吃药封包(<span class="string">&quot;輕型HP藥水&quot;</span>);</span><br><span class="line">			<span class="built_in">Sleep</span>(<span class="number">3000</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开关自动吃药按钮</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyDialog::OnBnClickedButton16</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">	<span class="keyword">if</span> (g_自动吃药开关标志)</span><br><span class="line">	&#123;</span><br><span class="line">		g_自动吃药开关标志 = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">SetDlgItemText</span>(IDC_BUTTON16, <span class="string">L&quot;开启自动吃药&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		::<span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>, (LPTHREAD_START_ROUTINE)自动吃药线程函数, <span class="literal">NULL</span>, <span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">		g_自动吃药开关标志 = <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">SetDlgItemText</span>(IDC_BUTTON16, <span class="string">L&quot;关闭自动吃药&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="攻击性技能封包call"><a href="#攻击性技能封包call" class="headerlink" title="攻击性技能封包call"></a>攻击性技能封包call</h3><p>hook明文发包，放3号键格子里的该技能id为CAC3分析：</p>
<p>[5956] 幻想神域   包长：c   包地址1e1fb2d0    包内容:0A005500C3CA46FFFEFF0000 </p>
<p>[5956] 幻想神域   包长：c   包地址1e228a00    包内容:0A005500C3CA47FCFFFF0000 </p>
<p>该技能放在5号格子里释放：</p>
<p>[5956] 幻想神域   包长：c   包地址1e1fcc90    包内容:0A005500C3CA21FFFEFF0000 </p>
<p>放在2号格子里的技能id为CABE的技能</p>
<p>[5956] 幻想神域   包长：c   包地址1e1fdb20    包内容:0A005500BECA53B0FEFF0000 </p>
<p>可以看出来技能封包结构为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">包长：c       包内容：0A00（真实包长）  +  5500（放技能头） +  BECA(技能id) + 53B0FEFF（怪物id） +0000 （这个实际上也和蓄力有关）</span><br></pre></td></tr></table></figure>

<p>每次放完技能后都会有一个这样的封包：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">包长:6         包内容:040043000000           似乎是心跳包</span><br></pre></td></tr></table></figure>

<p>这个直接不发送也可以，但为了尽量保证安全，要尽量和游戏本身发送的封包一致，避免被封禁。游戏中每次放技能都会带一个这个心跳包，所以我们也照做。</p>
<p>用发包封包函数尝试判断分析无误</p>
<p>明文包加密发包工具：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Call_发送封包(DWORD 待发包长,DWORD 待发包内容)</span><br><span class="line">&#123;</span><br><span class="line">	DWORD 加密长 = (DWORD)待发包长 - <span class="number">2</span>;</span><br><span class="line">	DWORD 加密地址 = (DWORD)待发包内容 + <span class="number">2</span>;</span><br><span class="line">	DWORD 密钥 = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//读密钥</span></span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		mov ecx, <span class="number">0x00F84BA4</span></span><br><span class="line">		mov ecx, [ecx]</span><br><span class="line">			mov ecx, [ecx]</span><br><span class="line">			mov ecx, [ecx + <span class="number">0x4</span>]</span><br><span class="line">			mov ecx, [ecx + <span class="number">0x14</span>]</span><br><span class="line">			mov ecx, [ecx]</span><br><span class="line">			lea ecx, [ecx + <span class="number">0x54</span>]</span><br><span class="line">			mov 密钥, ecx</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//偷游戏代码自己来加密</span></span><br><span class="line">	加密<span class="built_in">call</span>(密钥, 加密长, 加密地址, 加密地址);</span><br><span class="line">	<span class="comment">//获取socket</span></span><br><span class="line">	HWND hwnd = (HWND)<span class="built_in">FindWindowA</span>(<span class="string">&quot;Lapis Network Class&quot;</span>, <span class="number">0</span>);</span><br><span class="line">	DWORD socket = <span class="built_in">GetWindowLongW</span>(hwnd, GWL_USERDATA);</span><br><span class="line">	socket = *(DWORD*)(socket + <span class="number">0x38</span>);</span><br><span class="line">	<span class="comment">//调用发包函数</span></span><br><span class="line">	<span class="built_in">send</span>(socket, (<span class="keyword">const</span> <span class="keyword">char</span>*)待发包内容, 待发包长, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Call_释放攻击性技能(DWORD 技能id,DWORD 怪物id)</span><br><span class="line">&#123;</span><br><span class="line">	BYTE a[<span class="number">12</span>] = &#123; <span class="number">0x0A</span>,<span class="number">0x00</span>,<span class="number">0x55</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span> ,<span class="number">0x00</span> ,<span class="number">0x00</span> ,<span class="number">0x00</span> ,<span class="number">0x00</span> &#125;;</span><br><span class="line">	*(WORD*)(a + <span class="number">4</span>) = (WORD)技能id;</span><br><span class="line">	*(DWORD*)(a + <span class="number">6</span>) =怪物id;</span><br><span class="line">	Call_发送封包(<span class="number">0xc</span>, (DWORD)a);</span><br><span class="line"></span><br><span class="line">	BYTE b[<span class="number">6</span>] = &#123; <span class="number">0x04</span>,<span class="number">0x00</span>,<span class="number">0x43</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span> &#125;;</span><br><span class="line">	Call_发送封包(<span class="number">0x6</span>, (DWORD)b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> g_自动打怪开关标志 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">void</span> 打怪线程()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (g_自动打怪开关标志)</span><br><span class="line">	&#123;</span><br><span class="line">		Call_自动打一只最近的目标怪(<span class="string">&quot;暴躁鸚鵡&quot;</span>);</span><br><span class="line">		<span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//开关自动打怪</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyDialog::OnBnClickedButton19</span><span class="params">()</span><span class="comment">//按钮代码</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//<span class="doctag">BUG:</span>从没目标怪的区域跑进目标怪区域会崩溃</span></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">	<span class="keyword">if</span> (g_自动打怪开关标志)</span><br><span class="line">	&#123;</span><br><span class="line">		g_自动打怪开关标志 = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">SetDlgItemText</span>(IDC_BUTTON19, <span class="string">L&quot;开启自动打怪&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		g_自动打怪开关标志 = <span class="number">1</span>;</span><br><span class="line">		::<span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>, (LPTHREAD_START_ROUTINE)打怪线程, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="built_in">SetDlgItemText</span>(IDC_BUTTON19, <span class="string">L&quot;关闭自动打怪&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现BUG:从没目标怪的区域跑进目标怪区域会崩溃！</p>
<h2 id="寻路CALL"><a href="#寻路CALL" class="headerlink" title="寻路CALL"></a>寻路CALL</h2><p>一般来说，得到了加密封包就可以实现几乎所有功能，但是封包只能用来实现走路，却很难实现寻路，因此寻路还是要靠调用游戏自身的寻路call来实现。游戏没有自带寻路功能的话就可以录制寻路点，或者用A星算法写自动寻路。</p>
<p>因此，寻找寻路call：</p>
<p>寻路call一般是线程循环寻路，所以单纯用发包断很多游戏是断不到的。因此可以通过寻路的目的地或寻路的标志位来找。</p>
<p>用寻路的目的地来找的时候，浮点数区间一定要大。尝试后，扫不到就把范围变大。不移动的时候目标点坐标不变化，寻路开始的时候目标点先变化一次，然后寻路过程中目标点一直不变化。</p>
<p>找到的所有结果如下：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200623115813014.png" alt="image-20200623115813014"></p>
<p>内存布局和下写入断断下与否分析：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200623125915308.png" alt="image-20200623125915308"></p>
<p>走路（直接点地形）也会断，说明与寻路call关联小一些。</p>
<p>此处分析过程有待完善！！！！！！！！！</p>
<p>跳过各种分析过程，找到参数比较多的call比较好，因为便于分析。</p>
<p>最终定位到寻路call位置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">009265B2  |&gt; \0FBF96 C80100&gt;movsx   edx, word ptr [esi+1C8]</span><br><span class="line">009265B9  |.  6A 01         push    1                                ;  1</span><br><span class="line">009265BB  |.  6A 00         push    0                                ;  0</span><br><span class="line">009265BD  |.  6A 00         push    0                                ;  0</span><br><span class="line">009265BF  |.  8D4D E4       lea     ecx, dword ptr [ebp-1C]</span><br><span class="line">009265C2  |.  51            push    ecx                              ;  目标坐标结构体（浮点x,浮点y,整形x,整形y）</span><br><span class="line">009265C3  |.  8B0D 744BF800 mov     ecx, dword ptr [F84B74]</span><br><span class="line">009265C9  |.  52            push    edx                              ;  3 疑似地图id，一般人物对象中有挂着，实际位置为[人物信息+3a4]，没挂着就往上找来源呗</span><br><span class="line">009265CA  |.  E8 711DDBFF   call    006D8340                         ;  取人物对象</span><br><span class="line">009265CF  |.  8BC8          mov     ecx, eax                         ;  ecx==人物对象</span><br><span class="line">009265D1  |.  E8 8AA7DCFF   call    006F0D60                         ;  寻路call</span><br><span class="line">009265D6  |.  5F            pop     edi</span><br><span class="line">009265D7  |.  B0 01         mov     al, 1</span><br><span class="line">009265D9  |.  5E            pop     esi</span><br></pre></td></tr></table></figure>

<p>用代码注入器进行检测：</p>
<p>先给12345678地址写入目标坐标结构体：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200623134251855.png" alt="image-20200623134251855"></p>
<p>然后代码注入器内代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">push 1</span><br><span class="line">push 0</span><br><span class="line">push 0</span><br><span class="line">push 12345678</span><br><span class="line">push 3</span><br><span class="line">mov ecx,[0F84B74]</span><br><span class="line">call 06d8340</span><br><span class="line">mov ecx,eax</span><br><span class="line">call 06f0d60</span><br></pre></td></tr></table></figure>

<p>成功寻路！</p>
<p>因此该call可行。</p>
<p>寻路工具函数如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Call_寻路(<span class="keyword">float</span> x, <span class="keyword">float</span> y)</span><br><span class="line">&#123;</span><br><span class="line">	__try</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//DWORD 开辟的目标地址 = (DWORD)malloc(sizeof(float) * 4);</span></span><br><span class="line">		byte 开辟的目标地址[<span class="number">0x10</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">		*(<span class="keyword">float</span>*)开辟的目标地址 = x;</span><br><span class="line">		*(<span class="keyword">float</span>*)(开辟的目标地址 + <span class="number">4</span>) = y;</span><br><span class="line">		*(<span class="keyword">int</span>*)(开辟的目标地址 + <span class="number">8</span>) = (<span class="keyword">int</span>)x;</span><br><span class="line">		*(<span class="keyword">int</span>*)(开辟的目标地址 + <span class="number">0x0c</span>) = (<span class="keyword">int</span>)y;</span><br><span class="line">		DWORD A=(DWORD)开辟的目标地址;<span class="comment">//局部变量开辟的空间要在asm中使用必须另外一个局部变量存该地址</span></span><br><span class="line">		__asm</span><br><span class="line">		&#123;</span><br><span class="line">			pushad</span><br><span class="line">			push <span class="number">1</span></span><br><span class="line">			push <span class="number">0</span></span><br><span class="line">			push <span class="number">0</span></span><br><span class="line">			push A</span><br><span class="line">			mov ecx, <span class="number">0x0F84B74</span></span><br><span class="line">			mov ecx, [ecx]</span><br><span class="line">			mov eax, <span class="number">0x06d8340</span></span><br><span class="line">			call eax</span><br><span class="line">			mov ecx, eax</span><br><span class="line">			mov eax,[eax+<span class="number">0x0c</span>]</span><br><span class="line">			mov eax, [eax + <span class="number">0x3a4</span>]</span><br><span class="line">			push eax</span><br><span class="line">			mov eax, <span class="number">0x06f0d60</span></span><br><span class="line">			call eax</span><br><span class="line">			popad</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	__except (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Call_输出调试信息(<span class="string">&quot;幻想神域   寻路失败！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用过程代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CString Xstr,Ystr;</span><br><span class="line">	<span class="built_in">GetDlgItemTextW</span>(IDC_EDIT1, Xstr);</span><br><span class="line">	<span class="built_in">GetDlgItemTextW</span>(IDC_EDIT2, Ystr);</span><br><span class="line">	<span class="keyword">float</span> x,y;</span><br><span class="line">	x = _tstof(Xstr);</span><br><span class="line">	y= _tstof(Ystr);</span><br><span class="line">	Call_寻路(x, y);</span><br></pre></td></tr></table></figure>

<p>这里当频繁调用该call的时候会卡死或者崩溃</p>
<h3 id="重点：主线程调用"><a href="#重点：主线程调用" class="headerlink" title="重点：主线程调用"></a>重点：主线程调用</h3><p>排除了所有可能的其他bug外的情况下，这是由于调用的这个call比较复杂，但我们频繁调用call的时候出现访问冲突。</p>
<p>解决方案：主线程调用。（就是说把call放到主线程调用，所有的功能都是按照一个队列执行的，这样不会产生冲突）</p>
<p>很多游戏短时间内运行不崩溃是运气好，当长时间运行的话比如说1,2个小时后崩溃就是因为没有主线程调用的原因。</p>
<p>让call由主线程来实现的原理就是：通过setwindowshookex来hook主线程，因为回调函数是主线程调用的，通过回调函数中调call来实现主线程调用call。然后用发送消息给主线程的消息队列来操作主线程帮你调用call。</p>
<p>代码如下：</p>
<p>发送消息并且通过lparam和rparam携带结构信息来通知主线程的函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个发送明文包其实是多余的，因为我们发送封包不走游戏代码，没必要在主线程调用</span></span><br><span class="line"><span class="keyword">void</span>  Msg_发送明文包(DWORD 包长, DWORD 包地址)</span><br><span class="line">&#123;</span><br><span class="line">	T封包参数 封包;</span><br><span class="line">	封包.包长 = 包长;</span><br><span class="line">	封包.包地址 = 包地址;</span><br><span class="line">	<span class="built_in">SendMessageA</span>(Call_获取窗口句柄(), g_My消息ID, ID_发送封包, (LPARAM)&amp;封包);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>  Msg_寻路(<span class="keyword">float</span> x, <span class="keyword">float</span> y)</span><br><span class="line">&#123;</span><br><span class="line">	T寻路参数 寻路;</span><br><span class="line">	寻路.fx = x;</span><br><span class="line">	寻路.fy = y;</span><br><span class="line">	<span class="built_in">SendMessageA</span>(Call_获取窗口句柄(), g_My消息ID, ID_寻路, (LPARAM)&amp;寻路);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构以及预定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ID_发送封包 1 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ID_寻路 2</span></span><br><span class="line"></span><br><span class="line">HHOOK g_Hook返回;</span><br><span class="line"><span class="comment">//注册一个消息id</span></span><br><span class="line"><span class="keyword">const</span> DWORD g_My消息ID = <span class="built_in">RegisterWindowMessageA</span>(<span class="string">&quot;MyMsyCode&quot;</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T</span>封包参数</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	DWORD 包长;</span><br><span class="line">	DWORD 包地址;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T</span>寻路参数</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">float</span> fx;</span><br><span class="line">	<span class="keyword">float</span> fy;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>hook主线程和取消hook主线程的函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hook主线程</span></span><br><span class="line">DWORD Call_Hook主线程()</span><br><span class="line">&#123;</span><br><span class="line">	HWND hGame = Call_获取窗口句柄();</span><br><span class="line">	DWORD ndThreadId = <span class="built_in">GetWindowThreadProcessId</span>(hGame, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (ndThreadId != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		g_Hook返回 = <span class="built_in">SetWindowsHookEx</span>(WH_CALLWNDPROC, Call_主线程回调函数, <span class="literal">NULL</span>, ndThreadId);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//卸载主线程</span></span><br><span class="line">DWORD Call_卸载Hook主线程()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">UnhookWindowsHookEx</span>(g_Hook返回);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主线程回调函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主线程回调函数</span></span><br><span class="line">LRESULT CALLBACK Call_主线程回调函数(<span class="keyword">int</span> nCode, WPARAM wParam, LPARAM lparam)</span><br><span class="line">&#123;</span><br><span class="line">	CWPSTRUCT *lpArg = (CWPSTRUCT*)lparam;<span class="comment">//结构  hwnd message wParam  lPwaram</span></span><br><span class="line">	<span class="keyword">if</span> (nCode == HC_ACTION)<span class="comment">//自己进程的消息</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (lpArg-&gt;hwnd == Call_获取窗口句柄() &amp;&amp; lpArg-&gt;message == g_My消息ID)<span class="comment">//我们自己的消息</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in"><span class="keyword">switch</span></span> (lpArg-&gt;wParam)<span class="comment">//各个消息处理</span></span><br><span class="line">			&#123;</span><br><span class="line">				T封包参数 *封包;</span><br><span class="line">				T寻路参数 *寻路;</span><br><span class="line">			<span class="keyword">case</span> ID_发送封包:</span><br><span class="line">				Call_输出调试信息(<span class="string">&quot;幻想神域   主线程调用发包\r\n&quot;</span>);</span><br><span class="line">				封包 = (T封包参数*)lpArg-&gt;lParam;</span><br><span class="line">				Call_发送封包(封包-&gt;包长, 封包-&gt;包地址);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> ID_寻路:</span><br><span class="line">				Call_输出调试信息(<span class="string">&quot;幻想神域   主线程调用寻路\r\n&quot;</span>);</span><br><span class="line">				寻路 = (T寻路参数*)lpArg-&gt;lParam;</span><br><span class="line">				Call_寻路(寻路-&gt;fx, 寻路-&gt;fy);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">CallNextHookEx</span>(g_Hook返回, nCode, wParam, lparam);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后自动打怪中只需要把原本的call_寻路换成msg_寻路就可以实现主线程调用call来代替dll的线程来调用call！</p>
<p>然后经测试发现长久时间后，自动打怪也不会让游戏崩溃，但是随后又发现有卡地形的情况出现。</p>
<h2 id="完善自动打怪"><a href="#完善自动打怪" class="headerlink" title="完善自动打怪"></a>完善自动打怪</h2><p>寻路改善为防卡怪寻路，代码如下：（如果5秒没有到达目标点就跳出函数，重新遍历找最新怪物）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Call_寻到(<span class="keyword">float</span> x, <span class="keyword">float</span> y)<span class="comment">//用于打怪防止卡点</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	T人物信息 人物;</span><br><span class="line">	人物.初始化人物信息();</span><br><span class="line">	DWORD 人物对象 = 人物.d对象;</span><br><span class="line">	<span class="keyword">float</span> 距离;</span><br><span class="line">	<span class="keyword">do</span> </span><br><span class="line">	&#123;</span><br><span class="line">		Msg_寻路(x, y);</span><br><span class="line">		<span class="built_in">Sleep</span>(<span class="number">500</span>);</span><br><span class="line">		DWORD Temp = *(DWORD*)(人物对象 + <span class="number">0x10</span>);</span><br><span class="line">		FLOAT X = *(FLOAT*)(Temp + <span class="number">0x154</span>);</span><br><span class="line">		FLOAT Y = *(FLOAT*)(Temp + <span class="number">0x158</span>);</span><br><span class="line">		距离 = <span class="built_in">sqrt</span>((X - x)*(X - x) + (Y - y)*(Y - y));</span><br><span class="line">		i++;</span><br><span class="line">		<span class="keyword">if</span> (i&gt;<span class="number">10</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;<span class="comment">//如果5秒没有到达目标点就跳出函数，重新遍历找最新怪物</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">while</span> (距离&gt;<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>防止卡点打一只怪物的函数代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Call_自动打一只最近的目标怪(<span class="keyword">char</span>* 怪物名称)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">	T链表信息遍历 t;</span><br><span class="line">	t.距离排序信息();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;t.d数量; i++)<span class="comment">//距离最近地开始找</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(t.对象信息[i].cGBK名字, 怪物名称) == <span class="number">0</span>)<span class="comment">//是我们指定的怪</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//还要添加判断是否在攻击距离内。</span></span><br><span class="line">			<span class="keyword">if</span> (t.对象信息[i].d血量== t.对象信息[i].d最大血量)<span class="comment">//没人在打的怪</span></span><br><span class="line">			&#123;</span><br><span class="line">				Call_寻到(t.对象信息[i].fX, t.对象信息[i].fY);</span><br><span class="line">				<span class="comment">//活着就一直攻击</span></span><br><span class="line">				<span class="keyword">while</span> (t.对象信息[i].d血量&gt;<span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					n++;</span><br><span class="line">					<span class="comment">//刷新目标坐标再寻一次</span></span><br><span class="line">					DWORD temp2 = *(DWORD*)(t.对象信息[i].d对象 + <span class="number">0x10</span>);</span><br><span class="line">					t.对象信息[i].fX = *(FLOAT*)(temp2 + <span class="number">0x154</span>);</span><br><span class="line">					t.对象信息[i].fY = *(FLOAT*)(temp2 + <span class="number">0x158</span>);</span><br><span class="line">					Call_寻到(t.对象信息[i].fX, t.对象信息[i].fY);<span class="comment">//防止战斗中怪物脱离我们的范围</span></span><br><span class="line">					Call_输出调试信息(<span class="string">&quot;幻想神域    攻击怪物\r\n&quot;</span>);</span><br><span class="line">					Call_释放攻击性技能(<span class="number">0xCABD</span>, t.对象信息[i].dID);</span><br><span class="line">					<span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line">					<span class="comment">//更新目标血量</span></span><br><span class="line">					DWORD temp = *(DWORD*)(t.对象信息[i].d对象 + <span class="number">0xC</span>);</span><br><span class="line">					t.对象信息[i].d血量 = *(DWORD*)(temp + <span class="number">0x8</span>);</span><br><span class="line">					<span class="keyword">if</span>(n&gt;<span class="number">20</span>)<span class="comment">//防止卡点</span></span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (n &gt; <span class="number">20</span>)<span class="comment">//防止卡点(多久跳出循环，和跳出循环条件需要改善)</span></span><br><span class="line">				&#123;</span><br><span class="line">					n = <span class="number">0</span>;</span><br><span class="line">					<span class="keyword">continue</span>;<span class="comment">//不找最近的怪物，试着找下个近的怪物</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;<span class="comment">//目标怪物已死亡</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中continue是精髓。</p>
<p>上面代码第一行未赋初始值0会直接崩溃，要看看是什么情况。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(n&gt;<span class="number">20</span>)<span class="comment">//防止卡点</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码用于防止一直想走到怪的位置，但是怪的位置不可达时候可以刷新怪物位置，重新尝试寻路到那个怪新的位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (n &gt; 20)//防止卡点(多久跳出循环，和跳出循环条件需要改善)</span><br><span class="line">				&#123;</span><br><span class="line">					n = 0;</span><br><span class="line">					continue;//不找最近的怪物，试着找下个近的怪物</span><br><span class="line">				&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码用于当那个怪物半天都打不到的时候卡住了，跳出循环后依然可能打不到，因此跳出循环换一只怪</p>
<h3 id="技能循环"><a href="#技能循环" class="headerlink" title="技能循环"></a>技能循环</h3><p>判断是否有该技能代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Call_是否有该技能(<span class="keyword">char</span>* 技能名)</span><br><span class="line">&#123;</span><br><span class="line">	T遍历我的技能信息 t;</span><br><span class="line">	t.初始化我的技能信息();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;t.d数量;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(t.技能列表[i].cGBK名字,技能名)==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> TRUE;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断技能是否无冷却代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Call_该技能是否无冷却(<span class="keyword">char</span>* 技能名)</span><br><span class="line">&#123;</span><br><span class="line">	T遍历CD中技能信息 t;</span><br><span class="line">	t.初始化CD中技能信息();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.d数量; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(t.技能列表[i].cGBK名字, 技能名) == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> FALSE;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>技能优先级循环代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Call_智能使用技能(DWORD 怪物id)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (Call_是否有该技能(<span class="string">&quot;瞄準射擊&quot;</span>)&amp;&amp; Call_该技能是否无冷却(<span class="string">&quot;瞄準射擊&quot;</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		Call_释放攻击性技能(<span class="number">0x0CABD</span>, 怪物id);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (Call_是否有该技能(<span class="string">&quot;音速彈&quot;</span>) &amp;&amp; Call_该技能是否无冷却(<span class="string">&quot;音速彈&quot;</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		Call_释放攻击性技能(<span class="number">0x0CAC3</span>, 怪物id);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (Call_是否有该技能(<span class="string">&quot;砲轟&quot;</span>) &amp;&amp; Call_该技能是否无冷却(<span class="string">&quot;砲轟&quot;</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		Call_释放攻击性技能(<span class="number">0x0CABE</span>, 怪物id);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点：设置不同的技能的时候，一定要有公共cd的考量。</p>
<p>能实现放不同的技能打不同的怪物。</p>
<p>依然有bug：</p>
<p>1.某些情况按了自动打怪停止以后依然会寻怪</p>
<p>2.放技能时候误伤到沿路的怪物过来打你，由于血条不满，因此人物对其无反应。</p>
<h3 id="判断障碍点"><a href="#判断障碍点" class="headerlink" title="判断障碍点"></a>判断障碍点</h3><p>在游戏中，当寻路为无法前进的点的时候会显示：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200628115800117.png" alt="image-20200628115800117"></p>
<p>用该字符串作为突破口。</p>
<p>将“目的地為阻擋點，無法前進！   ”转成字符集为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A5 D8 AA BA A6 61 AC B0 AA FD BE D7 C2 49 A1 41 B5 4C AA 6B AB 65 B6 69 A1 49 00</span><br></pre></td></tr></table></figure>

<p>到ce中搜索:</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200628120134118.png" alt="image-20200628120134118"></p>
<p>对半修改发发现第一个地址是真正的字符串地址。</p>
<p>od中dd后下硬件访问断点</p>
<p>下了访问断点后发现正常寻路不会断下，只有走隔绝点才会断下</p>
<p>断下位置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">004149B1  |&gt; /8A08          /mov     cl, byte ptr [eax]              ;  隔绝点访问断在此处</span><br></pre></td></tr></table></figure>

<p>断下位置直接返回上一层到call处进行分析</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">008CB460  |.  E8 2B95B4FF   call    00414990                         ;  隔绝点访问断在此处1</span><br></pre></td></tr></table></figure>

<p>此处正常寻路不断下，非正常寻路断下。</p>
<p>继续返回上一层call：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0089290F  |.  FFD0          call    eax                              ;  隔绝点访问断在此处2</span><br></pre></td></tr></table></figure>

<p>断下秒断，说明此处除了非正常寻路，别的功能也回执行此处。</p>
<p>继续返回上一层call：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00889044  |.  E8 17980000   call    00892860                         ;  隔绝点访问断在此处3</span><br></pre></td></tr></table></figure>

<p>也是断下秒断</p>
<p>继续返回上一层call：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00765A2D  |.  E8 BE351200   call    00888FF0                         ;  隔绝点访问断在此处4</span><br></pre></td></tr></table></figure>

<p>此处正常寻路不断下，非正常寻路断下。</p>
<p>继续返回上一层call：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">006E7BC2  |.  E8 99DC0700   call    00765860                         ;  隔绝点访问断在此处5</span><br></pre></td></tr></table></figure>

<p>此处断下不秒断了。但正常寻路和非正常寻路都会断下，说明此call到内层call（隔绝点访问断在此处4位置）之前有跳转，该跳转决定了是否为正常寻路！</p>
<p>正常寻路与非正常寻路分别单步运行观察跳转情况得出该跳转为关键跳转，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">007659C9  |.  33FF          xor     edi, edi                         ;  di==0</span><br><span class="line">007659CB  |.  66:39BE 7C010&gt;cmp     word ptr [esi+17C], di           ;  障碍点关键跳转 [esi+17C]==0为遇到障碍点</span><br><span class="line">007659D2  |.  0F85 B4000000 jnz     00765A8C</span><br></pre></td></tr></table></figure>

<p>由于此处[esi+17C]是个值，此处追esi没有意义，我们要的是esi+17c地址中的值得来源，因此我们需要的是追[esi+17c]这个整体。</p>
<p>然而向上追的过程中直到函数头esi被改变都没有看见[esi+17c],因此判断是在该过程中的call内改变的。从函数头esi被赋值开始往下单步并且dd esi+17c看果然发现经过以下call值发生变化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0076594E  |.  FFD0          call    eax                              ;  [esi+17c]值清零</span><br></pre></td></tr></table></figure>

<p>以及：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">007659C4  |.  E8 E77E0100   call    0077D8B0                         ;  [esi+17c]值的真正来源</span><br></pre></td></tr></table></figure>

<p>进入上面这个真正来源的call进行单步执行分别判断正常寻路与非正常寻路进行分析：</p>
<p> 定位到是哪里改变了[esi+17c]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0077D9D6  |&gt; \66:8943 64    mov     word ptr [ebx+64], ax            ;  此处真正改变障碍点标志位</span><br></pre></td></tr></table></figure>

<p>发现此处的ebx+64正是外面的esi+17c的地址.</p>
<p>分析发现也就是在外面的call没执行前的ecx+64 为标志位地址，执行完外面的call后改变该地址的值后则可用于判断是否有障碍点。</p>
<p>因此回到上一层call分析ecx的来源。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">007659B0  |&gt; \8B0D 7443F800 mov     ecx, dword ptr [F84374]</span><br><span class="line">007659B6  |.  E8 C59EF1FF   call    0067F880                         ;   [人物对象+2c]+118+64==障碍标志地址</span><br><span class="line">007659BB  |.  8BCF          mov     ecx, edi                         ;  ecx+64==esi+17c==障碍标志地址 ecx==22BC5918 目的地结构信息  [ecx+10]==x [ecx+14]==y   ecx== [人物对象+2c]+118</span><br><span class="line">007659BD  |.  C745 FC 00000&gt;mov     dword ptr [ebp-4], 0</span><br><span class="line">007659C4  |.  E8 E77E0100   call    0077D8B0                         ;  [esi+17c]值的真正来源  标志位的值==word(2AAAAAAB*2AAAAAAB*([ecx+34+8]-[ecx+34+4])&gt;&gt;1)</span><br><span class="line">007659C9  |.  33FF          xor     edi, edi                         ;  di==0</span><br><span class="line">007659CB  |.  66:39BE 7C010&gt;cmp     word ptr [esi+17C], di           ;  障碍点关键跳转 [esi+17C]==0为遇到障碍点</span><br><span class="line">007659D2  |.  0F85 B4000000 jnz     00765A8C</span><br><span class="line">007659D8  |.  393D 7443F800 cmp     dword ptr [F84374], edi</span><br></pre></td></tr></table></figure>

<p>上面的代码分析有误，仔细分析后结构如下：</p>
<p>ecx=[人物对象+2c]+118=寻路结构（该寻路结构在未寻路之前是未被初始化状态的）</p>
<p>ecx+10=目的点x</p>
<p>ecx+14=目的点y</p>
<p>ecx+1C=下一个要寻往的中间点x</p>
<p>ecx+20=下一个要寻往的中间点y</p>
<p>ecx+38=当前点和最终目标点的中间点数组起始地址</p>
<p>ecx+3c=当前点和最终目标点的中间点数组结束地址</p>
<p>ecx+64==上面数组的中间点个数</p>
<p>通过判断下一个要寻往的中间点x，y坐标来确定是否有障碍点，寻路后若有障碍点，该值为0！</p>
<p>因此寻路后通过判断该值来判断是否是障碍点。</p>
<p>封住函数如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//寻一次路后调用该call返回0说明不可达</span></span><br><span class="line">DWORD Call_寻路是否成功()</span><br><span class="line">&#123;</span><br><span class="line">	T人物信息 me;</span><br><span class="line">	me.初始化人物信息();</span><br><span class="line">	DWORD Temp = *(DWORD*)(me.d对象 + <span class="number">0x2c</span>);</span><br><span class="line">	DWORD A= *(DWORD*)(Temp +<span class="number">0x118</span>+ <span class="number">0x1c</span>);</span><br><span class="line">	Call_输出调试信息(<span class="string">&quot;幻想神域     寻路是否成功，返回%X\r\n&quot;</span>,A);</span><br><span class="line">	<span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打怪优化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Call_自动打一只最近的目标怪(<span class="keyword">char</span>* 怪物名称)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">	T链表信息遍历 t;</span><br><span class="line">	t.距离排序信息();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;t.d数量; i++)<span class="comment">//距离最近地开始找</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(t.对象信息[i].cGBK名字, 怪物名称) == <span class="number">0</span>)<span class="comment">//是我们指定的怪</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//还要添加判断是否在攻击距离内。</span></span><br><span class="line">			<span class="keyword">if</span> (t.对象信息[i].d血量== t.对象信息[i].d最大血量)<span class="comment">//没人在打的怪</span></span><br><span class="line">			&#123;</span><br><span class="line">				Msg_寻路(t.对象信息[i].fX, t.对象信息[i].fY);</span><br><span class="line">				<span class="built_in">Sleep</span>(<span class="number">100</span>);</span><br><span class="line">				<span class="keyword">if</span> (Call_寻路是否成功())</span><br><span class="line">				&#123;</span><br><span class="line">					Call_寻到(t.对象信息[i].fX, t.对象信息[i].fY);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					Call_输出调试信息(<span class="string">&quot;幻想神域    卡点，找下只近的怪\r\n&quot;</span>);</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//活着就一直攻击</span></span><br><span class="line">				<span class="keyword">while</span> (t.对象信息[i].d血量&gt;<span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					n++;</span><br><span class="line">					<span class="comment">//刷新目标坐标再寻一次</span></span><br><span class="line">					DWORD temp2 = *(DWORD*)(t.对象信息[i].d对象 + <span class="number">0x10</span>);</span><br><span class="line">					t.对象信息[i].fX = *(FLOAT*)(temp2 + <span class="number">0x154</span>);</span><br><span class="line">					t.对象信息[i].fY = *(FLOAT*)(temp2 + <span class="number">0x158</span>);</span><br><span class="line">					Msg_寻路(t.对象信息[i].fX, t.对象信息[i].fY);</span><br><span class="line">					<span class="keyword">if</span> (Call_寻路是否成功())</span><br><span class="line">					&#123;</span><br><span class="line">						Call_寻到(t.对象信息[i].fX, t.对象信息[i].fY);<span class="comment">//防止战斗中怪物脱离我们的范围</span></span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">					&#123;</span><br><span class="line">						Call_输出调试信息(<span class="string">&quot;幻想神域    正在攻击怪物不可寻路\r\n&quot;</span>);</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">						</span><br><span class="line">					Call_输出调试信息(<span class="string">&quot;幻想神域    攻击怪物\r\n&quot;</span>);</span><br><span class="line">					Call_智能使用技能(t.对象信息[i].dID);</span><br><span class="line">					<span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line">					<span class="comment">//更新目标血量</span></span><br><span class="line">					DWORD temp = *(DWORD*)(t.对象信息[i].d对象 + <span class="number">0xC</span>);</span><br><span class="line">					t.对象信息[i].d血量 = *(DWORD*)(temp + <span class="number">0x8</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;<span class="comment">//目标怪物已死亡</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经测试，已无大碍，但背包满的时候会周围遍历异常，然后崩溃。</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200629131032241.png" alt="image-20200629131032241"></p>
<h3 id="异常bug修复"><a href="#异常bug修复" class="headerlink" title="异常bug修复"></a>异常bug修复</h3><p>实际上当掉落物品时候人物卡住不动是因为上来就遍历周围所有信息的时候，地上的物品也遍历进去了，然而地上的物品是没有血量等信息的，却还尝试读取血量偏移等信息，因此出现异常。</p>
<p>解决代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> T链表信息遍历::初始化对象信息()</span><br><span class="line">&#123;</span><br><span class="line">	__try</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">ZeroMemory</span>(对象信息, <span class="built_in"><span class="keyword">sizeof</span></span>(T人物信息) * <span class="number">1000</span>);</span><br><span class="line">		T人物信息 me;</span><br><span class="line">		me.初始化人物信息();</span><br><span class="line">		DWORD 基地址中 = *(DWORD*)<span class="number">0x0F84B74</span>;</span><br><span class="line">		DWORD tmp = *(DWORD*)(基地址中 + <span class="number">0x418</span>);</span><br><span class="line">		DWORD 链表头 = *(DWORD*)(tmp);</span><br><span class="line">		DWORD 当前链表 = *(DWORD*)(tmp);</span><br><span class="line">		<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (; 当前链表!=tmp; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			DWORD 当前对象 = *(DWORD*)(当前链表+<span class="number">0x0c</span>);</span><br><span class="line">			对象信息[i].d对象 = 当前对象;</span><br><span class="line">			对象信息[i].dID= *(DWORD*)(当前对象 + <span class="number">0x8</span>);</span><br><span class="line">			DWORD 人物属性 = *(DWORD *)(当前对象 + <span class="number">0x0c</span>);</span><br><span class="line">			DWORD 名称长度 = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (人物属性!=<span class="number">0</span>)<span class="comment">//防止遍历地上物品时候异常</span></span><br><span class="line">			&#123;</span><br><span class="line">				对象信息[i].d血量 = *(DWORD *)(人物属性 + <span class="number">0x8</span>);</span><br><span class="line">				对象信息[i].d最大血量 = *(DWORD *)(人物属性 + <span class="number">0x24</span>);</span><br><span class="line">				对象信息[i].d当前等级 = *(DWORD *)(人物属性 + <span class="number">0x10</span>);</span><br><span class="line">				名称长度 = *(DWORD *)(人物属性 + <span class="number">0x114</span>);</span><br><span class="line">				<span class="keyword">if</span> (名称长度 &lt;= <span class="number">0x10</span>)<span class="comment">//地址中直接是字符串</span></span><br><span class="line">				&#123;</span><br><span class="line">					对象信息[i].p名字 = (<span class="keyword">char</span> *)(人物属性 + <span class="number">0x100</span>);</span><br><span class="line">					<span class="built_in">strcpy</span>(对象信息[i].cGBK名字, 对象信息[i].p名字);</span><br><span class="line">					<span class="built_in">BIG52GBK</span>(对象信息[i].cGBK名字);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span><span class="comment">//地址中还要进一层</span></span><br><span class="line">				&#123;</span><br><span class="line">					对象信息[i].p名字 = (<span class="keyword">char</span>*)*(DWORD *)(人物属性 + <span class="number">0x100</span>);</span><br><span class="line">					<span class="built_in">strcpy</span>(对象信息[i].cGBK名字, 对象信息[i].p名字);</span><br><span class="line">					<span class="built_in">BIG52GBK</span>(对象信息[i].cGBK名字);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			DWORD 坐标信息 = *(DWORD *)(当前对象 + <span class="number">0x10</span>);</span><br><span class="line">			<span class="keyword">if</span> (坐标信息!=<span class="number">0</span>)<span class="comment">//防止遍历地上物品时候异常</span></span><br><span class="line">			&#123;</span><br><span class="line">				对象信息[i].fX = *(FLOAT *)(坐标信息 + <span class="number">0x154</span>);</span><br><span class="line">				对象信息[i].fY = *(FLOAT *)(坐标信息 + <span class="number">0x158</span>);</span><br><span class="line">				对象信息[i].fZ = *(FLOAT *)(坐标信息 + <span class="number">0x15c</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			对象信息[i].f距离 = <span class="built_in">sqrt</span>((对象信息[i].fX - me.fX)*(对象信息[i].fX - me.fX) + (对象信息[i].fY - me.fY)*(对象信息[i].fY - me.fY) + (对象信息[i].fZ - me.fZ)*(对象信息[i].fZ - me.fZ));</span><br><span class="line">			当前链表 = *(DWORD*)(当前链表);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		d数量 = i;</span><br><span class="line">	&#125;</span><br><span class="line">	__except (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Call_输出调试信息(<span class="string">&quot;幻想神域   链表信息遍历出错！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自动任务"><a href="#自动任务" class="headerlink" title="自动任务"></a>自动任务</h2><p>通过任务完成与未完成状态来找，或者任务是否接了来做突破口，或者通过任务id来做突破口。</p>
<p>最好的一般是通过任务完成状态来找最佳</p>
<p>一般是两种方案：</p>
<ol>
<li>收集类的任务，收了足够的数量的物品任务完成，丢掉一件，任务恢复未完成状态。</li>
<li>接任务再放弃任务可以改变任务是否接了的状态，但很多游戏一旦放弃任务对象很可能被初始化了，因此此种方法很可能不行。</li>
</ol>
<p>搜索状态类，一般没有都是0，但有的情况什么都有可能。</p>
<p>先尝试方案2，三种状态，任务完成，人物未接，任务接到是各自的标志位置。并且任务未接的时候状态为0。</p>
<p>用ce未知初始值进行筛选突破口。</p>
<p>最终找到唯一一个突破口：2ABAD3AE，二字节</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200629151827052.png" alt="image-20200629151827052"></p>
<p>od中dd该地址下访问断，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">007080A4  |&gt; \66:8B46 0E    mov     ax, word ptr [esi+E]             ;  访问任务状态标志位断在此处   word ptr[esi+0e]==4==任务状态标志</span><br></pre></td></tr></table></figure>

<p>经过一个二叉树结构追到头：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00AE1B8B  |.  E8 8086BFFF   call    006DA210                         ;  取[人物对象+0c]，即人物信息的call   word ptr[[[[[人物对象+0c]+3C4]+0C+4]+4]+0e]==4==任务状态标志</span><br></pre></td></tr></table></figure>

<p>途中经过的二叉树结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">00707F8A  |.  8D9B 00000000 lea     ebx, dword ptr [ebx]             ;  当前任务正好在该二叉树根节点 word ptr[eax+0e]==4==任务状态标志</span><br><span class="line">00707F90  |&gt;  66:3970 0C    /cmp     word ptr [eax+C], si            ;  疑似任务信息二叉树结构  根节点=eax    +0]左子树   +8]右子树   +11]标志位!=0跳出循环</span><br><span class="line">00707F94  |.  73 05         |jnb     short 00707F9B</span><br><span class="line">00707F96  |.  8B40 08       |mov     eax, dword ptr [eax+8]</span><br><span class="line">00707F99  |.  EB 04         |jmp     short 00707F9F</span><br><span class="line">00707F9B  |&gt;  8BD0          |mov     edx, eax</span><br><span class="line">00707F9D  |.  8B00          |mov     eax, dword ptr [eax]</span><br><span class="line">00707F9F  |&gt;  8078 11 00    |cmp     byte ptr [eax+11], 0</span><br><span class="line">00707FA3  |.^ 74 EB         \je      short 00707F90</span><br><span class="line">00707FA5  |&gt;  8B41 04       mov     eax, dword ptr [ecx+4]</span><br><span class="line">00707FA8  |.  3BD0          cmp     edx, eax</span><br></pre></td></tr></table></figure>

<p>该二叉树根节点:[[[[人物对象+0c]+3C4]+0C+4]+4]</p>
<p>+0]左子树      +8]右子树       +11]标志位！=0表示跳出循环 (BYTE)(经常忘记标志位类型！！)</p>
<p>+0C]为任务id（WORD）    +0e]为任务完成状态(WORD)</p>
<p>任务完成状态标志=word ptr[[[[[人物对象+0c]+3C4]+0C+4]+4]+0e]   （0表示未接取，3表示未完成状态，4表示完成状态）</p>
<p>代码如下：</p>
<p>结构如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T</span>任务</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	WORD wID;</span><br><span class="line">	WORD w完成度;</span><br><span class="line">	DWORD d对象;</span><br><span class="line">	<span class="keyword">char</span>* p名称;</span><br><span class="line">	<span class="keyword">char</span> pgbk名称[<span class="number">100</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T</span>任务遍历</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	T任务 列表[<span class="number">1000</span>];</span><br><span class="line">	DWORD d数量;</span><br><span class="line">	<span class="keyword">void</span> c初始化任务信息();</span><br><span class="line">	<span class="keyword">void</span> c递归遍历(DWORD);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>函数实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">DWORD g_任务下标 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">void</span> T任务遍历::c递归遍历(DWORD 根节点)</span><br><span class="line">&#123;</span><br><span class="line">	BYTE 标志位 = *(DWORD*)(根节点+<span class="number">0x11</span>);</span><br><span class="line">	<span class="keyword">if</span> (标志位==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		DWORD 左子树 = *(DWORD*)(根节点);</span><br><span class="line">		DWORD 右子树 = *(DWORD*)(根节点 + <span class="number">0x8</span>);</span><br><span class="line">		列表[g_任务下标].wID= *(WORD*)(根节点 + <span class="number">0x0c</span>);</span><br><span class="line">		列表[g_任务下标].d对象 = 根节点;</span><br><span class="line">		列表[g_任务下标].w完成度= *(WORD*)(根节点 + <span class="number">0x0e</span>);</span><br><span class="line">		g_任务下标++;</span><br><span class="line">		c递归遍历(左子树);</span><br><span class="line">		c递归遍历(右子树);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> T任务遍历::c初始化任务信息()</span><br><span class="line">&#123;</span><br><span class="line">	__try</span><br><span class="line">	&#123;</span><br><span class="line">		g_任务下标 = <span class="number">0</span>;</span><br><span class="line">		T人物信息 me;</span><br><span class="line">		me.初始化人物信息();</span><br><span class="line">		DWORD 根节点 = *(DWORD*)(me.d对象 + <span class="number">0x0c</span>);</span><br><span class="line">		根节点 = *(DWORD*)(根节点 + <span class="number">0x3c4</span>);</span><br><span class="line">		根节点 = *(DWORD*)(根节点 + <span class="number">0x10</span>);</span><br><span class="line">		根节点 = *(DWORD*)(根节点 + <span class="number">0x4</span>);</span><br><span class="line">		c递归遍历(根节点);</span><br><span class="line">		d数量 = g_任务下标;</span><br><span class="line">	&#125;</span><br><span class="line">	__except(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Call_输出调试信息(<span class="string">&quot;幻想神域   初始化任务信息出错！&quot;</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">T任务遍历 t;</span><br><span class="line">	t.c初始化任务信息();</span><br><span class="line">	Call_输出调试信息(<span class="string">&quot;幻想神域    任务数量:%d\r\n&quot;</span>,t.d数量);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;t.d数量;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Call_输出调试信息(<span class="string">&quot;幻想神域    任务id：%X   任务对象：%X    任务完成度：%X\r\n&quot;</span>,t.列表[i].wID, t.列表[i].d对象, t.列表[i].w完成度);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200629171419862.png" alt="image-20200629171419862"></p>
<p>分析可知，</p>
<ol>
<li>任务完成度为0表示当前可接而未接的任务</li>
<li>任务完成度为1表示已经完成提交的任务</li>
<li>任务完成度为3表示已接但未完成的任务</li>
<li>任务完成度为4表示已接并且完成可交的任务</li>
</ol>
<p>然而实际上它只能把已完成和已接取的任务显示出来，可接的任务能不能显示是不一定的</p>
<h3 id="完善任务遍历名字信息（比较难，有待提升）"><a href="#完善任务遍历名字信息（比较难，有待提升）" class="headerlink" title="完善任务遍历名字信息（比较难，有待提升）"></a>完善任务遍历名字信息（比较难，有待提升）</h3><p>直接通过任务名字找找看也行。</p>
<p>或者到明文发包call调用链中分析过程，在明文封包call上通过取消任务来断下，在堆栈中直接搜索该任务id，直接定位到取消任务call。取消任务call传进去的id的上一层偏移很有可能是任务对象，里面可能储存着任务名字。</p>
<p>按照上面的方案：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200629180635247.png" alt="image-20200629180635247"></p>
<p>返回到划线地址到达取消任务call如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00B3BDB8  |.  8B40 18       mov     eax, dword ptr [eax+18]</span><br><span class="line">00B3BDBB  |.  68 FFFF0000   push    0FFFF</span><br><span class="line">00B3BDC0  |.  6A 05         push    5</span><br><span class="line">00B3BDC2  |.  50            push    eax                              ;  任务id</span><br><span class="line">00B3BDC3  |.  E8 C866B7FF   call    006B2490                         ;  取消任务call</span><br><span class="line">00B3BDC8  |.  83C4 0C       add     esp, 0C</span><br></pre></td></tr></table></figure>

<p>如上面汇编，追eax追到[eax+18]，00B3BDB8处的eax很可能为任务对象,在此处dd eax观察成员元素，发现了疑似中文字符</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200629181014255.png" alt="image-20200629181014255"></p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200629181034665.png" alt="image-20200629181034665"></p>
<p>与游戏中的任务名称相对应。</p>
<p>追到此处：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00B3BDAE  |.  8B86 3C010000 mov     eax, dword ptr [esi+13C]         ;  取消任务的任务id==[[esi+13c]+18]==3ed</span><br></pre></td></tr></table></figure>

<h4 id="小重点难点"><a href="#小重点难点" class="headerlink" title="小重点难点"></a>小重点难点</h4><p>发现esi替换成寄存器的值，放开断点不断下来了！！！！！！！！</p>
<p>说明这个esi+13c 地址中存的是个临时会变的值，应该追[esi+13c]的整体。但该函数上面到函数头已经没有得追了。可以直接对esi+13c所在地址下写入断，来追[esi+13c]的整体来源</p>
<p>esi+13c地址中存进的值会随着玩家选不同任务而存不同的值</p>
<p>断到此处：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00B3DF33  |.  8986 3C010000 mov     dword ptr [esi+13C], eax         ;  取消任务的任务id==[eax+18]==3ed</span><br></pre></td></tr></table></figure>

<p>将[esi+13c]整个替换为eax。</p>
<p>继续向上追：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00B3E1C6  |.  8B11          mov     edx, dword ptr [ecx]</span><br><span class="line">00B3E1C8  |.  50            push    eax</span><br><span class="line">00B3E1C9  |.  8B82 E8000000 mov     eax, dword ptr [edx+E8]</span><br><span class="line">00B3E1CF  |.  897D 08       mov     dword ptr [ebp+8], edi</span><br><span class="line">00B3E1D2  |.  FFD0          call    eax                              ;  eax=[[[1789168]]+0E8]</span><br><span class="line">00B3E1D4  |.  8BF0          mov     esi, eax                         ;  取消任务的任务id==[eax+18]==3ed</span><br><span class="line">00B3E1D6  |.  33DB          xor     ebx, ebx</span><br></pre></td></tr></table></figure>

<p>eax来源于上面的call</p>
<p>进call追：</p>
<p>又追到这个call</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">007</span>C4A53  |.  <span class="number">8B</span>45 <span class="number">08</span>       mov     eax, dword ptr [ebp+<span class="number">8</span>]</span><br><span class="line"><span class="number">007</span>C4A56  |.  <span class="number">50</span>            push    eax                              ;  任务id</span><br><span class="line"><span class="number">007</span>C4A57  |.  <span class="number">68</span> <span class="number">8</span>C927E01   push    <span class="number">017E928</span>C</span><br><span class="line"><span class="number">007</span>C4A5C  |.  E8 <span class="number">1F</span>F3E9FF   call    <span class="number">00663</span>D80                         ；通过任务id取任务对象call</span><br><span class="line"><span class="number">007</span>C4A61  |.  <span class="number">83</span>C4 <span class="number">08</span>       add     esp, <span class="number">8</span></span><br><span class="line"><span class="number">007</span>C4A64  |.  <span class="number">5</span>D            pop     ebp</span><br><span class="line"><span class="number">007</span>C4A65  \.  C2 <span class="number">0400</span>       retn    <span class="number">4</span>                                ;  取消任务的任务id==[eax+<span class="number">18</span>]==<span class="number">3</span>ed</span><br></pre></td></tr></table></figure>

<p>尝试代码注入器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">push 3ED</span><br><span class="line">push 017E928C</span><br><span class="line">call 00663d80</span><br><span class="line">add esp,8</span><br><span class="line">mov [00178000],eax</span><br></pre></td></tr></table></figure>

<p>成功观察到结果：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200630180024957.png" alt="image-20200630180024957"></p>
<p>因此追到该call传进任务id获得任务对象后</p>
<p>+18]  表示任务id</p>
<p>+20]表示任务名称</p>
<p>+30]表示任务名称长短</p>
<p>继续往里分析：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">00663D87  |.  56            push    esi</span><br><span class="line">00663D88  |.  57            push    edi</span><br><span class="line">00663D89  |.  8B7D 08       mov     edi, dword ptr [ebp+8]</span><br><span class="line">00663D8C  |.  8D45 0C       lea     eax, dword ptr [ebp+C]</span><br><span class="line">00663D8F  |.  50            push    eax</span><br><span class="line">00663D90  |.  8D4D F0       lea     ecx, dword ptr [ebp-10]</span><br><span class="line">00663D93  |.  51            push    ecx</span><br><span class="line">00663D94  |.  8BCF          mov     ecx, edi</span><br><span class="line">00663D96  |.  E8 B5D91600   call    007D1750                         ;  eax来源于该call，并且eax是个栈地址</span><br><span class="line">00663D9B  |.  8B30          mov     esi, dword ptr [eax]</span><br><span class="line">00663D9D  |.  85F6          test    esi, esi                         ;  game.017E92A4</span><br><span class="line">00663D9F  |.  8B57 04       mov     edx, dword ptr [edi+4]</span><br><span class="line">00663DA2  |.  8B58 04       mov     ebx, dword ptr [eax+4]           ;  取消任务的任务id==[[[eax+4]+10]+18]==3ed</span><br><span class="line">00663DA5  |.  8955 FC       mov     dword ptr [ebp-4], edx</span><br><span class="line">00663DA8  |.  74 04         je      short 00663DAE</span><br><span class="line">00663DAA  |.  3BF7          cmp     esi, edi</span><br></pre></td></tr></table></figure>

<p>此处eax往上追发现eax是个栈地址。</p>
<p>遇到这种情况，有巧妙的办法就是进行替换。</p>
<p>断下00663D9B的时候发现eax和ebp的关系是eax相当于ebp-10</p>
<p>便宜表达式直接替换成追：取消任务的任务id==[[[ebp-10+4]+10]+18]==3ed</p>
<p>相当于要追[ebp-0C],相当于追第一个参数+4的地址中的值是什么</p>
<p>进call继续分析。发现：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200630183041901.png" alt="image-20200630183041901"></p>
<p>继续向上追追到二叉树。</p>
<p>取消任务的任务id==[[[[017E928C+4]+4]+10]+18]==3ed</p>
<p>+4]+4]后为根节点。结构分析如下：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200630190413663.png" alt="image-20200630190413663"></p>
<p>名称长度处理都不用分析了，因为一个游戏里都是一样的。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> T任务库遍历::c递归遍历(DWORD 根节点)</span><br><span class="line">&#123;</span><br><span class="line">	BYTE 标志位 = *(BYTE*)(根节点 + <span class="number">0x15</span>);</span><br><span class="line">	<span class="keyword">if</span> (标志位 == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		DWORD 左子树 = *(DWORD*)(根节点);</span><br><span class="line">		DWORD 右子树 = *(DWORD*)(根节点 + <span class="number">0x8</span>);</span><br><span class="line">		列表[g_任务下标].d对象 = *(DWORD*)(根节点 + <span class="number">0x10</span>);</span><br><span class="line">		列表[g_任务下标].wID = *(WORD*)(列表[g_任务下标].d对象 + <span class="number">0x18</span>);</span><br><span class="line">		DWORD 名称长度 = *(DWORD*)(列表[g_任务下标].d对象 + <span class="number">0x1c</span>+<span class="number">0x18</span>);</span><br><span class="line">		<span class="keyword">if</span> (名称长度&gt;=<span class="number">0x10</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			DWORD temp=*(DWORD*)(列表[g_任务下标].d对象 + <span class="number">0x1c</span> + <span class="number">0x4</span>);</span><br><span class="line">			列表[g_任务下标].p名称 = (<span class="keyword">char</span>*)temp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			列表[g_任务下标].p名称 = (<span class="keyword">char</span>*)(列表[g_任务下标].d对象 + <span class="number">0x1c</span> + <span class="number">0x4</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">strcpy</span>(列表[g_任务下标].pgbk名称, 列表[g_任务下标].p名称);</span><br><span class="line">		<span class="built_in">BIG52GBK</span>(列表[g_任务下标].pgbk名称);</span><br><span class="line">		g_任务下标++;</span><br><span class="line">		c递归遍历(左子树);</span><br><span class="line">		c递归遍历(右子树);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> T任务库遍历::c初始化任务库信息()</span><br><span class="line">&#123;</span><br><span class="line">	__try</span><br><span class="line">	&#123;</span><br><span class="line">		g_任务下标 = <span class="number">0</span>;</span><br><span class="line">		DWORD 根节点 = *(DWORD*)(<span class="number">0x17E928C</span>+<span class="number">0x4</span>);</span><br><span class="line">		根节点 = *(DWORD*)(根节点 + <span class="number">0x4</span>);</span><br><span class="line">		c递归遍历(根节点);</span><br><span class="line">		d数量 = g_任务下标;</span><br><span class="line">		Call_输出调试信息(<span class="string">&quot;幻想神域    任务库数量:%d\r\n&quot;</span>, d数量);</span><br><span class="line">	&#125;</span><br><span class="line">	__except (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Call_输出调试信息(<span class="string">&quot;幻想神域   读取任务库信息出错！&quot;</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果图：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200701142941429.png" alt="image-20200701142941429"></p>
<p>注意点：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200701145906136.png" alt="image-20200701145906136"></p>
<p>不要在递归中嵌套递归，否则很容易出问题！！！！</p>
<h4 id="完善之前的任务遍历："><a href="#完善之前的任务遍历：" class="headerlink" title="完善之前的任务遍历："></a>完善之前的任务遍历：</h4><p>任务遍历的关联任务名称的改善的调用代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历任务信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyDialog::OnBnClickedButton22</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">	T任务遍历 t;</span><br><span class="line">	t.c初始化任务信息();</span><br><span class="line">	T任务库遍历 t2;</span><br><span class="line">	t2.c初始化任务库信息();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.d数量; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; t2.d数量; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (t.列表[i].wID == t2.列表[j].wID)</span><br><span class="line">			&#123;</span><br><span class="line">				t.列表[i].p名称 = t2.列表[j].p名称;</span><br><span class="line">				<span class="built_in">strcpy</span>(t.列表[i].pgbk名称, t.列表[i].p名称);</span><br><span class="line">				<span class="built_in">BIG52GBK</span>(t.列表[i].pgbk名称);</span><br><span class="line">				Call_输出调试信息(<span class="string">&quot;幻想神域    任务id：%X   任务对象：%X   任务完成度:%X   任务名称：%s\r\n&quot;</span>, t.列表[i].wID, t.列表[i].d对象, t.列表[i].w完成度, t.列表[i].pgbk名称);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果图：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200701151102938.png" alt="image-20200701151102938"></p>
<h3 id="交接任务封包"><a href="#交接任务封包" class="headerlink" title="交接任务封包"></a>交接任务封包</h3><p>hook明文发包，进行分析</p>
<p>放弃任务封包：</p>
<p>[2924] 幻想神域   包长：c   包地址30f4ef60    包内容:0A001D000500ED030000FFFF<br>[2924] 幻想神域   包长：8   包地址3a52e500    包内容:0600C50000000000<br>[2924] 幻想神域   包长：d   包地址3a4a8ee0    包内容:0B00C50001000000ED03000002 </p>
<p>打开npc安妮塔对话框封包：<br>[2924] 幻想神域   包长：8   包地址3aedf850    包内容:06000300D9FEFFFF<br>[2924] 幻想神域   包长：8   包地址3a52e698    包内容:0600030000000000<br>[2924] 幻想神域   包长：8   包地址3aedf858    包内容:06005800D9FEFFFF </p>
<p>打开npc丝卡蒂对话框封包：</p>
<p>[2924] 幻想神域   包长：8   包地址120af320    包内容:06000300E0FEFFFF<br>[2924] 幻想神域   包长：8   包地址120afff0    包内容:0600030000000000<br>[2924] 幻想神域   包长：8   包地址121ec0a0    包内容:06005800E0FEFFFF<br>[2924] 幻想神域   包长：6   包地址3aedf7a8    包内容:040057000000 </p>
<p>关闭npc安妮塔对话框封包：</p>
<p>[2924] 幻想神域   包长：4   包地址3aedcb38    包内容:02006900 </p>
<p>关闭npc丝卡蒂对话框封包：：</p>
<p>[2924] 幻想神域   包长：4   包地址2298dd20    包内容:02006900 </p>
<p>接收丝卡蒂任务LV1.逃脱任务封包：</p>
<p>[2924] 幻想神域   包长：c   包地址357383c0    包内容:0A001D000100ED030000FFFF<br>[2924] 幻想神域   包长：4   包地址3aede3d8    包内容:02006900<br>[2924] 幻想神域   包长：8   包地址3a52e530    包内容:0600C50000000000<br>[2924] 幻想神域   包长：d   包地址3ae93700    包内容:0B00C50001000000ED03000001 </p>
<p>结合id进行分析：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200701154135148.png" alt="image-20200701154135148"></p>
<p>如果我们发送可以实现功能的封包以后，游戏会自动帮我们发后面的跟包，那就不需要我们自己手动发跟包了。</p>
<p>测试发现接任务的时候只发*[2924] 幻想神域   包长：c   包地址357383c0    包内容:0A001D000100ED030000FFFF* 这个包就直接游戏会自动帮我们发后面的三个包，并且游戏里任务也接取了。这说明其他三个包类似说拜拜。</p>
<p>也就是说接任务只需要分析如下包：</p>
<h3 id="交接任务封包分析"><a href="#交接任务封包分析" class="headerlink" title="交接任务封包分析"></a>交接任务封包分析</h3><p>[2924] 幻想神域   包长：c   包地址357383c0    包内容:0A001D000100ED030000FFFF </p>
<p>0A00 1D00 0100 ED030000 FFFF</p>
<p>放弃任务和上面同理，也只需要分析这个：</p>
<p>[2924] 幻想神域   包长：c   包地址30f4ef60    包内容:0A001D000500ED030000FFFF </p>
<p>0A00 1D00 0500 ED030000 FFFF</p>
<p>这两封包唯一的不同只有0100和0500的差异</p>
<p>分析结果：   </p>
<table>
<thead>
<tr>
<th>0A00</th>
<th>1D00</th>
<th>0500</th>
<th>ED030000</th>
<th>FFFF</th>
</tr>
</thead>
<tbody><tr>
<td>包长</td>
<td>包头</td>
<td>操作方式</td>
<td>任务id</td>
<td>包尾（暂时固定）</td>
</tr>
</tbody></table>
<p>操作方式： 1表示接受任务，2表示交任务，5表示放弃任务</p>
<h3 id="开关npc对话框封包分析"><a href="#开关npc对话框封包分析" class="headerlink" title="开关npc对话框封包分析"></a>开关npc对话框封包分析</h3><p>并且实际测试发现取消任务并不需要开关npc对话框。（不开关npc对话框就交接任务有隐性的被封禁风险）</p>
<p>而交和接任务却必须打开npc对话框才能成功执行</p>
<p>以上符合游戏操作逻辑，并且测试发现有交接任务的距离限制</p>
<p>分析打开npc丝卡蒂对话框封包：</p>
<p>[2924] 幻想神域   包长：8   包地址120af320    包内容:06000300E0FEFFFF<br>[2924] 幻想神域   包长：8   包地址120afff0    包内容:0600030000000000<br>[2924] 幻想神域   包长：8   包地址121ec0a0    包内容:06005800E0FEFFFF 发送这个包对话框打开<br>[2924] 幻想神域   包长：6   包地址3aedf7a8    包内容:040057000000 会自动跟这个包</p>
<p>有两个包不会自动跟。因此这两个封包我们要自己发。</p>
<p>比对这组发包进行分析：</p>
<p>打开npc安妮塔对话框封包：<br>[2924] 幻想神域   包长：8   包地址3aedf850    包内容:06000300D9FEFFFF<br>[2924] 幻想神域   包长：8   包地址3a52e698    包内容:0600030000000000<br>[2924] 幻想神域   包长：8   包地址3aedf858    包内容:06005800D9FEFFFF </p>
<p>测试发现选择某个npc的时候会发送06000300 D9FEFFFF，而取消选择npc的时候会发送这个06000300 00000000</p>
<p>但发送这两个包本身不能反映在游戏内有变化</p>
<p>06000300 D9FEFFFF  选择id为D9FEFFFF  的npc</p>
<p>06000300 00000000  清空选择id为D9FEFFFF  的npc</p>
<p>06005800 D9FEFFFF  打开id为D9FEFFFF的npc</p>
<p>最后，关闭对话框封包也不会在游戏中有反应</p>
<h4 id="之前一直都有的一个严重的bug未解决"><a href="#之前一直都有的一个严重的bug未解决" class="headerlink" title="之前一直都有的一个严重的bug未解决"></a>之前一直都有的一个严重的bug未解决</h4><p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200701164710276.png" alt="image-20200701164710276"></p>
<p>有些npc的名称中带有换行符。之前的遍历中之所以看不到是因为我们过滤掉了没有幻想神域这四个字的调试行，因此看不见蓝圈的信息。</p>
<p>因此名字信息写入的时候要写全。比如”村長夫人\n絲卡蒂”才是对象为1E57F100对应的npc的完整的名称。</p>
<p>函数实现代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//操作类型1表示接受任务，2表示交任务，5表示放弃任务</span></span><br><span class="line"><span class="keyword">void</span> Call_交接任务封包(<span class="keyword">char</span>* 任务名称, DWORD 操作类型)</span><br><span class="line">&#123;</span><br><span class="line">	DWORD 任务id = <span class="number">0</span>;</span><br><span class="line">	byte b[<span class="number">0xc</span>] = &#123; <span class="number">0x0a</span>,<span class="number">00</span>,<span class="number">0x1d</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">0xff</span>,<span class="number">0xff</span> &#125;;</span><br><span class="line">	<span class="comment">//对已接任务进行遍历</span></span><br><span class="line">	T任务遍历 t;</span><br><span class="line">	t.c初始化任务信息();</span><br><span class="line">	T任务库遍历 t2;</span><br><span class="line">	t2.c初始化任务库信息();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.d数量; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; t2.d数量; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (t.列表[i].wID == t2.列表[j].wID)</span><br><span class="line">			&#123;</span><br><span class="line">				t.列表[i].p名称 = t2.列表[j].p名称;</span><br><span class="line">				<span class="built_in">strcpy</span>(t.列表[i].pgbk名称, t.列表[i].p名称);</span><br><span class="line">				<span class="built_in">BIG52GBK</span>(t.列表[i].pgbk名称);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//取到名字对应的id</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.d数量;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(任务名称,t.列表[i].pgbk名称)==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			任务id = t.列表[i].wID;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//修改并发送封包</span></span><br><span class="line">	*(WORD*)(b + <span class="number">4</span>) = (WORD)操作类型;</span><br><span class="line">	*(DWORD*)(b + <span class="number">6</span>) = 任务id;</span><br><span class="line">	Msg_发送明文包(<span class="number">0xc</span>,(DWORD)b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Call_打开NPC对话框封包(<span class="keyword">char</span>* NPC名称)</span><br><span class="line">&#123;</span><br><span class="line">	DWORD NPCID = <span class="number">0</span>;</span><br><span class="line">	byte bbb[<span class="number">0x8</span>] = &#123; <span class="number">0x06</span>,<span class="number">00</span>,<span class="number">0x03</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span> &#125;;</span><br><span class="line">	byte bb[<span class="number">0x8</span>] = &#123; <span class="number">0x06</span>,<span class="number">00</span>,<span class="number">0x03</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span> &#125;;</span><br><span class="line">	byte b[<span class="number">0x8</span>] = &#123; <span class="number">0x06</span>,<span class="number">00</span>,<span class="number">0x58</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span> &#125;;</span><br><span class="line">	</span><br><span class="line">	T链表信息遍历 t;</span><br><span class="line">	t.初始化对象信息();</span><br><span class="line">	<span class="comment">//通过NPC名称获取npc的id</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.d数量;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(t.对象信息[i].cGBK名字, NPC名称)==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			NPCID = t.对象信息[i].dID;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//修改并发送封包</span></span><br><span class="line">	*(DWORD*)(b + <span class="number">4</span>) = NPCID;</span><br><span class="line">	*(DWORD*)(bb + <span class="number">4</span>) = NPCID;</span><br><span class="line">	Msg_发送明文包(<span class="number">0x8</span>, (DWORD)bb);</span><br><span class="line">	Msg_发送明文包(<span class="number">0x8</span>, (DWORD)bbb);</span><br><span class="line">	Msg_发送明文包(<span class="number">0x8</span>, (DWORD)b);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打开npc</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyDialog::OnBnClickedButton24</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">	Call_打开NPC对话框封包(<span class="string">&quot;村長夫人\n絲卡蒂&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接任务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyDialog::OnBnClickedButton25</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">	Call_交接任务封包(<span class="string">&quot;Lv1.送貨&quot;</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>先hook主线程，然后站在村長夫人\n絲卡蒂身边，按打开npc按钮，再按接任务按钮，效果顺利达成。</p>
<h2 id="自动任务逻辑"><a href="#自动任务逻辑" class="headerlink" title="自动任务逻辑"></a>自动任务逻辑</h2><p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200703123124781.png" alt="image-20200703123124781"></p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200703123901382.png" alt="image-20200703123901382"></p>
<p>注意，快速循环若无延时会崩溃</p>
<p>任务判读通过判断上一个任务已完成并且下一个任务未完成来决定下一个任务做哪个任务</p>
<h2 id="一键定位基地址和偏移"><a href="#一键定位基地址和偏移" class="headerlink" title="一键定位基地址和偏移"></a>一键定位基地址和偏移</h2><p>定位工具：</p>
<p>注入定位工具，点新建，如下填写</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200703133334276.png" alt="image-20200703133334276"></p>
<p>游戏更新一般改变：</p>
<ol>
<li>偏移</li>
<li>基地址</li>
<li>call的目标地址</li>
</ol>
<p>od中尽量复制完整的子程序</p>
<p>用一个记事本把内容装进去，尽量别留空行。</p>
<p>定位工具中选择打开之前新建的.xml后缀的定位文件，显示如下：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200703134009568.png" alt="image-20200703134009568"></p>
<p>在上图中双击想要定位的基地址：</p>
<p>出现一个箭头如下：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200703134243403.png" alt="image-20200703134243403"></p>
<p>然后在这周围选中一片区域，点设置特征，如下：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200703134336551.png" alt="image-20200703134336551"></p>
<p>然后在自己存子程序的txt文件右键点设置，如下：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200703134417594.png" alt="image-20200703134417594"></p>
<p>定位F3C570的例子填写如下</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200703134645865.png" alt="image-20200703134645865"></p>
<p>然后在自己存子程序的txt文件右键点开始定位：输出结果：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200703134718333.png" alt="image-20200703134718333"></p>
<p>只显示一个代表定位成功！</p>
<p>如果显示很多条，效果如下</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200703134929816.png" alt="image-20200703134929816"></p>
<p>代表游戏中具备该特征的不止一个，因此无效</p>
<p>选择特征区域的大小很重要，选得多，特征多，但失效几率也大，特征码要在能够少的情况下尽量少。</p>
<p>先筛除到只有一条，然后逐渐尝试减小特征码</p>
<p>直接在特征码字眼上右键开始定位，可以一步定位所有结果</p>
<p>定位call的时候注意属性要选call，如下：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200703135805836.png" alt="image-20200703135805836"></p>
<p>int3是不能当特征码来用的</p>
<h3 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h3><p>（1）有些极特殊的情况能用来定位的特征区域太少了，子程序很短的情况下，右键查找所有的常量，换地方定位。（但偏移不能换位置定位，只有基地址和call可以换地方定位）</p>
<p>（2）定位call内部某个什么的时候，可以用定位到call的目标地址加个偏移拿到目标定位</p>
<p>33后esp=前面esp+c</p>
<p>【后esp+10】==[前面esp+c+10]</p>
<p>参数和局部变量可以直接跳堆栈（查找地址，ctrl+L）</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/blog/tags/%E9%80%86%E5%90%91/" rel="tag"># 逆向</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/blog/2021/12/05/MFC/" rel="prev" title="MFC">
      <i class="fa fa-chevron-left"></i> MFC
    </a></div>
      <div class="post-nav-item">
    <a href="/blog/2022/03/26/64%E4%BD%8D%E9%80%86%E5%90%91/" rel="next" title="64位逆向">
      64位逆向 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%A3%E8%A2%8B%E8%A5%BF%E6%B8%B8%E5%AE%9E%E6%88%98"><span class="nav-number">1.</span> <span class="nav-text">口袋西游实战</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%EF%BC%9A%E8%BF%BD%E8%83%8C%E5%8C%85%E6%95%B0%E9%87%8F"><span class="nav-number">1.1.</span> <span class="nav-text">数组：追背包数量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%87%E8%83%BD%E6%8E%A7%E4%BB%B6call"><span class="nav-number">1.2.</span> <span class="nav-text">万能控件call</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%83%8C%E5%8C%85%E5%BC%80%E5%85%B3%E7%8A%B6%E6%80%81%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80"><span class="nav-number">1.2.0.0.0.1.</span> <span class="nav-text">背包开关状态内存地址:</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%94%B9%E5%86%99%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="nav-number">1.2.0.0.0.2.</span> <span class="nav-text">改写代码：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%87%E8%83%BD%E6%8E%A7%E4%BB%B6call%E4%BD%8D%E7%BD%AE"><span class="nav-number">1.2.0.0.0.3.</span> <span class="nav-text">万能控件call位置</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%87%E8%83%BD%E6%8E%A7%E4%BB%B6call-1"><span class="nav-number">1.2.0.0.0.4.</span> <span class="nav-text">万能控件call</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%B8%A6%E5%AF%B9%E8%AF%9D%E6%A1%86%E7%9A%84MFC-DLL"><span class="nav-number">2.</span> <span class="nav-text">创建带对话框的MFC DLL</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B9%BB%E6%83%B3%E7%A5%9E%E5%9F%9F"><span class="nav-number">3.</span> <span class="nav-text">幻想神域</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%BD%E8%A1%80%E9%87%8F%E6%95%B0%E6%8D%AE%E6%9D%A5%E6%BA%90%E6%89%BE%E4%BA%BA%E7%89%A9%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84"><span class="nav-number">3.1.</span> <span class="nav-text">追血量数据来源找人物对象数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84"><span class="nav-number">3.1.1.</span> <span class="nav-text">遍历数组</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%BD%E8%A1%80%E9%87%8F%E6%9D%A5%E6%BA%90%E6%89%BE%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84%E9%93%BE%E8%A1%A8"><span class="nav-number">3.2.</span> <span class="nav-text">追血量来源找对象结构链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%BE%E5%90%8D%E7%A7%B0"><span class="nav-number">3.2.1.</span> <span class="nav-text">找名称</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%BD%E8%83%8C%E5%8C%85%E4%B8%AD%E7%89%A9%E5%93%81%E6%95%B0%E9%87%8F%E6%89%BE%E8%83%8C%E5%8C%85%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">3.3.</span> <span class="nav-text">追背包中物品数量找背包数据结构二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%BE%E8%83%8C%E5%8C%85%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">3.3.1.</span> <span class="nav-text">找背包数据结构二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90%E7%89%A9%E5%93%81%E5%90%8D%E7%A7%B0"><span class="nav-number">3.3.2.</span> <span class="nav-text">分析物品名称</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%BE%E6%8A%80%E8%83%BD%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">3.4.</span> <span class="nav-text">找技能数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%BE%E6%8A%80%E8%83%BD%E5%90%8D"><span class="nav-number">3.4.1.</span> <span class="nav-text">找技能名</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A8%E6%8A%80%E8%83%BD%E9%81%8D%E5%8E%86"><span class="nav-number">3.5.</span> <span class="nav-text">全技能遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%C2%B7%E6%AC%A1%E6%89%BE%E5%85%A8%E6%8A%80%E8%83%BD%EF%BC%8C%E7%BB%93%E6%9E%9C%E6%89%BE%E5%88%B0%E9%BC%A0%E6%A0%87%E5%9D%90%E6%A0%87call"><span class="nav-number">3.5.1.</span> <span class="nav-text">第一·次找全技能，结果找到鼠标坐标call</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%89%BE%E5%85%A8%E6%8A%80%E8%83%BD%E7%BB%93%E6%9E%84%E5%A4%B1%E8%B4%A5%EF%BC%8C%E6%89%BE%E5%88%B0%E4%BA%86%E5%B7%B2%E4%BD%BF%E7%94%A8%E8%BF%87%E7%9A%84%E6%8A%80%E8%83%BD%E7%BB%93%E6%9E%84"><span class="nav-number">3.5.2.</span> <span class="nav-text">第二次找全技能结构失败，找到了已使用过的技能结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%89%BE%E5%85%A8%E6%8A%80%E8%83%BD"><span class="nav-number">3.5.3.</span> <span class="nav-text">第三次找全技能</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%BE%E6%98%8E%E6%96%87%E5%B0%81%E5%8C%85call"><span class="nav-number">3.6.</span> <span class="nav-text">找明文封包call</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AE%E5%AE%9A%E6%9C%89%E6%97%A0crc%E6%A3%80%E6%B5%8B%EF%BC%9F"><span class="nav-number">3.6.1.</span> <span class="nav-text">确定有无crc检测？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E6%98%AF%E5%93%AA%E7%A7%8D%E5%8F%91%E5%8C%85%EF%BC%9F"><span class="nav-number">3.6.2.</span> <span class="nav-text">判断是哪种发包？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%EF%BC%9F"><span class="nav-number">3.6.3.</span> <span class="nav-text">判断是否线程发包？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%B3%E5%87%BA%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85"><span class="nav-number">3.6.4.</span> <span class="nav-text">跳出线程发包</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E8%AF%A5%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E6%98%AF%E5%90%A6%E5%9C%B0%E5%9D%80%E4%B8%8D%E5%8F%98%EF%BC%9F%E5%8F%98%E7%9A%84%E8%AF%9D%E5%90%91%E4%B8%8A%E8%BF%BD%E6%9D%A5%E6%BA%90%EF%BC%8C%E6%89%BE%E5%88%B0%E4%B8%8D%E5%8F%98%E7%9A%84%E4%B8%80%E5%B1%82%E5%9C%B0%E5%9D%80%E5%8D%B3%E4%B8%BA%E8%B7%B3%E5%87%BA%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E7%9A%84%E7%AA%81%E7%A0%B4%E5%8F%A3%E3%80%82"><span class="nav-number">3.6.4.0.1.</span> <span class="nav-text">判断该线程发包是否地址不变？变的话向上追来源，找到不变的一层地址即为跳出线程发包的突破口。</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%BE%E6%98%8E%E6%96%87%E5%B0%81%E5%8C%85call-1"><span class="nav-number">3.6.5.</span> <span class="nav-text">找明文封包call</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%BE%E5%8A%A0%E5%AF%86call"><span class="nav-number">3.7.</span> <span class="nav-text">找加密call</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#vs%E5%80%9F%E7%94%A8%E6%B8%B8%E6%88%8F%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%96%8A%E8%AF%9D%E5%8A%9F%E8%83%BD"><span class="nav-number">3.7.1.</span> <span class="nav-text">vs借用游戏代码实现喊话功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%81%B7%E5%8A%9F%E8%83%BD%EF%BC%88%E4%B8%8D%E8%B5%B0%E6%B8%B8%E6%88%8F%E4%BB%A3%E7%A0%81%EF%BC%89"><span class="nav-number">3.7.2.</span> <span class="nav-text">偷功能（不走游戏代码）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%BE%E6%98%8E%E6%96%87%E6%94%B6%E5%8C%85"><span class="nav-number">3.8.</span> <span class="nav-text">找明文收包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HOOK%E6%98%8E%E6%96%87%E5%8F%91%E5%8C%85"><span class="nav-number">3.9.</span> <span class="nav-text">HOOK明文发包</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E7%94%A8%E6%94%B9%E7%9A%84%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0%E5%A6%82%E4%B8%8B"><span class="nav-number">3.9.0.1.</span> <span class="nav-text">不用改的工具函数如下</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hook%E9%9C%80%E8%A6%81%E6%94%B9%E5%8A%A8%E7%9A%84%E5%87%BD%E6%95%B0%E5%A6%82%E4%B8%8B"><span class="nav-number">3.9.0.2.</span> <span class="nav-text">hook需要改动的函数如下</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HOOK%E6%98%8E%E6%96%87%E6%94%B6%E5%8C%85"><span class="nav-number">3.10.</span> <span class="nav-text">HOOK明文收包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%91%E9%80%81%E5%B0%81%E5%8C%85%E5%AE%9E%E7%8E%B0%E4%BB%BB%E6%84%8F%E5%8A%9F%E8%83%BD"><span class="nav-number">3.11.</span> <span class="nav-text">发送封包实现任意功能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0%E5%A6%82%E4%B8%8B"><span class="nav-number">3.11.1.</span> <span class="nav-text">工具函数如下:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%91%E9%80%81%E5%B0%81%E5%8C%85%E5%87%BD%E6%95%B0%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="nav-number">3.11.2.</span> <span class="nav-text">发送封包函数如下：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%83%E8%8D%AF%E5%B0%81%E5%8C%85call"><span class="nav-number">3.11.3.</span> <span class="nav-text">吃药封包call</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E5%90%83%E8%8D%AF"><span class="nav-number">3.11.3.1.</span> <span class="nav-text">自动吃药</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%BB%E5%87%BB%E6%80%A7%E6%8A%80%E8%83%BD%E5%B0%81%E5%8C%85call"><span class="nav-number">3.11.4.</span> <span class="nav-text">攻击性技能封包call</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%BB%E8%B7%AFCALL"><span class="nav-number">3.12.</span> <span class="nav-text">寻路CALL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E7%82%B9%EF%BC%9A%E4%B8%BB%E7%BA%BF%E7%A8%8B%E8%B0%83%E7%94%A8"><span class="nav-number">3.12.1.</span> <span class="nav-text">重点：主线程调用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8C%E5%96%84%E8%87%AA%E5%8A%A8%E6%89%93%E6%80%AA"><span class="nav-number">3.13.</span> <span class="nav-text">完善自动打怪</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%80%E8%83%BD%E5%BE%AA%E7%8E%AF"><span class="nav-number">3.13.1.</span> <span class="nav-text">技能循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E9%9A%9C%E7%A2%8D%E7%82%B9"><span class="nav-number">3.13.2.</span> <span class="nav-text">判断障碍点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8bug%E4%BF%AE%E5%A4%8D"><span class="nav-number">3.13.3.</span> <span class="nav-text">异常bug修复</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E4%BB%BB%E5%8A%A1"><span class="nav-number">3.14.</span> <span class="nav-text">自动任务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8C%E5%96%84%E4%BB%BB%E5%8A%A1%E9%81%8D%E5%8E%86%E5%90%8D%E5%AD%97%E4%BF%A1%E6%81%AF%EF%BC%88%E6%AF%94%E8%BE%83%E9%9A%BE%EF%BC%8C%E6%9C%89%E5%BE%85%E6%8F%90%E5%8D%87%EF%BC%89"><span class="nav-number">3.14.1.</span> <span class="nav-text">完善任务遍历名字信息（比较难，有待提升）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%8F%E9%87%8D%E7%82%B9%E9%9A%BE%E7%82%B9"><span class="nav-number">3.14.1.1.</span> <span class="nav-text">小重点难点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8C%E5%96%84%E4%B9%8B%E5%89%8D%E7%9A%84%E4%BB%BB%E5%8A%A1%E9%81%8D%E5%8E%86%EF%BC%9A"><span class="nav-number">3.14.1.2.</span> <span class="nav-text">完善之前的任务遍历：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%A4%E6%8E%A5%E4%BB%BB%E5%8A%A1%E5%B0%81%E5%8C%85"><span class="nav-number">3.14.2.</span> <span class="nav-text">交接任务封包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%A4%E6%8E%A5%E4%BB%BB%E5%8A%A1%E5%B0%81%E5%8C%85%E5%88%86%E6%9E%90"><span class="nav-number">3.14.3.</span> <span class="nav-text">交接任务封包分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%80%E5%85%B3npc%E5%AF%B9%E8%AF%9D%E6%A1%86%E5%B0%81%E5%8C%85%E5%88%86%E6%9E%90"><span class="nav-number">3.14.4.</span> <span class="nav-text">开关npc对话框封包分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B9%8B%E5%89%8D%E4%B8%80%E7%9B%B4%E9%83%BD%E6%9C%89%E7%9A%84%E4%B8%80%E4%B8%AA%E4%B8%A5%E9%87%8D%E7%9A%84bug%E6%9C%AA%E8%A7%A3%E5%86%B3"><span class="nav-number">3.14.4.1.</span> <span class="nav-text">之前一直都有的一个严重的bug未解决</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E4%BB%BB%E5%8A%A1%E9%80%BB%E8%BE%91"><span class="nav-number">3.15.</span> <span class="nav-text">自动任务逻辑</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E9%94%AE%E5%AE%9A%E4%BD%8D%E5%9F%BA%E5%9C%B0%E5%9D%80%E5%92%8C%E5%81%8F%E7%A7%BB"><span class="nav-number">3.16.</span> <span class="nav-text">一键定位基地址和偏移</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E6%8A%80%E5%B7%A7"><span class="nav-number">3.16.1.</span> <span class="nav-text">小技巧</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ZEROKO14</p>
  <div class="site-description" itemprop="description">你好，欢迎来到ZEROKO14的个人博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">24</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZEROKO14</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>-->

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/muse.js"></script>


<script src="/blog/js/next-boot.js"></script>


  <script defer src="/blog/lib/three/three.min.js"></script>
    <script defer src="/blog/lib/three/three-waves.min.js"></script>


  















  

  

</body>
</html>
