<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zeroko14.gitee.io","root":"/blog/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="APC机制APC机制使耗时操作可以异步回调处理">
<meta property="og:type" content="article">
<meta property="og:title" content="APC机制">
<meta property="og:url" content="http://zeroko14.gitee.io/blog/2021/12/05/APC%E6%9C%BA%E5%88%B6/index.html">
<meta property="og:site_name" content="ZEROKO14的个人博客">
<meta property="og:description" content="APC机制APC机制使耗时操作可以异步回调处理">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20211013171657971.png">
<meta property="og:image" content="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20211023213229559.png">
<meta property="og:image" content="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20211023213307816.png">
<meta property="og:image" content="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20211028152615008.png">
<meta property="og:image" content="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20211018180147858.png">
<meta property="og:image" content="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20211012154033183.png">
<meta property="og:image" content="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20211019150353138.png">
<meta property="og:image" content="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20211029143018774.png">
<meta property="og:image" content="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20211101140140226.png">
<meta property="og:image" content="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20211101164401536.png">
<meta property="og:image" content="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20211101164523600.png">
<meta property="og:image" content="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20211026232558356.png">
<meta property="og:image" content="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20211015132902898.png">
<meta property="og:image" content="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20211023221626174.png">
<meta property="og:image" content="https://gitee.com/ZEROKO14/blog-img/raw/master/img/deliver.png">
<meta property="og:image" content="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20211118112937375.png">
<meta property="og:image" content="https://gitee.com/ZEROKO14/blog-img/raw/master/img/20201202171056458.png">
<meta property="og:image" content="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20211016154954475.png">
<meta property="og:image" content="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20211016155050235.png">
<meta property="og:image" content="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20210831191749044.png">
<meta property="article:published_time" content="2021-12-05T06:15:09.000Z">
<meta property="article:modified_time" content="2021-11-18T03:31:36.000Z">
<meta property="article:author" content="ZEROKO14">
<meta property="article:tag" content="内核">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20211013171657971.png">

<link rel="canonical" href="http://zeroko14.gitee.io/blog/2021/12/05/APC%E6%9C%BA%E5%88%B6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>APC机制 | ZEROKO14的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ZEROKO14的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">zeroko14's blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zeroko14.gitee.io/blog/2021/12/05/APC%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="ZEROKO14">
      <meta itemprop="description" content="你好，欢迎来到ZEROKO14的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZEROKO14的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          APC机制
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-05 14:15:09" itemprop="dateCreated datePublished" datetime="2021-12-05T14:15:09+08:00">2021-12-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-18 11:31:36" itemprop="dateModified" datetime="2021-11-18T11:31:36+08:00">2021-11-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="APC机制"><a href="#APC机制" class="headerlink" title="APC机制"></a>APC机制</h1><p>APC机制使耗时操作可以异步回调处理</p>
<span id="more"></span>

<p>线程是不能被“杀死”，“挂起”，“恢复”的，线程在执行的时候自己占据着CPU，别人怎么可能控制它呢？</p>
<p>如果说线程如果想“死”，<strong>一定是自己执行代码把自己杀死</strong>，不存在”他杀”这种情况！</p>
<p>如果要改变一个线程的行为该怎么办呢？</p>
<p>可以给他提供一个函数，让它自己去调用，这个函数就是<strong>APC（Asyncroneus Procedure Call）</strong>，即<strong>异步过程调用</strong></p>
<h2 id="KAPC-STATE"><a href="#KAPC-STATE" class="headerlink" title="_KAPC_STATE"></a>_KAPC_STATE</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KTHREAD</span><br><span class="line">nt!_KTHREAD</span><br><span class="line">	...</span><br><span class="line">	   +<span class="number">0x034</span> ApcState         : _KAPC_STATE</span><br><span class="line">	...</span><br><span class="line">kd&gt; dt _KAPC_STATE</span><br><span class="line">nt!_KAPC_STATE</span><br><span class="line">   +<span class="number">0x000</span> ApcListHead      : [<span class="number">2</span>] _LIST_ENTRY<span class="comment">//两个APC队列(分别是内核APC和用户APC)，存储着要给他提供的APC函数，在某个时刻线程会检查自己的APC链表执行。链表中的内容与当前地址一样则说明该链表为空</span></span><br><span class="line">   +<span class="number">0x010</span> Process          : Ptr32 _KPROCESS<span class="comment">//当前线程挂靠的进程的进程结构体地址</span></span><br><span class="line">   +<span class="number">0x014</span> KernelApcInProgress : UChar<span class="comment">//内核APC是否正在执行</span></span><br><span class="line">   +<span class="number">0x015</span> KernelApcPending : UChar<span class="comment">//是否有正在等待执行的内核APC</span></span><br><span class="line">   +<span class="number">0x016</span> UserApcPending   : UChar<span class="comment">//是否有正在等待执行的用户APC</span></span><br></pre></td></tr></table></figure>

<ul>
<li>用户APC：APC函数地址位于用户空间，在用户空间执行.</li>
<li>内核APC：APC函数地址位于内核空间，在内核空间执行.</li>
</ul>
<p><strong>_KAPC</strong>（详细解读在后面）</p>
<p>ApcListHead中存的就是_KAPC结构的地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _kapc</span><br><span class="line">nt!_KAPC</span><br><span class="line">   +<span class="number">0x000</span> Type             : Int2B</span><br><span class="line">   +<span class="number">0x002</span> Size             : Int2B</span><br><span class="line">   +<span class="number">0x004</span> Spare0           : Uint4B</span><br><span class="line">   +<span class="number">0x008</span> Thread           : Ptr32 _KTHREAD</span><br><span class="line">   +<span class="number">0x00c</span> ApcListEntry     : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x014</span> KernelRoutine    : Ptr32     <span class="keyword">void</span> </span><br><span class="line">   +<span class="number">0x018</span> RundownRoutine   : Ptr32     <span class="keyword">void</span> </span><br><span class="line">   +<span class="number">0x01c</span> NormalRoutine    : Ptr32     <span class="keyword">void</span> <span class="comment">//找到你提供的APC函数，并不完全等于APC函数的地址，后面会讲</span></span><br><span class="line">   +<span class="number">0x020</span> NormalContext    : Ptr32 Void</span><br><span class="line">   +<span class="number">0x024</span> SystemArgument1  : Ptr32 Void</span><br><span class="line">   +<span class="number">0x028</span> SystemArgument2  : Ptr32 Void</span><br><span class="line">   +<span class="number">0x02c</span> ApcStateIndex    : Char</span><br><span class="line">   +<span class="number">0x02d</span> ApcMode          : Char</span><br><span class="line">   +<span class="number">0x02e</span> Inserted         : UChar</span><br></pre></td></tr></table></figure>

<p>如果想让线程做什么事情，就给它的APC队列里面挂一个APC。 </p>
<p><img src="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20211013171657971.png" alt="image-20211013171657971"></p>
<p><img src="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20211023213229559.png" alt="image-20211023213229559"></p>
<p><img src="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20211023213307816.png" alt="image-20211023213307816"></p>
<h2 id="什么时候执行APC中的函数？"><a href="#什么时候执行APC中的函数？" class="headerlink" title="什么时候执行APC中的函数？"></a>什么时候执行APC中的函数？</h2><ul>
<li><p><strong>KiServiceExit</strong>函数：</p>
<p>​    这个函数是<strong>系统调用，异常或中断返回用户空间的必经之路</strong>。</p>
</li>
<li><p><strong>KiDeliverApc</strong>函数：</p>
<p>​    <strong>负责执行APC函数</strong></p>
</li>
</ul>
<p>总结：当系统调用，异常，中断的时候，都有机会调用KiDeliverApc函数执行APC函数。</p>
<h2 id="备用APC队列"><a href="#备用APC队列" class="headerlink" title="备用APC队列"></a>备用APC队列</h2><h3 id="KTHREAD中APC相关成员"><a href="#KTHREAD中APC相关成员" class="headerlink" title="_KTHREAD中APC相关成员"></a>_KTHREAD中APC相关成员</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KTHREAD</span><br><span class="line">nt!_KTHREAD</span><br><span class="line">   ...</span><br><span class="line">   +<span class="number">0x02e</span> Alerted          : [<span class="number">2</span>] UChar<span class="comment">//内核模式和用户模式apc是否为&quot;已经被唤醒&quot;</span></span><br><span class="line">   +<span class="number">0x034</span> ApcState         : _KAPC_STATE<span class="comment">//APC队列,挂靠的话就是挂靠进程相关的APC队列，若未挂靠就是所属进程相关的APC队列。总是标识线程当前使用的APC队列</span></span><br><span class="line">   ...</span><br><span class="line">   +<span class="number">0x138</span> ApcStatePointer  : [<span class="number">2</span>] Ptr32 _KAPC_STATE<span class="comment">//为了操作方便存在的指向APC队列和备用APC队列的指针数组（顺序看挂靠情况而定）</span></span><br><span class="line">  ...</span><br><span class="line">   +<span class="number">0x14c</span> SavedApcState    : _KAPC_STATE<span class="comment">//备用APC队列，挂靠的情景下是所属进程相关的APC队列</span></span><br><span class="line">  ...</span><br><span class="line">   +<span class="number">0x164</span> Alertable        : UChar<span class="comment">//当前线程的apc是否可唤醒</span></span><br><span class="line">   +<span class="number">0x165</span> ApcStateIndex    : UChar<span class="comment">//标识当前线程处于什么状态：0-正常状态  1-挂靠状态  </span></span><br><span class="line">   +<span class="number">0x166</span> ApcQueueable     : UChar<span class="comment">//表示是否可以向线程的APC队列中插入APC（当线程正在执行退出的代码时，会将这个值设置为0，如果此时执行插入APC的代码(KeInsertQueueApc后面会讲)，在插入函数中会判断这个值的状态，如果为0，则插入失败）</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<h3 id="ApcStatePointer"><a href="#ApcStatePointer" class="headerlink" title="ApcStatePointer"></a>ApcStatePointer</h3><p>为了操作方便，_KTHREAD结构体中定义了一个指针数组ApcStatePointer，长度为2</p>
<p>正常情况下：</p>
<ul>
<li><em>ApcStatePointer[0]</em>  指向<strong>ApcState</strong>（里面存的是<strong>所属进程</strong>的APC队列）</li>
<li><em>ApcStatePointer[1]</em>  指向<strong>SavedApcState</strong>（里面存的是<strong>挂靠进程</strong>的APC队列）</li>
</ul>
<p>挂靠情况下：</p>
<ul>
<li><em>ApcStatePointer[0]</em>  指向<strong>SavedApcState</strong>（里面存的是<strong>所属进程</strong>的APC队列）</li>
<li><em>ApcStatePointer[1]</em>  指向<strong>ApcState</strong>（里面存的是<strong>挂靠进程</strong>的APC队列）</li>
</ul>
<h3 id="SavedApcState的意义"><a href="#SavedApcState的意义" class="headerlink" title="SavedApcState的意义"></a>SavedApcState的意义</h3><p>线程APC队列中的APC函数都是与进程相关联的，具体点说：A进程的T线程中的所有APC函数，要访问的内存地址都是A进程的。</p>
<p>但线程是可以挂靠到其他的进程，比如A进程的线程T，通过修改Cr3(改为B进程的页目录基址)，就可以访问B进程地址空间，即所谓“进程挂靠”</p>
<p>当T线程挂靠B进程后，APC队列中存储的却仍然是原来的APC。具体点说，比如某个APC函数要读取一个地址为0x12345678的数据，如果此时进行读取，读到的将是B进程的地址空间，这样逻辑就错误了。</p>
<p><strong>为了避免混乱，在T线程挂靠B进程时，会将Apcstate中的值暂时存储到SavedApcState中，等回到原进程A时，再将APC队列恢复。</strong></p>
<p>所以，SavedApcState又称为<strong>备用APC队列</strong></p>
<h4 id="挂靠环境下ApcState的意义"><a href="#挂靠环境下ApcState的意义" class="headerlink" title="挂靠环境下ApcState的意义"></a>挂靠环境下ApcState的意义</h4><p><strong>在挂靠的环境下，也是可以在线程APC队列插入APC的</strong>，那这种情况下，使用的是哪个APC队列呢？</p>
<p>A进程的T线程挂靠B进程，A是T的所属进程，B是T的挂靠进程</p>
<ul>
<li>ApcState—B进程(挂靠进程)相关的APC函数</li>
<li>SavedApcState—A(所属进程)进程相关的APC函数</li>
</ul>
<h3 id="KTHREAD-ApcStatePointer与KTHREAD-ApcStateIndex组合寻址"><a href="#KTHREAD-ApcStatePointer与KTHREAD-ApcStateIndex组合寻址" class="headerlink" title="KTHREAD.ApcStatePointer与KTHREAD.ApcStateIndex组合寻址"></a>KTHREAD.ApcStatePointer与KTHREAD.ApcStateIndex组合寻址</h3><ul>
<li><p><input checked="" disabled="" type="checkbox">  正常情况下，向ApcState队列中插入APC时：</p>
</li>
<li><p>ApcStatePointer[0] 指向 ApcState此时ApcStateIndex的值为0</p>
</li>
<li><p><strong>ApcStatePointer[KTHREAD.ApcStateIndex] 指向 ApcState</strong></p>
</li>
<li><p><input checked="" disabled="" type="checkbox">  挂靠情况下，向ApcState队列中插入APC时：</p>
</li>
<li><p>ApcStatePointer[1] 指向 ApcState此时ApcStateIndex的值为1</p>
</li>
<li><p><strong>ApcStatePointer[KTHREAD.ApcStateIndex] 指向 ApcState</strong></p>
</li>
</ul>
<p>【总结】无论什么环境下,<strong>ApcStatePointer[ApcStateIndex] 指向的都是 ApcState</strong>。</p>
<p><strong>ApcState</strong>则<strong>总是标识线程当前使用的APC状态</strong>。</p>
<h3 id="分析NtReadVirtualMemory"><a href="#分析NtReadVirtualMemory" class="headerlink" title="分析NtReadVirtualMemory"></a>分析NtReadVirtualMemory</h3><p><strong>在挂靠时是如何备份和恢复APC队列的</strong></p>
<p><strong>NtReadVirtualMemory</strong>内有挂靠进程函数_KeStackAttachProcess以及恢复不挂靠状态的函数_KeUnstackDetachProcess</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_KeStackAttachProcess</span><br><span class="line">	---&gt;_KeStackAttachProcess</span><br><span class="line">		---&gt;_KiAttachProcess</span><br><span class="line">			---&gt;<span class="comment">//若进程本身未挂靠情况下，则调用_KiMoveApcState（x，y），其作用是将x的ApcState结构备份到y的ApcState中，以实现ApcState备份到SavedApcState中</span></span><br></pre></td></tr></table></figure>

<h4 id="KiMoveApcState"><a href="#KiMoveApcState" class="headerlink" title="_KiMoveApcState"></a>_KiMoveApcState</h4><p><img src="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20211028152615008.png" alt="image-20211028152615008"></p>
<h2 id="APC挂入过程-内含KAPC详细结构"><a href="#APC挂入过程-内含KAPC详细结构" class="headerlink" title="APC挂入过程(内含KAPC详细结构)"></a>APC挂入过程(内含KAPC详细结构)</h2><p>无论是正常状态还是挂靠状态，都有两个APC队列，一个内核队列，一个用户队列。</p>
<p>每当要挂入一个APC函数时，不管是内核APC还是用户APC，内核都要准备一个KAPC的数据结构，并且将这个KAPC结构挂到相应的APC队列中。</p>
<h3 id="KAPC"><a href="#KAPC" class="headerlink" title="_KAPC"></a>_KAPC</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _kapc</span><br><span class="line">nt!_KAPC</span><br><span class="line">   +<span class="number">0x000</span> Type             : Int2B<span class="comment">//类型 APC类型为0x12</span></span><br><span class="line">   +<span class="number">0x002</span> Size             : Int2B<span class="comment">//本结构体的大小 0x30</span></span><br><span class="line">   +<span class="number">0x004</span> Spare0           : Uint4B<span class="comment">//未使用，疑似多核相关</span></span><br><span class="line">   +<span class="number">0x008</span> Thread           : Ptr32 _KTHREAD<span class="comment">//目标线程</span></span><br><span class="line">   +<span class="number">0x00c</span> ApcListEntry     : _LIST_ENTRY<span class="comment">//APC队列挂的位置</span></span><br><span class="line">   +<span class="number">0x014</span> KernelRoutine    : Ptr32     <span class="keyword">void</span> <span class="comment">//指向一个函数(调用_IopDeallocateApc函数释放APC)</span></span><br><span class="line">   +<span class="number">0x018</span> RundownRoutine   : Ptr32     <span class="keyword">void</span> <span class="comment">//略</span></span><br><span class="line">   +<span class="number">0x01c</span> NormalRoutine    : Ptr32     <span class="keyword">void</span> <span class="comment">//用户APC总入口(通过这个入口，即_BaseDispatchAPC@12（用于分发用户APC的函数），可以找到所有的用户APC函数) 或者 真正的内核apc函数 或者该成员为NULL的特殊内核APC（执行该内核APC时将直接释放）</span></span><br><span class="line">   +<span class="number">0x020</span> NormalContext    : Ptr32 Void<span class="comment">//内核APC：NULL 用户APC：真正的APC函数</span></span><br><span class="line">   +<span class="number">0x024</span> SystemArgument1  : Ptr32 Void<span class="comment">//APC函数的参数</span></span><br><span class="line">   +<span class="number">0x028</span> SystemArgument2  : Ptr32 Void<span class="comment">//不是用户自己填的，来源于__imp__RtlQueryInformationActivationContext函数的返回值</span></span><br><span class="line">   +<span class="number">0x02c</span> ApcStateIndex    : Char<span class="comment">//挂哪个队列，有4个值：0,1,2,3，后续详解</span></span><br><span class="line">   +<span class="number">0x02d</span> ApcMode          : Char<span class="comment">//标识是内核APC还是用户APC，1表示用户APC,0表示内核apc</span></span><br><span class="line">   +<span class="number">0x02e</span> Inserted         : UChar<span class="comment">//表示本APC是否已挂入队列，挂入前：0		挂入后：1</span></span><br></pre></td></tr></table></figure>

<h4 id="ApcStateIndex"><a href="#ApcStateIndex" class="headerlink" title="ApcStateIndex"></a>ApcStateIndex</h4><p>与KTHREAD（+0x165）的属性同名但含义不一样：</p>
<p><strong>ApcStateIndex有四个值</strong></p>
<ul>
<li><strong>0</strong>—原始环境，不管是否挂靠都插入到当前线程所属进程相关的APC队列（未挂靠就插入ApcState，挂靠了就插入SavedApcState）</li>
<li><strong>1</strong>—挂靠环境，插入到当前线程挂靠进程相关的APC队列（未挂靠就插入SavedApcState，挂靠了就插入ApcState）</li>
<li><strong>2</strong>—当前环境，使用_KTHREAD.ApcStateIndex，ApcStatePointer[_KTHREAD.ApcStateIndex]， 即都是写入ApcState。初始化时如果没有挂靠，插入到所属进程相关的APC队列；初始化时如果挂靠了，插入到挂靠进程相关的APC队列</li>
<li><strong>3</strong>—插入APC时的当前环境，在插入APC之前会更新当前线程是否处于挂靠状态（将_ETHREAD.Tcb.ApcStateIndex覆盖到_KAPC.ApcStateIndex中） 再进行APC插入</li>
</ul>
<p>NtQueueApcThread到KiInsertQueueApc才真正插入完，插入的过程中有可能线程的状态改变，因此3的意思指的是在KiInsertQueueApc这一步才更新线程状态</p>
<p>TargetEnvironment(ApcStateIndex)里存的四种情况的枚举类型，出自WRK</p>
<p><img src="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20211018180147858.png" alt="image-20211018180147858"></p>
<h3 id="用户APC挂入流程"><a href="#用户APC挂入流程" class="headerlink" title="用户APC挂入流程"></a>用户APC挂入流程</h3><p><img src="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20211012154033183.png" alt="image-20211012154033183"></p>
<h4 id="QueueUserAPC函数"><a href="#QueueUserAPC函数" class="headerlink" title="QueueUserAPC函数"></a>QueueUserAPC函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">.text:7C82C07A ; DWORD __stdcall QueueUserAPC(PAPCFUNC pfnAPC, HANDLE hThread, ULONG_PTR dwData)</span><br><span class="line">.text:7C82C07A                 public _QueueUserAPC@12</span><br><span class="line">.text:7C82C07A _QueueUserAPC@12 proc near              ; DATA XREF: .text:off_7C802654↑o</span><br><span class="line">.text:7C82C07A</span><br><span class="line">.text:7C82C07A pvBuffer        = dword ptr -8</span><br><span class="line">.text:7C82C07A var_4           = byte ptr -4</span><br><span class="line">.text:7C82C07A pfnAPC          = dword ptr  8</span><br><span class="line">.text:7C82C07A hThread         = dword ptr  0Ch</span><br><span class="line">.text:7C82C07A dwData          = dword ptr  10h</span><br><span class="line">.text:7C82C07A</span><br><span class="line">.text:7C82C07A ; FUNCTION CHUNK AT .text:7C844C8E SIZE 00000022 BYTES</span><br><span class="line">.text:7C82C07A</span><br><span class="line">.text:7C82C07A                 mov     edi, edi</span><br><span class="line">.text:7C82C07C                 push    ebp</span><br><span class="line">.text:7C82C07D                 mov     ebp, esp</span><br><span class="line">.text:7C82C07F                 push    ecx</span><br><span class="line">.text:7C82C080                 push    ecx</span><br><span class="line">.text:7C82C081                 and     [ebp+pvBuffer], 0</span><br><span class="line">.text:7C82C085                 push    edi</span><br><span class="line">.text:7C82C086                 xor     eax, eax</span><br><span class="line">.text:7C82C088                 push    eax             ; pcbWrittenOrRequired</span><br><span class="line">.text:7C82C089                 push    8               ; cbBuffer</span><br><span class="line">.text:7C82C08B                 lea     edi, [ebp+var_4]</span><br><span class="line">.text:7C82C08E                 stosd</span><br><span class="line">.text:7C82C08F                 lea     eax, [ebp+pvBuffer]</span><br><span class="line">.text:7C82C092                 push    eax             ; pvBuffer</span><br><span class="line">.text:7C82C093                 push    1               ; ulInfoClass</span><br><span class="line">.text:7C82C095                 push    0               ; pvSubInstance</span><br><span class="line">.text:7C82C097                 push    0               ; Context</span><br><span class="line">.text:7C82C099                 push    1               ; dwFlags</span><br><span class="line">.text:7C82C09B                 call    ds:__imp__RtlQueryInformationActivationContext@28 ; RtlQueryInformationActivationContext(x,x,x,x,x,x,x)</span><br><span class="line">.text:7C82C0A1                 test    eax, eax</span><br><span class="line">.text:7C82C0A3                 pop     edi</span><br><span class="line">.text:7C82C0A4                 jl      loc_7C844C8E</span><br><span class="line">.text:7C82C0AA                 test    [ebp+var_4], 1</span><br><span class="line">.text:7C82C0AE                 mov     eax, [ebp+pvBuffer]</span><br><span class="line">.text:7C82C0B1                 jnz     loc_7C844CA8</span><br><span class="line">.text:7C82C0B7</span><br><span class="line">.text:7C82C0B7 loc_7C82C0B7:                           ; CODE XREF: QueueUserAPC(x,x,x)+18C31↓j</span><br><span class="line">.text:7C82C0B7                 push    eax             ; SystemArgument2，来源于__imp__RtlQueryInformationActivationContext函数的返回值</span><br><span class="line">.text:7C82C0B8                 push    [ebp+dwData]    ; SystemArgument1</span><br><span class="line">.text:7C82C0BB                 push    [ebp+pfnAPC]    ; NormalContext</span><br><span class="line">.text:7C82C0BE                 push    offset _BaseDispatchAPC@12 ; ApcRoutine，此处填入的是NormalRoutine，即_BaseDispatchAPC，分发函数的函数地址</span><br><span class="line">.text:7C82C0C3                 push    [ebp+hThread]   ; ThreadHandle</span><br><span class="line">.text:7C82C0C6                 call    ds:__imp__NtQueueApcThread@20 ; NtQueueApcThread(x,x,x,x,x)</span><br><span class="line">.text:7C82C0CC                 xor     ecx, ecx</span><br><span class="line">.text:7C82C0CE                 test    eax, eax</span><br><span class="line">.text:7C82C0D0                 setnl   cl</span><br><span class="line">.text:7C82C0D3                 mov     eax, ecx</span><br><span class="line">.text:7C82C0D5</span><br><span class="line">.text:7C82C0D5 locret_7C82C0D5:                        ; CODE XREF: QueueUserAPC(x,x,x)+18C29↓j</span><br><span class="line">.text:7C82C0D5                 leave</span><br><span class="line">.text:7C82C0D6                 retn    0Ch</span><br><span class="line">.text:7C82C0D6 _QueueUserAPC@12 endp</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面可见，三环插入用户apc往NormalRoutine填入的是_BaseDispatchAPC@12函数</p>
<h4 id="NtQueueApcThread函数"><a href="#NtQueueApcThread函数" class="headerlink" title="NtQueueApcThread函数"></a>NtQueueApcThread函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">PAGE:004BA08B ; NTSTATUS __stdcall NtQueueApcThread(HANDLE ThreadHandle, PKNORMAL_ROUTINE ApcRoutine, PVOID NormalContext, PVOID SystemArgument1, PVOID SystemArgument2)</span><br><span class="line">PAGE:004BA08B _NtQueueApcThread@20 proc near          ; DATA XREF: .text:0040B978↑o</span><br><span class="line">PAGE:004BA08B</span><br><span class="line">PAGE:004BA08B AccessMode      = byte ptr -4</span><br><span class="line">PAGE:004BA08B ThreadHandle    = dword ptr  8</span><br><span class="line">PAGE:004BA08B ApcRoutine      = dword ptr  0Ch</span><br><span class="line">PAGE:004BA08B NormalContext   = dword ptr  10h</span><br><span class="line">PAGE:004BA08B SystemArgument1 = dword ptr  14h</span><br><span class="line">PAGE:004BA08B SystemArgument2 = dword ptr  18h</span><br><span class="line">PAGE:004BA08B</span><br><span class="line">PAGE:004BA08B ; FUNCTION CHUNK AT PAGE:00523983 SIZE 00000025 BYTES</span><br><span class="line">PAGE:004BA08B</span><br><span class="line">PAGE:004BA08B                 mov     edi, edi</span><br><span class="line">PAGE:004BA08D                 push    ebp</span><br><span class="line">PAGE:004BA08E                 mov     ebp, esp</span><br><span class="line">PAGE:004BA090                 push    ecx</span><br><span class="line">PAGE:004BA091                 push    ebx</span><br><span class="line">PAGE:004BA092                 push    esi</span><br><span class="line">PAGE:004BA093                 mov     eax, large fs:124h</span><br><span class="line">PAGE:004BA099                 mov     al, [eax+140h]</span><br><span class="line">PAGE:004BA09F                 mov     [ebp+AccessMode], al</span><br><span class="line">PAGE:004BA0A2                 xor     esi, esi</span><br><span class="line">PAGE:004BA0A4                 push    esi             ; HandleInformation</span><br><span class="line">PAGE:004BA0A5                 lea     eax, [ebp+ThreadHandle]</span><br><span class="line">PAGE:004BA0A8                 push    eax             ; Object</span><br><span class="line">PAGE:004BA0A9                 push    dword ptr [ebp+AccessMode] ; AccessMode</span><br><span class="line">PAGE:004BA0AC                 push    _PsThreadType   ; ObjectType</span><br><span class="line">PAGE:004BA0B2                 push    10h             ; DesiredAccess</span><br><span class="line">PAGE:004BA0B4                 push    [ebp+ThreadHandle] ; Handle</span><br><span class="line">PAGE:004BA0B7                 call    _ObReferenceObjectByHandle@24 ; ObReferenceObjectByHandle(x,x,x,x,x,x)</span><br><span class="line">PAGE:004BA0BC                 mov     ebx, eax</span><br><span class="line">PAGE:004BA0BE                 cmp     ebx, esi</span><br><span class="line">PAGE:004BA0C0                 jl      short loc_4BA123</span><br><span class="line">PAGE:004BA0C2                 mov     eax, [ebp+ThreadHandle]</span><br><span class="line">PAGE:004BA0C5                 xor     ebx, ebx</span><br><span class="line">PAGE:004BA0C7                 test    byte ptr [eax+_ETHREAD.___u24.CrossThreadFlags], 10h ; 判断当前线程是否是系统线程</span><br><span class="line">PAGE:004BA0CE                 jnz     loc_523983</span><br><span class="line">PAGE:004BA0D4                 push    edi</span><br><span class="line">PAGE:004BA0D5                 push    70617350h       ; Tag</span><br><span class="line">PAGE:004BA0DA                 push    30h             ; NumberOfBytes</span><br><span class="line">PAGE:004BA0DC                 push    8               ; PoolType</span><br><span class="line">PAGE:004BA0DE                 call    _ExAllocatePoolWithQuotaTag@12 ; ExAllocatePoolWithQuotaTag(x,x,x)创建0x30字节的空间，给KAPC使用</span><br><span class="line">PAGE:004BA0E3                 mov     edi, eax        ; 返回的内存地址放入edi中</span><br><span class="line">PAGE:004BA0E5                 cmp     edi, esi        ; 判断是否返回NULL</span><br><span class="line">PAGE:004BA0E7                 jz      loc_52398D</span><br><span class="line">PAGE:004BA0ED                 push    [ebp+NormalContext]</span><br><span class="line">PAGE:004BA0F0                 push    1</span><br><span class="line">PAGE:004BA0F2                 push    [ebp+ApcRoutine];NormalRoutine，上层函数传入的参数，统一的分发函数</span><br><span class="line">PAGE:004BA0F5                 push    esi             ; 0</span><br><span class="line">PAGE:004BA0F6                 push    offset _IopDeallocateApc@20 ; _IopDeallocateApc函数地址，其内部执行了_ExFreePoolWithTag@8</span><br><span class="line">PAGE:004BA0FB                 push    esi             ; 0</span><br><span class="line">PAGE:004BA0FC                 push    [ebp+ThreadHandle]</span><br><span class="line">PAGE:004BA0FF                 push    edi             ; KAPC</span><br><span class="line">PAGE:004BA100                 call    _KeInitializeApc@32 ; KeInitializeApc(x,x,x,x,x,x,x,x)，初始化APC函数</span><br><span class="line">PAGE:004BA105                 push    esi             ; 0</span><br><span class="line">PAGE:004BA106                 push    [ebp+SystemArgument2]</span><br><span class="line">PAGE:004BA109                 push    [ebp+SystemArgument1]</span><br><span class="line">PAGE:004BA10C                 push    edi             ; KPAC</span><br><span class="line">PAGE:004BA10D                 call    _KeInsertQueueApc@16 ; KeInsertQueueApc(x,x,x,x)</span><br><span class="line">PAGE:004BA112                 test    al, al</span><br><span class="line">PAGE:004BA114                 jz      loc_523997</span><br><span class="line">PAGE:004BA11A</span><br><span class="line">PAGE:004BA11A loc_4BA11A:                             ; CODE XREF: NtQueueApcThread(x,x,x,x,x)+69907↓j</span><br><span class="line">PAGE:004BA11A                                         ; NtQueueApcThread(x,x,x,x,x)+69918↓j</span><br><span class="line">PAGE:004BA11A                 pop     edi</span><br><span class="line">PAGE:004BA11B</span><br><span class="line">PAGE:004BA11B loc_4BA11B:                             ; CODE XREF: NtQueueApcThread(x,x,x,x,x)+698FD↓j</span><br><span class="line">PAGE:004BA11B                 mov     ecx, [ebp+ThreadHandle] ; Object</span><br><span class="line">PAGE:004BA11E                 call    @ObfDereferenceObject@4 ; ObfDereferenceObject(x)</span><br><span class="line">PAGE:004BA123</span><br><span class="line">PAGE:004BA123 loc_4BA123:                             ; CODE XREF: NtQueueApcThread(x,x,x,x,x)+35↑j</span><br><span class="line">PAGE:004BA123                 pop     esi</span><br><span class="line">PAGE:004BA124                 mov     eax, ebx</span><br><span class="line">PAGE:004BA126                 pop     ebx</span><br><span class="line">PAGE:004BA127                 leave</span><br><span class="line">PAGE:004BA128                 retn    14h</span><br><span class="line">PAGE:004BA128 _NtQueueApcThread@20 endp</span><br></pre></td></tr></table></figure>

<h4 id="KeInitializeApc函数"><a href="#KeInitializeApc函数" class="headerlink" title="KeInitializeApc函数"></a>KeInitializeApc函数</h4><p>该函数并未公布，但导出了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//来自WRK源码</span></span><br><span class="line"><span class="function">VOID <span class="title">KeInitializeApc</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">IN PKAPC Apc,<span class="comment">//KAPC指针，分配好的还没有初始化的KAPC指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">IN PKTHREAD Thread,<span class="comment">//目标线程，存储到_kapc.Thread</span></span></span></span><br><span class="line"><span class="params"><span class="function">IN KAPC_ENVIRONMENT TargetEnvironment,<span class="comment">//0 1 2 3四种状态，要挂到哪一个APC队列中，存储到_kapc.ApcStateIndex</span></span></span></span><br><span class="line"><span class="params"><span class="function">IN PKKERNEL_ROUTINE KernelRoutine,<span class="comment">//销毁KAPC的函数地址,存储到_kapc.KernelRoutine</span></span></span></span><br><span class="line"><span class="params"><span class="function">IN PKRUNDOWN_ROUTINE RundownRoutine OPTIONAL,</span></span></span><br><span class="line"><span class="params"><span class="function">IN PKNORMAL_ROUTINE NormalRoutine,<span class="comment">//用户APC总入口或者内核apc函数,存储到_kapc.NormalRoutine</span></span></span></span><br><span class="line"><span class="params"><span class="function">IN KPROCESSOR_MODE Mode,<span class="comment">//要插入用户apc队列还是内核apc队列，存储到_kapc.ApcMode</span></span></span></span><br><span class="line"><span class="params"><span class="function">IN PVOID Context<span class="comment">//内核APC：NULL  用户APC：真正的APC函数   存储到_kapc.NormalContext</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span> </span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20211019150353138.png" alt="image-20211019150353138"></p>
<h4 id="KeInsertQueueApc函数"><a href="#KeInsertQueueApc函数" class="headerlink" title="KeInsertQueueApc函数"></a>KeInsertQueueApc函数</h4><p><img src="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20211029143018774.png" alt="image-20211029143018774"></p>
<h4 id="KiInsertQueueApc函数"><a href="#KiInsertQueueApc函数" class="headerlink" title="KiInsertQueueApc函数"></a>KiInsertQueueApc函数</h4><ol>
<li>根据KAPC.ApcStateIndex找到对应的APC队列</li>
<li>再根据KAPC.ApcMode确定是用户队列还是内核队列</li>
<li>将KAPC挂到对应的队列中(挂到KAPC的ApcListEntry处)</li>
<li>再根据KAPC结构中的Inserted置1，标识当前的KAPC为已插入状态</li>
<li>KAPC_STATE结构中的KernelApcPending/UserApcPending置1(<strong>UserApcPending未必置1，只有当前线程处于等待状态，并且是用户自己导致的等待，并且是可以吵醒(Alertable)的线程才置1</strong>)</li>
</ol>
<p><img src="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20211101140140226.png" alt="image-20211101140140226"></p>
<p>该函数返回值为1表示APC已插入，但<strong>如果UserApcPending未置1，则该用户APC未必有机会执行</strong></p>
<p>插入的上半部分</p>
<p><img src="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20211101164401536.png" alt="image-20211101164401536"></p>
<p>插入的下半部分</p>
<img src="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20211101164523600.png" alt="image-20211101164523600"  />

<p>反汇编：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID</span></span><br><span class="line"><span class="function">FASTCALL</span></span><br><span class="line"><span class="function"><span class="title">KiInsertQueueApc</span><span class="params">(IN PKAPC Apc,IN KPRIORITY PriorityBoost)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">if</span> (Apc-&gt;ApcStateIndex == InsertApcEnvironment)</span><br><span class="line">    &#123;</span><br><span class="line">        Apc-&gt;ApcStateIndex = Thread-&gt;ApcStateIndex;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">//PKAPC_STATE ApcStatePointer[2];//说明ApcStateIndex只能是</span></span><br><span class="line">    <span class="comment">//OriginalApcEnvironment,//0</span></span><br><span class="line">    <span class="comment">//AttachedApcEnvironment,//1</span></span><br><span class="line">    <span class="comment">//从Thread的ApcStatePointer取出对应的ApcState</span></span><br><span class="line">    ApcState = Thread-&gt;ApcStatePointer[(UCHAR)Apc-&gt;ApcStateIndex];</span><br><span class="line">    ApcMode = Apc-&gt;ApcMode;</span><br><span class="line">    </span><br><span class="line">    ASSERT(Apc-&gt;Inserted == TRUE);    </span><br><span class="line">    <span class="comment">/* 插入队列的三种方式:</span></span><br><span class="line"><span class="comment">     * 1) Kernel APC with Normal Routine or User APC = Put it at the end of the List</span></span><br><span class="line"><span class="comment">     * 2) User APC which is PsExitSpecialApc = Put it at the front of the List</span></span><br><span class="line"><span class="comment">     * 3) Kernel APC without Normal Routine = Put it at the end of the No-Normal Routine Kernel APC list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//PsExitSpecialApc</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (Thread-&gt;ApcStateIndex == Apc-&gt;ApcStateIndex)</span><br><span class="line">    &#123;   <span class="keyword">if</span>(当前线程 ) &#123;            </span><br><span class="line">            <span class="keyword">if</span>(KernelMode) </span><br><span class="line">            &#123;</span><br><span class="line">                Thread-&gt;ApcState.KernelApcPending = TRUE;                </span><br><span class="line">                <span class="keyword">if</span> (!Thread-&gt;SpecialApcDisable)</span><br><span class="line">                &#123;                        <span class="comment">//中断线程当前执行六？？</span></span><br><span class="line">                    <span class="comment">/* They&#x27;re not, so request the interrupt */</span></span><br><span class="line">                    HalRequestSoftwareInterrupt(APC_LEVEL);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">else</span> &#123;            </span><br><span class="line">            <span class="keyword">if</span>(KernelMode) &#123;</span><br><span class="line">                Thread-&gt;ApcState.KernelApcPending = TRUE;                </span><br><span class="line">                <span class="keyword">if</span> (Thread-&gt;State == Running) </span><br><span class="line">                    HalRequestSoftwareInterrupt(APC_LEVEL);                </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(一堆条件)&#123;</span><br><span class="line">                    KiUnwaitThread(Thread, Status, PriorityBoost);<span class="comment">//唤醒线程</span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> &#123;                </span><br><span class="line">                <span class="keyword">if</span> ((Thread-&gt;State == Waiting) &amp;&amp;</span><br><span class="line">                     (Thread-&gt;WaitMode == UserMode) &amp;&amp;</span><br><span class="line">                     ((Thread-&gt;Alertable) || <span class="comment">//</span></span><br><span class="line">                      (Thread-&gt;ApcState.UserApcPending)))</span><br><span class="line">                &#123;                    <span class="comment">/* Set user-mode APC pending */</span></span><br><span class="line">                    Thread-&gt;ApcState.UserApcPending = TRUE;</span><br><span class="line">                    Status = STATUS_USER_APC;</span><br><span class="line">                    KiUnwaitThread(Thread, Status, PriorityBoost);<span class="comment">//唤醒线程</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>KiInsertQueueApc函数插入的三种方式，上面只节选了如下第2种方式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 插入队列的三种方式:</span></span><br><span class="line"><span class="comment">     * 1) Kernel APC with Normal Routine or User APC = Put it at the end of the List</span></span><br><span class="line"><span class="comment">     * 2) User APC which is PsExitSpecialApc = Put it at the front of the List</span></span><br><span class="line"><span class="comment">     * 3) Kernel APC without Normal Routine = Put it at the end of the No-Normal Routine Kernel APC list</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>

<h5 id="Alertable属性"><a href="#Alertable属性" class="headerlink" title="Alertable属性"></a>Alertable属性</h5><p>意思为：是否允许被APC吵醒</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KTHREAD</span><br><span class="line">ntdll!_KTHREAD</span><br><span class="line">   ...</span><br><span class="line">   +<span class="number">0x164</span> Alertable        : UChar</span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">SleepEx</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD dwMilliseconds, <span class="comment">// time-out interval</span></span></span></span><br><span class="line"><span class="params"><span class="function">  BOOL bAlertable        	<span class="comment">// early completion option</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">DWORD <span class="title">WaitForSingleObjectEx</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE hHandle,        	<span class="comment">// handle to object</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD dwMilliseconds, <span class="comment">// time-out interval</span></span></span></span><br><span class="line"><span class="params"><span class="function">  BOOL bAlertable        	<span class="comment">// alertable option</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Alertable=0 时</p>
<p>​    当前插入的APC函数未必有机会执行：UserApcPending = 0</p>
</li>
<li><p>Alertable=1 时</p>
<p>​    UserApcPending = 1</p>
<p>​    将目标线程唤醒(从等待链表中摘出来，并挂到调度链表)</p>
</li>
</ul>
<h3 id="三环APC-API挂入实验"><a href="#三环APC-API挂入实验" class="headerlink" title="三环APC API挂入实验"></a>三环APC API挂入实验</h3><h4 id="QueueUserAPC"><a href="#QueueUserAPC" class="headerlink" title="QueueUserAPC"></a>QueueUserAPC</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">QueueUserAPC</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] PAPCFUNC  pfnAPC,<span class="comment">//APC回调函数</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in] HANDLE    hThread,<span class="comment">//线程的句柄。句柄必须具有THREAD_SET_CONTEXT访问权限。</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in] ULONG_PTR dwData<span class="comment">//APC回调函数参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="三环APC-API挂入实验-1"><a href="#三环APC-API挂入实验-1" class="headerlink" title="三环APC API挂入实验"></a>三环APC API挂入实验</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID NTAPI <span class="title">myAPC</span><span class="params">(_In_ ULONG_PTR Parameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;APC执行，参数为%d\r\n&quot;</span>, Parameter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadCall</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;线程开始执行\r\n&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;线程执行中...\r\n&quot;</span>);</span><br><span class="line">		SleepEx(<span class="number">1000</span>,TRUE);<span class="comment">//TRUE表示该线程的休眠可被APC唤醒，修改的成员是KTHREAD.alertable。WaitForSingleObjectEx也有类似参数</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HANDLE hThread = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)threadCall, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (hThread==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;CreateThread wrong!   wrong num：&quot;</span>&lt;&lt; GetLastError() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ULONG a = <span class="number">30</span>;</span><br><span class="line">	getchar();<span class="comment">//按任意键插入用户APC</span></span><br><span class="line">	<span class="comment">//使用现成的API编写代码向某个线程插入一个用户APC，体会什么是APC</span></span><br><span class="line">	QueueUserAPC(myAPC, hThread, a);</span><br><span class="line">	</span><br><span class="line">	getchar();<span class="comment">//防止主线程结束，导致程序释放了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20211026232558356.png" alt="image-20211026232558356"></p>
<h2 id="内核APC执行流程"><a href="#内核APC执行流程" class="headerlink" title="内核APC执行流程"></a>内核APC执行流程</h2><p>APC函数的执行与插入并不是同一个线程，具体点讲：</p>
<p>在线程A中向B线程插入一个APC，插入的动作是在A线程中完成的，但什么时候执行则由B线程决定。所以叫”异步过程调用”。</p>
<p>内核APC函数与用户APC函数的执行时间和执行方式也有区别。</p>
<h3 id="执行点：线程切换"><a href="#执行点：线程切换" class="headerlink" title="执行点：线程切换"></a>执行点：线程切换</h3><p><strong>该执行点只执行内核APC</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SwapContext	<span class="comment">//判断是否有内核APC，有内核apc执行返回1，没有返回0</span></span><br><span class="line">    | 执行完返回到</span><br><span class="line">KiSwapContext<span class="comment">//有内核apc执行返回1，没有返回0</span></span><br><span class="line">    | 执行完返回到</span><br><span class="line">KiSwapThread<span class="comment">//KiSwapContext返回的是1就调用下面的函数</span></span><br><span class="line">	| 执行完返回到</span><br><span class="line">KiDeliverApc <span class="comment">//执行内核APC函数</span></span><br></pre></td></tr></table></figure>

<p><strong>SwapContext函数截取</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">;末端截取</span><br><span class="line">.text:004049F6                 cmp     [esi+_ETHREAD.Tcb.ApcState.KernelApcPending], 0 ; 判断要切换的线程是否有要执行的内核APC</span><br><span class="line">.text:004049FA                 jnz     short loc_404A00</span><br><span class="line">.text:004049FC                 popf</span><br><span class="line">.text:004049FD                 xor     eax, eax</span><br><span class="line">.text:004049FF                 retn</span><br><span class="line">.text:00404A00 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00404A00</span><br><span class="line">.text:00404A00 loc_404A00:                             ; CODE XREF: SwapContext+D6↑j</span><br><span class="line">.text:00404A00                 popf</span><br><span class="line">.text:00404A01                 jnz     short loc_404A06</span><br><span class="line">.text:00404A03                 mov     al, 1           ; 有要执行的内核apc返回1</span><br><span class="line">.text:00404A05                 retn</span><br><span class="line">.text:00404A06 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00404A06</span><br><span class="line">.text:00404A06 loc_404A06:                             ; CODE XREF: SwapContext+DD↑j</span><br><span class="line">.text:00404A06                 mov     cl, 1</span><br><span class="line">.text:00404A08                 call    ds:__imp_@HalRequestSoftwareInterrupt@4 ; HalRequestSoftwareInterrupt(x)</span><br><span class="line">.text:00404A0E                 xor     eax, eax        ; 没有要执行的内核apc返回0</span><br><span class="line">.text:00404A10                 retn</span><br><span class="line">.text:00404A11 ; ---------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p><strong>KiSwapThread函数截取</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">;截取KiSwapThread</span><br><span class="line">.text:004050F0 loc_4050F0:                             ; CODE XREF: KiSwapThread()+B8F4↓j</span><br><span class="line">.text:004050F0                 mov     ecx, eax        ; 取要切换的目标线程</span><br><span class="line">.text:004050F2                 call    @KiSwapContext@4 ; KiSwapContext(x)</span><br><span class="line">.text:004050F7                 test    al, al</span><br><span class="line">.text:004050F9                 mov     cl, [edi+_KTHREAD.WaitIrql] ; NewIrql</span><br><span class="line">.text:004050FC                 mov     edi, [edi+_KTHREAD.WaitStatus]</span><br><span class="line">.text:004050FF                 mov     esi, ds:__imp_@KfLowerIrql@4 ; KfLowerIrql(x)</span><br><span class="line">.text:00405105                 jnz     loc_415ADB      ; 这个跳转处理APC</span><br><span class="line">.text:00415ADB ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00415ADB</span><br><span class="line">.text:00415ADB loc_415ADB:                             ; CODE XREF: KiSwapThread()+46↑j</span><br><span class="line">.text:00415ADB                 mov     cl, 1           ; NewIrql</span><br><span class="line">.text:00415ADD                 call    esi ; KfLowerIrql(x) ; KfLowerIrql(x)</span><br><span class="line">.text:00415ADF                 xor     eax, eax</span><br><span class="line">.text:00415AE1                 push    eax</span><br><span class="line">.text:00415AE2                 push    eax</span><br><span class="line">.text:00415AE3                 push    eax             ; 0处理内核APC  1处理内核APC和用户APC</span><br><span class="line">.text:00415AE4                 call    _KiDeliverApc@12 ; KiDeliverApc(x,x,x) 专门用来处理APC的函数</span><br><span class="line">.text:00415AE9                 xor     cl, cl</span><br><span class="line">.text:00415AEB                 jmp     loc_40510B</span><br><span class="line">.text:00415AF0 ; ---------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<h3 id="执行点：系统调用，中断或异常-KiServiceExit"><a href="#执行点：系统调用，中断或异常-KiServiceExit" class="headerlink" title="执行点：系统调用，中断或异常(_KiServiceExit)"></a>执行点：系统调用，中断或异常(_KiServiceExit)</h3><p>即从内核返回用户空间的途中</p>
<p><strong>_KiServiceExit</strong>是系统调用，中断或异常<strong>回三环的时候必须要走的函数</strong>。</p>
<p><strong>该执行点先执行内核APC，再执行用户APC</strong></p>
<p><strong>_KiServiceExit截取</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">.text:004077FD _KiServiceExit  proc near               ; CODE XREF: _KiSetLowWaitHighThread+7C↓j</span><br><span class="line">.text:004077FD                                         ; NtContinue(x,x)+42↓j ...</span><br><span class="line">.text:004077FD</span><br><span class="line">.text:004077FD arg_C           = dword ptr  10h</span><br><span class="line">.text:004077FD arg_10          = dword ptr  14h</span><br><span class="line">.text:004077FD arg_40          = dword ptr  44h</span><br><span class="line">.text:004077FD arg_44          = dword ptr  48h</span><br><span class="line">.text:004077FD arg_48          = dword ptr  4Ch</span><br><span class="line">.text:004077FD arg_60          = dword ptr  64h</span><br><span class="line">.text:004077FD arg_64          = dword ptr  68h</span><br><span class="line">.text:004077FD arg_68          = dword ptr  6Ch</span><br><span class="line">.text:004077FD arg_6C          = dword ptr  70h</span><br><span class="line">.text:004077FD</span><br><span class="line">.text:004077FD ; FUNCTION CHUNK AT .text:00407908 SIZE 00000088 BYTES</span><br><span class="line">.text:004077FD</span><br><span class="line">.text:004077FD                 cli</span><br><span class="line">.text:004077FE                 test    dword ptr [ebp+70h], 20000h ; 判断CPU模式 [ebp+70]是3环的Eflags</span><br><span class="line">.text:00407805                 jnz     short loc_40780D ; 获取_KTHREAD</span><br><span class="line">.text:00407807                 test    byte ptr [ebp+6Ch], 1 ; 三环的SegCs</span><br><span class="line">.text:0040780B                 jz      short loc_407864</span><br><span class="line">.text:0040780D</span><br><span class="line">.text:0040780D loc_40780D:                             ; CODE XREF: _KiServiceExit+8↑j</span><br><span class="line">.text:0040780D                                         ; _KiServiceExit+63↓j</span><br><span class="line">.text:0040780D                 mov     ebx, ds:0FFDFF124h ; 获取_KTHREAD</span><br><span class="line">.text:00407813                 mov     [ebx+_KTHREAD.Alerted], 0</span><br><span class="line">.text:00407817                 cmp     [ebx+_KTHREAD.ApcState.UserApcPending], 0 ; 判断是否存在用户APC等待执行</span><br><span class="line">.text:0040781B                 jz      short loc_407864 ; 没有用户APC等待执行就跳转</span><br><span class="line">.text:0040781D                 mov     ebx, ebp</span><br><span class="line">.text:0040781F                 mov     [ebx+44h], eax</span><br><span class="line">.text:00407822                 mov     dword ptr [ebx+50h], 3Bh</span><br><span class="line">.text:00407829                 mov     dword ptr [ebx+38h], 23h</span><br><span class="line">.text:00407830                 mov     dword ptr [ebx+34h], 23h</span><br><span class="line">.text:00407837                 mov     dword ptr [ebx+30h], 0</span><br><span class="line">.text:0040783E                 mov     ecx, 1          ; NewIrql</span><br><span class="line">.text:00407843                 call    ds:__imp_@KfRaiseIrql@4 ; KfRaiseIrql(x)</span><br><span class="line">.text:00407849                 push    eax             ; KfRaiseIrql返回老的运行级别，入栈</span><br><span class="line">.text:0040784A                 sti</span><br><span class="line">.text:0040784B                 push    ebx</span><br><span class="line">.text:0040784C                 push    0</span><br><span class="line">.text:0040784E                 push    1               ; 0处理内核APC   1处理内核APC和用户APC</span><br><span class="line">.text:00407850                 call    _KiDeliverApc@12 ; 执行内核APC函数，并为用户空间的APC的执行进行准备</span><br><span class="line">.text:00407850                                         ; 下面是将老的运行级别出栈，然后执行KfLowerIrql函数恢复原来的运行级别</span><br><span class="line">.text:00407855                 pop     ecx             ; NewIrql</span><br><span class="line">.text:00407856                 call    ds:__imp_@KfLowerIrql@4 ; KfLowerIrql(x)</span><br><span class="line">.text:0040785C                 mov     eax, [ebx+44h]</span><br><span class="line">.text:0040785F                 cli</span><br><span class="line">.text:00407860                 jmp     short loc_40780D ; 获取_KTHREAD</span><br><span class="line">.text:00407860 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00407862                 align 4</span><br></pre></td></tr></table></figure>

<p><strong>【注意】这个执行点必须是有用户APC存在的情况下，才可以触发该执行点</strong>(先处理内核APC再处理用户APC)，不然就直接返回了</p>
<h3 id="KiDeliverApc函数内核APC执行流程"><a href="#KiDeliverApc函数内核APC执行流程" class="headerlink" title="KiDeliverApc函数内核APC执行流程"></a>KiDeliverApc函数内核APC执行流程</h3><ol>
<li>判断第一个链表是否为空</li>
<li>判断KTHREAD.ApcState.KernelApcInProgress是否为1</li>
<li>判断是否禁用内核APC（KTHREAD.KernelApcDisable是否为1）</li>
<li>将当前KAPC结构体从链表中摘除</li>
<li>执行KAPC.KernelRoutine执行的函数，释放KAPC结构体占用的空间</li>
<li>将KTHREAD.ApcState.KernelApcInProgress设置为1，标识正在执行内核APC</li>
<li>执行真正的内核APC函数（KAPC.NormalRoutine）</li>
<li>执行完毕，将KernelApcInProgress改为0</li>
<li>循环</li>
</ol>
<p><strong>汇编流程如下：</strong></p>
<img src="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20211015132902898.png" alt="image-20211015132902898"  />

<h3 id="内核APC总结"><a href="#内核APC总结" class="headerlink" title="内核APC总结"></a>内核APC总结</h3><ol>
<li>内核APC在线程切换的时候就会执行，这也就意味着，只要插入内核APC很快就会执行。</li>
<li>在执行用户APC之前就会先执行内核APC。</li>
<li>内核APC在内核空间执行，不需要换栈，一个循环全部执行完毕</li>
</ol>
<h2 id="用户APC执行流程"><a href="#用户APC执行流程" class="headerlink" title="用户APC执行流程"></a>用户APC执行流程</h2><p>当产生系统调用，中断或者异常，线程在返回用户空间前都会调用_KiServiceExit函数，在_KiServiceExit会判断是否有要执行的用户APC，如果有则调用KiDeliverApc函数(第一个参数为1)进行处理</p>
<p><img src="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20211023221626174.png" alt="image-20211023221626174"></p>
<p><img src="https://gitee.com/ZEROKO14/blog-img/raw/master/img/deliver.png" alt="deliver"></p>
<p>上图是从用户模式调用Native API才走KiServiceExit2</p>
<p><strong>总览流程图</strong></p>
<p><img src="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20211118112937375.png" alt="image-20211118112937375"></p>
<p><img src="https://gitee.com/ZEROKO14/blog-img/raw/master/img/20201202171056458.png" alt="20201202171056458"></p>
<h3 id="执行用户APC时的堆栈操作"><a href="#执行用户APC时的堆栈操作" class="headerlink" title="执行用户APC时的堆栈操作"></a>执行用户APC时的堆栈操作</h3><p>处理用户APC要比内核APC复杂的多，因为，用户APC函数要在用户空间执行的，这里<strong>涉及到大量换栈的操作</strong>：</p>
<p>当线程从用户层进入内核层时，要保留原来的运行环境，比如各种寄存器，栈的位置等等（_Trap_Frame），然后切换成内核的堆栈，如果正常返回，恢复堆栈环境即可。</p>
<p>但如果有用户APC要执行的话，就意味着线程要<strong>提前返回到用户空间去执行</strong>，而且返回的位置不是线程进入内核时的位置，而是<strong>返回到其他的位置</strong>，每处理一个用户APC都会涉及到：<br>$$<br>内核  —&gt;  用户空间  —&gt;  再回到内核空间<br>$$<br>堆栈的操作比较复杂，如果不了解堆栈的操作细节不可能理解用户APC是如何执行的！</p>
<p>堆栈变化总结：</p>
<h3 id="KiInitializeUserApc函数分析"><a href="#KiInitializeUserApc函数分析" class="headerlink" title="KiInitializeUserApc函数分析"></a>KiInitializeUserApc函数分析</h3><p>线程进入0环时，原来的运行环境（寄存器栈顶等）保存到_Trap_Frame结构体中，如果要提前返回到3环取处理用户APC，就必须要<strong>修改_Trap_Frame结构体</strong>：</p>
<p>比如：进入0环时的位置存储在EIP中，现在要提前返回，而且返回的并不是原来的位置，那就意味着必须要修改EIP为新的返回位置。还有堆栈ESP，也要修改为处理APC需要的堆栈。那原来的值怎么办呢？处理完APC后该如何返回原来的位置呢？</p>
<p>KiInitializeUserApc要做的<strong>第一件事就是备份</strong>：</p>
<p>将原来的_Trap_Frame结构体的值备份到一个新的结构体中（<a target="_blank" rel="noopener" href="https://www.cnblogs.com/DeeLMind/p/6855085.html">CONTEXT</a>），这个功能由其子函数<strong>KeContextFromKframes</strong>来完成。</p>
<p><strong>KiInitializeUserApc函数分析：准备回用户层的执行环境</strong></p>
<ol>
<li>段寄存器：SS DS FS GS</li>
<li>修改EFLAGS寄存器</li>
<li>修改ESP</li>
<li>修改EIP（此EIP是固定修改为全局变量_KeUserApcDispatcher存的值，其值指向ntdll.KiUserApcDispatcher函数）</li>
</ol>
<p><img src="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20211016154954475.png" alt="image-20211016154954475"><img src="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20211016155050235.png" alt="image-20211016155050235"></p>
<h4 id="CONTEXT结构体"><a href="#CONTEXT结构体" class="headerlink" title="CONTEXT结构体"></a>CONTEXT结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">CONTEXT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    DWORD           ContextFlags    <span class="comment">// -|               +00h</span></span><br><span class="line">    DWORD           Dr0             <span class="comment">//  |               +04h</span></span><br><span class="line">    DWORD           Dr1             <span class="comment">//  |               +08h</span></span><br><span class="line">    DWORD           Dr2             <span class="comment">//  &gt;调试寄存器     +0Ch</span></span><br><span class="line">    DWORD           Dr3             <span class="comment">//  |               +10h</span></span><br><span class="line">    DWORD           Dr6             <span class="comment">//  |               +14h</span></span><br><span class="line">    DWORD           Dr7             <span class="comment">// -|               +18h</span></span><br><span class="line"></span><br><span class="line">    FLOATING_SAVE_AREA FloatSave;   <span class="comment">//浮点寄存器区      +1Ch~~~88h</span></span><br><span class="line"></span><br><span class="line">    DWORD           SegGs           <span class="comment">//-|                +8Ch</span></span><br><span class="line">    DWORD           SegFs           <span class="comment">// |\段寄存器       +90h</span></span><br><span class="line">    DWORD           SegEs           <span class="comment">// |/               +94h</span></span><br><span class="line">    DWORD           SegDs           <span class="comment">//-|                +98h</span></span><br><span class="line"></span><br><span class="line">    DWORD           Edi             <span class="comment">//________          +9Ch</span></span><br><span class="line">    DWORD           Esi             <span class="comment">// |  通用          +A0h</span></span><br><span class="line">    DWORD           Ebx             <span class="comment">// |   寄           +A4h</span></span><br><span class="line">    DWORD           Edx             <span class="comment">// |   存           +A8h</span></span><br><span class="line">    DWORD           Ecx             <span class="comment">// |   器           +ACh</span></span><br><span class="line">    DWORD           Eax             <span class="comment">//_|___组_          +B0h</span></span><br><span class="line"></span><br><span class="line">    DWORD           Ebp             <span class="comment">//++++++            +B4h</span></span><br><span class="line">    DWORD           Eip             <span class="comment">// |控制            +B8h</span></span><br><span class="line">    DWORD           SegCs           <span class="comment">// |寄存            +BCh</span></span><br><span class="line">    DWORD           EFlag           <span class="comment">// |器组            +C0h</span></span><br><span class="line">    DWORD           Esp             <span class="comment">// |                +C4h</span></span><br><span class="line">    DWORD           SegSs           <span class="comment">//++++++            +C8h</span></span><br><span class="line"></span><br><span class="line">    BYTE    ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];</span><br><span class="line">&#125; CONTEXT;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//windbg中</span></span><br><span class="line">nt!_CONTEXT</span><br><span class="line">   +<span class="number">0x000</span> ContextFlags     : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> Dr0              : Uint4B</span><br><span class="line">   +<span class="number">0x008</span> Dr1              : Uint4B</span><br><span class="line">   +<span class="number">0x00c</span> Dr2              : Uint4B</span><br><span class="line">   +<span class="number">0x010</span> Dr3              : Uint4B</span><br><span class="line">   +<span class="number">0x014</span> Dr6              : Uint4B</span><br><span class="line">   +<span class="number">0x018</span> Dr7              : Uint4B</span><br><span class="line">   +<span class="number">0x01c</span> FloatSave        : _FLOATING_SAVE_AREA</span><br><span class="line">   +<span class="number">0x08c</span> SegGs            : Uint4B</span><br><span class="line">   +<span class="number">0x090</span> SegFs            : Uint4B</span><br><span class="line">   +<span class="number">0x094</span> SegEs            : Uint4B</span><br><span class="line">   +<span class="number">0x098</span> SegDs            : Uint4B</span><br><span class="line">   +<span class="number">0x09c</span> Edi              : Uint4B</span><br><span class="line">   +<span class="number">0x0a0</span> Esi              : Uint4B</span><br><span class="line">   +<span class="number">0x0a4</span> Ebx              : Uint4B</span><br><span class="line">   +<span class="number">0x0a8</span> Edx              : Uint4B</span><br><span class="line">   +<span class="number">0x0ac</span> Ecx              : Uint4B</span><br><span class="line">   +<span class="number">0x0b0</span> Eax              : Uint4B</span><br><span class="line">   +<span class="number">0x0b4</span> Ebp              : Uint4B</span><br><span class="line">   +<span class="number">0x0b8</span> Eip              : Uint4B</span><br><span class="line">   +<span class="number">0x0bc</span> SegCs            : Uint4B</span><br><span class="line">   +<span class="number">0x0c0</span> EFlags           : Uint4B</span><br><span class="line">   +<span class="number">0x0c4</span> Esp              : Uint4B</span><br><span class="line">   +<span class="number">0x0c8</span> SegSs            : Uint4B</span><br><span class="line">   +<span class="number">0x0cc</span> ExtendedRegisters : [<span class="number">512</span>] UChar</span><br><span class="line">   <span class="comment">//win32的CONTEXT结构体共占0xCC+0x200=0x2CC字节</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20210831191749044.png" alt="image-20210831191749044"></p>
<h4 id="ntdll-KiUserApcDispatcher分析"><a href="#ntdll-KiUserApcDispatcher分析" class="headerlink" title="ntdll.KiUserApcDispatcher分析"></a>ntdll.KiUserApcDispatcher分析</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.text:7C92E430 ; __stdcall KiUserApcDispatcher(x, x, x, x, x)</span><br><span class="line">.text:7C92E430                 public _KiUserApcDispatcher@20</span><br><span class="line">.text:7C92E430 _KiUserApcDispatcher@20 proc near       ; DATA XREF: .text:off_7C923428↑o</span><br><span class="line">.text:7C92E430</span><br><span class="line">.text:7C92E430 arg_C           = byte ptr  10h</span><br><span class="line">.text:7C92E430</span><br><span class="line">.text:7C92E430                 lea     edi, [esp+arg_C]; CONTEXT指针</span><br><span class="line">.text:7C92E434                 pop     eax</span><br><span class="line">.text:7C92E435                 call    eax             ; 处理用户APC的总入口：NormalRoutine</span><br><span class="line">.text:7C92E437                 push    1</span><br><span class="line">.text:7C92E439                 push    edi</span><br><span class="line">.text:7C92E43A                 call    _ZwContinue@8   ; ZwContinue(x,x) 返回内核</span><br><span class="line">.text:7C92E43F                 nop</span><br><span class="line">.text:7C92E43F _KiUserApcDispatcher@20 endp ; sp-analysis failed</span><br><span class="line">.text:7C92E43F</span><br><span class="line">.text:7C92E440 ; Exported entry  46. KiUserCallbackDispatcher</span><br></pre></td></tr></table></figure>

<ol>
<li><p>当用户在3环调用QueueUserAPC函数来插入APC时，不需要提供NormalRoutine，这个参数是在QueueUserAPC内部指定的：</p>
<p>​    <strong>Kernel32.BaseDispatchAPC函数</strong>：调用用户提供的真正的用户APC函数</p>
</li>
<li><p>ZwContinue函数的意义：</p>
<ul>
<li>返回内核，如果还有用户APC，重复上面的执行过程</li>
<li>如果没有需要执行的用户APC，会将CONTEXT赋值给Trap_Frame结构体。就像从来没有修改过一样。ZwContinue后面的代码不会执行，线程从哪里进0环仍然会从哪里回去。</li>
</ul>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>内核APC在线程切换时执行，不需要换栈，比较简单，一个循环执行完毕。</li>
<li>用户APC在系统调用，中断或异常返回3环前会进行判断，如果有要执行的用户APC，再执行。</li>
<li>用户APC执行前会先执行内核APC</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/blog/tags/%E5%86%85%E6%A0%B8/" rel="tag"># 内核</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/blog/2021/12/05/FPS%E9%80%86%E5%90%91%E9%9A%8F%E7%AC%94/" rel="prev" title="FPS逆向">
      <i class="fa fa-chevron-left"></i> FPS逆向
    </a></div>
      <div class="post-nav-item">
    <a href="/blog/2021/12/05/64%E4%BD%8D%E9%80%86%E5%90%91/" rel="next" title="64位逆向">
      64位逆向 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#APC%E6%9C%BA%E5%88%B6"><span class="nav-number">1.</span> <span class="nav-text">APC机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#KAPC-STATE"><span class="nav-number">1.1.</span> <span class="nav-text">_KAPC_STATE</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%89%A7%E8%A1%8CAPC%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="nav-number">1.2.</span> <span class="nav-text">什么时候执行APC中的函数？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%87%E7%94%A8APC%E9%98%9F%E5%88%97"><span class="nav-number">1.3.</span> <span class="nav-text">备用APC队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#KTHREAD%E4%B8%ADAPC%E7%9B%B8%E5%85%B3%E6%88%90%E5%91%98"><span class="nav-number">1.3.1.</span> <span class="nav-text">_KTHREAD中APC相关成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ApcStatePointer"><span class="nav-number">1.3.2.</span> <span class="nav-text">ApcStatePointer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SavedApcState%E7%9A%84%E6%84%8F%E4%B9%89"><span class="nav-number">1.3.3.</span> <span class="nav-text">SavedApcState的意义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%82%E9%9D%A0%E7%8E%AF%E5%A2%83%E4%B8%8BApcState%E7%9A%84%E6%84%8F%E4%B9%89"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">挂靠环境下ApcState的意义</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KTHREAD-ApcStatePointer%E4%B8%8EKTHREAD-ApcStateIndex%E7%BB%84%E5%90%88%E5%AF%BB%E5%9D%80"><span class="nav-number">1.3.4.</span> <span class="nav-text">KTHREAD.ApcStatePointer与KTHREAD.ApcStateIndex组合寻址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90NtReadVirtualMemory"><span class="nav-number">1.3.5.</span> <span class="nav-text">分析NtReadVirtualMemory</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#KiMoveApcState"><span class="nav-number">1.3.5.1.</span> <span class="nav-text">_KiMoveApcState</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#APC%E6%8C%82%E5%85%A5%E8%BF%87%E7%A8%8B-%E5%86%85%E5%90%ABKAPC%E8%AF%A6%E7%BB%86%E7%BB%93%E6%9E%84"><span class="nav-number">1.4.</span> <span class="nav-text">APC挂入过程(内含KAPC详细结构)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#KAPC"><span class="nav-number">1.4.1.</span> <span class="nav-text">_KAPC</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ApcStateIndex"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">ApcStateIndex</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7APC%E6%8C%82%E5%85%A5%E6%B5%81%E7%A8%8B"><span class="nav-number">1.4.2.</span> <span class="nav-text">用户APC挂入流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#QueueUserAPC%E5%87%BD%E6%95%B0"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">QueueUserAPC函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NtQueueApcThread%E5%87%BD%E6%95%B0"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">NtQueueApcThread函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#KeInitializeApc%E5%87%BD%E6%95%B0"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">KeInitializeApc函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#KeInsertQueueApc%E5%87%BD%E6%95%B0"><span class="nav-number">1.4.2.4.</span> <span class="nav-text">KeInsertQueueApc函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#KiInsertQueueApc%E5%87%BD%E6%95%B0"><span class="nav-number">1.4.2.5.</span> <span class="nav-text">KiInsertQueueApc函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Alertable%E5%B1%9E%E6%80%A7"><span class="nav-number">1.4.2.5.1.</span> <span class="nav-text">Alertable属性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E7%8E%AFAPC-API%E6%8C%82%E5%85%A5%E5%AE%9E%E9%AA%8C"><span class="nav-number">1.4.3.</span> <span class="nav-text">三环APC API挂入实验</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#QueueUserAPC"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">QueueUserAPC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E7%8E%AFAPC-API%E6%8C%82%E5%85%A5%E5%AE%9E%E9%AA%8C-1"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">三环APC API挂入实验</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E6%A0%B8APC%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.5.</span> <span class="nav-text">内核APC执行流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E7%82%B9%EF%BC%9A%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2"><span class="nav-number">1.5.1.</span> <span class="nav-text">执行点：线程切换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E7%82%B9%EF%BC%9A%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%EF%BC%8C%E4%B8%AD%E6%96%AD%E6%88%96%E5%BC%82%E5%B8%B8-KiServiceExit"><span class="nav-number">1.5.2.</span> <span class="nav-text">执行点：系统调用，中断或异常(_KiServiceExit)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KiDeliverApc%E5%87%BD%E6%95%B0%E5%86%85%E6%A0%B8APC%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.5.3.</span> <span class="nav-text">KiDeliverApc函数内核APC执行流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8APC%E6%80%BB%E7%BB%93"><span class="nav-number">1.5.4.</span> <span class="nav-text">内核APC总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E6%88%B7APC%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.6.</span> <span class="nav-text">用户APC执行流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E7%94%A8%E6%88%B7APC%E6%97%B6%E7%9A%84%E5%A0%86%E6%A0%88%E6%93%8D%E4%BD%9C"><span class="nav-number">1.6.1.</span> <span class="nav-text">执行用户APC时的堆栈操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KiInitializeUserApc%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90"><span class="nav-number">1.6.2.</span> <span class="nav-text">KiInitializeUserApc函数分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CONTEXT%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">CONTEXT结构体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ntdll-KiUserApcDispatcher%E5%88%86%E6%9E%90"><span class="nav-number">1.6.2.2.</span> <span class="nav-text">ntdll.KiUserApcDispatcher分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.6.3.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ZEROKO14</p>
  <div class="site-description" itemprop="description">你好，欢迎来到ZEROKO14的个人博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZEROKO14</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>-->

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/muse.js"></script>


<script src="/blog/js/next-boot.js"></script>


  <script defer src="/blog/lib/three/three.min.js"></script>
    <script defer src="/blog/lib/three/three-waves.min.js"></script>


  















  

  

</body>
</html>
