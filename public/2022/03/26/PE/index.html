<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zeroko14.gitee.io","root":"/blog/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="什么是可执行文件">
<meta property="og:type" content="article">
<meta property="og:title" content="PE">
<meta property="og:url" content="http://zeroko14.gitee.io/blog/2022/03/26/PE/index.html">
<meta property="og:site_name" content="ZEROKO14的个人博客">
<meta property="og:description" content="什么是可执行文件">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210604121004126.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210604134303017.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/pe%E7%BB%93%E6%9E%84%E5%9B%BE.JPG">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20211127210012444.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210604141102723.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210604180109514.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210604210332119.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210604220050538.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210604162826452.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210604163038120.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/tempsnip.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210605145444540.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210606121703626.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210606115603452.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210606115642621.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210406133806124.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210607121906024.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210607122444890.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210607123144789.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210607132251965.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210708142928288.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210607134402552.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210607140823333.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210607141338756.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/20131007225555312.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/20131007225859203.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210607141808212.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210607151337405.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210607163327446.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210607164617022.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20211125115210958.png">
<meta property="article:published_time" content="2022-03-26T14:25:00.719Z">
<meta property="article:modified_time" content="2022-03-26T14:25:00.721Z">
<meta property="article:author" content="ZEROKO14">
<meta property="article:tag" content="PE">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210604121004126.png">

<link rel="canonical" href="http://zeroko14.gitee.io/blog/2022/03/26/PE/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>PE | ZEROKO14的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ZEROKO14的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">zeroko14's blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zeroko14.gitee.io/blog/2022/03/26/PE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="ZEROKO14">
      <meta itemprop="description" content="你好，欢迎来到ZEROKO14的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZEROKO14的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          PE
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-26 22:25:00" itemprop="dateCreated datePublished" datetime="2022-03-26T22:25:00+08:00">2022-03-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="什么是可执行文件"><a href="#什么是可执行文件" class="headerlink" title="什么是可执行文件"></a>什么是可执行文件</h1><span id="more"></span>

<p>可执行文件（executable file）指的是可以由操作系统进行加载执行的文件。</p>
<p>可执行文件的格式：</p>
<ol>
<li>windows平台：PE（Portable Executable）文件结构</li>
<li>Linux平台：ELF（Executable and Linking Format）文件结构</li>
</ol>
<p>哪些领域会用到PE文件结构</p>
<ol>
<li>病毒与反病毒</li>
<li>外挂与反外挂</li>
<li>加壳与脱壳（保护与破解）</li>
<li>无源码修改功能，软件汉化等等</li>
</ol>
<h2 id="如何识别PE文件"><a href="#如何识别PE文件" class="headerlink" title="如何识别PE文件"></a>如何识别PE文件</h2><ol>
<li><p>PE文件的特征（PE指纹）</p>
<p>分别打开.exe .dll .sys 等文件，观察特征前2个字节</p>
<p>UE二进制方式打开文件，前两个字节是4D 5A表示得字符是MZ，然后0x3c的地址处如果说是E0 00 00 00，就到000000E0地址处查看前两个字节是不是50 45，表示得字符是PE，如果上述的都满足，就说明这个文件是PE文件。</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210604121004126.png" alt="image-20210604121004126"></p>
</li>
<li><p>不要仅仅通过文件名的后缀名来认定PE文件（因为后缀名是可以改的）</p>
</li>
</ol>
<p>PE文件结构</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210604134303017.png" alt="image-20210604134303017"></p>
<ol>
<li>DOS部分是历史遗留问题，以前是DOS系统</li>
<li>PE文件头是给windows用的</li>
<li>节表，当前文件一共分成多少部分，就是一个索引目录</li>
<li>节数据，存具体的数据</li>
</ol>
<p>WINNT.H的文件中定义了PE文件需要用到的结构体</p>
<img src="https://raw.githubusercontent.com/che77a38/blogImage/main/pe%E7%BB%93%E6%9E%84%E5%9B%BE.JPG" alt="pe结构图"  />

<p>详细的结构体信息参考<strong>pe结构.pdf</strong></p>
<p>PE在文件中结构参考</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20211127210012444.png" alt="image-20211127210012444"></p>
<h1 id="主要结构体"><a href="#主要结构体" class="headerlink" title="主要结构体"></a>主要结构体</h1><h2 id="DOS部分"><a href="#DOS部分" class="headerlink" title="DOS部分"></a>DOS部分</h2><h3 id="IMAGE-DOS-HEADER结构："><a href="#IMAGE-DOS-HEADER结构：" class="headerlink" title="IMAGE_DOS_HEADER结构："></a><strong>IMAGE_DOS_HEADER结构</strong>：</h3><p>DOS MZ文件头，固定为64个字节</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210604141102723.png" alt="image-20210604141102723"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个结构体都是给16位程序看的，所以都是无用的，只有e_magic和e_lfanew有用，是例外</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DOS_HEADER</span> &#123;</span>      <span class="comment">// DOS .EXE header</span></span><br><span class="line">    WORD   e_magic;                     <span class="comment">// Magic number//MZ标志</span></span><br><span class="line">    WORD   e_cblp;                      <span class="comment">// Bytes on last page of file</span></span><br><span class="line">    WORD   e_cp;                        <span class="comment">// Pages in file</span></span><br><span class="line">    WORD   e_crlc;                      <span class="comment">// Relocations</span></span><br><span class="line">    WORD   e_cparhdr;                   <span class="comment">// Size of header in paragraphs</span></span><br><span class="line">    WORD   e_minalloc;                  <span class="comment">// Minimum extra paragraphs needed</span></span><br><span class="line">    WORD   e_maxalloc;                  <span class="comment">// Maximum extra paragraphs needed</span></span><br><span class="line">    WORD   e_ss;                        <span class="comment">// Initial (relative) SS value</span></span><br><span class="line">    WORD   e_sp;                        <span class="comment">// Initial SP value</span></span><br><span class="line">    WORD   e_csum;                      <span class="comment">// Checksum</span></span><br><span class="line">    WORD   e_ip;                        <span class="comment">// Initial IP value</span></span><br><span class="line">    WORD   e_cs;                        <span class="comment">// Initial (relative) CS value</span></span><br><span class="line">    WORD   e_lfarlc;                    <span class="comment">// File address of relocation table</span></span><br><span class="line">    WORD   e_ovno;                      <span class="comment">// Overlay number</span></span><br><span class="line">    WORD   e_res[<span class="number">4</span>];                    <span class="comment">// Reserved words</span></span><br><span class="line">    WORD   e_oemid;                     <span class="comment">// OEM identifier (for e_oeminfo)</span></span><br><span class="line">    WORD   e_oeminfo;                   <span class="comment">// OEM information; e_oemid specific</span></span><br><span class="line">    WORD   e_res2[<span class="number">10</span>];                  <span class="comment">// Reserved words</span></span><br><span class="line">    LONG   e_lfanew;                    <span class="comment">// File address of new exe header  偏移为0x3C，指向的是PE指纹(PE字符)所在的位置</span></span><br><span class="line">  &#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;</span><br></pre></td></tr></table></figure>

<p>只有e_magic和e_lfanew有用，e_magic修改的话直接不能打开了，e_lfanew指向PE头的地址，修改的话，对应位置也要改为PE头和其后续的内容</p>
<h3 id="DOS-Stub（DOS块）"><a href="#DOS-Stub（DOS块）" class="headerlink" title="DOS Stub（DOS块）"></a><strong>DOS Stub</strong>（DOS块）</h3><p>大小不确定，这块数据是给链接器用的，链接器会往里面插入数据；DOS块的内容，不会影响程序执行，所以可以肆意修改（因为是DOS系统历史遗留问题，PE保留了这个结构，仅在dos系统有用）</p>
<p>默认内容为弹框显示当前程序在dos系统不可用（仅在dos系统有效）</p>
<p>DOS块不是一个结构体，是由一堆单个字节的数据组成的数据</p>
<p>IMAGE_DOS_HEADER结构中的e_lfanew指向了PE头，<strong>从DOS MZ部分尾到PE头之间的就是DOS块</strong></p>
<p>整个DOS块可以全部修改都不影响程序运行</p>
<h2 id="PE文件头"><a href="#PE文件头" class="headerlink" title="PE文件头"></a><strong>PE文件头</strong></h2><p>真正有用的数据是从PE头开始的</p>
<p><strong>PE标识不能破坏，操作系统在启动一个程序的时候会检测该标识</strong>,映射到内存后可破坏</p>
<p>PE文件头的数据结构</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//32位</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS</span> &#123;</span></span><br><span class="line">    DWORD Signature;<span class="comment">//PE标识</span></span><br><span class="line">    IMAGE_FILE_HEADER FileHeader;<span class="comment">//IMAGE_FILE_HEADER子结构体（标准PE头）</span></span><br><span class="line">    IMAGE_OPTIONAL_HEADER32 OptionalHeader;<span class="comment">//IMAGE_OPTIONAL_HEADER32子结构体（拓展PE头）</span></span><br><span class="line">&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br><span class="line"><span class="comment">//64位</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS64</span> &#123;</span></span><br><span class="line">    DWORD Signature;</span><br><span class="line">    IMAGE_FILE_HEADER FileHeader;</span><br><span class="line">    IMAGE_OPTIONAL_HEADER64 OptionalHeader;</span><br><span class="line">&#125; IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;</span><br><span class="line"><span class="comment">//32位和64位的区别只有PE拓展头</span></span><br></pre></td></tr></table></figure>

<p>PE文件头包含三个部分</p>
<ol>
<li>PE文件头标记，存的是‘P’ ‘E’，0,0（4个字节）</li>
<li>标准PE头（20个字节）</li>
<li>拓展PE头（这个结构体32位（默认224个字节）和64位（默认240个字节）文件不一样）</li>
</ol>
<h3 id="标准PE头"><a href="#标准PE头" class="headerlink" title="标准PE头"></a>标准PE头</h3><p>固定20个字节</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_FILE_HEADER</span> &#123;</span></span><br><span class="line">    WORD    Machine;<span class="comment">//可以运行在什么样的CPU上 任意：0  </span></span><br><span class="line">    <span class="comment">//Intel 386以及后续（32位）：14C   宏：IMAGE_FILE_MACHINE_I386 </span></span><br><span class="line">    <span class="comment">//x64:8664   宏：IMAGE_FILE_MACHINE_AMD64</span></span><br><span class="line">    WORD    NumberOfSections;<span class="comment">//表示节的数量</span></span><br><span class="line">    DWORD   TimeDateStamp;<span class="comment">//编译器填写的时间戳(从1970年0时0分0秒开始算的秒数)，与文件属性里的创建修改时间无关</span></span><br><span class="line">    DWORD   PointerToSymbolTable;<span class="comment">//调试相关，苹果的pdb文件和exe文件是合二为一的，这里和下面那个字段是为了兼容其他系统的做准备的，微软本身并不使用（空想的野心无实际作用）</span></span><br><span class="line">    DWORD   NumberOfSymbols;<span class="comment">//调试相关</span></span><br><span class="line">    WORD    SizeOfOptionalHeader;<span class="comment">//决定了拓展PE头的大小，32位不修改的话默认0xE0，即十进制224，64位不修改的话，默认0xF0，即十进制240</span></span><br><span class="line">    WORD    Characteristics;<span class="comment">//记录当前PE文件属性</span></span><br><span class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure>

<p><code>p.s.C:\Windows\SysWOW64存放的是32位PE文件，C:\Windows\System32存放的是64位PE文件</code></p>
<p>应该根据SizeOfOptionalHeader字段的长度去解析后面的拓展PE头的数据</p>
<p>OD原版是默认识别224位拓展pe头的。</p>
<p><strong>Characteristics字段含义</strong>：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210604180109514.png" alt="image-20210604180109514"></p>
<p>32位notepad.exe比如0x0102，展开成二进制为0000 0001 0000 0010，意思是第1位和第8位是1，所以对照上图，文件是可执行的并且只在32位平台运行</p>
<p>64位notepad.exe比如0x0022，展开成二进制为0000 0000 0010 0010，意思是第1位和第5位是1，所以对照上图，文件是可执行的并且应用程序可处理大于2GB的地址</p>
<p><code>应用程序可处理大于2GB的地址的理解：应用程序在32位有4GB的存储空间，内核部分用了2G，应用程序可处理低2G的内存空间，这个设置最高可以达到用户地址3G，部分游戏优化器会这么做</code></p>
<h3 id="拓展PE头"><a href="#拓展PE头" class="headerlink" title="拓展PE头"></a>拓展PE头</h3><p>32位的拓展PE头默认占224个字节，但可以靠修改标准PE头中的SizeOfOptionalHeader修改它的大小，然后往里面添加东西</p>
<p>拓展PE头有三类：1.32位 2.64位 3.嵌入式</p>
<p>结构如下：（下面的”没用”表示不具备参考意义，可以随意修改的）(注意重点)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//32位的拓展PE头结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER</span> &#123;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Standard fields.标准字段，嵌入式拓展PE头同样的下面这6个字段，64位拓展PE头同样的下面5个字段</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    WORD    Magic;<span class="comment">//PE32:10B   PE32+:20B 只读芯片(嵌入式设备)：0x107，最准确的用于判断是32位程序还是64位程序的字段(重点)</span></span><br><span class="line">    BYTE    MajorLinkerVersion;<span class="comment">//链接器主版本号（可用于参考平台和依赖，但不能信任）</span></span><br><span class="line">    BYTE    MinorLinkerVersion;<span class="comment">//链接器次版本号</span></span><br><span class="line">    DWORD   SizeOfCode;<span class="comment">//所有代码节的总和文件对齐后的大小，编译器填写的，无用</span></span><br><span class="line">    DWORD   SizeOfInitializedData;<span class="comment">//包含所有已经初始化数据的节的总数据文件对齐后的大小，编译器填写，无用</span></span><br><span class="line">    DWORD   SizeOfUninitializedData;<span class="comment">//包含未初始化数据的节的总数据文件对齐后的大小，编译器填写，无用</span></span><br><span class="line">    <span class="comment">//拓展PE头的第16个字节</span></span><br><span class="line">    DWORD   AddressOfEntryPoint;<span class="comment">//程序入口，相对整个PE文件起始位置（ImageBase）的偏移(重点)</span></span><br><span class="line">    <span class="comment">//上面字段简称EP，与之相关的还有个OEP表示的是原始入口点</span></span><br><span class="line">    DWORD   BaseOfCode;<span class="comment">//代码开始的基址，编译器填写，无用</span></span><br><span class="line">    DWORD   BaseOfData;<span class="comment">//数据开始的基址，编译器填写，无用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// NT additional fields.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">	<span class="comment">//拓展PE头的第28个字节</span></span><br><span class="line">    DWORD   ImageBase;<span class="comment">//内存镜像基址(建议装载地址)，PE文件在内存中展开的首地址(重点)</span></span><br><span class="line">    <span class="comment">//上面这个字段，修改的话，由于很多内容是写在地址固定位置的，ImageBase修改的话，也要对他们进行修正，工作量大的话几乎是不可能的。（老师认为自动化不可能实现100%修正）；建议装载地址的意思是：如果这个地址没被占用并且合法有效（基于分页的首地址（页边界）并且不能是内核的地址）的就放这个地址，否则哪里有位置放哪里。</span></span><br><span class="line">    DWORD   SectionAlignment;<span class="comment">//内存对齐，在内存中对齐的大小，默认0x1000</span></span><br><span class="line">    <span class="comment">//上面这个字段可以改，但必须是按照操作系统的特性改，winXP的话可以按照4个字节改，而win7开始必须1000为单位改（即可以改为2000,3000等等）（因为一页为1000字节）,当然，想要程序正常运行后面也要相对应的调整</span></span><br><span class="line">    <span class="comment">//拓展PE头的第36个字节(重点)</span></span><br><span class="line">    DWORD   FileAlignment;<span class="comment">//文件对齐，通常是0x200，对齐的话一定要按照这个里面存的整数倍(重点)</span></span><br><span class="line">    <span class="comment">//上面这个对齐和编译器有关，某些高级编译器是0x1000和内存对齐一样</span></span><br><span class="line">    WORD    MajorOperatingSystemVersion;<span class="comment">//标识操作系统主版本号（这几个版本号也被OD原版参考了）</span></span><br><span class="line">    WORD    MinorOperatingSystemVersion;<span class="comment">//标识操作系统次版本号</span></span><br><span class="line">    WORD    MajorImageVersion;<span class="comment">//Pe文件自身的主版本号</span></span><br><span class="line">    WORD    MinorImageVersion;<span class="comment">//PE文件自身的次版本号</span></span><br><span class="line">    WORD    MajorSubsystemVersion;<span class="comment">//运行所需主子系统版本号(不能修改，否则会运行不了)</span></span><br><span class="line">    WORD    MinorSubsystemVersion;<span class="comment">//运行所需次子系统版本号</span></span><br><span class="line">    DWORD   Win32VersionValue;<span class="comment">//子系统版本的值，必须为0</span></span><br><span class="line">    <span class="comment">//拓展PE头的第56个字节</span></span><br><span class="line">    DWORD   SizeOfImage;<span class="comment">//内存中整个PE文件的映射的的内存对齐后的尺寸，所以可比实际的增大，必须是SectionAlignment的整数倍，该字段可以修改，但修改不能多不能少还要对齐，否则运行出错(重点)</span></span><br><span class="line">    <span class="comment">//拓展PE头的第60个字节</span></span><br><span class="line">    DWORD   SizeOfHeaders;<span class="comment">//DOS头加上PE头加上节表按照文件对齐后的大小，否则加载会出错(重点)</span></span><br><span class="line">    DWORD   CheckSum;<span class="comment">//校验和，一些系统文件有要求(sys)，用来判断文件是否被修改(两个字节两个字节相加，最后再加上文件的长度得到的值就是校验和)(重点)</span></span><br><span class="line">    WORD    Subsystem;<span class="comment">//子系统  驱动程序(1) 图像界面(2) 控制台,DLL(3) XBOX(14)</span></span><br><span class="line">    WORD    DllCharacteristics;<span class="comment">//文件特性 别被名字误导，不是针对DLL文件的,如果是0x2000就是基于WDM的驱动程序。</span></span><br><span class="line">    DWORD   SizeOfStackReserve;<span class="comment">//初始化时保留的栈大小</span></span><br><span class="line">    DWORD   SizeOfStackCommit;<span class="comment">//初始化时实际提交的栈的大小</span></span><br><span class="line">    DWORD   SizeOfHeapReserve;<span class="comment">//初始化时保留的堆大小</span></span><br><span class="line">    DWORD   SizeOfHeapCommit;<span class="comment">//初始化时实际提交堆的大小</span></span><br><span class="line">    <span class="comment">//保留和提交的区别，提交的是实际提供了物理空间的，马上可以用，保留是被分配了但并没有物理空间存在直到被使用才分配物理空间。&quot;保留&quot;就是最多可以&quot;提交&quot;多少，大型保留区域的副作用是应用程序可能会导致系统耗尽物理内存。上面四个字段都可以修改，但必须该空间大小系统能提供</span></span><br><span class="line">    DWORD   LoaderFlags;<span class="comment">//调试相关，操作系统保证不用他，用于程序运行后写自定义数据（被淘汰了）</span></span><br><span class="line">    DWORD   NumberOfRvaAndSizes;<span class="comment">//目录项数目，当前的程序会用到各种表，这个值告诉我们有多少个表。</span></span><br><span class="line">    <span class="comment">//前面的结构占96个字节</span></span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];<span class="comment">//16个IMAGE_DATA_DIRECTORY DataDirectory结构体数组，共占16*8=128个字节，里面存的是各种表。大部分情况下是16个结构体的数组，但实际上有多少个结构体取决于NumberOfRvaAndSizes字段</span></span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure>

<p>文件对齐的意思：假设DOS头加上PE头加上节表大小为0x302，且FileAlignment存的是0x200，则SizeOfHeaders里面文件对齐的数值为0x400</p>
<p>OD原版的分析功能，参考了这个SizeOfCode字段来确定读入的代码数，而这个字段只是一个参考字段，因此这里可以作为反OD原版其中一个方案的方式，把这个数设置得超大直接读不了那么多而让od崩溃，或者设置得比较大，让od很卡（一般8位16进制高位给个1）。</p>
<p>DllCharacteristics详细选项（WORD拆分为16位,按位对应含义）</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210604210332119.png" alt="image-20210604210332119"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//64位的拓展PE头结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER64</span> &#123;</span></span><br><span class="line">    WORD        Magic;</span><br><span class="line">    BYTE        MajorLinkerVersion;</span><br><span class="line">    BYTE        MinorLinkerVersion;</span><br><span class="line">    DWORD       SizeOfCode;</span><br><span class="line">    DWORD       SizeOfInitializedData;</span><br><span class="line">    DWORD       SizeOfUninitializedData;</span><br><span class="line">    DWORD       AddressOfEntryPoint;</span><br><span class="line">    DWORD       BaseOfCode;</span><br><span class="line">    ULONGLONG   ImageBase;</span><br><span class="line">    DWORD       SectionAlignment;</span><br><span class="line">    DWORD       FileAlignment;</span><br><span class="line">    WORD        MajorOperatingSystemVersion;</span><br><span class="line">    WORD        MinorOperatingSystemVersion;</span><br><span class="line">    WORD        MajorImageVersion;</span><br><span class="line">    WORD        MinorImageVersion;</span><br><span class="line">    WORD        MajorSubsystemVersion;</span><br><span class="line">    WORD        MinorSubsystemVersion;</span><br><span class="line">    DWORD       Win32VersionValue;</span><br><span class="line">    DWORD       SizeOfImage;</span><br><span class="line">    DWORD       SizeOfHeaders;</span><br><span class="line">    DWORD       CheckSum;</span><br><span class="line">    WORD        Subsystem;</span><br><span class="line">    WORD        DllCharacteristics;</span><br><span class="line">    ULONGLONG   SizeOfStackReserve;</span><br><span class="line">    ULONGLONG   SizeOfStackCommit;</span><br><span class="line">    ULONGLONG   SizeOfHeapReserve;</span><br><span class="line">    ULONGLONG   SizeOfHeapCommit;</span><br><span class="line">    DWORD       LoaderFlags;</span><br><span class="line">    DWORD       NumberOfRvaAndSizes;</span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;</span><br><span class="line"><span class="comment">//和32位比少了几个成员</span></span><br><span class="line"><span class="comment">//然后ULONGLONG那几个成员由4字节变成了8字节</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> __int64 ULONGLONG;<span class="comment">//无符号64位int</span></span><br></pre></td></tr></table></figure>

<p>嵌入式设备PE拓展头</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_ROM_OPTIONAL_HEADER</span> &#123;</span></span><br><span class="line">    WORD   Magic;</span><br><span class="line">    BYTE   MajorLinkerVersion;</span><br><span class="line">    BYTE   MinorLinkerVersion;</span><br><span class="line">    DWORD  SizeOfCode;</span><br><span class="line">    DWORD  SizeOfInitializedData;</span><br><span class="line">    DWORD  SizeOfUninitializedData;</span><br><span class="line">    DWORD  AddressOfEntryPoint;</span><br><span class="line">    DWORD  BaseOfCode;</span><br><span class="line">    DWORD  BaseOfData;</span><br><span class="line">    DWORD  BaseOfBss;</span><br><span class="line">    DWORD  GprMask;</span><br><span class="line">    DWORD  CprMask[<span class="number">4</span>];</span><br><span class="line">    DWORD  GpValue;</span><br><span class="line">&#125; IMAGE_ROM_OPTIONAL_HEADER, *PIMAGE_ROM_OPTIONAL_HEADER;</span><br></pre></td></tr></table></figure>

<h2 id="节表"><a href="#节表" class="headerlink" title="节表"></a>节表</h2><p>真正的数据都存在节里</p>
<p>有多少个节呢，节从哪开始到哪结束，存储的是什么数据，能读能写等等这些信息都存在节表里，相当于<strong>节数据的目录</strong></p>
<p>节表实际上是一个结构体数组，<strong>每一个结构体成员40个字节</strong>，每一个结构体都可以描述一个节的特性（所有节相关的重要特性都记录在节表中）</p>
<p><strong>标准PE头中的NumberOfSections字段决定节的数量</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_SECTION_HEADER</span> &#123;</span></span><br><span class="line">    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];<span class="comment">//ASCII字符串，可自定义，只占8个字节</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span><span class="comment">//Misc双字 是该节在没有对齐前的真实尺寸，实际的大小（包含了未初始化变量在内存中占的位置），该值可以不准确</span></span><br><span class="line">            DWORD   PhysicalAddress;<span class="comment">//实际上也可以表示物理地址的意思，但是往往表示得就是在虚拟内存中占用的未对齐前的真实大小</span></span><br><span class="line">            DWORD   VirtualSize;</span><br><span class="line">    &#125; Misc;</span><br><span class="line">    DWORD   VirtualAddress;<span class="comment">//在内存中的偏移地址，加上imageBase才是在内存中的真正地址</span></span><br><span class="line">    DWORD   SizeOfRawData;<span class="comment">//节在文件中对齐后的大小（实际上是磁盘上初始化数据文件对齐后的大小）</span></span><br><span class="line">    DWORD   PointerToRawData;<span class="comment">//节区在文件中的起始偏移地址</span></span><br><span class="line">    DWORD   PointerToRelocations;<span class="comment">//调试相关（除了调试相关的都是重点）</span></span><br><span class="line">    DWORD   PointerToLinenumbers;<span class="comment">//调试相关</span></span><br><span class="line">    WORD    NumberOfRelocations;<span class="comment">//调试相关</span></span><br><span class="line">    WORD    NumberOfLinenumbers;<span class="comment">//调试相关</span></span><br><span class="line">    DWORD   Characteristics;<span class="comment">//节的属性</span></span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>上面的Misc字段详解【理解】</strong></p>
<p>Misc的大小有可能比SizeOfRawData大，也有可能比SizeOfRawData小</p>
<p>有初始值的全局变量和没有初始值的全局变量，<strong>没有初始值的全局变量在文件中是不给他分配位置的，但在内存中是有位置且初始化了值的</strong></p>
<p>由于上面这点，所以Misc的大小有可能比SizeOfRawData大，但是又由于Misc是未内存对齐的数据大小，所以Misc 内存对齐后的大小有可能比SizeOfRawData小</p>
<p>实际在内存中到底占多大取决于SizeOfRawData和Misc的大小比较，若SizeOfRawData大则直接占SizeOfRawData的大小的空间，若Misc大则按照Misc内存对齐后的大小占用空间</p>
</blockquote>
<p>Characteristics节的属性详解（DWORD拆分为32位,按位对应含义）</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210604220050538.png" alt="image-20210604220050538"></p>
<p><em>比如Characteristics中二进制1100 0000 0000 0000 0000 0000 0100 0000</em></p>
<p><em>表示的是节中包含已初始化数据，映射到内存后的页面包含可读可写属性。</em></p>
<p><em>由此可知这个节存的都是可读可写的全局变量(参考C语言入门部分内存布局*<em>全局初始化数据区/静态数据区</em></em>)*</p>
<p><code>编译完了以后很多成员是没有意义的，所以也可以往这里成员里写入自己想写入的东西</code></p>
<p>节表后面会被编译器插入很多数据，这些数据不能动，不然会出问题</p>
<h2 id="节数据"><a href="#节数据" class="headerlink" title="节数据"></a>节数据</h2><p>节数据的开始位置一定是拓展PE头里的SizeOfHeaders字段的地址位置。</p>
<p>节数据中的每个节也是要按照拓展PE头里的SizeOfHeaders字段进行文件对齐</p>
<h1 id="PE文件的两种状态"><a href="#PE文件的两种状态" class="headerlink" title="PE文件的两种状态"></a>PE文件的两种状态</h1><p>上述所有结构都是针对PE在硬盘文件中的状态</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210604162826452.png" alt="image-20210604162826452"></p>
<p>如图，PE文件在内存是按照SectionAlignment内存对齐，如果SectionAlignment和FileAlignment一样的话，那么PE在磁盘文件和在内存中就是一样的</p>
<p>块表和节表是一样的。</p>
<p>通过WinHex图示按钮可以查看exe在内存中的视图</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210604163038120.png" alt="image-20210604163038120"></p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/tempsnip.png" alt="tempsnip"></p>
<p><strong>在内存中节的大小按照拓展PE头中的SectionAlignment字段进行的内存对齐，而不是文件对齐</strong></p>
<p>上图PE磁盘文件与内存映像结构图中为什么每个刚好是0x1000，就是因为拓展PE头中的SectionAlignment字段为0x1000，并且每个节的真正字节大小为小于等于0x1000</p>
<h2 id="RVA到FOA的转换"><a href="#RVA到FOA的转换" class="headerlink" title="RVA到FOA的转换"></a>RVA到FOA的转换</h2><p><strong>RVA</strong>：Relative Virtual Address（相对虚拟地址）</p>
<p><strong>FOA</strong>：File Offset Address（文件偏移地址）</p>
<p><strong>相对虚拟地址</strong>到<strong>文件偏移地址</strong>的转换（内存对齐与文件对齐不一样的情况）</p>
<ol>
<li><p>得到RVA的值：内存地址-ImageBase</p>
</li>
<li><p>判断RVA是否位于PE头中，如果是：FOA==RVA</p>
</li>
<li><p>判断RVA位于哪个节：</p>
<p>​        RVA&gt;=节.VirtualAddress</p>
<p>​        RVA&lt;节.VirtualAddress+节.virtualSize</p>
<p>差值=RVA-节.VirtuallAddress;</p>
</li>
<li><p>FOA=节.PointerToRawData+差值;</p>
</li>
</ol>
<p><code>想要找的目标地址到当前节头的差值在文件中和在内存中是一样的</code></p>
<p>如果文件对齐和内存对齐是一样的，那么直接FOA=内存地址-ImageBase。也就是FOA=RVA</p>
<h1 id="PE的空白区添加代码"><a href="#PE的空白区添加代码" class="headerlink" title="PE的空白区添加代码"></a>PE的空白区添加代码</h1><p>加壳：通常的目的就是为了隐藏程序的入口。</p>
<p>病毒：感染了程序，在程序执行之前先做病毒的事情。</p>
<p>让程序执行之前，先执行我们添加的代码，再执行程序</p>
<p><strong>空白区添加代码的步骤</strong></p>
<ol>
<li><p>构造要写入的代码（这里的例子是弹出一个对话框）（E8这种CALL是不依赖于导入表的）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">6A 00 6A 00 6A 00 6A 00 E8 00 00 00 00 E9 00 00 00 00</span><br><span class="line">//6A 00为push 0	E8为call，后面填入messagebox的call的地址-E8指令当前的地址-5</span><br><span class="line">E9 为jmp，后面的00000000要填入程序入口地址-E9指令当前的地址-5（跳回程序入口）</span><br></pre></td></tr></table></figure>

<p><code>上面目前构造的硬编码只可以在自己的电脑上执行，若上面构造的硬编码为在任何机器上都可以执行，那么他就是一段标准的shellCode，后续会讲</code></p>
</li>
<li><p>在PE的空白处构造一段代码</p>
</li>
<li><p>修改入口地址为空白区新增代码的所在地址</p>
</li>
</ol>
<h2 id="扩大节"><a href="#扩大节" class="headerlink" title="扩大节"></a>扩大节</h2><p>我们可以在任意空白区添加自己的代码，但如果添加的代码比较多，空白区不够怎么办？</p>
<p>扩大节。扩大最后一节就无需修正前面的节了</p>
<p><strong>扩大节的步骤：</strong></p>
<p>1.分配一块新的空间，大小为S（直接增加内存对齐的倍数省事）</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210605145444540.png" alt="image-20210605145444540"></p>
<ol start="2">
<li><p>将最后一个节的SizeOfRawData和VirtualSize改为N（看谁大）</p>
<p>​    N=（SizeOfRawData或者VirtualSize按照内存对齐后的值）+S</p>
</li>
<li><p>修改SizeOfImage（拓展PE头里的字段）大小</p>
<p>​    SizeOfImage新值=SizeOfImage旧值按内存对齐+S</p>
</li>
<li><p>扩大节的目的是为了插入代码执行的，所以当前节必须是可执行的，如果不行，则还需要手动修改当前节的节表里的当前节结构体的Characteristics节的属性字段，改成可执行字段</p>
</li>
</ol>
<h2 id="新增节"><a href="#新增节" class="headerlink" title="新增节"></a>新增节</h2><p>扩大节，新增的代码和原代码混在一起了。</p>
<p>还有一种方法是新增一个自己的节</p>
<p><strong>新增节的步骤</strong></p>
<ol>
<li>判断是否有足够的空间，可以添加一个节表(不确定不够的话是否可以修改sizeOfHeader强行增加，<strong>待测试</strong>)</li>
<li>修改节表末尾节的大小（只是为了省事，不修改的话麻烦一丢丢，下面例子修改了末尾节）</li>
<li>在节表中新增一个成员</li>
<li>修改PE头中节的数量</li>
<li>修改sizeOfImage的大小</li>
<li>在原有数据的最后，新增一个节的数据（内存对齐的整数倍）</li>
<li>修正新增节表的属性</li>
</ol>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210606121703626.png" alt="image-20210606121703626"></p>
<p>新增节前：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210606115603452.png" alt="image-20210606115603452"></p>
<p>新增节后：（.tttt为新增节的名称）</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210606115642621.png" alt="image-20210606115642621"></p>
<h2 id="合并节"><a href="#合并节" class="headerlink" title="合并节"></a>合并节</h2><p>问：如果节表没有地方可以插入成员了怎么办？</p>
<p>答：合并节</p>
<table>
<thead>
<tr>
<th align="left">涉及的节表成员</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Name</td>
<td align="left">节名称</td>
</tr>
<tr>
<td align="left">VirtualAddress</td>
<td align="left">节在内存中的偏移 （RVA）</td>
</tr>
<tr>
<td align="left">Misc</td>
<td align="left">节的实际大小</td>
</tr>
<tr>
<td align="left">SizeOfRawData</td>
<td align="left">节在文件中对齐后的尺寸</td>
</tr>
<tr>
<td align="left">PointerToRawData</td>
<td align="left">节区在文件中的偏移</td>
</tr>
<tr>
<td align="left">Characteristics</td>
<td align="left">节的属性</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">涉及的标准PE头成员</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">NumberOfSections</td>
<td align="left">节的个数</td>
</tr>
</tbody></table>
<p>下面合并所有节</p>
<p><strong>合并节的步骤</strong></p>
<ol>
<li><p>将每个节都修正内存对齐</p>
</li>
<li><p>将第一个节的内存大小，文件大小改成一样</p>
<p>​        最后一个节Max=SizeOfRawData&gt;VirtualSize内存对齐后?SizeOfRawData:VirtualSize内存对齐后</p>
<p>​        第一个节SizeOfRawData=VirtualSize=最后一个节的VirtualAddress+最后一个节Max-SizeOfHeaders内存对齐后的大小</p>
</li>
<li><p>将第一个节的属性改为包含所有节的属性</p>
</li>
<li><p>修改节的数量为1</p>
</li>
</ol>
<h3 id="修正内存对齐"><a href="#修正内存对齐" class="headerlink" title="修正内存对齐"></a>修正内存对齐</h3><p>修正内存对齐 使得 节文件对齐后的大小和内存对齐后的大小一致，方便后续合并节</p>
<table>
<thead>
<tr>
<th align="left">涉及的节表成员</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Misc</td>
<td align="left">节的实际大小</td>
</tr>
<tr>
<td align="left">SizeOfRawData</td>
<td align="left">节在文件中对齐后的尺寸</td>
</tr>
<tr>
<td align="left">PointerToRawData</td>
<td align="left">节区在文件中的偏移</td>
</tr>
</tbody></table>
<ol>
<li>计算节内存对齐后的大小</li>
<li>计算差值 = 节内存对齐后的大小 - 节文件对齐后的大小</li>
<li>计算节在文件中的末尾位置 = 节在文件中的偏移 + 节文件对齐后的大小</li>
<li>在节的文件中的末尾位置后填充新空间，新空间的大小为 前面计算的差值</li>
<li>修正Misc和SizeOfRawData为节内存对齐后的大小</li>
<li>在该节后面的节在文件中的偏移增加差值</li>
</ol>
<h4 id="计算节内存对齐后的大小"><a href="#计算节内存对齐后的大小" class="headerlink" title="计算节内存对齐后的大小"></a>计算节内存对齐后的大小</h4><p>节内存对齐后的大小 = ( max{Misc,SizeOfRawData} ÷ SectionAlignment)向上取整 × SectionAlignment</p>
<p>即节内存对齐后的大小 = ( max{0x62008,0x62200}÷0x1000)向上取整 × 0x1000</p>
<p>即节内存对齐后的大小 = ( max{0x62008,0x62200}÷0x1000)向上取整 × 0x1000</p>
<p>即节内存对齐后的大小 = (0x62200 ÷ 0x1000)向上取整 × 0x1000 = 0x63000</p>
<h4 id="计算差值"><a href="#计算差值" class="headerlink" title="计算差值"></a>计算差值</h4><p>差值 = 节内存对齐后的大小 - 节文件对齐后的大小 = 节内存对齐后的大小 - SizeOfRawData</p>
<p>即 差值 = 0x63000 - 0x62200 = 0xE00</p>
<h4 id="计算节在文件中的末尾位置"><a href="#计算节在文件中的末尾位置" class="headerlink" title="计算节在文件中的末尾位置"></a>计算节在文件中的末尾位置</h4><p>节在文件中的末尾位置 = 节在文件中的偏移 + 节文件对齐后的大小</p>
<p>即节在文件中的末尾位置 = PointerToRawData + SizeOfRawData</p>
<p>即节在文件中的末尾位置 = 0x1dfa00 + 0x62200 = 0x241C00</p>
<h4 id="填充新空间"><a href="#填充新空间" class="headerlink" title="填充新空间"></a>填充新空间</h4><p>找到前面计算出来的节在文件中的末尾位置</p>
<p>选择插入的大小为：0xE00(对应十进制为3584)，即插入前面计算出来的差值</p>
<p>插入后，保存</p>
<h4 id="修正节成员"><a href="#修正节成员" class="headerlink" title="修正节成员"></a>修正节成员</h4><p>修正Misc和SizeOfRawData为节内存对齐后的大小：0x63000</p>
<p>修正后：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210406133806124.png" alt="image-20210406133806124"></p>
<h4 id="修正后面的节"><a href="#修正后面的节" class="headerlink" title="修正后面的节"></a>修正后面的节</h4><p>在该节后面的节在文件中的偏移增加差值</p>
<p>修改其PointerToRawData = PointerToRawData + 差值</p>
<p>即 PointerToRawData = 0x241c00 + 0xe00 = 242A00</p>
<h1 id="表"><a href="#表" class="headerlink" title="表"></a>表</h1><p>问：一个可执行程序是由一个PE文件组成的吗?</p>
<p>答：不是</p>
<p>导入表：记录当前PE文件用到哪些PE文件中的哪些函数</p>
<p>导出表：当前的PE文件提供了哪些函数给别的PE文件使用 </p>
<p>拓展PE头最后一个字段是一个记录了所有表信息的结构体数组</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Directory Entries目录入口：结构体数组每个下标对应的含义</span></span><br><span class="line"><span class="comment">//虽然有16个表，但真正有用的就4个表，导出表，导入表，资源表，重定位表</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_EXPORT          0   <span class="comment">// Export Directory导出表</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_IMPORT          1   <span class="comment">// Import Directory导入表</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_RESOURCE        2   <span class="comment">// Resource Directory资源表</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   <span class="comment">// Exception Directory异常表</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_SECURITY        4   <span class="comment">// Security Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_BASERELOC       5   <span class="comment">// Base Relocation Table重定位表</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_DEBUG           6   <span class="comment">// Debug Directory</span></span></span><br><span class="line"><span class="comment">//      IMAGE_DIRECTORY_ENTRY_COPYRIGHT       7   // (X86 usage)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   <span class="comment">// Architecture Specific Data</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   <span class="comment">// RVA of GP</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_TLS             9   <span class="comment">// TLS Directory（dll入口之前执行，可用于反调试）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   <span class="comment">// Load Configuration Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   <span class="comment">// Bound Import Directory in headers</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_IAT            12   <span class="comment">// Import Address Table</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   <span class="comment">// Delay Load Import Descriptors</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   <span class="comment">// COM Runtime descriptor</span></span></span><br></pre></td></tr></table></figure>

<p>结构体IMAGE_DATA_DIRECTORY</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DATA_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD   VirtualAddress;<span class="comment">//表在哪里，记录的是RVA</span></span><br><span class="line">    DWORD   Size;<span class="comment">//表有多大(包含对应表结构中的所有连带结构占的空间),但只是个参考值</span></span><br><span class="line">&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;</span><br></pre></td></tr></table></figure>

<h2 id="导出表"><a href="#导出表" class="headerlink" title="导出表"></a>导出表</h2><p>将DataDirectory[0].VirtualAddress转换为FOA，则可以在对应文件中找到导出表</p>
<p>导出表结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//40字节</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_EXPORT_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD   Characteristics;<span class="comment">//未使用</span></span><br><span class="line">    DWORD   TimeDateStamp;<span class="comment">//时间戳(与标准PE头里的时间戳是一样的,记录当前dll什么时候生成的)</span></span><br><span class="line">    WORD    MajorVersion;<span class="comment">//未使用</span></span><br><span class="line">    WORD    MinorVersion;<span class="comment">//未使用</span></span><br><span class="line">    DWORD   Name;<span class="comment">//指向该导出表文件名字符串FOA，辅助信息，修改还能运行(重要)</span></span><br><span class="line">    DWORD   Base;<span class="comment">//导出函数起始序号（是在构建PE文件的时候写得导出表的那里面的序号）</span></span><br><span class="line">    DWORD   NumberOfFunctions;<span class="comment">//所有导出函数的个数</span></span><br><span class="line">    DWORD   NumberOfNames;<span class="comment">//以函数名字导出的函数个数</span></span><br><span class="line">    DWORD   AddressOfFunctions;     <span class="comment">//导出函数地址表RVA(存指向函数的指针)</span></span><br><span class="line">    DWORD   AddressOfNames;         <span class="comment">//导出函数名称表RVA（存指向函数名的指针，函数名遇0表示结束）</span></span><br><span class="line">    DWORD   AddressOfNameOrdinals;  <span class="comment">//导出函数序号表RVA（实际是下标）</span></span><br><span class="line">&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;</span><br></pre></td></tr></table></figure>

<p>举例导出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EXPORTS</span><br><span class="line">Plus  @12</span><br><span class="line">Sub	  @15 NONAME</span><br><span class="line">Mul   @13</span><br><span class="line">Div   @16</span><br></pre></td></tr></table></figure>

<p>上面导出文件对应的在PE文件中所有导出函数的个数NumberOfFunctions为5，以函数名字导出的函数个数NumberOfNames为3。</p>
<p>NumberOfFunctions为5是因为序号断档也会算进去，12,13,14,15,16刚好5个序号</p>
<h3 id="函数地址表"><a href="#函数地址表" class="headerlink" title="函数地址表"></a>函数地址表</h3><p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210607121906024.png" alt="image-20210607121906024"></p>
<h3 id="函数名称表"><a href="#函数名称表" class="headerlink" title="函数名称表"></a>函数名称表</h3><p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210607122444890.png" alt="image-20210607122444890"></p>
<p><strong>函数名称表是按照字母排序的</strong></p>
<h3 id="序号表"><a href="#序号表" class="headerlink" title="序号表"></a>序号表</h3><p><strong>序号表内项的个数取决于名字表里项的个数</strong>。</p>
<p><strong>序号表是两个字节为一个项的</strong></p>
<p><strong>序号表是为函数名称表找函数地址表服务的</strong></p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210607123144789.png" alt="image-20210607123144789"></p>
<p>里面的内容表示的是函数名称表中的项在函数地址表中的位置</p>
<blockquote>
<p><strong>【总结】重点</strong></p>
<p><strong>通过函数名称在函数名称表找到要找的函数在函数名称表中的下标，通过此下标在函数序号表中找到对应的值，该值表示要找函数在函数地址表中的下标。用此值在函数地址表中找到要找函数的地址。</strong></p>
</blockquote>
<h3 id="解读GetProcAddress函数"><a href="#解读GetProcAddress函数" class="headerlink" title="解读GetProcAddress函数"></a>解读GetProcAddress函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//功能是检索指定的动态链接库(DLL)中的输出库函数地址</span></span><br><span class="line"><span class="function">FARPROC <span class="title">GetProcAddress</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HMODULE hModule,<span class="comment">//DLL模块句柄（实际上就是当前的PE文件在内存中展开的起始位置）</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPCSTR lpProcName<span class="comment">//函数名（可以写函数名NULL结尾的字符串的指针，也可以写序号）如果此参数是一个序号，它必须在低字，高字必须为0。</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//返回值：</span></span><br><span class="line"><span class="comment">//如果函数调用成功，返回值是DLL中的输出函数地址。</span></span><br><span class="line"><span class="comment">//如果函数调用失败，返回值是NULL。得到进一步的错误信息，调用函数GetLastError。</span></span><br></pre></td></tr></table></figure>

<p><strong>原理</strong></p>
<ol>
<li>找名字的话原理就是到函数名称地址表找函数名，找到的话返回下标，用下标到序号表中找到对应的序号，用序号到函数地址表中取出函数地址返回</li>
<li>找序号的话原理就是先找到Base字段，确定起始序号，然后找多少序号，就在起始序号上偏移多少序号（要找的序号-起始序号=函数地址表要找的下标），也就用这个在函数地址表找到函数地址</li>
</ol>
<h2 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h2><p>一个进程是由一组PE文件构成的：</p>
<p>PE文件提供哪些功能：导出表</p>
<p>PE文件需要依赖哪些模块以及依赖这些模块中的哪些函数：导入表</p>
<p>导出表只有一个，导入表有一堆，所以_IMAGE_DATA_DIRECTORY的VirtualAddress存的是导入结构的数组（判断到末尾的依据是读到20个字节的0表示到头了）</p>
<p>导入表是拓展pe头最后一个字段的第2个结构体存了导入表对应的位置（指向的是导入表的第一个结构体），和对应的大小。</p>
<p>导入表（结构体数组）的单个结构体结构：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//共占20个字节，每个该结构体描述一个导入的PE文件</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        DWORD   Characteristics;            <span class="comment">// 0 for terminating null import descriptor</span></span><br><span class="line">        DWORD   OriginalFirstThunk;         <span class="comment">// RVA to original unbound IAT (PIMAGE_THUNK_DATA)  RVA，指向IMAGE_THUNK_DATA结构数组</span></span><br><span class="line">    &#125;;</span><br><span class="line">    DWORD   TimeDateStamp;                  <span class="comment">// 0 if not bound,时间戳（无用）</span></span><br><span class="line">                                            <span class="comment">// -1 if bound, and real date\time stamp</span></span><br><span class="line">                                            <span class="comment">//     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)</span></span><br><span class="line">                                            <span class="comment">// O.W. date/time stamp of DLL bound to (Old BIND)</span></span><br><span class="line"></span><br><span class="line">    DWORD   ForwarderChain;                 <span class="comment">// -1 if no forwarders（无用）</span></span><br><span class="line">    DWORD   Name;<span class="comment">//RVA，指向DLL名字，该名字以0结尾</span></span><br><span class="line">    DWORD   FirstThunk;                     <span class="comment">// RVA to IAT (if bound this IAT has actual addresses)     RVA，指向IMAGE_THUNK_DATA结构数组（在文件中和OriginalFirstThunk一样，但在内存中不一样指向的内容不一样）</span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br><span class="line"><span class="comment">//typedef IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;</span></span><br></pre></td></tr></table></figure>

<h3 id="导入表：确定依赖的函数"><a href="#导入表：确定依赖的函数" class="headerlink" title="导入表：确定依赖的函数"></a>导入表：确定依赖的函数</h3><p>下图是PE文件加载到内存前在文件中的结构</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210607132251965.png" alt="image-20210607132251965"></p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210708142928288.png" alt="image-20210708142928288"></p>
<ul>
<li>INT：import name table导入名称表</li>
<li>IAT：import address table导入地址表</li>
</ul>
<p>FirstThunk和OriginalFirstThunk<strong>在文件中</strong>都指向同样的_IMAGE_THUNK_DATA32数组，在文件中都指向内容为INT</p>
<p>INT和IAT中有多少个项表明该PE文件有多少个导入函数（4个字节的0表示结束符）</p>
<p>如图INT和IAT中的项结构是IMAGE_THUNK_DATA</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该结构体只占4个字节,每个该结构体描述一个函数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_THUNK_DATA32</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        PBYTE  ForwarderString;<span class="comment">//无用</span></span><br><span class="line">        PDWORD Function;<span class="comment">//无用</span></span><br><span class="line">        DWORD Ordinal;<span class="comment">//序号</span></span><br><span class="line">        PIMAGE_IMPORT_BY_NAME  AddressOfData;<span class="comment">//指向IMAGE_IMPORT_BY_NAME</span></span><br><span class="line">    &#125; u1;</span><br><span class="line">&#125; IMAGE_THUNK_DATA32;</span><br><span class="line"><span class="comment">//64位</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_THUNK_DATA64</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        ULONGLONG ForwarderString;  <span class="comment">// PBYTE </span></span><br><span class="line">        ULONGLONG Function;         <span class="comment">// PDWORD</span></span><br><span class="line">        ULONGLONG Ordinal;</span><br><span class="line">        ULONGLONG AddressOfData;    <span class="comment">// PIMAGE_IMPORT_BY_NAME</span></span><br><span class="line">    &#125; u1;</span><br><span class="line">&#125; IMAGE_THUNK_DATA64;</span><br></pre></td></tr></table></figure>

<p>_IMAGE_THUNK_DATA32中内容的判断方式</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210607134402552.png" alt="image-20210607134402552"></p>
<ol>
<li>判断最高位是否1，若是，那么除去最高位的值就是函数的导出序号</li>
<li>若不是，那么这个值是一个RVA指向IMAGE_IMPORT_BY_NAME</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_BY_NAME</span> &#123;</span></span><br><span class="line">    WORD    Hint;<span class="comment">//可能为空，编译器决定；若不为空，则是函数在导出表中的索引（注意不是导出序号）</span></span><br><span class="line">    BYTE    Name[<span class="number">1</span>];<span class="comment">//函数名称，以0结尾（只留第一个名字的第一个字符，因为名称长度并不确定，只是作为一个结构体中这个字段调用的接口）</span></span><br><span class="line">&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;</span><br></pre></td></tr></table></figure>

<h3 id="导入表：确定函数地址"><a href="#导入表：确定函数地址" class="headerlink" title="导入表：确定函数地址"></a>导入表：确定函数地址</h3><p>当我们的程序调用了一个别的dll中的函数，编译器就会在我们程序的导入表中生成一个相关的结构。</p>
<p>这些结构的最终目的都是为了程序在运行的时候能得到函数的内存地址。</p>
<p>下面的call是一个间接call，只要我们用的是其他dll中的函数，那么我们这个call生成的都是这种间接call</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210607140823333.png" alt="image-20210607140823333"></p>
<p>这个call的地址指向的内容是</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210607141338756.png" alt="image-20210607141338756"></p>
<p>直接指向的是函数地址</p>
<p><strong>这是因为PE文件在加载到内存后，导入表的结构会发生变化</strong></p>
<p>在文件中：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/20131007225555312.jpg" alt="20131007225555312"></p>
<p>加载到内存后：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/20131007225859203.jpg" alt="20131007225859203"></p>
<p>此时FirstThunk指向的不再是OriginalFirstThunk指向的结构</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210607141808212.png" alt="image-20210607141808212"></p>
<p>FirstThunk而是指向直接的函数地址（IAT）。加载到内存的时候，由操作系统根据函数名称或导出表中的索引到对应dll的导出表去找内存地址填入FirstThunk指向的数组</p>
<p>脱壳的时候修复导入表就是利用OrignalFirstThunk指向的最终的函数名称获取到函数内存地址，去修复firstThunk指向的IAT</p>
<h2 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h2><p>举个例子，未初始化的全局变量的虚拟地址不是RVA，而是以固定的虚拟地址写死在汇编中（如下图，x是未初始化的全局变量）。所以在加载到内存中之后如果不是加载到对应的PE文件的imageBase的话会出问题。（xp系统以后都是动态加载,原因就是因为有重定位表）</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210607151337405.png" alt="image-20210607151337405"></p>
<p>所以重定位表就是为了解决这个问题的</p>
<p><strong>重定位表</strong>：一张记录了<code>所有要修改的地址</code>的地址表</p>
<p>数据目录项的第6个结构，就是重定位表</p>
<p>重定位表是一堆重定位块结构体数组</p>
<p>每个重定位块的结构体：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实际上是一个物理页（4KB）创建一个重定位块</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_BASE_RELOCATION</span> &#123;</span></span><br><span class="line">    DWORD   VirtualAddress;<span class="comment">//重定位块公用地址（为了减少储存重定位块的空间）,RVA</span></span><br><span class="line">    DWORD   SizeOfBlock;<span class="comment">//重定位块大小，字节为单位</span></span><br><span class="line"><span class="comment">//  WORD    TypeOffset[1];//后面直接接当前重定位块，若干个大小为两个字节的元素</span></span><br><span class="line">&#125; IMAGE_BASE_RELOCATION;</span><br></pre></td></tr></table></figure>

<p>下图一个格子表示一个字节，X为VirtualAddress，Y为SizeOfBlock</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210607163327446.png" alt="image-20210607163327446"></p>
<p>重定位表到连续8个字节为0表示到头了（也就是VirtualAddress和SizeOfBlock都为0表示到头了）。</p>
<p><strong>IMAGE_BASE_RELOCATION结构和后面紧跟的若干个Typeoffset组成了一个块，其大小为结构体中的SizeOfBlock</strong></p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210607164617022.png" alt="image-20210607164617022"></p>
<p>重定位块是按照上图红色部分这样两个字节存一个要修改的地址</p>
<p>因为每个重定位块的VirtualAddress是按照物理页一页（0x1000字节）来分的，所以内部的红色部分实际上真正使用的只需要12位（0xFFF）就能索引到物理页任何一个地址，因此高4位挪作他用。</p>
<p><strong>只有高4位为3的时候，才表明这个数据块内的这个地址是需要被重定位的</strong>，不是3表示这里面的值不需要重定位，实际上就是因为这个值只是用来内存对齐用于填位置用的，里面的值是没意义的所以不需要重定位</p>
<p><strong>所以真正重定位针对的地址是：VirtualAddress（图中X）+红色部分组成的地址的低12位。</strong></p>
<p>找到需要重定位的地点之后，怎么重定位呢？前文说到Typeoffset指示了多种重定位类型，其中最常见的为3，在此只介绍这种情况。其他重定位类型的主体思想基本是相似的，只有细微的不同。</p>
<p> 我们首先计算得到基地址的偏移量，也就是实际的DLL加载地址减去DLL的推荐加载地址。<strong>DLL推荐加载地址保存在拓展PE头中的ImageBase成员中，而实际DLL加载地址并不一定在那位置上。然后我们将VirtualAddress和Typeoffset低12位合力组成的地址所指向的双字加上这个偏移量，重定位就完成了。</strong><br>$$<br><em>(DWORD</em>)(VirtualAddress + Typeoffset的低12位) += （实际DLL加载地址 – 推荐DLL加载地址）<br>$$</p>
<h1 id="简单加密壳编写"><a href="#简单加密壳编写" class="headerlink" title="简单加密壳编写"></a>简单加密壳编写</h1><h1 id="手动映射DLL"><a href="#手动映射DLL" class="headerlink" title="手动映射DLL"></a><a target="_blank" rel="noopener" href="https://bbs.ichunqiu.com/thread-40593-1-1.html">手动映射DLL</a></h1><p>exe编译出的debug版是带重定位表的，浮动基址的exe都带有重定位表</p>
<p>将一个DLL贴入内存中，使其可以使用，需要下面三步</p>
<ol>
<li>手动将文件拉伸对齐后写入内存</li>
<li>修改IAT表</li>
<li>根据重定位表修正内存中基址相关数据 </li>
<li>调用DLL入口点（入口点可以通过拓展PE头中的AddressOfEntryPoint找到。一般地，它会完成C运行库的初始化，执行一系列安全检查并调用dllmain。）</li>
</ol>
<p>文件一旦“落地”就也存在着被杀毒软件查杀的风险，因此可以以加密的方式存储到硬盘上。</p>
<p><strong>为什么要修改IAT表和重定位表？</strong></p>
<ol>
<li>程序可以在不重建导入表的情况下工作，但前提是您不使用任何导入的函数。尝试访问尚未解析的导入代码将失败；</li>
<li>为简单起见，PE 可执行文件是位置无关的（可以在任何基地址上工作），即使代码不是。为此，该文件包含一个重定位表，用于调整依赖于基地址位置的所有数据。如果可以在首选地址（<code>pINH-&gt;OptionalHeader.ImageBase</code>）加载，这点是可选的，但这意味着如果使用重定位表，则可以在任何地方加载图像，并且可以省略的第一个参数<code>VirtualAlloc</code>（并删除相关检查）。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://www.one-tab.com/page/OOKOc7rnQG-ong09H6nEfw">这两个练习并未完成，网页思考</a></p>
<h2 id="重载内核练习"><a href="#重载内核练习" class="headerlink" title="重载内核练习"></a>重载内核练习</h2><p>内核文件本身就是一个exe文件，实际上<strong>内核重载</strong>就是内核可执行程序在<strong>零环</strong>内存中的文件展开          </p>
<ol>
<li>手动将文件拉伸对齐后写入内存</li>
<li>修改IAT表</li>
<li>根据重定位表修正内存中基址相关数据  </li>
<li>修改新内核系统服务表（老SSDT函数地址-老内核基址+新内核基址=新SSDT函数地址）</li>
<li>HOOK KiFastCallEntry(HOOK原内核的KiFastCallEntry,如果是目标进程则将跳转改为新内核的系统服务表。)</li>
</ol>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20211125115210958.png" alt="image-20211125115210958"></p>
<p>重载内核的<strong>弊端</strong>：太容易被发现了，随便搜一个内核函数的特征码都能搜索出来两份。</p>
<p>可以尝试加密内核函数，走HOOK的时候才解密</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/blog/tags/PE/" rel="tag"># PE</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/blog/2022/03/26/FPS%E9%80%86%E5%90%91%E9%9A%8F%E7%AC%94/" rel="prev" title="FPS逆向">
      <i class="fa fa-chevron-left"></i> FPS逆向
    </a></div>
      <div class="post-nav-item">
    <a href="/blog/2022/03/26/QT/" rel="next" title="QT入门">
      QT入门 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6"><span class="nav-number">1.</span> <span class="nav-text">什么是可执行文件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%AF%86%E5%88%ABPE%E6%96%87%E4%BB%B6"><span class="nav-number">1.1.</span> <span class="nav-text">如何识别PE文件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">2.</span> <span class="nav-text">主要结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#DOS%E9%83%A8%E5%88%86"><span class="nav-number">2.1.</span> <span class="nav-text">DOS部分</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#IMAGE-DOS-HEADER%E7%BB%93%E6%9E%84%EF%BC%9A"><span class="nav-number">2.1.1.</span> <span class="nav-text">IMAGE_DOS_HEADER结构：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DOS-Stub%EF%BC%88DOS%E5%9D%97%EF%BC%89"><span class="nav-number">2.1.2.</span> <span class="nav-text">DOS Stub（DOS块）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PE%E6%96%87%E4%BB%B6%E5%A4%B4"><span class="nav-number">2.2.</span> <span class="nav-text">PE文件头</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E5%87%86PE%E5%A4%B4"><span class="nav-number">2.2.1.</span> <span class="nav-text">标准PE头</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%93%E5%B1%95PE%E5%A4%B4"><span class="nav-number">2.2.2.</span> <span class="nav-text">拓展PE头</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8A%82%E8%A1%A8"><span class="nav-number">2.3.</span> <span class="nav-text">节表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8A%82%E6%95%B0%E6%8D%AE"><span class="nav-number">2.4.</span> <span class="nav-text">节数据</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#PE%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="nav-number">3.</span> <span class="nav-text">PE文件的两种状态</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#RVA%E5%88%B0FOA%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-number">3.1.</span> <span class="nav-text">RVA到FOA的转换</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#PE%E7%9A%84%E7%A9%BA%E7%99%BD%E5%8C%BA%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%A0%81"><span class="nav-number">4.</span> <span class="nav-text">PE的空白区添加代码</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A9%E5%A4%A7%E8%8A%82"><span class="nav-number">4.1.</span> <span class="nav-text">扩大节</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B0%E5%A2%9E%E8%8A%82"><span class="nav-number">4.2.</span> <span class="nav-text">新增节</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E8%8A%82"><span class="nav-number">4.3.</span> <span class="nav-text">合并节</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E6%AD%A3%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90"><span class="nav-number">4.3.1.</span> <span class="nav-text">修正内存对齐</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E8%8A%82%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E5%90%8E%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="nav-number">4.3.1.1.</span> <span class="nav-text">计算节内存对齐后的大小</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E5%B7%AE%E5%80%BC"><span class="nav-number">4.3.1.2.</span> <span class="nav-text">计算差值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E8%8A%82%E5%9C%A8%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%9C%AB%E5%B0%BE%E4%BD%8D%E7%BD%AE"><span class="nav-number">4.3.1.3.</span> <span class="nav-text">计算节在文件中的末尾位置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A1%AB%E5%85%85%E6%96%B0%E7%A9%BA%E9%97%B4"><span class="nav-number">4.3.1.4.</span> <span class="nav-text">填充新空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%AE%E6%AD%A3%E8%8A%82%E6%88%90%E5%91%98"><span class="nav-number">4.3.1.5.</span> <span class="nav-text">修正节成员</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%AE%E6%AD%A3%E5%90%8E%E9%9D%A2%E7%9A%84%E8%8A%82"><span class="nav-number">4.3.1.6.</span> <span class="nav-text">修正后面的节</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A1%A8"><span class="nav-number">5.</span> <span class="nav-text">表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%BC%E5%87%BA%E8%A1%A8"><span class="nav-number">5.1.</span> <span class="nav-text">导出表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%9C%B0%E5%9D%80%E8%A1%A8"><span class="nav-number">5.1.1.</span> <span class="nav-text">函数地址表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%90%8D%E7%A7%B0%E8%A1%A8"><span class="nav-number">5.1.2.</span> <span class="nav-text">函数名称表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%8F%E5%8F%B7%E8%A1%A8"><span class="nav-number">5.1.3.</span> <span class="nav-text">序号表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E8%AF%BBGetProcAddress%E5%87%BD%E6%95%B0"><span class="nav-number">5.1.4.</span> <span class="nav-text">解读GetProcAddress函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%BC%E5%85%A5%E8%A1%A8"><span class="nav-number">5.2.</span> <span class="nav-text">导入表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%BC%E5%85%A5%E8%A1%A8%EF%BC%9A%E7%A1%AE%E5%AE%9A%E4%BE%9D%E8%B5%96%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">5.2.1.</span> <span class="nav-text">导入表：确定依赖的函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%BC%E5%85%A5%E8%A1%A8%EF%BC%9A%E7%A1%AE%E5%AE%9A%E5%87%BD%E6%95%B0%E5%9C%B0%E5%9D%80"><span class="nav-number">5.2.2.</span> <span class="nav-text">导入表：确定函数地址</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8"><span class="nav-number">5.3.</span> <span class="nav-text">重定位表</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E5%8A%A0%E5%AF%86%E5%A3%B3%E7%BC%96%E5%86%99"><span class="nav-number">6.</span> <span class="nav-text">简单加密壳编写</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%89%8B%E5%8A%A8%E6%98%A0%E5%B0%84DLL"><span class="nav-number">7.</span> <span class="nav-text">手动映射DLL</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E5%86%85%E6%A0%B8%E7%BB%83%E4%B9%A0"><span class="nav-number">7.1.</span> <span class="nav-text">重载内核练习</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ZEROKO14</p>
  <div class="site-description" itemprop="description">你好，欢迎来到ZEROKO14的个人博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">24</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZEROKO14</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>-->

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/muse.js"></script>


<script src="/blog/js/next-boot.js"></script>


  <script defer src="/blog/lib/three/three.min.js"></script>
    <script defer src="/blog/lib/three/three-waves.min.js"></script>


  















  

  

</body>
</html>
