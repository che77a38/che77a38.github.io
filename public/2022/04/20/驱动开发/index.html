<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zeroko14.gitee.io","root":"/blog/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="驱动开发理解  SDK   software development kits(软件开发包)   如Visual Studio 2019(v142) WDK  windows driver development kits(驱动开发包)  如WindowsKernelModeDriver10.0">
<meta property="og:type" content="article">
<meta property="og:title" content="驱动开发">
<meta property="og:url" content="http://zeroko14.gitee.io/blog/2022/04/20/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/index.html">
<meta property="og:site_name" content="ZEROKO14的个人博客">
<meta property="og:description" content="驱动开发理解  SDK   software development kits(软件开发包)   如Visual Studio 2019(v142) WDK  windows driver development kits(驱动开发包)  如WindowsKernelModeDriver10.0">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202205161418079.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202205161420348.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202205161420283.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202205171721503.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210825204301335.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210825204450485.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210825212547927.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20211109133128464.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210826200052881.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210826200052881.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210828154104796.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210828154124934.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210828154334924.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210827111116147.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210829163134914.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/sdsad.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210827114410752.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202204241910209.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210829212010210.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210829212159461.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210830211435935.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202205291945467.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202205041101739.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202205041103204.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202205041105434.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202205292047586.jpeg">
<meta property="article:published_time" content="2022-04-20T02:54:07.214Z">
<meta property="article:modified_time" content="2022-07-21T06:45:42.280Z">
<meta property="article:author" content="ZEROKO14">
<meta property="article:tag" content="内核相关">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202205161418079.jpeg">

<link rel="canonical" href="http://zeroko14.gitee.io/blog/2022/04/20/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>驱动开发 | ZEROKO14的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ZEROKO14的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">zeroko14's blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zeroko14.gitee.io/blog/2022/04/20/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="ZEROKO14">
      <meta itemprop="description" content="你好，欢迎来到ZEROKO14的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZEROKO14的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          驱动开发
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-20 10:54:07" itemprop="dateCreated datePublished" datetime="2022-04-20T10:54:07+08:00">2022-04-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-21 14:45:42" itemprop="dateModified" datetime="2022-07-21T14:45:42+08:00">2022-07-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="驱动开发"><a href="#驱动开发" class="headerlink" title="驱动开发"></a>驱动开发</h1><p><strong>理解</strong></p>
<ul>
<li>SDK   software development kits(软件开发包)   如Visual Studio 2019(v142)</li>
<li>WDK  windows driver development kits(驱动开发包)  如WindowsKernelModeDriver10.0</li>
</ul>
<span id="more"></span>

<p>设置他们的位置在属性-配置属性-常规-平台工具集,但实际上无需手动设置,因为新建什么项目时vs都帮你自动配置好了</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/newnewman80/article/details/90754999">环境配置参考</a></p>
<p>创建<strong>Empty WDM Driver</strong>项目，生成的Driver Files文件中的<strong>inf后缀文件</strong>可以直接删除</p>
<p>在源文件中添加的必须是.c后缀的C语言文件。</p>
<p>项目配置中：</p>
<ol>
<li>属性-C/C++中<code>将警告视为错误</code>选项设置为否</li>
<li>属性-链接器中<code>将链接器警告视为错误</code>设为否</li>
</ol>
<p>由于使用的是windowsXP作为开发环境，所以要<strong>针对windowsXP进行项目配置，参考链接</strong>：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Kwansy/article/details/111051265">开发各平台驱动的设置参考</a></p>
<p>如果建立的是KMDF项目的话,除了上述步骤,还可以将属性-Inf2Cat中<code>Run Inf2Cat</code>选项设置为否</p>
<p><strong>制作不同系统的驱动,要设置属性-Driver Settings-Target OS Version设置为对应操作系统</strong></p>
<p>属性-Driver Settings-Target Platform设置为Desktop</p>
<p><strong>驱动的开发流程：</strong></p>
<p>编写代码-&gt;生成.sys文件-&gt;部署-&gt;启动-&gt;停止-&gt;卸载</p>
<p>驱动程序的测试最好在<strong>虚拟机中</strong>测试，因为一出问题就蓝屏</p>
<p><strong>DebugView</strong>软件监视选项中要选上<strong>监视核心</strong></p>
<p>驱动开发的调试：双机调试</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//操作系统调试驱动需要打开测试模式</span></span><br><span class="line">bcdedit /<span class="built_in">set</span> nointegritychecks on<span class="comment">//关闭驱动数字证书检测</span></span><br><span class="line">bcdedit /<span class="built_in">set</span> testsigning on<span class="comment">//打开测试模式</span></span><br><span class="line">pause</span><br><span class="line">shutdown -r -t <span class="number">1000</span><span class="comment">//一秒之后重启系统</span></span><br></pre></td></tr></table></figure>

<p>无论是debug还是release版本的驱动都会带一个测试的签名,测试的签名 只在测试模式下有效.非测试模式下等于没有签名无法加载驱动.</p>
<p>虚拟机设置(防止待机过长屏幕自动关闭时虚拟机出现问题)</p>
<p>右键-显示设置-电源和随眠-屏幕定时关闭调成从不</p>
<h3 id="设置双机调试步骤"><a href="#设置双机调试步骤" class="headerlink" title="设置双机调试步骤"></a>设置双机调试步骤</h3><p>虚拟机设置中添加串行端口</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202205161418079.jpeg" alt="xvniji2"></p>
<p><strong>红色线虽然显示是串行端口2,但实际上由于当前只有一个串行端口,所以在虚拟机系统中设置的引导的调试端口应该是com1</strong></p>
<p>然后如下,到操作系统中添加调试引导项</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//操作系统打开双机调试模式</span></span><br><span class="line"><span class="comment">//操作系统添加新引导(管理员启动)</span></span><br><span class="line">bcdedit /copy &#123;current&#125; /d <span class="string">&quot;win10 x64 debug for windbg&quot;</span><span class="comment">//新建引导选项,新引导的名字随意取</span></span><br><span class="line">pause</span><br><span class="line"><span class="comment">//手动到运行(win+r)输入msconfig回车-选到新建的引导-高级选项-打开调试模式,设置调试端口为多少(可以到虚拟机中设别管理器的串行端口查看,不要受com几的名字影响,顺序是第几个就是com几)</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202205161420348.jpeg" alt="xvniji3"></p>
<h3 id="设置windbg连接哪个串口"><a href="#设置windbg连接哪个串口" class="headerlink" title="设置windbg连接哪个串口"></a>设置windbg连接哪个串口</h3><p>两种方式,1.图形化操作(下面主要介绍的是这种方式)    2.快捷方式设置参数 <code>-b -k com:pipe,port=\\.\pipe\管道名,resets=0,reconnect -y</code></p>
<p>windbg打开后,点击File-Kernel Debug,打开的窗口中选择COM,Port设置为虚拟机中给串行端口设置的命名管道名字,并且勾选Pipe(表示是命名管道)和Reconnect</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202205161420283.jpeg" alt="xvniji1"></p>
<h3 id="设置符号"><a href="#设置符号" class="headerlink" title="设置符号"></a>设置符号</h3><p>设置添加系统环境变量_NT_SYMBOL_PATH的值为: <code>srv*c:\symbols*http://msdl.microsoft.com/download/symbols</code></p>
<p>强制加载符号命令: <code>.reload /f</code>               使用 <code>lm</code>可以看到已加载的符号信息</p>
<h3 id="windbg调试蓝屏dump文件"><a href="#windbg调试蓝屏dump文件" class="headerlink" title="windbg调试蓝屏dump文件"></a>windbg调试蓝屏dump文件</h3><p>windbg可用于查看蓝屏的dump文件,dump文件默认位置在 <code>C:\\Windows\Minidump\</code>中</p>
<p>在windbg中选择File-Open source file打开蓝屏的dump文件</p>
<p>分析命令: <code>!analyze -v</code> (该命令可以看到蓝屏的时候的调用栈)               查看堆栈命令: <code>kv</code></p>
<p>往往是通过调用栈查看问题出在哪里</p>
<h4 id="操作系统设置dump文件生成步骤"><a href="#操作系统设置dump文件生成步骤" class="headerlink" title="操作系统设置dump文件生成步骤"></a>操作系统设置dump文件生成步骤</h4><p>此电脑右键属性-高级系统设置-启动和故障恢复处的设置按钮,在该界面做如下修改</p>
<ul>
<li>勾选 <code>将事件写入系统日志</code></li>
<li>[写入调试信息] 设置为 <code>核心内存转储</code></li>
<li>此处也可以设置转储文件的保存位置</li>
</ul>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202205171721503.jpeg" alt="dump"></p>
<p>补充</p>
<p>p.s.修复虚拟机花屏:vmtool重新安装,选择修改,去除SVGA驱动(核显驱动),然后重新在虚拟机中安装显卡驱动.</p>
<h2 id="PDB（Program-Debug-Database）"><a href="#PDB（Program-Debug-Database）" class="headerlink" title="PDB（Program Debug Database）"></a>PDB（Program Debug Database）</h2><p>什么是PDB文件？</p>
<ol>
<li>PDB文件是在我们编译工程的时候产生的，它是和对应的模块(exe或dll)一起生成出来的。</li>
<li>每个模块编译的时候都可以生成自己的PDB文件。比如.exe/.dll/.sys等等。</li>
</ol>
<p>PDB文件对应上了位置和函数名。</p>
<p><strong>windbg如何找到PDB文件？</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SRV*D:\Symbols\XP*http://msdl.microsoft.com/download/symbols</span><br><span class="line">;上面可以在后面添加;继续添加本地地址，比如SRV*D:\Symbols\XP*http://msdl.microsoft.com/download/symbols；D:\Symbols</span><br><span class="line">;D:\Symbols\XP是本地路径，</span><br><span class="line">;http://msdl.microsoft.com/download/symbols是网络路径</span><br><span class="line">kd&gt;.reload</span><br><span class="line">;让windbg重新加载PDB</span><br></pre></td></tr></table></figure>

<p><strong>MSB8040错误</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error MSB8040: 此项目需要缓解了 Spectre 漏洞的库。</span><br></pre></td></tr></table></figure>

<p>在属性-常规-输出目录-宏中搜索14：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210825204301335.png" alt="image-20210825204301335"></p>
<p>确定需要的是14.29版本</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210825204450485.png" alt="image-20210825204450485"></p>
<p>Visual Studio Installer的单个组件中搜索14.29，将黄标全部勾选，点击修改。问题解决！</p>
<h2 id="第一个驱动程序"><a href="#第一个驱动程序" class="headerlink" title="第一个驱动程序"></a>第一个驱动程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ntddk.h&gt;</span><span class="comment">//winXP驱动开发用此头文件</span></span></span><br><span class="line"><span class="comment">//#include &lt;ntifs.h&gt;//wdk开发(除了winXP的其他系统)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//卸载函数</span></span><br><span class="line"><span class="function">VOID <span class="title">DriverUnload</span><span class="params">(PDRIVER_OBJECT driver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DbgPrint(<span class="string">&quot;停止运行了\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入口函数，相当于main函数</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT pdriver, PUNICODE_STRING pReg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//驱动程序的入口</span></span><br><span class="line">	DbgPrint(<span class="string">&quot;hello world!\n&quot;</span>);</span><br><span class="line">	DbgPrint(<span class="string">&quot;pdriver:%wZ\r\n&quot;</span>,pReg);</span><br><span class="line">	DbgPrint(<span class="string">&quot;pReg:%X\r\n&quot;</span>,pdriver);</span><br><span class="line">	<span class="comment">//设置一个卸载函数，用于退出</span></span><br><span class="line">	pdriver-&gt;DriverUnload = DriverUnload;</span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210825212547927.png" alt="image-20210825212547927"></p>
<p>windbg中可以使用dt命令查看对应数据结构的数据</p>
<p>头文件</p>
<ul>
<li><code>#include &lt;ntddk.h&gt;</code>     winXP驱动开发用此头文件</li>
<li><code>#include &lt;ntifs.h&gt;</code>     wdk开发</li>
</ul>
<h3 id="头文件Wdm-h、Ntddk-h-和-Ntifs-h-的组织结构"><a href="#头文件Wdm-h、Ntddk-h-和-Ntifs-h-的组织结构" class="headerlink" title="头文件Wdm.h、Ntddk.h 和 Ntifs.h 的组织结构"></a>头文件Wdm.h、Ntddk.h 和 Ntifs.h 的组织结构</h3><p>在 Windows Vista 版本的 WDK 之前，用于驱动程序开发的主要头文件为 Wdm.h、Ntddk.h 和 Ntifs.h，它们包含很多重复声明。</p>
<p>从 Windows Vista 版本的 WDK 开始，Wdm.h、Ntddk.h 和 Ntifs.h 将按层次结构来组织并且不包含重复信息。上层的文件将包含下层的文件。每个函数和结构声明仅出现一次。</p>
<p><strong><code>Ntifs.h</code> 包含 <code>Ntddk.h</code>，而 <code>Ntddk.h</code> 又包含 <code>Wdm.h</code>。</strong></p>
<h2 id="内核编程基础"><a href="#内核编程基础" class="headerlink" title="内核编程基础"></a>内核编程基础</h2><h3 id="内核API的使用"><a href="#内核API的使用" class="headerlink" title="内核API的使用"></a>内核API的使用</h3><ol>
<li>在应用层编程我们可以使用WINDOWS提供的各种API函数，只要导入头文件&lt;windows.h&gt;就可以了，但是在内核编程的时候，我们不能像Ring3那样直接使用。微软为内核提供了专门的API，只要在程序中包含相应的头文件就可以使用了，如：#include&lt;ntddk.h&gt;(假设你已经正确安装了WDK)</li>
<li>在应用层编程的时候，我们通过MSDN来了解函数的详细信息，在内核编程的时候，要使用WDK自己的帮助文档。</li>
</ol>
<h3 id="未导出函数的使用"><a href="#未导出函数的使用" class="headerlink" title="未导出函数的使用"></a>未导出函数的使用</h3><p>内核函数有三种</p>
<ol>
<li>有一些是文档有写，也导出了的函数</li>
<li>有一些是文档没写，但导出了的函数</li>
<li>还有一些是文档没写，也没导出的函数，通过自己特征码定位CALL的位置，手动调用</li>
</ol>
<p>WDK说明文档只包含了内核模块导出的函数，对于未导出的函数，则不能直接使用</p>
<p>如果要使用未导出的函数，只要自己定义一个函数指针，并且为函数指针提供正确的函数地址就可以使用了。有两种办法都可以获取为导出的函数地址：</p>
<ol>
<li>特征码搜索</li>
<li>解析内核PDB文件</li>
</ol>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>在内核编程的时候，强烈建议大家遵守WDK的编码习惯，不要这么写：unsigned long length；</p>
<p>习惯使用WDK自己的类型：</p>
<table>
<thead>
<tr>
<th>WDK的类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ULONG</td>
<td>unsigned long</td>
</tr>
<tr>
<td>PULONG</td>
<td>unsigned long*</td>
</tr>
<tr>
<td>UCHAR</td>
<td>unsigned char</td>
</tr>
<tr>
<td>PUCHAR</td>
<td>unsigned char*</td>
</tr>
<tr>
<td>UINT</td>
<td>unsigned int</td>
</tr>
<tr>
<td>PUNIT</td>
<td>unsigned int*</td>
</tr>
<tr>
<td>VOID</td>
<td>void</td>
</tr>
<tr>
<td>PVOID</td>
<td>void*</td>
</tr>
</tbody></table>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>大部分内核函数的返回值都是NTSTATUS类型，如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">PsCreateSystemThread</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">NTSTATUS <span class="title">ZwOpenProcess</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">NTSTATUS <span class="title">ZwOpenEvent</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个值能说明函数执行的结果，比如：</p>
<table>
<thead>
<tr>
<th>返回宏</th>
<th>代表数值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>STATUS_SUCCESS</td>
<td>0x00000000</td>
<td>成功</td>
</tr>
<tr>
<td>STATUS_INVALID_PARAMETER</td>
<td>0xC000000D</td>
<td>参数无效(这个错误出现往往代表出现了很多错误，因此不代表任何意义)</td>
</tr>
<tr>
<td>STATUS_BUFFER_OVERFLOW</td>
<td>0x80000005</td>
<td>缓冲区长度不够</td>
</tr>
<tr>
<td>STATUS_PENDING</td>
<td></td>
<td>不能算作一个错误，只是文件传输请求未决(异步)</td>
</tr>
<tr>
<td>STATUS_INSUFFICIENT_RESOURCES</td>
<td></td>
<td>资源调用错误</td>
</tr>
</tbody></table>
<p>当你调用的内核函数，如果返回的结果不是STATUS_SUCCESS，就说明函数执行中遇到了问题，具体是什么问题，可以在ntstatus.h文件中查看。</p>
<h3 id="内核函数中的异常处理"><a href="#内核函数中的异常处理" class="headerlink" title="内核函数中的异常处理"></a>内核函数中的异常处理</h3><p><strong>意义不大，该蓝屏还是蓝屏</strong></p>
<p>在内核中，一个小小的错误就可能导致蓝屏，比如：读写一个无效的内存地址。为了让自己的内核程序更加健壮，强烈建议大家在编写内核程序时，使用异常处。</p>
<p>Windows提供了机构化异常处理机制，一般的编译器都是支持的，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__try&#123;</span><br><span class="line">    <span class="comment">//可能出错的代码</span></span><br><span class="line">&#125;</span><br><span class="line">__except(filter_value)&#123;</span><br><span class="line">    <span class="comment">//出错时要执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>出现异常时，可根据filter_value的值来决定程序该如何执行，当filter_value的值为：</p>
<table>
<thead>
<tr>
<th>filter_value</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>EXCEPTION_EXECUTE_HANDLER(1)</td>
<td>代码进入except块</td>
</tr>
<tr>
<td>EXCEPTION_CONTINUE_SEARCH(0)</td>
<td>不处理异常，由上一层调用函数处理</td>
</tr>
<tr>
<td>EXCEPTION_CONTINUE_EXECUTION(-1)</td>
<td>回去继续执行错误处的代码(基本用不到)</td>
</tr>
</tbody></table>
<h3 id="常用的内核内存函数"><a href="#常用的内核内存函数" class="headerlink" title="常用的内核内存函数"></a>常用的内核内存函数</h3><p>对内核的使用，主要就是：申请，设置，拷贝以及释放。</p>
<table>
<thead>
<tr>
<th>C语言</th>
<th>内核中</th>
</tr>
</thead>
<tbody><tr>
<td>malloc</td>
<td>ExAllocatePool</td>
</tr>
<tr>
<td>memset(内核可用)</td>
<td>RtlFillMemory</td>
</tr>
<tr>
<td>memcpy(内核可用)(非重叠复制)</td>
<td>RtlCopyMemory(非重叠复制)</td>
</tr>
<tr>
<td>memmove(内核可用)(重叠复制)</td>
<td>RtlMoveMemory(重叠复制)</td>
</tr>
<tr>
<td>free</td>
<td>ExFreePool</td>
</tr>
</tbody></table>
<p>ExAllocatePool已被淘汰，取而代之的是<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/nf-wdm-exallocatepoolwithtag">ExAllocatePoolWithTag</a></p>
<p>后又在 Windows 10 版本 2004 中被弃用，并已被<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/nf-wdm-exallocatepool2">ExAllocatePool2</a>取代</p>
<h3 id="内核字符串种类"><a href="#内核字符串种类" class="headerlink" title="内核字符串种类"></a>内核字符串种类</h3><ul>
<li>CHAR（char）</li>
<li>WCHAR（wchar_t）</li>
<li>ANSI_STRING</li>
<li>UNICODE_STRING</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ANSI_STRING字符串：</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">STRING</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    USHORT Length;<span class="comment">//当前字符串的长度</span></span><br><span class="line">    USHORT MaximumLength;<span class="comment">//最大长度</span></span><br><span class="line">    PCHAR Buffer;<span class="comment">//指针</span></span><br><span class="line">&#125;STRING;</span><br><span class="line"></span><br><span class="line"><span class="comment">//UNICODE_STRING字符串：</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    USHORT Length;</span><br><span class="line">    USHORT MaximumLength;</span><br><span class="line">    PWCHAR Buffer;</span><br><span class="line">&#125;UNICODE_STRING;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">UNICODE_STRING abc=RTL_CONSTANT_STRING(<span class="string">L&quot;Hello World!&quot;</span>);<span class="comment">//要放在全局</span></span><br><span class="line">DbgPrint(<span class="string">&quot;%wZ&quot;</span>,&amp;abc);</span><br></pre></td></tr></table></figure>

<p>内核中字符串尽量用ANSI_STRING字符串和UNICODE_STRING字符串，通过这种方法能避免使用0结尾，读字符串的时候读Length个字符就可以了，防止访问0蓝屏。</p>
<p>内核字符串常用函数</p>
<table>
<thead>
<tr>
<th>ANSI_STRING字符串</th>
<th>UNICODE_STRING字符串</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>RtlInitAnsiString</td>
<td>RtlInitUnicodeString</td>
<td>创建字符串</td>
</tr>
<tr>
<td>RtlCopyString</td>
<td>RtlCopyUnicodeString</td>
<td>复制字符串</td>
</tr>
<tr>
<td>RtlCpmpareString</td>
<td>RtlCpmpareUnicodeString</td>
<td>比较字符串</td>
</tr>
<tr>
<td>RtlAnsiStringToUnicodeString</td>
<td>RtlUnicodeStringToAnsiString</td>
<td>字符串转换</td>
</tr>
<tr>
<td>RtlAppendStringToString</td>
<td>RtlAppendUnicodeToString/RtlAppendUnicodeStringToString</td>
<td>字符串拼接</td>
</tr>
<tr>
<td>RtlFreeAnsiString</td>
<td>RtlFreeUnicodeString</td>
<td>销毁字符串</td>
</tr>
<tr>
<td>RtlUpperString</td>
<td>RtlUpcaseUnicodeString</td>
<td>转换成大写</td>
</tr>
<tr>
<td>RtlEqualString</td>
<td>RtlEqualUnicodeString</td>
<td>字符串是否相等</td>
</tr>
</tbody></table>
<p>DbgPrint,KdPrint打印字符串：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>格式说明符</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>%c, %lc</td>
<td>ANSI字符</td>
<td>char</td>
</tr>
<tr>
<td>%C, %wc</td>
<td>宽字符</td>
<td>wchar_t</td>
</tr>
<tr>
<td>%d, %i</td>
<td>十进制有符号整数</td>
<td>int</td>
</tr>
<tr>
<td>%D</td>
<td>十进制_int64</td>
<td>_int64</td>
</tr>
<tr>
<td>%L</td>
<td>十六进制的LARGE_INTEGER</td>
<td>LARGE_INTEGER</td>
</tr>
<tr>
<td>%s, %ls</td>
<td>NULL终止的ANSI字符串</td>
<td>char*</td>
</tr>
<tr>
<td>%S, %ws</td>
<td>NULL终止的宽字符串</td>
<td>wchar_t*</td>
</tr>
<tr>
<td>%Z</td>
<td>ANSI_STRING字符串</td>
<td></td>
</tr>
<tr>
<td>%wZ</td>
<td>UNICODE_STRING字符串</td>
<td></td>
</tr>
<tr>
<td>%u</td>
<td>十进制的ULONG</td>
<td>ULONG</td>
</tr>
<tr>
<td>%x</td>
<td>小写字符十六进制的ULONG</td>
<td>ULONG</td>
</tr>
<tr>
<td>%X</td>
<td>大写字符十六进制的ULONG</td>
<td>ULONG</td>
</tr>
<tr>
<td>%p</td>
<td>指针Pointer 32/64位</td>
<td></td>
</tr>
</tbody></table>
<p>根据DDK上说明,Unicode格式(%C, %S, %lc, %ls, %wc, %ws, and %wZ)只能在 IRQL = PASSIVE_LEVEL时才能使用.</p>
<h3 id="常用的其他内核API函数"><a href="#常用的其他内核API函数" class="headerlink" title="常用的其他内核API函数"></a>常用的其他内核API函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ExAcquireFastMutex</td>
<td>获取一个快速互斥体，用于多线程环境下的同步</td>
</tr>
<tr>
<td>ExReleaseFastMutex</td>
<td>快速释放一个互斥体</td>
</tr>
<tr>
<td>ExRaiseStatus</td>
<td>抛出一个异常，带有一个status值的，代码很深的地方直接报错</td>
</tr>
<tr>
<td>ZwCreateFile</td>
<td>创建文件</td>
</tr>
<tr>
<td>ZwWriteFile</td>
<td>写入文件</td>
</tr>
<tr>
<td>ZwReadFile</td>
<td>读取文件</td>
</tr>
<tr>
<td>ZwQueryDirctory</td>
<td>查询目录文件</td>
</tr>
<tr>
<td>ZwDeviceIoControlFile</td>
<td>创建设备io文件</td>
</tr>
<tr>
<td>ZwCreateKey</td>
<td>创建注册表的键</td>
</tr>
<tr>
<td>ZwQueryValueKey</td>
<td>创建注册表的键值</td>
</tr>
<tr>
<td>IoCreateFile</td>
<td>创建文件，比ZwCreateFile更加底层</td>
</tr>
<tr>
<td>IoCreateDevice</td>
<td>创建设备</td>
</tr>
<tr>
<td>IoCallDriver</td>
<td>发送一个请求，实际上这个函数可能是由IofCallDriver别名</td>
</tr>
<tr>
<td>IoCompleteRequest</td>
<td>完成请求</td>
</tr>
<tr>
<td>IoCopyCurrentIrpStackLocationToNext</td>
<td>将当前IRP请求的栈空间拷贝到下一个栈空间</td>
</tr>
<tr>
<td>IoSkipCurrentIrpStackLocationToNext</td>
<td>跳过当前IRP栈空间</td>
</tr>
<tr>
<td>IoGetCurrentIrpStackLocation</td>
<td>获得当前IRP栈空间指针</td>
</tr>
</tbody></table>
<h3 id="IRQL中断请求级别"><a href="#IRQL中断请求级别" class="headerlink" title="IRQL中断请求级别"></a>IRQL中断请求级别</h3><p>处理器在一个IRQL上执行线程代码。IRQL是帮助决定线程如何被中断的。<strong>在同一处理器上，线程只能被更高级别IRQL的线程能中断</strong>。每个处理器都有自己的中断IRQL。我们经常遇见的有四种IRQL级别。“Passive”, “APC”, “Dispatch” and “DIRQL”.</p>
<p>“DriverEntry”将会在PASSIVE_LEVEL被调用。</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20211109133128464.png" alt="image-20211109133128464"></p>
<ul>
<li><p><strong>PASSIVE_LEVEL</strong>   无中断</p>
<p>IRQL最低级别,没有被屏蔽的中断，在这个级别上，线程执行用户模式，可以访问分页内存。DriverEntry、DriverUnload、DispatchRead…等分发函数都处于这个级别,我们创建的线程也是这个级别</p>
</li>
<li><p><strong>APC_LEVEL</strong>   软中断</p>
<p>在这个级别上,只有APC级别的中断被屏蔽，可以访问分页内存。当有APC发生时，处理器提升到APC级别，这样，就屏蔽掉其它APC，为了和APC执行 一些同步，驱动程序可以手动提升到这个级别。比如，如果提升到这个级别，APC就不能调用。在这个级别，APC被禁止了，导致禁止一些I/O完成APC， 所以有一些API不能调用。</p>
<p><strong>阻止响应任何APC，而且线程不能被挂起（suspend），为什么不能被挂起？因为操作系统实现线程挂起的方式，就是递交 APC</strong></p>
</li>
<li><p><strong>DISPATCH_LEVEL</strong>  软中断</p>
<p>这个级别，DPC(延迟过程) 和更低的中断被屏蔽，不能访问分页内存，所有的被访问的内存不能分页。因为只能处理分页内存，所以在这个级别，能够访问的Api大大减少。</p>
</li>
<li><p><strong>DIRQL (Device IRQL)</strong>  硬中断</p>
<p>通常处于高层次的驱动程序不会使用这个IRQL等级，在这个等级上所有的中断都会被忽略。这是IRQL的最高等级。通常使用这个来判断设备的优先级。<br>一般的，更高级的驱动在这个级别上不处理IRQL，但是几乎所有的中断被屏蔽，这实际上是IRQL的一个范围，这是一个决定某个驱动有更高的优先级的方法。</p>
</li>
</ul>
<h3 id="驱动内核框架"><a href="#驱动内核框架" class="headerlink" title="驱动内核框架"></a>驱动内核框架</h3><h4 id="Windows的驱动开发模型变迁"><a href="#Windows的驱动开发模型变迁" class="headerlink" title="Windows的驱动开发模型变迁"></a>Windows的驱动开发模型变迁</h4><ul>
<li>vxd(windows98)</li>
<li>kdm(windows98~windows2000)</li>
<li>wdm(再之后)</li>
<li>wdf(进一步原有基础上封装了一套更简单的API，现在)</li>
</ul>
<h4 id="内核编程的主要调用源："><a href="#内核编程的主要调用源：" class="headerlink" title="内核编程的主要调用源："></a>内核编程的主要调用源：</h4><ol>
<li>入口函数 DriverEntry 和 卸载函数 DriverUnload（单线程环境）</li>
<li>各种分发函数（多线程环境，可以和DriverUnload并发，无法和DriverEntry并发）</li>
<li>处理请求时设置的完成函数（多线程环境）</li>
<li>其他回调函数  ndis（网络相关）（多线程环境）</li>
</ol>
<h4 id="函数的多线程安全性"><a href="#函数的多线程安全性" class="headerlink" title="函数的多线程安全性"></a>函数的多线程安全性</h4><ol>
<li>可能运行于多线程环境的函数，必须是多线程安全的，只运行于单线程环境的函数，则不需要多线程安全性</li>
<li>如果函数A的所有调用源只运行于同一单线程环境，则函数A也是只运行在单线程环境下。</li>
<li>如果函数A的其中一个调用源是可能运行在多线程环境下的，或者多个调用源可能运行于不同的可并发的多线程环境，而且调用路径上没有采取多线程序列化成单线程的强制措施，则函数A也是可能运行在多线程环境的。</li>
<li>如果函数A所有可能运行于多线程环境的调用路径上，都有多线程序列化成单线程的强制措施，则函数A是运行于单线程环境的。</li>
<li>只使用函数内部资源的，完全不使用全局变量，静态变量或其他全局性资源的函数是多线程安全的。</li>
<li>如果对某个全局变量或者静态变量的所有访问都被强制的同步手段限制为同一时刻只有一个线程访问，则即使使用了这些全局变量或静态变量，对函数的多线程安全性也是没有影响的。</li>
</ol>
<table>
<thead>
<tr>
<th>调用源</th>
<th>运行环境</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td>DriverEntry/DriverUnload</td>
<td>单线程</td>
<td>这两个函数由系统集成的单一线程调用。不会出现多线程同时调用的情况</td>
</tr>
<tr>
<td>各种分发函数</td>
<td>多线程</td>
<td>没有任何文档保证分发函数是不会被多线程同时调用的。此外，分发函数是不会和DriverEntry并发，但可能和DriverUnload并发</td>
</tr>
<tr>
<td>完成函数</td>
<td>多线程</td>
<td>完成函数随时可能被未知的线程调用</td>
</tr>
<tr>
<td>各种NDIS回调函数</td>
<td>多线程</td>
<td>同上</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="代码的中断级"><a href="#代码的中断级" class="headerlink" title="代码的中断级"></a>代码的中断级</h4><p>win32编程是没有中断级这个概念的，但是在内核编程中是有中断级的概念的，我们的程序好像是并发的，但其实是有优先级的，就是中断级</p>
<ul>
<li>passive</li>
<li>dispatch</li>
</ul>
<p>规则：</p>
<ol>
<li>如果在调用路径上没有特殊情况（导致中断级的提高或降低），则一个函数执行时的中断和它的调用源的中断级相同</li>
<li>如果在调用路径上有获取自旋锁，则中断级随之升高；如果调用路径上有释放自旋锁，则中断级随之下降。</li>
</ol>
<table>
<thead>
<tr>
<th>调用源</th>
<th>一般运行中断级</th>
</tr>
</thead>
<tbody><tr>
<td>DriverUnload/DriverEntry</td>
<td>Passive级</td>
</tr>
<tr>
<td>各种分发函数</td>
<td>Passive级</td>
</tr>
<tr>
<td>完成函数</td>
<td>Dispatch级</td>
</tr>
<tr>
<td>各种NDIS回调函数</td>
<td>Dispatch级</td>
</tr>
</tbody></table>
<h4 id="WDK中出现的特殊代码"><a href="#WDK中出现的特殊代码" class="headerlink" title="WDK中出现的特殊代码"></a>WDK中出现的特殊代码</h4><h5 id="IN和OUT"><a href="#IN和OUT" class="headerlink" title="IN和OUT"></a>IN和OUT</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OUT</span></span><br></pre></td></tr></table></figure>

<p>空定义，只是作为提示函数中参数时输入还是输出的</p>
<h5 id="pragma-alloc-text"><a href="#pragma-alloc-text" class="headerlink" title="#pragma alloc_text"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/analogous_love/article/details/47274559">#pragma alloc_text</a></h5><p>有时，驱动程序的某些部分必须驻留内存而另一些可以被分页，这就需要一种能控制代码和数据是否分页的方法。通过指导编译器的段分配可以实现这个目的。</p>
<p>#pragma alloc_text：<strong>把驱动程序的单独例程放到特定段中。</strong></p>
<p>使编译器把代码放到特定段的传统方法是使用alloc_text编译指示。但不是每种编译器都支持这个编译指示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> alloc_text(PAGE, a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> alloc_text(PAGE, b)</span></span><br><span class="line"><span class="comment">//表示函数a和b都运行在分页内存中，就是有可能被交换到分页池中，程序中一些高等级，例如dispatch 级别的代码当然不能运行在分页内存，这样往往出现BSOD</span></span><br><span class="line"><span class="comment">//如果没有上述指令，则默认位于PAGELK这个节，即不会把内存放入硬盘。</span></span><br></pre></td></tr></table></figure>

<p><strong>#pragma alloc_text使用注意</strong></p>
<ol>
<li>该编译指示必须跟在函数声明后面而不能在前面。你可以把驱动程序中的所有函数集中到一个头文件中，并在包含该头文件的源文件中，在#include语句的后面使用alloc_text。</li>
<li>该编译指示仅能用于有C连接形式的函数。即，它不能用于类成员函数或 C++源文件中未用extern “C”声明的函数。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> alloc_text(INIT,DriverEntry)<span class="comment">//某些代码在驱动程序完成初始化后不再需要，可以直接把它插入到INIT段。</span></span></span><br></pre></td></tr></table></figure>









<h2 id="内核空间与内核模块"><a href="#内核空间与内核模块" class="headerlink" title="内核空间与内核模块"></a>内核空间与内核模块</h2><h3 id="内核空间"><a href="#内核空间" class="headerlink" title="内核空间"></a>内核空间</h3><p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210826200052881.png" alt="image-20210826200041917"></p>
<p><strong>内核空间中的地址在各个进程中都是一样的。</strong></p>
<p>内核模块定义全局变量：可在不同进程中查看</p>
<p><strong>windbg进入对应进程的进程空间</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kd&gt;!process <span class="number">0</span> <span class="number">0</span><span class="comment">//罗列出来的进程信息枚举，将PROCESS后接的地址放入下面的命令</span></span><br><span class="line">kd&gt;.<span class="function">process <span class="title">XXXXXXXX</span><span class="params">(上面获取到的地址)</span></span></span><br><span class="line"><span class="function"><span class="comment">//转到了对应进程的内存空间</span></span></span><br></pre></td></tr></table></figure>

<h3 id="内核模块"><a href="#内核模块" class="headerlink" title="内核模块"></a>内核模块</h3><p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210826200052881.png" alt="image-20210826200052881"></p>
<ol>
<li>硬件种类繁多，不可能做一个兼容所有硬件的内核，所以，微软提供规定的接口格式，让硬件驱动人员按照规定的格式编写“驱动程序”。</li>
<li>这些驱动程序每一个都是一个模块，称为“内核模块”，都可以加载到内核中，<strong>都遵守PE结构</strong>。本质上讲，任意一个.sys文件与内核文件没有区别。</li>
</ol>
<h4 id="DRIVER-OBJECT结构体"><a href="#DRIVER-OBJECT结构体" class="headerlink" title="DRIVER_OBJECT结构体"></a>DRIVER_OBJECT结构体</h4><p>定义在wdm.h中。</p>
<p>每个内核模块都有一个对应的结构体，来描述这个模块在内核中的各种信息：位置、大小、名称等等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _DRIVER_OBJECT</span><br><span class="line">nt!_DRIVER_OBJECT</span><br><span class="line">   +<span class="number">0x000</span> Type             : Int2B<span class="comment">//类型</span></span><br><span class="line">   +<span class="number">0x002</span> Size             : Int2B<span class="comment">//大小</span></span><br><span class="line">   +<span class="number">0x004</span> DeviceObject     : Ptr32 _DEVICE_OBJECT<span class="comment">//设备对象，这里实际上是一个设备对象的链表的开始。因为DeviceObject中有相关链表信息</span></span><br><span class="line">   +<span class="number">0x008</span> Flags            : Uint4B</span><br><span class="line">   +<span class="number">0x00c</span> DriverStart      : Ptr32 Void<span class="comment">//驱动被加载到什么地方了，即内核模块的起始地址</span></span><br><span class="line">   +<span class="number">0x010</span> DriverSize       : Uint4B<span class="comment">//该驱动内核模块的大小</span></span><br><span class="line">   +<span class="number">0x014</span> DriverSection    : Ptr32 Void<span class="comment">//指向当前驱动的_LDR_DATA_TABLE_ENTRY结构体的指针</span></span><br><span class="line">   +<span class="number">0x018</span> DriverExtension  : Ptr32 _DRIVER_EXTENSION<span class="comment">//热拔插会用到的相关信息</span></span><br><span class="line">   +<span class="number">0x01c</span> DriverName       : _UNICODE_STRING<span class="comment">//驱动的名字</span></span><br><span class="line">   +<span class="number">0x024</span> HardwareDatabase : Ptr32 _UNICODE_STRING<span class="comment">//注册表</span></span><br><span class="line">   +<span class="number">0x028</span> FastIoDispatch   : Ptr32 _FAST_IO_DISPATCH<span class="comment">//某派遣函数，快速IO分发函数</span></span><br><span class="line">   +<span class="number">0x02c</span> DriverInit       : Ptr32     <span class="keyword">long</span> <span class="comment">//初始化派遣函数</span></span><br><span class="line">   +<span class="number">0x030</span> DriverStartIo    : Ptr32     <span class="keyword">void</span> <span class="comment">//某派遣函数</span></span><br><span class="line">   +<span class="number">0x034</span> DriverUnload     : Ptr32     <span class="keyword">void</span> <span class="comment">//驱动卸载派遣函数</span></span><br><span class="line">   +<span class="number">0x038</span> MajorFunction    : [<span class="number">28</span>] Ptr32     <span class="keyword">long</span> <span class="comment">//包含28个派遣函数地址</span></span><br><span class="line">       <span class="comment">//0编号的IRP对应的派遣函数的地址就存在MajorFunction[0]的位置。</span></span><br><span class="line"><span class="comment">////////////////////////////////_DRIVER_EXTENSION///////////////////////////</span></span><br><span class="line">ntdll!_DRIVER_EXTENSION<span class="comment">//热拔插驱动相关的</span></span><br><span class="line">   +<span class="number">0x000</span> DriverObject     : Ptr32 _DRIVER_OBJECT</span><br><span class="line">   +<span class="number">0x004</span> AddDevice        : Ptr32     <span class="keyword">long</span> </span><br><span class="line">   +<span class="number">0x008</span> Count            : Uint4B</span><br><span class="line">   +<span class="number">0x00c</span> ServiceKeyName   : _UNICODE_STRING</span><br><span class="line">   +<span class="number">0x014</span> ClientDriverExtension : Ptr32 _IO_CLIENT_EXTENSION</span><br><span class="line">   +<span class="number">0x018</span> FsFilterCallbacks : Ptr32 _FS_FILTER_CALLBACKS</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210828154104796.png" alt="image-20210828154104796"></p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210828154124934.png" alt="image-20210828154124934"></p>
<p>Type，Flags，MajorFunction等等，因为他们是固有特征，尽可能隐藏特征，因为内核文件已经加载到内存里了，所以即使修改了，也不影响正常运行。</p>
<h4 id="LDR-DATA-TABLE-ENTRY结构体"><a href="#LDR-DATA-TABLE-ENTRY结构体" class="headerlink" title="_LDR_DATA_TABLE_ENTRY结构体"></a>_LDR_DATA_TABLE_ENTRY结构体</h4><p>完整版定义见WRK的_KLDR_DATA_TABLE_ENTRY</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//所有内核模块的双向链表</span></span><br><span class="line">kd&gt; dt _LDR_DATA_TABLE_ENTRY</span><br><span class="line">nt!_LDR_DATA_TABLE_ENTRY</span><br><span class="line">   +<span class="number">0x000</span> InLoadOrderLinks : _LIST_ENTRY<span class="comment">//初始化顺序双向链表</span></span><br><span class="line">   +<span class="number">0x008</span> InMemoryOrderLinks : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x010</span> InInitializationOrderLinks : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x018</span> DllBase          : Ptr32 Void<span class="comment">//内核模块的起始地址</span></span><br><span class="line">   +<span class="number">0x01c</span> EntryPoint       : Ptr32 Void</span><br><span class="line">   +<span class="number">0x020</span> SizeOfImage      : Uint4B<span class="comment">//内核模块的大小</span></span><br><span class="line">   +<span class="number">0x024</span> FullDllName      : _UNICODE_STRING<span class="comment">//完整的内核模块名，实际上就是全路径</span></span><br><span class="line">   +<span class="number">0x02c</span> BaseDllName      : _UNICODE_STRING<span class="comment">//只有内核模块名，如：xxx.sys</span></span><br><span class="line">   +<span class="number">0x034</span> Flags            : Uint4B</span><br><span class="line">   +<span class="number">0x038</span> LoadCount        : Uint2B</span><br><span class="line">   +<span class="number">0x03a</span> TlsIndex         : Uint2B</span><br><span class="line">   +<span class="number">0x03c</span> HashLinks        : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x03c</span> SectionPointer   : Ptr32 Void</span><br><span class="line">   +<span class="number">0x040</span> CheckSum         : Uint4B<span class="comment">//校验和</span></span><br><span class="line">   +<span class="number">0x044</span> TimeDateStamp    : Uint4B</span><br><span class="line">   +<span class="number">0x044</span> LoadedImports    : Ptr32 Void</span><br><span class="line">   +<span class="number">0x048</span> EntryPointActivationContext : Ptr32 Void</span><br><span class="line">   +<span class="number">0x04c</span> PatchInformation : Ptr32 Void</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//wrk版符号结构</span></span><br><span class="line">     <span class="meta">#<span class="meta-keyword">ifdef</span> _WIN64</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KLDR_DATA_TABLE_ENTRY</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        LIST_ENTRY listEntry;</span><br><span class="line">        ULONG64 __Undefined1;</span><br><span class="line">        ULONG64 __Undefined2;</span><br><span class="line">        ULONG64 __Undefined3;</span><br><span class="line">        ULONG64 NonPagedDebugInfo;</span><br><span class="line">        ULONG64 DllBase;</span><br><span class="line">        ULONG64 EntryPoint;</span><br><span class="line">        ULONG SizeOfImage;</span><br><span class="line">        UNICODE_STRING path;</span><br><span class="line">        UNICODE_STRING name;</span><br><span class="line">        ULONG   Flags;</span><br><span class="line">        USHORT  LoadCount;</span><br><span class="line">        USHORT  __Undefined5;</span><br><span class="line">        ULONG64 __Undefined6;</span><br><span class="line">        ULONG   CheckSum;</span><br><span class="line">        ULONG   __padding1;</span><br><span class="line">        ULONG   TimeDateStamp;</span><br><span class="line">        ULONG   __padding2;</span><br><span class="line">    &#125; KLDR_DATA_TABLE_ENTRY, *PKLDR_DATA_TABLE_ENTRY;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KLDR_DATA_TABLE_ENTRY</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        LIST_ENTRY listEntry;</span><br><span class="line">        ULONG unknown1;</span><br><span class="line">        ULONG unknown2;</span><br><span class="line">        ULONG unknown3;</span><br><span class="line">        ULONG unknown4;</span><br><span class="line">        ULONG unknown5;</span><br><span class="line">        ULONG unknown6;</span><br><span class="line">        ULONG unknown7;</span><br><span class="line">        UNICODE_STRING path;</span><br><span class="line">        UNICODE_STRING name;</span><br><span class="line">        ULONG   Flags;</span><br><span class="line">    &#125; KLDR_DATA_TABLE_ENTRY, *PKLDR_DATA_TABLE_ENTRY;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通杀x32和x64版</span></span><br><span class="line"><span class="comment">//这里字节对齐要采用默认，不要按1对齐，这样才符合32位和64位结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LDR_DATA_TABLE_ENTRY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	LIST_ENTRY InLoadOrderLinks;</span><br><span class="line">	LIST_ENTRY InMemoryOrderLinks;</span><br><span class="line">	LIST_ENTRY InInitializationOrderLinks;</span><br><span class="line">	PVOID DllBase;</span><br><span class="line">	PVOID EntryPoint;</span><br><span class="line">	ULONG SizeOfImage;</span><br><span class="line">	UNICODE_STRING FullDllName;</span><br><span class="line">	UNICODE_STRING BaseDllName;</span><br><span class="line">	ULONG Flags;</span><br><span class="line">	USHORT LoadCount;</span><br><span class="line">	USHORT TlsIndex;</span><br><span class="line">	<span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		LIST_ENTRY HashLinks;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">		&#123;</span></span><br><span class="line">			PVOID SectionPointer;</span><br><span class="line">			ULONG CheckSum;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">		&#123;</span></span><br><span class="line">			ULONG TimeDateStamp;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">		&#123;</span></span><br><span class="line">			PVOID LoadedImports;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">ACTIVATION_CONTEXT</span> * <span class="title">EntryPointActivationContext</span>;</span></span><br><span class="line">	PVOID PatchInformation;</span><br><span class="line">&#125; LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210828154334924.png" alt="image-20210828154334924"></p>
<p>_DRIVER_OBJECT结构可以通过DriverSection找到记录所有内核模块简单信息的双向链表，但双向链表没法找回_DRIVER_OBJECT结构。因此即使是在双向链表中将目标驱动断链了，对于pchunter也依然能找到内核对象，原因是因为pchunter是通过特征码直接索引到_DRIVER_OBJECT结构来遍历所有内核模块，而非通过该双向链表</p>
<h3 id="遍历内核模块作业"><a href="#遍历内核模块作业" class="headerlink" title="遍历内核模块作业"></a>遍历内核模块作业</h3><p><strong>驱动对象遍历，模块隐藏（断链）</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> OldDriverSection= <span class="number">0</span>;<span class="comment">//保存原DriverSection</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//卸载函数</span></span><br><span class="line"><span class="function">VOID <span class="title">DriverUnload</span><span class="params">(PDRIVER_OBJECT driver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//恢复原链和原DriverSection</span></span><br><span class="line">	<span class="keyword">if</span> (OldDriverSection != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//恢复原DriverSection</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> DriverSectionAddr = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)driver + <span class="number">0x014</span>;</span><br><span class="line">		*(<span class="keyword">unsigned</span> <span class="keyword">int</span>*)DriverSectionAddr = OldDriverSection;</span><br><span class="line">		<span class="comment">//恢复原链</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> currentIndex = *(<span class="keyword">unsigned</span> <span class="keyword">int</span>*)DriverSectionAddr;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> lastIndex = *(<span class="keyword">unsigned</span> <span class="keyword">int</span>*)(currentIndex + <span class="number">0x4</span>);</span><br><span class="line">		*(<span class="keyword">unsigned</span> <span class="keyword">int</span>*)lastIndex = currentIndex;</span><br><span class="line">		*(<span class="keyword">unsigned</span> <span class="keyword">int</span>*)(*(<span class="keyword">unsigned</span> <span class="keyword">int</span>*)(currentIndex)+<span class="number">0x4</span>) = currentIndex;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	DbgPrint(<span class="string">&quot;停止运行了\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内核对象链表遍历</span></span><br><span class="line"><span class="function">VOID <span class="title">forEachDriverChain</span><span class="params">(PDRIVER_OBJECT pdriver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> DriverSection = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)pdriver + <span class="number">0x014</span>;</span><br><span class="line">	<span class="comment">//DbgPrint(&quot;DriverSection:%X\n&quot;, DriverSection);</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> beginIndex = *(<span class="keyword">unsigned</span> <span class="keyword">int</span>*)DriverSection;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> currentIndex = beginIndex;</span><br><span class="line">	DbgPrint(<span class="string">&quot;----------------------------------------\r\n&quot;</span>);</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		PUNICODE_STRING BaseDllName = (PUNICODE_STRING)(currentIndex + <span class="number">0x02c</span>);</span><br><span class="line">		DbgPrint(<span class="string">&quot;%wZ\r\n&quot;</span>, BaseDllName);</span><br><span class="line">		currentIndex=*(<span class="keyword">unsigned</span> <span class="keyword">int</span>*)currentIndex;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">while</span> (currentIndex != beginIndex);</span><br><span class="line">	DbgPrint(<span class="string">&quot;----------------------------------------\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//内核对象链表断链</span></span><br><span class="line"><span class="function">VOID <span class="title">BreakDriverChain</span><span class="params">(PDRIVER_OBJECT pdriver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> DriverSectionAddr = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)pdriver + <span class="number">0x014</span>;</span><br><span class="line">	<span class="comment">//DbgPrint(&quot;DriverSection:%X\n&quot;, DriverSection);</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> currentIndex = *(<span class="keyword">unsigned</span> <span class="keyword">int</span>*)DriverSectionAddr;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> lastIndex = *(<span class="keyword">unsigned</span> <span class="keyword">int</span>*)(currentIndex +<span class="number">0x4</span>);</span><br><span class="line">	*(<span class="keyword">unsigned</span> <span class="keyword">int</span>*)lastIndex = *(<span class="keyword">unsigned</span> <span class="keyword">int</span>*)(currentIndex);</span><br><span class="line">	*(<span class="keyword">unsigned</span> <span class="keyword">int</span>*)(*(<span class="keyword">unsigned</span> <span class="keyword">int</span>*)(currentIndex)+<span class="number">0x4</span>) = lastIndex;</span><br><span class="line">	<span class="comment">//修正原PDRIVER_OBJECT中的DriverSection指向前一个链表</span></span><br><span class="line">	OldDriverSection = *(<span class="keyword">unsigned</span> <span class="keyword">int</span>*)DriverSectionAddr;</span><br><span class="line">	*(<span class="keyword">unsigned</span> <span class="keyword">int</span>*)DriverSectionAddr = lastIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入口函数，相当于main函数</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT pdriver, PUNICODE_STRING pReg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//驱动程序的入口</span></span><br><span class="line">	DbgPrint(<span class="string">&quot;hello world!\n&quot;</span>);</span><br><span class="line">	DbgPrint(<span class="string">&quot;pdriver:%wZ\r\n&quot;</span>,pReg);</span><br><span class="line">	DbgPrint(<span class="string">&quot;pReg:%p\r\n&quot;</span>,pdriver);</span><br><span class="line">	DbgPrint(<span class="string">&quot;hello world!\n&quot;</span>);</span><br><span class="line">	DbgPrint(<span class="string">&quot;===============断链前==============\n&quot;</span>);</span><br><span class="line">	forEachDriverChain(pdriver);</span><br><span class="line">	BreakDriverChain(pdriver);</span><br><span class="line">	DbgPrint(<span class="string">&quot;===============断链后==============\n&quot;</span>);</span><br><span class="line">	forEachDriverChain(pdriver);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置一个卸载函数，用于退出</span></span><br><span class="line">	pdriver-&gt;DriverUnload = DriverUnload;</span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br></pre></td><td class="code"><pre><span class="line">hello world!</span><br><span class="line">pdriver:\REGISTRY\MACHINE\SYSTEM\ControlSet002\Services\HelloWorld</span><br><span class="line">pReg:<span class="number">81</span>DDCD18</span><br><span class="line">hello world!</span><br><span class="line">===============断链前==============</span><br><span class="line">----------------------------------------</span><br><span class="line">HelloWorld.sys</span><br><span class="line">(null)</span><br><span class="line">ntoskrnl.exe</span><br><span class="line">hal.dll</span><br><span class="line">kdcom.dll</span><br><span class="line">BOOTVID.dll</span><br><span class="line">ACPI.sys</span><br><span class="line">WMILIB.SYS</span><br><span class="line">pci.sys</span><br><span class="line">isapnp.sys</span><br><span class="line">compbatt.sys</span><br><span class="line">BATTC.SYS</span><br><span class="line">intelide.sys</span><br><span class="line">PCIIDEX.SYS</span><br><span class="line">MountMgr.sys</span><br><span class="line">ftdisk.sys</span><br><span class="line">dmload.sys</span><br><span class="line">dmio.sys</span><br><span class="line">PartMgr.sys</span><br><span class="line">vmci.sys</span><br><span class="line">VolSnap.sys</span><br><span class="line">vsock.sys</span><br><span class="line">atapi.sys</span><br><span class="line">disk.sys</span><br><span class="line">CLASSPNP.SYS</span><br><span class="line">fltMgr.sys</span><br><span class="line">sr.sys</span><br><span class="line">KSecDD.sys</span><br><span class="line">Ntfs.sys</span><br><span class="line">NDIS.sys</span><br><span class="line">Mup.sys</span><br><span class="line">agp440.sys</span><br><span class="line">i8042prt.sys</span><br><span class="line">kbdclass.sys</span><br><span class="line">vmmouse.sys</span><br><span class="line">mouclass.sys</span><br><span class="line">serial.sys</span><br><span class="line">serenum.sys</span><br><span class="line">imapi.sys</span><br><span class="line">cdrom.sys</span><br><span class="line">redbook.sys</span><br><span class="line">ks.sys</span><br><span class="line">vmx_svga.sys</span><br><span class="line">VIDEOPRT.SYS</span><br><span class="line">usbuhci.sys</span><br><span class="line">USBPORT.SYS</span><br><span class="line">vmxnet.sys</span><br><span class="line">es1371mp.sys</span><br><span class="line">portcls.sys</span><br><span class="line">drmk.sys</span><br><span class="line">usbehci.sys</span><br><span class="line">CmBatt.sys</span><br><span class="line">intelppm.sys</span><br><span class="line">fsvga.sys</span><br><span class="line">audstub.sys</span><br><span class="line">rasl2tp.sys</span><br><span class="line">ndistapi.sys</span><br><span class="line">ndiswan.sys</span><br><span class="line">raspppoe.sys</span><br><span class="line">raspptp.sys</span><br><span class="line">TDI.SYS</span><br><span class="line">psched.sys</span><br><span class="line">msgpc.sys</span><br><span class="line">ptilink.sys</span><br><span class="line">raspti.sys</span><br><span class="line">rdpdr.sys</span><br><span class="line">termdd.sys</span><br><span class="line">swenum.sys</span><br><span class="line">update.sys</span><br><span class="line">mssmbios.sys</span><br><span class="line">NDProxy.SYS</span><br><span class="line">usbhub.sys</span><br><span class="line">USBD.SYS</span><br><span class="line">gameenum.sys</span><br><span class="line">Fs_Rec.SYS</span><br><span class="line">Null.SYS</span><br><span class="line">Beep.SYS</span><br><span class="line">vga.sys</span><br><span class="line">mnmdd.SYS</span><br><span class="line">RDPCDD.sys</span><br><span class="line">Msfs.SYS</span><br><span class="line">Npfs.SYS</span><br><span class="line">rasacd.sys</span><br><span class="line">ipsec.sys</span><br><span class="line">tcpip.sys</span><br><span class="line">netbt.sys</span><br><span class="line">ws2ifsl.sys</span><br><span class="line">afd.sys</span><br><span class="line">netbios.sys</span><br><span class="line">vmhgfs.sys</span><br><span class="line">rdbss.sys</span><br><span class="line">mrxsmb.sys</span><br><span class="line">Fips.SYS</span><br><span class="line">ipnat.sys</span><br><span class="line">Cdfs.SYS</span><br><span class="line">wanarp.sys</span><br><span class="line">usbccgp.sys</span><br><span class="line">hidusb.sys</span><br><span class="line">HIDCLASS.SYS</span><br><span class="line">HIDPARSE.SYS</span><br><span class="line">BTHUSB.sys</span><br><span class="line">bthport.sys</span><br><span class="line">mouhid.sys</span><br><span class="line">vmusbmouse.sys</span><br><span class="line">dump_atapi.sys</span><br><span class="line">dump_WMILIB.SYS</span><br><span class="line">win32k.sys</span><br><span class="line">Dxapi.sys</span><br><span class="line">watchdog.sys</span><br><span class="line">dxg.sys</span><br><span class="line">dxgthk.sys</span><br><span class="line">vmx_fb.dll</span><br><span class="line">rfcomm.sys</span><br><span class="line">BthEnum.sys</span><br><span class="line">bthpan.sys</span><br><span class="line">ndisuio.sys</span><br><span class="line">wdmaud.sys</span><br><span class="line">sysaudio.sys</span><br><span class="line">mrxdav.sys</span><br><span class="line">vmmemctl.sys</span><br><span class="line">srv.sys</span><br><span class="line">HTTP.sys</span><br><span class="line">Dbgv.sys</span><br><span class="line">----------------------------------------</span><br><span class="line">===============断链后==============</span><br><span class="line">----------------------------------------</span><br><span class="line">Dbgv.sys</span><br><span class="line">(null)</span><br><span class="line">ntoskrnl.exe</span><br><span class="line">hal.dll</span><br><span class="line">kdcom.dll</span><br><span class="line">BOOTVID.dll</span><br><span class="line">ACPI.sys</span><br><span class="line">WMILIB.SYS</span><br><span class="line">pci.sys</span><br><span class="line">isapnp.sys</span><br><span class="line">compbatt.sys</span><br><span class="line">BATTC.SYS</span><br><span class="line">intelide.sys</span><br><span class="line">PCIIDEX.SYS</span><br><span class="line">MountMgr.sys</span><br><span class="line">ftdisk.sys</span><br><span class="line">dmload.sys</span><br><span class="line">dmio.sys</span><br><span class="line">PartMgr.sys</span><br><span class="line">vmci.sys</span><br><span class="line">VolSnap.sys</span><br><span class="line">vsock.sys</span><br><span class="line">atapi.sys</span><br><span class="line">disk.sys</span><br><span class="line">CLASSPNP.SYS</span><br><span class="line">fltMgr.sys</span><br><span class="line">sr.sys</span><br><span class="line">KSecDD.sys</span><br><span class="line">Ntfs.sys</span><br><span class="line">NDIS.sys</span><br><span class="line">Mup.sys</span><br><span class="line">agp440.sys</span><br><span class="line">i8042prt.sys</span><br><span class="line">kbdclass.sys</span><br><span class="line">vmmouse.sys</span><br><span class="line">mouclass.sys</span><br><span class="line">serial.sys</span><br><span class="line">serenum.sys</span><br><span class="line">imapi.sys</span><br><span class="line">cdrom.sys</span><br><span class="line">redbook.sys</span><br><span class="line">ks.sys</span><br><span class="line">vmx_svga.sys</span><br><span class="line">VIDEOPRT.SYS</span><br><span class="line">usbuhci.sys</span><br><span class="line">USBPORT.SYS</span><br><span class="line">vmxnet.sys</span><br><span class="line">es1371mp.sys</span><br><span class="line">portcls.sys</span><br><span class="line">drmk.sys</span><br><span class="line">usbehci.sys</span><br><span class="line">CmBatt.sys</span><br><span class="line">intelppm.sys</span><br><span class="line">fsvga.sys</span><br><span class="line">audstub.sys</span><br><span class="line">rasl2tp.sys</span><br><span class="line">ndistapi.sys</span><br><span class="line">ndiswan.sys</span><br><span class="line">raspppoe.sys</span><br><span class="line">raspptp.sys</span><br><span class="line">TDI.SYS</span><br><span class="line">psched.sys</span><br><span class="line">msgpc.sys</span><br><span class="line">ptilink.sys</span><br><span class="line">raspti.sys</span><br><span class="line">rdpdr.sys</span><br><span class="line">termdd.sys</span><br><span class="line">swenum.sys</span><br><span class="line">update.sys</span><br><span class="line">mssmbios.sys</span><br><span class="line">NDProxy.SYS</span><br><span class="line">usbhub.sys</span><br><span class="line">USBD.SYS</span><br><span class="line">gameenum.sys</span><br><span class="line">Fs_Rec.SYS</span><br><span class="line">Null.SYS</span><br><span class="line">Beep.SYS</span><br><span class="line">vga.sys</span><br><span class="line">mnmdd.SYS</span><br><span class="line">RDPCDD.sys</span><br><span class="line">Msfs.SYS</span><br><span class="line">Npfs.SYS</span><br><span class="line">rasacd.sys</span><br><span class="line">ipsec.sys</span><br><span class="line">tcpip.sys</span><br><span class="line">netbt.sys</span><br><span class="line">ws2ifsl.sys</span><br><span class="line">afd.sys</span><br><span class="line">netbios.sys</span><br><span class="line">vmhgfs.sys</span><br><span class="line">rdbss.sys</span><br><span class="line">mrxsmb.sys</span><br><span class="line">Fips.SYS</span><br><span class="line">ipnat.sys</span><br><span class="line">Cdfs.SYS</span><br><span class="line">wanarp.sys</span><br><span class="line">usbccgp.sys</span><br><span class="line">hidusb.sys</span><br><span class="line">HIDCLASS.SYS</span><br><span class="line">HIDPARSE.SYS</span><br><span class="line">BTHUSB.sys</span><br><span class="line">bthport.sys</span><br><span class="line">mouhid.sys</span><br><span class="line">vmusbmouse.sys</span><br><span class="line">dump_atapi.sys</span><br><span class="line">dump_WMILIB.SYS</span><br><span class="line">win32k.sys</span><br><span class="line">Dxapi.sys</span><br><span class="line">watchdog.sys</span><br><span class="line">dxg.sys</span><br><span class="line">dxgthk.sys</span><br><span class="line">vmx_fb.dll</span><br><span class="line">rfcomm.sys</span><br><span class="line">BthEnum.sys</span><br><span class="line">bthpan.sys</span><br><span class="line">ndisuio.sys</span><br><span class="line">wdmaud.sys</span><br><span class="line">sysaudio.sys</span><br><span class="line">mrxdav.sys</span><br><span class="line">vmmemctl.sys</span><br><span class="line">srv.sys</span><br><span class="line">HTTP.sys</span><br><span class="line">----------------------------------------</span><br><span class="line">停止运行了</span><br></pre></td></tr></table></figure>

<p>由上面打印可知HelloWorld.sys成功被隐藏，但pchunter依然可以查找到我们的驱动</p>
<p><strong>真隐藏（pchunter无法找到）</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LDR_DATA_TABLE_ENTRY</span> &#123;</span></span><br><span class="line">	LIST_ENTRY InLoadOrderLinks;</span><br><span class="line">	LIST_ENTRY InMemoryOrderLinks;</span><br><span class="line">	LIST_ENTRY InInitializationOrderLinks;</span><br><span class="line">	PVOID DllBase;</span><br><span class="line">	PVOID EntryPoint;</span><br><span class="line">	ULONG SizeOfImage;</span><br><span class="line">	UNICODE_STRING FullDllName;</span><br><span class="line">	UNICODE_STRING BaseDllName;</span><br><span class="line">	ULONG Flags;</span><br><span class="line">	USHORT LoadCount;</span><br><span class="line">	USHORT TlsIndex;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		LIST_ENTRY HashLinks;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			PVOID SectionPointer;</span><br><span class="line">			ULONG CheckSum;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			ULONG TimeDateStamp;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			PVOID LoadedImports;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">ACTIVATION_CONTEXT</span> * <span class="title">EntryPointActivationContext</span>;</span></span><br><span class="line"></span><br><span class="line">	PVOID PatchInformation;</span><br><span class="line"></span><br><span class="line">&#125; LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;</span><br><span class="line"></span><br><span class="line">HANDLE hThread;</span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">DriverUnload</span><span class="params">(PDRIVER_OBJECT pDriver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	KdPrint((<span class="string">&quot;卸载的了&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">threadRun</span><span class="params">(_In_ PVOID StartContext)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	KdPrint((<span class="string">&quot;开始执行1\n&quot;</span>));</span><br><span class="line">	LARGE_INTEGER times;</span><br><span class="line">	times.QuadPart = <span class="number">-30</span> * <span class="number">1000</span> * <span class="number">1000</span>;</span><br><span class="line">	KeDelayExecutionThread(KernelMode, FALSE, &amp;times);</span><br><span class="line">	PDRIVER_OBJECT pDriver = (PDRIVER_OBJECT)StartContext;</span><br><span class="line">	<span class="comment">//抹除特征</span></span><br><span class="line">    pDriver-&gt;DriverSize = <span class="number">0</span>;</span><br><span class="line">	pDriver-&gt;DriverSection = <span class="literal">NULL</span>;</span><br><span class="line">	pDriver-&gt;DriverExtension = <span class="literal">NULL</span>;</span><br><span class="line">	pDriver-&gt;DriverStart = <span class="literal">NULL</span>;</span><br><span class="line">	pDriver-&gt;DriverInit = <span class="literal">NULL</span>;</span><br><span class="line">	pDriver-&gt;FastIoDispatch = <span class="literal">NULL</span>;</span><br><span class="line">	pDriver-&gt;DriverStartIo = <span class="literal">NULL</span>;</span><br><span class="line">	ZwClose(hThread);</span><br><span class="line">	KdPrint((<span class="string">&quot;执行结束1\n&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT pDriver, PUNICODE_STRING pReg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	KdPrint((<span class="string">&quot;驱动被加载\n&quot;</span>));</span><br><span class="line">	PLDR_DATA_TABLE_ENTRY pList = (PLDR_DATA_TABLE_ENTRY)pDriver-&gt;DriverSection;</span><br><span class="line">	PLDR_DATA_TABLE_ENTRY pCur = pList;</span><br><span class="line">	pList = pList-&gt;InLoadOrderLinks.Flink;</span><br><span class="line"></span><br><span class="line">	pList-&gt;InLoadOrderLinks.Blink = pCur-&gt;InLoadOrderLinks.Blink;</span><br><span class="line">	pCur-&gt;InLoadOrderLinks.Flink = pList;</span><br><span class="line"></span><br><span class="line">	pDriver-&gt;DriverUnload = DriverUnload;</span><br><span class="line"></span><br><span class="line">	PsCreateSystemThread(&amp;hThread, GENERIC_ALL, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, threadRun, pDriver);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码可让pchunter也找不到驱动，但此代码只做了抹特征隐藏，却并未恢复特征或手动调用函数卸载驱动。停止驱动的时候会因为信息缺失直接蓝屏。需要一个时间点做恢复特征（不可以在DriverUnload中，因为是还没到该函数就蓝屏了）。</p>
<p>64位下不能直接断链(PG的原因)</p>
<p>MiProcessLoaderEntry，第一个参数是当前链表，第二个参数false表示卸载，true表示插入。该函数模块从链表上移除了，但没有释放内存。</p>
<p>64位用这个函数不会触发PG，不会蓝屏。PG可以理解成就是保护全局变量bu不被直接修改。</p>
<p><strong>KdPrint和DbgPrint的区别：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DBG</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> KdPrint(_x_) DbgPrint _x_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> KdPrint(_x_)<span class="comment">//把KdPrint(_x_)宏替换成什么也没有</span></span></span><br><span class="line"><span class="comment">//即如下两句在debug模式下含义相同:</span></span><br><span class="line">KdPrint((<span class="string">&quot;hello World!\n&quot;</span>));</span><br><span class="line">DbgPrint(<span class="string">&quot;hello World!\n&quot;</span>);</span><br><span class="line"><span class="comment">//但在release模式下，KdPrint不会打印。</span></span><br></pre></td></tr></table></figure>

<h3 id="驱动键鼠过滤"><a href="#驱动键鼠过滤" class="headerlink" title="驱动键鼠过滤"></a>驱动键鼠过滤</h3><p>IoAttachDevice绑定设备</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS</span></span><br><span class="line"><span class="function"><span class="title">IoAttachDevice</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">IN PDEVICE_OBJECT SourceDevice,<span class="comment">//生成的设备对象</span></span></span></span><br><span class="line"><span class="params"><span class="function">IN PUNICODE_STRING TargetDevice,<span class="comment">//目标串口设备名称</span></span></span></span><br><span class="line"><span class="params"><span class="function">OUT PDEVICE_OBJECT *AttachedDevice<span class="comment">//【返回被绑定设备指针】的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UNICODE_STRING com_name = RLT_CONSTANT_STRING(<span class="string">L&quot;\\Device\\Serial0&quot;</span>);</span><br><span class="line">NTSTATUS status = IoAttachDevice(com_filter_device,&amp;com_device_name,&amp;attached_device);</span><br></pre></td></tr></table></figure>

<h2 id="驱动开发中的链表"><a href="#驱动开发中的链表" class="headerlink" title="驱动开发中的链表"></a>驱动开发中的链表</h2><p><strong>常用函数</strong></p>
<ul>
<li>IsListEmpty          判断链表是否为空  </li>
<li>InitializeListHead  初始化双向链表头  </li>
<li>InsertHeadList      插入链表头部   </li>
<li>InsertTailList         插入链表尾部   </li>
<li>RemoveHeadList  移除头部节点   </li>
<li>RemoveTailList     移除尾部节点  </li>
<li>RemoveEntryList  移除当前节点   </li>
</ul>
<p>链表在驱动中需要处理同步,因为链表涉及到指针操作,一不小心就可能导致蓝屏.</p>
<p>因此驱动开发中数组可以不需要同步处理(多线程写入同一个位置一样可能有问题,但概率没那么大),但链表必须做<a href="#%E5%AE%8C%E7%BE%8E%E8%BF%87%E6%8E%89%E5%AF%B9%E8%B1%A1%E4%BF%9D%E6%8A%A4%E9%92%A9%E5%AD%90">同步处理</a></p>
<h2 id="零环与三环通信-常规方式"><a href="#零环与三环通信-常规方式" class="headerlink" title="零环与三环通信(常规方式)"></a>零环与三环通信(常规方式)</h2><p>常规方式表示微软提供的正常通信方式，还有非常规通信。正常通信方式受到一定限制。</p>
<p><strong>设备对象</strong></p>
<p>我们在开发窗口程序的时候，消息被封装成一个结构体：MSG，<strong>在内核开发时，消息被封装成另外一个结构体：IRP</strong>（I/O Request Package输入输出请求包）</p>
<p>在窗口程序中，能够接受消息的只能是窗口对象。在内核中，能够接收IRP消息的只能是设备对象</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210827111116147.png" alt="image-20210827111116147"></p>
<ul>
<li><strong>驱动对象</strong>（DRIVER_OBJECT）生成多个设备对象，</li>
<li><strong>设备对象</strong>（DEVICE_OBJECT）可以是硬件（硬盘等），也可以是软件，比如NTFS文件系统。它们都属于设备对象。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210829163134914.png" alt="image-20210829163134914"></p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/sdsad.jpeg" alt="sdsad"></p>
<h3 id="创建设备对象"><a href="#创建设备对象" class="headerlink" title="创建设备对象"></a><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/nf-wdm-iocreatedevice">创建设备对象</a></h3><h4 id="设备对象结构"><a href="#设备对象结构" class="headerlink" title="设备对象结构"></a>设备对象结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> struct <span class="title">DECLSPEC_ALIGN</span><span class="params">(MEMORY_ALLOCATION_ALIGNMENT)</span> _DEVICE_OBJECT</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CSHORT Type;<span class="comment">//类型</span></span><br><span class="line">    USHORT Size;<span class="comment">//大小</span></span><br><span class="line">    LONG ReferenceCount;<span class="comment">//引用计数</span></span><br><span class="line">    <span class="comment">/*指向驱动程序中驱动对象的指针*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">DRIVER_OBJECT</span> *<span class="title">DriverObject</span>;</span><span class="comment">//设备所属的驱动对象</span></span><br><span class="line">    <span class="comment">/*指向下一个设备对象的指针*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">DEVICE_OBJECT</span> *<span class="title">NextDevice</span>;</span><span class="comment">//下一个设备对象，在一个驱动对象中有N个设备，这些设备用这个指针连接起来作为一个单向的链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">DEVICE_OBJECT</span> *<span class="title">AttachedDevice</span>;</span></span><br><span class="line">    <span class="comment">/*当前IRP结构*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IRP</span> *<span class="title">CurrentIrp</span>;</span></span><br><span class="line">    PIO_TIMER Timer;</span><br><span class="line">    <span class="comment">/*设备对象的特性标志*/</span></span><br><span class="line">    ULONG Flags;</span><br><span class="line">    ULONG Characteristics;</span><br><span class="line">    _volatile PVPB Vpb;</span><br><span class="line">    <span class="comment">/*指向设备扩展对象的指针*/</span></span><br><span class="line">    PVOID DeviceExtension;</span><br><span class="line">    <span class="comment">/*指明设备类型*/</span></span><br><span class="line">    DEVICE_TYPE DeviceType;</span><br><span class="line">    <span class="comment">/*堆栈的最小层数*/</span></span><br><span class="line">    CCHAR StackSize;<span class="comment">//IRP栈的大小,用于存放参数的</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        LIST_ENTRY ListEntry;</span><br><span class="line">        WAIT_CONTEXT_BLOCK Wcb;</span><br><span class="line">    &#125; Queue;</span><br><span class="line">    <span class="comment">/*内存对齐*/</span></span><br><span class="line">    ULONG AlignmentRequirement;</span><br><span class="line">    KDEVICE_QUEUE DeviceQueue;</span><br><span class="line">    KDPC Dpc;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *下列成员用于支持文件系统的互斥操作</span></span><br><span class="line"><span class="comment">    *以便对文件系统处理线程使用设备的计数保持跟踪</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    ULONG ActiveThreadCount;</span><br><span class="line">    PSECURITY_DESCRIPTOR SecurityDescriptor;</span><br><span class="line">    KEVENT DeviceLock;</span><br><span class="line"> </span><br><span class="line">    USHORT SectorSize;</span><br><span class="line">    USHORT Spare1;</span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">DEVOBJ_EXTENSION</span>  *<span class="title">DeviceObjectExtension</span>;</span></span><br><span class="line">    PVOID  Reserved;</span><br><span class="line"> </span><br><span class="line">&#125; DEVICE_OBJECT;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DEVICE_OBJECT</span> *<span class="title">PDEVICE_OBJECT</span>;</span></span><br></pre></td></tr></table></figure>

<h4 id="IoCreateDevice"><a href="#IoCreateDevice" class="headerlink" title="IoCreateDevice"></a>IoCreateDevice</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">IoCreateDevice</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  PDRIVER_OBJECT  DriverObject,<span class="comment">//驱动对象指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">  ULONG           DeviceExtensionSize,<span class="comment">//指定要为设备对象的设备扩展分配的驱动程序确定的字节数；设备扩展内存的大小，你可以在这申请一块非分页内存，只要设备还在，就都可以用，可以用它代替全局变量。</span></span></span></span><br><span class="line"><span class="params"><span class="function">  PUNICODE_STRING DeviceName,<span class="comment">//可选地指向一个缓冲区，该缓冲区包含一个以空字符结尾的 Unicode 字符串，用于命名设备对象。该字符串必须是完整路径名。</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DEVICE_TYPE     DeviceType,<span class="comment">//一般用FILE_DEVICE_UNKNOWN，#define FILE_DEVICE_UNKNOWN             0x00000022</span></span></span></span><br><span class="line"><span class="params"><span class="function">  ULONG           DeviceCharacteristics,<span class="comment">//基本就是填FILE_DEVICE_SECURE_OPEN</span></span></span></span><br><span class="line"><span class="params"><span class="function">  BOOLEAN         Exclusive,<span class="comment">//TRUE代表设备是独占的，FALSE代表该设备是共享的；独享可以防止前面的驱动拦截后面的驱动的派遣函数处理</span></span></span></span><br><span class="line"><span class="params"><span class="function">  PDEVICE_OBJECT  *DeviceObject<span class="comment">//【out】二级指针，目的是返回设备对象指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给某个设备发送IRP请求</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">MyDispath</span><span class="params">(PDEVICE_OBJECT device,PIRP irp)</span></span>;</span><br></pre></td></tr></table></figure>

<p>实例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建设备名称</span></span><br><span class="line">UNICODE_STRING Devicename;</span><br><span class="line">RtlInitUnicodeString(&amp;Devicename,<span class="string">L&quot;\\Device\\MyDevice&quot;</span>);<span class="comment">//\\Device尽量不要改，为了让驱动文件同一个树结构下，方便统一。该名字是给零环用的，三环通过这个名字是找不到该设备对象的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设备对象指针，用于接受</span></span><br><span class="line">PDEVICE_OBJECT pDeviceObj = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//创建设备</span></span><br><span class="line">status = IoCreateDevice(</span><br><span class="line">pDriver,				<span class="comment">//当前设备所属的驱动对象</span></span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">&amp;Devicename,			<span class="comment">//设备对象的名称</span></span><br><span class="line">FILE_DEVICE_UNKNOWN,<span class="comment">//不知道什么类型</span></span><br><span class="line">FILE_DEVICE_SECURE_OPEN,</span><br><span class="line">TRUE,</span><br><span class="line">&amp;pDeviceObj			<span class="comment">//【out】设备对象指针</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">if</span>(!NT_SUCCESS(status))<span class="comment">//NT_SUCCESS,微软提供的，实际上就是判断status是否大于等于0</span></span><br><span class="line">&#123;</span><br><span class="line">    DbgPrint(<span class="string">&quot;创建设备失败!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除设备对象"><a href="#删除设备对象" class="headerlink" title="删除设备对象"></a>删除设备对象</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IoDeleteDevice(pDeviceObj);<span class="comment">//删除设备</span></span><br></pre></td></tr></table></figure>

<h3 id="设置交互数据的方式"><a href="#设置交互数据的方式" class="headerlink" title="设置交互数据的方式"></a>设置交互数据的方式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果前面创建设备对象成功，就设置交互数据的方式</span></span><br><span class="line">pDeviceObj-&gt;Flags |= DO_BUFFERED_IO;</span><br></pre></td></tr></table></figure>

<ul>
<li>**缓冲区方式读写(DO_BUFFERED_IO)**：操作系统将应用程序提供缓冲区的数据复制到内核模式下的地址中。(效率不高，适合小规模数据)</li>
<li>**直接方式读写(DO_DIRECT_IO)**：操作系统会将用户模式下的缓冲区锁住。然后操作系统将这段缓冲区在内核模式地址再次映射一遍。这样，用户模式的缓冲区和内核模式的缓冲区指向的是同一区域的物理内存。缺点就是要单独占用物理页面。(适合大规模数据，比较浪费物理页)</li>
<li><strong>其他方式读写</strong>(在调用IoCreateDevice创建设备后对pDevObj-&gt;Flags即不设置DO_BUFFERED_IO，也不设置DO_DIRECT_IO，此时就是其他方式)：在使用其他方式读写设备时，派遣函数直接读写应用程序提供的缓冲区地址。在驱动程序中，直接操作应用程序的缓冲区地址是很危险的**(这种方法须要注意的是ReadFile可能把空指针地址或者非法地址传递给驱动程序，因此驱动程序使用用户模式地址前须要检查是否可读或者可写)<strong>。</strong>只有驱动程序与应用程序运行在相同线程上下文的情况下，才能使用这种方式**。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读写方式不一样,则读写的位置不一样</span></span><br><span class="line"><span class="keyword">if</span>(DeviceObject-&gt;Flags&amp;DO_BUFFERED_IO)<span class="comment">//缓冲区方式读写</span></span><br><span class="line">	&#123;</span><br><span class="line">		KdPrint((<span class="string">&quot;Flags:DO_BUFFER_IO\n&quot;</span>));</span><br><span class="line">		pBuffer=Irp-&gt;AssociatedIrp.SystemBuffer;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(DeviceObject-&gt;Flags&amp;DO_DIRECT_IO)<span class="comment">//直接方式读写</span></span><br><span class="line">	&#123;</span><br><span class="line">		KdPrint((<span class="string">&quot;Flags:DO_DIRECT_IO\n&quot;</span>));</span><br><span class="line">		pBuffer=MmGetSystemAddressForMdl(Irp-&gt;MdlAddress);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span><span class="comment">//其他方式读写</span></span><br><span class="line">	&#123;</span><br><span class="line">		KdPrint((<span class="string">&quot;Flags:Neither\n&quot;</span>));</span><br><span class="line">		pBuffer=Irp-&gt;UserBuffer;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//ReadFile和WriteFile方式通信的内核缓冲区长度在IrpStack-&gt;Parameters.Read.Length和IrpStack-&gt;Parameters.Write.Length中</span></span><br></pre></td></tr></table></figure>

<h3 id="创建与卸载符号链接"><a href="#创建与卸载符号链接" class="headerlink" title="创建与卸载符号链接"></a>创建与卸载符号链接</h3><p>就是设置一个名字，让三环可以通过这个名字找到设备对象来操作他。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建符号链接名称</span></span><br><span class="line">UNICODE_STRING SymbolicLinkName;</span><br><span class="line">RtlInitUnicodeString(&amp;SymbolicLinkName,<span class="string">L&quot;\\??\\MyTestDriver&quot;</span>);</span><br><span class="line"><span class="comment">//两个问号代表根目录</span></span><br><span class="line"><span class="comment">//Ring3用CreateFile打开设备时，用&quot;\\\\.\\MyTestDriver&quot;(实际上就是地址要\\.\开始，但是要转义，所以为\\\\.\\)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建符号链接</span></span><br><span class="line">status = IoCreateSymbolicLink(&amp;SymbolicLinkName,&amp;Devicename);</span><br><span class="line"><span class="keyword">if</span>(status!=STATUS_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">    DbgPrint(<span class="string">&quot;创建符号链接失败!\n&quot;</span>);</span><br><span class="line">    IoDeleteDevice(pDeviceObj);<span class="comment">//删除设备</span></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//卸载符号链接</span></span><br><span class="line">IoDeleteSymbolicLink(&amp;SymbolicLinkName);</span><br></pre></td></tr></table></figure>

<p>特别说明：</p>
<ol>
<li>设备名称的作用是给内核对象用的，如果要在Ring3访问，必须要有符号链接，其实就是一个别名，没有这个别名，在Ring3不可见</li>
<li><strong>内核模式下，符号链接是以”??&quot;开头的，如C盘就是”??\C:”</strong></li>
<li><strong>用户模式下，则是以”\\.\&quot;开头的，如C盘就是”\\.\C:”</strong></li>
</ol>
<p>创建设备对象并设置符号链接</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _LINK_NAME <span class="meta-string">L&quot;\\??\\MyDriver&quot;</span></span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">CreateDevice</span><span class="params">(PDRIVER_OBJECT driver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS status;</span><br><span class="line">    UNICODE_STRING MyDriver;<span class="comment">//驱动字符串</span></span><br><span class="line">    PDEVICE_OBJECT device = <span class="literal">NULL</span>;<span class="comment">//用于存放设备对象</span></span><br><span class="line">    RtlInitUnicodeString(&amp;MyDriver, <span class="string">L&quot;\\DEVICE\\MyDriver&quot;</span>);</span><br><span class="line">    status = IoCreateDevice(driver,</span><br><span class="line">        <span class="keyword">sizeof</span>(driver-&gt;DriverExtension),</span><br><span class="line">        &amp;MyDriver,</span><br><span class="line">        FILE_DEVICE_UNKNOWN,</span><br><span class="line">        FILE_DEVICE_SECURE_OPEN,</span><br><span class="line">        FALSE,</span><br><span class="line">        &amp;device</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (status==STATUS_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        KdPrint((<span class="string">&quot;zeroko14:kernel:驱动设备对象创建成功\n&quot;</span>));</span><br><span class="line">        UNICODE_STRING uzSymbolName;</span><br><span class="line">        RtlInitUnicodeString(&amp;uzSymbolName, _LINK_NAME);</span><br><span class="line">        status = IoCreateSymbolicLink(&amp;uzSymbolName, &amp;MyDriver);</span><br><span class="line">        <span class="keyword">if</span> (status == STATUS_SUCCESS)</span><br><span class="line">        &#123;</span><br><span class="line">            KdPrint((<span class="string">&quot;zeroko14:kernel:创建符号链接%wZ成功\n&quot;</span>, &amp;uzSymbolName));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            KdPrint((<span class="string">&quot;zeroko14:kernel:创建符号链接%wZ失败  status:%X\n&quot;</span>, &amp;uzSymbolName,status));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        KdPrint((<span class="string">&quot;zeroko14:kernel:驱动对象创建失败,删除设备\n&quot;</span>));</span><br><span class="line">        IoDeleteDevice(device);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="IRP与派遣函数"><a href="#IRP与派遣函数" class="headerlink" title="IRP与派遣函数"></a>IRP与派遣函数</h3><p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210827114410752.png" alt="image-20210827114410752"></p>
<p>驱动程序与I/O管理器通信，使用的是IRP，即<strong>I/O请求包</strong>。</p>
<h4 id="IRP类型"><a href="#IRP类型" class="headerlink" title="IRP类型"></a>IRP类型</h4><ol>
<li><p>当应用层通过CreateFile，ReadFile，WriteFile，CloseHandle等函数打开，从设备读取数据，向设备写入数据，关闭设备的时候，会使操作系统分别产生出IRP_MJ_CREATE,IRP_MJ_READ,IRP_MJ_WRITE,IRP_MJ_CLOSE等不同的IRP。</p>
</li>
<li><p>其他类型的IRP</p>
<table>
<thead>
<tr>
<th>IRP类型</th>
<th>来源</th>
</tr>
</thead>
<tbody><tr>
<td><strong>IRP_MJ_DEVICE_CONTROL</strong></td>
<td>DeviceIoControl函数会产生此IRP</td>
</tr>
<tr>
<td>IRP_MJ_POWER</td>
<td>在操作系统处理电源信息时，产生此IRP</td>
</tr>
<tr>
<td>IRP_MJ_SHUTDOWN</td>
<td>关闭系统前会产生此IRP</td>
</tr>
<tr>
<td>IRP_MJ_CREATE</td>
<td>生成请求 CreateFile</td>
</tr>
<tr>
<td>IRP_MJ_QUERY_INFORMATION</td>
<td>查询请求</td>
</tr>
<tr>
<td>IRP_MJ_CLOSE</td>
<td>关闭请求 CloseHandle</td>
</tr>
<tr>
<td>IRP_MJ_SET_INFORMATION</td>
<td>设置请求</td>
</tr>
<tr>
<td>IRP_MJ_READ</td>
<td>从设备得到数据 ReadFile</td>
</tr>
<tr>
<td>IRP_MJ_WRITE</td>
<td>传送数据到设备 WriteFile</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/irp-major-function-codes">还有很多。。。</a></td>
<td>。。。</td>
</tr>
</tbody></table>
<p>IRP_MJ_DEVICE_CONTROL是我们用的最多的一种方式，比较灵活。可以拿到三环传过来的消息码，自己设定怎么处理(通过消息码确定)。</p>
</li>
<li><p>每个IRP都对应一个输入输出</p>
</li>
</ol>
<h5 id="IRP结构"><a href="#IRP结构" class="headerlink" title="IRP结构"></a>IRP结构</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IRP</span> &#123;</span></span><br><span class="line">	PMDL              MdlAddress;<span class="comment">//是一个MDL的指针，当内核层和用户层采用共享内存的结构传递数据的时候，这个MDL就代表共享的内存信息（共享物理内存，通过MDL映射）。这个成员生效的标记为：DO_DIRECT_IO, METHOD_IN_DIRECT 或者METHOD_OUT_DIRECT.</span></span><br><span class="line">	ULONG             Flags;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> _<span class="title">IRP</span>*   <span class="title">MasterIrp</span>;</span></span><br><span class="line">		PVOID          SystemBuffer;</span><br><span class="line">	&#125; AssociatedIrp;</span><br><span class="line">	IO_STATUS_BLOCK   IoStatus;</span><br><span class="line">	KPROCESSOR_MODE   RequestorMode;</span><br><span class="line">	BOOLEAN           PendingReturned;</span><br><span class="line">	BOOLEAN           Cancel;</span><br><span class="line">	KIRQL             CancelIrql;</span><br><span class="line">	PDRIVER_CANCEL    CancelRoutine;</span><br><span class="line">	PVOID             UserBuffer;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">				KDEVICE_QUEUE_ENTRY DeviceQueueEntry;</span><br><span class="line">				<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">					PVOID    DriverContext[<span class="number">4</span>];</span><br><span class="line">				&#125;;</span><br><span class="line">			&#125;;</span><br><span class="line">			PETHREAD     Thread;</span><br><span class="line">			LIST_ENTRY   ListEntry;</span><br><span class="line">		&#125; Overlay;</span><br><span class="line">	&#125; Tail;</span><br><span class="line">&#125; IRP, *PIRP;</span><br><span class="line"></span><br><span class="line">kd&gt; dt nt!_IRP</span><br><span class="line">   +<span class="number">0x000</span> Type             : Int2B</span><br><span class="line">   +<span class="number">0x002</span> Size             : Uint2B</span><br><span class="line">   +<span class="number">0x004</span> MdlAddress       : Ptr32 _MDL</span><br><span class="line">   +<span class="number">0x008</span> Flags            : Uint4B</span><br><span class="line">   +<span class="number">0x00c</span> AssociatedIrp    : &lt;unnamed-tag&gt;</span><br><span class="line">   +<span class="number">0x010</span> ThreadListEntry  : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x018</span> IoStatus         : _IO_STATUS_BLOCK</span><br><span class="line">   +<span class="number">0x020</span> RequestorMode    : Char</span><br><span class="line">   +<span class="number">0x021</span> PendingReturned  : UChar</span><br><span class="line">   +<span class="number">0x022</span> StackCount       : Char</span><br><span class="line">   +<span class="number">0x023</span> CurrentLocation  : Char</span><br><span class="line">   +<span class="number">0x024</span> Cancel           : UChar</span><br><span class="line">   +<span class="number">0x025</span> CancelIrql       : UChar</span><br><span class="line">   +<span class="number">0x026</span> ApcEnvironment   : Char</span><br><span class="line">   +<span class="number">0x027</span> AllocationFlags  : UChar</span><br><span class="line">   +<span class="number">0x028</span> UserIosb         : Ptr32 _IO_STATUS_BLOCK</span><br><span class="line">   +<span class="number">0x02c</span> UserEvent        : Ptr32 _KEVENT</span><br><span class="line">   +<span class="number">0x030</span> Overlay          : &lt;unnamed-tag&gt;</span><br><span class="line">   +<span class="number">0x038</span> CancelRoutine    : Ptr32     <span class="keyword">void</span> </span><br><span class="line">   +<span class="number">0x03c</span> UserBuffer       : Ptr32 Void</span><br><span class="line">   +<span class="number">0x040</span> Tail             : &lt;unnamed-tag&gt;</span><br></pre></td></tr></table></figure>

<p>每个IRP对应一个<code>IO_STACK_LOCATION结构</code>,通过下面的函数可以获取到此IRP对应的<code>IO_STACK_LOCATION结构</code></p>
<p><code>IoGetCurrentIrpStackLocation</code>返回一个指向IO_STACK_LOCATION结构的指针，该结构包含驱动程序的 I/O 堆栈位置</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202204241910209.jpeg" alt="IRP"></p>
<p><strong>上图为DeviceIoControl方式读写</strong>,如果是用ReadFile/WriteFile方式读写,应参考<a href="#%E8%AE%BE%E7%BD%AE%E4%BA%A4%E4%BA%92%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E5%BC%8F">设置交互数据的方式</a></p>
<p>注意information设置不正确.案例中,仅传一个整形数据时候,设置到99,导致蓝屏(吃了大亏)</p>
<h5 id="IO-STACK-LOCATION结构"><a href="#IO-STACK-LOCATION结构" class="headerlink" title="IO_STACK_LOCATION结构"></a>IO_STACK_LOCATION结构</h5><h4 id="派遣函数"><a href="#派遣函数" class="headerlink" title="派遣函数"></a>派遣函数</h4><h5 id="派遣函数在哪里注册呢？"><a href="#派遣函数在哪里注册呢？" class="headerlink" title="派遣函数在哪里注册呢？"></a>派遣函数在哪里注册呢？</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _DRIVER_OBJECT</span><br><span class="line">nt!_DRIVER_OBJECT</span><br><span class="line">   +<span class="number">0x000</span> Type             : Int2B</span><br><span class="line">   +<span class="number">0x002</span> Size             : Int2B</span><br><span class="line">   +<span class="number">0x004</span> DeviceObject     : Ptr32 _DEVICE_OBJECT</span><br><span class="line">   +<span class="number">0x008</span> Flags            : Uint4B</span><br><span class="line">   +<span class="number">0x00c</span> DriverStart      : Ptr32 Void</span><br><span class="line">   +<span class="number">0x010</span> DriverSize       : Uint4B</span><br><span class="line">....</span><br><span class="line">   +<span class="number">0x030</span> DriverStartIo    : Ptr32     <span class="keyword">void</span> </span><br><span class="line">   +<span class="number">0x034</span> DriverUnload     : Ptr32     <span class="keyword">void</span> 		<span class="comment">//卸载函数</span></span><br><span class="line">   +<span class="number">0x038</span> MajorFunction    : [<span class="number">28</span>] Ptr32     <span class="keyword">long</span> 	<span class="comment">//派遣函数</span></span><br><span class="line">   <span class="comment">//0编号的IRP对应的派遣函数的地址就存在MajorFunction[0]的位置。</span></span><br></pre></td></tr></table></figure>

<p>0编号的IRP对应的派遣函数的地址就存在MajorFunction[0]的位置。</p>
<h5 id="注册派遣函数"><a href="#注册派遣函数" class="headerlink" title="注册派遣函数"></a>注册派遣函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT pDriverObject, PUNICODE_STRING pReg)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="comment">//设置卸载函数   </span></span><br><span class="line">    pDriverObject-&gt;DriverUnload = 卸载函数;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//设置派遣函数   </span></span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_CREATE] 	= 派遣函数<span class="number">1</span>; <span class="comment">//一般都处理 对应用户层CreateFile</span></span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_CLOSE] 	= 派遣函数<span class="number">2</span>;  <span class="comment">//一般都处理  对应用户层CloseHandle</span></span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_WRITE] 	= 派遣函数<span class="number">3</span>;  </span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_READ] 	= 派遣函数<span class="number">4</span>;  </span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_CLEANUP] 	= 派遣函数<span class="number">5</span>;  </span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_SET_INFORMATION] 	= 派遣函数<span class="number">6</span>;  </span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] 	= 派遣函数<span class="number">7</span>;  <span class="comment">//一般都处理   对应用户层DeviceIoControl</span></span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_SHUTDOWN] 		= 派遣函数<span class="number">8</span>;  </span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_SYSTEM_CONTROL] 	= 派遣函数<span class="number">9</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//派遣函数1~9可以全都一个函数  NTSTATUS 函数名(PDEVICE_OBJECT pDevObj, PIRP pIrp) ,在函数内做区分处理</span></span><br></pre></td></tr></table></figure>

<p>IRP_MJ_MAXIMUM_FUNCTION  派遣函数的最大值宏</p>
<h4 id="派遣函数的格式"><a href="#派遣函数的格式" class="headerlink" title="派遣函数的格式"></a>派遣函数的格式</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">MyDispatchFunction</span><span class="params">(PDEVICE_OBJECT pDevObj, PIRP pIrp)</span><span class="comment">//PIRP为IRP报文数据结构指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//处理自己的业务...</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置返回状态,返回状态如果不设置，Ring3返回的是失败</span></span><br><span class="line">	pIrp-&gt;IoStatus.Status = STATUS_SUCCESS;	<span class="comment">//  三环getlasterror()得到的就是这个值</span></span><br><span class="line">	pIrp-&gt;IoStatus.Information = <span class="number">0</span>;		<span class="comment">//  返回给3环多少个字节的数据 没有填0</span></span><br><span class="line">	IoCompleteRequest(pIrp, IO_NO_INCREMENT);<span class="comment">//表示调用方已完成所有I/O请求处理操作，并将给定的 IRP 返回给 I/O 管理器。将IRP往下派发</span></span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//一个派遣函数处理所有情况:</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">DeviceIrpCtl</span><span class="params">(PDEVICE_OBJECT pDevObj, PIRP pIrp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  PIO_STACK_LOCATION irpStackL;</span><br><span class="line">  ULONG CtlCode;</span><br><span class="line">  ULONG InputBuffLength;</span><br><span class="line">  irpStackL=IoGetCurrentIrpStackLocation(pIrp);<span class="comment">//获取应用层传来的参数</span></span><br><span class="line">  <span class="keyword">switch</span>(irpStackL-&gt;MajorFunction)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> IRP_MJ_DEVICE_CONTROL:</span><br><span class="line">      DbgPrint(<span class="string">&quot;用户调用了DeviceIoControl!\n&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> IRP_MJ_CREATE:</span><br><span class="line">      DbgPrint(<span class="string">&quot;用户调用了CreateFile!\n&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> IRP_MJ_CLOSE;</span><br><span class="line">      DbgPrint(<span class="string">&quot;用户调用了CloseHandle!\n&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  pIrp-&gt;IoStatus.Status = STATUS_SUCCESS;</span><br><span class="line">  pIrp-&gt;IoStatus.Information = <span class="number">4</span>;<span class="comment">//返回给DeviceIoControl中的倒数第二个参数lpButesReturned</span></span><br><span class="line">  IoCompleteRequest(pIrp,IO_NO_INCREMENT);<span class="comment">//调用方已完成所有I/O请求处理操作,并且不增加优先级</span></span><br><span class="line">  <span class="keyword">return</span> STATUS_SUCCESS;<span class="comment">//返回成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ns-wdm-_irp">IRP结构详解</a></p>
<h5 id="IRP-MJ-DEVICE-CONTROL的派遣函数"><a href="#IRP-MJ-DEVICE-CONTROL的派遣函数" class="headerlink" title="IRP_MJ_DEVICE_CONTROL的派遣函数"></a><strong>IRP_MJ_DEVICE_CONTROL的派遣函数</strong></h5><h6 id="CTL操作码"><a href="#CTL操作码" class="headerlink" title="CTL操作码"></a>CTL操作码</h6><p>IRP_MJ_DEVICE_CONTROL用到的操作码是个复合数据，微软提供了一个<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/d4drvif/nf-d4drvif-ctl_code">宏CTL_CODE</a>来组合这个复合数据，如下定义方式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该宏的定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CTL_CODE( DeviceType, Function, Method, Access ) (                 \</span></span><br><span class="line"><span class="meta">    ((DeviceType) &lt;&lt; 16) | ((Access) &lt;&lt; 14) | ((Function) &lt;&lt; 2) | (Method) \</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="comment">//是个宏，按照函数讲解每个参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CTL_CODE</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">   DeviceType,<span class="comment">//驱动种类，一般是FILE_DEVICE_UNKNOWN</span></span></span></span><br><span class="line"><span class="params"><span class="function">   Function,<span class="comment">//提供一个数值，标识其独特性</span></span></span></span><br><span class="line"><span class="params"><span class="function">   Method,<span class="comment">//交互数据的方式(要与前面设定的一致)，METHOD_BUFFERED或METHOD_IN_DIRECT或METHOD_OUT_DIRECT或METHOD_NEITHER</span></span></span></span><br><span class="line"><span class="params"><span class="function">   Access<span class="comment">//权限，FILE_ANY_ACCESS表示全部权限，或FILE_READ_ACCESS或FILE_WRITE_ACCESS</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//定义实例：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE_READ CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,METHOD_BUFFERED,FILE_ANY_ACCESS)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE_WRITE CTL_CODE(FILE_DEVICE_UNKNOWN,0x900,METHOD_BUFFERED,FILE_ANY_ACCESS)</span></span><br></pre></td></tr></table></figure>

<h6 id="IRP-MJ-DEVICE-CONTROL的派遣函数编写"><a href="#IRP-MJ-DEVICE-CONTROL的派遣函数编写" class="headerlink" title="IRP_MJ_DEVICE_CONTROL的派遣函数编写"></a>IRP_MJ_DEVICE_CONTROL的派遣函数编写</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">ControlCallBack</span><span class="params">(PDEVICE_OBJECT pDevObj, PIRP pIrp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PIO_STACK_LOCATION psl = IoGetCurrentIrpStackLocation(pIrp);<span class="comment">//获取应用层传来的参数</span></span><br><span class="line">    ULONG code = psl-&gt;Parameters.DeviceIoControl.IoControlCode;<span class="comment">//获取派遣过来的CTL操作码</span></span><br><span class="line">    PVOID systemBuf = pIrp-&gt;AssociatedIrp.SystemBuffer;<span class="comment">//获取缓存地址(输入输出都靠这个地址)</span></span><br><span class="line">    ULONG inLen = psl-&gt;Parameters.DeviceIoControl.InputBufferLength;<span class="comment">//获取输入长度</span></span><br><span class="line">    ULONG outLen = psl-&gt;Parameters.DeviceIoControl.OutputBufferLength;<span class="comment">//获取输出长度</span></span><br><span class="line">    <span class="comment">//根据不同的CTL操作码做不同的处理</span></span><br><span class="line">    <span class="keyword">switch</span>(code)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> CODE_READ:<span class="comment">//注意是以三环视角来看其含义，三环想要读</span></span><br><span class="line">            <span class="comment">//执行想做的事情</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> CODE_WRITE:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    IoCompleteRequest(pIrp, IO_NO_INCREMENT);<span class="comment">//表示调用方已完成所有I/O请求处理操作，并将给定的 IRP 返回给 I/O 管理器。将IRP往下派发</span></span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-iogetcurrentirpstacklocation">IoGetCurrentIrpStackLocation详解</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ns-wdm-_io_stack_location">PIO_STACK_LOCATION结构详解</a></li>
</ul>
<h6 id="三环写法"><a href="#三环写法" class="headerlink" title="三环写法"></a>三环写法</h6><p><strong><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a>函数结构</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">DeviceIoControl</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE       hDevice,<span class="comment">//设备句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD        dwIoControlCode,<span class="comment">//CTL操作码</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPVOID       lpInBuffer,<span class="comment">//三环给零环的数据的地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD        nInBufferSize,<span class="comment">//三环给零环多少字节数据</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPVOID       lpOutBuffer,<span class="comment">//零环给三环的数据到的地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD        nOutBufferSize,<span class="comment">//零环给三环多少字节数据</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPDWORD      lpBytesReturned,<span class="comment">//零环给三环实际多少字节数据</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPOVERLAPPED lpOverlapped<span class="comment">//异步相关，一般填NULL，略</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>内核通信，需要头文件<code>#include &lt;WinIoCtl.h&gt;</code></p>
<p>并且<strong>WinIoCtl.h必须定义到Windows.h的后面</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE_READ CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,METHOD_BUFFERED,FILE_ANY_ACCESS)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE_WRITE CTL_CODE(FILE_DEVICE_UNKNOWN,0x900,METHOD_BUFFERED,FILE_ANY_ACCESS)<span class="comment">//基本上都是用METHOD_BUFFERED这种方式</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打开设备</span></span><br><span class="line"><span class="function">BOOLEAN <span class="title">openDevice</span><span class="params">(HANDLE *handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE _handle = CreateFileA(<span class="string">&quot;\\\\.\\MyTestDriver&quot;</span>,GENERIC_READ|GENERIC_WRITE,<span class="number">0</span>,<span class="literal">NULL</span>,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,<span class="literal">NULL</span>);<span class="comment">//打开设备对象句柄</span></span><br><span class="line">    *handle=_handle;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">int</span>)_handle&gt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭设备</span></span><br><span class="line">CloseHandle(handle);</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送IRP_MJ_DEVICE_CONTROL</span></span><br><span class="line"><span class="function">BOOLEAN <span class="title">sendCode</span><span class="params">(HANDLE hDevice,DWORD code,PVOID inData,ULONG Inlen,PVOID outData,ULONG outLen,LPDWORD resultLen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DeviceIoControl(hDevice,code,inData,Inlen,outData,outLen,resultLen,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>0-3环常规通信框架：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE_CHANGE CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,METHOD_BUFFERED,FILE_ANY_ACCESS)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE_RESUME CTL_CODE(FILE_DEVICE_UNKNOWN,0x900,METHOD_BUFFERED,FILE_ANY_ACCESS)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE_READ CTL_CODE(FILE_DEVICE_UNKNOWN,0x1000,METHOD_BUFFERED,FILE_ANY_ACCESS)</span></span><br><span class="line">UNICODE_STRING SymbolicLinkName;</span><br><span class="line"></span><br><span class="line"><span class="comment">//卸载函数</span></span><br><span class="line"><span class="function">VOID <span class="title">DriverUnload</span><span class="params">(PDRIVER_OBJECT driver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DbgPrint(<span class="string">&quot;停止运行了\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">MyCreateDispatchFunction</span><span class="params">(PDEVICE_OBJECT pDevObj, PIRP pIrp)</span><span class="comment">//PIRP为IRP报文数据结构指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//处理自己的业务...</span></span><br><span class="line">	DbgPrint(<span class="string">&quot;三环连接成功\n&quot;</span>);</span><br><span class="line">	<span class="comment">//设置返回状态,返回状态如果不设置，Ring3返回的是失败</span></span><br><span class="line">	pIrp-&gt;IoStatus.Status = STATUS_SUCCESS;	<span class="comment">//  三环getlasterror()得到的就是这个值</span></span><br><span class="line">	pIrp-&gt;IoStatus.Information = <span class="number">0</span>;		<span class="comment">//  返回给3环多少个字节的数据 没有填0</span></span><br><span class="line">	IoCompleteRequest(pIrp, IO_NO_INCREMENT);<span class="comment">//表示调用方已完成所有I/O请求处理操作，并将给定的 IRP 返回给 I/O 管理器。将IRP往下派发</span></span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">NTSTATUS <span class="title">MyCloseDispatchFunction</span><span class="params">(PDEVICE_OBJECT pDevObj, PIRP pIrp)</span><span class="comment">//PIRP为IRP报文数据结构指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//处理自己的业务...</span></span><br><span class="line">	DbgPrint(<span class="string">&quot;三环断开连接成功\n&quot;</span>);</span><br><span class="line">	<span class="comment">//设置返回状态,返回状态如果不设置，Ring3返回的是失败</span></span><br><span class="line">	pIrp-&gt;IoStatus.Status = STATUS_SUCCESS;	<span class="comment">//  三环getlasterror()得到的就是这个值</span></span><br><span class="line">	pIrp-&gt;IoStatus.Information = <span class="number">0</span>;		<span class="comment">//  返回给3环多少个字节的数据 没有填0</span></span><br><span class="line">	IoCompleteRequest(pIrp, IO_NO_INCREMENT);<span class="comment">//表示调用方已完成所有I/O请求处理操作，并将给定的 IRP 返回给 I/O 管理器。将IRP往下派发</span></span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ULONG current = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">ControlCallBack</span><span class="params">(PDEVICE_OBJECT pDevObj, PIRP pIrp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	PIO_STACK_LOCATION psl = IoGetCurrentIrpStackLocation(pIrp);</span><br><span class="line">	ULONG code = psl-&gt;Parameters.DeviceIoControl.IoControlCode;<span class="comment">//获取派遣过来的CTL操作码</span></span><br><span class="line">	PVOID systemBuf = pIrp-&gt;AssociatedIrp.SystemBuffer;<span class="comment">//获取缓存地址(输入输出都靠这个地址)</span></span><br><span class="line">	ULONG inLen = psl-&gt;Parameters.DeviceIoControl.InputBufferLength;<span class="comment">//获取输入长度</span></span><br><span class="line">	ULONG outLen = psl-&gt;Parameters.DeviceIoControl.OutputBufferLength;<span class="comment">//获取输出长度</span></span><br><span class="line">	<span class="comment">//根据不同的CTL操作码做不同的处理</span></span><br><span class="line">	<span class="keyword">switch</span> (code)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> CODE_CHANGE:<span class="comment">//注意是以三环视角来看其含义，初始化</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> CODE_RESUME:<span class="comment">//三环想要反初始化</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> CODE_READ:</span><br><span class="line"></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	IoCompleteRequest(pIrp, IO_NO_INCREMENT);<span class="comment">//表示调用方已完成所有I/O请求处理操作，并将给定的 IRP 返回给 I/O 管理器。将IRP往下派发</span></span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//入口函数，相当于main函数</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT pdriver, PUNICODE_STRING pReg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//设置一个卸载函数，用于退出</span></span><br><span class="line">	pdriver-&gt;DriverUnload = DriverUnload;</span><br><span class="line">	<span class="comment">//创建设备名称</span></span><br><span class="line">	UNICODE_STRING Devicename;</span><br><span class="line">	RtlInitUnicodeString(&amp;Devicename, <span class="string">L&quot;\\Device\\MyDevice&quot;</span>);</span><br><span class="line">	<span class="comment">//设备对象指针，用于接受</span></span><br><span class="line">	PDEVICE_OBJECT pDeviceObj = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//创建设备</span></span><br><span class="line">	NTSTATUS status = IoCreateDevice(pdriver,<span class="number">0</span>,&amp;Devicename,FILE_DEVICE_UNKNOWN,FILE_DEVICE_SECURE_OPEN,TRUE,&amp;pDeviceObj	);</span><br><span class="line">	<span class="keyword">if</span> (!NT_SUCCESS(status))<span class="comment">//NT_SUCCESS,微软提供的，实际上就是判断status是否大于等于0</span></span><br><span class="line">	&#123;</span><br><span class="line">		DbgPrint(<span class="string">&quot;创建设备失败!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> status;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果前面创建设备对象成功，就设置交互数据的方式</span></span><br><span class="line">	pDeviceObj-&gt;Flags |= DO_BUFFERED_IO;</span><br><span class="line">	<span class="comment">//创建符号链接名称</span></span><br><span class="line">	RtlInitUnicodeString(&amp;SymbolicLinkName, <span class="string">L&quot;\\??\\MyTestDriver&quot;</span>);</span><br><span class="line">	status = IoCreateSymbolicLink(&amp;SymbolicLinkName, &amp;Devicename);</span><br><span class="line">	<span class="keyword">if</span> (!NT_SUCCESS(status))</span><br><span class="line">	&#123;</span><br><span class="line">		DbgPrint(<span class="string">&quot;创建符号链接失败!\n&quot;</span>);</span><br><span class="line">		IoDeleteDevice(pDeviceObj);<span class="comment">//删除设备</span></span><br><span class="line">		<span class="keyword">return</span> status;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置派遣函数   </span></span><br><span class="line">	pdriver-&gt;MajorFunction[IRP_MJ_CREATE] = MyCreateDispatchFunction;</span><br><span class="line">	pdriver-&gt;MajorFunction[IRP_MJ_CLOSE] = MyCloseDispatchFunction;</span><br><span class="line">	pdriver-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = ControlCallBack;</span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="IRP-MJ-DEVICE-CONTROL交互数据实验"><a href="#IRP-MJ-DEVICE-CONTROL交互数据实验" class="headerlink" title="IRP_MJ_DEVICE_CONTROL交互数据实验"></a>IRP_MJ_DEVICE_CONTROL交互数据实验</h3><h4 id="R0代码："><a href="#R0代码：" class="headerlink" title="R0代码："></a>R0代码：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE_READ CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,METHOD_BUFFERED,FILE_ANY_ACCESS)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE_WRITE CTL_CODE(FILE_DEVICE_UNKNOWN,0x900,METHOD_BUFFERED,FILE_ANY_ACCESS)</span></span><br><span class="line">UNICODE_STRING SymbolicLinkName;</span><br><span class="line"></span><br><span class="line"><span class="comment">//卸载函数</span></span><br><span class="line"><span class="function">VOID <span class="title">DriverUnload</span><span class="params">(PDRIVER_OBJECT driver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//删除设备对象</span></span><br><span class="line">	<span class="keyword">if</span> (driver-&gt;DeviceObject)</span><br><span class="line">	&#123;</span><br><span class="line">		IoDeleteDevice(driver-&gt;DeviceObject);<span class="comment">//设备对象已挂载在driver中</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (SymbolicLinkName.Length&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		IoDeleteSymbolicLink(&amp;SymbolicLinkName);</span><br><span class="line">	&#125;</span><br><span class="line">	DbgPrint(<span class="string">&quot;停止运行了\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">MyCreateDispatchFunction</span><span class="params">(PDEVICE_OBJECT pDevObj, PIRP pIrp)</span><span class="comment">//PIRP为IRP报文数据结构指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//处理自己的业务...</span></span><br><span class="line">	DbgPrint(<span class="string">&quot;三环连接成功\n&quot;</span>);</span><br><span class="line">	<span class="comment">//设置返回状态,返回状态如果不设置，Ring3返回的是失败</span></span><br><span class="line">	pIrp-&gt;IoStatus.Status = STATUS_SUCCESS;	<span class="comment">//  三环getlasterror()得到的就是这个值</span></span><br><span class="line">	pIrp-&gt;IoStatus.Information = <span class="number">0</span>;		<span class="comment">//  返回给3环多少个字节的数据 没有填0</span></span><br><span class="line">	IoCompleteRequest(pIrp, IO_NO_INCREMENT);<span class="comment">//表示调用方已完成所有I/O请求处理操作，并将给定的 IRP 返回给 I/O 管理器。将IRP往下派发</span></span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">NTSTATUS <span class="title">MyCloseDispatchFunction</span><span class="params">(PDEVICE_OBJECT pDevObj, PIRP pIrp)</span><span class="comment">//PIRP为IRP报文数据结构指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//处理自己的业务...</span></span><br><span class="line">	DbgPrint(<span class="string">&quot;三环断开连接成功\n&quot;</span>);</span><br><span class="line">	<span class="comment">//设置返回状态,返回状态如果不设置，Ring3返回的是失败</span></span><br><span class="line">	pIrp-&gt;IoStatus.Status = STATUS_SUCCESS;	<span class="comment">//  三环getlasterror()得到的就是这个值</span></span><br><span class="line">	pIrp-&gt;IoStatus.Information = <span class="number">0</span>;		<span class="comment">//  返回给3环多少个字节的数据 没有填0</span></span><br><span class="line">	IoCompleteRequest(pIrp, IO_NO_INCREMENT);<span class="comment">//表示调用方已完成所有I/O请求处理操作，并将给定的 IRP 返回给 I/O 管理器。将IRP往下派发</span></span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">ControlCallBack</span><span class="params">(PDEVICE_OBJECT pDevObj, PIRP pIrp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	PIO_STACK_LOCATION psl = IoGetCurrentIrpStackLocation(pIrp);</span><br><span class="line">	ULONG code = psl-&gt;Parameters.DeviceIoControl.IoControlCode;<span class="comment">//获取派遣过来的CTL操作码</span></span><br><span class="line">	PVOID systemBuf = pIrp-&gt;AssociatedIrp.SystemBuffer;<span class="comment">//获取缓存地址(输入输出都靠这个地址)</span></span><br><span class="line">	ULONG inLen = psl-&gt;Parameters.DeviceIoControl.InputBufferLength;<span class="comment">//获取输入长度</span></span><br><span class="line">	ULONG outLen = psl-&gt;Parameters.DeviceIoControl.OutputBufferLength;<span class="comment">//获取输出长度</span></span><br><span class="line">	<span class="comment">//根据不同的CTL操作码做不同的处理</span></span><br><span class="line">	<span class="keyword">switch</span> (code)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> CODE_READ:<span class="comment">//注意是以三环视角来看其含义，三环想要读</span></span><br><span class="line">		<span class="comment">//把1234567传给三环读</span></span><br><span class="line">		<span class="built_in">memcpy</span>(systemBuf, <span class="string">&quot;1234567&quot;</span>, <span class="keyword">sizeof</span>(<span class="string">&quot;1234567&quot;</span>));</span><br><span class="line">		<span class="comment">//把零环写入的长度传给三环</span></span><br><span class="line">		pIrp-&gt;IoStatus.Information = <span class="keyword">sizeof</span>(<span class="string">&quot;1234567&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> CODE_WRITE:</span><br><span class="line">		<span class="comment">//打印三环写入的信息</span></span><br><span class="line">		DbgPrint(<span class="string">&quot;派遣函数:三环传入的信息：%s\n&quot;</span>,<span class="comment">/*(char*)*/</span>systemBuf);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	IoCompleteRequest(pIrp, IO_NO_INCREMENT);<span class="comment">//表示调用方已完成所有I/O请求处理操作，并且不增加优先级,并将给定的 IRP 返回给 I/O 管理器。将IRP往下派发</span></span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入口函数，相当于main函数</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT pdriver, PUNICODE_STRING pReg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//设置一个卸载函数，用于退出</span></span><br><span class="line">	pdriver-&gt;DriverUnload = DriverUnload;</span><br><span class="line">	<span class="comment">//创建设备名称</span></span><br><span class="line">	UNICODE_STRING Devicename;</span><br><span class="line">	RtlInitUnicodeString(&amp;Devicename, <span class="string">L&quot;\\Device\\MyDevice&quot;</span>);</span><br><span class="line">	<span class="comment">//设备对象指针，用于接受</span></span><br><span class="line">	PDEVICE_OBJECT pDeviceObj = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//创建设备</span></span><br><span class="line">	NTSTATUS status = IoCreateDevice(pdriver,<span class="number">0</span>,&amp;Devicename,FILE_DEVICE_UNKNOWN,FILE_DEVICE_SECURE_OPEN,TRUE,&amp;pDeviceObj	);</span><br><span class="line">	<span class="keyword">if</span> (!NT_SUCCESS(status))<span class="comment">//NT_SUCCESS,微软提供的，实际上就是判断status是否大于等于0</span></span><br><span class="line">	&#123;</span><br><span class="line">		DbgPrint(<span class="string">&quot;创建设备失败!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> status;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果前面创建设备对象成功，就设置交互数据的方式.其实此代码可以不设置,因为项目未使用ReadFile和WriteFile来通信,而是使用DeviceIoControl.</span></span><br><span class="line">	pDeviceObj-&gt;Flags |= DO_BUFFERED_IO;</span><br><span class="line">	<span class="comment">//创建符号链接名称</span></span><br><span class="line">	RtlInitUnicodeString(&amp;SymbolicLinkName, <span class="string">L&quot;\\??\\MyTestDriver&quot;</span>);</span><br><span class="line">	status = IoCreateSymbolicLink(&amp;SymbolicLinkName, &amp;Devicename);</span><br><span class="line">	<span class="keyword">if</span> (!NT_SUCCESS(status))</span><br><span class="line">	&#123;</span><br><span class="line">		DbgPrint(<span class="string">&quot;创建符号链接失败!\n&quot;</span>);</span><br><span class="line">		IoDeleteDevice(pDeviceObj);<span class="comment">//删除设备</span></span><br><span class="line">		<span class="keyword">return</span> status;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置派遣函数   </span></span><br><span class="line">	pdriver-&gt;MajorFunction[IRP_MJ_CREATE] = MyCreateDispatchFunction;</span><br><span class="line">	pdriver-&gt;MajorFunction[IRP_MJ_CLOSE] = MyCloseDispatchFunction;</span><br><span class="line">	pdriver-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = ControlCallBack;</span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="R3代码："><a href="#R3代码：" class="headerlink" title="R3代码："></a>R3代码：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;WinIoCtl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE_READ CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,METHOD_BUFFERED,FILE_ANY_ACCESS)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE_WRITE CTL_CODE(FILE_DEVICE_UNKNOWN,0x900,METHOD_BUFFERED,FILE_ANY_ACCESS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打开设备</span></span><br><span class="line"><span class="function">BOOLEAN <span class="title">openDevice</span><span class="params">(HANDLE *handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HANDLE _handle = CreateFileA(<span class="string">&quot;\\\\.\\MyTestDriver&quot;</span>, GENERIC_READ | GENERIC_WRITE, <span class="number">0</span>, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);<span class="comment">//打开设备对象句柄</span></span><br><span class="line">	*handle = _handle;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">int</span>)_handle &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//发送IRP_MJ_DEVICE_CONTROL</span></span><br><span class="line"><span class="function">BOOLEAN <span class="title">sendCode</span><span class="params">(HANDLE hDevice, DWORD code, PVOID inData, ULONG Inlen, PVOID outData, ULONG outLen, LPDWORD resultLen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> DeviceIoControl(hDevice, code, inData, Inlen, outData, outLen, resultLen, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HANDLE hDevice;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">30</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	DWORD realReaded = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!openDevice(&amp;hDevice))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;打开设备对象失败!\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//写数据给R0！！！！！！！！！！！！！！！！！！！！！！</span></span><br><span class="line">	<span class="built_in">memcpy</span>(buf,<span class="string">&quot;i am R3&quot;</span>,<span class="keyword">sizeof</span>(<span class="string">&quot;i am R3&quot;</span>));</span><br><span class="line">	sendCode(hDevice, CODE_WRITE, buf, <span class="number">30</span>, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;realReaded);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//读R0数据	！！！！！！！！！！！！！！！！！！！！！！</span></span><br><span class="line">	<span class="comment">//sendCode(hDevice, CODE_READ, NULL, 0, buf, 30, &amp;realReaded);</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;读到：%s\r\n&quot;</span>, buf);</span><br><span class="line">	CloseHandle(hDevice);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写数据结果如图：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210829212010210.png" alt="image-20210829212010210"></p>
<p>将<code>写数据给R0</code>代码注释，放开<code>读R0数据</code>的代码，结果如图：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210829212159461.png" alt="image-20210829212159461"></p>
<h2 id="驱动加载"><a href="#驱动加载" class="headerlink" title="驱动加载"></a>驱动加载</h2><p>需要头文件 <code>#include &lt;winsvc.h&gt;</code></p>
<p><strong>加载驱动过程</strong></p>
<ol>
<li>用OpenSCManager打开服务控制管理器</li>
<li>用CreateService创建对应服务</li>
<li>如果驱动服务已经创建过,则用OpenService打开服务</li>
<li>用StartService加载启动驱动服务</li>
<li>用QueryServiceStatus获得服务的当前状态</li>
<li>用ControlService停止,暂停,恢复服务</li>
<li>用DeleteService卸载驱动</li>
<li>清理工作,用CloseServiceHandle关闭释放句柄</li>
</ol>
<h3 id="驱动注册-安装"><a href="#驱动注册-安装" class="headerlink" title="驱动注册/安装"></a>驱动注册/安装</h3><h4 id="OpenSCManagerA函数"><a href="#OpenSCManagerA函数" class="headerlink" title="OpenSCManagerA函数"></a><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/win32/api/winsvc/nf-winsvc-openscmanagera">OpenSCManagerA函数</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果函数成功，则返回值是指定服务控制管理器数据库的句柄。</span></span><br><span class="line"><span class="comment">//如果函数失败，则返回值为 NULL。</span></span><br><span class="line"><span class="comment">//打开服务管理器</span></span><br><span class="line"><span class="function">SC_HANDLE <span class="title">OpenSCManagerA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR lpMachineName,<span class="comment">//目标计算机的名称。如果指针为 NULL 或指向空字符串，则该函数连接到本地计算机上的服务控制管理器。</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR lpDatabaseName,<span class="comment">//服务控制管理器数据库的名称。此参数应设置为 SERVICES_ACTIVE_DATABASE。如果为 NULL，则打开活动数据库 SERVICES_ACTIVE_DATABASE 数据库。</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD  dwDesiredAccess<span class="comment">//权限，SC_MANAGER_ALL_ACCESS 表示所有权限;还有诸如创建服务,枚举服务权限等</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="创建服务CreateServiceA函数"><a href="#创建服务CreateServiceA函数" class="headerlink" title="创建服务CreateServiceA函数"></a>创建服务<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/win32/api/winsvc/nf-winsvc-createservicea">CreateServiceA函数</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果函数成功，则返回值是服务的句柄。</span></span><br><span class="line"><span class="comment">//如果函数失败，则返回值为 NULL。</span></span><br><span class="line"><span class="function">SC_HANDLE <span class="title">CreateServiceA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  SC_HANDLE hSCManager,<span class="comment">//服务管理器句柄,一般从OpenSCManagerA的返回值获取</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR    lpServiceName,<span class="comment">//这个服务在注册表中的名字(名字唯一性);服务唯一标识,一般取的是可执行文件名(不带后缀)</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR    lpDisplayName,<span class="comment">//注册表驱动程序的DisplayName值,显示给别人看的名字(名字不唯一)</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD     dwDesiredAccess,<span class="comment">//服务的访问权限，SERVICE_ALL_ACCESS表示所有权限</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD     dwServiceType,<span class="comment">//创建什么类型的服务，SERVICE_KERNEL_DRIVER表示内核驱动服务,即表示加载的服务是驱动程序</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD     dwStartType,<span class="comment">//创建服务的启动类型，SERVICE_BOOT_START开机启动服务，SERVICE_AUTO_START自动启动服务，SERVICE_DEMAND_START按需启动，即当进程调用StartService函数时由服务控制管理器启动的服务 。</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD     dwErrorControl,<span class="comment">//注册表服务的ErrorControl(错误控制).如果此服务无法启动，则错误的严重性以及采取的措施。SERVICE_ERROR_NORMAL表示启动程序在事件日志中记录错误，但继续启动操作。</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR    lpBinaryPathName,<span class="comment">//服务对应的可执行程序的全路径  如驱动服务:C:\\222\1.sys)。可用GetFullPathNameA函数以及可执行文件名获取</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">//后面都为NULL就可以了</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR    lpLoadOrderGroup,<span class="comment">//服务所在分组的名字</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPDWORD   lpdwTagId,<span class="comment">//分组内该服务的启动顺序</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR    lpDependencies,<span class="comment">//需要依赖其他服务名的列表</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR    lpServiceStartName,<span class="comment">//加上下面哪个,表示以什么身份启动服务</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR    lpPassword</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>CreateServiceA</code>函数执行后,<code>GetLastError()</code>如果为<code>ERROR_SERVICE_EXISTS</code>,则调用<code>OpenService</code></p>
<p><strong>关闭服务句柄</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CloseServiceHandle(serviceHandle);<span class="comment">//serviceHandle为某服务的句柄</span></span><br><span class="line"><span class="comment">//也可以直接调用CloseHandle(serviceHandle);CloseServiceHandle还是会调用CloseHandle</span></span><br></pre></td></tr></table></figure>

<h3 id="驱动启动"><a href="#驱动启动" class="headerlink" title="驱动启动"></a>驱动启动</h3><h4 id="打开服务OpenServiceA函数"><a href="#打开服务OpenServiceA函数" class="headerlink" title="打开服务OpenServiceA函数"></a>打开服务<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/win32/api/winsvc/nf-winsvc-openservicea">OpenServiceA函数</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SC_HANDLE <span class="title">OpenServiceA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  SC_HANDLE hSCManager,<span class="comment">//服务管理器句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR    lpServiceName,<span class="comment">//服务名字，根据这个服务名字找服务</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD     dwDesiredAccess<span class="comment">//权限，SC_MANAGER_ALL_ACCESS表示所有权限</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="开始服务StartServiceA函数"><a href="#开始服务StartServiceA函数" class="headerlink" title="开始服务StartServiceA函数"></a>开始服务<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/winsvc/nf-winsvc-startservicea">StartServiceA函数</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果函数成功，则返回值非零。</span></span><br><span class="line"><span class="comment">//如果函数失败，则返回值为零。</span></span><br><span class="line"><span class="function">BOOL <span class="title">StartServiceA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  SC_HANDLE hService,<span class="comment">//服务句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">//服务函数的参数相关</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD     dwNumServiceArgs,<span class="comment">//参数字节数，没有填0</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR    *lpServiceArgVectors<span class="comment">//如果没有参数，则此参数可以为 NULL。</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="停止驱动"><a href="#停止驱动" class="headerlink" title="停止驱动"></a>停止驱动</h3><p>OpenServiceA后ControlService</p>
<h4 id="控制服务ControlService函数"><a href="#控制服务ControlService函数" class="headerlink" title="控制服务ControlService函数"></a>控制服务<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/winsvc/nf-winsvc-controlservice">ControlService函数</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果函数成功，则返回值非零。</span></span><br><span class="line"><span class="comment">//如果函数失败，则返回值为零。</span></span><br><span class="line"><span class="function">BOOL <span class="title">ControlService</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  SC_HANDLE        hService,<span class="comment">//服务句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD            dwControl,<span class="comment">//控制码,可以停止/暂停/恢复服务，其中SERVICE_CONTROL_STOP表示停止服务的控制码</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPSERVICE_STATUS lpServiceStatus<span class="comment">//指向SERVICE_STATUS结构的指针，该结构接收最新的服务状态信息。返回的信息反映了服务向服务控制管理器报告的最新状态。仅当GetLastError返回以下错误代码之一时，服务控制管理器才会填充结构 ：NO_ERROR、ERROR_INVALID_SERVICE_CONTROL、 ERROR_SERVICE_CANNOT_ACCEPT_CTRL或 ERROR_SERVICE_NOT_ACTIVE。否则，不填充结构。</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="卸载驱动"><a href="#卸载驱动" class="headerlink" title="卸载驱动"></a>卸载驱动</h3><p>OpenServiceA后DeleteService</p>
<p>删除服务<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/winsvc/nf-winsvc-deleteservice">DeleteService函数</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果函数成功，则返回值非零。</span></span><br><span class="line"><span class="comment">//如果函数失败，则返回值为零。</span></span><br><span class="line"><span class="function">BOOL <span class="title">DeleteService</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  SC_HANDLE hService<span class="comment">//服务句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="驱动加载-启动-停止-卸载案例"><a href="#驱动加载-启动-停止-卸载案例" class="headerlink" title="驱动加载/启动/停止/卸载案例"></a>驱动加载/启动/停止/卸载案例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载驱动封装函数   lpszDriverName是不带后缀的服务唯一标识,sysFileName是带后缀的驱动文件名</span></span><br><span class="line"><span class="function">BOOL <span class="title">loadDriver</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* lpszDriverName, <span class="keyword">const</span> <span class="keyword">char</span>* sysFileName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//用于保存.sys的全路径名,得到完整的驱动路径</span></span><br><span class="line">	<span class="keyword">char</span> szDriverImagePath[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	GetFullPathNameA(sysFileName, <span class="number">256</span>, szDriverImagePath, <span class="literal">NULL</span>);</span><br><span class="line">	myOutPutDebug(<span class="string">&quot;加载驱动的全路径名:%s&quot;</span>, szDriverImagePath);</span><br><span class="line">	SC_HANDLE hMgr = OpenSCManagerA(<span class="literal">NULL</span>, <span class="literal">NULL</span>, SC_MANAGER_ALL_ACCESS);</span><br><span class="line">	<span class="keyword">if</span> (!hMgr)</span><br><span class="line">	&#123;</span><br><span class="line">		myOutPutDebug(<span class="string">&quot;OpenSCManagerA失败 ERROR:%d&quot;</span>,GetLastError());</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	SC_HANDLE hSve = CreateServiceA(hMgr,</span><br><span class="line">		lpszDriverName,<span class="comment">//驱动在注册表中的名字</span></span><br><span class="line">		lpszDriverName,<span class="comment">//注册表驱动程序的DisplayName值</span></span><br><span class="line">		SERVICE_START,<span class="comment">//加载驱动程序的访问权限,SERVICE_START 或者 SERVICE_ALL_ACCESS</span></span><br><span class="line">		SERVICE_KERNEL_DRIVER,<span class="comment">//表示加载的服务是驱动程序</span></span><br><span class="line">		SERVICE_DEMAND_START,<span class="comment">//注册表驱动程序的Start值   //指定当进程调用StartService函数时由服务控制管理器启动的服务</span></span><br><span class="line">		SERVICE_ERROR_NORMAL,<span class="comment">//SERVICE_ERROR_IGNORE   //注册表驱动程序的ErrorControl值</span></span><br><span class="line">		szDriverImagePath,<span class="comment">//szDriverImagePath注册表驱动程序的全路径  如:C:\\222\1.sys   通过GetFullPathNameA函数获取</span></span><br><span class="line">		<span class="literal">NULL</span>,<span class="comment">//GroupOrder HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\GroupOrderList</span></span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		<span class="literal">NULL</span></span><br><span class="line">	);</span><br><span class="line">	<span class="keyword">if</span> (GetLastError()==ERROR_SERVICE_EXISTS)<span class="comment">//服务已经存在的话,直接打开该服务</span></span><br><span class="line">	&#123;</span><br><span class="line">		hSve = OpenServiceA(hMgr, lpszDriverName, SERVICE_START);</span><br><span class="line">	&#125;</span><br><span class="line">	myOutPutDebug(<span class="string">&quot;hSve:%X&quot;</span>, hSve);</span><br><span class="line">	<span class="comment">//此处可以用QueryServiceStatus查询服务状态,来判断是否需要开启服务,可能已经开启了</span></span><br><span class="line">	<span class="keyword">bool</span> bRet = StartServiceW(hSve, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (hSve)</span><br><span class="line">	&#123;</span><br><span class="line">		CloseServiceHandle(hSve);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(hMgr)</span><br><span class="line">	&#123;</span><br><span class="line">		CloseServiceHandle(hMgr);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//卸载驱动封装函数</span></span><br><span class="line"><span class="function">BOOL <span class="title">UnloadDriver</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* lpszDriverName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BOOL bRet = FALSE;</span><br><span class="line">	SC_HANDLE hMgr = <span class="literal">NULL</span>;<span class="comment">//SCM管理器的句柄</span></span><br><span class="line">	SC_HANDLE hSve = <span class="literal">NULL</span>;<span class="comment">//NT驱动程序的服务句柄</span></span><br><span class="line">	SERVICE_STATUS SveSta;</span><br><span class="line">	hMgr = OpenSCManagerA(<span class="literal">NULL</span>, <span class="literal">NULL</span>, SC_MANAGER_ALL_ACCESS);</span><br><span class="line">	<span class="keyword">if</span> (!hMgr)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//打开失败</span></span><br><span class="line">		bRet = FALSE;</span><br><span class="line">		<span class="keyword">goto</span> BeforeLeave;</span><br><span class="line">	&#125;</span><br><span class="line">	hSve = OpenServiceA(hMgr, lpszDriverName, SERVICE_ALL_ACCESS);</span><br><span class="line">	<span class="keyword">if</span> (!hSve)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//打开失败</span></span><br><span class="line">		bRet = FALSE;</span><br><span class="line">		<span class="keyword">goto</span> BeforeLeave;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//停止服务</span></span><br><span class="line">	<span class="keyword">if</span> (!ControlService(hSve,SERVICE_CONTROL_STOP,&amp;SveSta))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 停止失败</span></span><br><span class="line">		bRet = FALSE;</span><br><span class="line">		<span class="keyword">goto</span> BeforeLeave;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//卸载服务</span></span><br><span class="line">	<span class="keyword">if</span> (!DeleteService(hSve))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 卸载失败</span></span><br><span class="line">		bRet = FALSE;</span><br><span class="line">		<span class="keyword">goto</span> BeforeLeave;</span><br><span class="line">	&#125;</span><br><span class="line">	bRet = TRUE;</span><br><span class="line">BeforeLeave:</span><br><span class="line">	<span class="keyword">if</span> (hSve)</span><br><span class="line">	&#123;</span><br><span class="line">		CloseServiceHandle(hSve);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (hMgr)</span><br><span class="line">	&#123;</span><br><span class="line">		CloseServiceHandle(hMgr);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面两个函数依赖的调试信息输出函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myOutPutDebug</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pszFormat, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> szbufFormat[<span class="number">0x1000</span>];</span><br><span class="line">	<span class="keyword">char</span> szbufFormat_withHead[<span class="number">0x1100</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	va_list argList;</span><br><span class="line">	va_start(argList, pszFormat);</span><br><span class="line">	vsprintf_s(szbufFormat, pszFormat, argList);</span><br><span class="line">	strcat_s(szbufFormat_withHead, <span class="string">&quot;zeroko: &quot;</span>);<span class="comment">// 加上本人输出头特征</span></span><br><span class="line">	strcat_s(szbufFormat_withHead, szbufFormat);</span><br><span class="line">	OutputDebugStringA(szbufFormat_withHead);<span class="comment">// 编码转换</span></span><br><span class="line">	va_end(argList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载驱动函数使用案例:</span></span><br><span class="line">loadDriver(<span class="string">&quot;driverKMDFempty&quot;</span>, <span class="string">&quot;driverKMDFempty.sys&quot;</span>);</span><br><span class="line"><span class="comment">//卸载驱动函数使用案例:</span></span><br><span class="line">UnloadDriver(<span class="string">&quot;driverKMDFempty&quot;</span>);</span><br></pre></td></tr></table></figure>





<h2 id="全局监听API实验"><a href="#全局监听API实验" class="headerlink" title="全局监听API实验"></a>全局监听API实验</h2><ol>
<li>自己加载驱动</li>
<li>写拷贝(段页知识)</li>
<li>R3,R0通信</li>
<li>写HOOK</li>
<li>ShellCode</li>
</ol>
<p>写拷贝的本来流程：</p>
<blockquote>
<p>当写一个内存的时候先判断到内存是否可写(R/W位是否为1)，若为0，则表示该内存不可写，进入异常，在异常中通过VAD进一步判断其到底是写拷贝还是只读，如果是只读报错；如果是写拷贝，则映射一份新物理页将原内容复制过来，直接写到新物理页上，不影响原物理页。因此你HOOK了一个API只影响你自己的进程，而无法影响别的进程是因为别的进程还是原物理页，并未被你修改。解决方法很简单，找到要hook API的地方将R/W位置1，根本不进异常直接hook原物理页，规避触发写拷贝。</p>
</blockquote>
<p>下面代码针对2-9-9-12分页，并且事后未复原。</p>
<h3 id="R0代码"><a href="#R0代码" class="headerlink" title="R0代码"></a>R0代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE_CHANGE CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,METHOD_BUFFERED,FILE_ANY_ACCESS)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE_RESUME CTL_CODE(FILE_DEVICE_UNKNOWN,0x900,METHOD_BUFFERED,FILE_ANY_ACCESS)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE_READ CTL_CODE(FILE_DEVICE_UNKNOWN,0x1000,METHOD_BUFFERED,FILE_ANY_ACCESS)</span></span><br><span class="line">UNICODE_STRING SymbolicLinkName;</span><br><span class="line"></span><br><span class="line"><span class="comment">//卸载函数</span></span><br><span class="line"><span class="function">VOID <span class="title">DriverUnload</span><span class="params">(PDRIVER_OBJECT driver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//删除设备对象</span></span><br><span class="line">	<span class="keyword">if</span> (driver-&gt;DeviceObject)</span><br><span class="line">	&#123;</span><br><span class="line">		IoDeleteDevice(driver-&gt;DeviceObject);<span class="comment">//设备对象已挂载在driver中</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (SymbolicLinkName.Length&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		IoDeleteSymbolicLink(&amp;SymbolicLinkName);</span><br><span class="line">	&#125;</span><br><span class="line">	DbgPrint(<span class="string">&quot;停止运行了\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">MyCreateDispatchFunction</span><span class="params">(PDEVICE_OBJECT pDevObj, PIRP pIrp)</span><span class="comment">//PIRP为IRP报文数据结构指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//处理自己的业务...</span></span><br><span class="line">	DbgPrint(<span class="string">&quot;三环连接成功\n&quot;</span>);</span><br><span class="line">	<span class="comment">//设置返回状态,返回状态如果不设置，Ring3返回的是失败</span></span><br><span class="line">	pIrp-&gt;IoStatus.Status = STATUS_SUCCESS;	<span class="comment">//  三环getlasterror()得到的就是这个值</span></span><br><span class="line">	pIrp-&gt;IoStatus.Information = <span class="number">0</span>;		<span class="comment">//  返回给3环多少个字节的数据 没有填0</span></span><br><span class="line">	IoCompleteRequest(pIrp, IO_NO_INCREMENT);<span class="comment">//表示调用方已完成所有I/O请求处理操作，并将给定的 IRP 返回给 I/O 管理器。将IRP往下派发</span></span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">NTSTATUS <span class="title">MyCloseDispatchFunction</span><span class="params">(PDEVICE_OBJECT pDevObj, PIRP pIrp)</span><span class="comment">//PIRP为IRP报文数据结构指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//处理自己的业务...</span></span><br><span class="line">	DbgPrint(<span class="string">&quot;三环断开连接成功\n&quot;</span>);</span><br><span class="line">	<span class="comment">//设置返回状态,返回状态如果不设置，Ring3返回的是失败</span></span><br><span class="line">	pIrp-&gt;IoStatus.Status = STATUS_SUCCESS;	<span class="comment">//  三环getlasterror()得到的就是这个值</span></span><br><span class="line">	pIrp-&gt;IoStatus.Information = <span class="number">0</span>;		<span class="comment">//  返回给3环多少个字节的数据 没有填0</span></span><br><span class="line">	IoCompleteRequest(pIrp, IO_NO_INCREMENT);<span class="comment">//表示调用方已完成所有I/O请求处理操作，并将给定的 IRP 返回给 I/O 管理器。将IRP往下派发</span></span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ULONG param[<span class="number">5</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//ULONG getESP = 0;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//shellcode写到这里</span></span><br><span class="line"><span class="keyword">void</span> __declspec(naked) interruptGate()</span><br><span class="line">&#123;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//通过ESP获取MessageBoxA的参数</span></span><br><span class="line">		pushfd;</span><br><span class="line">		pushad;</span><br><span class="line">		mov eax, dword ptr ds : [esp + <span class="number">0x24</span> + <span class="number">0xC</span>] ;<span class="comment">//获取三环esp</span></span><br><span class="line">		<span class="comment">//mov dword ptr ds : [getESP] , eax;</span></span><br><span class="line">		lea ecx, param;</span><br><span class="line">		add eax, <span class="number">4</span>;<span class="comment">//跳过call的返回地址</span></span><br><span class="line">		<span class="comment">//获取四个参数填入param全局数组中。</span></span><br><span class="line">		mov ebx, dword ptr ds : [eax] ;</span><br><span class="line">		mov dword ptr ds : [ecx] , ebx;</span><br><span class="line">		mov ebx, dword ptr ds : [eax+<span class="number">4</span>] ;</span><br><span class="line">		mov dword ptr ds : [ecx+<span class="number">4</span>] , ebx;</span><br><span class="line">		mov ebx, dword ptr ds : [eax+<span class="number">8</span>] ;</span><br><span class="line">		mov dword ptr ds : [ecx+<span class="number">8</span>] , ebx;</span><br><span class="line">		mov ebx, dword ptr ds : [eax + <span class="number">0xC</span>] ;</span><br><span class="line">		mov dword ptr ds : [ecx + <span class="number">0xC</span>] , ebx;</span><br><span class="line">		add dword ptr ds : [ecx + <span class="number">0x10</span>],<span class="number">1</span></span><br><span class="line">		popad;</span><br><span class="line">		popfd;</span><br><span class="line">		iretd;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ULONG current = <span class="number">0</span>;<span class="comment">//为了防止打印重复</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">ControlCallBack</span><span class="params">(PDEVICE_OBJECT pDevObj, PIRP pIrp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	PIO_STACK_LOCATION psl = IoGetCurrentIrpStackLocation(pIrp);</span><br><span class="line">	ULONG code = psl-&gt;Parameters.DeviceIoControl.IoControlCode;<span class="comment">//获取派遣过来的CTL操作码</span></span><br><span class="line">	PVOID systemBuf = pIrp-&gt;AssociatedIrp.SystemBuffer;<span class="comment">//获取缓存地址(输入输出都靠这个地址)</span></span><br><span class="line">	ULONG inLen = psl-&gt;Parameters.DeviceIoControl.InputBufferLength;<span class="comment">//获取输入长度</span></span><br><span class="line">	ULONG outLen = psl-&gt;Parameters.DeviceIoControl.OutputBufferLength;<span class="comment">//获取输出长度</span></span><br><span class="line">	UCHAR IDT[<span class="number">6</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	UCHAR GDT[<span class="number">6</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	ULONG IDT_BASE = <span class="number">0</span>;</span><br><span class="line">	ULONG GDT_BASE = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//根据不同的CTL操作码做不同的处理</span></span><br><span class="line">	<span class="keyword">switch</span> (code)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> CODE_CHANGE:<span class="comment">//注意是以三环视角来看其含义，初始化</span></span><br><span class="line">		<span class="comment">//填充中断门描述符</span></span><br><span class="line">		__asm sidt IDT;</span><br><span class="line">		IDT_BASE = *(PULONG)(&amp;IDT[<span class="number">2</span>]); </span><br><span class="line">		DbgPrint(<span class="string">&quot;shellCode地址为:%p\n&quot;</span>, interruptGate);</span><br><span class="line">		ULONG firstPart = (((ULONG)interruptGate) &amp; <span class="number">0xFFFF0000</span>) | <span class="number">0x0000EE00</span>;</span><br><span class="line">		ULONG secondPart = (((ULONG)interruptGate) &amp; <span class="number">0x0000FFFF</span>) | <span class="number">0x00080000</span>;</span><br><span class="line">		DbgPrint(<span class="string">&quot;中断门描述符:%p`%p\n&quot;</span>, firstPart, secondPart);</span><br><span class="line">		*(PULONG)(IDT_BASE + <span class="number">32</span> * <span class="number">8</span>) = secondPart;</span><br><span class="line">		*(PULONG)(IDT_BASE + <span class="number">32</span> * <span class="number">8</span> + <span class="number">4</span>) = firstPart;</span><br><span class="line">		<span class="comment">//填充调用门</span></span><br><span class="line">		__asm sgdt GDT;</span><br><span class="line">		GDT_BASE = *(PULONG)(&amp;GDT[<span class="number">2</span>]);</span><br><span class="line">		ULONG targetAddress = *(ULONG*)systemBuf;<span class="comment">//获取三环传过来的要跳转的函数地址</span></span><br><span class="line">		DbgPrint(<span class="string">&quot;targetAddress:%p\n&quot;</span>, targetAddress);</span><br><span class="line">		ULONG firstPart_gdt = (((ULONG)targetAddress) &amp; <span class="number">0xFFFF0000</span>) | <span class="number">0x0000EC00</span>;</span><br><span class="line">		ULONG secondPart_gdt = (((ULONG)targetAddress) &amp; <span class="number">0x0000FFFF</span>) | <span class="number">0x00080000</span>;</span><br><span class="line">		DbgPrint(<span class="string">&quot;调用门描述符:%p`%p\n&quot;</span>, firstPart_gdt, secondPart_gdt);</span><br><span class="line">		*(PULONG)(GDT_BASE + <span class="number">9</span> * <span class="number">8</span>) = secondPart_gdt;</span><br><span class="line">		*(PULONG)(GDT_BASE + <span class="number">9</span> * <span class="number">8</span> + <span class="number">4</span>) = firstPart_gdt;</span><br><span class="line"><span class="comment">//下面代码想在驱动中修改PTE却发现PTE是0。</span></span><br><span class="line">		<span class="comment">//改变messageBox所在的物理页属性R/W为1</span></span><br><span class="line">		<span class="comment">//判断systemBuf中是否有内容</span></span><br><span class="line">		<span class="comment">//ULONG targetAddress = *(ULONG*)systemBuf;//获取三环传过来的函数地址</span></span><br><span class="line">		<span class="comment">//DbgPrint(&quot;MessageBoxA地址为:%p\n&quot;, messageBoxAAddr);</span></span><br><span class="line">		<span class="comment">//ULONG PDI = (messageBoxAAddr &gt;&gt; 21) &amp; 0x1FF;</span></span><br><span class="line">		<span class="comment">////读取PDE</span></span><br><span class="line">		<span class="comment">//ULONG lowPDE = *(ULONG*)(0xC0601000 + 8 * PDI);</span></span><br><span class="line">		<span class="comment">//ULONG highPDE = *(ULONG*)(0xC0601000 + 8 * PDI +4);</span></span><br><span class="line">		<span class="comment">//DbgPrint(&quot;PDE为:%p`%p\n&quot;, highPDE,lowPDE);</span></span><br><span class="line">		<span class="comment">////读取PTE</span></span><br><span class="line">		<span class="comment">//ULONG PTI= (messageBoxAAddr &gt;&gt; 12)&amp; 0x1FF;</span></span><br><span class="line">		<span class="comment">//ULONG lowPTE = *(ULONG*)(0xC0000000 + 0x1000 * PDI + PTI * 8);</span></span><br><span class="line">		<span class="comment">//ULONG highPTE = *(ULONG*)(0xC0000000+ 0x1000 * PDI + PTI * 8 + 4);</span></span><br><span class="line">		<span class="comment">//DbgPrint(&quot;PTE为:%p`%p\n&quot;, highPTE, lowPTE);</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> CODE_RESUME:<span class="comment">//三环想要反初始化</span></span><br><span class="line">		<span class="comment">//恢复原样</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> CODE_READ:</span><br><span class="line">		<span class="comment">/*DbgPrint(&quot;current ESP:%p\n&quot;, getESP);</span></span><br><span class="line"><span class="comment">		DbgPrint(&quot;param:%p,%p,%p,%p,%p\n&quot;, param[0], param[1], param[2], param[3], param[4]);*/</span></span><br><span class="line">		<span class="keyword">if</span>(param[<span class="number">4</span>]!= current)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">memcpy</span>(systemBuf, param, <span class="number">20</span>);</span><br><span class="line">			pIrp-&gt;IoStatus.Information = <span class="number">20</span>;</span><br><span class="line">			current++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			pIrp-&gt;IoStatus.Information = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	IoCompleteRequest(pIrp, IO_NO_INCREMENT);<span class="comment">//表示调用方已完成所有I/O请求处理操作，并将给定的 IRP 返回给 I/O 管理器。将IRP往下派发</span></span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//入口函数，相当于main函数</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT pdriver, PUNICODE_STRING pReg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//设置一个卸载函数，用于退出</span></span><br><span class="line">	pdriver-&gt;DriverUnload = DriverUnload;</span><br><span class="line">	<span class="comment">//创建设备名称</span></span><br><span class="line">	UNICODE_STRING Devicename;</span><br><span class="line">	RtlInitUnicodeString(&amp;Devicename, <span class="string">L&quot;\\Device\\MyDevice&quot;</span>);</span><br><span class="line">	<span class="comment">//设备对象指针，用于接受</span></span><br><span class="line">	PDEVICE_OBJECT pDeviceObj = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//创建设备</span></span><br><span class="line">	NTSTATUS status = IoCreateDevice(pdriver,<span class="number">0</span>,&amp;Devicename,FILE_DEVICE_UNKNOWN,FILE_DEVICE_SECURE_OPEN,TRUE,&amp;pDeviceObj	);</span><br><span class="line">	<span class="keyword">if</span> (!NT_SUCCESS(status))<span class="comment">//NT_SUCCESS,微软提供的，实际上就是判断status是否大于等于0</span></span><br><span class="line">	&#123;</span><br><span class="line">		DbgPrint(<span class="string">&quot;创建设备失败!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> status;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果前面创建设备对象成功，就设置交互数据的方式</span></span><br><span class="line">	pDeviceObj-&gt;Flags |= DO_BUFFERED_IO;</span><br><span class="line">	<span class="comment">//创建符号链接名称</span></span><br><span class="line">	RtlInitUnicodeString(&amp;SymbolicLinkName, <span class="string">L&quot;\\??\\MyTestDriver&quot;</span>);</span><br><span class="line">	status = IoCreateSymbolicLink(&amp;SymbolicLinkName, &amp;Devicename);</span><br><span class="line">	<span class="keyword">if</span> (!NT_SUCCESS(status))</span><br><span class="line">	&#123;</span><br><span class="line">		DbgPrint(<span class="string">&quot;创建符号链接失败!\n&quot;</span>);</span><br><span class="line">		IoDeleteDevice(pDeviceObj);<span class="comment">//删除设备</span></span><br><span class="line">		<span class="keyword">return</span> status;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置派遣函数   </span></span><br><span class="line">	pdriver-&gt;MajorFunction[IRP_MJ_CREATE] = MyCreateDispatchFunction;</span><br><span class="line">	pdriver-&gt;MajorFunction[IRP_MJ_CLOSE] = MyCloseDispatchFunction;</span><br><span class="line">	pdriver-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = ControlCallBack;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="R3代码"><a href="#R3代码" class="headerlink" title="R3代码"></a>R3代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;WinIoCtl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE_CHANGE CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,METHOD_BUFFERED,FILE_ANY_ACCESS)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE_RESUME CTL_CODE(FILE_DEVICE_UNKNOWN,0x900,METHOD_BUFFERED,FILE_ANY_ACCESS)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE_READ CTL_CODE(FILE_DEVICE_UNKNOWN,0x1000,METHOD_BUFFERED,FILE_ANY_ACCESS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打开设备</span></span><br><span class="line"><span class="function">BOOLEAN <span class="title">openDevice</span><span class="params">(HANDLE *handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HANDLE _handle = CreateFileA(<span class="string">&quot;\\\\.\\MyTestDriver&quot;</span>, GENERIC_READ | GENERIC_WRITE, <span class="number">0</span>, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);<span class="comment">//打开设备对象句柄</span></span><br><span class="line">	*handle = _handle;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">int</span>)_handle &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送IRP_MJ_DEVICE_CONTROL</span></span><br><span class="line"><span class="function">BOOLEAN <span class="title">sendCode</span><span class="params">(HANDLE hDevice, DWORD code, PVOID inData, ULONG Inlen, PVOID outData, ULONG outLen, LPDWORD resultLen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> DeviceIoControl(hDevice, code, inData, Inlen, outData, outLen, resultLen, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DWORD lowPDE,lowPTE;</span><br><span class="line">DWORD highPDE,highPTE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __declspec(naked) callGate()</span><br><span class="line">&#123;</span><br><span class="line">	_asm</span><br><span class="line">	&#123;</span><br><span class="line">		pushfd;</span><br><span class="line">		pushad;</span><br><span class="line">		mov ecx,dword ptr ds:[MessageBoxA];</span><br><span class="line">		<span class="comment">//get pde</span></span><br><span class="line">		mov eax,ecx;</span><br><span class="line">		shr eax,<span class="number">21</span>;</span><br><span class="line">		<span class="keyword">and</span> eax,<span class="number">0x1FF</span>;</span><br><span class="line">		shl eax,<span class="number">3</span>;</span><br><span class="line">		mov edx,dword ptr ds:[<span class="number">0xC0601000</span>+eax];</span><br><span class="line">		mov dword ptr ds:[lowPDE],edx;</span><br><span class="line">		mov edx,dword ptr ds:[<span class="number">0xC0601000</span>+eax+<span class="number">4</span>];</span><br><span class="line">		mov dword ptr ds:[highPDE],edx;</span><br><span class="line">		<span class="comment">//get pte</span></span><br><span class="line">		mov eax,ecx;</span><br><span class="line">		shr eax,<span class="number">12</span>;</span><br><span class="line">		<span class="keyword">and</span> eax,<span class="number">0xFFFFF</span>;</span><br><span class="line">		shl eax,<span class="number">3</span>;</span><br><span class="line">		mov edi,dword ptr ds:[<span class="number">0xC0000000</span>+eax];</span><br><span class="line">		mov dword ptr ds:[lowPTE],edi;</span><br><span class="line">		mov edx,dword ptr ds:[<span class="number">0xC0000000</span>+eax+<span class="number">4</span>];</span><br><span class="line">		mov dword ptr ds:[highPTE],edx;</span><br><span class="line">		<span class="comment">//change R/W in PDE</span></span><br><span class="line">		<span class="keyword">or</span> edi,<span class="number">0x2</span>;</span><br><span class="line">		mov dword ptr ds:[<span class="number">0xC0000000</span>+eax],edi</span><br><span class="line">		popad;</span><br><span class="line">		popfd;</span><br><span class="line">		retf;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// MessageBoxA 挂物理页，不这样操作，MessageBoxA的PTE可能是无效的</span></span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		mov eax, dword ptr ds:[MessageBoxA];</span><br><span class="line">		mov eax,[eax];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;MessageBoxA address:%p\n&quot;</span>,MessageBoxA);</span><br><span class="line">	HANDLE hDevice;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">30</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	DWORD realReaded = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!openDevice(&amp;hDevice))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;打开设备对象失败!\r\n&quot;</span>);</span><br><span class="line">		system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	*(DWORD*)buf=(DWORD)callGate;</span><br><span class="line">	sendCode(hDevice, CODE_CHANGE, buf, <span class="number">30</span>, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;realReaded);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;callGate address:%p\n&quot;</span>,callGate);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">char</span> callCallgate[<span class="number">6</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x48</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	_asm</span><br><span class="line">	&#123;</span><br><span class="line">		call fword ptr[callCallgate];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;PDE:%p`%p\n&quot;</span>,highPDE,lowPDE);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;PTE:%p`%p\n&quot;</span>,highPTE,lowPTE);</span><br><span class="line">	<span class="comment">//hook MessageBoxA</span></span><br><span class="line">	<span class="keyword">char</span> hookContent[<span class="number">2</span>]=&#123;<span class="number">0xCD</span>,<span class="number">0x20</span>&#125;;</span><br><span class="line">	<span class="built_in">memcpy</span>(MessageBoxA,hookContent,<span class="number">2</span>);</span><br><span class="line">	<span class="comment">//hook succeed!</span></span><br><span class="line">	<span class="comment">//get R0 info from MessageBoxA</span></span><br><span class="line">	DWORD current=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		sendCode(hDevice, CODE_READ, <span class="literal">NULL</span>, <span class="number">0</span>, buf, <span class="number">30</span>, &amp;realReaded);</span><br><span class="line">		DWORD* p=(DWORD*)buf;</span><br><span class="line">		<span class="keyword">if</span>(realReaded&gt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;No.%d MessageBoxA(%p,%p,%p,%p)\n&quot;</span>,p[<span class="number">4</span>],p[<span class="number">0</span>],p[<span class="number">1</span>],p[<span class="number">2</span>],p[<span class="number">3</span>]);</span><br><span class="line">			current++;</span><br><span class="line">		&#125;</span><br><span class="line">		Sleep(<span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	CloseHandle(hDevice);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成功监听MessageBoxA结果：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210830211435935.png" alt="image-20210830211435935"></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41875267/article/details/109692389">别人的代码参考</a></p>
<h3 id="重难点"><a href="#重难点" class="headerlink" title="重难点"></a>重难点</h3><ul>
<li>跟界面相关的API永远都是<strong>懒加载</strong>的，即没调用不加载，物理页不会挂上去。</li>
<li>但是OpenProcess这种，他自己事先就加载好了，挂上了物理页。</li>
</ul>
<h2 id="Inline-Hook"><a href="#Inline-Hook" class="headerlink" title="Inline Hook"></a>Inline Hook</h2><p>与R3的Inline Hook完全一样</p>
<p>位置的选择：</p>
<ol>
<li>JMP/CALL指令至少占用5个字节</li>
<li>绕开全局变量（每次的全局变量位置是不确定，因为模块加载的顺序不一致）</li>
<li>根据业务来决定在哪里HOOK，过滤参数？修改返回结果？</li>
</ol>
<p>思考：</p>
<ol>
<li>正在hook的瞬间，如何保证多核切换的稳定性</li>
<li>如何绕过硬编码校验检测内联HOOK</li>
</ol>
<h2 id="注册系统回调保护进程"><a href="#注册系统回调保护进程" class="headerlink" title="注册系统回调保护进程"></a>注册系统回调保护进程</h2><p>xp不可用</p>
<p><strong>替代hook的官方手段:回调函数</strong>  (64位未过pg不能inline hook的替代方案)</p>
<p><strong>注册系统回调最需要注意的一点就是: 一定要防止回调发生死循环</strong></p>
<h3 id="核心函数ObRegisterCallbacks"><a href="#核心函数ObRegisterCallbacks" class="headerlink" title="核心函数ObRegisterCallbacks"></a>核心函数ObRegisterCallbacks</h3><p><strong>可以为线程、进程和桌面句柄操作注册回调函数</strong></p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202205291945467.jpeg" alt="regsyscallback"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS </span></span><br><span class="line"><span class="function">  <span class="title">ObRegisterCallbacks</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    IN POB_CALLBACK_REGISTRATION  CallBackRegistration,</span></span></span><br><span class="line"><span class="params"><span class="function">    OUT PVOID  *RegistrationHandle)</span></span>;<span class="comment">////返回该系统回调的句柄,卸载时用得上</span></span><br><span class="line"><span class="comment">//NT_SUCCESS(ObRegisterCallbacks的返回值)为1表示成功,否则失败</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202205041101739.jpeg" alt="v2-e07e93bb06ba604bbe332d3bfbc0183a_1440w"></p>
<blockquote>
<p><strong>破解ObRegisterCallbacks函数的使用限制</strong> : 驱动程序必须有数字签名才能使用此函数,通过逆向ObRegisterCallbacks,找到了破解这个限制的方法.经研究,内核通过MmVerifyCallbackFunction验证此回调是否合法,但此函数只是简单的验证了一下DriverObject-&gt;DriverSection-&gt;Flags的值是不是包含0x20.在驱动的入口函数中添加代码: <code>PLDR_DATA_TABLE_ENTRY  pobj = (PLDR_DATA_TABLE_ENTRY)DriverObject-&gt;DriverSection;DriverObject-&gt;Flags |= 0x20; </code> (PLDR_DATA_TABLE_ENTRY需要自己定义),即可破解该使用限制</p>
<p>想要使用ObRegisterCallbacks函数成功,必须在编译器的 <strong>链接器-命令行行中添加</strong><code>/INTEGRITYCHECK</code>   (指定必须在加载时检查二进制映像的签名)</p>
<p>关于/INTEGRITYCHECK详细信息 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/cpp/build/reference/integritycheck-require-signature-check?view=msvc-160">https://docs.microsoft.com/zh-cn/cpp/build/reference/integritycheck-require-signature-check?view=msvc-160</a> </p>
</blockquote>
<p>该函数第一个参数指向下面结构</p>
<h4 id="OB-CALLBACK-REGISTRATION结构"><a href="#OB-CALLBACK-REGISTRATION结构" class="headerlink" title="OB_CALLBACK_REGISTRATION结构"></a>OB_CALLBACK_REGISTRATION结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OB_CALLBACK_REGISTRATION</span> &#123;</span></span><br><span class="line">  __in USHORT  Version;<span class="comment">//一般为OB_FLT_REGISTRATION_VERSION</span></span><br><span class="line">  __in USHORT  OperationRegistrationCount;<span class="comment">//注册回调函数的个数</span></span><br><span class="line">  __in UNICODE_STRING  Altitude;<span class="comment">//决定加载顺序(越大的越早被执行)</span></span><br><span class="line">  __in PVOID  RegistrationContext;<span class="comment">//自定义数据,没有填空</span></span><br><span class="line">  __in OB_OPERATION_REGISTRATION  *OperationRegistration;<span class="comment">//指向_OB_OPERATION_REGISTRATION结构</span></span><br><span class="line">&#125; OB_CALLBACK_REGISTRATION, *POB_CALLBACK_REGISTRATION;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202205041103204.jpeg" alt="v2-fe188ac7d8bd77ba391df598072daa18_1440w"></p>
<p>可见成员又指向_OB_OPERATION_REGISTRATION结构体</p>
<h4 id="OB-OPERATION-REGISTRATION结构体"><a href="#OB-OPERATION-REGISTRATION结构体" class="headerlink" title="_OB_OPERATION_REGISTRATION结构体"></a>_OB_OPERATION_REGISTRATION结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OB_OPERATION_REGISTRATION</span> &#123;</span></span><br><span class="line">  __in POBJECT_TYPE  *ObjectType;<span class="comment">//针对进程还是线程还是桌面句柄</span></span><br><span class="line">  __in OB_OPERATION  Operations;<span class="comment">//针对什么行为回调</span></span><br><span class="line">  __in POB_PRE_OPERATION_CALLBACK  PreOperation;<span class="comment">//[前]设置自定义的回调函数</span></span><br><span class="line">  __in POB_POST_OPERATION_CALLBACK  PostOperation;<span class="comment">//[后]设置自定义的回调函数</span></span><br><span class="line">&#125; OB_OPERATION_REGISTRATION, *POB_OPERATION_REGISTRATION;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202205041105434.jpeg" alt="v2-29347fc67c90d940d2ba3e58702b5035_1440w"></p>
<p>上述函数第三个参数指向一个自定的回调函数如下</p>
<h4 id="自定义回调函数"><a href="#自定义回调函数" class="headerlink" title="自定义回调函数"></a>自定义回调函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自己起名字</span></span><br><span class="line"><span class="function">OB_PREOP_CALLBACK_STATUS <span class="title">my_pre_callback</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PVOID RegistrationContext,<span class="comment">//注册回调时传入的自定义数据</span></span></span></span><br><span class="line"><span class="params"><span class="function">    POB_PRE_OPERATION_INFORMATION OperationInformation</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//想要的操作</span></span><br><span class="line">  <span class="keyword">return</span> OB_PREOP_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>POB_PRE_OPERATION_INFORMATION结构</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OB_PRE_OPERATION_INFORMATION</span> &#123;</span></span><br><span class="line">  OB_OPERATION                 Operation;</span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    ULONG Flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">      ULONG KernelHandle : <span class="number">1</span>;</span><br><span class="line">      ULONG Reserved : <span class="number">31</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  PVOID                        Object;<span class="comment">//打开句柄的目标对象结构体首地址</span></span><br><span class="line">  POBJECT_TYPE                 ObjectType;<span class="comment">//对象种类</span></span><br><span class="line">  PVOID                        CallContext;</span><br><span class="line">  POB_PRE_OPERATION_PARAMETERS Parameters;<span class="comment">//指向包含操作特定信息的OB_PRE_OPERATION_PARAMETERS的指针。</span></span><br><span class="line">&#125; OB_PRE_OPERATION_INFORMATION, *POB_PRE_OPERATION_INFORMATION;</span><br><span class="line"></span><br><span class="line"><span class="comment">//POB_PRE_OPERATION_PARAMETERS结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> _<span class="title">OB_PRE_OPERATION_PARAMETERS</span> &#123;</span></span><br><span class="line">  OB_PRE_CREATE_HANDLE_INFORMATION    CreateHandleInformation;<span class="comment">//包含特定于正在打开的句柄的信息的OB_PRE_CREATE_HANDLE_INFORMATION结构</span></span><br><span class="line">  OB_PRE_DUPLICATE_HANDLE_INFORMATION DuplicateHandleInformation;</span><br><span class="line">&#125; OB_PRE_OPERATION_PARAMETERS, *POB_PRE_OPERATION_PARAMETERS;</span><br><span class="line"></span><br><span class="line"><span class="comment">//OB_PRE_CREATE_HANDLE_INFORMATION结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OB_PRE_CREATE_HANDLE_INFORMATION</span> &#123;</span></span><br><span class="line">  ACCESS_MASK DesiredAccess;<span class="comment">//一个ACCESS_MASK值，它指定要为句柄授予的访问权限。默认情况下，此成员等于OriginalDesiredAccess，但ObjectPreCallback例程可以修改此值以限制授予的访问权限。</span></span><br><span class="line">  ACCESS_MASK OriginalDesiredAccess;<span class="comment">//一个 ACCESS_MASK 值，它指定为句柄请求的原始访问权限。</span></span><br><span class="line">&#125; OB_PRE_CREATE_HANDLE_INFORMATION, *POB_PRE_CREATE_HANDLE_INFORMATION;</span><br><span class="line"><span class="comment">//此结构可用于控制句柄权限</span></span><br></pre></td></tr></table></figure>

<h4 id="注册系统回调案例"><a href="#注册系统回调案例" class="headerlink" title="注册系统回调案例"></a>注册系统回调案例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解锁使用限制</span></span><br><span class="line">    ldr = (PLDR_DATA)pDriverObject-&gt;DriverSection;</span><br><span class="line">    ldr-&gt;Flags |= <span class="number">0x20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//安装系统回调钩子代码如下</span></span><br><span class="line"><span class="comment">//安装内存保护</span></span><br><span class="line">HANDLE gs_HandleCallback = <span class="literal">NULL</span>;<span class="comment">//用来存放返回的句柄,以方便卸载对应功能</span></span><br><span class="line"><span class="function">BOOLEAN <span class="title">protectProcessStart</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    OB_CALLBACK_REGISTRATION ob1_callback_reg = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    OB_OPERATION_REGISTRATION ob2_operation = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">//初始化ob1_callback_reg</span></span><br><span class="line">    RtlInitUnicodeString(&amp;ob1_callback_reg.Altitude, <span class="string">L&quot;321000&quot;</span>);<span class="comment">//加载顺序</span></span><br><span class="line">    ob1_callback_reg.RegistrationContext = <span class="literal">NULL</span>;<span class="comment">//自定义数据</span></span><br><span class="line">    ob1_callback_reg.Version = OB_FLT_REGISTRATION_VERSION;<span class="comment">//版本ObGetFilterVersion(); //OB_FLT_REGISTRATION_VERSION</span></span><br><span class="line">    ob1_callback_reg.OperationRegistrationCount = <span class="number">1</span>;<span class="comment">//注册回调函数的个数</span></span><br><span class="line">    ob1_callback_reg.OperationRegistration = &amp;ob2_operation;</span><br><span class="line">    <span class="comment">//接下来初始化ob2_operation</span></span><br><span class="line">    ob2_operation.ObjectType = PsProcessType;<span class="comment">//OpenProcess OpenThread PsThreadType</span></span><br><span class="line">    ob2_operation.Operations = OB_OPERATION_HANDLE_CREATE;<span class="comment">//针对什么行为回调</span></span><br><span class="line">    ob2_operation.PostOperation = <span class="literal">NULL</span>;<span class="comment">//行为发生之后的钩子</span></span><br><span class="line">    ob2_operation.PreOperation = my_pre_callback;<span class="comment">//行为发生之前的钩子,这个函数是自定义的函数</span></span><br><span class="line">    NTSTATUS ntRet = ObRegisterCallbacks(&amp;ob1_callback_reg, &amp;gs_HandleCallback);<span class="comment">//注册回调函数</span></span><br><span class="line">    KdPrint((<span class="string">&quot;zeroko:sys安装进程保护:gs_HandleCallback=%p,ntRet=%x&quot;</span>, gs_HandleCallback,ntRet));</span><br><span class="line">    <span class="keyword">return</span> ntRet == STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//卸载系统回调钩子代码如下</span></span><br><span class="line"><span class="comment">//卸载进程保护</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">protectProcessEnd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (gs_HandleCallback)</span><br><span class="line">    &#123;</span><br><span class="line">        ObUnRegisterCallbacks(gs_HandleCallback);</span><br><span class="line">        gs_HandleCallback = <span class="literal">NULL</span>;</span><br><span class="line">        KdPrint((<span class="string">&quot;zeroko:sys卸载进程保护&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义的回调函数</span></span><br><span class="line"><span class="function">OB_PREOP_CALLBACK_STATUS <span class="title">my_pre_callback</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PVOID RegistrationContext,</span></span></span><br><span class="line"><span class="params"><span class="function">    POB_PRE_OPERATION_INFORMATION OperationInformation</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="comment">//KdPrint((&quot;zeroko:sys pEprocess = %p&quot;, OperationInformation-&gt;Object));</span></span><br><span class="line">    <span class="keyword">if</span> (OperationInformation-&gt;KernelHandle)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//内核层</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//用户层</span></span><br><span class="line">        <span class="comment">//只针对指定目标进程保护</span></span><br><span class="line">        HANDLE dwTargetPId = PsGetProcessId((PEPROCESS)OperationInformation-&gt;Object);<span class="comment">//获取目标进程pid</span></span><br><span class="line">        <span class="comment">//KdPrint((&quot;zeroko:sys: 目标pid:%d&quot;, dwTargetPId));</span></span><br><span class="line">        <span class="keyword">if</span> (isInProtectPidsVec(dwTargetPId))</span><br><span class="line">        &#123;</span><br><span class="line">            ACCESS_MASK newAccess = OperationInformation-&gt;Parameters-&gt;CreateHandleInformation.OriginalDesiredAccess;<span class="comment">//获取原始赋予的权限</span></span><br><span class="line">            <span class="comment">//去除某些权限</span></span><br><span class="line">            <span class="comment">//去除终止进程权限</span></span><br><span class="line">            newAccess &amp;= ~PROCESS_TERMINATE;</span><br><span class="line">            <span class="comment">//去除跨进程读进程权限</span></span><br><span class="line">            newAccess &amp;= ~PROCESS_VM_READ;</span><br><span class="line">            <span class="comment">//去除跨进程写进程权限</span></span><br><span class="line">            newAccess &amp;= ~PROCESS_VM_WRITE;</span><br><span class="line">            OperationInformation-&gt;Parameters-&gt;CreateHandleInformation.DesiredAccess = newAccess;<span class="comment">//更改要赋予的权限为我们处理过的权限</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OB_PREOP_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><h4 id="进程有哪些权限"><a href="#进程有哪些权限" class="headerlink" title="进程有哪些权限"></a><strong>进程有哪些权限</strong></h4><p>即使是任务管理器对进程进行操作,也需要获取对应进程权限才可以操作进程,因此如果用回调函数拦截了目标进程相应句柄的权限,则任务管理器也会无权限操作目标进程.</p>
<p>进程权限如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROCESS_TERMINATE                  (0x0001)<span class="comment">//终止进程(任务管理器中如果在详细信息中对进程右键选择终止进程就需要用到此权限)  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROCESS_CREATE_THREAD              (0x0002)<span class="comment">//创建线程</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROCESS_SET_SESSIONID              (0x0004)  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROCESS_VM_OPERATION               (0x0008)  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROCESS_VM_READ                    (0x0010)<span class="comment">//跨进程读目标进程 </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROCESS_VM_WRITE                   (0x0020)<span class="comment">//跨进程写目标进程  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROCESS_DUP_HANDLE                 (0x0040)<span class="comment">//复制目标进程的句柄</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROCESS_CREATE_PROCESS             (0x0080)<span class="comment">//创建进程</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROCESS_SET_QUOTA                  (0x0100)<span class="comment">//设置一些进程的信息  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROCESS_SET_INFORMATION            (0x0200)  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROCESS_QUERY_INFORMATION          (0x0400)<span class="comment">//查询进程的详细信息  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROCESS_SUSPEND_RESUME             (0x0800)<span class="comment">//进程挂起和恢复  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROCESS_QUERY_LIMITED_INFORMATION  (0x1000)  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROCESS_SET_LIMITED_INFORMATION    (0x2000)  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (NTDDI_VERSION &gt;= NTDDI_VISTA)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROCESS_ALL_ACCESS        (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | \</span></span><br><span class="line"><span class="meta">                                   0xFFFF)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROCESS_ALL_ACCESS        (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | \</span></span><br><span class="line"><span class="meta">                                   0xFFF)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h4 id="驱动中通过进程对象结构体首地址获取进程名"><a href="#驱动中通过进程对象结构体首地址获取进程名" class="headerlink" title="驱动中通过进程对象结构体首地址获取进程名"></a>驱动中通过进程对象结构体首地址获取进程名</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面两个均只能获取到小于15字节的进程名    (EProcess是想获取的目标进程结构体首地址)</span></span><br><span class="line"><span class="keyword">char</span>* processName = (<span class="keyword">char</span>*)EProcess+<span class="number">0x174</span>;<span class="comment">//只知道win7可用,不能针对所有操作系统,0x174在部分版本windows系统可能不正确(可能!)</span></span><br><span class="line"><span class="keyword">char</span>* processName2 = PsGetProcessImageFileName(EProcess);</span><br><span class="line"><span class="comment">//PsGetProcessImageFileName是未导出的函数,需要如下声明:</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">PsGetProcessImageFileName</span><span class="params">(PEPROCESS arg1)</span></span>;</span><br></pre></td></tr></table></figure>

<p>即可以获取当前进程名(最多显示14个字节)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PsGetProcessImageFileName(PsGetCurrentProcess());</span><br></pre></td></tr></table></figure>

<p>获取当前进程pid函数: <code>PsGetCurrentProcessId</code></p>
<p>在系统回调中获取目标进程id</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HANDLE pid = PsGetProcessId((PEPROCESS)OperationInformation-&gt;OBject);</span><br></pre></td></tr></table></figure>

<h4 id="进程id获取进程名"><a href="#进程id获取进程名" class="headerlink" title="进程id获取进程名"></a>进程id获取进程名</h4><p>核心函数</p>
<ul>
<li>PsLookupProcessByProcessId      ObfDereferenceObject  (成对使用)</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">GetProcessNameByProcessId</span><span class="params">(HANDLE ProcessId)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS st = STATUS_UNSUCCESSFUL;</span><br><span class="line">    PEPROCESS ProcessObj = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* PNameString = <span class="literal">NULL</span>;</span><br><span class="line">    st = PsLookupProcessByProcessId(ProcessId, &amp;ProcessObj);</span><br><span class="line">    <span class="keyword">if</span> (NT_SUCCESS(st))</span><br><span class="line">    &#123;</span><br><span class="line">        PNameString = PsGetProcessImageFileName(ProcessObj);</span><br><span class="line">        ObfDereferenceObject(ProcessObj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> PNameString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="另一种实现方式"><a href="#另一种实现方式" class="headerlink" title="另一种实现方式"></a>另一种实现方式</h5><p>这种方式在注册OpenProcess系统回调函数中使用会蓝屏</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">GetProcessName</span><span class="params">(ULONG dwPid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE ProcessHandle;</span><br><span class="line">    NTSTATUS status;</span><br><span class="line">    OBJECT_ATTRIBUTES ObjectAttributes;</span><br><span class="line">    CLIENT_ID myCid;</span><br><span class="line">    PEPROCESS EProcess;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* PsName = <span class="literal">NULL</span>;</span><br><span class="line">    InitializeObjectAttributes(&amp;ObjectAttributes, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    myCid.UniqueProcess = (HANDLE)dwPid;</span><br><span class="line">    myCid.UniqueThread = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//打开进程,获取句柄</span></span><br><span class="line">    status = ZwOpenProcess(&amp;ProcessHandle, PROCESS_ALL_ACCESS, &amp;ObjectAttributes,&amp;myCid);<span class="comment">//如果在注册OpenProcess系统回调中使用此函数,就会陷入循环无限调用的情况导致堆栈溢出</span></span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(status))</span><br><span class="line">    &#123;</span><br><span class="line">        KdPrint((<span class="string">&quot;zeroko:kernel:打开进程出错\n&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//得到EPROCESS结构,结构中取进程名</span></span><br><span class="line">    status = ObReferenceObjectByHandle(ProcessHandle,FILE_READ_DATA,<span class="number">0</span>,KernelMode,&amp;EProcess,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(status))</span><br><span class="line">    &#123;</span><br><span class="line">        PsName = PsGetProcessImageFileName(EProcess);</span><br><span class="line">        KdPrint((<span class="string">&quot;zeroko:kernel:PsName is %s&quot;</span>, PsName));</span><br><span class="line">        ZwClose(ProcessHandle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        KdReint((<span class="string">&quot;zeroko:kernel:Get ProcessName error&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> PsName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NtOpenProcess和ZwOpenProcess对应的函数地址实际上是同一个,只是符号不同.</p>
<p>如果在注册OpenProcess系统回调中使用此函数,就会陷入无限递归的死循环 <code>NtOpenProcess -&gt; my_pre_callback -&gt; GetProcessName -&gt; NtOpenProcess </code>,最终导致堆栈溢出蓝屏</p>
<h4 id="驱动中设置断点"><a href="#驱动中设置断点" class="headerlink" title="驱动中设置断点:"></a>驱动中设置断点:</h4><h5 id="代码的方式下断点"><a href="#代码的方式下断点" class="headerlink" title="代码的方式下断点"></a>代码的方式下断点</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DbgBreakPoint __debugbreak</span></span><br></pre></td></tr></table></figure>

<p>使用方式: <code>DbgBreakPoint();</code>或者 <code>__debugbreak();</code></p>
<h5 id="windbg直接下断点"><a href="#windbg直接下断点" class="headerlink" title="windbg直接下断点"></a>windbg直接下断点</h5><p><code>bu 模块名!函数名</code>   例如:  <code>bu mysys!testFunc</code>    <code>bp mysys!testFunc</code></p>
<h3 id="远程读写绕过系统回调保护"><a href="#远程读写绕过系统回调保护" class="headerlink" title="远程读写绕过系统回调保护"></a>远程读写绕过系统回调保护</h3><p>远程读写效率怎么都比不上内部读写</p>
<h4 id="进程挂靠的方式实现"><a href="#进程挂靠的方式实现" class="headerlink" title="进程挂靠的方式实现"></a>进程挂靠的方式实现</h4><p><strong>用到的核心函数</strong></p>
<ol>
<li>KeStackAttachProcess 进程挂靠  (直接修改CR3应该也可以)</li>
<li>KeUnstackDetachProcess 解除进程挂靠</li>
</ol>
<p>此处为内核申请一个过渡的内核内存,来临时存放要读的数据</p>
<h5 id="读进程"><a href="#读进程" class="headerlink" title="读进程"></a>读进程</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过pid读取目标内存,返回实际读到的字节数(用到自定义的KReadProcessMemory函数)</span></span><br><span class="line"><span class="function">BOOLEAN <span class="title">ReadProcessMemoryByPid</span><span class="params">(UINT32 dwPid, PVOID pBase, PVOID lpBuffer, UINT32 nSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//根据pid获取PEPROCESS OpenProcess</span></span><br><span class="line">    PEPROCESS Seleted_pEPROCESS = <span class="literal">NULL</span>;</span><br><span class="line">    KdPrint((<span class="string">&quot;zeroko:kernel:ReadMemory pid=%d,pBase=%p  lineNo.%d  is in Func:%s\n&quot;</span>,dwPid,pBase,__LINE__,__FUNCDNAME__));</span><br><span class="line">    <span class="keyword">if</span> (PsLookupProcessByProcessId(dwPid,&amp;Seleted_pEPROCESS)==STATUS_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        BOOLEAN br = KReadProcessMemory(Seleted_pEPROCESS, pBase,nSize, lpBuffer);</span><br><span class="line">        ObDereferenceObject(Seleted_pEPROCESS);</span><br><span class="line">        <span class="keyword">if</span> (br)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        KdPrint((<span class="string">&quot;zeroko:kernel:PsLookupProcessByProcessId Fail...\n&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//apc方式系统回调保护读内存(Process 是要读的进程结构体指针,Address是要读的地址,Length是要读的长度,Buffer存放读到哪里)</span></span><br><span class="line"><span class="comment">//不借助于内核层和三环层的常规通信方式</span></span><br><span class="line"><span class="function">BOOLEAN <span class="title">KReadProcessMemory2</span><span class="params">(IN PEPROCESS Process, IN PVOID Address, IN UINT32 Length, IN OUT PVOID Buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    KAPC_STATE apc_state;</span><br><span class="line">    RtlZeroMemory(&amp;apc_state, <span class="keyword">sizeof</span>(KAPC_STATE));</span><br><span class="line">    <span class="comment">//申请内核空间  在所有进程间通用   (实际上可以不申请空间,如果是零环与三环通信的时候,直接把那个通信缓冲区拿来用就可以了)</span></span><br><span class="line">    PVOID tmpBuf_Kernel = ExAllocatePool(NonPagedPool, Length);</span><br><span class="line">    <span class="keyword">if</span> (!tmpBuf_Kernel) &#123;</span><br><span class="line">        KdPrint((<span class="string">&quot;zeroko:kernel:内核空间申请失败\n&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//也可以改MDL把 进程地址空间  映射到  内核驱动空间</span></span><br><span class="line">    <span class="comment">//中转内存地址中的内容,因为KeStackAttachProcess后,原来的进程R3 Buffer在目标地址里不存在(但如果是直接似乎内核内存,实际上不需要这一步)</span></span><br><span class="line">    <span class="comment">//RtlCopyMemory(tmpBuf_Kernel,Buffer,Length);</span></span><br><span class="line">    <span class="comment">//进入目标进程内存空间</span></span><br><span class="line">    KdPrint((<span class="string">&quot;zeroko:kernel:附加到目标进程Address = %p  BUffer=%p\n&quot;</span>,Address,Buffer));</span><br><span class="line">    KeStackAttachProcess((PVOID)Process, &amp;apc_state);</span><br><span class="line">    <span class="comment">//判断目标地址是否可以访问</span></span><br><span class="line">    BOOLEAN dwRet = MmIsAddressValid(Address);</span><br><span class="line">    <span class="keyword">if</span> (dwRet)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把要读的目标进程中地址对应的内容拷到内核空间中</span></span><br><span class="line">        RtlCopyMemory(tmpBuf_Kernel, Address, Length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        KdPrint((<span class="string">&quot;zeroko:kernel:Error Line37\n&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分离目标进程空间,恢复环境</span></span><br><span class="line">    KeUnstackDetachProcess(&amp;apc_state);</span><br><span class="line">    KdPrint((<span class="string">&quot;zeroko:kernel:分离目标进程\n&quot;</span>));</span><br><span class="line">    <span class="comment">//内核内存复制回原进程内存</span></span><br><span class="line">    RtlCopyMemory(Buffer, tmpBuf_Kernel, Length);</span><br><span class="line">    <span class="comment">//释放作为中转站的内核内存</span></span><br><span class="line">    ExFreePool(tmpBuf_Kernel);</span><br><span class="line">    <span class="keyword">return</span> dwRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//apc方式系统回调保护读内存(Process 是要读的进程结构体指针,Address是要读的地址,Length是要读的长度,Buffer存放读到哪里)</span></span><br><span class="line"><span class="comment">//借助于内核层和三环层的常规通信方式</span></span><br><span class="line"><span class="function">BOOLEAN <span class="title">KReadProcessMemory</span><span class="params">(IN PEPROCESS Process, IN PVOID Address, IN UINT32 Length, IN OUT PVOID Buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    KAPC_STATE apc_state;</span><br><span class="line">    RtlZeroMemory(&amp;apc_state, <span class="keyword">sizeof</span>(KAPC_STATE));</span><br><span class="line">    <span class="comment">//也可以改MDL把 进程地址空间  映射到  内核驱动空间</span></span><br><span class="line">    <span class="comment">//进入目标进程内存空间</span></span><br><span class="line">    KdPrint((<span class="string">&quot;zeroko:kernel:附加到目标进程Address = %p  BUffer=%p\n&quot;</span>, Address, Buffer));</span><br><span class="line">    KeStackAttachProcess((PVOID)Process, &amp;apc_state);</span><br><span class="line">    <span class="comment">//判断目标地址是否可以访问</span></span><br><span class="line">    BOOLEAN dwRet = MmIsAddressValid(Address);</span><br><span class="line">    <span class="keyword">if</span> (dwRet)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把要读的目标进程中地址对应的内容拷到内核空间中</span></span><br><span class="line">        RtlCopyMemory(Buffer, Address, Length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        KdPrint((<span class="string">&quot;zeroko:kernel:Error Line37\n&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分离目标进程空间,恢复环境</span></span><br><span class="line">    KeUnstackDetachProcess(&amp;apc_state);</span><br><span class="line">    <span class="comment">//KdPrint((&quot;zeroko:kernel:分离目标进程\n&quot;));</span></span><br><span class="line">    <span class="comment">//内核内存复制回原进程内存</span></span><br><span class="line">    <span class="keyword">return</span> dwRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="写进程"><a href="#写进程" class="headerlink" title="写进程"></a>写进程</h5><p>下面函数<strong>不能写只读内存</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//远程写(不可以写只读内存):将UserBuffer(用户传过来的内容的地址)写入Process进程的Address地址,内容长度为Length</span></span><br><span class="line"><span class="function">BOOLEAN <span class="title">KWriteProcessMemory</span><span class="params">(IN PEPROCESS Process, IN PVOID Address, IN UINT32 Length, IN PVOID UserBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    KAPC_STATE apc_state;</span><br><span class="line">    RtlZeroMemory(&amp;apc_state, <span class="keyword">sizeof</span>(KAPC_STATE));</span><br><span class="line">    <span class="comment">//申请内核空间  在所有进程间通用   </span></span><br><span class="line">    PVOID tmpBuf_Kernel = ExAllocatePool(NonPagedPool, Length);</span><br><span class="line">    <span class="keyword">if</span> (!tmpBuf_Kernel) &#123;</span><br><span class="line">        KdPrint((<span class="string">&quot;zeroko:kernel:内核空间申请失败\n&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    BOOLEAN dwRet = MmIsAddressValid(UserBuffer);</span><br><span class="line">    <span class="keyword">if</span> (dwRet)</span><br><span class="line">    &#123;</span><br><span class="line">        RtlCopyMemory(tmpBuf_Kernel, UserBuffer, Length);<span class="comment">//真正的写操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        KdPrint((<span class="string">&quot;zeroko:kernel:UserBuffer memory Error Line37\n&quot;</span>));</span><br><span class="line">        ExFreePool(tmpBuf_Kernel);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//附加要写的目标进程</span></span><br><span class="line">    KeStackAttachProcess((PVOID)Process, &amp;apc_state);</span><br><span class="line">    dwRet = MmIsAddressValid(Address);</span><br><span class="line">    <span class="comment">//写入内存</span></span><br><span class="line">    <span class="keyword">if</span> (dwRet)</span><br><span class="line">    &#123;</span><br><span class="line">        RtlCopyMemory(Address, tmpBuf_Kernel, Length);<span class="comment">//真正的写操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        KdPrint((<span class="string">&quot;zeroko:kernel:Error Line37\n&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    KeUnstackDetachProcess(&amp;apc_state);</span><br><span class="line">    ExFreePool(tmpBuf_Kernel);</span><br><span class="line">    <span class="keyword">return</span> dwRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过id远程写,用到了自定义的KWriteProcessMemory函数</span></span><br><span class="line"><span class="comment">//对dwPid进程的pBase地址,写长度为nSize的在lpBuffer地址的内存</span></span><br><span class="line"><span class="function">BOOLEAN <span class="title">WriteProcessMemoryByPid</span><span class="params">(UINT32 dwPid, PVOID pBase, PVOID lpBuffer, UINT32 nSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//根据pid获取PEPROCESS OpenProcess</span></span><br><span class="line">    PEPROCESS Seleted_pEPROCESS = <span class="literal">NULL</span>;</span><br><span class="line">    KdPrint((<span class="string">&quot;zeroko:kernel:WriteMemory pid=%d,pBase=%p  lineNo.%d  is in Func:%s\n&quot;</span>, dwPid, pBase, __LINE__, __FUNCDNAME__));</span><br><span class="line">    <span class="keyword">if</span> (PsLookupProcessByProcessId(dwPid, &amp;Seleted_pEPROCESS) == STATUS_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        BOOLEAN br = KWriteProcessMemory(Seleted_pEPROCESS, pBase, nSize, lpBuffer);</span><br><span class="line">        ObDereferenceObject(Seleted_pEPROCESS);</span><br><span class="line">        <span class="keyword">if</span> (br)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        KdPrint((<span class="string">&quot;zeroko:kernel:PsLookupProcessByProcessId Fail...\n&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接写入只读内存会蓝屏,下面有写只读内存的方式</p>
<h4 id="MDL方式"><a href="#MDL方式" class="headerlink" title="MDL方式"></a>MDL方式</h4><p>优势:对于大内存远程读取写入有速度优势</p>
<p>上述过渡的内核内存,可以使用MDL映射方式替代:</p>
<p><strong>用到的核心函数</strong></p>
<ol>
<li>IoAllocateMdl   申请映射内存描述信息  IoFreeMdl  释放映射内存描述信息</li>
<li>MmBuildMdlForNonPagedPool  把内存标记为非分页内存,防止数据因为内存不足而被迁移到硬盘上</li>
<li>MmMapLockedPages  锁定内存映射  MmUnmapLockedPages 解除内存映射锁定</li>
</ol>
<p>当不再需要 MDL描述的页的时,请调用<code>MmUnlockPages</code>将它们解除锁定,然后调用<code>IoFreeMdl</code> 来释放它们</p>
<h5 id="读内存"><a href="#读内存" class="headerlink" title="读内存"></a>读内存</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以不借助于内核层和三环层的常规通信方式</span></span><br><span class="line"><span class="function">BOOLEAN <span class="title">KReadProcessMemory3</span><span class="params">(IN PEPROCESS Process, IN PVOID Address, IN UINT32 Length, IN PVOID UserBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    KAPC_STATE apc_state;</span><br><span class="line">    RtlZeroMemory(&amp;apc_state, <span class="keyword">sizeof</span>(KAPC_STATE));</span><br><span class="line">    <span class="comment">//为UserBuffer创建MDL内存描述</span></span><br><span class="line">    <span class="comment">//创建MDL来读取内存</span></span><br><span class="line">    PMDL g_pmdl = IoAllocateMdl(UserBuffer, Length, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!g_pmdl)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//标记为非分页内存,避免置换到硬盘上</span></span><br><span class="line">    MmBuildMdlForNonPagedPool(g_pmdl);</span><br><span class="line">    <span class="comment">//锁定,映射用户内存到内核内存    Mapped指向UserBuffer地址指向的同一个物理内存</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>* Mapped = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)MmMapLockedPages(g_pmdl, KernelMode);</span><br><span class="line">    <span class="keyword">if</span> (!Mapped)<span class="comment">//映射失败</span></span><br><span class="line">    &#123;</span><br><span class="line">        IoFreeMdl(g_pmdl);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    KeStackAttachProcess((PVOID)Process, &amp;apc_state);</span><br><span class="line">    <span class="comment">//判断目标地址是否可访问</span></span><br><span class="line">    BOOLEAN dwRet = MmIsAddressValid(Address);</span><br><span class="line">    <span class="keyword">if</span> (dwRet)</span><br><span class="line">    &#123;</span><br><span class="line">        RtlCopyMemory(Mapped, Address, Length);<span class="comment">//此处实际上已经拷贝到想要的地址中去了.  写内存只需要调换此处的Mapped和Address</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        KdPrint((<span class="string">&quot;zeroko:kernel:Error Line37\n&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    KeUnstackDetachProcess(&amp;apc_state);</span><br><span class="line">    IoFreeMdl(g_pmdl);</span><br><span class="line">    <span class="comment">//MDL清理工作</span></span><br><span class="line">    <span class="comment">//释放MDL相关资源</span></span><br><span class="line">    MmUnmapLockedPages((PVOID)Mapped, g_pmdl);</span><br><span class="line">    IoFreeMdl(g_pmdl);</span><br><span class="line">    <span class="keyword">return</span> dwRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="写内存"><a href="#写内存" class="headerlink" title="写内存"></a>写内存</h5><p>三环是通过 <code>VirtualProtectEx</code> 或 <code>VirtualQueryEx</code> 函数来修改页面属性来达到写只读内存的目的(E.g. CE修改器就是采取这套方式)</p>
<p><strong>下面是可以用于写只读内存的驱动实现方式</strong></p>
<p>核心点是: <code>MmProbeAndLockPages</code> 将 <code>MdlFlags = MDL_WRITE_OPERATION | MDL_ALLOCATED_FIXED_SIZE | MDL_PAGES_LOCKED</code> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以用于写只读内存    将UserBuffer(用户传过来的内容的地址)写入Process进程的Address地址,内容长度为Length</span></span><br><span class="line"><span class="function">BOOLEAN <span class="title">KWriteProcessMemory</span><span class="params">(IN PEPROCESS Process, IN PVOID Address, IN UINT32 Length, IN PVOID UserBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    KAPC_STATE apc_state;</span><br><span class="line">    RtlZeroMemory(&amp;apc_state, <span class="keyword">sizeof</span>(KAPC_STATE));</span><br><span class="line">    <span class="comment">//进程挂靠</span></span><br><span class="line">    KeStackAttachProcess((PVOID)Process, &amp;apc_state);</span><br><span class="line">    BOOLEAN dwRet = MmIsAddressValid(Address);</span><br><span class="line">    <span class="keyword">if</span> (!dwRet)</span><br><span class="line">    &#123;</span><br><span class="line">        KdPrint((<span class="string">&quot;zeroko:kernel: ERROR LINE%d\n&quot;</span>, __LINE__));</span><br><span class="line">        KeUnstackDetachProcess(&amp;apc_state);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//为UserBuffer创建MDL内存描述</span></span><br><span class="line">    PMDL g_pmdl = IoAllocateMdl(Address, Length, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!g_pmdl)</span><br><span class="line">    &#123;</span><br><span class="line">        KdPrint((<span class="string">&quot;zeroko:kernel: ERROR LINE%d\n&quot;</span>, __LINE__));</span><br><span class="line">        KeUnstackDetachProcess(&amp;apc_state);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//标记为非分页内存</span></span><br><span class="line">    MmBuildMdlForNonPagedPool(g_pmdl);</span><br><span class="line">    <span class="comment">//设置标志位</span></span><br><span class="line">    g_pmdl-&gt;MdlFlags = MDL_WRITE_OPERATION | MDL_ALLOCATED_FIXED_SIZE | MDL_PAGES_LOCKED; </span><br><span class="line">    <span class="comment">//锁定映射关系</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>* Mapped = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)MmMapLockedPages(g_pmdl, KernelMode);</span><br><span class="line">    <span class="keyword">if</span> (!Mapped)</span><br><span class="line">    &#123;</span><br><span class="line">        KdPrint((<span class="string">&quot;zeroko:kernel: ERROR LINE%d\n&quot;</span>, __LINE__));</span><br><span class="line">        IoFreeMdl(g_pmdl);</span><br><span class="line">        KeUnstackDetachProcess(&amp;apc_state);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//映射成功后,退出挂靠环境</span></span><br><span class="line">    KeUnstackDetachProcess(&amp;apc_state);</span><br><span class="line">    RtlCopyMemory(Mapped, UserBuffer, Length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//恢复环境</span></span><br><span class="line">    MmUnmapLockedPages((PVOID)Mapped, g_pmdl);</span><br><span class="line">    IoFreeMdl(g_pmdl);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CR0方式写只读内存"><a href="#CR0方式写只读内存" class="headerlink" title="CR0方式写只读内存"></a>CR0方式写只读内存</h4><p>内存类型</p>
<ol>
<li>PagedPool   可以被置换到硬盘中,一般存储数据</li>
<li>NonPagedPool 不能被置换到硬盘中,驻留在内存中,一般用来存储代码</li>
</ol>
<p>如果执行代码到PagedPool的内存中很有可能蓝屏</p>
<p>在<strong>内核空间中所有内存都是可读可写可执行的</strong>,故没有类似用户态下的VirtualProtect改变内存属性的函数,但是并<strong>不意味着可以随意执行和改写内存中的代码,要满足2个条件</strong>:</p>
<ol>
<li>关闭内存写保护  通过操作CR0寄存器实现</li>
<li>提升IRQL级别(防止执行出错)     使用 <code>KeRaiseIrqlToDpcLevel</code>和 <code>KeLowerIrql</code> 实现</li>
</ol>
<p><code>__readcr0()函数</code> 需要头文件: <code>#include &lt;intrin.h&gt;</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关闭内存写保护和提升IRQL</span></span><br><span class="line">KIRQL irql = KeRaiseIrqlToDpcLevel();<span class="comment">//不提高中断等级无法写CR0</span></span><br><span class="line">UINT64 cr0 = __readcr0();</span><br><span class="line">cr0 &amp;= <span class="number">0xfffffffffffeffff</span>;</span><br><span class="line">__writecr0(cr0);</span><br><span class="line">_disable();</span><br><span class="line"></span><br><span class="line"><span class="comment">//还原  (开启内存写保护)</span></span><br><span class="line">UINT64 cr0 = __readcr0();</span><br><span class="line">cr0 |= <span class="number">0x10000</span>;</span><br><span class="line">_enable();</span><br><span class="line">KeLowerIrql(irql);</span><br><span class="line"><span class="comment">//内存操作放到二者之间就可以正常操作内存了</span></span><br></pre></td></tr></table></figure>

<h4 id="物理内存读写内存方法"><a href="#物理内存读写内存方法" class="headerlink" title="物理内存读写内存方法"></a>物理内存读写内存方法</h4><p>物理内存读写内存速度比较慢,不建议用于频繁地读写内存,<strong>一般用于注入代码</strong></p>
<h5 id="核心函数"><a href="#核心函数" class="headerlink" title="核心函数"></a><strong>核心函数</strong></h5><ul>
<li><code>ZwMapViewOfSection</code> 把物理地址映射到当前进程 </li>
<li><code>ZeUnmapViewOfSection</code>  取消映射</li>
<li><code>MmGetPhysicalAddress</code> 虚拟地址转换为物理地址</li>
</ul>
<h6 id="ZwMapViewOfSection"><a href="#ZwMapViewOfSection" class="headerlink" title="ZwMapViewOfSection"></a>ZwMapViewOfSection</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSYSAPI NTSTATUS <span class="title">ZwMapViewOfSection</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]                HANDLE          SectionHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]                HANDLE          ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, out]           PVOID           *BaseAddress,<span class="comment">//映射后返回出来的虚拟地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in]                ULONG_PTR       ZeroBits,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]                SIZE_T          CommitSize,<span class="comment">//想要映射的字节大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in, out, optional] PLARGE_INTEGER  SectionOffset,<span class="comment">//要映射的物理地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in, out]           PSIZE_T         ViewSize,<span class="comment">//实际映射的字节大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in]                SECTION_INHERIT InheritDisposition,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]                ULONG           AllocationType,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]                ULONG           Win32Protect</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h5><h6 id="最外层的读写内存接口"><a href="#最外层的读写内存接口" class="headerlink" title="最外层的读写内存接口"></a>最外层的读写内存接口</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读dwPid中的pBase地址中长nSize的值搭配lpBuffer地址中</span></span><br><span class="line"><span class="function">BOOLEAN <span class="title">ReadPhysicalMemoryByPid</span><span class="params">(UINT32 dwPid, PVOID pBase, PVOID lpBuffer, UINT32 nSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PVOID physicalAddress = GetPhysicalAddress(dwPid, pBase);</span><br><span class="line">    KdPrint((<span class="string">&quot;zeroko:kernel:获取到的物理地址为%llx\n&quot;</span>, physicalAddress));</span><br><span class="line">    <span class="keyword">if</span> (physicalAddress)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ReadPhysicalMemory(physicalAddress, nSize, lpBuffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将lpBuffer地址中长nSize的值写到dwPid中的pBase地址</span></span><br><span class="line"><span class="function">BOOLEAN <span class="title">WritePhysicalMemoryByPid</span><span class="params">(UINT32 dwPid, PVOID pBase, PVOID lpBuffer, UINT32 nSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PVOID physicalAddress = GetPhysicalAddress(dwPid, pBase);</span><br><span class="line">    KdPrint((<span class="string">&quot;zeroko:kernel:获取到的物理地址为%llx\n&quot;</span>, physicalAddress));</span><br><span class="line">    <span class="keyword">if</span> (physicalAddress)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> WritePhysicalMemory(physicalAddress, nSize, lpBuffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="获取最大物理地址函数"><a href="#获取最大物理地址函数" class="headerlink" title="获取最大物理地址函数"></a>获取最大物理地址函数</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">UINT64 g_maxPhysAddress = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//利用cpuid取出 物理地址Bits</span></span><br><span class="line"><span class="comment">//获取最大的物理地址</span></span><br><span class="line"><span class="function">UINT64 <span class="title">getg_maxPhysAddress</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (g_maxPhysAddress == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> physicalbits;</span><br><span class="line">        UINT32 r[<span class="number">4</span>]; <span class="comment">//四个整数的数组，包含在 EAX、EBX、ECX 和 EDX 中返回的有关 CPU 支持的功能的信息</span></span><br><span class="line">        __cpuid(r, <span class="number">0x80000008</span>); <span class="comment">//只有r[0]的前 8位和 8至15们有用 后边3个 全保留</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//get max physical address</span></span><br><span class="line">        physicalbits = r[<span class="number">0</span>] &amp; <span class="number">0xff</span>;</span><br><span class="line"></span><br><span class="line">        g_maxPhysAddress = <span class="number">0xFFFFFFFFFFFFFFFF</span>ULL;</span><br><span class="line">        g_maxPhysAddress = g_maxPhysAddress &gt;&gt; physicalbits; <span class="comment">//if physicalbits==36 then g_maxPhysAddress=0x000000000fffffff</span></span><br><span class="line">        g_maxPhysAddress = ~(g_maxPhysAddress &lt;&lt; physicalbits); <span class="comment">//&lt;&lt; 36 = 0xfffffff000000000 .  after inverse : 0x0000000fffffffff		</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> g_maxPhysAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="获取物理地址的值函数"><a href="#获取物理地址的值函数" class="headerlink" title="获取物理地址的值函数"></a>获取物理地址的值函数</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将ProcessId目标进程中的虚拟地址转为物理地址</span></span><br><span class="line"><span class="function">PVOID <span class="title">GetPhysicalAddress</span><span class="params">(UINT64 ProcessId, PVOID vBaseAddress)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PEPROCESS selectedProcess;<span class="comment">//ProcessId的进程对象</span></span><br><span class="line">    PHYSICAL_ADDRESS physical;</span><br><span class="line">    physical.QuadPart = <span class="number">0</span>;<span class="comment">//PHYSICAL_ADDRESS实际上就是INT64 8字节</span></span><br><span class="line">    NTSTATUS ntStatus = STATUS_SUCCESS;</span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (PsLookupProcessByProcessId((PVOID)(ProcessId), &amp;selectedProcess)==STATUS_SUCCESS)</span><br><span class="line">        &#123;</span><br><span class="line">            KAPC_STATE apc_state;</span><br><span class="line">            RtlZeroMemory(&amp;apc_state, <span class="keyword">sizeof</span>(apc_state));</span><br><span class="line">            KeStackAttachProcess((PVOID)selectedProcess, &amp;apc_state);<span class="comment">//关键地方,附加到指定进程</span></span><br><span class="line">            __try</span><br><span class="line">            &#123;</span><br><span class="line">                physical = MmGetPhysicalAddress((PVOID)vBaseAddress);<span class="comment">//把虚拟地址转换为物理地址</span></span><br><span class="line">            &#125;</span><br><span class="line">            __finally</span><br><span class="line">            &#123;</span><br><span class="line">                KeUnstackDetachProcess(&amp;apc_state);</span><br><span class="line">            &#125;</span><br><span class="line">            ObDereferenceObject(selectedProcess);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __except (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ntStatus = STATUS_UNSUCCESSFUL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ntStatus == STATUS_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (PVOID)physical.QuadPart;<span class="comment">//返回物理地址</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">//失败返回NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="物理内存读写函数"><a href="#物理内存读写函数" class="headerlink" title="物理内存读写函数"></a>物理内存读写函数</h6><p><strong>读函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于分页内存来说，调用MmProbeAndLockPages以及MmGetSystemAddressForMdlSafe来锁定内存页，以防止被page out出去；</span></span><br><span class="line"><span class="comment">//对于非分页内存而言，调用MmBuildMdlForNonPagedPool映射到物理内存上。</span></span><br><span class="line"><span class="comment">//__noop((&quot;zeroko:kernel:Too small map&quot;));</span></span><br><span class="line"><span class="comment">//physicalBase本身就是物理地址</span></span><br><span class="line"><span class="comment">//读取物理地址的值physicalBase,读到output地址中,读bytestoread长度</span></span><br><span class="line"><span class="function">BOOLEAN <span class="title">ReadPhysicalMemory</span><span class="params">(<span class="keyword">char</span>* physicalBase, UINT_PTR bytestoread, <span class="keyword">void</span>* output)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UNICODE_STRING	physmemString;</span><br><span class="line">    OBJECT_ATTRIBUTES attributes;</span><br><span class="line">    HANDLE	physmem = <span class="literal">NULL</span>;</span><br><span class="line">    UCHAR* vaddress; <span class="comment">// 用于映射后的虚地址 供访问</span></span><br><span class="line">    KdPrint((<span class="string">&quot;zeroko:kernel:要读的物理地址为%llx  最大物理地址为%llx \n&quot;</span>, physicalBase, getg_maxPhysAddress()));</span><br><span class="line">    <span class="comment">//校验是否超过最大物理内存</span></span><br><span class="line">    <span class="keyword">if</span> (((UINT64)physicalBase &gt; getg_maxPhysAddress()) || ((UINT64)physicalBase + bytestoread &gt; getg_maxPhysAddress()))</span><br><span class="line">    &#123;</span><br><span class="line">        KdPrint((<span class="string">&quot;zeroko:kernel: Invalid physical address\n&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//初始化映射物理内存需要用到的数据</span></span><br><span class="line">        RtlInitUnicodeString(&amp;physmemString, <span class="string">L&quot;\\device\\physicalmemory&quot;</span>);<span class="comment">//要访问物理内存,需要用到该设备描述</span></span><br><span class="line">        InitializeObjectAttributes(&amp;attributes,&amp;physmemString, OBJ_CASE_INSENSITIVE, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        NTSTATUS ntStatus = ZwOpenSection(&amp;physmem, SECTION_ALL_ACCESS, &amp;attributes);</span><br><span class="line">        <span class="keyword">if</span> (ntStatus == STATUS_SUCCESS)</span><br><span class="line">        &#123;</span><br><span class="line">            PHYSICAL_ADDRESS	viewBase;<span class="comment">//物理内存地址</span></span><br><span class="line">            viewBase.QuadPart = (ULONGLONG)(physicalBase);</span><br><span class="line">            KdPrint((<span class="string">&quot;zeroko:kernel:ReadPhysicalMemory:viewBase.QuadPart=%x&quot;</span>, viewBase.QuadPart));</span><br><span class="line">            SIZE_T length = bytestoread;</span><br><span class="line">            <span class="comment">//映射物理内存地址到当前进程的虚地址空间</span></span><br><span class="line">            ntStatus = ZwMapViewOfSection(</span><br><span class="line">                physmem,  <span class="comment">//sectionhandle</span></span><br><span class="line">                NtCurrentProcess(), <span class="comment">//processhandle (should be -1)</span></span><br><span class="line">                &amp;vaddress, <span class="comment">//BaseAddress 映射产生的虚拟地址</span></span><br><span class="line">                <span class="number">0L</span>, <span class="comment">//ZeroBits</span></span><br><span class="line">                length, <span class="comment">//CommitSize</span></span><br><span class="line">                &amp;viewBase, <span class="comment">//SectionOffset  要映射的物理地址</span></span><br><span class="line">                &amp;length, <span class="comment">//ViewSize</span></span><br><span class="line">                ViewShare,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                PAGE_READWRITE);</span><br><span class="line">            <span class="comment">//映射成功的话</span></span><br><span class="line">            <span class="keyword">if</span> (ntStatus == STATUS_SUCCESS &amp;&amp; vaddress != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//实际映射的长度大于要写入的内容长度</span></span><br><span class="line">                <span class="keyword">if</span> (bytestoread &gt; length)</span><br><span class="line">                &#123;</span><br><span class="line">                    KdPrint((<span class="string">&quot;zeroko:kernel:Too small map\n&quot;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//真正的读操作</span></span><br><span class="line">                    RtlCopyMemory(output, vaddress, bytestoread);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//解除映射</span></span><br><span class="line">                ZwUnmapViewOfSection(NtCurrentProcess(), vaddress);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __except (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        KdPrint((<span class="string">&quot;zeroko:kernel:Failure mapping physical memory&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭节对象</span></span><br><span class="line">    ZwClose(physmem);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>写函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写物理地址函数</span></span><br><span class="line"><span class="comment">//将input地址的长度为nSizeWrite的内存写到physicalBase物理地址中</span></span><br><span class="line"><span class="function">BOOLEAN <span class="title">WritePhysicalMemory</span><span class="params">(<span class="keyword">char</span>* physicalBase, IN UINT_PTR nSizeWrite, IN PVOID input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UNICODE_STRING	physmemString;</span><br><span class="line">    OBJECT_ATTRIBUTES attributes;</span><br><span class="line">    HANDLE	physmem = <span class="literal">NULL</span>;</span><br><span class="line">    UCHAR* vaddress; <span class="comment">// 用于映射后的虚地址 供访问</span></span><br><span class="line">    <span class="comment">//校验是否超过最大物理内存</span></span><br><span class="line">    <span class="keyword">if</span> (((UINT64)physicalBase &gt; getg_maxPhysAddress()) || ((UINT64)physicalBase + nSizeWrite &gt; getg_maxPhysAddress()))</span><br><span class="line">    &#123;</span><br><span class="line">        KdPrint((<span class="string">&quot;zeroko:kernel: Invalid physical address\n&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//初始化映射物理内存需要用到的数据</span></span><br><span class="line">        RtlInitUnicodeString(&amp;physmemString, <span class="string">L&quot;\\device\\physicalmemory&quot;</span>);<span class="comment">//要访问物理内存,需要用到该设备描述</span></span><br><span class="line">        InitializeObjectAttributes(&amp;attributes, &amp;physmemString, OBJ_CASE_INSENSITIVE, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        NTSTATUS ntStatus = ZwOpenSection(&amp;physmem, SECTION_ALL_ACCESS, &amp;attributes);</span><br><span class="line">        <span class="keyword">if</span> (ntStatus == STATUS_SUCCESS)</span><br><span class="line">        &#123;</span><br><span class="line">            PHYSICAL_ADDRESS	viewBase;<span class="comment">//物理内存地址</span></span><br><span class="line">            viewBase.QuadPart = (ULONGLONG)(physicalBase);</span><br><span class="line">          KdPrint((<span class="string">&quot;zeroko:kernel:ReadPhysicalMemory:viewBase.QuadPart=%x&quot;</span>, viewBase.QuadPart));</span><br><span class="line">            SIZE_T length = <span class="number">0x2000</span>;</span><br><span class="line">            <span class="comment">//映射物理内存地址到当前进程的虚地址空间</span></span><br><span class="line">            ntStatus = ZwMapViewOfSection(</span><br><span class="line">                physmem,  <span class="comment">//sectionhandle</span></span><br><span class="line">                NtCurrentProcess(), <span class="comment">//processhandle (should be -1)</span></span><br><span class="line">                &amp;vaddress, <span class="comment">//BaseAddress 映射产生的虚拟地址</span></span><br><span class="line">                <span class="number">0L</span>, <span class="comment">//ZeroBits</span></span><br><span class="line">                length, <span class="comment">//CommitSize</span></span><br><span class="line">                &amp;viewBase, <span class="comment">//SectionOffset  要映射的物理地址</span></span><br><span class="line">                &amp;length, <span class="comment">//ViewSize</span></span><br><span class="line">                ViewShare,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                PAGE_READWRITE);</span><br><span class="line">            <span class="comment">//映射成功的话</span></span><br><span class="line">            <span class="keyword">if</span> (ntStatus == STATUS_SUCCESS &amp;&amp; vaddress != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//实际映射的长度大于要写入的内容长度</span></span><br><span class="line">                <span class="keyword">if</span> (nSizeWrite &gt; length)</span><br><span class="line">                &#123;</span><br><span class="line">                    KdPrint((<span class="string">&quot;zeroko:kernel:Too small map\n&quot;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//真正的写操作</span></span><br><span class="line">                    RtlCopyMemory(vaddress, input, nSizeWrite);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//解除映射</span></span><br><span class="line">                ZwUnmapViewOfSection(NtCurrentProcess(), vaddress);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __except (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        KdPrint((<span class="string">&quot;zeroko:kernel:Failure mapping physical memory&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭节对象</span></span><br><span class="line">    ZwClose(physmem);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="针对对象回调钩子的操作"><a href="#针对对象回调钩子的操作" class="headerlink" title="针对对象回调钩子的操作"></a>针对对象回调钩子的操作</h2><h3 id="遍历进程-线程对象钩子"><a href="#遍历进程-线程对象钩子" class="headerlink" title="遍历进程/线程对象钩子"></a>遍历进程/线程对象钩子</h3><p><strong>兼容win7~win10</strong></p>
<h4 id="需要用的自定义结构和变量"><a href="#需要用的自定义结构和变量" class="headerlink" title="需要用的自定义结构和变量"></a>需要用的自定义结构和变量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//=================================</span></span><br><span class="line"><span class="comment">//下面开始遍历系统回调钩子</span></span><br><span class="line"><span class="comment">//=================================</span></span><br><span class="line"><span class="comment">//需要用到的自定义结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">CALL_BACK_INFO</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ULONG64 Unknow;</span><br><span class="line">    ULONG64 Unknow1;</span><br><span class="line">    UNICODE_STRING AltitudeString;<span class="comment">//该成员决定执行顺序,越大越早被执行</span></span><br><span class="line">    LIST_ENTRY NextEntryItemList; <span class="comment">//(callbacklist) 跟上面开头的那个一样 存储下一个callbacklist</span></span><br><span class="line">    ULONG64 Operations;</span><br><span class="line">    PVOID ObHandle; <span class="comment">//存储详细的数据 版本号 POB_OPERATION_REGISTRATION AltitudeString 也就是本身节点CALL_BACK_INFO 注销时也使用这个 注意是指针 //CALL_BACK_INFO</span></span><br><span class="line">    PVOID ObjectType;</span><br><span class="line">    ULONG64 PreCallbackAddr;</span><br><span class="line">    ULONG64 PostCallbackAddr;</span><br><span class="line">&#125;CALL_BACK_INFO, * PCALL_BACK_INFO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OB_CALLBACK</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    LIST_ENTRY	ListEntry;<span class="comment">//链表结构</span></span><br><span class="line">    ULONG64		Operations;</span><br><span class="line">    PCALL_BACK_INFO		ObHandle;<span class="comment">//该结构指向上面的结构</span></span><br><span class="line">    ULONG64		ObjTypeAddr;</span><br><span class="line">    ULONG64		PreCall;<span class="comment">//前回调函数</span></span><br><span class="line">    ULONG64		PostCall;<span class="comment">//后回调函数</span></span><br><span class="line">&#125; OB_CALLBACK, * POB_CALLBACK;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> ULONG ObjectCallbackListOffset = <span class="number">0</span>;<span class="comment">//win7的该偏移与win10有差异</span></span><br><span class="line"><span class="keyword">extern</span> PSHORT NtBuildNumber;<span class="comment">//导出的内部版本号地址</span></span><br></pre></td></tr></table></figure>

<h4 id="遍历回调需要用到的自定义子函数-包含依赖关系"><a href="#遍历回调需要用到的自定义子函数-包含依赖关系" class="headerlink" title="遍历回调需要用到的自定义子函数(包含依赖关系)"></a>遍历回调需要用到的自定义子函数(包含依赖关系)</h4><ul>
<li><code>GetVersionAndHardCode</code>  </li>
<li><code>GetPsLoadedListModule</code>  获取模块链表头<ul>
<li><code>GetUndocumentFunctionAddress</code>  通过函数名获取未文档化的函数地址</li>
<li><code>GetMovPoint</code></li>
</ul>
</li>
<li><code>ObGetDriverNameByPoint</code>   通过地址,获取对应模块的模块名</li>
</ul>
<p>(上面子函数具备通用性的有文字描述)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取版本和对应的硬编码(EnumObRegisterCallBacks函数需要用到的子函数)</span></span><br><span class="line"><span class="function">BOOLEAN <span class="title">GetVersionAndHardCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BOOLEAN b = FALSE;</span><br><span class="line">    <span class="keyword">switch</span> (*NtBuildNumber)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7600</span>:<span class="comment">//win7</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">7601</span>:<span class="comment">//win7</span></span><br><span class="line">    &#123;</span><br><span class="line">        ObjectCallbackListOffset = <span class="number">0xC0</span>;</span><br><span class="line">        b = TRUE;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">9200</span>:<span class="comment">//win8</span></span><br><span class="line">    &#123;</span><br><span class="line">        ObjectCallbackListOffset = <span class="number">0xC8</span>;	<span class="comment">//OBJECT_TYPE.CallbackList</span></span><br><span class="line">        b = TRUE;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">9600</span>:<span class="comment">//win8</span></span><br><span class="line">    &#123;</span><br><span class="line">        ObjectCallbackListOffset = <span class="number">0xC8</span>;	<span class="comment">//OBJECT_TYPE.CallbackList</span></span><br><span class="line">        b = TRUE;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">if</span> (*NtBuildNumber &gt; <span class="number">10000</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ObjectCallbackListOffset = <span class="number">0xc8</span>;</span><br><span class="line">            b = TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取未文档化的函数  </span></span><br><span class="line"><span class="comment">//win7获取函数链表头需要用到的函数(GetPsLoadedListModule用到的子函数)</span></span><br><span class="line"><span class="function">PVOID <span class="title">GetUndocumentFunctionAddress</span><span class="params">(IN PUNICODE_STRING pFunName,</span></span></span><br><span class="line"><span class="params"><span class="function">    IN PUCHAR pStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">    IN UCHAR* pFeatureCode,</span></span></span><br><span class="line"><span class="params"><span class="function">    IN ULONG FeatureCodeNum,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG SerSize,</span></span></span><br><span class="line"><span class="params"><span class="function">    UCHAR SegCode,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG AddNum,</span></span></span><br><span class="line"><span class="params"><span class="function">    BOOLEAN ByName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ULONG dwIndex = <span class="number">0</span>;</span><br><span class="line">    PUCHAR pFunAddress = <span class="literal">NULL</span>;</span><br><span class="line">    ULONG dwCodeNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (pFeatureCode == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (FeatureCodeNum &gt;= <span class="number">15</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (SerSize &gt; <span class="number">0x1024</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (ByName)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pFunName == <span class="literal">NULL</span> || !MmIsAddressValid(pFunName-&gt;Buffer))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        pFunAddress = (PUCHAR)MmGetSystemRoutineAddress(pFunName);</span><br><span class="line">        <span class="keyword">if</span> (pFunAddress == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pStartAddress == <span class="literal">NULL</span> || !MmIsAddressValid(pStartAddress))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        pFunAddress = pStartAddress;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (dwIndex = <span class="number">0</span>; dwIndex &lt; SerSize; dwIndex++)</span><br><span class="line">    &#123;</span><br><span class="line">        __try</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pFunAddress[dwIndex] == pFeatureCode[dwCodeNum] || pFeatureCode[dwCodeNum] == SegCode)</span><br><span class="line">            &#123;</span><br><span class="line">                dwCodeNum++;</span><br><span class="line">                <span class="keyword">if</span> (dwCodeNum == FeatureCodeNum)</span><br><span class="line">                    <span class="keyword">return</span> pFunAddress + dwIndex - dwCodeNum + <span class="number">1</span> + AddNum;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dwCodeNum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        __except (EXCEPTION_EXECUTE_HANDLER)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//win7获取函数链表头需要用到的函数(GetPsLoadedListModule用到的子函数)</span></span><br><span class="line"><span class="function">PVOID <span class="title">GetMovPoint</span><span class="params">(PVOID pCallPoint)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ULONG dwOffset = <span class="number">0</span>;</span><br><span class="line">    ULONG_PTR returnAddress = <span class="number">0</span>;</span><br><span class="line">    LARGE_INTEGER returnAddressTemp = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    PUCHAR pFunAddress = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pCallPoint == <span class="literal">NULL</span> || !MmIsAddressValid(pCallPoint))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    pFunAddress = pCallPoint;</span><br><span class="line">    <span class="comment">// 函数偏移  </span></span><br><span class="line">    RtlCopyMemory(&amp;dwOffset, (PVOID)(pFunAddress + <span class="number">3</span>), <span class="keyword">sizeof</span>(ULONG));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// JMP向上跳转  </span></span><br><span class="line">    <span class="keyword">if</span> ((dwOffset &amp; <span class="number">0x10000000</span>) == <span class="number">0x10000000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dwOffset = dwOffset + <span class="number">7</span> + pFunAddress;</span><br><span class="line">        returnAddressTemp.QuadPart = (ULONG_PTR)pFunAddress &amp; <span class="number">0xFFFFFFFF00000000</span>;</span><br><span class="line">        returnAddressTemp.LowPart = dwOffset;</span><br><span class="line">        returnAddress = returnAddressTemp.QuadPart;</span><br><span class="line">        <span class="keyword">return</span> (PVOID)returnAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    returnAddress = (ULONG_PTR)dwOffset + <span class="number">7</span> + pFunAddress;</span><br><span class="line">    <span class="keyword">return</span> (PVOID)returnAddress;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取模块链表头地址(ObGetDriverNameByPoint函数需要用到的子函数)</span></span><br><span class="line"><span class="function">PVOID <span class="title">GetPsLoadedListModule</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    为什么不使用DriverObject去枚举呢 主要是win10这玩意导出了 追随步伐啊 哈哈</span></span><br><span class="line"><span class="comment">    RtlPcToFileHeader</span></span><br><span class="line"><span class="comment">    text:000000014015D6A3 48 8B 0D 86 50 0E 00                          mov     rcx, qword ptr cs:PsLoadedModuleList</span></span><br><span class="line"><span class="comment">    .text:000000014015D6AA 48 85 C9                                      test    rcx, rcx</span></span><br><span class="line"><span class="comment">    .text:000000014015D6AD 74 28                                         jz      short loc_14015D6D7</span></span><br><span class="line"><span class="comment">    .text:000000014015D6AF 48 8D 15 7A 50 0E 00                          lea     rdx, PsLoadedModuleList</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    UNICODE_STRING usRtlPcToFileHeader = RTL_CONSTANT_STRING(<span class="string">L&quot;RtlPcToFileHeader&quot;</span>);</span><br><span class="line">    UNICODE_STRING usPsLoadedModuleList = RTL_CONSTANT_STRING(<span class="string">L&quot;PsLoadedModuleList&quot;</span>);</span><br><span class="line">    PVOID Point = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">static</span> PVOID PsLoadedListModule = <span class="literal">NULL</span>;</span><br><span class="line">    UCHAR shellcode[<span class="number">11</span>] =</span><br><span class="line">        <span class="string">&quot;\x48\x8b\x0d\x60\x60\x60\x60&quot;</span></span><br><span class="line">        <span class="string">&quot;\x48\x85\xc9&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (PsLoadedListModule)</span><br><span class="line">        <span class="keyword">return</span> PsLoadedListModule;</span><br><span class="line">    <span class="comment">//win10直接就导出了</span></span><br><span class="line">    <span class="keyword">if</span> (*NtBuildNumber &gt; <span class="number">9600</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// win10 PsLoadedModuleList导出</span></span><br><span class="line">        PsLoadedListModule = MmGetSystemRoutineAddress(&amp;usPsLoadedModuleList);</span><br><span class="line">        <span class="keyword">return</span> PsLoadedListModule;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//win7未导出,相对麻烦</span></span><br><span class="line">    Point = GetUndocumentFunctionAddress(&amp;usRtlPcToFileHeader, <span class="literal">NULL</span>, shellcode, <span class="number">10</span>, <span class="number">0xff</span>, <span class="number">0x60</span>, <span class="number">0</span>, TRUE);</span><br><span class="line">    <span class="keyword">if</span> (Point == <span class="literal">NULL</span> || !MmIsAddressValid(Point))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    Point = GetMovPoint(Point);</span><br><span class="line">    <span class="keyword">if</span> (Point == <span class="literal">NULL</span> || !MmIsAddressValid(Point))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    PsLoadedListModule = Point;</span><br><span class="line">    <span class="keyword">return</span> PsLoadedListModule;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过某地址,获得该地址所处的模块对应的模块名(主要用于判断回调函数地址属于哪个模块)</span></span><br><span class="line"><span class="comment">//(EnumObRegisterCallBacks函数需要用到的子函数)</span></span><br><span class="line"><span class="function">BOOLEAN <span class="title">ObGetDriverNameByPoint</span><span class="params">(ULONG_PTR Point, OUT WCHAR* szDriverName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PLDR_DATA_TABLE_ENTRY Begin = <span class="literal">NULL</span>;</span><br><span class="line">    PLIST_ENTRY Head = <span class="literal">NULL</span>;</span><br><span class="line">    PLIST_ENTRY Next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取模块链表头</span></span><br><span class="line">    Begin = GetPsLoadedListModule();</span><br><span class="line">    <span class="comment">//开始遍历模块链表</span></span><br><span class="line">    <span class="keyword">if</span> (Begin == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    Head = (PLIST_ENTRY)Begin-&gt;InLoadOrderLinks.Flink;</span><br><span class="line">    Next = Head-&gt;Flink;</span><br><span class="line">    <span class="comment">//遍历模块地址,判断地址是处于哪个模块</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        PLDR_DATA_TABLE_ENTRY Entry = CONTAINING_RECORD(Next, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);</span><br><span class="line">        Next = Next-&gt;Flink;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((ULONG_PTR)Entry-&gt;DllBase &lt;= Point &amp;&amp; Point &lt;= ((ULONG_PTR)Entry-&gt;DllBase + Entry-&gt;SizeOfImage))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (szDriverName == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> FALSE;</span><br><span class="line">            RtlZeroMemory(szDriverName, <span class="number">600</span>);</span><br><span class="line">            RtlCopyMemory(szDriverName, Entry-&gt;BaseDllName.Buffer, Entry-&gt;BaseDllName.Length);</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (Next != Head-&gt;Flink);<span class="comment">//循环链表,如果下一个指针再次指向首节点,则遍历结束</span></span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="遍历回调函数"><a href="#遍历回调函数" class="headerlink" title="遍历回调函数"></a>遍历回调函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历所有 进程  线程  注册的ObRegisterCallBacks回调</span></span><br><span class="line"><span class="function">ULONG <span class="title">EnumObRegisterCallBacks</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ULONG c = <span class="number">0</span>;<span class="comment">//回调个数计数</span></span><br><span class="line">    PLIST_ENTRY CurrEntry = <span class="literal">NULL</span>;</span><br><span class="line">    POB_CALLBACK pObCallback;</span><br><span class="line">    ULONG64 ObProcessCallbackListHead = <span class="number">0</span>;</span><br><span class="line">    ULONG64 ObThreadCallbackListHead = <span class="number">0</span>;</span><br><span class="line">    WCHAR* szDriverBaseName = <span class="literal">NULL</span>;</span><br><span class="line">    szDriverBaseName = ExAllocatePool(NonPagedPool, <span class="number">600</span>);</span><br><span class="line">    <span class="keyword">if</span> (szDriverBaseName == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    RtlZeroMemory(szDriverBaseName, <span class="number">600</span>);</span><br><span class="line">    GetVersionAndHardCode();</span><br><span class="line">    <span class="comment">//PsProcessType和PsThreadType是导出的,直接使用   ObjectCallbackListOffset和ObjectCallbackListOffset需要自己计算出来</span></span><br><span class="line">    ObProcessCallbackListHead = *(ULONG64*)PsProcessType + ObjectCallbackListOffset;<span class="comment">//获取进程链表头</span></span><br><span class="line">    ObThreadCallbackListHead = *(ULONG64*)PsThreadType + ObjectCallbackListOffset;<span class="comment">//获取线程链表头</span></span><br><span class="line">    <span class="comment">//遍历进程回调</span></span><br><span class="line">    KdPrint((<span class="string">&quot;zeroko:kernel:进程对象回调:\n&quot;</span>));</span><br><span class="line">    CurrEntry = ((PLIST_ENTRY)ObProcessCallbackListHead)-&gt;Flink;</span><br><span class="line">    <span class="keyword">if</span> (CurrEntry == <span class="literal">NULL</span> || !MmIsAddressValid(CurrEntry))</span><br><span class="line">    &#123;</span><br><span class="line">        ExFreePool(szDriverBaseName);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        pObCallback = (POB_CALLBACK)CurrEntry;</span><br><span class="line">        <span class="keyword">if</span> (pObCallback-&gt;ObHandle != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//遍历所有进程回调前函数,并且打印所属驱动名</span></span><br><span class="line">            <span class="keyword">if</span> (ObGetDriverNameByPoint(pObCallback-&gt;PreCall, szDriverBaseName))</span><br><span class="line">                DbgPrint(<span class="string">&quot;zeroko:kernel:&gt;DriverName=%S ObHandle=%p  Index=%wZ PreCall=%p PostCall=%p \n&quot;</span>,</span><br><span class="line">                    szDriverBaseName,</span><br><span class="line">                    pObCallback-&gt;ObHandle,</span><br><span class="line">                    &amp;pObCallback-&gt;ObHandle-&gt;AltitudeString,</span><br><span class="line">                    pObCallback-&gt;PreCall,</span><br><span class="line">                    pObCallback-&gt;PostCall);</span><br><span class="line">            c++;</span><br><span class="line">        &#125;</span><br><span class="line">        CurrEntry = CurrEntry-&gt;Flink;</span><br><span class="line">    &#125; <span class="keyword">while</span> (CurrEntry != (PLIST_ENTRY)ObProcessCallbackListHead);</span><br><span class="line">    <span class="comment">//遍历线程回调</span></span><br><span class="line">    DbgPrint(<span class="string">&quot;zeroko:kernel:-&gt;线程对象回调:\n&quot;</span>);</span><br><span class="line">    CurrEntry = ((PLIST_ENTRY)ObThreadCallbackListHead)-&gt;Flink;</span><br><span class="line">    <span class="keyword">if</span> (CurrEntry == <span class="literal">NULL</span> || !MmIsAddressValid(CurrEntry))</span><br><span class="line">    &#123;</span><br><span class="line">        ExFreePool(szDriverBaseName);</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        pObCallback = (POB_CALLBACK)CurrEntry;</span><br><span class="line">        <span class="keyword">if</span> (pObCallback-&gt;ObHandle != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (ObGetDriverNameByPoint(pObCallback-&gt;PreCall, szDriverBaseName))</span><br><span class="line">                DbgPrint(<span class="string">&quot;zeroko:kernel:&gt;DriverName=%S ObHandle=%p  Index=%wZ PreCall=%p PostCall=%p \n&quot;</span>,</span><br><span class="line">                    szDriverBaseName,</span><br><span class="line">                    pObCallback-&gt;ObHandle,</span><br><span class="line">                    &amp;pObCallback-&gt;ObHandle-&gt;AltitudeString,</span><br><span class="line">                    pObCallback-&gt;PreCall,</span><br><span class="line">                    pObCallback-&gt;PostCall);</span><br><span class="line">            c++;</span><br><span class="line">        &#125;</span><br><span class="line">        CurrEntry = CurrEntry-&gt;Flink;</span><br><span class="line">    &#125; <span class="keyword">while</span> (CurrEntry != (PLIST_ENTRY)ObThreadCallbackListHead);</span><br><span class="line">    DbgPrint(<span class="string">&quot;zeroko:kernel:ObCallback count: %ld\n&quot;</span>, c);</span><br><span class="line">    ExFreePool(szDriverBaseName);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历部分输出如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">zeroko:kernel:进程对象回调:</span><br><span class="line">zeroko:kernel:&gt;DriverName=<span class="number">360F</span>sFlt.sys ObHandle=FFFFB0837FB8C960  Index=<span class="number">425000</span> PreCall=FFFFF8055984DF30 PostCall=FFFFF8055984DF90 </span><br><span class="line">zeroko:kernel:&gt;DriverName=<span class="number">360B</span>ox64.sys ObHandle=FFFFB0837FB8DE60  Index=<span class="number">382310</span> PreCall=FFFFF8055991BB20 PostCall=FFFFF8055991BB2C </span><br><span class="line">zeroko:kernel:&gt;DriverName=sysdiag.sys ObHandle=FFFFB0837F8D3C90  Index=<span class="number">324600</span> PreCall=FFFFF80559E562B0 PostCall=<span class="number">0000000000000000</span> </span><br><span class="line">zeroko:kernel:-&gt;线程对象回调:</span><br><span class="line">zeroko:kernel:&gt;DriverName=<span class="number">360F</span>sFlt.sys ObHandle=FFFFB0837FB8C960  Index=<span class="number">425000</span> PreCall=FFFFF8055984DF30 PostCall=FFFFF8055984DF90 </span><br><span class="line">zeroko:kernel:&gt;DriverName=<span class="number">360B</span>ox64.sys ObHandle=FFFFB0837FB8DE60  Index=<span class="number">382310</span> PreCall=FFFFF8055991BB20 PostCall=FFFFF8055991BB2C </span><br><span class="line">zeroko:kernel:ObCallback count: <span class="number">5</span></span><br><span class="line"><span class="comment">//遍历结果中Index越大的越早被执行</span></span><br></pre></td></tr></table></figure>

<h3 id="完美过掉对象保护钩子"><a href="#完美过掉对象保护钩子" class="headerlink" title="完美过掉对象保护钩子"></a>完美过掉对象保护钩子</h3><p><strong>[[绕过回调保护思路]]</strong>:借助于<code>OB_CALLBACK.CALL_BACK_INFO.AltitudeString</code>越大越早被执行的规则,可以通过最早执行的回调钩子记录权限,再配合最晚执行的回调钩子恢复所有权限,以此对抗权限保护.</p>
<blockquote>
<p>前面的<a href="#%E6%B3%A8%E5%86%8C%E7%B3%BB%E7%BB%9F%E5%9B%9E%E8%B0%83%E6%A1%88%E4%BE%8B">注册系统回调</a>做的是让其他进程都没办法以[想要保护的进程]为目标打开进程,而此处做的是:让指定进程打开进程时,不会受到系统回调保护的限制.所以在自定义回调函数中,前者是通过OB_PRE_OPERATION_INFORMATION.Object来判断打开进程的目标进程;后者是通过PsGetCurrentProcessId获取自身pid来判断是不是我们想要绕过保护的进程.</p>
</blockquote>
<p>需要用到互斥提同步相关函数:</p>
<ul>
<li><code>ExInitializeFastMutex</code> 初始化快速互斥体</li>
<li><code>ExAcquireFastMutex</code> 请求使用快速互斥体</li>
<li>要同步的代码在上下之间</li>
<li><code>ExReleaseFastMutex</code> 释放</li>
</ul>
<p>代码如下:</p>
<h4 id="需要用到的结构"><a href="#需要用到的结构" class="headerlink" title="需要用到的结构"></a>需要用到的结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里字节对齐要采用默认，不要按1对齐，这样才符合32位和64位结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LDR_DATA_TABLE_ENTRY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	LIST_ENTRY InLoadOrderLinks;</span><br><span class="line">	LIST_ENTRY InMemoryOrderLinks;</span><br><span class="line">	LIST_ENTRY InInitializationOrderLinks;</span><br><span class="line">	PVOID DllBase;</span><br><span class="line">	PVOID EntryPoint;</span><br><span class="line">	ULONG SizeOfImage;</span><br><span class="line">	UNICODE_STRING FullDllName;</span><br><span class="line">	UNICODE_STRING BaseDllName;</span><br><span class="line">	ULONG Flags;</span><br><span class="line">	USHORT LoadCount;</span><br><span class="line">	USHORT TlsIndex;</span><br><span class="line">	<span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		LIST_ENTRY HashLinks;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">		&#123;</span></span><br><span class="line">			PVOID SectionPointer;</span><br><span class="line">			ULONG CheckSum;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">		&#123;</span></span><br><span class="line">			ULONG TimeDateStamp;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">		&#123;</span></span><br><span class="line">			PVOID LoadedImports;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">ACTIVATION_CONTEXT</span>* <span class="title">EntryPointActivationContext</span>;</span></span><br><span class="line">	PVOID PatchInformation;</span><br><span class="line">&#125; LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义的记录对象信息的链表结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OPERATION_INFO_ENTRY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	LIST_ENTRY    ListEntry;</span><br><span class="line">	OB_OPERATION  Operation;</span><br><span class="line">	ULONG         Flags;</span><br><span class="line">	PVOID         Object;</span><br><span class="line">	POBJECT_TYPE  ObjectType;</span><br><span class="line">	ACCESS_MASK   AccessMask;</span><br><span class="line">	ULONG32 time;</span><br><span class="line">&#125; OPERATION_INFO_ENTRY, * POPERATION_INFO_ENTRY;</span><br></pre></td></tr></table></figure>

<h4 id="需要用到的自定义子函数以及全局变量"><a href="#需要用到的自定义子函数以及全局变量" class="headerlink" title="需要用到的自定义子函数以及全局变量"></a>需要用到的自定义子函数以及全局变量</h4><ul>
<li><code>MyGetTickCount</code>  内核获得系统启动计数</li>
<li><code>IsMyProcess</code>  </li>
<li><code>Last_CallBack</code> 还原原权限自定义回调函数</li>
<li><code>First_CallBack</code>  记录原权限的自定义回调函数</li>
<li>ntoskrnl.exe导出的PsInitialSystemProcess 是一个指向system进程的EPROCESS全局变量</li>
<li>其他在注册系统回调时需要用到的结构体</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//申请空间的标签</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRIVER_TAG <span class="meta-string">&#x27;zk14&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//链表用于记录所有被触发回调的进程或线程信息</span></span><br><span class="line">LIST_ENTRY  g_OperationListHead;</span><br><span class="line">FAST_MUTEX  g_OperationListLock;<span class="comment">//给 g_OperationListHead链表  加的同步手段 互斥体</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内核获取系统启动计数</span></span><br><span class="line"><span class="function">ULONG <span class="title">MyGetTickCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LARGE_INTEGER la;</span><br><span class="line">    ULONG MyInc;</span><br><span class="line">    MyInc = KeQueryTimeIncrement(); <span class="comment">//返回滴答数频率</span></span><br><span class="line">    <span class="comment">//下方 KeQueryTickCount 的宏的原型.</span></span><br><span class="line">    KeQueryTickCount(&amp;la);</span><br><span class="line">    la.QuadPart *= MyInc;</span><br><span class="line">    la.QuadPart /= <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">return</span> la.LowPart;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否自己目标的进程 可以过保护(暂时写死)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TARGETPROCESSNAME <span class="meta-string">&quot;driverTest.exe&quot;</span></span></span><br><span class="line"><span class="function">BOOLEAN <span class="title">IsMyProcess</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PEPROCESS Process = <span class="literal">NULL</span>;</span><br><span class="line">    Process = PsGetCurrentProcess();</span><br><span class="line">    <span class="comment">//KeQuerySystemTime(1);</span></span><br><span class="line">    <span class="keyword">if</span> (_strnicmp(TARGETPROCESSNAME, PsGetProcessImageFileName(Process), <span class="built_in">strlen</span>(TARGETPROCESSNAME)) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> TRUE;<span class="comment">// OB_PREOP_SUCCESS;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后一个自定义回调函数,用于恢复权限  </span></span><br><span class="line"><span class="comment">//APC_LEVEL=1;</span></span><br><span class="line"><span class="function">OB_PREOP_CALLBACK_STATUS <span class="title">Last_CallBack</span><span class="params">(IN PVOID RegistrationContext, IN POB_PRE_OPERATION_INFORMATION OperationInformation)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PLIST_ENTRY ListEntry;</span><br><span class="line">    UNREFERENCED_PARAMETER(RegistrationContext);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IsMyProcess())</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        ExAcquireFastMutex(&amp;g_OperationListLock);<span class="comment">//获取同步所有权</span></span><br><span class="line">        <span class="keyword">for</span> (ListEntry = g_OperationListHead.Flink; ListEntry != &amp;g_OperationListHead; ListEntry = ListEntry-&gt;Flink)</span><br><span class="line">        &#123;</span><br><span class="line">            POPERATION_INFO_ENTRY Entry = (POPERATION_INFO_ENTRY)ListEntry;</span><br><span class="line">            <span class="keyword">if</span> (Entry-&gt;Operation == OperationInformation-&gt;Operation &amp;&amp;</span><br><span class="line">                Entry-&gt;Flags == OperationInformation-&gt;Flags &amp;&amp;</span><br><span class="line">                Entry-&gt;Object == OperationInformation-&gt;Object &amp;&amp;</span><br><span class="line">                Entry-&gt;ObjectType == OperationInformation-&gt;ObjectType)</span><br><span class="line">            &#123;</span><br><span class="line">                ULONG32 newAccess = OperationInformation-&gt;Parameters-&gt;CreateHandleInformation.DesiredAccess;</span><br><span class="line">                ULONG32 oldAccess = Entry-&gt;AccessMask;</span><br><span class="line">                KdPrint((<span class="string">&quot;zeroko:kernel: Last_CallBack  PID=%d &lt;原权限=%llX,新权限=%llX&gt;-----&gt;time=%llX line=%d\n&quot;</span>,</span><br><span class="line">                    (ULONG64)PsGetCurrentProcessId(),</span><br><span class="line">                    (ULONG64)(Entry-&gt;AccessMask),<span class="comment">//原权限</span></span><br><span class="line">                    (ULONG64)newAccess,</span><br><span class="line">                    (ULONG64)Entry-&gt;time, (ULONG64)__LINE__)); <span class="comment">//新权限</span></span><br><span class="line">                <span class="comment">//恢复权限</span></span><br><span class="line">                OperationInformation-&gt;Parameters-&gt;CreateHandleInformation.DesiredAccess = Entry-&gt;AccessMask;    <span class="comment">//恢复权限请求OpenProcess</span></span><br><span class="line">                OperationInformation-&gt;Parameters-&gt;DuplicateHandleInformation.DesiredAccess = Entry-&gt;AccessMask; <span class="comment">//恢复权限请求 DuplicateHandle</span></span><br><span class="line">                <span class="comment">//移出结点</span></span><br><span class="line">                RemoveEntryList(&amp;Entry-&gt;ListEntry);</span><br><span class="line">                <span class="comment">//释放空间</span></span><br><span class="line">                ExFreePoolWithTag(Entry, DRIVER_TAG);</span><br><span class="line">                <span class="keyword">goto</span> Release;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    Release:</span><br><span class="line">        ExReleaseFastMutex(&amp;g_OperationListLock);<span class="comment">//释放同步所有权</span></span><br><span class="line">        <span class="comment">//ok</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OB_PREOP_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一个自定义回调,做记录信息工作,方便最后的回调恢复</span></span><br><span class="line"><span class="function">OB_PREOP_CALLBACK_STATUS <span class="title">First_CallBack</span><span class="params">(IN PVOID RegistrationContext, IN POB_PRE_OPERATION_INFORMATION OperationInformation)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    POPERATION_INFO_ENTRY NewEntry = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ntoskrnl.exe导出的PsInitialSystemProcess 是一个指向system进程的EPROCESS,如果是他则跳过</span></span><br><span class="line">    <span class="keyword">if</span> (PsGetCurrentProcess() == PsInitialSystemProcess)</span><br><span class="line">        <span class="keyword">return</span> OB_PREOP_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果是线程回调的话跳过</span></span><br><span class="line">    <span class="keyword">if</span> (OperationInformation-&gt;ObjectType == PsThreadType)</span><br><span class="line">        <span class="keyword">return</span> OB_PREOP_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断打开进程是否为目标进程</span></span><br><span class="line">    <span class="keyword">if</span> (IsMyProcess())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//申请空间</span></span><br><span class="line">        NewEntry = (POPERATION_INFO_ENTRY)ExAllocatePoolWithTag(NonPagedPool, <span class="keyword">sizeof</span>(OPERATION_INFO_ENTRY), DRIVER_TAG);</span><br><span class="line">        <span class="comment">//记录数据</span></span><br><span class="line">        <span class="keyword">if</span> (NewEntry)</span><br><span class="line">        &#123;</span><br><span class="line">            NewEntry-&gt;Operation = OperationInformation-&gt;Operation;</span><br><span class="line">            NewEntry-&gt;Flags = OperationInformation-&gt;Flags;</span><br><span class="line">            NewEntry-&gt;Object = OperationInformation-&gt;Object;</span><br><span class="line">            NewEntry-&gt;ObjectType = OperationInformation-&gt;ObjectType;</span><br><span class="line">            <span class="comment">//保存请求的权限 防止被保护回调 修改 DuplicateHandle OpenProcess</span></span><br><span class="line">            NewEntry-&gt;AccessMask = <span class="number">0x1fffff</span>;<span class="comment">//OperationInformation-&gt;Parameters-&gt;CreateHandleInformation.DesiredAccess; /// Same for duplicate handle   1fffff表示全部权限,实际上FFFF就已经是全部全新了</span></span><br><span class="line">            NewEntry-&gt;time = MyGetTickCount();<span class="comment">// KeQuerySystemTime(1);</span></span><br><span class="line"></span><br><span class="line">            ExAcquireFastMutex(&amp;g_OperationListLock);<span class="comment">//同步快速互斥体 获取所有权</span></span><br><span class="line">            <span class="comment">//回调的各种数据插入链表</span></span><br><span class="line">            InsertTailList(&amp;g_OperationListHead, &amp;NewEntry-&gt;ListEntry);<span class="comment">//保存节点</span></span><br><span class="line">            KdPrint((<span class="string">&quot;zeroko:kernel:First_CallBack   保存权限=%llX PID=%d time=%llX line=%lld\n&quot;</span>,</span><br><span class="line">                (ULONG64)OperationInformation-&gt;Parameters-&gt;CreateHandleInformation.DesiredAccess,<span class="comment">//原权限 保存</span></span><br><span class="line">                (ULONG64)PsGetCurrentProcessId(),</span><br><span class="line">                (ULONG64)NewEntry-&gt;time,</span><br><span class="line">                (ULONG64)__LINE__));</span><br><span class="line">            ExReleaseFastMutex(&amp;g_OperationListLock);<span class="comment">//同步快速互斥体 释放所有权</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    UNREFERENCED_PARAMETER(RegistrationContext);<span class="comment">//避免未使用参数的警告,可有可无</span></span><br><span class="line">    <span class="keyword">return</span> OB_PREOP_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录系统回调的句柄,用于卸载</span></span><br><span class="line">PVOID       g_UpperHandle = <span class="literal">NULL</span>;</span><br><span class="line">PVOID       g_LowerHandle = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Last_CallBack和First_CallBack是自定义回调函数</span></span><br><span class="line">OB_OPERATION_REGISTRATION ObUpperOperationRegistration[] =</span><br><span class="line">&#123;</span><br><span class="line">    &#123; <span class="literal">NULL</span>, OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE, First_CallBack, <span class="literal">NULL</span> &#125;,<span class="comment">//进程的</span></span><br><span class="line">    &#123; <span class="literal">NULL</span>, OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE, First_CallBack, <span class="literal">NULL</span> &#125;,<span class="comment">//线程的</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">OB_OPERATION_REGISTRATION ObLowerOperationRegistration[] =</span><br><span class="line">&#123;</span><br><span class="line">    &#123; <span class="literal">NULL</span>, OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE, Last_CallBack, <span class="literal">NULL</span> &#125;,<span class="comment">//进程的</span></span><br><span class="line">    &#123; <span class="literal">NULL</span>, OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE, Last_CallBack, <span class="literal">NULL</span> &#125;,<span class="comment">//线程的</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// XignCode3 回调码 380800</span></span><br><span class="line"><span class="comment">// EAC       回调码 327530</span></span><br><span class="line"><span class="comment">// BE        回调码 363220</span></span><br><span class="line">OB_CALLBACK_REGISTRATION UpperCallbackRegistration =</span><br><span class="line">&#123;</span><br><span class="line">    OB_FLT_REGISTRATION_VERSION,</span><br><span class="line">    <span class="number">2</span>,</span><br><span class="line">    RTL_CONSTANT_STRING(<span class="string">L&quot;880000&quot;</span>),<span class="comment">//高的</span></span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    ObUpperOperationRegistration</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">OB_CALLBACK_REGISTRATION LowerCallcackRegistration =</span><br><span class="line">&#123;</span><br><span class="line">    OB_FLT_REGISTRATION_VERSION,</span><br><span class="line">    <span class="number">2</span>,</span><br><span class="line">    RTL_CONSTANT_STRING(<span class="string">L&quot;10000&quot;</span>),<span class="comment">//低的</span></span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    ObLowerOperationRegistration</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="接口函数"><a href="#接口函数" class="headerlink" title="接口函数"></a>接口函数</h4><ul>
<li>安装系统回调的 <code>ObRegisterCallBacksInitBreakProtect</code></li>
<li> 卸载系统回调的 <code>ObRegisterUnload</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ObRegisterUnload</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != g_LowerHandle)</span><br><span class="line">        ObUnRegisterCallbacks(g_LowerHandle);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != g_UpperHandle)</span><br><span class="line">        ObUnRegisterCallbacks(g_UpperHandle);</span><br><span class="line">    <span class="keyword">while</span> (!IsListEmpty(&amp;g_OperationListHead))</span><br><span class="line">        ExFreePoolWithTag(RemoveHeadList(&amp;g_OperationListHead), DRIVER_TAG);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOLEAN <span class="title">ObRegisterCallBacksInitBreakProtect</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">////解锁使用限制  (添加参数PDRIVER_OBJECT pDriverObject)</span></span><br><span class="line">    <span class="comment">// PLDR_DATA ldr;</span></span><br><span class="line">    <span class="comment">//ldr = (PLDR_DATA)pDriverObject-&gt;DriverSection;</span></span><br><span class="line">    <span class="comment">//ldr-&gt;Flags |= 0x20;</span></span><br><span class="line"></span><br><span class="line">    InitializeListHead(&amp;g_OperationListHead);<span class="comment">//初始化链表头</span></span><br><span class="line">    ExInitializeFastMutex(&amp;g_OperationListLock);<span class="comment">//初始化快速互斥体</span></span><br><span class="line"></span><br><span class="line">    ObUpperOperationRegistration[<span class="number">0</span>].ObjectType = PsProcessType;<span class="comment">//针对进程回调</span></span><br><span class="line">    <span class="comment">//新添加的</span></span><br><span class="line">    ObUpperOperationRegistration[<span class="number">0</span>].Operations = OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE;</span><br><span class="line"></span><br><span class="line">    ObUpperOperationRegistration[<span class="number">1</span>].ObjectType = PsThreadType;<span class="comment">//针对线程回调</span></span><br><span class="line">    <span class="comment">//新添加的</span></span><br><span class="line">    ObUpperOperationRegistration[<span class="number">1</span>].Operations = OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE;</span><br><span class="line">    Status = ObRegisterCallbacks(&amp;UpperCallbackRegistration, &amp;g_UpperHandle);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        g_UpperHandle = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">goto</span> Exit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ObLowerOperationRegistration[<span class="number">0</span>].ObjectType = PsProcessType;<span class="comment">//针对进程回调</span></span><br><span class="line">    <span class="comment">//新添加的</span></span><br><span class="line">    ObLowerOperationRegistration[<span class="number">0</span>].Operations = OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE;</span><br><span class="line"></span><br><span class="line">    ObLowerOperationRegistration[<span class="number">1</span>].ObjectType = PsThreadType;<span class="comment">//针对线程回调</span></span><br><span class="line">    <span class="comment">//新添加的</span></span><br><span class="line">    ObLowerOperationRegistration[<span class="number">1</span>].Operations = OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE;</span><br><span class="line">    Status = ObRegisterCallbacks(&amp;LowerCallcackRegistration, &amp;g_LowerHandle);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        g_LowerHandle = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">goto</span> Exit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Exit:</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line">        ObRegisterUnload();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NT_SUCCESS(Status) ? TRUE : FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>安装过保护后,遍历系统回调如下:</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202205292047586.jpeg" alt="foreach"></p>
<p>tp刚开始可以读取,但是过了一会儿又不能访问了,很可能tp有遍历句柄表,找谁打开了自己的句柄,就释放掉.</p>
<h2 id="句柄表遍历相关"><a href="#句柄表遍历相关" class="headerlink" title="句柄表遍历相关"></a>句柄表遍历相关</h2><h3 id="R3句柄遍历"><a href="#R3句柄遍历" class="headerlink" title="R3句柄遍历"></a>R3句柄遍历</h3><ul>
<li><code>NtQuerySystemInformation</code>   遍历句柄</li>
<li><code>NtQueryInformationProcess</code>   句柄转pid</li>
<li><code>NtQueryObject</code>     获取句柄信息   类型   名字</li>
<li><code>DuplicateHandle</code>   把目标进程的句柄复制到当前进程,类似于内存映射</li>
</ul>
<h1 id="完整项目参考"><a href="#完整项目参考" class="headerlink" title="完整项目参考"></a>完整项目参考</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="一些名词理解"><a href="#一些名词理解" class="headerlink" title="一些名词理解"></a>一些名词理解</h1><p><strong>PG/过PG/KPP/DSE/过DSE/内核越狱/免签加载驱动/API(MSG)HOOK名词理解</strong></p>
<ul>
<li>KPP：内核补丁保护，详见<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Kernel_Patch_Protection">http://en.wikipedia.org/wiki/Kernel_Patch_Protection</a></li>
<li>PG：基本可以认为和KPP是一个意思。PatchGuard（正名Kernel Patch Protection）相当于“哨兵”，它的功能是不定时地“巡逻”，检查重要的内核数据结构有没有被篡改，发现篡改就立刻触发蓝屏（也就是Bugcheck 109，CRITICAL_STRUCTURE_CORRUPTION）。</li>
<li>过PG：让PG无法工作，或工作无效。方法基本分为两类，动态（无需重启，重启后失效）和静态（需要重启，重启后一直生效）。</li>
<li>DSE：数字签名强制。全名driver signature enforcement，可以简单理解为“驱动文件必须包含正确的交叉签名”。DSE（Driver Signature Enforcement）相当于“守门员”，在驱动加载前检查数字签名是否有效，无效则拒绝加载进内核；</li>
<li>过DSE：让DSE机制无法工作，或工作无效。方法基本分为两类，动态（无需重启，重启后失效）和静态（需要重启，重启后一直生效）。</li>
<li>免签加载驱动：就是加载一个无签名，或签名无效的驱动。</li>
<li>内核越狱：可以简单理解为｛过PG+过DSE｝。</li>
<li>关于HOOK：MESSAGE HOOK是RING3的HOOK，所有RING3的HOOK（包括RING3 IAT/EAT/INLINE HOOK）都不被PG限制。RING0里对关键模块（包括但不限于NTOSKRNL.EXE、HAL.DLL、NDIS.SYS等）以及一些关键的表（包括但不限于SSDT、IDT、PsActiveProcessLinks等）的任何修改，都不被PG所允许。</li>
</ul>
<p>要加载驱动，需要先pass掉DSE，进了内核以后，再看情况考虑要不要干掉PG……</p>
<p><strong>不重启禁用/绕过DSE的方法：</strong></p>
<p>不支持重启的方法:</p>
<p>1.在内存中修改全局变量g_CiEnabled（也就是所谓的flag？）</p>
<p><a href="https://link.zhihu.com/?target=http://www.kernelmode.info/forum/viewtopic.php?f=11&t=3322">DSEFix - Defeating x64 Driver Signature Enforcement</a></p>
<p>需要一个有<strong>任意内存读写/执行漏洞</strong>的<strong>有合法签名的驱动</strong>先被加载进内核，然后可以利用漏洞完成修改。<strong>修改完DSE就被关闭了。</strong></p>
<p>也有带合法签名的驱动直接实现了这个功能，比如WIN64AST这个小工具就有关闭DSE的功能。</p>
<p>缺点：修改会被不定时运行的<strong>PatchGuard</strong>检测到，<strong>一旦被检测到就会立刻蓝屏</strong>。</p>
<p>可以在要加载驱动时先修改flag来禁用DSE，然后抓紧时间加载驱动，加载完成后再立刻把flag改回去，这样可以大大降低蓝屏的概率。</p>
<p>2.不使用正常的驱动加载途径，使用自己编写的shellcode加载</p>
<p><a href="https://link.zhihu.com/?target=https://github.com/hfiref0x/TDL">hfiref0x/TDL</a></p>
<p><strong>同样需要一个有合法签名的驱动先被加载</strong>，然后利用这个驱动（<strong>可能是利用bug，也可能是驱动自己实现的功能</strong>）来完成无签名驱动的加载。</p>
<p>这个方法的优点是<strong>不会触发PatchGuard</strong>，但缺点也很明显：被加载的驱动需要被特殊设计，加载后不支持卸载，不支持SEH，函数导入不正常……<strong>限制很多</strong></p>
<p><strong>VT技术过PG</strong></p>
<p>驱动开发小技巧:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NT_SUCCESS(Status) (((NTSTATUS)(Status)) &gt;= 0)</span></span><br><span class="line"><span class="comment">//用于判断返回值</span></span><br></pre></td></tr></table></figure>

<h3 id="签名相关"><a href="#签名相关" class="headerlink" title="签名相关"></a>签名相关</h3><p>目前默认的证书签名算法都是sha-256，通过申请的证书可以使用工具进行双签名，给应用程序或驱动签名的摘要算法就是sha1和sha256，但签发的证书本身签名算法是sha-256，可以通过所以在旧版的操作系统中会出现驱动类文件不兼容。目前在旧版操作系统的内核驱动签名不支持单证书双签名，普通应用程序则支持单证书双签名。</p>
<p>对于内核驱动签名，如果要实现双签名，例如同时在Windows 7 和 Windows 10 上运行，Windows 10则要求使用sha-256的签名算法创建签名，但是Windows 7的内核驱动签名则需要使用sha-1来实现。也就是说<strong>对于内核驱动的签名，需要同时购买EV代码签名证书和标准签名证书来实现内核驱动的双签名</strong>。对于普通的应用程序可以使用一张证书来双签名实现兼容性。</p>
<h4 id="签名工具使用"><a href="#签名工具使用" class="headerlink" title="签名工具使用"></a>签名工具使用</h4><p>先添加签名规则,再给文件签名.</p>
<h1 id="64位16进制字符串操作"><a href="#64位16进制字符串操作" class="headerlink" title="64位16进制字符串操作"></a>64位16进制字符串操作</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//十六进制字符串转十六进制数字</span></span><br><span class="line">ULONG_PTR ulModBase  = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(_WIN64)</span></span><br><span class="line">    ulModBase            = _tcstoui64(strParam,<span class="literal">NULL</span>,<span class="number">16</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    ulModBase            = _tcstoul(strParam,<span class="literal">NULL</span>,<span class="number">16</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">//上面的strParam是wchar*类型的</span></span><br></pre></td></tr></table></figure>

<p>**[printf的64位16进制输出格式]**为 <code>%016I64x</code>  0表示用0填充空白位置,16表示16个字符,I64表示64位,%x表示输出16进制数</p>
<h1 id="设定驱动和用户层相接数据结构"><a href="#设定驱动和用户层相接数据结构" class="headerlink" title="设定驱动和用户层相接数据结构"></a>设定驱动和用户层相接数据结构</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类似如下方式,统一内存对齐最稳妥</span></span><br><span class="line"><span class="comment">//当然也可以按照64位默认的8字节对齐,但用户层和内存层都必须是64位</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(push)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(8)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TINPUT_BUF</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	UINT64 dwPid;</span><br><span class="line">  PVOID PBase;</span><br><span class="line">  UINT64 nSize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(pop)</span></span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/blog/tags/%E5%86%85%E6%A0%B8%E7%9B%B8%E5%85%B3/" rel="tag"># 内核相关</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/blog/2021/12/05/32%E4%BD%8D%E9%80%86%E5%90%91/" rel="prev" title="32位逆向">
      <i class="fa fa-chevron-left"></i> 32位逆向
    </a></div>
      <div class="post-nav-item">
    <a href="/blog/2022/05/05/windows%E5%BC%80%E5%8F%91/" rel="next" title="windows开发">
      windows开发 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91"><span class="nav-number">1.</span> <span class="nav-text">驱动开发</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="nav-number">1.1.</span> <span class="nav-text">准备工作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E5%8F%8C%E6%9C%BA%E8%B0%83%E8%AF%95%E6%AD%A5%E9%AA%A4"><span class="nav-number">1.1.1.</span> <span class="nav-text">设置双机调试步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AEwindbg%E8%BF%9E%E6%8E%A5%E5%93%AA%E4%B8%AA%E4%B8%B2%E5%8F%A3"><span class="nav-number">1.1.2.</span> <span class="nav-text">设置windbg连接哪个串口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E7%AC%A6%E5%8F%B7"><span class="nav-number">1.1.3.</span> <span class="nav-text">设置符号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#windbg%E8%B0%83%E8%AF%95%E8%93%9D%E5%B1%8Fdump%E6%96%87%E4%BB%B6"><span class="nav-number">1.1.4.</span> <span class="nav-text">windbg调试蓝屏dump文件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AEdump%E6%96%87%E4%BB%B6%E7%94%9F%E6%88%90%E6%AD%A5%E9%AA%A4"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">操作系统设置dump文件生成步骤</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PDB%EF%BC%88Program-Debug-Database%EF%BC%89"><span class="nav-number">1.2.</span> <span class="nav-text">PDB（Program Debug Database）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.3.</span> <span class="nav-text">第一个驱动程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6Wdm-h%E3%80%81Ntddk-h-%E5%92%8C-Ntifs-h-%E7%9A%84%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84"><span class="nav-number">1.3.1.</span> <span class="nav-text">头文件Wdm.h、Ntddk.h 和 Ntifs.h 的组织结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="nav-number">1.4.</span> <span class="nav-text">内核编程基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8API%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.4.1.</span> <span class="nav-text">内核API的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AA%E5%AF%BC%E5%87%BA%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.4.2.</span> <span class="nav-text">未导出函数的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.4.3.</span> <span class="nav-text">基本数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">1.4.4.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">1.4.5.</span> <span class="nav-text">内核函数中的异常处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E5%86%85%E6%A0%B8%E5%86%85%E5%AD%98%E5%87%BD%E6%95%B0"><span class="nav-number">1.4.6.</span> <span class="nav-text">常用的内核内存函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%A7%8D%E7%B1%BB"><span class="nav-number">1.4.7.</span> <span class="nav-text">内核字符串种类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E5%85%B6%E4%BB%96%E5%86%85%E6%A0%B8API%E5%87%BD%E6%95%B0"><span class="nav-number">1.4.8.</span> <span class="nav-text">常用的其他内核API函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IRQL%E4%B8%AD%E6%96%AD%E8%AF%B7%E6%B1%82%E7%BA%A7%E5%88%AB"><span class="nav-number">1.4.9.</span> <span class="nav-text">IRQL中断请求级别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A9%B1%E5%8A%A8%E5%86%85%E6%A0%B8%E6%A1%86%E6%9E%B6"><span class="nav-number">1.4.10.</span> <span class="nav-text">驱动内核框架</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Windows%E7%9A%84%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B%E5%8F%98%E8%BF%81"><span class="nav-number">1.4.10.1.</span> <span class="nav-text">Windows的驱动开发模型变迁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%BB%E8%A6%81%E8%B0%83%E7%94%A8%E6%BA%90%EF%BC%9A"><span class="nav-number">1.4.10.2.</span> <span class="nav-text">内核编程的主要调用源：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7"><span class="nav-number">1.4.10.3.</span> <span class="nav-text">函数的多线程安全性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B8%AD%E6%96%AD%E7%BA%A7"><span class="nav-number">1.4.10.4.</span> <span class="nav-text">代码的中断级</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WDK%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E7%89%B9%E6%AE%8A%E4%BB%A3%E7%A0%81"><span class="nav-number">1.4.10.5.</span> <span class="nav-text">WDK中出现的特殊代码</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#IN%E5%92%8COUT"><span class="nav-number">1.4.10.5.1.</span> <span class="nav-text">IN和OUT</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#pragma-alloc-text"><span class="nav-number">1.4.10.5.2.</span> <span class="nav-text">#pragma alloc_text</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97"><span class="nav-number">1.5.</span> <span class="nav-text">内核空间与内核模块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4"><span class="nav-number">1.5.1.</span> <span class="nav-text">内核空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97"><span class="nav-number">1.5.2.</span> <span class="nav-text">内核模块</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#DRIVER-OBJECT%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">DRIVER_OBJECT结构体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LDR-DATA-TABLE-ENTRY%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">_LDR_DATA_TABLE_ENTRY结构体</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E4%BD%9C%E4%B8%9A"><span class="nav-number">1.5.3.</span> <span class="nav-text">遍历内核模块作业</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A9%B1%E5%8A%A8%E9%94%AE%E9%BC%A0%E8%BF%87%E6%BB%A4"><span class="nav-number">1.5.4.</span> <span class="nav-text">驱动键鼠过滤</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E9%93%BE%E8%A1%A8"><span class="nav-number">1.6.</span> <span class="nav-text">驱动开发中的链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%B6%E7%8E%AF%E4%B8%8E%E4%B8%89%E7%8E%AF%E9%80%9A%E4%BF%A1-%E5%B8%B8%E8%A7%84%E6%96%B9%E5%BC%8F"><span class="nav-number">1.7.</span> <span class="nav-text">零环与三环通信(常规方式)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%AE%BE%E5%A4%87%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.7.1.</span> <span class="nav-text">创建设备对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84"><span class="nav-number">1.7.1.1.</span> <span class="nav-text">设备对象结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IoCreateDevice"><span class="nav-number">1.7.1.2.</span> <span class="nav-text">IoCreateDevice</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E8%AE%BE%E5%A4%87%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.7.2.</span> <span class="nav-text">删除设备对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E4%BA%A4%E4%BA%92%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">1.7.3.</span> <span class="nav-text">设置交互数据的方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%8D%B8%E8%BD%BD%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5"><span class="nav-number">1.7.4.</span> <span class="nav-text">创建与卸载符号链接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IRP%E4%B8%8E%E6%B4%BE%E9%81%A3%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.5.</span> <span class="nav-text">IRP与派遣函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#IRP%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.7.5.1.</span> <span class="nav-text">IRP类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#IRP%E7%BB%93%E6%9E%84"><span class="nav-number">1.7.5.1.1.</span> <span class="nav-text">IRP结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#IO-STACK-LOCATION%E7%BB%93%E6%9E%84"><span class="nav-number">1.7.5.1.2.</span> <span class="nav-text">IO_STACK_LOCATION结构</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B4%BE%E9%81%A3%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.5.2.</span> <span class="nav-text">派遣函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B4%BE%E9%81%A3%E5%87%BD%E6%95%B0%E5%9C%A8%E5%93%AA%E9%87%8C%E6%B3%A8%E5%86%8C%E5%91%A2%EF%BC%9F"><span class="nav-number">1.7.5.2.1.</span> <span class="nav-text">派遣函数在哪里注册呢？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C%E6%B4%BE%E9%81%A3%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.5.2.2.</span> <span class="nav-text">注册派遣函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B4%BE%E9%81%A3%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="nav-number">1.7.5.3.</span> <span class="nav-text">派遣函数的格式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#IRP-MJ-DEVICE-CONTROL%E7%9A%84%E6%B4%BE%E9%81%A3%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.5.3.1.</span> <span class="nav-text">IRP_MJ_DEVICE_CONTROL的派遣函数</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#CTL%E6%93%8D%E4%BD%9C%E7%A0%81"><span class="nav-number">1.7.5.3.1.1.</span> <span class="nav-text">CTL操作码</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#IRP-MJ-DEVICE-CONTROL%E7%9A%84%E6%B4%BE%E9%81%A3%E5%87%BD%E6%95%B0%E7%BC%96%E5%86%99"><span class="nav-number">1.7.5.3.1.2.</span> <span class="nav-text">IRP_MJ_DEVICE_CONTROL的派遣函数编写</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%89%E7%8E%AF%E5%86%99%E6%B3%95"><span class="nav-number">1.7.5.3.1.3.</span> <span class="nav-text">三环写法</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IRP-MJ-DEVICE-CONTROL%E4%BA%A4%E4%BA%92%E6%95%B0%E6%8D%AE%E5%AE%9E%E9%AA%8C"><span class="nav-number">1.7.6.</span> <span class="nav-text">IRP_MJ_DEVICE_CONTROL交互数据实验</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#R0%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="nav-number">1.7.6.1.</span> <span class="nav-text">R0代码：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#R3%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="nav-number">1.7.6.2.</span> <span class="nav-text">R3代码：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A9%B1%E5%8A%A8%E5%8A%A0%E8%BD%BD"><span class="nav-number">1.8.</span> <span class="nav-text">驱动加载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A9%B1%E5%8A%A8%E6%B3%A8%E5%86%8C-%E5%AE%89%E8%A3%85"><span class="nav-number">1.8.1.</span> <span class="nav-text">驱动注册&#x2F;安装</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#OpenSCManagerA%E5%87%BD%E6%95%B0"><span class="nav-number">1.8.1.1.</span> <span class="nav-text">OpenSCManagerA函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%9C%8D%E5%8A%A1CreateServiceA%E5%87%BD%E6%95%B0"><span class="nav-number">1.8.1.2.</span> <span class="nav-text">创建服务CreateServiceA函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A9%B1%E5%8A%A8%E5%90%AF%E5%8A%A8"><span class="nav-number">1.8.2.</span> <span class="nav-text">驱动启动</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%93%E5%BC%80%E6%9C%8D%E5%8A%A1OpenServiceA%E5%87%BD%E6%95%B0"><span class="nav-number">1.8.2.1.</span> <span class="nav-text">打开服务OpenServiceA函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%80%E5%A7%8B%E6%9C%8D%E5%8A%A1StartServiceA%E5%87%BD%E6%95%B0"><span class="nav-number">1.8.2.2.</span> <span class="nav-text">开始服务StartServiceA函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%81%9C%E6%AD%A2%E9%A9%B1%E5%8A%A8"><span class="nav-number">1.8.3.</span> <span class="nav-text">停止驱动</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E6%9C%8D%E5%8A%A1ControlService%E5%87%BD%E6%95%B0"><span class="nav-number">1.8.3.1.</span> <span class="nav-text">控制服务ControlService函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%B8%E8%BD%BD%E9%A9%B1%E5%8A%A8"><span class="nav-number">1.8.4.</span> <span class="nav-text">卸载驱动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A9%B1%E5%8A%A8%E5%8A%A0%E8%BD%BD-%E5%90%AF%E5%8A%A8-%E5%81%9C%E6%AD%A2-%E5%8D%B8%E8%BD%BD%E6%A1%88%E4%BE%8B"><span class="nav-number">1.8.5.</span> <span class="nav-text">驱动加载&#x2F;启动&#x2F;停止&#x2F;卸载案例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E7%9B%91%E5%90%ACAPI%E5%AE%9E%E9%AA%8C"><span class="nav-number">1.9.</span> <span class="nav-text">全局监听API实验</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#R0%E4%BB%A3%E7%A0%81"><span class="nav-number">1.9.1.</span> <span class="nav-text">R0代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#R3%E4%BB%A3%E7%A0%81"><span class="nav-number">1.9.2.</span> <span class="nav-text">R3代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E9%9A%BE%E7%82%B9"><span class="nav-number">1.9.3.</span> <span class="nav-text">重难点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Inline-Hook"><span class="nav-number">1.10.</span> <span class="nav-text">Inline Hook</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C%E7%B3%BB%E7%BB%9F%E5%9B%9E%E8%B0%83%E4%BF%9D%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.11.</span> <span class="nav-text">注册系统回调保护进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0ObRegisterCallbacks"><span class="nav-number">1.11.1.</span> <span class="nav-text">核心函数ObRegisterCallbacks</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#OB-CALLBACK-REGISTRATION%E7%BB%93%E6%9E%84"><span class="nav-number">1.11.1.1.</span> <span class="nav-text">OB_CALLBACK_REGISTRATION结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#OB-OPERATION-REGISTRATION%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">1.11.1.2.</span> <span class="nav-text">_OB_OPERATION_REGISTRATION结构体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="nav-number">1.11.1.3.</span> <span class="nav-text">自定义回调函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C%E7%B3%BB%E7%BB%9F%E5%9B%9E%E8%B0%83%E6%A1%88%E4%BE%8B"><span class="nav-number">1.11.1.4.</span> <span class="nav-text">注册系统回调案例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A5%E5%85%85"><span class="nav-number">1.11.2.</span> <span class="nav-text">补充</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E6%9D%83%E9%99%90"><span class="nav-number">1.11.2.1.</span> <span class="nav-text">进程有哪些权限</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A9%B1%E5%8A%A8%E4%B8%AD%E9%80%9A%E8%BF%87%E8%BF%9B%E7%A8%8B%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84%E4%BD%93%E9%A6%96%E5%9C%B0%E5%9D%80%E8%8E%B7%E5%8F%96%E8%BF%9B%E7%A8%8B%E5%90%8D"><span class="nav-number">1.11.2.2.</span> <span class="nav-text">驱动中通过进程对象结构体首地址获取进程名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8Bid%E8%8E%B7%E5%8F%96%E8%BF%9B%E7%A8%8B%E5%90%8D"><span class="nav-number">1.11.2.3.</span> <span class="nav-text">进程id获取进程名</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">1.11.2.3.1.</span> <span class="nav-text">另一种实现方式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A9%B1%E5%8A%A8%E4%B8%AD%E8%AE%BE%E7%BD%AE%E6%96%AD%E7%82%B9"><span class="nav-number">1.11.2.4.</span> <span class="nav-text">驱动中设置断点:</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%9A%84%E6%96%B9%E5%BC%8F%E4%B8%8B%E6%96%AD%E7%82%B9"><span class="nav-number">1.11.2.4.1.</span> <span class="nav-text">代码的方式下断点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#windbg%E7%9B%B4%E6%8E%A5%E4%B8%8B%E6%96%AD%E7%82%B9"><span class="nav-number">1.11.2.4.2.</span> <span class="nav-text">windbg直接下断点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8B%E8%AF%BB%E5%86%99%E7%BB%95%E8%BF%87%E7%B3%BB%E7%BB%9F%E5%9B%9E%E8%B0%83%E4%BF%9D%E6%8A%A4"><span class="nav-number">1.11.3.</span> <span class="nav-text">远程读写绕过系统回调保护</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%8C%82%E9%9D%A0%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.11.3.1.</span> <span class="nav-text">进程挂靠的方式实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%BB%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.11.3.1.1.</span> <span class="nav-text">读进程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%99%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.11.3.1.2.</span> <span class="nav-text">写进程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MDL%E6%96%B9%E5%BC%8F"><span class="nav-number">1.11.3.2.</span> <span class="nav-text">MDL方式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%BB%E5%86%85%E5%AD%98"><span class="nav-number">1.11.3.2.1.</span> <span class="nav-text">读内存</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%99%E5%86%85%E5%AD%98"><span class="nav-number">1.11.3.2.2.</span> <span class="nav-text">写内存</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CR0%E6%96%B9%E5%BC%8F%E5%86%99%E5%8F%AA%E8%AF%BB%E5%86%85%E5%AD%98"><span class="nav-number">1.11.3.3.</span> <span class="nav-text">CR0方式写只读内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E8%AF%BB%E5%86%99%E5%86%85%E5%AD%98%E6%96%B9%E6%B3%95"><span class="nav-number">1.11.3.4.</span> <span class="nav-text">物理内存读写内存方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0"><span class="nav-number">1.11.3.4.1.</span> <span class="nav-text">核心函数</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#ZwMapViewOfSection"><span class="nav-number">1.11.3.4.1.1.</span> <span class="nav-text">ZwMapViewOfSection</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="nav-number">1.11.3.4.2.</span> <span class="nav-text">完整代码</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9C%80%E5%A4%96%E5%B1%82%E7%9A%84%E8%AF%BB%E5%86%99%E5%86%85%E5%AD%98%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.11.3.4.2.1.</span> <span class="nav-text">最外层的读写内存接口</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E6%9C%80%E5%A4%A7%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E5%87%BD%E6%95%B0"><span class="nav-number">1.11.3.4.2.2.</span> <span class="nav-text">获取最大物理地址函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E5%80%BC%E5%87%BD%E6%95%B0"><span class="nav-number">1.11.3.4.2.3.</span> <span class="nav-text">获取物理地址的值函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E8%AF%BB%E5%86%99%E5%87%BD%E6%95%B0"><span class="nav-number">1.11.3.4.2.4.</span> <span class="nav-text">物理内存读写函数</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%92%88%E5%AF%B9%E5%AF%B9%E8%B1%A1%E5%9B%9E%E8%B0%83%E9%92%A9%E5%AD%90%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">1.12.</span> <span class="nav-text">针对对象回调钩子的操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E5%AF%B9%E8%B1%A1%E9%92%A9%E5%AD%90"><span class="nav-number">1.12.1.</span> <span class="nav-text">遍历进程&#x2F;线程对象钩子</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9C%80%E8%A6%81%E7%94%A8%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%93%E6%9E%84%E5%92%8C%E5%8F%98%E9%87%8F"><span class="nav-number">1.12.1.1.</span> <span class="nav-text">需要用的自定义结构和变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E5%9B%9E%E8%B0%83%E9%9C%80%E8%A6%81%E7%94%A8%E5%88%B0%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%90%E5%87%BD%E6%95%B0-%E5%8C%85%E5%90%AB%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"><span class="nav-number">1.12.1.2.</span> <span class="nav-text">遍历回调需要用到的自定义子函数(包含依赖关系)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="nav-number">1.12.1.3.</span> <span class="nav-text">遍历回调函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8C%E7%BE%8E%E8%BF%87%E6%8E%89%E5%AF%B9%E8%B1%A1%E4%BF%9D%E6%8A%A4%E9%92%A9%E5%AD%90"><span class="nav-number">1.12.2.</span> <span class="nav-text">完美过掉对象保护钩子</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9C%80%E8%A6%81%E7%94%A8%E5%88%B0%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">1.12.2.1.</span> <span class="nav-text">需要用到的结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9C%80%E8%A6%81%E7%94%A8%E5%88%B0%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%90%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8A%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="nav-number">1.12.2.2.</span> <span class="nav-text">需要用到的自定义子函数以及全局变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="nav-number">1.12.2.3.</span> <span class="nav-text">接口函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%A5%E6%9F%84%E8%A1%A8%E9%81%8D%E5%8E%86%E7%9B%B8%E5%85%B3"><span class="nav-number">1.13.</span> <span class="nav-text">句柄表遍历相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#R3%E5%8F%A5%E6%9F%84%E9%81%8D%E5%8E%86"><span class="nav-number">1.13.1.</span> <span class="nav-text">R3句柄遍历</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4%E9%A1%B9%E7%9B%AE%E5%8F%82%E8%80%83"><span class="nav-number">2.</span> <span class="nav-text">完整项目参考</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E5%90%8D%E8%AF%8D%E7%90%86%E8%A7%A3"><span class="nav-number">3.</span> <span class="nav-text">一些名词理解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%BE%E5%90%8D%E7%9B%B8%E5%85%B3"><span class="nav-number">3.0.1.</span> <span class="nav-text">签名相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AD%BE%E5%90%8D%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8"><span class="nav-number">3.0.1.1.</span> <span class="nav-text">签名工具使用</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#64%E4%BD%8D16%E8%BF%9B%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C"><span class="nav-number">4.</span> <span class="nav-text">64位16进制字符串操作</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%BE%E5%AE%9A%E9%A9%B1%E5%8A%A8%E5%92%8C%E7%94%A8%E6%88%B7%E5%B1%82%E7%9B%B8%E6%8E%A5%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">5.</span> <span class="nav-text">设定驱动和用户层相接数据结构</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ZEROKO14</p>
  <div class="site-description" itemprop="description">你好，欢迎来到ZEROKO14的个人博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZEROKO14</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>-->

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/muse.js"></script>


<script src="/blog/js/next-boot.js"></script>


  <script defer src="/blog/lib/three/three.min.js"></script>
    <script defer src="/blog/lib/three/three-waves.min.js"></script>


  















  

  

</body>
</html>
