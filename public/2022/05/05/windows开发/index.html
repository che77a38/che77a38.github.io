<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zeroko14.gitee.io","root":"/blog/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="暂未完成">
<meta property="og:type" content="article">
<meta property="og:title" content="windows开发">
<meta property="og:url" content="http://zeroko14.gitee.io/blog/2022/05/05/windows%E5%BC%80%E5%8F%91/index.html">
<meta property="og:site_name" content="ZEROKO14的个人博客">
<meta property="og:description" content="暂未完成">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/4f06232eed4f93be762cd15d664b407c.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/05d27497327d7264b74d178aaf312830.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210613135932861.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210615121702693.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210615134439052.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210615144439614.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210615144902520.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210615145614061.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210615150920853.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210615155616437.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210615162232666.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210615163527181.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210619181855365.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210619182205646.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210619190656121.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210619190048156.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210619190359223.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210623173443224.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210623175414083.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210623183240740.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210623183337829.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210627131449985.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210627132533158.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210627133328265.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210627141039758.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210627151302111.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210627151210561.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210627144328602.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210627171511300.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/5396392-230b8f4ea39a4f00.webp">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210627184154084.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210627184851391.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210627185746450.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210628152849905.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210628153031108.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210630122311355.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210630122444855.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210628154143292.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210703130407329.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210703132545845.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210703161630006.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210703161739985.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210703163120600.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210703170047278.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210703170103293.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210703185707851.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210703222153407.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210703221045789.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210703193415048.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210703220919906.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210703222600004.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210703223924648.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210703224651453.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210706131700275.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210707145837215.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210707150201266.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210707150256851.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210707153018376.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210707153029369.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210707155954691.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210706162954067.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210607170623362.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210607172332382.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210607170623362.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210607172332382.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210707174332826.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210707174410932.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210707184145923.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210708190212173.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210708190233787.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210708190305081.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210709000121629.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210709002047122.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210710150602775.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210710150629920.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210709163413382.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210709162621067.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210714143816162.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/WonderFox_Video_Recording_001_001.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210710163925510.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210715194421171.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20211124154438711.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20211124154455104.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210608224348679.png">
<meta property="article:published_time" content="2022-05-05T07:27:30.326Z">
<meta property="article:modified_time" content="2022-12-23T09:51:58.932Z">
<meta property="article:author" content="ZEROKO14">
<meta property="article:tag" content="开发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/4f06232eed4f93be762cd15d664b407c.jpeg">

<link rel="canonical" href="http://zeroko14.gitee.io/blog/2022/05/05/windows%E5%BC%80%E5%8F%91/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>windows开发 | ZEROKO14的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ZEROKO14的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">zeroko14's blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zeroko14.gitee.io/blog/2022/05/05/windows%E5%BC%80%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="ZEROKO14">
      <meta itemprop="description" content="你好，欢迎来到ZEROKO14的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZEROKO14的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          windows开发
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-05 15:27:30" itemprop="dateCreated datePublished" datetime="2022-05-05T15:27:30+08:00">2022-05-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-23 17:51:58" itemprop="dateModified" datetime="2022-12-23T17:51:58+08:00">2022-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>暂未完成</p>
<span id="more"></span>

<h1 id="Win32课程有哪些内容"><a href="#Win32课程有哪些内容" class="headerlink" title="Win32课程有哪些内容"></a>Win32课程有哪些内容</h1><ol>
<li>字符</li>
<li>多线程</li>
<li>线程同步</li>
<li>窗口的本质</li>
<li>windows消息机制</li>
<li>子窗口的使用</li>
<li>进程</li>
<li>内存管理</li>
<li>文件系统</li>
<li>内存映射</li>
<li>DLL</li>
<li>远程注入</li>
<li>模块隐藏</li>
<li>进程通信</li>
<li>HOOK专题（各种类型HOOK&#x2F;绕过全代码校验）</li>
</ol>
<p>malloc在windows上的底层也是win32实现的</p>
<h1 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h1><h2 id="ANSI编码"><a href="#ANSI编码" class="headerlink" title="ANSI编码"></a>ANSI编码</h2><h3 id="原始的ASCII编码"><a href="#原始的ASCII编码" class="headerlink" title="原始的ASCII编码"></a><strong>原始</strong>的ASCII编码</h3><p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/4f06232eed4f93be762cd15d664b407c.jpeg" alt="4f06232eed4f93be762cd15d664b407c"></p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/05d27497327d7264b74d178aaf312830.jpeg" alt="05d27497327d7264b74d178aaf312830"></p>
<p>原始的ASCII码只占一个字节</p>
<h3 id="ASCII编码的拓展：GB2312（GBK）或GB2312-80"><a href="#ASCII编码的拓展：GB2312（GBK）或GB2312-80" class="headerlink" title="ASCII编码的拓展：GB2312（GBK）或GB2312-80"></a>ASCII编码的拓展：GB2312（GBK）或GB2312-80</h3><p>GB2312或GB2312-80：专门用来表示中文的编码</p>
<h4 id="实现原理："><a href="#实现原理：" class="headerlink" title="实现原理："></a>实现原理：</h4><p>把80<del>FF的表给占用了，由80</del>FF开头的两个字节拼在一起表示一个字符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">中国</span><br><span class="line">D6 D0 B9 FA</span><br></pre></td></tr></table></figure>

<p>GB2312（GBK）或GB2312-80也就是ANSI编码（各国各自的编码格式统称ANSI）</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>其他象形文字国家也是采取和我国一样的策略，所以各个国家看到的同一个编码意思不一致。</p>
<p>ANSI编码也就是GB2312（GBK）或GB2312-80，表示英文字符时用一个字节，表示中文字符时用两个或4个字节</p>
<h2 id="UNICODE编码"><a href="#UNICODE编码" class="headerlink" title="UNICODE编码"></a>UNICODE编码</h2><p>一张包含全世界所有文字的一个编码表，Unicode的编码范围是：0~0x10FFFF，可以容纳100多万个符号！</p>
<p>但他只是一个符号集，只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。</p>
<h3 id="UNICODE编码的存储方式"><a href="#UNICODE编码的存储方式" class="headerlink" title="UNICODE编码的存储方式"></a><strong>UNICODE编码的存储方式</strong></h3><h4 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h4><p>UTF-16编码以16位无符号整数为单位，注意是16位为一个单位，不表示一个字符就只有16位。这个要看字符的unicode编码处于什么范围而定的，有<strong>可能是2个字节，也可能是4个字节</strong>。<strong>现在机器上的unicode编码一般指的就是UTF-16。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">UTF-16小端存储</span><br><span class="line">中国A</span><br><span class="line">2D 4E FD 56 41 00</span><br><span class="line"></span><br><span class="line">UTF-16大端存储</span><br><span class="line">中国A</span><br><span class="line">4E 2D 56 FD 00 41</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210613135932861.png" alt="image-20210613135932861"></p>
<p>上图箭头所指的没有明确说明是哪种存储方式的Unicode<strong>实际上就是UTF-16</strong></p>
<p>优缺点：拆分解析快，浪费空间多（尤其是网络传输）</p>
<h4 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h4><p>一种变长的存储方案</p>
<p>网络传输火起来的编码格式     </p>
<table>
<thead>
<tr>
<th>Unicode符号集</th>
<th>UTF-8(x表示Unicode符号集)</th>
</tr>
</thead>
<tbody><tr>
<td>0~7F</td>
<td>0xxxxxxx</td>
</tr>
<tr>
<td>80~7FF</td>
<td>110xxxxx 10xxxxxx</td>
</tr>
<tr>
<td>800~FFFF</td>
<td>1110xxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr>
<td>10000~10FFFF</td>
<td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>
</tr>
</tbody></table>
<p>因此占用1~4个字节都有可能</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A中</span><br><span class="line">41             	E4           	B8           	AD</span><br><span class="line">0(100 0001)    	1110 (0100)		10(11 1000)		10(10 1101)</span><br><span class="line">100 0001		0100			1110    0010	1101</span><br><span class="line">4	1			4				E		2		D</span><br><span class="line">A				中</span><br></pre></td></tr></table></figure>

<p>数据大部分是英文字符的话采用UTF-8比较好，中文多的话采用UTF-16比较好</p>
<p>优缺点：拆分解析慢，但节省空间（尤其是网络传输）</p>
<h4 id="UTF-32"><a href="#UTF-32" class="headerlink" title="UTF-32"></a>UTF-32</h4><p>任何元素都是4个字节为单位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A					中</span><br><span class="line">41 00 00 00			 2D 4E 00 00 </span><br></pre></td></tr></table></figure>

<h3 id="BOM字节顺序标识"><a href="#BOM字节顺序标识" class="headerlink" title="BOM字节顺序标识"></a>BOM字节顺序标识</h3><p>Byte Order Mark</p>
<p>文本文件的起始位置存这几个字节来表示当前文件采用什么格式存储</p>
<table>
<thead>
<tr>
<th>存储格式</th>
<th>BOM</th>
</tr>
</thead>
<tbody><tr>
<td>UTF-8</td>
<td>EF BB BF</td>
</tr>
<tr>
<td>UTF-16LE（小端存储）</td>
<td>FF FE</td>
</tr>
<tr>
<td>UTF-16BE（大端存储）</td>
<td>FE FF</td>
</tr>
<tr>
<td>UTF-32LE</td>
<td>FF FE 00 00</td>
</tr>
<tr>
<td>UTF-32BE</td>
<td>00 00 FE FF</td>
</tr>
</tbody></table>
<p>添加BOM头</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;d:\\Temp\\test.txt&quot;</span>)</span></span>; <span class="comment">//文件是utf8编码</span></span><br><span class="line"><span class="type">char</span> c1 = <span class="number">0xEF</span>;<span class="comment">// 仿utf-8 BOM头  三字节</span></span><br><span class="line"><span class="type">char</span> c2 = <span class="number">0xBB</span>;</span><br><span class="line"><span class="type">char</span> c3 = <span class="number">0xBF</span>;</span><br><span class="line">ofs &lt;&lt; c1 &lt;&lt; c2 &lt;&lt; c3;</span><br></pre></td></tr></table></figure>

<p>QT中添加BOM头提供了封装好的函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QTextStream <span class="title">out</span><span class="params">(&amp;data)</span></span>;</span><br><span class="line">out.<span class="built_in">setCodec</span>(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">out.<span class="built_in">setGenerateByteOrderMark</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<h2 id="C语言中的宽字符"><a href="#C语言中的宽字符" class="headerlink" title="C语言中的宽字符"></a>C语言中的宽字符</h2><h3 id="宽字符类型"><a href="#宽字符类型" class="headerlink" title="宽字符类型"></a>宽字符类型</h3><ul>
<li>char：多字节字符类型</li>
<li>wchar_t：宽字符类型</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> szStr[]=<span class="string">&quot;中国&quot;</span>;<span class="comment">//使用的是ANSI编码 D6 D0 B9 FA 00 (一个字节的零表示结尾)</span></span><br><span class="line"><span class="type">wchar_t</span> sezStr[]=<span class="string">L&quot;中国&quot;</span>;<span class="comment">//使用的是UTF-16编码 2D 4E FD 56 00 00(两个字节的0表示结尾)</span></span><br><span class="line"><span class="comment">//L的意思是让编译器存储该字符串的时候按照UTF-16来存储，也可以设置编译器选项设置默认存储格式为UTF-16，就不需要写这个L了</span></span><br></pre></td></tr></table></figure>

<h3 id="字符常用函数"><a href="#字符常用函数" class="headerlink" title="字符常用函数"></a>字符常用函数</h3><p>使用的函数版本根据编码不同也被提供了两套</p>
<table>
<thead>
<tr>
<th>多字节字符函数</th>
<th>宽字符函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>printf</td>
<td>wprintf</td>
<td>打印到控制台函数</td>
</tr>
<tr>
<td>strlen</td>
<td>wcslen</td>
<td>获取长度</td>
</tr>
<tr>
<td>strcpy</td>
<td>wcscpy</td>
<td>字符串复制</td>
</tr>
<tr>
<td>strcat</td>
<td>wcscat</td>
<td>字符串拼接</td>
</tr>
<tr>
<td>strcmp</td>
<td>wcscmp</td>
<td>字符串比较</td>
</tr>
<tr>
<td>strstr</td>
<td>wcsstr</td>
<td>字符串查找功能</td>
</tr>
</tbody></table>
<p>&#x3D;&#x3D;&#x3D;</p>
<p>下面是Windows定义的一组字符串函数，这些函数用来计算字符串长度、复制字符串、连接字符串和比较字符串：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ILength = <span class="built_in">lstrlen</span> (pString) ;</span><br><span class="line">        </span><br><span class="line">pString = <span class="built_in">lstrcpy</span> (pString1, pString2) ;</span><br><span class="line">        </span><br><span class="line">pString = <span class="built_in">lstrcpyn</span> (pString1, pString2, iCount) ;</span><br><span class="line">        </span><br><span class="line">pString = <span class="built_in">lstrcat</span> (pString1, pString2) ;</span><br><span class="line">        </span><br><span class="line">iComp = <span class="built_in">lstrcmp</span> (pString1, pString2) ;</span><br><span class="line">        </span><br><span class="line">iComp = <span class="built_in">lstrcmpi</span> (pString1, pString2) ;</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<p>这些函数与C链接库中对应的函数功能相同。如果定义了UNICODE标识符，那么这些函数将接受宽字符串，否则只接受常规字符串。宽字符串版的lstrlenW函数可在Windows 98中执行。</p>
<h1 id="win32的API"><a href="#win32的API" class="headerlink" title="win32的API"></a>win32的API</h1><p>主要是存放在C：&#x2F;IWINDOWS&#x2F;system32和C：&#x2F;IWINDOWS&#x2F;SysWow64 下面的所有dll</p>
<p>SysWow64 存的是32位dll，而system32存的是64位DLL</p>
<p>几个重要的DLL：</p>
<ol>
<li>Kernel32.dll：最核心的功能模块，比如管理内存，进程和线程相关的函数等。</li>
<li>User32.dll：是Windows用户界面相关应用程序接口，如创建窗口和发送消息等。</li>
<li>GDI32.dll：全程是Graphical Device Interface（图形设备接口），包含用于画图和显示文本的函数。</li>
</ol>
<p>使用win32的api只需要包含头文件：#include&lt;windows.h&gt;</p>
<h1 id="win32的类型"><a href="#win32的类型" class="headerlink" title="win32的类型"></a>win32的类型</h1><p> LPCSTR -&gt; CONST CHAR *-&gt;const char*</p>
<p>看起来很复杂但其实只是起的别名</p>
<table>
<thead>
<tr>
<th>原类型</th>
<th>windows.h起的别名</th>
<th>指针别名</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>BYTE</td>
<td>PBYTE</td>
</tr>
<tr>
<td>word</td>
<td>WORD</td>
<td>PWORD</td>
</tr>
<tr>
<td>dword</td>
<td>DWORD</td>
<td>PDWORD</td>
</tr>
<tr>
<td>char(ANSI)</td>
<td>CHAR</td>
<td>PCHAR&#x2F;PSTR</td>
</tr>
<tr>
<td>unsigned char</td>
<td>UCHAR</td>
<td>PUCHAR</td>
</tr>
<tr>
<td>short</td>
<td>SHORT</td>
<td>PSHORT</td>
</tr>
<tr>
<td>unsigned short</td>
<td>USHORT</td>
<td>PUSHORT</td>
</tr>
<tr>
<td>int</td>
<td>INT</td>
<td>PINT</td>
</tr>
<tr>
<td>unsigned int</td>
<td>UINT</td>
<td>PUINT</td>
</tr>
<tr>
<td>bool</td>
<td>BOOL</td>
<td></td>
</tr>
<tr>
<td>wchar_t(UTF-16)</td>
<td>WCHAR</td>
<td>PWSTR</td>
</tr>
</tbody></table>
<h1 id="WIN32中使用字符串"><a href="#WIN32中使用字符串" class="headerlink" title="WIN32中使用字符串"></a>WIN32中使用字符串</h1><p>字符类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CHAR szStr[]=<span class="string">&quot;中国&quot;</span>;</span><br><span class="line">WCHAR sezStr[]=<span class="string">L&quot;中国&quot;</span>;</span><br><span class="line">TCHAR stzStr[]=<span class="built_in">TEXT</span>(<span class="string">&quot;中国&quot;</span>);<span class="comment">//这种方式只要修改项目设置，就可以全部修改ASCII和宽字符</span></span><br></pre></td></tr></table></figure>

<p>字符串指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PSTR pszStr=<span class="string">&quot;中国&quot;</span>;</span><br><span class="line">PWSTR pwszStr=<span class="string">L&quot;中国&quot;</span>;</span><br><span class="line">PTSTR ptszStr=<span class="built_in">TEXT</span>(<span class="string">&quot;中国&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>由于windows的底层全是unicode，所以unicode性能更好。</p>
<p>编程的时候推荐，函数用宏，类型用PTSTR和TCHAR，字符串用TEXT，项目设置为unicode。</p>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>进程提供程序所需的资源，如：数据，代码等等</p>
<p><strong>进程内存空间的地址划分</strong></p>
<table>
<thead>
<tr>
<th>分区</th>
<th>X86 32位Windows</th>
</tr>
</thead>
<tbody><tr>
<td>空指针赋值区(前64KB)</td>
<td>0x00000000~0x0000FFFF</td>
</tr>
<tr>
<td>用户模式区</td>
<td>0x00010000~0x7FFEFFFF</td>
</tr>
<tr>
<td>64KB禁入区(后64KB)</td>
<td>0x7FFF0000~0x7FFFFFFF</td>
</tr>
<tr>
<td>内核</td>
<td>0x80000000~0xFFFFFFFF</td>
</tr>
</tbody></table>
<p>每个进程的内核部分其实是同一份</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210615121702693.png" alt="image-20210615121702693"></p>
<h2 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h2><p>任何进程都是别的进程创建的（第一个进程是操作系统内核创建的）</p>
<p><code>当我们双击运行的时候，实际上是explorer.exe调用了CreateProcess函数帮我们创建了进程</code></p>
<p><strong>进程的创建过程</strong></p>
<ol>
<li><p>映射EXE文件</p>
</li>
<li><p>创建内核对象EPROCESS</p>
</li>
<li><p>映射系统DLL（ntdll.dll）</p>
</li>
<li><p>创建线程内核对象ETHREAD</p>
</li>
<li><p>系统启动线程</p>
<p>​		映射DLL（ntdll.LdrInitializeThunk）</p>
<p>​		线程开始执行</p>
</li>
</ol>
<p><strong>对抗点：</strong>映射DLL之前注入DLL，映射DLL之前替换整个进程等等</p>
<p>创建进程的同时也创建了线程。</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210615134439052.png" alt="image-20210615134439052"></p>
<h2 id="CreateProcess函数"><a href="#CreateProcess函数" class="headerlink" title="CreateProcess函数"></a>CreateProcess函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回值表示是否创建成功</span></span><br><span class="line"><span class="function">BOOL <span class="title">CreateProcessA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR                lpApplicationName,<span class="comment">//全路径对象名称</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPSTR                 lpCommandLine,<span class="comment">//命令行参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPSECURITY_ATTRIBUTES lpProcessAttributes,<span class="comment">//安全属性结构体指针，是否可继承进程句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPSECURITY_ATTRIBUTES lpThreadAttributes,<span class="comment">//安全属性结构体指针，是否可继承线程句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">  BOOL                  bInheritHandles,<span class="comment">//是否继承父进程的句柄表</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD                 dwCreationFlags,<span class="comment">//创建标志（可以指定是否开新的控制台，是否挂起启动等等）</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPVOID                lpEnvironment,<span class="comment">//进程环境变量（填空就好，没什么用）</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR                lpCurrentDirectory,<span class="comment">//工作目录，即进程工作路径</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPSTARTUPINFOA        lpStartupInfo,<span class="comment">//[IN参数]启动信息结构体指针(必填)</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPPROCESS_INFORMATION lpProcessInformation<span class="comment">//[OUT参数]进程信息结构体</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">CreateProcessW</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCWSTR               lpApplicationName,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPWSTR                lpCommandLine,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPSECURITY_ATTRIBUTES lpProcessAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPSECURITY_ATTRIBUTES lpThreadAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">  BOOL                  bInheritHandles,</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD                 dwCreationFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPVOID                lpEnvironment,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCWSTR               lpCurrentDirectory,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPSTARTUPINFOW        lpStartupInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPPROCESS_INFORMATION lpProcessInformation</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>dwCreationFlags字段设置挂起启动的意义</strong>：</p>
<ol>
<li><p>映射EXE文件</p>
</li>
<li><p>创建内核对象EPROCESS</p>
</li>
<li><p>映射系统DLL（ntdll.dll）</p>
</li>
<li><p>创建线程内核对象ETHREAD</p>
</li>
<li><p>如果是挂起的方式启动</p>
<p>​		。。。（为所欲为，比如提前注入）</p>
</li>
<li><p>恢复以后再继续执行（ResumeThread函数恢复）</p>
<p>​		映射DLL（ntdll.LdrInitializeThunk）</p>
<p>​		线程开始执行</p>
</li>
</ol>
<h3 id="LPSTARTUPINFO结构体指针指向的结构体"><a href="#LPSTARTUPINFO结构体指针指向的结构体" class="headerlink" title="LPSTARTUPINFO结构体指针指向的结构体"></a>LPSTARTUPINFO结构体指针指向的结构体</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_STARTUPINFOA</span> &#123;</span><br><span class="line">  DWORD  cb;<span class="comment">//存当前结构体的大小，目的是为了以后程序的拓展(必填)</span></span><br><span class="line">  LPSTR  lpReserved;<span class="comment">//保留，置为NULL</span></span><br><span class="line">  LPSTR  lpDesktop;<span class="comment">//指定一个字符串，包括该进程的桌面名或窗口位置名</span></span><br><span class="line">  LPSTR  lpTitle;<span class="comment">//指定控制台进程创建的新控制台窗口标题</span></span><br><span class="line">  DWORD  dwX;<span class="comment">//指定新窗口左上角的x和y偏移量（以像素为单位）</span></span><br><span class="line">  DWORD  dwY;</span><br><span class="line">  DWORD  dwXSize;<span class="comment">//指定新窗口的宽度和高度</span></span><br><span class="line">  DWORD  dwYSize;</span><br><span class="line">  DWORD  dwXCountChars;<span class="comment">//指定新窗口的屏幕缓冲区的宽度和高度</span></span><br><span class="line">  DWORD  dwYCountChars;</span><br><span class="line">  DWORD  dwFillAttribute;<span class="comment">//指定新窗口的初始文字和背景颜色</span></span><br><span class="line">  DWORD  dwFlags;<span class="comment">//创建窗口标志</span></span><br><span class="line">  WORD   wShowWindow;<span class="comment">//新窗口的显示状态</span></span><br><span class="line">  WORD   cbReserved2;<span class="comment">//保留，必须置为0</span></span><br><span class="line">  LPBYTE lpReserved2;<span class="comment">//保留，必须置为NULL</span></span><br><span class="line">  HANDLE hStdInput;<span class="comment">//指定一个句柄，该句柄用作进程的标准输入句柄</span></span><br><span class="line">  HANDLE hStdOutput;<span class="comment">//指定一个句柄，该句柄用作进程的标准输出句柄</span></span><br><span class="line">  HANDLE hStdError;<span class="comment">//指定一个句柄，句柄用作进程的标准错误句柄</span></span><br><span class="line">&#125; STARTUPINFOA, *LPSTARTUPINFOA;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_STARTUPINFOW</span> &#123;</span><br><span class="line">  DWORD  cb;</span><br><span class="line">  LPWSTR lpReserved;</span><br><span class="line">  LPWSTR lpDesktop;</span><br><span class="line">  LPWSTR lpTitle;</span><br><span class="line">  DWORD  dwX;</span><br><span class="line">  DWORD  dwY;</span><br><span class="line">  DWORD  dwXSize;</span><br><span class="line">  DWORD  dwYSize;</span><br><span class="line">  DWORD  dwXCountChars;</span><br><span class="line">  DWORD  dwYCountChars;</span><br><span class="line">  DWORD  dwFillAttribute;</span><br><span class="line">  DWORD  dwFlags;</span><br><span class="line">  WORD   wShowWindow;</span><br><span class="line">  WORD   cbReserved2;</span><br><span class="line">  LPBYTE lpReserved2;</span><br><span class="line">  HANDLE hStdInput;</span><br><span class="line">  HANDLE hStdOutput;</span><br><span class="line">  HANDLE hStdError;</span><br><span class="line">&#125; STARTUPINFOW, *LPSTARTUPINFOW;</span><br></pre></td></tr></table></figure>

<p><strong>对抗点</strong>：_STARTUPINFOA如果由explorer.exe创建的进程填写的和由调试器创建，在不作处理的情况下，给_STARTUPINFOA填写的不一致，(explorer.exe 使用 shell32 中 ShellExecute 的来运行程序, ShellExecute 会清不用的值)（ollydbg 会向 STARTUPINFO 中的  dwFlags 设置 STARTF_FORCEOFFFEEDBACK,而 explorer 不会）</p>
<h3 id="LPPROCESS-INFORMATION结构体指针指向的结构体"><a href="#LPPROCESS-INFORMATION结构体指针指向的结构体" class="headerlink" title="LPPROCESS_INFORMATION结构体指针指向的结构体"></a>LPPROCESS_INFORMATION结构体指针指向的结构体</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_PROCESS_INFORMATION</span> &#123;</span><br><span class="line">  HANDLE hProcess;<span class="comment">//进程句柄</span></span><br><span class="line">  HANDLE hThread;<span class="comment">//线程句柄</span></span><br><span class="line">  DWORD  dwProcessId;<span class="comment">//进程ID</span></span><br><span class="line">  DWORD  dwThreadId;<span class="comment">//线程ID</span></span><br><span class="line">&#125; PROCESS_INFORMATION, *PPROCESS_INFORMATION, *LPPROCESS_INFORMATION;</span><br></pre></td></tr></table></figure>

<h3 id="LPSECURITY-ATTRIBUTES结构体指针指向的结构体"><a href="#LPSECURITY-ATTRIBUTES结构体指针指向的结构体" class="headerlink" title="LPSECURITY_ATTRIBUTES结构体指针指向的结构体"></a>LPSECURITY_ATTRIBUTES结构体指针指向的结构体</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_SECURITY_ATTRIBUTES</span> &#123;</span><br><span class="line">  DWORD  nLength;<span class="comment">//该结构体的长度（必填）</span></span><br><span class="line">  LPVOID lpSecurityDescriptor;<span class="comment">//指向一个安全描述符结构体的指针，表明当前内核对象，哪个用户能访问（写代码时不需要关注，因为不设置的时候，默认表示安全设置与父进程一样）</span></span><br><span class="line">  BOOL   bInheritHandle;<span class="comment">//当前内核对象是否允许继承（重点）决定了后面有张图中父进程句柄表中的字段是0还是1，允许被继承填1，不允许填0</span></span><br><span class="line">&#125; SECURITY_ATTRIBUTES, *PSECURITY_ATTRIBUTES, *LPSECURITY_ATTRIBUTES;</span><br></pre></td></tr></table></figure>

<p>如果bInheritHandle填的是不允许被继承，那么不需要填写这个字段，直接整个_SECURITY_ATTRIBUTES结构体字段填NULL就可以了，表明不被继承。即父进程句柄表中字段为0。</p>
<p><strong>创建进程案例</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CreateChildProcess</span><span class="params">(PTCHAR szChildProcssName,PTCHAR szCommandLine)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    STARTUPINFO si;</span><br><span class="line">	PROCESS_INFORMATION pi;</span><br><span class="line">	<span class="built_in">ZeroMemory</span>(&amp;pi,<span class="built_in">sizeof</span>(pi));</span><br><span class="line">	<span class="built_in">ZeroMemory</span>(&amp;pi,<span class="built_in">sizeof</span>(si));</span><br><span class="line">	si.cb=<span class="built_in">sizeof</span>(si);<span class="comment">//必填</span></span><br><span class="line">	<span class="comment">//创建进程，返回成功与失败</span></span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">CreateProcess</span>(</span><br><span class="line">    	szChildProcssName,<span class="comment">//对象名称</span></span><br><span class="line">        szCommandLine,<span class="comment">//命令行</span></span><br><span class="line">        <span class="literal">NULL</span>,<span class="comment">//不继承进程句柄</span></span><br><span class="line">        <span class="literal">NULL</span>,<span class="comment">//不继承线程句柄</span></span><br><span class="line">        FALSE,<span class="comment">//不继承父进程的句柄表</span></span><br><span class="line">        <span class="number">0</span>,<span class="comment">//没有创建标志</span></span><br><span class="line">        <span class="literal">NULL</span>,<span class="comment">//使用父进程环境变量</span></span><br><span class="line">        <span class="literal">NULL</span>,<span class="comment">//使用父进程工作路径作为当前进程工作路径</span></span><br><span class="line">        &amp;si,<span class="comment">//_STARTUPINFOW结构体详细信息</span></span><br><span class="line">	    &amp;pi)<span class="comment">//LPPROCESS_INFORMATION结构体详细信息</span></span><br><span class="line">      )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建子进程失败,错误：%d\n&quot;</span>,<span class="built_in">GetLastError</span>());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放句柄</span></span><br><span class="line">    <span class="built_in">CloseHandle</span>(pi.hProcess);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(pi.hThread);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>WIN32的部分api是通过GetLastError()获取错误原因和返回值。</code></p>
<h2 id="main函数的参数"><a href="#main函数的参数" class="headerlink" title="main函数的参数"></a>main函数的参数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//argc是命令行参数的个数，argv是存命令行参数的指针。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="句柄表（与上一章紧密相连）"><a href="#句柄表（与上一章紧密相连）" class="headerlink" title="句柄表（与上一章紧密相连）"></a>句柄表（与上一章紧密相连）</h1><h2 id="内核对象"><a href="#内核对象" class="headerlink" title="内核对象"></a>内核对象</h2><p>像进程，线程，文件，互斥体，事件等在内核都有一个对应的结构体，这些结构体由内核负责管理。我们管这样的对象叫做内核对象。</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210615144439614.png" alt="image-20210615144439614"></p>
<p>内核对象有如下：</p>
<ul>
<li>Access token</li>
<li>Communications device</li>
<li>Console input</li>
<li>Console screen buffer</li>
<li>Event    事件</li>
<li>File    文件</li>
<li>File mapping    文件映射</li>
<li>I&#x2F;O completion port</li>
<li>Job</li>
<li>Mailslot</li>
<li>Memory resource notification</li>
<li>Mutex    互斥体</li>
<li>Named pipe    命名管道</li>
<li>Pipe    管道</li>
<li>Process    进程</li>
<li>Semaphore    信号量</li>
<li>Thread    线程</li>
<li>Transaction</li>
<li>Waitable timer</li>
</ul>
<p>内核对象的共同特征，其对应创建函数中有安全描述符，即LPSECURITY_ATTRIBUTES参数。</p>
<h3 id="如何管理内核对象"><a href="#如何管理内核对象" class="headerlink" title="如何管理内核对象"></a><strong>如何管理内核对象</strong></h3><p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210615144902520.png" alt="image-20210615144902520"></p>
<p>内核结构的地址一定是大于0x80000000的，属于内核区，如果应用层访问内核区的地址将<strong>直接蓝屏</strong>。为了避免这种情况，不能直接暴露内核地址给应用层，从根源上解决这种隐患。<strong>句柄表</strong>就是为了不直接暴露内核地址做的隔离层。</p>
<h2 id="句柄表"><a href="#句柄表" class="headerlink" title="句柄表"></a>句柄表</h2><h3 id="每一个进程都有一个句柄表"><a href="#每一个进程都有一个句柄表" class="headerlink" title="每一个进程都有一个句柄表"></a><strong>每一个进程都有一个句柄表</strong></h3><p>只有进程内核对象才有句柄表</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210615145614061.png" alt="image-20210615145614061"></p>
<p><strong>句柄表</strong>：通过句柄表访问内核对象，而不直接通过内核地址。蓝色表格中的编号就是句柄，即<strong>应用层通过进程中的句柄表中的句柄访问内核对象</strong>。</p>
<p><strong>句柄</strong>：当前进程私有的一个内核对象的索引</p>
<p>句柄就是一道防火墙，隔离应用层和内核层，防止应用层直接访问内核层地址。</p>
<p><strong>句柄就是应用层访问内核对象的安全方式</strong></p>
<hr>
<h3 id="多进程共享一个内核对象"><a href="#多进程共享一个内核对象" class="headerlink" title="多进程共享一个内核对象"></a><strong>多进程共享一个内核对象</strong></h3><p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210615150920853.png" alt="image-20210615150920853"></p>
<p>上图可知，<strong>句柄的值只针对当前进程才有意义</strong></p>
<p>A上面的2表示计数器，两个进程的句柄表都记录了A的句柄，所以计数器为2。closeHandle关闭句柄，<strong>只有当计数器变为0了，才能真正地释放该内核对象</strong></p>
<p><strong>线程内核对象释放</strong>有一点例外：要真正释放一个线程内核对象，必须线程执行结束并且关闭所有该线程句柄，才能真正释放该线程内核对象。</p>
<p><strong>进程里的唯一线程被释放了，进程才真正被释放。</strong></p>
<h3 id="句柄可以被继承"><a href="#句柄可以被继承" class="headerlink" title="句柄可以被继承"></a>句柄可以被继承</h3><p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210615155616437.png" alt="image-20210615155616437"></p>
<p>父进程的句柄表中绿色表格部分表示<strong>该句柄是否可以被子进程继承</strong>。</p>
<p><strong>创建子进程的bInheritHandles参数如果指定了true，表示该子进程继承父进程的句柄表，但只能继承绿色表格部分为1的句柄</strong>。</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210615162232666.png" alt="image-20210615162232666"></p>
<p>总结，多进程共享内核对象的方式：</p>
<ol>
<li>通过函数（例：OpenProcess）来得到对应内核对象句柄。</li>
<li>通过继承（设置继承与否相关等属性后，直接通过命令行参数传句柄具体值）</li>
</ol>
<h3 id="WIN32中句柄的种类"><a href="#WIN32中句柄的种类" class="headerlink" title="WIN32中句柄的种类"></a>WIN32中句柄的种类</h3><ol>
<li>HANDLE 指向内核对象的句柄</li>
<li>HWND 指向窗口的句柄</li>
<li>HDC 指向设备上下文的句柄</li>
<li>HINSTANCE 指向模块的句柄</li>
<li>……(H开头的都是句柄)</li>
</ol>
<h1 id="进程ID与线程ID"><a href="#进程ID与线程ID" class="headerlink" title="进程ID与线程ID"></a>进程ID与线程ID</h1><p>操作系统有一张<strong>全局句柄表</strong>，里面包含了所有进程和线程，<strong>进程ID和线程ID</strong>就是这张表中的句柄</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210615163527181.png" alt="image-20210615163527181"></p>
<p>进程ID和线程ID是全局的，可以<strong>跨进程</strong>的。ID是<strong>唯一</strong>的，不同时存在重复的。</p>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p><strong>线程独享各自的栈</strong>，堆是各个线程可以共享的</p>
<ul>
<li><p>线程和进程的区别</p>
<p><strong>从内存上</strong>：进程创建时会被分配地址空间，并且包含以下几种内存空间：堆区、栈区、代码区、全局变量区。</p>
<p>​				  线程创建时会分配线程的私有栈，包括：维护参数和局部变量线程栈区，程序计数器（维护线程挂起再运行），寄存器集合等。</p>
<p>​				  线程共享进程中除了线程上下文外的所有内存空间，包括（文件、系统资源等）</p>
<p><strong>从效率上</strong>：进程包含线程，并且拥有更多的数据结构需要维护。所以切换或者创建，进程的效率要慢于线程。</p>
<p><strong>安全性上</strong>：进程间有独立的地址空间，安全性较好；线程间虽然有私有的栈区，当理论上只要知道栈帧地址即可修改其他线程的变量。</p>
</li>
</ul>
<h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><ol>
<li>线程是附属在进程上的<strong>执行实体</strong>，是代码的执行流程。</li>
<li>一个进程可以包含多个线程，但一个进程至少要包含一个线程。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回值为线程句柄</span></span><br><span class="line"><span class="function">HANDLE <span class="title">CreateThread</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPSECURITY_ATTRIBUTES   lpThreadAttributes,<span class="comment">//安全属性，决定是否可被继承</span></span></span></span><br><span class="line"><span class="params"><span class="function">  SIZE_T                  dwStackSize,<span class="comment">//初始堆栈（0表示系统默认）</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPTHREAD_START_ROUTINE  lpStartAddress,<span class="comment">//线程回调函数</span></span></span></span><br><span class="line"><span class="params"><span class="function">  __drv_aliasesMem LPVOID lpParameter,<span class="comment">//线程回调函数的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD                   dwCreationFlags,<span class="comment">//创建线程的标识，0表示立即执行，CREATE_SUSPENDED表示挂起</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPDWORD                 lpThreadId<span class="comment">//[out]返回线程id，不接受填NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>上文句柄表中内核对象部分有提到：要真正释放一个线程内核对象，必须线程执行结束并且关闭所有该线程句柄，才能真正释放该线程内核对象。</p>
<p>即<strong>线程释放</strong>的两个条件</p>
<ul>
<li>打开句柄计数为0</li>
<li>线程执行结束</li>
</ul>
<p>所以如果创建的线程后续不需要使用句柄再操作该线程，则可以直接创建线程后马上CloseHandle。线程正常执行，线程执行结束后系统释放线程内核对象。</p>
<h3 id="创建线程的各种方法"><a href="#创建线程的各种方法" class="headerlink" title="创建线程的各种方法"></a>创建线程的各种方法</h3><p>1） Create&#x2F;EndThread是Win32方法开始&#x2F;结束一个线程<br>2） _beginthreadx&#x2F;_endthreadex是C RunTime方式开始&#x2F;结束一个线程<br>3） AfxBeginThread是在MFC中开始&#x2F;结束一个线程 </p>
<h4 id="C-11之前"><a href="#C-11之前" class="headerlink" title="C++11之前"></a>C++11之前</h4><p>是用_beginthreadex创建线程，内部实现是调用CreareThread，但一般不推荐直接使用CreateThread，因为前者做了许多安全保护的工作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> _beginthread(</span><br><span class="line">  <span class="built_in">void</span>(_cdecl *start_address)(<span class="type">void</span> *), <span class="comment">//声明为void (*start_address)(void *)形式</span></span><br><span class="line">  <span class="type">unsigned</span> stack_size, <span class="comment">//是线程堆栈大小，一般默认为0</span></span><br><span class="line">  <span class="type">void</span> *arglist <span class="comment">//向线程传递的参数，一般为结构体</span></span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> _beginthreadex( <span class="comment">//推荐使用</span></span><br><span class="line">  <span class="type">void</span> *security,    <span class="comment">//安全属性，NULL表示默认安全性</span></span><br><span class="line">  <span class="type">unsigned</span> stack_size, <span class="comment">//是线程堆栈大小，一般默认为0</span></span><br><span class="line">  <span class="built_in">unsigned</span>(_stdcall  *start_address)(<span class="type">void</span> *),    <span class="comment">//声明为unsigned(*start_address)(void *)形式</span></span><br><span class="line">  <span class="type">void</span> *argilist,    <span class="comment">//向线程传递的参数，一般为结构体</span></span><br><span class="line">  <span class="type">unsigned</span> initflag, <span class="comment">//新线程的初始状态，0表示立即执行，CREATE_SUSPEND表示创建后挂起（可用ResumeThread唤醒）。</span></span><br><span class="line">  <span class="type">unsigned</span> *thrdaddr <span class="comment">//该变量存放线程标识符，它是CreateThread函数中的线程ID。</span></span><br><span class="line">); <span class="comment">//创建成功条件下的将线程句柄转化为unsigned long型返回，创建失败条件下返回0</span></span><br></pre></td></tr></table></figure>

<h4 id="C-11之后"><a href="#C-11之后" class="headerlink" title="C++11之后"></a>C++11之后</h4><h4 id="thread-（thread-h中）"><a href="#thread-（thread-h中）" class="headerlink" title="thread　（thread.h中）"></a>thread　（thread.h中）</h4><p>使用方式：所有可执行的对象都可以放入thread中，包括，全局函数、类的成员函数、lambda表达式等。</p>
<p><strong>略</strong></p>
<h2 id="线程回调函数"><a href="#线程回调函数" class="headerlink" title="线程回调函数"></a>线程回调函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_ LPVOID lpParameter</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>不一定 要按照上面的格式定义现线程回调函数，只要填入CreateThread的时候进行强制转换一下。</p>
<p><strong>线程传参要注意：</strong>因为传的是指针，<strong>必须保证该指针指向的变量的生命周期在线程使用完该变量之后结束</strong></p>
<p>除了线程传参外，<strong>全局变量线程函数是可以直接使用的。</strong></p>
<p>向线程函数传递变量：</p>
<ol>
<li>线程参数</li>
<li>全局变量</li>
</ol>
<h2 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h2><h3 id="让线程停下"><a href="#让线程停下" class="headerlink" title="让线程停下"></a>让线程停下</h3><p>让当前线程停下来</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Sleep</span>()</span><br></pre></td></tr></table></figure>

<p>挂起别的线程，即线程挂起计数++</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SuspendThread</span>(线程句柄)</span><br></pre></td></tr></table></figure>

<p>恢复线程挂起计数,即线程挂起计数–</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ResumeThread</span>()</span><br></pre></td></tr></table></figure>

<p><strong>线程挂起计数为0，线程才会真正恢复执行</strong></p>
<h3 id="等待线程结束"><a href="#等待线程结束" class="headerlink" title="等待线程结束"></a>等待线程结束</h3><p>线程的四种状态：</p>
<ol>
<li>新建状态（New）：刚被创建</li>
<li>准备状态（Runnable）：加载所需的所有资源，等待CPU</li>
<li>运行状态（Running）：被CPU执行</li>
<li>挂起状态（Blocked）：阻塞，等待唤醒</li>
</ol>
<h4 id="WaitForSingleObject"><a href="#WaitForSingleObject" class="headerlink" title="WaitForSingleObject()"></a>WaitForSingleObject()</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前线程阻塞状态，等待指定对象状态发生变更（执行完毕也属于状态发生变更）或超时间隔结束才继续执行。</span></span><br><span class="line"><span class="function">DWORD <span class="title">WaitForSingleObject</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE hHandle,<span class="comment">//什么内核对象句柄都可以</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD  dwMilliseconds<span class="comment">//超时时间，最多等多久，INFINITE表示等无限久</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="WaitForMultipleObjects"><a href="#WaitForMultipleObjects" class="headerlink" title="WaitForMultipleObjects();"></a>WaitForMultipleObjects();</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">WaitForMultipleObjects</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD        nCount,<span class="comment">//等几个内核对象</span></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">const</span> HANDLE *lpHandles,<span class="comment">//内核对象指针，什么内核对象句柄都可以</span></span></span></span><br><span class="line"><span class="params"><span class="function">  BOOL         bWaitAll,<span class="comment">//等待模式，1表示等所有对象状态变更，0表示等任一个对象状态变更</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD        dwMilliseconds<span class="comment">//超时时间，最多等多久，INFINITE表示等无限久</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="GetExitCodeThread"><a href="#GetExitCodeThread" class="headerlink" title="GetExitCodeThread()"></a>GetExitCodeThread()</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取线程回调函数的返回结果</span></span><br><span class="line"><span class="comment">//返回值：函数成功，则返回值非零。失败为零</span></span><br><span class="line"><span class="function">BOOL <span class="title">GetExitCodeThread</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE  hThread,<span class="comment">//线程句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPDWORD lpExitCode<span class="comment">//[out]存返回结果的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="线程上下文"><a href="#线程上下文" class="headerlink" title="线程上下文"></a>线程上下文</h3><p><strong>CONTEXT结构体</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//64位</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">DECLSPEC_ALIGN</span>(<span class="number">16</span>) _CONTEXT &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Register parameter home addresses.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// N.B. These fields are for convience - they could be used to extend the</span></span><br><span class="line">    <span class="comment">//      context record in the future.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    DWORD64 P1Home;</span><br><span class="line">    DWORD64 P2Home;</span><br><span class="line">    DWORD64 P3Home;</span><br><span class="line">    DWORD64 P4Home;</span><br><span class="line">    DWORD64 P5Home;</span><br><span class="line">    DWORD64 P6Home;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Control flags.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    DWORD ContextFlags;</span><br><span class="line">    DWORD MxCsr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Segment Registers and processor flags.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    WORD   SegCs;</span><br><span class="line">    WORD   SegDs;</span><br><span class="line">    WORD   SegEs;</span><br><span class="line">    WORD   SegFs;</span><br><span class="line">    WORD   SegGs;</span><br><span class="line">    WORD   SegSs;</span><br><span class="line">    DWORD EFlags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Debug registers</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    DWORD64 Dr0;</span><br><span class="line">    DWORD64 Dr1;</span><br><span class="line">    DWORD64 Dr2;</span><br><span class="line">    DWORD64 Dr3;</span><br><span class="line">    DWORD64 Dr6;</span><br><span class="line">    DWORD64 Dr7;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Integer registers.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    DWORD64 Rax;</span><br><span class="line">    DWORD64 Rcx;</span><br><span class="line">    DWORD64 Rdx;</span><br><span class="line">    DWORD64 Rbx;</span><br><span class="line">    DWORD64 Rsp;</span><br><span class="line">    DWORD64 Rbp;</span><br><span class="line">    DWORD64 Rsi;</span><br><span class="line">    DWORD64 Rdi;</span><br><span class="line">    DWORD64 R8;</span><br><span class="line">    DWORD64 R9;</span><br><span class="line">    DWORD64 R10;</span><br><span class="line">    DWORD64 R11;</span><br><span class="line">    DWORD64 R12;</span><br><span class="line">    DWORD64 R13;</span><br><span class="line">    DWORD64 R14;</span><br><span class="line">    DWORD64 R15;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Program counter.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    DWORD64 Rip;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Floating point state.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        XMM_SAVE_AREA32 FltSave;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            M128A Header[<span class="number">2</span>];</span><br><span class="line">            M128A Legacy[<span class="number">8</span>];</span><br><span class="line">            M128A Xmm0;</span><br><span class="line">            M128A Xmm1;</span><br><span class="line">            M128A Xmm2;</span><br><span class="line">            M128A Xmm3;</span><br><span class="line">            M128A Xmm4;</span><br><span class="line">            M128A Xmm5;</span><br><span class="line">            M128A Xmm6;</span><br><span class="line">            M128A Xmm7;</span><br><span class="line">            M128A Xmm8;</span><br><span class="line">            M128A Xmm9;</span><br><span class="line">            M128A Xmm10;</span><br><span class="line">            M128A Xmm11;</span><br><span class="line">            M128A Xmm12;</span><br><span class="line">            M128A Xmm13;</span><br><span class="line">            M128A Xmm14;</span><br><span class="line">            M128A Xmm15;</span><br><span class="line">        &#125; DUMMYSTRUCTNAME;</span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Vector registers.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    M128A VectorRegister[<span class="number">26</span>];</span><br><span class="line">    DWORD64 VectorControl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Special debug control registers.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    DWORD64 DebugControl;</span><br><span class="line">    DWORD64 LastBranchToRip;</span><br><span class="line">    DWORD64 LastBranchFromRip;</span><br><span class="line">    DWORD64 LastExceptionToRip;</span><br><span class="line">    DWORD64 LastExceptionFromRip;</span><br><span class="line">&#125; CONTEXT, *PCONTEXT;</span><br><span class="line"></span><br><span class="line"><span class="comment">//32位</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_WOW64_CONTEXT</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The flags values within this flag control the contents of</span></span><br><span class="line">    <span class="comment">// a CONTEXT record.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// If the context record is used as an input parameter, then</span></span><br><span class="line">    <span class="comment">// for each portion of the context record controlled by a flag</span></span><br><span class="line">    <span class="comment">// whose value is set, it is assumed that that portion of the</span></span><br><span class="line">    <span class="comment">// context record contains valid context. If the context record</span></span><br><span class="line">    <span class="comment">// is being used to modify a threads context, then only that</span></span><br><span class="line">    <span class="comment">// portion of the threads context will be modified.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// If the context record is used as an IN OUT parameter to capture</span></span><br><span class="line">    <span class="comment">// the context of a thread, then only those portions of the thread&#x27;s</span></span><br><span class="line">    <span class="comment">// context corresponding to set flags will be returned.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The context record is never used as an OUT only parameter.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    DWORD ContextFlags;<span class="comment">//在查询的时候需要设置该字段，表示查询哪些其他的CONTEXT结构字段。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This section is specified/returned if CONTEXT_DEBUG_REGISTERS is</span></span><br><span class="line">    <span class="comment">// set in ContextFlags.  Note that CONTEXT_DEBUG_REGISTERS is NOT</span></span><br><span class="line">    <span class="comment">// included in CONTEXT_FULL.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    DWORD   Dr0;</span><br><span class="line">    DWORD   Dr1;</span><br><span class="line">    DWORD   Dr2;</span><br><span class="line">    DWORD   Dr3;</span><br><span class="line">    DWORD   Dr6;</span><br><span class="line">    DWORD   Dr7;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This section is specified/returned if the</span></span><br><span class="line">    <span class="comment">// ContextFlags word contians the flag CONTEXT_FLOATING_POINT.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    WOW64_FLOATING_SAVE_AREA FloatSave;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This section is specified/returned if the</span></span><br><span class="line">    <span class="comment">// ContextFlags word contians the flag CONTEXT_SEGMENTS.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    DWORD   SegGs;</span><br><span class="line">    DWORD   SegFs;</span><br><span class="line">    DWORD   SegEs;</span><br><span class="line">    DWORD   SegDs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This section is specified/returned if the</span></span><br><span class="line">    <span class="comment">// ContextFlags word contians the flag CONTEXT_INTEGER.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    DWORD   Edi;</span><br><span class="line">    DWORD   Esi;</span><br><span class="line">    DWORD   Ebx;</span><br><span class="line">    DWORD   Edx;</span><br><span class="line">    DWORD   Ecx;</span><br><span class="line">    DWORD   Eax;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This section is specified/returned if the</span></span><br><span class="line">    <span class="comment">// ContextFlags word contians the flag CONTEXT_CONTROL.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    DWORD   Ebp;</span><br><span class="line">    DWORD   Eip;</span><br><span class="line">    DWORD   SegCs;              <span class="comment">// MUST BE SANITIZED</span></span><br><span class="line">    DWORD   EFlags;             <span class="comment">// MUST BE SANITIZED</span></span><br><span class="line">    DWORD   Esp;</span><br><span class="line">    DWORD   SegSs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This section is specified/returned if the ContextFlags word</span></span><br><span class="line">    <span class="comment">// contains the flag CONTEXT_EXTENDED_REGISTERS.</span></span><br><span class="line">    <span class="comment">// The format and contexts are processor specific</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    BYTE    ExtendedRegisters[WOW64_MAXIMUM_SUPPORTED_EXTENSION];</span><br><span class="line"></span><br><span class="line">&#125; WOW64_CONTEXT;</span><br></pre></td></tr></table></figure>

<p>获取线程上下文</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">GetThreadContext</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE    hThread,<span class="comment">//线程句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCONTEXT lpContext<span class="comment">//[out]用于接受返回上下文结构体对象的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>设置线程上下文</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">SetThreadContext</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE        hThread,<span class="comment">//线程句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">const</span> CONTEXT *lpContext<span class="comment">//上下文结构体对象的指针，用于设置</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>单核多线程</strong>的实现原理就是保存当前线程上下文，读取待切换的线程的上下文，继续执行那个线程。</p>
<h2 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h2><p>每个线程都有自己的栈，而局部变量是存储在栈中的，这就意味着每个线程都有一份自己的“局部变量”，如果线程仅仅使用“局部变量”那么就不存在线程安全问题。</p>
<p>那如果多个线程共用一个全局变量（或者堆空间）呢？</p>
<p><strong>多线程修改同一个内存地址会产生线程安全问题</strong>！</p>
<p>单核多线程也是同样存在这个问题，因为cpu时间片随机分配，在线程回调函数的任意进行状态下，cpu都可能切换线程。即无法保证线程回调函数是一个整体接一个整体。下图表现出来就是cpu会执行图内上面的线程函数的某一句，就可能突然跳到图内下面的线程函数的某一句。</p>
<p>如下两个线程函数：全局变量存剩余票数</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210619181855365.png" alt="image-20210619181855365"></p>
<p>产生的问题如下：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210619182205646.png" alt="image-20210619182205646"></p>
<p>解决方法：</p>
<p>要使两个线程函数，必须某个线程函数执行完，另一个线程函数才可以开始执行。</p>
<p>我们把涉及多线程修改的变量设置为<strong>临界资源</strong></p>
<p>访问临界资源的那段代码称为<strong>临界区</strong></p>
<p><strong>临界区能保证，一次只能有一个线程执行临界区的代码（原子操作）</strong>。</p>
<p>原子操作：不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。</p>
<h3 id="临界区之线程锁的代码实现"><a href="#临界区之线程锁的代码实现" class="headerlink" title="临界区之线程锁的代码实现"></a>临界区之线程锁的代码实现</h3><p>线程锁是实现临界区的其中一种方式。</p>
<ol>
<li><p>创建全局结构体变量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CRITICAL_SECTION cs;<span class="comment">//可以把它理解成一个全局令牌，用于区分临界资源是否被占用。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化全局结构体变量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">InitializeCriticalSection</span>(&amp;cs);</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现临界区</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">EnterCriticalSection</span>(&amp;cs);</span><br><span class="line">	<span class="comment">//临界区</span></span><br><span class="line"><span class="built_in">LeaveCriticalSection</span>(&amp;cs);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>原理图：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210619190656121.png" alt="image-20210619190656121"></p>
<p>真正的原理如何实现的参考<strong>内核笔记</strong></p>
<h1 id="互斥体"><a href="#互斥体" class="headerlink" title="互斥体"></a>互斥体</h1><p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210619190048156.png" alt="image-20210619190048156"></p>
<p>内核级临界资源怎么办？</p>
<p>要既可以A进程中的X线程可以访问，又要进程b中的y线程可以访问，同时还必须线程安全</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210619190359223.png" alt="image-20210619190359223"></p>
<p>互斥体是内核对象。</p>
<p>互斥体就是类比于线程锁中的令牌，只是线程锁图中的令牌是应用层令牌，而互斥体是内核层令牌，所以可以实现跨进程访问。</p>
<h2 id="创建互斥体"><a href="#创建互斥体" class="headerlink" title="创建互斥体"></a>创建互斥体</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建和打开互斥体都是该函数</span></span><br><span class="line"><span class="function">HANDLE <span class="title">CreateMutexA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPSECURITY_ATTRIBUTES lpMutexAttributes,<span class="comment">//安全属性，表示是否可以被子进程继承句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">  BOOL                  bInitialOwner,<span class="comment">//初始有无信号，信号表示其他线程的wait是否会阻塞，无信号表示其他线程会阻塞，有信号表示其他线程不阻塞。true表示初始无信号即其他线程会阻塞，false表示初始有信号即其他线程不阻塞。；下面有详解</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR                lpName<span class="comment">//内核互斥体的名字，随便起的</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">HANDLE <span class="title">CreateMutexW</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPSECURITY_ATTRIBUTES lpMutexAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">  BOOL                  bInitialOwner,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCWSTR               lpName</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="bInitialOwner参数"><a href="#bInitialOwner参数" class="headerlink" title="bInitialOwner参数"></a>bInitialOwner参数</h3><p>互斥对象是一个内核对象，这个内核对象中有两个特殊的域，一个是用来保存哪个线程当前正拥有这个互斥对象，另一个域是一个递归计数器。当互斥对象的用来保存线程ID的域为0时，表示这个互斥对象没有被任何线程拥有，换句话说，任何一个进程中的线程调用wait函数时，都会马上返回，并将自己的线程ID设置到互斥对象的这个域当中和设置递归计数器的值为1，这时候，如果有其他的线程调用wait等待这个互斥对象时，那么这个线程就会被挂起，直到这个互斥对象用来保存线程ID的域为0时为止。这里面有一个特殊情况，就是，<strong>在调用wait函数等待互斥对象时，如果系统发现调用wait的线程ID和互斥对象中保存的线程ID相等，则会马上返回而不是挂起等待</strong>，这时候，返回的同时，系统会让互斥对象的递归计数器加1。</p>
<ol>
<li>若为TRUE，互斥器对象内部会<strong>记录创建它的线程的线程ID号</strong>并将递归计数设置为1，由于该线程ID非零，所以互斥器处于未触发状态，表示互斥器为创建线程拥有，此时Mutex的状态是无信号的，其他线程中的WaitForSingleObject都将堵塞。</li>
<li>若为FALSE，那么互斥量对象内部的线程ID号将设置为NULL，递归计数设置为0，这意味互斥器不为任何线程占用，处于触发状态。<br>也就是说，只有当递归计数为0时，该互斥器才属于触发状态，即：解锁。</li>
</ol>
<p>深入理解bInitialOwner参数：</p>
<blockquote>
<p>使用<code>bInitialOwner=TRUE</code> ，互斥锁创建者会自动获取互斥锁。 然后，当您调用<code>WaitForSingleObject</code> ，它<em>再次</em>获取了互斥锁。 由于win32互斥锁是递归互斥锁，因此每次获取互斥锁时都必须释放一次 - 因此初始创建者需要两次<code>ReleaseMutex</code>调用（但是每个其他线程只能释放一次！） </p>
<p> 您可以通过不使用<code>bInitialOwner</code>或通过跳过<em>第一个循环</em>上的<code>WaitForSingleObject</code>来避免这种<code>bInitialOwner</code> ，只有在<code>GetLastError() != ERROR_ALREADY_EXISTS</code>才有。 如果选择后者，则需要在<code>CreateMutex</code>之前调用<code>SetLastError(0)</code>来清除错误代码。 </p>
<p> 如果您只需要<code>bInitialOwner</code>进行某种初始设置，如果在进入公共循环之前删除互斥锁，它将简化您的代码。 否则，我强烈建议不要使用<code>bInitialOwner</code> ，除非你有令人信服的理由这样做。 </p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HANDLE hMutex = <span class="built_in">CreateMutex</span>(<span class="literal">NULL</span>, <span class="literal">false</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;1&quot;</span>));</span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(hMutex, INFINITE);</span><br><span class="line"><span class="comment">//上面两句代码与下面代码在创建时候是一样的，都会阻塞其他wait的线程；使用时候下面代码填true和false是没有意义的，含义都是打开互斥体</span></span><br><span class="line">HANDLE hMutex = <span class="built_in">CreateMutex</span>(<span class="literal">NULL</span>, <span class="literal">true</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;1&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>**销毁 当程序不再需要互斥锁时，要减少它的句柄使用计数让系统有机会摧毁他。 **</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CloseHandle</span>(hMutex);</span><br></pre></td></tr></table></figure>

<h3 id="互斥体方式实现临界区代码"><a href="#互斥体方式实现临界区代码" class="headerlink" title="互斥体方式实现临界区代码"></a><strong>互斥体方式实现临界区代码</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个互斥体</span></span><br><span class="line">HANDLE  g_hMutex=<span class="built_in">CreateMutex</span>(<span class="literal">NULL</span>,FALSE,<span class="string">&quot;XYZ&quot;</span>);</span><br><span class="line"><span class="comment">//获取令牌</span></span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(g_hMutex,INFINITE);</span><br><span class="line"><span class="comment">//这里面的代码实现原子操作===========</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;A进程的x线程：%d\n&quot;</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//=================================</span></span><br><span class="line"><span class="comment">//释放令牌</span></span><br><span class="line"><span class="built_in">ReleaseMutex</span>(g_hMutex);</span><br></pre></td></tr></table></figure>

<h3 id="互斥体实现临界区与线程锁实现临界区的区别"><a href="#互斥体实现临界区与线程锁实现临界区的区别" class="headerlink" title="互斥体实现临界区与线程锁实现临界区的区别"></a>互斥体实现临界区与线程锁实现临界区的区别</h3><ol>
<li>线程锁只能用于单个进程间的线程控制</li>
<li>互斥体可以设定等待超时，但线程锁不能</li>
<li>线程意外终结时，<strong>互斥体可以避免无限等待</strong></li>
<li>互斥体效率没有线程锁高（仅仅需要在一个进程控制原子操作的话还是用线程锁）</li>
</ol>
<p><strong>线程意外终结时会自动释放互斥体！</strong></p>
<h3 id="互斥体可以用于实现只能实例化一个进程"><a href="#互斥体可以用于实现只能实例化一个进程" class="headerlink" title="互斥体可以用于实现只能实例化一个进程"></a><strong>互斥体可以用于实现只能实例化一个进程</strong></h3><p>命名互斥锁 如果CreateMutex函数的第三个参数传入一个字符串，那么所创建的锁就是命名的。当一个命名的锁被创建出来以后，当前进程和其他进程如果试图创建相同名字的锁，CreateMutex会返回原来那把锁的句柄，并且GetLastError函数会返回ERROR_ALREADY_EXISTS。这个特点可以使一个程序在同一时刻最多运行一个实例。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个互斥体</span></span><br><span class="line">HANDLE hMutex=<span class="built_in">CreateMutexA</span>(<span class="literal">NULL</span>,FALSE,<span class="string">&quot;防止多开&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(hMutex)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">GetLastError</span>()==ERROR_ALREADY_EXISTS)<span class="comment">//代表之前已经存在了一个进程了</span></span><br><span class="line">	&#123;</span><br><span class="line">    	<span class="built_in">CloseHandle</span>(hMutex);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//程序创建失败</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hMutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//程序开始点</span></span><br></pre></td></tr></table></figure>

<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>内核对象，事件。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建或打开事件</span></span><br><span class="line"><span class="function">HANDLE <span class="title">CreateEventA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPSECURITY_ATTRIBUTES lpEventAttributes,<span class="comment">//安全属性</span></span></span></span><br><span class="line"><span class="params"><span class="function">  BOOL                  bManualReset,<span class="comment">//true表示通知类型，false表示互斥</span></span></span></span><br><span class="line"><span class="params"><span class="function">  BOOL                  bInitialState,<span class="comment">//false：初始没信号：wait会阻塞；true：初始有信号：wait会继续执行</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR                lpName<span class="comment">//给Event起个名字，方便跨进程打开</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">HANDLE <span class="title">CreateEventW</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPSECURITY_ATTRIBUTES lpEventAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">  BOOL                  bManualReset,</span></span></span><br><span class="line"><span class="params"><span class="function">  BOOL                  bInitialState,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCWSTR               lpName</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>两种事件对象（bManualReset）：</p>
<ol>
<li>true：该函数将创建一个手动重置事件对象，这需要使用 ResetEvent函数将事件状态设置为无信号。就是说只要调用了SetEvent函数就可以通过无数个wait</li>
<li>false：则该函数创建一个自动重置事件对象，系统会在释放单个等待线程后自动将事件状态重置为无信号状态。也就实现了互斥效果，SetEvent一次只能通过一个wait</li>
</ol>
<h2 id="设置事件有无信号"><a href="#设置事件有无信号" class="headerlink" title="设置事件有无信号"></a>设置事件有无信号</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SetEvent会让cpu分出去时间片（体现不是很直观）</span></span><br><span class="line"><span class="comment">//SetEvent后被唤醒的线程优先级被提升所以会先执行，执行完了它所应有的时间片之后，优先级会被降低，然后其他线程就有机会执行了。</span></span><br><span class="line"><span class="comment">//将指定的事件对象设置为有信号状态。有信号，就是通知其他线程wait可以解除阻塞了</span></span><br><span class="line"><span class="function">BOOL <span class="title">SetEvent</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE hEvent</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//将指定的事件对象设置为无信号状态</span></span><br><span class="line"><span class="function">BOOL <span class="title">ResetEvent</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE hEvent</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><ol>
<li>线程互斥</li>
<li>线程同步</li>
</ol>
<h3 id="线程互斥"><a href="#线程互斥" class="headerlink" title="线程互斥"></a>线程互斥</h3><p>对于共享的进程系统资源，在各单个线程访问时的排他性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其他要使用该资源的线程必须等待，直到占用资源者释放该资源。</p>
<h3 id="线程同步-1"><a href="#线程同步-1" class="headerlink" title="线程同步"></a>线程同步</h3><p>线程之间所具有的一种制约关系，一个线程的执行依赖另一个线程的消息，当没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒<br>$$<br>同步&#x3D;互斥+有序<br>$$</p>
<h3 id="伪同步与真同步的区别（重点）"><a href="#伪同步与真同步的区别（重点）" class="headerlink" title="伪同步与真同步的区别（重点）"></a><strong>伪同步与真同步的区别（重点）</strong></h3><p>经典案例：生产者与消费者案例：通过以下代码也能实现伪同步</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生产者与消费者真同步案例(互斥体实现)</span></span><br><span class="line"><span class="type">int</span> g_time = <span class="number">10</span>;<span class="comment">//生产10次</span></span><br><span class="line"><span class="type">int</span> g_Number = <span class="number">0</span>;<span class="comment">//生产者将他置1表示生产成功，消费者将他置0表示消费掉了。</span></span><br><span class="line">HANDLE g_hMutex=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread1</span><span class="params">()</span><span class="comment">//生产者</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> current = <span class="number">0</span>;<span class="comment">//当前生产个数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g_time; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">WaitForSingleObject</span>(g_hMutex, INFINITE);<span class="comment">//互斥区</span></span><br><span class="line">		<span class="keyword">if</span> (g_Number==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			g_Number = <span class="number">1</span>;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;生产者线程生产第%d个\r\n&quot;</span>,++current);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;==============\r\n&quot;</span>);<span class="comment">//1处</span></span><br><span class="line">			i--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">ReleaseMutex</span>(g_hMutex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread2</span><span class="params">()</span><span class="comment">//消费者</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> current = <span class="number">0</span>;<span class="comment">//当前消费个数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g_time; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">WaitForSingleObject</span>(g_hMutex, INFINITE);<span class="comment">//互斥区</span></span><br><span class="line">		<span class="keyword">if</span> (g_Number == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			g_Number=<span class="number">0</span>;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;消费者线程消费第%d个\r\n&quot;</span>, ++current);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;==============\r\n&quot;</span>);<span class="comment">//2处</span></span><br><span class="line">			i--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">ReleaseMutex</span>(g_hMutex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	g_hMutex = <span class="built_in">CreateMutex</span>(<span class="literal">NULL</span>, <span class="literal">false</span>, <span class="literal">NULL</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;g_hMutex：&quot;</span> &lt;&lt; g_hMutex &lt;&lt; endl;</span><br><span class="line">	HANDLE threadHandleArray[<span class="number">2</span>];</span><br><span class="line">	threadHandleArray[<span class="number">0</span>] = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)thread1, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	threadHandleArray[<span class="number">1</span>] = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)thread2, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">WaitForMultipleObjects</span>(<span class="number">2</span>, threadHandleArray, <span class="literal">true</span>, INFINITE);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;测试结束\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210623173443224.png" alt="image-20210623173443224"></p>
<p>但其实并非真同步，只是显示出来是同步。实际上损耗了cpu很多性能（消耗了更多cpu时间片），上面代码1处和2处会打印很多&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;，之所以没打印可能是新系统优化好了。但要真正实现同步还是不能靠上面代码，而应该是下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生产者与消费者真同步案例(事件实现)</span></span><br><span class="line"><span class="type">int</span> g_time = <span class="number">10</span>;<span class="comment">//生产10次</span></span><br><span class="line"><span class="type">int</span> g_Number = <span class="number">0</span>;<span class="comment">//生产者将他置1表示生产成功，消费者将他置0表示消费掉了。</span></span><br><span class="line">HANDLE g_hEvent =<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread1</span><span class="params">()</span><span class="comment">//生产者</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> current = <span class="number">0</span>;<span class="comment">//当前生产个数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g_time; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">WaitForSingleObject</span>(g_hEvent, INFINITE);<span class="comment">//互斥区</span></span><br><span class="line">		<span class="keyword">if</span> (g_Number == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			g_Number = <span class="number">1</span>;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;生产者线程生产第%d个\r\n&quot;</span>, ++current);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;==============\r\n&quot;</span>);</span><br><span class="line">			i--;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//其实真同步直接用下面代码顶替上面if else就可以了。</span></span><br><span class="line">		<span class="comment">/*g_Number = 1;</span></span><br><span class="line"><span class="comment">		printf(&quot;生产者线程生产第%d个\r\n&quot;, ++current);*/</span></span><br><span class="line">		<span class="built_in">SetEvent</span>(g_hEvent);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread2</span><span class="params">()</span><span class="comment">//消费者</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> current = <span class="number">0</span>;<span class="comment">//当前消费个数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g_time; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">WaitForSingleObject</span>(g_hEvent, INFINITE);<span class="comment">//互斥区</span></span><br><span class="line">		<span class="keyword">if</span> (g_Number == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			g_Number=<span class="number">0</span>;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;消费者线程消费第%d个\r\n&quot;</span>, ++current);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;==============\r\n&quot;</span>);</span><br><span class="line">			i--;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//其实真同步直接用下面代码顶替上面if else就可以了。</span></span><br><span class="line">		<span class="comment">/*g_Number = 0;</span></span><br><span class="line"><span class="comment">		printf(&quot;消费者线程消费第%d个\r\n&quot;, ++current);*/</span></span><br><span class="line">		<span class="built_in">SetEvent</span>(g_hEvent);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	g_hEvent = <span class="built_in">CreateEvent</span>(<span class="literal">NULL</span>, <span class="literal">false</span>,<span class="literal">true</span>,<span class="literal">NULL</span>);</span><br><span class="line">	HANDLE threadHandleArray[<span class="number">2</span>];</span><br><span class="line">	threadHandleArray[<span class="number">0</span>] = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)thread1, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	threadHandleArray[<span class="number">1</span>] = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)thread2, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">WaitForMultipleObjects</span>(<span class="number">2</span>, threadHandleArray, <span class="literal">true</span>, INFINITE);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;测试结束\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210623175414083.png" alt="image-20210623175414083"></p>
<p>虽然结果都一样，但使用事件的才是真同步！</p>
<p>正是因为SetEvent后被唤醒的线程优先级会被提升，所以事件才能保证执行顺序，而互斥体ReleaseMutex后可能下次cpu时间片还是分到当前线程执行。</p>
<p>【总结】<strong>互斥体无法实现真正的同步，事件才可以实现真正的同步</strong>。</p>
<h1 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h1><p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210623183240740.png" alt="image-20210623183240740"></p>
<p>高2G是内核空间，多进程公用，里面有很多系统模块。</p>
<p>其中和窗口最相关的主要是两个系统模块：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210623183337829.png" alt="image-20210623183337829"></p>
<p>kernel32.dll只是一个接口，它真正调用的是ntoskrnl.exe的模块，user32.dll和gdi32.dll也只是win32k.sys的内核模块的接口</p>
<p>GUI 图形用户接口 就是使用user32.dll 表示使用别人已经绘制好的组件。</p>
<p>GDI 图形设备接口  就是使用gdi32.dll 表示自己绘制。</p>
<h2 id="HWND窗口句柄"><a href="#HWND窗口句柄" class="headerlink" title="HWND窗口句柄"></a>HWND窗口句柄</h2><p>HWND是窗口的句柄</p>
<p>并且HWND是<strong>全局</strong>的索引</p>
<p>桌面的窗口句柄是NULL。</p>
<p>获取窗口句柄的方法有三种</p>
<ul>
<li>使用FindWindow函数获取指定窗口句柄</li>
<li>获取所有顶层窗口以及它们的子窗口<ul>
<li>使用<code>EnumWindows</code>和<code>EnumChildWindows</code>函数以及相对的回调函数<code>EnumWindowsProc</code>和<code>EnumChildWindowsProc</code>获取所有顶层窗口以及它们的子窗口</li>
<li>使用<code>GetDesktopWindow</code>和<code>GetNextWindow</code>函数得到所有的子窗口</li>
</ul>
</li>
</ul>
<p>获取窗口句柄代码如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">HWND <span class="title function_">findWindowOneByOne</span><span class="params">(<span class="type">char</span>* windowName)</span></span><br><span class="line">&#123;</span><br><span class="line">	HWND hd = GetDesktopWindow();        <span class="comment">//得到桌面窗口</span></span><br><span class="line">	hd = GetWindow(hd, GW_CHILD);        <span class="comment">//得到屏幕上第一个子窗口</span></span><br><span class="line">	<span class="type">char</span> s[<span class="number">200</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (hd != <span class="literal">NULL</span>)                    <span class="comment">//循环得到所有的子窗口</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">200</span>);</span><br><span class="line">		GetWindowText(hd, s, <span class="number">200</span>);</span><br><span class="line">		<span class="comment">//cout &lt;&lt; num++ &lt;&lt; &quot;: &quot; &lt;&lt; s &lt;&lt;&quot;: &quot;&lt;&lt;hd &lt;&lt; endl;//遍历打印所有标题和窗口句柄</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(s, windowName) == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> hd;</span><br><span class="line">		hd = GetNextWindow(hd, GW_HWNDNEXT);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="GDI-图形设备接口"><a href="#GDI-图形设备接口" class="headerlink" title="GDI  图形设备接口"></a>GDI  图形设备接口</h2><p>Graphics Device Interface</p>
<ol>
<li>设备对象（HWID）</li>
<li>DC（设备上下文，Device Contexts）</li>
<li>图形对象</li>
</ol>
<table>
<thead>
<tr>
<th>图像对象</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>画笔（Pen）</td>
<td>影响线条，包括颜色，粗细，虚实，箭头形状等</td>
</tr>
<tr>
<td>画刷（Brushes）</td>
<td>影响对形状，区域等操作，如使用的颜色，是否有阴影等</td>
</tr>
<tr>
<td>字体（Fonts）</td>
<td>影响文字输出的字体</td>
</tr>
<tr>
<td>位图（Bitmaps）</td>
<td>影响位图创建，位图操作和保存等</td>
</tr>
</tbody></table>
<p>我们绘图的时候，首先是在设备上下文画的，就是一块内存，然后把内存中画好的形状直接打印到设备对象上，也就是窗口句柄上。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">HWND hwnd;</span><br><span class="line">HDC hdc;<span class="comment">//设备上下文的句柄</span></span><br><span class="line">HPEN hpen;<span class="comment">//画笔句柄</span></span><br><span class="line">HBRUSH hBrush;<span class="comment">//画刷句柄</span></span><br><span class="line"><span class="comment">//===设备对象，画在哪</span></span><br><span class="line">hwnd=(HWND)<span class="number">0x000E0244</span>;<span class="comment">//某窗口句柄</span></span><br><span class="line"><span class="comment">//===获取设备对象上下文 DC</span></span><br><span class="line">hdc=<span class="built_in">GetDC</span>(hwnd);</span><br><span class="line"><span class="comment">//===图形对象，画什么,画线，所以使用Pen,PS_SOLID实线,线的宽度为5,颜色为RGB(0xFF,00,00),RGB是个宏</span></span><br><span class="line">hpen=<span class="built_in">CreatePen</span>(PS_SOLID,<span class="number">5</span>,<span class="built_in">RGB</span>(<span class="number">0xFF</span>,<span class="number">00</span>,<span class="number">00</span>));</span><br><span class="line"><span class="comment">//直接用系统提供的其他画刷</span></span><br><span class="line">hBrush=(HBRUSH)<span class="built_in">GetStockObject</span>(DC_BRUSH);</span><br><span class="line"><span class="comment">//===关联图形对象和设备上下文,如果不关联，调用的是默认的笔，每种图像对象都存在对应的默认款。</span></span><br><span class="line"><span class="comment">//===SelectObject返回的是原来默认的图像对象的句柄</span></span><br><span class="line"><span class="built_in">SelectObject</span>(hdc,hpen);</span><br><span class="line"><span class="comment">//关联画刷</span></span><br><span class="line"><span class="built_in">SelectObject</span>(hdc,hBrush);</span><br><span class="line"><span class="comment">//===实际的绘制操作</span></span><br><span class="line"><span class="comment">//画线  从哪画到哪</span></span><br><span class="line"><span class="built_in">MoveToEx</span>(hdc,<span class="number">0</span>,<span class="number">400</span>,<span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">LineTo</span>(hdc,<span class="number">400</span>,<span class="number">400</span>);</span><br><span class="line"><span class="comment">//DC_BRUSH可以通过下面函数设置颜色</span></span><br><span class="line"><span class="built_in">SetDCBrushColor</span>(hdc,<span class="built_in">RGB</span>(<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">00</span>));</span><br><span class="line"><span class="comment">//画矩形</span></span><br><span class="line"><span class="built_in">Rectangle</span>(hdc,<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line"><span class="comment">//===释放资源</span></span><br><span class="line"><span class="built_in">DeleteObject</span>(hpen);</span><br><span class="line"><span class="built_in">DeleteObject</span>(hBrush);<span class="comment">//GetStockObject获得的图像对象可以不用删，但删了也没坏处</span></span><br><span class="line"><span class="built_in">ReleaseDC</span>(hwnd,hdc);</span><br><span class="line"><span class="comment">//get对象release  create对象delete</span></span><br></pre></td></tr></table></figure>

<p>上面H开头的类型全是句柄，所谓句柄就是隔离用户层和内核层的工具，其真正所在都在零环。</p>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><ul>
<li>Q：什么是消息？</li>
<li>A：当我们点击鼠标的时候，或者当我们按下键盘的时候，操作系统都要把这些动作记录下来，存储到一个结构体中，这个结构体就是<strong>消息</strong>。</li>
</ul>
<p>每个窗口都是在内核层有一个结构体记录了一切信息，供操作系统索引。</p>
<p><strong>每个线程只有一个消息队列</strong></p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210627131449985.png" alt="image-20210627131449985"></p>
<p>操作系统先捕获到我们的键盘鼠标操作，然后<strong>根据每个窗口在内核的结构体中的信息，找到对应窗口的对应负责消息队列的线程，将消息放进他的消息队列</strong>。</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210627132533158.png" alt="image-20210627132533158"></p>
<p>窗口对象中有个成员记录了负责消息队列的线程的指针。</p>
<ul>
<li>一个线程可以有很多个窗口，多个窗口共用一个消息队列线程。</li>
<li>每个窗口只属于一个线程</li>
</ul>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210627133328265.png" alt="image-20210627133328265"></p>
<p>红线是操作系统分发消息的过程。键盘，鼠标，内核程序的操作被操作系统捕获，封装成消息结构体，根据消息针对的窗口的对象找到对应的消息队列线程，将消息放进对应消息队列线程的消息队列</p>
<h2 id="第一个windows窗口程序"><a href="#第一个windows窗口程序" class="headerlink" title="第一个windows窗口程序"></a>第一个windows窗口程序</h2><p>控制台程序的默认入口是main，windows程序的默认入口是WinMain</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> WINAPI <span class="title">WinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	HINSTANCE hInstance,<span class="comment">//当前模块句柄（实际上就是当前模块在内存中的位置）</span></span></span></span><br><span class="line"><span class="params"><span class="function">	HINSTANCE hPrevInstance,<span class="comment">// 没有任何意义。 它用于16位 Windows，但现在始终为零。</span></span></span></span><br><span class="line"><span class="params"><span class="function">	LPSTR lpCmdLine,<span class="comment">//命令行参数，由CreateProcess的lpCommandLine参数决定</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">int</span> nCmdShow<span class="comment">//是一个标志，用于指示主应用程序窗口是最小化、最大化还是正常显示。由CreateProcess的lpStartupInfo中的显示状态决定</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//第一步：定义你的窗口是什么样的，并注册窗口类</span></span><br><span class="line">    TCHAR className[]=<span class="built_in">TEXT</span>(<span class="string">&quot;My First Window&quot;</span>);</span><br><span class="line">    WNDCLASS wndclass=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    wndclass.hbrBackground=(HBRUSH)COLOR_BACKGROUND;</span><br><span class="line">    wndclass.lpszClassName=className;</span><br><span class="line">    wndclass.hInstance=hInstance;</span><br><span class="line">    wndclass.lpfnWndProc=myWindowProc;<span class="comment">//窗口程序回调函数名</span></span><br><span class="line">    <span class="built_in">RegisterClass</span>(&amp;wndclass);<span class="comment">//注册窗口类，把这个封装好的类给操作系统</span></span><br><span class="line">    <span class="comment">//第二步，创建并显示窗口</span></span><br><span class="line">    HWND hwnd=<span class="built_in">CreateWindow</span>(className,<span class="built_in">TEXT</span>(<span class="string">&quot;我的第一个窗口&quot;</span>),WS_OVERLAPPEDWINDOW,<span class="number">10</span>,<span class="number">10</span>,<span class="number">600</span>,<span class="number">300</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,hInstance,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(hwnd==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> szOutBuff[<span class="number">0x80</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(szOutBuff,<span class="string">&quot;Error:%d&quot;</span>,<span class="built_in">GetLastError</span>());<span class="comment">//格式化字符串</span></span><br><span class="line">		<span class="built_in">OutputDebugString</span>(szOutBuff);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ShowWindow</span>(hwnd,SW_SHOW);</span><br><span class="line">    <span class="comment">//第三部,接受消息并处理</span></span><br><span class="line">    MSG msg;</span><br><span class="line">    <span class="type">bool</span> bRet;</span><br><span class="line">    <span class="keyword">while</span>((bRet=<span class="built_in">GetMessage</span>(&amp;msg,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>))!=<span class="number">0</span>)<span class="comment">//循环从消息队列获取消息</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(bRet==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//出问题了</span></span><br><span class="line">            <span class="type">char</span> szOutBuff[<span class="number">0x80</span>];</span><br><span class="line">		   <span class="built_in">sprintf</span>(szOutBuff,<span class="string">&quot;Error:%d&quot;</span>,<span class="built_in">GetLastError</span>());<span class="comment">//格式化字符串</span></span><br><span class="line">		    <span class="built_in">OutputDebugString</span>(szOutBuff);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">TranslateMessage</span>(&amp;msg);<span class="comment">//转换消息，针对WM_CHAR消息</span></span><br><span class="line">            <span class="built_in">DispatchMessage</span>(&amp;msg);<span class="comment">//分发消息，该函数就是为了调用消息处理函数，每个窗口都有对应的消息处理函数</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【总结】</strong></p>
<ol>
<li>先定义窗口类，指明了窗口是怎么样的，窗口的回调函数是谁。</li>
<li>创建窗口，该函数在内核层创建真正的窗口对象，并且在该线程内核对象创建消息队列</li>
<li>线程循环从消息队列中取消息进行处理，分发给对应的窗口回调函数。</li>
</ol>
<p>做完上述操作后，若操作系统捕获到用户输入，将其封装成消息，根据用户输入的窗口对象找到对应的消息队列线程对象，将消息放到其消息队列中。当线程调用DispatchMessage,操作系统拿着MSG结构体中的HWND找到窗口对象，由操作系统调用对应窗口对象的回调函数。</p>
<p><code>下面有上面代码中函数的详解</code></p>
<h3 id="WNDCLASS结构体"><a href="#WNDCLASS结构体" class="headerlink" title="WNDCLASS结构体"></a>WNDCLASS结构体</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//告诉我们要创建的窗口是怎么样的</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">tagWNDCLASSA</span> &#123;</span><br><span class="line">    UINT        style;</span><br><span class="line">    WNDPROC     lpfnWndProc;<span class="comment">//窗口程序,处理各种消息。</span></span><br><span class="line">    <span class="type">int</span>         cbClsExtra;</span><br><span class="line">    <span class="type">int</span>         cbWndExtra;</span><br><span class="line">    HINSTANCE   hInstance;<span class="comment">//这个窗口是属于哪个模块的，往往是属于自己模块的，所以填WinMain传进来的hInstance</span></span><br><span class="line">    HICON       hIcon;</span><br><span class="line">    HCURSOR     hCursor;</span><br><span class="line">    HBRUSH      hbrBackground;<span class="comment">//背景色,类型是画刷类型</span></span><br><span class="line">    LPCSTR      lpszMenuName;</span><br><span class="line">    LPCSTR      lpszClassName;<span class="comment">//窗口类名</span></span><br><span class="line">&#125; WNDCLASSA, *PWNDCLASSA, NEAR *NPWNDCLASSA, FAR *LPWNDCLASSA;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">tagWNDCLASSW</span> &#123;</span><br><span class="line">    UINT        style;</span><br><span class="line">    WNDPROC     lpfnWndProc;</span><br><span class="line">    <span class="type">int</span>         cbClsExtra;</span><br><span class="line">    <span class="type">int</span>         cbWndExtra;</span><br><span class="line">    HINSTANCE   hInstance;</span><br><span class="line">    HICON       hIcon;</span><br><span class="line">    HCURSOR     hCursor;</span><br><span class="line">    HBRUSH      hbrBackground;</span><br><span class="line">    LPCWSTR     lpszMenuName;</span><br><span class="line">    LPCWSTR     lpszClassName;</span><br><span class="line">&#125; WNDCLASSW, *PWNDCLASSW, NEAR *NPWNDCLASSW, FAR *LPWNDCLASSW;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="lpfnWndProc成员（窗口函数）"><a href="#lpfnWndProc成员（窗口函数）" class="headerlink" title="lpfnWndProc成员（窗口函数）"></a>lpfnWndProc成员（窗口函数）</h4><p>处理发送到窗口的消息的应用程序定义的回调函数，格式如下：(函数名可以随便改)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">myWindowProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_ HWND   hwnd,</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_ UINT   uMsg,</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_ WPARAM wParam,</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_ LPARAM lParam</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hwnd,uMsg,wParam,lParam);<span class="comment">//就算你什么也不想做，也要调用默认的消息处理函数,因为系统已经做好了很多基本的消息处理代码，比如说放大窗口，移动窗口等等。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>窗口回调函数实际上是由操作系统发起调用</strong></p>
<h3 id="CreateWindow创建窗口函数"><a href="#CreateWindow创建窗口函数" class="headerlink" title="CreateWindow创建窗口函数"></a>CreateWindow创建窗口函数</h3><p>创建重叠窗口、弹出窗口或子窗口。它指定窗口类、窗口标题、窗口样式和（可选）窗口的初始位置和大小。该函数还指定窗口的父级或所有者（如果有）以及窗口的菜单。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建窗口成功返回窗口句柄;失败返回NULL。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateWindowA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">   lpClassName,<span class="comment">//类名,创建窗口的时候操作系统就是通过calssName关联起来该窗口的WNDCLASS结构体的</span></span></span></span><br><span class="line"><span class="params"><span class="function">   lpWindowName,<span class="comment">//窗口名</span></span></span></span><br><span class="line"><span class="params"><span class="function">   dwStyle,<span class="comment">//窗口样式（很多种样式，每种样式又有很多子样式组成）</span></span></span></span><br><span class="line"><span class="params"><span class="function">   x,<span class="comment">//相对于父窗口的x坐标（像素单位）</span></span></span></span><br><span class="line"><span class="params"><span class="function">   y,<span class="comment">//相对于父窗口的y坐标（像素单位）</span></span></span></span><br><span class="line"><span class="params"><span class="function">   nWidth,<span class="comment">//窗口宽度（像素单位）</span></span></span></span><br><span class="line"><span class="params"><span class="function">   nHeight,<span class="comment">//窗口高度（像素单位）</span></span></span></span><br><span class="line"><span class="params"><span class="function">   hWndParent,<span class="comment">//父窗口句柄，没有填空</span></span></span></span><br><span class="line"><span class="params"><span class="function">   hMenu,<span class="comment">//若是该窗口是父窗口，该参数表示菜单句柄，没有的话填空；若创建的是子窗口，表示子窗口的id标识编号</span></span></span></span><br><span class="line"><span class="params"><span class="function">   hInstance,<span class="comment">//当前应用程序的句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">   lpParam<span class="comment">//附加数据</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateWindowW</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">   lpClassName,</span></span></span><br><span class="line"><span class="params"><span class="function">   lpWindowName,</span></span></span><br><span class="line"><span class="params"><span class="function">   dwStyle,</span></span></span><br><span class="line"><span class="params"><span class="function">   x,</span></span></span><br><span class="line"><span class="params"><span class="function">   y,</span></span></span><br><span class="line"><span class="params"><span class="function">   nWidth,</span></span></span><br><span class="line"><span class="params"><span class="function">   nHeight,</span></span></span><br><span class="line"><span class="params"><span class="function">   hWndParent,</span></span></span><br><span class="line"><span class="params"><span class="function">   hMenu,</span></span></span><br><span class="line"><span class="params"><span class="function">   hInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">   lpParam</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>只要线程调用创建窗口函数，就会有消息队列</strong></p>
<h3 id="ShowWindow显示窗口函数"><a href="#ShowWindow显示窗口函数" class="headerlink" title="ShowWindow显示窗口函数"></a>ShowWindow显示窗口函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">ShowWindow</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HWND hWnd,<span class="comment">//显示窗口的窗口句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">int</span>  nCmdShow<span class="comment">//以什么形式显示(例如：最大化等等)</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="GetMessage函数"><a href="#GetMessage函数" class="headerlink" title="GetMessage函数"></a>GetMessage函数</h3><p><strong>取消息队列中的消息的函数，若消息队列中没有消息他会阻塞直到有消息才继续执行</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果函数检索WM_QUIT以外的消息，则返回值非零。</span></span><br><span class="line"><span class="comment">//如果该函数检索WM_QUIT消息，则返回值为零。</span></span><br><span class="line"><span class="comment">//如果有错误，返回值为-1。例如，如果hWnd是无效的窗口句柄或lpMsg是无效的指针，则该函数将失败。要获取扩展错误信息，请调用GetLastError。</span></span><br><span class="line"><span class="function">BOOL <span class="title">GetMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPMSG lpMsg,<span class="comment">//从消息队列中取出的消息存放的位置</span></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="comment">//后三个参数全是过滤消息的条件，因为一个消息队列线程同时有多个窗口</span></span></span></span><br><span class="line"><span class="params"><span class="function">  HWND  hWnd,<span class="comment">//针对哪个窗口</span></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="comment">//下面两个表示针对不同类型的消息不一样，比如键盘鼠标等</span></span></span></span><br><span class="line"><span class="params"><span class="function">  UINT  wMsgFilterMin,<span class="comment">//0表示我全要</span></span></span></span><br><span class="line"><span class="params"><span class="function">  UINT  wMsgFilterMax<span class="comment">//0表示我全要</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="DispatchMessage分发消息函数"><a href="#DispatchMessage分发消息函数" class="headerlink" title="DispatchMessage分发消息函数"></a>DispatchMessage分发消息函数</h3><p>由于每个窗口都有对应的消息处理函数，该函数就是为了让操作系统调用对应窗口的消息处理函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//含义取决于正在调度的消息，通常会忽略返回值</span></span><br><span class="line"><span class="function">LRESULT <span class="title">DispatchMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">const</span> MSG *lpMsg</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210627141039758.png" alt="image-20210627141039758"></p>
<p><code>消息结构中有窗口HWND，下面有MSG结构体详解</code></p>
<h3 id="TranslateMessage转换消息函数"><a href="#TranslateMessage转换消息函数" class="headerlink" title="TranslateMessage转换消息函数"></a>TranslateMessage转换消息函数</h3><p>将虚拟键消息转换为字符消息。字符消息被发送到调用线程的消息队列，以便在线程下次调用<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-getmessage">GetMessage</a>或<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-peekmessagea">PeekMessage</a>函数时读取。</p>
<p>写了TranslateMessage函数能转换出WM_CHAR这样的消息。不写TranslateMessage，按下键盘的时候不存在WM_CHAR这样的消息。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果消息被翻译（即，一个字符消息被发送到线程的消息队列），则返回值非零。</span></span><br><span class="line"><span class="comment">//如果消息未翻译（即字符消息未发送到线程的消息队列），则返回值为零。</span></span><br><span class="line"><span class="function">BOOL <span class="title">TranslateMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">const</span> MSG *lpMsg</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>WM_CHAR的wParam参数直接为键盘的字符</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//窗口回调函数中如下代码：</span></span><br><span class="line"><span class="keyword">case</span> WM_KEYDOWN:</span><br><span class="line">	<span class="built_in">OutputDebugStringA</span>(<span class="string">&quot;WM_KEYDOWN&quot;</span>);</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WM_KEYUP:</span><br><span class="line">	<span class="built_in">OutputDebugStringA</span>(<span class="string">&quot;WM_KEYUP&quot;</span>);</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WM_CHAR:</span><br><span class="line">	<span class="type">char</span> szOutBuff[<span class="number">0x80</span>];</span><br><span class="line">	<span class="built_in">sprintf</span>(szOutBuff, <span class="string">&quot;%c&quot;</span>, wParam);<span class="comment">//格式化字符串</span></span><br><span class="line">	<span class="built_in">OutputDebugStringA</span>(szOutBuff);</span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>有TranslateMessage的情况</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210627151302111.png" alt="image-20210627151302111"></p>
<p>无TranslateMessage的情况</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210627151210561.png" alt="image-20210627151210561"></p>
<h3 id="windows程序调试信息的输出"><a href="#windows程序调试信息的输出" class="headerlink" title="windows程序调试信息的输出"></a>windows程序调试信息的输出</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> szOutBuff[<span class="number">0x80</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(szOutBuff,<span class="string">&quot;Error:%d&quot;</span>,<span class="built_in">GetLastError</span>());<span class="comment">//格式化字符串</span></span><br><span class="line"><span class="built_in">OutputDebugStringA</span>(szOutBuff);</span><br></pre></td></tr></table></figure>

<h3 id="MSG结构体"><a href="#MSG结构体" class="headerlink" title="MSG结构体"></a>MSG结构体</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">tagMSG</span> &#123;</span><br><span class="line">  HWND   hwnd;<span class="comment">//窗口句柄</span></span><br><span class="line">  UINT   message;<span class="comment">//消息类型的编号，用于标识消息是什么类型的</span></span><br><span class="line">  <span class="comment">//下面两个参数存储消息具体的内容，比如说怎么操作了哪个键位。</span></span><br><span class="line">  WPARAM wParam;</span><br><span class="line">  LPARAM lParam;</span><br><span class="line">  DWORD  time;<span class="comment">//消息产生的时间</span></span><br><span class="line">  POINT  pt;<span class="comment">//point发布消息时的光标位置，以屏幕坐标表示。</span></span><br><span class="line">  DWORD  lPrivate;</span><br><span class="line">&#125; MSG, *PMSG, *NPMSG, *LPMSG;</span><br></pre></td></tr></table></figure>

<p><strong>hwnd，message，wParam，lParam这四个参数就是操作系统调用窗口回调函数的时候会给你传进来的参数。</strong>在窗口回调函数中可以针对性的进行处理</p>
<p>WINDOWS提供了编号的宏，message参数用于判断消息类型,罗列几个出来，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Window Messages</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WM_NULL                         0x0000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WM_CREATE                       0x0001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WM_DESTROY                      0x0002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WM_MOVE                         0x0003</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WM_SIZE                         0x0005</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WM_ACTIVATE                     0x0006</span></span><br></pre></td></tr></table></figure>

<p>在微软官方在线开发者手册，可以搜索信息名，比如WM_KEYDOWM可以查到wParam和lParam的具体含义。</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210627144328602.png" alt="image-20210627144328602"></p>
<h2 id="子窗口"><a href="#子窗口" class="headerlink" title="子窗口"></a>子窗口</h2><ol>
<li>WINDOWS提供了几个预定义的窗口类以方便我们的使用，我们一般把它们叫做子窗口控件，简称控件</li>
<li>控件会自己处理消息，并在自己状态发生改变时通知父窗口</li>
<li>预定义的控件有：按钮，复选框，编辑框，静态字符串标签和滚动条等。（还有些通用控件，需要自己安装模块）</li>
</ol>
<p>父窗口的消息处理回调函数中可以直接处理子窗口穿过来的消息。</p>
<p>实际项目中因为win32窗口不好看，很少有直接用win32来开发界面的。</p>
<p>定义子窗口不需要写WNDCLASS结构体和注册窗口类。</p>
<h3 id="创建子窗口"><a href="#创建子窗口" class="headerlink" title="创建子窗口"></a>创建子窗口</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建文本框,可以写到窗口过程处理函数的WM_CREATE信息下，创建好父窗口后就创建子窗口</span></span><br><span class="line"><span class="built_in">CreatWindow</span>(</span><br><span class="line">    <span class="string">&quot;EDIT&quot;</span>,</span><br><span class="line">    <span class="string">&quot;&quot;</span>,<span class="comment">//编辑子窗口这里是空就可以了</span></span><br><span class="line">    WS_CHILD|WS_VISIBLE|WS_VSCROLL|ES_MULTILINE,<span class="comment">//WS_CHILD必须有表示子窗口;WS_VISIBLE表示初始就是可见状态;WS_VSCROLL表示带滚动条的;ES_MULTILINEL是编辑框的特有属性，表示支持多行编辑</span></span><br><span class="line">    <span class="number">10</span>,<span class="comment">//离父窗口左上角向右偏移10像素</span></span><br><span class="line">    <span class="number">10</span>,<span class="comment">//离父窗口左上角向下偏移10像素</span></span><br><span class="line">    <span class="number">500</span>,<span class="comment">//子窗口宽500像素</span></span><br><span class="line">    <span class="number">300</span>,<span class="comment">//子窗口高300像素</span></span><br><span class="line">    hWnd,<span class="comment">//父窗口的窗口句柄</span></span><br><span class="line">    (HMENU)<span class="number">1</span>,<span class="comment">//子窗口的标识编号</span></span><br><span class="line">    hInst,<span class="comment">//当前窗口属于哪个程序</span></span><br><span class="line">    <span class="literal">NULL</span><span class="comment">//附加数据</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">//按钮子控件</span></span><br><span class="line"><span class="built_in">CreatWindow</span>(</span><br><span class="line">    <span class="string">&quot;BUTTON&quot;</span>,</span><br><span class="line">    <span class="string">&quot;设置&quot;</span>,<span class="comment">//按钮子窗口这里代表按钮里的文本</span></span><br><span class="line">    WS_CHILD|WS_VISIBLE,</span><br><span class="line">    <span class="number">520</span>,<span class="comment">//离父窗口左上角向右偏移520像素</span></span><br><span class="line">    <span class="number">180</span>,<span class="comment">//离父窗口左上角向下偏移180像素</span></span><br><span class="line">    <span class="number">60</span>,<span class="comment">//子窗口宽60像素</span></span><br><span class="line">    <span class="number">30</span>,<span class="comment">//子窗口高30像素</span></span><br><span class="line">    hWnd,<span class="comment">//父窗口的窗口句柄</span></span><br><span class="line">    (HMENU)<span class="number">2</span>,<span class="comment">//子窗口的标识编号</span></span><br><span class="line">    hInst,<span class="comment">//当前窗口属于哪个程序</span></span><br><span class="line">    <span class="literal">NULL</span><span class="comment">//附加数据</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">//按钮控件点击给父窗口传的是WM_COMMAND消息，他的wParam的低16位表示子窗口的标识编号可以区分是哪个控件的消息。</span></span><br><span class="line"><span class="comment">//p.s.LOWORD()宏可以直接获得DWORD的低16位。</span></span><br></pre></td></tr></table></figure>

<p>如何查特殊样式</p>
<p>微软在线开发者手册CreatWindow函数详解页中的dwStyle参数罗列了所有的通用样式属性。但是还有特有样式属性，这种特有的样式属性要针对子控件去找。比如说要找编辑框的特有样式属性就搜索<strong>Edit Control Styles</strong>。</p>
<h3 id="SeTDlgItemText函数"><a href="#SeTDlgItemText函数" class="headerlink" title="SeTDlgItemText函数"></a>SeTDlgItemText函数</h3><p>  设置控件的标题或文本</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">SetDlgItemTextA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HWND   hDlg,<span class="comment">//子窗口句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">int</span>    nIDDlgItem,<span class="comment">//子窗口标识编号</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR lpString<span class="comment">//设置的文本</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">SetDlgItemTextW</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HWND    hDlg,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">int</span>     nIDDlgItem,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCWSTR lpString</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>



<h1 id="内存相关"><a href="#内存相关" class="headerlink" title="内存相关"></a>内存相关</h1><h2 id="虚拟内存与物理内存"><a href="#虚拟内存与物理内存" class="headerlink" title="虚拟内存与物理内存"></a>虚拟内存与物理内存</h2><p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210627171511300.png" alt="image-20210627171511300"></p>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>参考《现代操作系统》交换技术讲解。</p>
<p>虚拟内存地址划分：</p>
<table>
<thead>
<tr>
<th>分区</th>
<th>X86 32位Windows</th>
</tr>
</thead>
<tbody><tr>
<td>空指针赋值区(前64KB)</td>
<td>0x00000000~0x0000FFFF</td>
</tr>
<tr>
<td>用户模式区</td>
<td>0x00010000~0x7FFEFFFF</td>
</tr>
<tr>
<td>64KB禁入区(后64KB)</td>
<td>0x7FFF0000~0x7FFFFFFF</td>
</tr>
<tr>
<td>内核</td>
<td>0x80000000~0xFFFFFFFF</td>
</tr>
</tbody></table>
<p>说明:</p>
<ol>
<li>线性地址有4G，但未必都能访问（未申请的内存不能访问）</li>
<li>所以需要记录哪些地方分配了</li>
</ol>
<h3 id="物理内存"><a href="#物理内存" class="headerlink" title="物理内存"></a>物理内存</h3><p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/5396392-230b8f4ea39a4f00.webp" alt="5396392-230b8f4ea39a4f00"></p>
<p>因特尔x86CPU架构将物理内存按照4KB的方式分成一页来进行页式管理</p>
<p>物理页和内存条之间还有一层映射。</p>
<p><strong>可供使用的物理内存</strong></p>
<ol>
<li>MmNumberOfPhysicalPages（物理页数）*4&#x3D;物理内存</li>
<li>硬盘伪装的物理内存。（可选）</li>
</ol>
<p><strong>能够识别的物理内存</strong></p>
<p>32位系统最多可以识别物理内存为64G，但由于操作系统的限制，比如XP，只能识别4G（Windows 2003服务器版本 可以识别4G以上）</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210627184154084.png" alt="image-20210627184154084"></p>
<p>物理内存不够用，可以把硬盘当成内存，操作如下：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210627184851391.png" alt="image-20210627184851391"></p>
<p>自定义大小中的初始大小可以修改硬盘当物理内存使用的大小。该大小可以在c盘直观地看到一个叫pagefile.sys的文件，占用就和你设置的值一样。</p>
<p>对于程序员来说<strong>感知不到物理内存的存在</strong>是因为操作系统做了下面这些事：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210627185746450.png" alt="image-20210627185746450"></p>
<p><strong>已经分配的虚拟内存也可能没有物理页</strong>，因为可能被临时移动到硬盘去给物理内存腾出空间放新的进程了。</p>
<h2 id="私有内存与申请释放"><a href="#私有内存与申请释放" class="headerlink" title="私有内存与申请释放"></a>私有内存与申请释放</h2><ul>
<li>私有内存（又叫线性内存）：当前物理页只能某个进程使用，别的进程无法使用的。</li>
<li>共享内存(又叫Mapped内存)：多个进程都可以共用的物理页</li>
</ul>
<p>申请内存的两种方式</p>
<ol>
<li>通过VirtualAlloc&#x2F;VirtualAllocEx申请的：Private Memory(私有内存)</li>
<li>通过CreateFileMapping映射的：Mapped Memory(映射内存，共享内存)</li>
</ol>
<p>真正的申请内存只有上述这两个方式，其他如malloc，new其实和内存没有关系。</p>
<p>new&#x3D;malloc+构造函数;</p>
<p><strong>而malloc是从已经由操作系统申请好的内存中再拿一小块来用。程序启动的时候，操作系统已经为程序分配好了内存</strong></p>
<p>malloc的本质就是malloc-&gt;HeapAlloc-&gt;没有进内核。因为内存实际上已经分配好了</p>
<h3 id="私有内存申请与释放"><a href="#私有内存申请与释放" class="headerlink" title="私有内存申请与释放"></a>私有内存申请与释放</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//成功的话返回分配的虚拟内存首地址</span></span><br><span class="line"><span class="comment">//失败返回NULL</span></span><br><span class="line"><span class="function">LPVOID <span class="title">VirtualAlloc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPVOID lpAddress,<span class="comment">//要分配的内存区域的地址，如果指定到已经分配的虚拟空间了则一定失败。所以一般填空表示分配到哪个虚拟地址都可以</span></span></span></span><br><span class="line"><span class="params"><span class="function">  SIZE_T dwSize,<span class="comment">//分配多大的虚拟内存，哪怕写一个字节也会分配一个页的大小，所以通常写页的整数倍</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD  flAllocationType,<span class="comment">//分配的类型，比如MEM_RESERVE表示占用虚拟地址（使用时，操作系统才帮你挂物理页），MEM_COMMIT表示占用虚拟地址并且挂上物理页</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD  flProtect<span class="comment">//内存的初始保护属性，比如PAGE_READWRITE可读可写，比如PAGE_READONLY只读，比如PAGE_EXECUTE_READWRITE可读可写可执行</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//释放私有内存或仅释放物理页</span></span><br><span class="line"><span class="function">BOOL <span class="title">VirtualFree</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPVOID lpAddress,<span class="comment">//释放的虚拟内存首地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">  SIZE_T dwSize,<span class="comment">//释放多大的内存，通常写页的整数倍。dwFreeType为MEM_RELEASE时，这里必须为0</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD  dwFreeType<span class="comment">//释放方式：MEM_DECOMMIT只取消占用物理页，虚拟地址依然保留；MEM_RELEASE表示物理页不占用的同时也释放虚拟地址，如果指定此值，则dwSize必须为 0</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//VirtualAllocEx只比VirtualAlloc多一个进程句柄，可以给别人申请内存</span></span><br><span class="line"><span class="function">LPVOID <span class="title">VirtualAllocEx</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE hProcess,<span class="comment">//申请内存的目标进程句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPVOID lpAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">  SIZE_T dwSize,</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD  flAllocationType,</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD  flProtect</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>可在微软官方开发者手册搜索Memory Protection Constants，有flProtect参数的可选项罗列</code></p>
<h2 id="公有内存申请释放"><a href="#公有内存申请释放" class="headerlink" title="公有内存申请释放"></a>公有内存申请释放</h2><h3 id="公有内存申请释放案例"><a href="#公有内存申请释放案例" class="headerlink" title="公有内存申请释放案例"></a>公有内存申请释放案例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建内核对象:物理页</span></span><br><span class="line">HANDLE hMapFile=<span class="built_in">CreateFileMapping</span>((HANDLE)<span class="number">-1</span>, <span class="literal">NULL</span>, PAGE_READWRITE, <span class="number">0</span>, <span class="number">0x1000</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//将物理页与线性地址进行映射</span></span><br><span class="line">DWORD newMemAddress=(DWORD)<span class="built_in">MapViewOfFile</span>(hMapFile, FILE_MAP_ALL_ACCESS, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line"><span class="comment">//简单使用一下地址</span></span><br><span class="line">*(DWORD*)newMemAddress = <span class="number">0x12345678</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p虚拟地址中的值为：%p\r\n&quot;</span>, newMemAddress, *(DWORD*)newMemAddress);</span><br><span class="line"><span class="comment">//关闭映射</span></span><br><span class="line"><span class="built_in">UnmapViewOfFile</span>((LPCVOID)newMemAddress);</span><br><span class="line"><span class="comment">//关闭物理页内核对象句柄</span></span><br><span class="line"><span class="built_in">CloseHandle</span>(hMapFile);</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210628152849905.png" alt="image-20210628152849905"></p>
<p>下断点查看那块内存：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210628153031108.png" alt="image-20210628153031108"></p>
<h3 id="CreateFileMapping函数（重点）"><a href="#CreateFileMapping函数（重点）" class="headerlink" title="CreateFileMapping函数（重点）"></a>CreateFileMapping函数（重点）</h3><p><strong>创建或打开文件映射内核对象</strong></p>
<p>功能上：申请物理页或者申请物理页并把文件映射到物理页</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回文件映射内核对象句柄</span></span><br><span class="line"><span class="comment">//如果对象在函数调用之前存在，则函数返回现有对象的句柄（使用其当前大小，而不是指定大小），并且GetLastError返回ERROR_ALREADY_EXISTS。</span></span><br><span class="line"><span class="comment">//如果函数失败，则返回值为NULL</span></span><br><span class="line"><span class="function">HANDLE <span class="title">CreateFileMappingA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE                hFile,<span class="comment">//文件句柄，如果指定了文件句柄，不仅给你提供物理页，还可以把这个文件映射到物理页上面。填-1表示只要物理页，不需要映射文件。</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPSECURITY_ATTRIBUTES lpFileMappingAttributes,<span class="comment">//安全属性</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD                 flProtect,<span class="comment">//保护属性：这个是设置的物理内存的访问权限。PAGE_READONLY,PAGE_READWRITE,PAGE_WRITECOPY等等，设置了该物理内存的访问权限，则其挂到的虚拟内存的访问权限必须小于等于该物理页的访问权限</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">//下面两项共同表示你要多大一块物理内存；若关联文件，如果此参数和dwMaximumSizeHigh为 0（零），则文件映射对象的最大大小等于hFile标识的文件的当前大小 。</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD                 dwMaximumSizeHigh,<span class="comment">//高32位，32位系统用不上这个成员一定填空</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD                 dwMaximumSizeLow,<span class="comment">//低32位</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR                lpName<span class="comment">//内核对象的名字，其他进程打开该内核对象才需要此标识。</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">HANDLE <span class="title">CreateFileMappingW</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE                hFile,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPSECURITY_ATTRIBUTES lpFileMappingAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD                 flProtect,</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD                 dwMaximumSizeHigh,</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD                 dwMaximumSizeLow,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCWSTR               lpName</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>文件映射内核对象</strong>就可以<strong>理解成</strong>是一个<strong>物理页内核对象</strong></p>
<p><strong>CreateFileMapping映射到物理页并不会按照PE格式从硬盘到内存伸缩展开，而是按照文件原来的二进制格式映射到内存中</strong></p>
<p>他的释放要当所有进程都不用这个物理页的时候，操作系统会将他清除。不使用的时候CloseHandle关闭物理页内核对象句柄。</p>
<h3 id="MapViewOfFile物理页映射到虚拟地址函数"><a href="#MapViewOfFile物理页映射到虚拟地址函数" class="headerlink" title="MapViewOfFile物理页映射到虚拟地址函数"></a>MapViewOfFile物理页映射到虚拟地址函数</h3><p>CreateFileMapping只是申请物理页或者申请物理页并把文件映射到物理页，但并没有映射物理页到进程的虚拟地址空间，下面函数就是实现这个过程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//成功的话返回物理页映射到的虚拟地址首地址</span></span><br><span class="line"><span class="comment">//如果函数失败，则返回值为NULL</span></span><br><span class="line"><span class="function">LPVOID <span class="title">MapViewOfFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE hFileMappingObject,<span class="comment">//文件映射内核对象的句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD  dwDesiredAccess,<span class="comment">//映射的虚拟内存的权限保护属性，这个权限必须小于被映射的物理页的flProtect权限保护属性(否则该函数失败)。</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">//FILE_MAP_ALL_ACCESS可读可写;</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">//FILE_MAP_READ只读;</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">//FILE_MAP_WRITE只写。</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">//前面3个属性唯一一个可与后面属性按位或|组合：</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">//FILE_MAP_EXECUTE可执行;</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">//FILE_MAP_COPY写拷贝（表示当修改的时候提供副本物理页供修改而不是修改原物理页，下面《内存映射文件实现读写文件的系统文件共享的注意点》有详解）等等。</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">//--------------------------------------------------------------------</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">//下面两项共同表示从物理页的哪里开始映射到虚拟内存空间，是相对物理页的偏移地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD  dwFileOffsetHigh,<span class="comment">//高32位，32位系统用不上这个成员一定填空</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD  dwFileOffsetLow,<span class="comment">//低32位</span></span></span></span><br><span class="line"><span class="params"><span class="function">  SIZE_T dwNumberOfBytesToMap<span class="comment">//映射物理页的多少字节数到虚拟内存空间，必须在CreateFileMapping指定的最大大小范围内。如果此参数为 0，则映射从指定的偏移量扩展到文件映射的末尾（就是整个物理页的大小）。一般与CreateFileMappingA的dwMaximumSizeHigh和dwMaximumSizeLow的组合一致</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//解除物理页到虚拟内存空间的映射关系，解除完后物理页还是存在的</span></span><br><span class="line"><span class="function">BOOL <span class="title">UnmapViewOfFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCVOID lpBaseAddress<span class="comment">//物理页映射出来的虚拟内存首地址，MapViewOfFile返回的地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>【重点】其实一个进程中绝大多数内存都是映射内存，只有如堆和栈还有自己virtualAlloc的空间才是私有内存。</strong></p>
<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><p>文件系统是操作系统用来管理磁盘上文件的方法和数据结构；简单点说就是<strong>在磁盘上如何组织文件的方法</strong>。</p>
<table>
<thead>
<tr>
<th></th>
<th>NTFS</th>
<th>FAT32</th>
</tr>
</thead>
<tbody><tr>
<td>磁盘分区容量</td>
<td>2T(2048G)</td>
<td>32G</td>
</tr>
<tr>
<td>单个文件容量</td>
<td>4G以上</td>
<td>最大4G</td>
</tr>
<tr>
<td>EFS加密</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>磁盘配额</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody></table>
<p><strong>EFS加密</strong>：是让同一个电脑上别的用户无法访问</p>
<p>下图设置加密：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210630122311355.png" alt="image-20210630122311355"></p>
<p><strong>磁盘配额</strong>：让别的用户只能固定使用某个磁盘多少空间</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210630122444855.png" alt="image-20210630122444855"></p>
<p>文件系统：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210628154143292.png" alt="image-20210628154143292"></p>
<h2 id="文件相关API"><a href="#文件相关API" class="headerlink" title="文件相关API"></a>文件相关API</h2><p>文件相关API不需要区分文件系统的概念。windows API已经屏蔽了文件系统的底层实现。</p>
<h3 id="卷相关API"><a href="#卷相关API" class="headerlink" title="卷相关API"></a>卷相关API</h3><p>硬盘分成多个虚拟逻辑驱动器，这个虚拟逻辑驱动器就是<strong>卷</strong>。</p>
<p><strong>卷</strong>是文件系统最上层的组织形式。</p>
<ol>
<li>获取卷(有哪些卷，是什么)GetLogicalDrives</li>
<li>获取一个卷的盘符的字符串GetLogicalDriveStrings</li>
<li>获取卷的类型GetDriveType</li>
<li>获取卷的信息GetVolumeInformation</li>
</ol>
<h4 id="GetLogicalDrives"><a href="#GetLogicalDrives" class="headerlink" title="GetLogicalDrives"></a>GetLogicalDrives</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果函数成功，则返回值是表示当前可用磁盘驱动器的位掩码。位位置 0（最低有效位）是驱动器 A，位位置 1 是驱动器 B，位位置 2 是驱动器 C，依此类推。</span></span><br><span class="line"><span class="comment">//如果函数失败，则返回值为零。要获取扩展错误信息，请调用 GetLastError。</span></span><br><span class="line"><span class="function">DWORD <span class="title">GetLogicalDrives</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="GetLogicalDriveStrings"><a href="#GetLogicalDriveStrings" class="headerlink" title="GetLogicalDriveStrings"></a>GetLogicalDriveStrings</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果函数成功，则返回值是复制到缓冲区的字符串的长度（以字符为单位），不包括终止空字符。请注意，ANSI-ASCII 空字符使用一个字节，而 Unicode (UTF-16) 空字符使用两个字节。</span></span><br><span class="line"><span class="comment">//如果缓冲区不够大，则返回值大于nBufferLength。它是保存驱动器字符串所需的缓冲区大小。</span></span><br><span class="line"><span class="comment">//如果函数失败，则返回值为零。要获取扩展错误信息，请使用 GetLastError函数。</span></span><br><span class="line"><span class="function">DWORD <span class="title">GetLogicalDriveStringsA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD nBufferLength,<span class="comment">//缓冲区的最大大小(不包括终止空字符)</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPSTR lpBuffer<span class="comment">//指向缓冲区的指针，该缓冲区接收一系列以空字符结尾的字符串</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">DWORD <span class="title">GetLogicalDriveStringsW</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD  nBufferLength,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPWSTR lpBuffer</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>lpBuffer获取到的字符串如下：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210703130407329.png" alt="image-20210703130407329"></p>
<h4 id="GetDriveType"><a href="#GetDriveType" class="headerlink" title="GetDriveType"></a>GetDriveType</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//确定磁盘驱动器是可移动、固定、CD-ROM、RAM 磁盘还是网络驱动器。</span></span><br><span class="line"><span class="function">UINT <span class="title">GetDriveTypeA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR lpRootPathName<span class="comment">//驱动器的根目录。需要尾随反斜杠。如果此参数为NULL，则该函数使用当前目录的根目录。</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">UINT <span class="title">GetDriveTypeW</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCWSTR lpRootPathName</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getdrivetypew">详细信息查询文档</a></p>
<h4 id="GetVolumeInformation"><a href="#GetVolumeInformation" class="headerlink" title="GetVolumeInformation"></a>GetVolumeInformation</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">GetVolumeInformationA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR  lpRootPathName,<span class="comment">//IN 磁盘驱动器代码字符串</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPSTR   lpVolumeNameBuffer,<span class="comment">//OUT 磁盘驱动器卷标名称(别名)</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD   nVolumeNameSize,<span class="comment">//IN 磁盘驱动器卷标名称长度</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPDWORD lpVolumeSerialNumber,<span class="comment">//OUT 磁盘驱动器卷标序列号（不是硬盘序列号，该号是硬盘出厂时生产厂家为区别产品而设置的，就像人的身份证）</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPDWORD lpMaximumComponentLength,<span class="comment">//OUT 系统允许的最大文件名长度</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPDWORD lpFileSystemFlags,<span class="comment">//OUT 文件系统标识</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPSTR   lpFileSystemNameBuffer,<span class="comment">//OUT 文件操作系统名称</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD   nFileSystemNameSize<span class="comment">//IN 文件操作系统名称长度</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">GetVolumeInformationW</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCWSTR lpRootPathName,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPWSTR  lpVolumeNameBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD   nVolumeNameSize,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPDWORD lpVolumeSerialNumber,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPDWORD lpMaximumComponentLength,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPDWORD lpFileSystemFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPWSTR  lpFileSystemNameBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD   nFileSystemNameSize</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a><strong>使用案例</strong></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TCHAR szVolumneName[<span class="number">260</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">DWORD dwVolumneSerial = <span class="number">0</span>;</span><br><span class="line">DWORD dwMaxLength = <span class="number">0</span>;</span><br><span class="line">DWORD dwFileSystem = <span class="number">0</span>;</span><br><span class="line">TCHAR szFileSystem[<span class="number">260</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">GetVolumeInformation</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;C://&quot;</span>), szVolumneName, <span class="number">260</span>, &amp;dwVolumneSerial, &amp;dwMaxLength, &amp;dwFileSystem, szFileSystem, <span class="number">260</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210703132545845.png" alt="image-20210703132545845"></p>
<h3 id="目录相关API"><a href="#目录相关API" class="headerlink" title="目录相关API"></a>目录相关API</h3><ol>
<li>创建目录CreateDirectory</li>
<li>删除现有空目录RemoveDirectory</li>
<li>修改目录名称MoveFile</li>
<li>获取程序当前目录GetCurrentDirectory</li>
<li>设置程序当前目录SetCurrentDirectory</li>
</ol>
<p><code>要具备管理员权限</code></p>
<h4 id="CreateDirectory"><a href="#CreateDirectory" class="headerlink" title="CreateDirectory"></a>CreateDirectory</h4><p>目录也是个<strong>内核对象</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果函数成功，则返回值非零。</span></span><br><span class="line"><span class="comment">//如果函数失败，则返回值为零。要获取扩展错误信息，请调用 GetLastError。</span></span><br><span class="line"><span class="comment">//ERROR_ALREADY_EXISTS	指定的目录已经存在。</span></span><br><span class="line"><span class="comment">//ERROR_PATH_NOT_FOUND	一个或多个中间目录不存在；此函数只会在路径中创建最终目录。</span></span><br><span class="line"><span class="function">BOOL <span class="title">CreateDirectoryA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR                lpPathName,<span class="comment">//要创建的目录的路径。</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPSECURITY_ATTRIBUTES lpSecurityAttributes<span class="comment">//安全属性</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">CreateDirectoryW</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCWSTR               lpPathName,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPSECURITY_ATTRIBUTES lpSecurityAttributes</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="RemoveDirectory"><a href="#RemoveDirectory" class="headerlink" title="RemoveDirectory"></a>RemoveDirectory</h4><p>只能删除现有的<strong>空目录</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果函数成功，则返回值非零。</span></span><br><span class="line"><span class="comment">//如果函数失败，则返回值为零。</span></span><br><span class="line"><span class="function">BOOL <span class="title">RemoveDirectoryA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR lpPathName<span class="comment">//要删除的目录的路径。此路径必须指定一个空目录，并且调用进程必须对该目录具有删除权限。</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">RemoveDirectoryW</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCWSTR lpPathName</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="MoveFile"><a href="#MoveFile" class="headerlink" title="MoveFile"></a>MoveFile</h4><p><strong>移动</strong>现有文件或目录，包括其子目录。（可以用于<strong>改名</strong>）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">MoveFileA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR lpExistingFileName,<span class="comment">//原路径（文件或目录）</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR lpNewFileName<span class="comment">//新路径（文件或目录）</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">MoveFileW</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCWSTR lpExistingFileName,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCWSTR lpNewFileName</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="GetCurrentDirectory-x2F-SetCurrentDirectory"><a href="#GetCurrentDirectory-x2F-SetCurrentDirectory" class="headerlink" title="GetCurrentDirectory&#x2F;SetCurrentDirectory"></a>GetCurrentDirectory&#x2F;SetCurrentDirectory</h4><p>获取和设置工作目录绝对路径</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前进程的当前目录。</span></span><br><span class="line"><span class="function">DWORD <span class="title">GetCurrentDirectory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD  nBufferLength,<span class="comment">//当前目录字符串的缓冲区长度，以TCHARs 为单位。缓冲区长度必须包括用于终止空字符的空间。</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPTSTR lpBuffer<span class="comment">//指向接收当前目录字符串的缓冲区的指针。</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//更改当前进程的当前目录。</span></span><br><span class="line"><span class="function">BOOL <span class="title">SetCurrentDirectory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCTSTR lpPathName<span class="comment">//新的当前目录的路径</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="文件相关API-1"><a href="#文件相关API-1" class="headerlink" title="文件相关API"></a>文件相关API</h3><ol>
<li>创建或打开文件或 I&#x2F;O 设备CreateFile</li>
<li>关闭文件CloseHandle</li>
<li>获取文件长度GetFileSize</li>
<li>获取文件的属性和信息GetFileAttributes()&#x2F;GetFileAttributesEx</li>
<li>读&#x2F;写&#x2F;拷贝&#x2F;删除 文件ReadFile()&#x2F;WriteFile()&#x2F;CopyFile()&#x2F;DeleteFile</li>
<li>遍历某个盘查找文件FindFirstFile()&#x2F;FindNextFile</li>
</ol>
<h4 id="CreateFile"><a href="#CreateFile" class="headerlink" title="CreateFile"></a>CreateFile</h4><p>创建或打开文件或 I&#x2F;O 设备。最常用的 I&#x2F;O 设备如下：文件、文件流、目录、物理磁盘、卷、控制台缓冲区、磁带驱动器、通信资源、邮槽和管道。该函数返回一个句柄，该句柄可用于根据文件或设备以及指定的标志和属性为各种类型的 I&#x2F;O 访问文件或设备。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果函数成功，则返回值是指定文件、设备、命名管道或邮槽的句柄。</span></span><br><span class="line"><span class="comment">//如果函数失败，则返回值为INVALID_HANDLE_VALUE。要获取扩展错误信息，请调用GetLastError。</span></span><br><span class="line"><span class="function">HANDLE <span class="title">CreateFileA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR                lpFileName,<span class="comment">//文件名</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD                 dwDesiredAccess,<span class="comment">//访问模式，权限</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD                 dwShareMode,<span class="comment">//分享模式,0表示当前创建的文件使用是排他的，只有当前程序关闭后才能读写该文件;FILE_SHARE_DELETE表示在当前程序使用中，别的程序可以删掉。详情查看说明文档</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPSECURITY_ATTRIBUTES lpSecurityAttributes,<span class="comment">//安全属性</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD                 dwCreationDisposition,<span class="comment">//创建的处理方式:</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">//CREATE_NEW创建一个新文件，仅当它不存在时；</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">//OPEN_EXISTING打开文件或设备，仅当它存在时；</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">//TRUNCATE_EXISTING打开一个文件并截断它，使其大小为零字节，仅当它存在时。</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">//OPEN_ALWAYS总是打开一个文件。不存在就创建</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">//CREATE_ALWAYS不存在的话创建，存在的话覆盖创建</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD                 dwFlagsAndAttributes,<span class="comment">//标志和属性，例如：FILE_ATTRIBUTE_HIDDEN文件属性设置为隐藏;FILE_ATTRIBUTE_NORMAL该文件没有设置其他属性，此属性仅在单独使用时有效。还有很多属性参考说明文档</span></span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE                hTemplateFile<span class="comment">//此参数可以为NULL。基本只在加密文件文件时用到该参数。详情看文档</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">HANDLE <span class="title">CreateFileW</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCWSTR               lpFileName,</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD                 dwDesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD                 dwShareMode,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPSECURITY_ATTRIBUTES lpSecurityAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD                 dwCreationDisposition,</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD                 dwFlagsAndAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE                hTemplateFile</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//确定C:\\路径没有A.txt的情况下，在C盘下创建A.txt。并且该程序使用该文件时候，其他程序可读可写</span></span><br><span class="line">HANDLE hFile = <span class="built_in">CreateFile</span>(</span><br><span class="line">		<span class="built_in">TEXT</span>(<span class="string">&quot;C:\\A.txt&quot;</span>),</span><br><span class="line">		GENERIC_READ|GENERIC_WRITE,</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		CREATE_NEW,</span><br><span class="line">		FILE_ATTRIBUTE_NORMAL,</span><br><span class="line">		<span class="literal">NULL</span></span><br><span class="line">		);</span><br></pre></td></tr></table></figure>

<h4 id="GetFileSize"><a href="#GetFileSize" class="headerlink" title="GetFileSize"></a>GetFileSize</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//若成功，返回的是文件大小低位双字</span></span><br><span class="line"><span class="comment">//如果函数失败并且lpFileSizeHigh为NULL，则返回值为INVALID_FILE_SIZE。</span></span><br><span class="line"><span class="function">DWORD <span class="title">GetFileSize</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE  hFile,<span class="comment">//文件句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPDWORD lpFileSizeHigh<span class="comment">//指向返回文件大小高位双字的变量的指针，若不需要高位这里设置NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>该函数成功的话，对于大文件来说，返回值和lpFileSizeHigh参数共同组成<strong>文件大小</strong></p>
<h4 id="GetFileAttributes-x2F-GetFileAttributesEx"><a href="#GetFileAttributes-x2F-GetFileAttributesEx" class="headerlink" title="GetFileAttributes()&#x2F;GetFileAttributesEx"></a>GetFileAttributes()&#x2F;GetFileAttributesEx</h4><p>检索指定文件或目录的属性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">GetFileAttributesExA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR                 lpFileName,<span class="comment">//要获取属性的文件或目录路径名</span></span></span></span><br><span class="line"><span class="params"><span class="function">  GET_FILEEX_INFO_LEVELS fInfoLevelId,<span class="comment">//GetFileExInfoStandard，所述lpFileInformation参数是一个 WIN32_FILE_ATTRIBUTE_DATA 结构。</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPVOID                 lpFileInformation<span class="comment">//指向接收属性信息的结构体指针。</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">GetFileAttributesExW</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCWSTR                lpFileName,</span></span></span><br><span class="line"><span class="params"><span class="function">  GET_FILEEX_INFO_LEVELS fInfoLevelId,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPVOID                 lpFileInformation</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">DWORD <span class="title">GetFileAttributesA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR lpFileName</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">DWORD <span class="title">GetFileAttributesW</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCWSTR lpFileName</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/fileapi/ns-fileapi-win32_file_attribute_data">WIN32_FILE_ATTRIBUTE_DATA</a>结构</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_WIN32_FILE_ATTRIBUTE_DATA</span> &#123;</span><br><span class="line">  DWORD    dwFileAttributes;<span class="comment">//文件或目录的文件系统属性信息。详情见文档</span></span><br><span class="line">  FILETIME ftCreationTime;<span class="comment">//创建时间结构体</span></span><br><span class="line">  FILETIME ftLastAccessTime;<span class="comment">//最后访问时间结构体</span></span><br><span class="line">  FILETIME ftLastWriteTime;<span class="comment">//最后修改时间结构体</span></span><br><span class="line">  DWORD    nFileSizeHigh;<span class="comment">//文件大小的高位 DWORD。</span></span><br><span class="line">  DWORD    nFileSizeLow;<span class="comment">//文件大小的低位 DWORD。</span></span><br><span class="line">&#125; WIN32_FILE_ATTRIBUTE_DATA, *LPWIN32_FILE_ATTRIBUTE_DATA;</span><br></pre></td></tr></table></figure>

<p><strong>FILETIME结构体</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_FILETIME</span> &#123;</span><br><span class="line">  DWORD dwLowDateTime;<span class="comment">//文件时间的低位部分。</span></span><br><span class="line">  DWORD dwHighDateTime;<span class="comment">//文件时间的高位部分。</span></span><br><span class="line">&#125; FILETIME, *PFILETIME, *LPFILETIME;</span><br></pre></td></tr></table></figure>

<p>要将 <strong>FILETIME</strong>结构转换为易于向用户显示的时间，请使用 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/timezoneapi/nf-timezoneapi-filetimetosystemtime">FileTimeToSystemTime</a>函数。</p>
<h4 id="ReadFile-x2F-WriteFile-x2F-CopyFile-x2F-DeleteFile"><a href="#ReadFile-x2F-WriteFile-x2F-CopyFile-x2F-DeleteFile" class="headerlink" title="ReadFile()&#x2F;WriteFile()&#x2F;CopyFile()&#x2F;DeleteFile"></a>ReadFile()&#x2F;WriteFile()&#x2F;CopyFile()&#x2F;DeleteFile</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">ReadFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE       hFile,<span class="comment">//读的文件句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPVOID       lpBuffer,<span class="comment">//读到哪去</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD        nNumberOfBytesToRead,<span class="comment">//要读多少个字节</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPDWORD      lpNumberOfBytesRead,<span class="comment">//读了多少个</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPOVERLAPPED lpOverlapped<span class="comment">//网络编程的异步模型要关注的参数，暂不管,填NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">WriteFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE       hFile,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCVOID      lpBuffer,<span class="comment">//写什么</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD        nNumberOfBytesToWrite,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPDWORD      lpNumberOfBytesWritten,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPOVERLAPPED lpOverlapped</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">CopyFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCTSTR lpExistingFileName,<span class="comment">//拷贝哪个文件</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCTSTR lpNewFileName,<span class="comment">//拷贝到哪里</span></span></span></span><br><span class="line"><span class="params"><span class="function">  BOOL    bFailIfExists<span class="comment">//如果此参数为TRUE并且lpNewFileName指定的新文件 已经存在，则函数失败。如果此参数为 FALSE且新文件已存在，则该函数会覆盖现有文件并成功。</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">DeleteFileA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR lpFileName<span class="comment">//要删除的文件路径</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">DeleteFileW</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCWSTR lpFileName</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="读取文件案例"><a href="#读取文件案例" class="headerlink" title="读取文件案例"></a>读取文件案例</h5><p>test.txt如图：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210703161630006.png" alt="image-20210703161630006"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">HANDLE hFile = <span class="built_in">CreateFile</span>(</span><br><span class="line">		<span class="built_in">TEXT</span>(<span class="string">&quot;C:\\Users\\Administrator\\Desktop\\test.txt&quot;</span>),</span><br><span class="line">		GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		OPEN_EXISTING,</span><br><span class="line">		FILE_ATTRIBUTE_NORMAL,</span><br><span class="line">		<span class="literal">NULL</span></span><br><span class="line">		);</span><br><span class="line">	cout&lt;&lt;hFile&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">if</span> (hFile)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//读取文件</span></span><br><span class="line">		<span class="comment">//	分配空间</span></span><br><span class="line">		<span class="type">char</span>* pszBuffer;</span><br><span class="line">		DWORD lowSize =<span class="built_in">GetFileSize</span>(hFile, <span class="literal">NULL</span>);<span class="comment">//文件不能过大</span></span><br><span class="line">		<span class="keyword">if</span> (lowSize)</span><br><span class="line">		&#123;</span><br><span class="line">			pszBuffer = (<span class="type">char</span>*)<span class="built_in">malloc</span>(lowSize+<span class="number">1</span>);</span><br><span class="line">			<span class="built_in">ZeroMemory</span>(pszBuffer, lowSize + <span class="number">1</span>);</span><br><span class="line">			<span class="comment">//	设置当前读取的位置</span></span><br><span class="line">			<span class="built_in">SetFilePointer</span>(hFile, <span class="number">0</span>, <span class="literal">NULL</span>, FILE_BEGIN);<span class="comment">//设置hFile对应文件光标为从文件头偏移0个字节的位置</span></span><br><span class="line">			<span class="comment">//读取数据</span></span><br><span class="line">			DWORD dwReadLength = <span class="number">0</span>;</span><br><span class="line">			<span class="built_in">ReadFile</span>(hFile, pszBuffer, lowSize, &amp;dwReadLength, <span class="literal">NULL</span>);</span><br><span class="line">			cout&lt;&lt;pszBuffer&lt;&lt;endl;</span><br><span class="line">			<span class="comment">//关闭文件句柄</span></span><br><span class="line">			<span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">			<span class="comment">//释放内存</span></span><br><span class="line">			<span class="built_in">free</span>(pszBuffer);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>案例输出如图：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210703161739985.png" alt="image-20210703161739985"></p>
<p><code>红线是bom头</code></p>
<h5 id="写文件案例"><a href="#写文件案例" class="headerlink" title="写文件案例"></a>写文件案例</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> szBuffer[] = <span class="string">&quot;中国123&quot;</span>;</span><br><span class="line">DWORD dwWritten = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">WriteFile</span>(hFile, szBuffer, <span class="built_in">strlen</span>(szBuffer), &amp;dwWritten, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>结果如图：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210703163120600.png" alt="image-20210703163120600"></p>
<h5 id="拷贝文件和删除文件案例"><a href="#拷贝文件和删除文件案例" class="headerlink" title="拷贝文件和删除文件案例"></a>拷贝文件和删除文件案例</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拷贝文件</span></span><br><span class="line"><span class="built_in">CopyFileA</span>(<span class="string">&quot;C:\\test.txt&quot;</span>,<span class="string">&quot;C:\\test2.txt&quot;</span>,FALSE);</span><br><span class="line"><span class="comment">//删除文件</span></span><br><span class="line"><span class="built_in">DeleteFileA</span>(<span class="string">&quot;C:\\test.txt&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="FindFirstFile-x2F-FindNextFile"><a href="#FindFirstFile-x2F-FindNextFile" class="headerlink" title="FindFirstFile()&#x2F;FindNextFile"></a>FindFirstFile()&#x2F;FindNextFile</h4><p>根据文件名查找文件。该函数到一个文件夹(包括子文件夹)去搜索指定文件（或部分名称，如果使用通配符）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果函数成功，则返回值是在随后调用FindNextFile或 FindClose 时使用的搜索句柄 ，并且 lpFindFileData参数包含有关找到的第一个文件或目录的信息。</span></span><br><span class="line"><span class="comment">//如果函数失败或无法从lpFileName参数中的搜索字符串中定位文件 ，则返回值为 INVALID_HANDLE_VALUE并且lpFindFileData的内容不确定。</span></span><br><span class="line"><span class="function">HANDLE <span class="title">FindFirstFileA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR             lpFileName,<span class="comment">//欲搜索的目录或路径，以及文件名。文件名可以包含通配符，例如星号 (*) 或问号 (?)。</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPWIN32_FIND_DATAA lpFindFileData<span class="comment">//指向WIN32_FIND_DATA结构的指针，该结构接收有关找到的文件或目录的信息。</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">HANDLE <span class="title">FindFirstFileW</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCWSTR            lpFileName,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPWIN32_FIND_DATAW lpFindFileData</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">FindNextFileA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE             hFindFile,<span class="comment">//搜索句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPWIN32_FIND_DATAA lpFindFileData</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">FindNextFileW</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE             hFindFile,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPWIN32_FIND_DATAW lpFindFileData</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="WIN32-FIND-DATA结构"><a href="#WIN32-FIND-DATA结构" class="headerlink" title="WIN32_FIND_DATA结构"></a>WIN32_FIND_DATA结构</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//包含有关FindFirstFile、 FindFirstFileEx或 FindNextFile函数找到的文件的信息 。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_WIN32_FIND_DATAA</span> &#123;</span><br><span class="line">  DWORD    dwFileAttributes;<span class="comment">//文件的文件属性。</span></span><br><span class="line">  FILETIME ftCreationTime;<span class="comment">//创建时间结构体</span></span><br><span class="line">  FILETIME ftLastAccessTime;<span class="comment">//最后访问时间结构体</span></span><br><span class="line">  FILETIME ftLastWriteTime;<span class="comment">//最后修改时间结构体</span></span><br><span class="line">  DWORD    nFileSizeHigh;<span class="comment">//文件大小高DWORD</span></span><br><span class="line">  DWORD    nFileSizeLow;<span class="comment">//文件大小低DWORD</span></span><br><span class="line">  DWORD    dwReserved0;<span class="comment">//如果dwFileAttributes成员包括 FILE_ATTRIBUTE_REPARSE_POINT属性，则该成员指定重新分析点标记。否则，此值未定义且不应使用。</span></span><br><span class="line">  DWORD    dwReserved1;<span class="comment">//保留以备将来使用。</span></span><br><span class="line">  CHAR     cFileName[MAX_PATH];<span class="comment">//文件名。</span></span><br><span class="line">  CHAR     cAlternateFileName[<span class="number">14</span>];<span class="comment">//长文件名才有的文件的替代名称，是截断版本，否则为NULL。</span></span><br><span class="line">  <span class="comment">//下面三个参数开发文档未说明</span></span><br><span class="line">  DWORD    dwFileType;</span><br><span class="line">  DWORD    dwCreatorType;</span><br><span class="line">  WORD     wFinderFlags;</span><br><span class="line">&#125; WIN32_FIND_DATAA, *PWIN32_FIND_DATAA, *LPWIN32_FIND_DATAA;</span><br></pre></td></tr></table></figure>

<p>dwFileAttributes可以是如下属性，通过这个字段可以检查找到的究竟是一个文件还是一个子目录</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">●FILE_ATTRIBUTE_ARCHIVE——文件包含归档属性。</span><br><span class="line">●FILE_ATTRIBUTE_COMPRESSED——文件和目录被压缩。</span><br><span class="line">●FILE_ATTRIBUTE_DIRECTORY——找到的是一个目录。</span><br><span class="line">●FILE_ATTRIBUTE_HIDDEN——文件包含隐含属性。</span><br><span class="line">●FILE_ATTRIBUTE_NORMAL——文件没有其他属性。</span><br><span class="line">●FILE_ATTRIBUTE_READONLY——文件包含只读属性。</span><br><span class="line">●FILE_ATTRIBUTE_SYSTEM——文件包含系统属性。</span><br><span class="line">●FILE_ATTRIBUTE_TEMPORARY——文件是一个临时文件。</span><br></pre></td></tr></table></figure>

<h5 id="查找文件案例"><a href="#查找文件案例" class="headerlink" title="查找文件案例"></a>查找文件案例</h5><p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210703170047278.png" alt="image-20210703170047278"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_WIN32_FIND_DATAA p;</span><br><span class="line">	HANDLE h = <span class="built_in">FindFirstFileA</span>(<span class="string">&quot;C:\\Users\\Administrator\\Desktop\\123\\*.txt&quot;</span>, &amp;p);</span><br><span class="line">	<span class="built_in">puts</span>(p.cFileName);</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">FindNextFileA</span>(h, &amp;p))</span><br><span class="line">		<span class="built_in">puts</span>(p.cFileName);</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210703170103293.png" alt="image-20210703170103293"></p>
<h1 id="内存映射文件实现读写文件"><a href="#内存映射文件实现读写文件" class="headerlink" title="内存映射文件实现读写文件"></a>内存映射文件实现读写文件</h1><p>内存映射文件：把一个硬盘里的文件直接映射到物理页上，直接再把物理页映射到进程的虚拟内存里（如图）</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210703185707851.png" alt="image-20210703185707851"><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210703222153407.png" alt="image-20210703222153407"></p>
<p>优点：对于大文件的读写性能非常好，操作方便，可以在<strong>多个进程中共享</strong></p>
<p>步骤：</p>
<ol>
<li>CreateFile得到文件句柄</li>
<li>CreateFileMapping创建物理页并映射文件</li>
<li>MapViewOfFile将物理页映射到虚拟内存</li>
</ol>
<blockquote>
<p><strong>【注意】</strong>文件大小要修正的情况</p>
<p>如果要修改文件的大小，CreateFileMapping这个函数共有6个参数。它的第五个跟第六个函数告诉我们我们要映射文件的高32位的最大值，与低32位的最小值，如果两个都为零的话，它默认映射的大小就是原文件的大小，所以你在试图修改它的映射文件并把它映射回去的时候，会出现比原文件大的情况，这样就出现映射回去的时候只有原文件大小截断部分的问题了。所有，我们在映射文件到到内存之前，最好求出我们修改后的文件大小，给CreateFileMapping函数。</p>
<p>在参数dwMaximumSizeHigh和dwMaximumSizeLow中指定内存映射文件的大小，如果指定的值大于实际的文件，则实际的文件将增长到指定的大小</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">HANDLE hFile = <span class="built_in">CreateFile</span>(</span><br><span class="line">	<span class="built_in">TEXT</span>(<span class="string">&quot;C:\\Users\\Administrator\\Desktop\\test.txt&quot;</span>),</span><br><span class="line">	GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">	<span class="number">0</span>,</span><br><span class="line">	<span class="literal">NULL</span>,</span><br><span class="line">	OPEN_EXISTING,</span><br><span class="line">	FILE_ATTRIBUTE_NORMAL,</span><br><span class="line">	<span class="literal">NULL</span></span><br><span class="line">	);</span><br><span class="line"><span class="keyword">if</span> (hFile==INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;创建文件失败&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建FileMapping对象</span></span><br><span class="line">HANDLE hMapFile = <span class="built_in">CreateFileMapping</span>(hFile, <span class="literal">NULL</span>, PAGE_READWRITE, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (hMapFile==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;创建文件映射失败&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//映射到虚拟内存</span></span><br><span class="line">LPVOID lpAddr = <span class="built_in">MapViewOfFile</span>(hMapFile, FILE_MAP_ALL_ACCESS, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (lpAddr==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;物理页映射到虚拟地址失败&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">CloseHandle</span>(hMapFile);</span><br><span class="line">	<span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在内存中直接读取文件</span></span><br><span class="line"><span class="type">char</span> tmp = *(<span class="type">char</span>*)lpAddr;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;读到的第一个字符是：&quot;</span> &lt;&lt; tmp &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在内存中写文件</span></span><br><span class="line">*(<span class="type">char</span>*)lpAddr = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="built_in">FlushViewOfFile</span>(lpAddr, <span class="number">1</span>);<span class="comment">//强制更新缓存</span></span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;修改后的第一个字符为：&quot;</span>&lt;&lt; *(<span class="type">char</span>*)lpAddr &lt;&lt;endl;</span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line"><span class="built_in">UnmapViewOfFile</span>(lpAddr);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hMapFile);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hFile);</span><br></pre></td></tr></table></figure>

<p>程序结果：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210703221045789.png" alt="image-20210703221045789"></p>
<p>原本的文件：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210703193415048.png" alt="image-20210703193415048"></p>
<p>修改后的文件：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210703220919906.png" alt="image-20210703220919906"></p>
<h2 id="FlushViewOfFile"><a href="#FlushViewOfFile" class="headerlink" title="FlushViewOfFile"></a>FlushViewOfFile</h2><p><strong>【注意】</strong>内存映射文件这种方式的写入，为了保证效率，所以其写入不是实时写入，而是释放资源的时候才会做收尾工作，即真正改写映射的文件（把物理页的值写回到文件里）。但可以通过下面的函数强制马上写入：</p>
<p>将文件映射指定范围的字节即刻写入硬盘（强制更新缓存）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果函数成功，则返回值非零。</span></span><br><span class="line"><span class="comment">//如果函数失败，则返回值为零。</span></span><br><span class="line"><span class="function">BOOL <span class="title">FlushViewOfFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCVOID lpBaseAddress,<span class="comment">//要刷新写入硬盘文件的虚拟内存首地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">  SIZE_T  dwNumberOfBytesToFlush<span class="comment">//刷新几个字节</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="系统文件共享的注意点（重点理解）"><a href="#系统文件共享的注意点（重点理解）" class="headerlink" title="系统文件共享的注意点（重点理解）"></a>系统文件共享的注意点（重点理解）</h2><p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210703222600004.png" alt="image-20210703222600004"></p>
<p>如kernel32.dll，user32.dll和ntdll.dll等系统模块，他在内存中就是文件映射到进程中的。</p>
<p><strong>Q：</strong>那么如果你在进程A中修改了系统文件的物理页，那么进程B不就直接受到影响了吗。</p>
<p>但事实上是并不会，例如进程A在kernel32.dll的代码上下软件断点（实际上就是把一个字节改成了0xCC表示汇编int 3），当前A进程执行到这里会断下来，但进程B执行到那里却不会断下来</p>
<p><strong>A：</strong>如果在MapViewOfFile映射的时候指定的是写拷贝<strong>FILE_MAP_COPY</strong>的话，就会产生上述效果，原理如下：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210703223924648.png" alt="image-20210703223924648"><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210703224651453.png" alt="image-20210703224651453"></p>
<p>当进程A修改的时候，并不会对原映射的物理页做修改，而是拷贝一份修改处的最少一页的物理页。然后再修改新出现的<strong>物理页副本</strong>。并且修改虚拟地址对物理页的映射关系（如上面右图）。最后映射结束的时候，对物理页的副本做的所有操作也并不会写回到文件中。</p>
<p>如上图，进程A下断点修改的CC实际上是修改到了上面标着CC的物理页副本，对原来的没影响</p>
<h1 id="链接库"><a href="#链接库" class="headerlink" title="链接库"></a>链接库</h1><h2 id="静态链接库"><a href="#静态链接库" class="headerlink" title="静态链接库"></a>静态链接库</h2><h3 id="编写静态链接库文件"><a href="#编写静态链接库文件" class="headerlink" title="编写静态链接库文件"></a>编写静态链接库文件</h3><ol>
<li>在vc6.0中创建新项目，项目类型：Win32 Static Library</li>
<li>在项目中创建xxxx.h和xxxx.cpp 编写代码，然后构建即可</li>
</ol>
<p>在项目目录中会生成xxxx.lib文件</p>
<h3 id="静态链接库的使用-两种方式"><a href="#静态链接库的使用-两种方式" class="headerlink" title="静态链接库的使用(两种方式)"></a>静态链接库的使用(两种方式)</h3><ol>
<li><p>将生成的.h和.lib文件复制到项目根目录，然后再代码中引用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xxxx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;xxxx.lib&quot;</span>)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将xxxx.h与xxxx.lib文件复制到vc6安装目录，与库文件放在一起。然后在工程-&gt;设置-&gt;连接-&gt;对象&#x2F;库模块中添加xxxx.lib</p>
</li>
</ol>
<p><strong>静态链接库的缺点：</strong></p>
<ol>
<li>使用静态链接生成的可执行文件体积较大</li>
<li>包含相同的公共代码，造成浪费</li>
</ol>
<p><strong>静态库会和所写代码编到一个模块</strong></p>
<h2 id="动态链接库"><a href="#动态链接库" class="headerlink" title="动态链接库"></a>动态链接库</h2><p>动态链接库（Dynamic Link Library，缩写为DLL），是微软公司在微软Windows操作系统中，实现共享函数库概念的一种方式。</p>
<p>这些库函数的拓展名是”.dll”,”.ocx”（包含ActiveX控制的库）</p>
<h3 id="DLL的入口点"><a href="#DLL的入口点" class="headerlink" title="DLL的入口点"></a><strong>DLL的入口点</strong></h3><p>动态链接库中的可选入口点 (DLL) 。 当系统启动或终止进程或线程时，它将使用进程的第一个线程为每个加载的 DLL 调用入口点函数。 使用 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya"><strong>LoadLibrary</strong></a> 和 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/win32/api/libloaderapi/nf-libloaderapi-freelibrary"><strong>FreeLibrary</strong></a> 函数加载或卸载 DLL 时，系统还会为其调用入口点函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">DllMain</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hinstDLL,  <span class="comment">// handle to DLL module	当前DLL的模块句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD fdwReason,     <span class="comment">// reason for calling function	这个DLL入口函数被调用的原因</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID lpReserved )</span>  <span class="comment">// reserved	不同调用原因，含义不同</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Perform actions based on the reason for calling.</span></span><br><span class="line">    <span class="keyword">switch</span>( fdwReason ) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_ATTACH:<span class="comment">//附加进程的时候</span></span><br><span class="line">         <span class="comment">// Initialize once for each new process.为每个新进程初始化一次。一个进程第一次加载dll的时候调用</span></span><br><span class="line">         <span class="comment">// Return FALSE to fail DLL load.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">         <span class="comment">// Do thread-specific initialization.执行特定于线程的初始化。子线程调用LoadLibrary</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> DLL_THREAD_DETACH:<span class="comment">//解除附加进程的时候</span></span><br><span class="line">         <span class="comment">// Do thread-specific cleanup.执行特定于线程的清理。已LoadLibrary的子线程结束的时候调用</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">         <span class="comment">// Perform any necessary cleanup.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;  <span class="comment">// Successful DLL_PROCESS_ATTACH.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建动态链接库-两种方法"><a href="#创建动态链接库-两种方法" class="headerlink" title="创建动态链接库(两种方法)"></a>创建动态链接库(两种方法)</h3><ol>
<li><p>函数声明用以下方式声明表明该函数要导出</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> _declspec(dllexport) 调用约定 返回类型 函数名 (参数列表);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用.def文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPORTS</span><br><span class="line">函数名	@编号</span><br><span class="line">函数名	@编号	NONAME</span><br></pre></td></tr></table></figure></li>
</ol>
<p>使用序号导出的好处：</p>
<p>名字是一段程序最精华的注释，通过名字可以直接猜测到函数的功能，通过使用序号，可以达到隐藏的目的</p>
<h3 id="使用动态链接库-两种方法"><a href="#使用动态链接库-两种方法" class="headerlink" title="使用动态链接库(两种方法)"></a>使用动态链接库(两种方法)</h3><ol>
<li>显示链接</li>
<li>隐式链接</li>
</ol>
<h4 id="显示链接"><a href="#显示链接" class="headerlink" title="显示链接"></a>显示链接</h4><p><strong>显示链接只需要用到一个DLL</strong></p>
<p>步骤如下：</p>
<ol>
<li><p>定义函数指针,如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(__stdcall *lpPlus)</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(__stdcall *lpSub)</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>声明函数指针变量，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lpPlus myPlus;</span><br><span class="line">lpSub mySub;</span><br></pre></td></tr></table></figure>
</li>
<li><p>动态加载DLL到内存中，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HINSTANCE hModule = <span class="built_in">LoadLibrary</span>(<span class="string">&quot;DllDemo.dll&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取函数地址，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myPlus=(lpPlus)<span class="built_in">GetProcAddress</span>(hModule,<span class="string">&quot;Plus&quot;</span>);<span class="comment">//通过函数名找函数地址</span></span><br><span class="line">mySub=(lpSub)<span class="built_in">GetProcAddress</span>(hModule,(<span class="type">char</span>*)<span class="number">0x10</span>);<span class="comment">//通过函数编号找函数地址</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>调用函数，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">myPlus</span>(<span class="number">10</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">mySub</span>(<span class="number">10</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>释放动态链接库，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">FreeLibrary</span>(hModule);</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="隐式链接"><a href="#隐式链接" class="headerlink" title="隐式链接"></a>隐式链接</h4><p>隐式链接需要用到DLL和LIB文件</p>
<blockquote>
<p>静态链接库的LIB文件中包含了所有代码；而动态链接库的LIB文件中只包含辅助信息，真正的代码在DLL中</p>
</blockquote>
<p>隐式链接步骤如下：</p>
<ol>
<li><p>将*.dll和*.lib放到工程目录下面</p>
</li>
<li><p>将#pragma comment(lib,”DLL名.lib”)添加到调用文件中。</p>
</li>
<li><p>加入函数的声明</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__declspec(dllimport) <span class="function">__stdcall <span class="type">int</span> <span class="title">Plus</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>;</span><br><span class="line">__declspec(dllimport) <span class="function">__stdcall <span class="type">int</span> <span class="title">Sub</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>之后就可以正常使用该函数了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Plus</span>(<span class="number">10</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">Sub</span>(<span class="number">10</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>【注意】</strong></p>
<p>如果导出的时候，是下面这样导出的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> _declspec(dllexport) 调用约定 返回类型 函数名 (参数列表);</span><br></pre></td></tr></table></figure>

<p>则上述第三步的位置也要对应写成</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllimport) <span class="function">__stdcall <span class="type">int</span> <span class="title">Plus</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllimport) <span class="function">__stdcall <span class="type">int</span> <span class="title">Sub</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="隐式链接和显示链接的区别"><a href="#隐式链接和显示链接的区别" class="headerlink" title="隐式链接和显示链接的区别"></a>隐式链接和显示链接的区别</h4><p>本质上没有什么区别，只是显示链接是我们自己调用LoadLibrary等函数，而隐式链接是操作系统帮我们调用。</p>
<h2 id="静态库和动态库在汇编的不同"><a href="#静态库和动态库在汇编的不同" class="headerlink" title="静态库和动态库在汇编的不同"></a>静态库和动态库在汇编的不同</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//静态库函数的call   0x4101234直接是函数首地址，直接调用</span><br><span class="line">call 0x4101234</span><br><span class="line">//动态库函数的call   0x0042a190内存中存的值才是函数首地址，是个间接调用</span><br><span class="line">//程序真正运行的时候，才会把对应的函数首地址填入0x0042a190内存的位置</span><br><span class="line">call dword ptr:[0x0042a190]</span><br></pre></td></tr></table></figure>

<h1 id="远程线程"><a href="#远程线程" class="headerlink" title="远程线程"></a>远程线程</h1><h2 id="CreateRemoteThread"><a href="#CreateRemoteThread" class="headerlink" title="CreateRemoteThread"></a>CreateRemoteThread</h2><p>给别的进程中创建线程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//和创建线程的区别仅在与多了一个进程句柄</span></span><br><span class="line"><span class="comment">//成功的话返回线程句柄</span></span><br><span class="line"><span class="function">HANDLE <span class="title">CreateRemoteThread</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE                 hProcess,<span class="comment">//进程句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPSECURITY_ATTRIBUTES  lpThreadAttributes,<span class="comment">//安全属性</span></span></span></span><br><span class="line"><span class="params"><span class="function">  SIZE_T                 dwStackSize,<span class="comment">//堆栈大小，填0表示默认</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPTHREAD_START_ROUTINE lpStartAddress,<span class="comment">//线程函数指针，该线程函数必须存在于远程进程中。</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPVOID                 lpParameter,<span class="comment">//参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD                  dwCreationFlags,<span class="comment">//创建状态，0表示创建好立即执行</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPDWORD                lpThreadId<span class="comment">//【out】线程id</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="远线程注入"><a href="#远线程注入" class="headerlink" title="远线程注入"></a>远线程注入</h2><p>Q：什么是注入？</p>
<p>A：所谓注入就是在第三方进程不知道或者不允许的情况下将模块或者代码写入对方进程空间，并设法执行的技术。</p>
<p>在安全领域，“注入”是非常重要的一种技术手段，注入与反注入也一直处于不断变化的，而且正处于愈来愈激烈的对抗当中</p>
<p>已知的注入方式：</p>
<ol>
<li>远程线程注入</li>
<li>APC注入</li>
<li>消息钩子注入</li>
<li>注册表注入</li>
<li>导入表注入</li>
<li>输入法注入</li>
<li>等等</li>
</ol>
<p><strong>远程线程注入的流程</strong></p>
<ol>
<li>在进程A中分配空间，存储DLL的路径</li>
<li>获取LoadLibrary函数的地址</li>
<li>创建远程线程，将线程函数指向为LoadLibrary</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">WinTool::remoteThreadInject</span><span class="params">(LPTSTR szProcessname, LPTSTR szDllName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//打开目标进程句柄</span></span><br><span class="line">	HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, <span class="literal">NULL</span>, <span class="built_in">getProcessIdByName</span>(szProcessname));<span class="comment">//getProcessIdByName为自己封装的函数</span></span><br><span class="line">	<span class="keyword">if</span> (!hProcess|| hProcess == INVALID_HANDLE_VALUE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">outDebugString</span>(<span class="string">&quot;WinTool OpenProcess ERROR\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//计算DLL路径字符串所需长度</span></span><br><span class="line">	<span class="type">int</span> dwStrLength=(<span class="built_in">lstrlen</span>(szDllName)+<span class="number">1</span>) * <span class="built_in">sizeof</span>(TCHAR);</span><br><span class="line">	<span class="comment">//在目标进程分配空间</span></span><br><span class="line">	LPVOID dwDllStrAddress= <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, dwStrLength, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">	<span class="keyword">if</span> (!dwDllStrAddress)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">outDebugString</span>(<span class="string">&quot;WinTool VirtualAllocEx ERROR\n&quot;</span>);</span><br><span class="line">		<span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将DLL路径名称拷贝到目标进程内存中</span></span><br><span class="line"></span><br><span class="line">	BOOL bRet = <span class="built_in">WriteProcessMemory</span>(hProcess, dwDllStrAddress, szDllName, dwStrLength, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (!bRet)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">outDebugString</span>(<span class="string">&quot;WinTool WriteProcessMemory ERROR\n&quot;</span>);</span><br><span class="line">		<span class="built_in">VirtualFreeEx</span>(hProcess, dwDllStrAddress, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">		<span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取模块句柄</span></span><br><span class="line">	HMODULE hModule = <span class="built_in">GetModuleHandle</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;kernel32.dll&quot;</span>));<span class="comment">//同一操作系统下，kernel32.dll位置一样。</span></span><br><span class="line">	<span class="keyword">if</span> (!hModule)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">outDebugString</span>(<span class="string">&quot;WinTool GetModuleHandle ERROR\n&quot;</span>);</span><br><span class="line">		<span class="built_in">VirtualFreeEx</span>(hProcess, dwDllStrAddress, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">		<span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取LoadLibrary函数地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> UNICODE</span></span><br><span class="line">	DWORD dwLoadLibraryAddress = (DWORD)<span class="built_in">GetProcAddress</span>(hModule, <span class="string">&quot;LoadLibraryW&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	DWORD dwLoadLibraryAddress = (DWORD)<span class="built_in">GetProcAddress</span>(hModule, <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// UNICODE</span></span></span><br><span class="line">	<span class="keyword">if</span> (!dwLoadLibraryAddress)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">outDebugString</span>(<span class="string">&quot;WinTool GetProcAddress ERROR\n&quot;</span>);</span><br><span class="line">		<span class="built_in">VirtualFreeEx</span>(hProcess, dwDllStrAddress, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">		<span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">		<span class="built_in">CloseHandle</span>(hModule);</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	HANDLE hThread = <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)dwLoadLibraryAddress, dwDllStrAddress, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (!hThread|| hThread == INVALID_HANDLE_VALUE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">outDebugString</span>(<span class="string">&quot;WinTool CreateRemoteThread ERROR\n&quot;</span>);</span><br><span class="line">		<span class="built_in">VirtualFreeEx</span>(hProcess, dwDllStrAddress, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">		<span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">		<span class="built_in">CloseHandle</span>(hModule);</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">VirtualFreeEx</span>(hProcess, dwDllStrAddress, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">	<span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">	<span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">	<span class="built_in">CloseHandle</span>(hModule);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1><p>进程间通信有很多种手段</p>
<ol>
<li>管道</li>
<li>消息队列</li>
<li>信号量</li>
<li>共享内存</li>
<li>等等</li>
</ol>
<p>看似很多，但本质上都是<strong>共享内存</strong></p>
<p><code>注入游戏的DLL带窗口是没有实用价值的，因为特征太明显了。</code></p>
<h1 id="三环遍历进程代码"><a href="#三环遍历进程代码" class="headerlink" title="三环遍历进程代码"></a>三环遍历进程代码</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历全部进程名</span></span><br><span class="line">	PROCESSENTRY32 pe32;</span><br><span class="line">	pe32.dwSize = <span class="keyword">sizeof</span>(pe32);</span><br><span class="line">	HANDLE hSnapshot_proc = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (hSnapshot_proc != INVALID_HANDLE_VALUE)</span><br><span class="line">	&#123;</span><br><span class="line">		BOOL check = Process32First(hSnapshot_proc, &amp;pe32);</span><br><span class="line">		<span class="keyword">while</span> (check)</span><br><span class="line">		&#123;</span><br><span class="line">			myOutPutDebug(<span class="string">&quot;进程PID = %d 进程名 = %s\n&quot;</span>, pe32.th32ProcessID, pe32.szExeFile);</span><br><span class="line">			check = Process32Next(hSnapshot_proc, &amp;pe32);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	CloseHandle(hSnapshot_proc);</span><br></pre></td></tr></table></figure>

<h1 id="模块隐藏"><a href="#模块隐藏" class="headerlink" title="模块隐藏"></a>模块隐藏</h1><p>直接注入的DLL是很容易被目标程序检测到的。</p>
<p>所以需要模块隐藏</p>
<p>TEB和PEB都是三环结构体。</p>
<h2 id="模块隐藏之断链"><a href="#模块隐藏之断链" class="headerlink" title="模块隐藏之断链"></a>模块隐藏之断链</h2><p>windows的三环API查的就是这些数据块，TEB和PEB</p>
<p>就是注入后，模块已经在进程内存空间中了，在PEB中的Ldr指向的模块双向链表中把注入的模块给断链。用户层API就无法找到你的模块了</p>
<h3 id="TEB"><a href="#TEB" class="headerlink" title="TEB"></a>TEB</h3><p>《1》TEB（Thread Environment Block），它记录的相关线程的信息，每个线程都有自己的TEB，FS:[0]即是<strong>当前线程</strong>的TEB。<br>$$<br>mov\ \ eax,fs:[0]<br>$$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_TEB</span> &#123;</span><br><span class="line">  PVOID Reserved1[<span class="number">12</span>];</span><br><span class="line">  PPEB  ProcessEnvironmentBlock;<span class="comment">//指向PEB</span></span><br><span class="line">  PVOID Reserved2[<span class="number">399</span>];</span><br><span class="line">  BYTE  Reserved3[<span class="number">1952</span>];</span><br><span class="line">  PVOID TlsSlots[<span class="number">64</span>];</span><br><span class="line">  BYTE  Reserved4[<span class="number">8</span>];</span><br><span class="line">  PVOID Reserved5[<span class="number">26</span>];</span><br><span class="line">  PVOID ReservedForOle;</span><br><span class="line">  PVOID Reserved6[<span class="number">4</span>];</span><br><span class="line">  PVOID TlsExpansionSlots;</span><br><span class="line">&#125; TEB, *PTEB;</span><br><span class="line"><span class="comment">//====================偏移详解===================</span></span><br><span class="line">kd&gt; dt _teb</span><br><span class="line">nt!_TEB</span><br><span class="line">   +<span class="number">0x000</span> NtTib            : _NT_TIB		<span class="comment">//重要成员，内嵌_NT_TIB结构体</span></span><br><span class="line">   +<span class="number">0x01c</span> EnvironmentPointer : Ptr32 Void</span><br><span class="line">   +<span class="number">0x020</span> ClientId         : _CLIENT_ID    <span class="comment">//内嵌_CLIENT_ID结构，内含进程id和线程id</span></span><br><span class="line">   +<span class="number">0x028</span> ActiveRpcHandle  : Ptr32 Void</span><br><span class="line">   +<span class="number">0x02c</span> ThreadLocalStoragePointer : Ptr32 Void</span><br><span class="line">   +<span class="number">0x030</span> ProcessEnvironmentBlock : Ptr32 _PEB             <span class="comment">//重要成员，进程PEB</span></span><br><span class="line">   +<span class="number">0x034</span> LastErrorValue   : Uint4B		<span class="comment">//上个错误号</span></span><br><span class="line">   +<span class="number">0x038</span> CountOfOwnedCriticalSections : Uint4B</span><br><span class="line">   +<span class="number">0x03c</span> CsrClientThread  : Ptr32 Void</span><br><span class="line">   +<span class="number">0x040</span> Win32ThreadInfo  : Ptr32 Void</span><br><span class="line">   +<span class="number">0x044</span> User32Reserved   : [<span class="number">26</span>] Uint4B</span><br><span class="line">   +<span class="number">0x0ac</span> UserReserved     : [<span class="number">5</span>] Uint4B</span><br><span class="line">   +<span class="number">0x0c0</span> WOW32Reserved    : Ptr32 Void</span><br><span class="line">   +<span class="number">0x0c4</span> CurrentLocale    : Uint4B</span><br><span class="line">   +<span class="number">0x0c8</span> FpSoftwareStatusRegister : Uint4B</span><br><span class="line">   +<span class="number">0x0cc</span> SystemReserved1  : [<span class="number">54</span>] Ptr32 Void</span><br><span class="line">   +<span class="number">0x1a4</span> ExceptionCode    : Int4B</span><br><span class="line">   +<span class="number">0x1a8</span> ActivationContextStack : _ACTIVATION_CONTEXT_STACK</span><br><span class="line">   +<span class="number">0x1bc</span> SpareBytes1      : [<span class="number">24</span>] UChar</span><br><span class="line">   +<span class="number">0x1d4</span> GdiTebBatch      : _GDI_TEB_BATCH</span><br><span class="line">   +<span class="number">0x6b4</span> RealClientId     : _CLIENT_ID</span><br><span class="line">   +<span class="number">0x6bc</span> GdiCachedProcessHandle : Ptr32 Void</span><br><span class="line">   +<span class="number">0x6c0</span> GdiClientPID     : Uint4B</span><br><span class="line">   +<span class="number">0x6c4</span> GdiClientTID     : Uint4B</span><br><span class="line">   +<span class="number">0x6c8</span> GdiThreadLocalInfo : Ptr32 Void</span><br><span class="line">   +<span class="number">0x6cc</span> Win32ClientInfo  : [<span class="number">62</span>] Uint4B</span><br><span class="line">   +<span class="number">0x7c4</span> glDispatchTable  : [<span class="number">233</span>] Ptr32 Void</span><br><span class="line">   +<span class="number">0xb68</span> glReserved1      : [<span class="number">29</span>] Uint4B</span><br><span class="line">   +<span class="number">0xbdc</span> glReserved2      : Ptr32 Void</span><br><span class="line">   +<span class="number">0xbe0</span> glSectionInfo    : Ptr32 Void</span><br><span class="line">   +<span class="number">0xbe4</span> glSection        : Ptr32 Void</span><br><span class="line">   +<span class="number">0xbe8</span> glTable          : Ptr32 Void</span><br><span class="line">   +<span class="number">0xbec</span> glCurrentRC      : Ptr32 Void</span><br><span class="line">   +<span class="number">0xbf0</span> glContext        : Ptr32 Void</span><br><span class="line">   +<span class="number">0xbf4</span> LastStatusValue  : Uint4B</span><br><span class="line">   +<span class="number">0xbf8</span> StaticUnicodeString : _UNICODE_STRING</span><br><span class="line">   +<span class="number">0xc00</span> StaticUnicodeBuffer : [<span class="number">261</span>] Uint2B</span><br><span class="line">   +<span class="number">0xe0c</span> DeallocationStack : Ptr32 Void</span><br><span class="line">   +<span class="number">0xe10</span> TlsSlots         : [<span class="number">64</span>] Ptr32 Void                  <span class="comment">//TLS值 是个数组[64]</span></span><br><span class="line">   +<span class="number">0xf10</span> TlsLinks         : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0xf18</span> Vdm              : Ptr32 Void</span><br><span class="line">   +<span class="number">0xf1c</span> ReservedForNtRpc : Ptr32 Void</span><br><span class="line">   +<span class="number">0xf20</span> DbgSsReserved    : [<span class="number">2</span>] Ptr32 Void</span><br><span class="line">   +<span class="number">0xf28</span> HardErrorsAreDisabled : Uint4B</span><br><span class="line">   +<span class="number">0xf2c</span> Instrumentation  : [<span class="number">16</span>] Ptr32 Void</span><br><span class="line">   +<span class="number">0xf6c</span> WinSockData      : Ptr32 Void</span><br><span class="line">   +<span class="number">0xf70</span> GdiBatchCount    : Uint4B</span><br><span class="line">   +<span class="number">0xf74</span> InDbgPrint       : UChar</span><br><span class="line">   +<span class="number">0xf75</span> FreeStackOnTermination : UChar</span><br><span class="line">   +<span class="number">0xf76</span> HasFiberData     : UChar</span><br><span class="line">   +<span class="number">0xf77</span> IdealProcessor   : UChar</span><br><span class="line">   +<span class="number">0xf78</span> Spare3           : Uint4B</span><br><span class="line">   +<span class="number">0xf7c</span> ReservedForPerf  : Ptr32 Void</span><br><span class="line">   +<span class="number">0xf80</span> ReservedForOle   : Ptr32 Void</span><br><span class="line">   +<span class="number">0xf84</span> WaitingOnLoaderLock : Uint4B</span><br><span class="line">   +<span class="number">0xf88</span> Wx86Thread       : _Wx86ThreadState</span><br><span class="line">   +<span class="number">0xf94</span> TlsExpansionSlots : Ptr32 Ptr32 Void                <span class="comment">//TLS扩展值 是个数组[Ptr32]</span></span><br><span class="line">   +<span class="number">0xf98</span> ImpersonationLocale : Uint4B</span><br><span class="line">   +<span class="number">0xf9c</span> IsImpersonating  : Uint4B</span><br><span class="line">   +<span class="number">0xfa0</span> NlsCache         : Ptr32 Void</span><br><span class="line">   +<span class="number">0xfa4</span> pShimData        : Ptr32 Void</span><br><span class="line">   +<span class="number">0xfa8</span> HeapVirtualAffinity : Uint4B</span><br><span class="line">   +<span class="number">0xfac</span> CurrentTransactionHandle : Ptr32 Void</span><br><span class="line">   +<span class="number">0xfb0</span> ActiveFrame      : Ptr32 _TEB_ACTIVE_FRAME</span><br><span class="line">   +<span class="number">0xfb4</span> SafeThunkCall    : UChar</span><br><span class="line">   +<span class="number">0xfb5</span> BooleanSpare     : [<span class="number">3</span>] UChar</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重要结构使用说明</span></span><br><span class="line">FS:[<span class="number">000</span>]   指向SEH链指针</span><br><span class="line">FS:[<span class="number">004</span>]  线程堆栈顶部</span><br><span class="line">FS:[<span class="number">008</span>] 线程堆栈底部</span><br><span class="line">FS:[<span class="number">00</span>C]  SubSystemTib</span><br><span class="line">FS:[<span class="number">010</span>]  FiberData</span><br><span class="line">FS:[<span class="number">014</span>] ArbitraryUserPointer</span><br><span class="line">FS:[<span class="number">018</span>]  指向TEB自身</span><br><span class="line">FS:[<span class="number">020</span>] 进程PID</span><br><span class="line">FS:[<span class="number">024</span>] 线程ID</span><br><span class="line">FS:[<span class="number">02</span>C] 指向线程局部存储指针</span><br><span class="line">FS:[<span class="number">030</span>] PEB结构地址（进程结构）</span><br><span class="line">FS:[<span class="number">034</span>] 上个错误号</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210706131700275.png" alt="image-20210706131700275"></p>
<h4 id="NtTib成员"><a href="#NtTib成员" class="headerlink" title="NtTib成员"></a>NtTib成员</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NtTib成员</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>	<span class="title class_">_NT_TIB</span>&#123;</span><br><span class="line">	 <span class="keyword">struct</span>	<span class="title class_">_EXCEPTION_REGISTRATION_RECORD</span> *ExceptionList;<span class="comment">//指向_EXCEPTION_REGISTRATION_RECORD结构体组成的链表，它用于WindowsOS的SEH， SEH是Wiondows操作系统中的结构化异常处理机制，常用于反调试技术。</span></span><br><span class="line">	 PVOID StackBase;</span><br><span class="line">	 PVOID StackLimit; </span><br><span class="line">	 PVOID SubSystemTib; </span><br><span class="line">	 <span class="keyword">union</span> &#123;</span><br><span class="line">		PVOID FiberData; </span><br><span class="line">		DWORD Version;</span><br><span class="line">	 &#125;; </span><br><span class="line">	 PVOID ArbitraryUserPointer;</span><br><span class="line"> 	 <span class="keyword">struct</span>	<span class="title class_">_NT_TIB</span> *Self;<span class="comment">//Self成员是_NT_TIB结构体的自引用指针，它指向_NT_TIB结构体，又因为_NT_TIB是TEB结构体的第一个成员，所以它也是指向TEB结构体的指针（它里面存着TEB结构体的地址）。</span></span><br><span class="line">&#125; NT_TIB;</span><br><span class="line"><span class="keyword">typedef</span> NT_TIB *PNT_TIB;</span><br><span class="line"><span class="comment">//===============偏移详解=============</span></span><br><span class="line">ntdll!_NT_TIB</span><br><span class="line">   +<span class="number">0x000</span> ExceptionList    : Ptr32 _EXCEPTION_REGISTRATION_RECORD　　<span class="comment">//当前线程内核异常链表(SEH)</span></span><br><span class="line">   +<span class="number">0x004</span> StackBase        : Ptr32 Void　　　　　　　　　　　　　　　　　 <span class="comment">//当前线程内核的基址（当前线程栈底）</span></span><br><span class="line">   +<span class="number">0x008</span> StackLimit       : Ptr32 Void　　　　　　　　　　　　　　　　　 <span class="comment">//当前线程内核的大小（当前线程最高允许的栈顶）</span></span><br><span class="line">   +<span class="number">0x00c</span> SubSystemTib     : Ptr32 Void</span><br><span class="line">   +<span class="number">0x010</span> FiberData        : Ptr32 Void</span><br><span class="line">   +<span class="number">0x010</span> Version          : Uint4B</span><br><span class="line">   +<span class="number">0x014</span> ArbitraryUserPointer : Ptr32 Void</span><br><span class="line">   +<span class="number">0x018</span> Self             : Ptr32 _NT_TIB　　　　　　　　　　　　　　　 <span class="comment">//指向自己头部，目的为了方便查找</span></span><br></pre></td></tr></table></figure>

<p>_CLIENT_ID成员</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _CLIENT_ID</span><br><span class="line">nt! CLIENT_ID</span><br><span class="line">    +<span class="number">0x000</span> UniqueProcess  : Ptr32 Void<span class="comment">//当前线程所属的进程ID</span></span><br><span class="line">    +<span class="number">0x004</span> UniqueThread   : Ptr32 Void<span class="comment">//当前线程ID</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>32位系统FS三环时指向TEB，零环时用KPCR，而<strong>64位系统三环时用GS指向TEB</strong>，零环时GS指向KPCR（之前32位windows下根本没用过GS），也就是说，在64位下不再用FS指向KPCR和TEB，64位下用GS取代了FS，FS则继续留给32位程序继续用</p>
</blockquote>
<h3 id="PEB"><a href="#PEB" class="headerlink" title="PEB"></a>PEB</h3><p>《2》PEB（Process Environment Block，进程环境块）存放进程信息，每个进程都有自己的PEB信息，TEB偏移0x30的位置就是当前进程的PEB<br>$$<br>mov\ \ eax,fs:[0x30]<br>$$<br>不同的windows版本中TEB结构会不同</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_PEB</span> &#123;               <span class="comment">// Size: 0x1D8</span></span><br><span class="line">    <span class="number">000</span>h    UCHAR           InheritedAddressSpace;</span><br><span class="line">    <span class="number">001</span>h    UCHAR           ReadImageFileExecOptions;</span><br><span class="line">    <span class="comment">//下面参数标识当前进程是否处于调试状态，Kernel32.dll中的IsDebuggerPresent() API就是用来获取该处的值的（是，则返回1；否，则返回0）。【破解之法】只要借助OllyDbg调试器的编辑功能，将PEB.BeingDebugged的值修改为0（FALSE）即可。</span></span><br><span class="line">    <span class="number">002</span>h    UCHAR           BeingDebugged;      <span class="comment">//Debug运行标志(可用于反调试技术)，只要该进程被调试就会被置1</span></span><br><span class="line">    <span class="number">003</span>h    UCHAR           SpareBool;</span><br><span class="line">    <span class="number">004</span>h    HANDLE          Mutant;</span><br><span class="line">    <span class="number">008</span>h    HINSTANCE       ImageBaseAddress;  <span class="comment">//程序加载的基地址</span></span><br><span class="line">    <span class="number">00</span>Ch    <span class="keyword">struct</span> <span class="title class_">_PEB_LDR_DATA</span>    *Ldr    <span class="comment">//Ptr32 指向_PEB_LDR_DATA结构体，记录了程序包含哪些模块(可用于反调试技术)</span></span><br><span class="line">    <span class="number">010</span>h    <span class="keyword">struct</span> <span class="title class_">_RTL_USER_PROCESS_PARAMETERS</span>  *ProcessParameters;</span><br><span class="line">    <span class="number">014</span>h    ULONG           SubSystemData;</span><br><span class="line">    <span class="number">018</span>h    HANDLE          DefaultHeap;    <span class="comment">//(可用于反调试技术)</span></span><br><span class="line">    <span class="number">01</span>Ch    KSPIN_LOCK      FastPebLock;</span><br><span class="line">    <span class="number">020</span>h    ULONG           FastPebLockRoutine;</span><br><span class="line">    <span class="number">024</span>h    ULONG           FastPebUnlockRoutine;</span><br><span class="line">    <span class="number">028</span>h    ULONG           EnvironmentUpdateCount;</span><br><span class="line">    <span class="number">02</span>Ch    ULONG           KernelCallbackTable;</span><br><span class="line">    <span class="number">030</span>h    LARGE_INTEGER   SystemReserved;</span><br><span class="line">    <span class="number">038</span>h    <span class="keyword">struct</span> <span class="title class_">_PEB_FREE_BLOCK</span>  *FreeList</span><br><span class="line">    <span class="number">03</span>Ch    ULONG           TlsExpansionCounter;</span><br><span class="line">    <span class="number">040</span>h    ULONG           TlsBitmap;</span><br><span class="line">    <span class="number">044</span>h    LARGE_INTEGER   TlsBitmapBits;</span><br><span class="line">    <span class="number">04</span>Ch    ULONG           ReadOnlySharedMemoryBase;</span><br><span class="line">    <span class="number">050</span>h    ULONG           ReadOnlySharedMemoryHeap;</span><br><span class="line">    <span class="number">054</span>h    ULONG           ReadOnlyStaticServerData;</span><br><span class="line">    <span class="number">058</span>h    ULONG           AnsiCodePageData;</span><br><span class="line">    <span class="number">05</span>Ch    ULONG           OemCodePageData;</span><br><span class="line">    <span class="number">060</span>h    ULONG           UnicodeCaseTableData;</span><br><span class="line">    <span class="number">064</span>h    ULONG           NumberOfProcessors;</span><br><span class="line">    <span class="number">068</span>h    LARGE_INTEGER   NtGlobalFlag;               <span class="comment">// Address of a local copy(可用于反调试技术)</span></span><br><span class="line">    <span class="number">070</span>h    LARGE_INTEGER   CriticalSectionTimeout;</span><br><span class="line">    <span class="number">078</span>h    ULONG           HeapSegmentReserve;</span><br><span class="line">    <span class="number">07</span>Ch    ULONG           HeapSegmentCommit;</span><br><span class="line">    <span class="number">080</span>h    ULONG           HeapDeCommitTotalFreeThreshold;</span><br><span class="line">    <span class="number">084</span>h    ULONG           HeapDeCommitFreeBlockThreshold;</span><br><span class="line">    <span class="number">088</span>h    ULONG           NumberOfHeaps;</span><br><span class="line">    <span class="number">08</span>Ch    ULONG           MaximumNumberOfHeaps;</span><br><span class="line">    <span class="number">090</span>h    ULONG           ProcessHeaps;</span><br><span class="line">    <span class="number">094</span>h    ULONG           GdiSharedHandleTable;</span><br><span class="line">    <span class="number">098</span>h    ULONG           ProcessStarterHelper;</span><br><span class="line">    <span class="number">09</span>Ch    ULONG           GdiDCAttributeList;</span><br><span class="line">    <span class="number">0</span>A0h    KSPIN_LOCK      LoaderLock;</span><br><span class="line">    <span class="number">0</span>A4h    ULONG           OSMajorVersion;</span><br><span class="line">    <span class="number">0</span>A8h    ULONG           OSMinorVersion;</span><br><span class="line">    <span class="number">0</span>ACh    USHORT          OSBuildNumber;</span><br><span class="line">    <span class="number">0</span>AEh    USHORT          OSCSDVersion;</span><br><span class="line">    <span class="number">0B</span>0h    ULONG           OSPlatformId;</span><br><span class="line">    <span class="number">0B</span>4h    ULONG           ImageSubsystem;</span><br><span class="line">    <span class="number">0B</span>8h    ULONG           ImageSubsystemMajorVersion;</span><br><span class="line">    <span class="number">0B</span>Ch    ULONG           ImageSubsystemMinorVersion;</span><br><span class="line">    <span class="number">0</span>C0h    ULONG           ImageProcessAffinityMask;</span><br><span class="line">    <span class="number">0</span>C4h    ULONG           GdiHandleBuffer[<span class="number">0x22</span>];</span><br><span class="line">    <span class="number">14</span>Ch    ULONG           PostProcessInitRoutine;</span><br><span class="line">    <span class="number">150</span>h    ULONG           TlsExpansionBitmap;</span><br><span class="line">    <span class="number">154</span>h    UCHAR           TlsExpansionBitmapBits[<span class="number">0x80</span>];</span><br><span class="line">    <span class="number">1</span>D4h    ULONG           SessionId;</span><br><span class="line">&#125; PEB, *PPEB;</span><br></pre></td></tr></table></figure>

<h4 id="PEB-LDR-DATA"><a href="#PEB-LDR-DATA" class="headerlink" title="_PEB_LDR_DATA"></a>_PEB_LDR_DATA</h4><p>PEB loader data 进程环境块装载机信息</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_PEB_LDR_DATA</span></span><br><span class="line">&#123;</span><br><span class="line">　ULONG         Length;                             <span class="comment">// 00h</span></span><br><span class="line">　BOOLEAN       Initialized;                        <span class="comment">// 04h</span></span><br><span class="line">　PVOID         SsHandle;                           <span class="comment">// 08h</span></span><br><span class="line">　LIST_ENTRY    InLoadOrderModuleList;              <span class="comment">// 0ch，加载的时候按顺序有哪些模块的双向链表</span></span><br><span class="line">　LIST_ENTRY    InMemoryOrderModuleList;            <span class="comment">// 14h,加载完了后在内存中有哪些模块的双向链表</span></span><br><span class="line">　LIST_ENTRY    InInitializationOrderModuleList;    <span class="comment">// 1ch，按模块初始化顺序存的双向链表</span></span><br><span class="line">&#125;PEB_LDR_DATA,*PPEB_LDR_DATA;                       <span class="comment">// 24h</span></span><br></pre></td></tr></table></figure>

<h5 id="LIST-ENTRY"><a href="#LIST-ENTRY" class="headerlink" title="LIST_ENTRY"></a>LIST_ENTRY</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nt!_LIST_ENTRY</span><br><span class="line">   +<span class="number">0x000</span>   Flink       : Ptr32 _LIST_ENTRY     <span class="comment">//表示从前往后</span></span><br><span class="line">   +<span class="number">0x004</span>   Blink       : Ptr32 _LIST_ENTRY     <span class="comment">//表示从后往前</span></span><br><span class="line"><span class="comment">//该结构本身就提供了（不需要自己写）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_LIST_ENTRY</span> &#123;</span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">_LIST_ENTRY</span> *Flink;</span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">_LIST_ENTRY</span> *Blink;</span><br><span class="line">&#125; LIST_ENTRY, *PLIST_ENTRY, *RESTRICTED_POINTER PRLIST_ENTRY;</span><br></pre></td></tr></table></figure>

<p>链表中保存的是_LDR_DATA_TABLE_ENTRY结构体的信息，给结构体如下。</p>
<h5 id="LDR-DATA-TABLE-ENTRY"><a href="#LDR-DATA-TABLE-ENTRY" class="headerlink" title="_LDR_DATA_TABLE_ENTRY"></a>_LDR_DATA_TABLE_ENTRY</h5><p>该结构未导出,需要自己定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//x86</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_LDR_DATA_TABLE_ENTRY</span></span><br><span class="line">&#123;</span><br><span class="line">LIST_ENTRY InLoadOrderLinks;<span class="comment">//代表按加载顺序构成的模块双向链表</span></span><br><span class="line">LIST_ENTRY InMemoryOrderLinks;<span class="comment">//代表按内存顺序构成的模块双向链表</span></span><br><span class="line">LIST_ENTRY InInitializationOrderLinks;<span class="comment">//代表按初始化顺序构成的模块双向链表</span></span><br><span class="line">PVOID      DllBase;<span class="comment">//该模块的基地址</span></span><br><span class="line">PVOID      EntryPoint;<span class="comment">//该模块的入口</span></span><br><span class="line">ULONG32    SizeOfImage;<span class="comment">//该模块的映像大小</span></span><br><span class="line">UNICODE_STRING FullDllName;<span class="comment">//内嵌包含路径的模块名的结构体</span></span><br><span class="line">UNICODE_STRING BaseDllName;<span class="comment">//内嵌不包含路径的模块名的结构体</span></span><br><span class="line">UINT32   Unknow[<span class="number">17</span>];</span><br><span class="line"></span><br><span class="line">&#125;LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//x64</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_LDR_DATA_TABLE_ENTRY</span></span><br><span class="line">&#123;</span><br><span class="line">LIST_ENTRY InLoadOrderLinks;</span><br><span class="line">LIST_ENTRY InMemoryOrderLinks;</span><br><span class="line">LIST_ENTRY InInitializationOrderLinks;</span><br><span class="line">PVOID      DllBase;</span><br><span class="line">PVOID      EntryPoint;</span><br><span class="line">ULONG32    SizeOfImage;</span><br><span class="line">UINT8      Unknow0[<span class="number">0x4</span>];</span><br><span class="line">UNICODE_STRING FullDllName;</span><br><span class="line">UNICODE_STRING BaseDllName;</span><br><span class="line">&#125;LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Windows XP Professional Service Pack <span class="number">3</span> (x86) (<span class="number">5.1</span>, Build <span class="number">2600</span>)</span><br><span class="line"></span><br><span class="line">lkd&gt; dt -b _LDR_DATA_TABLE_ENTRY</span><br><span class="line">nt!_LDR_DATA_TABLE_ENTRY</span><br><span class="line">   +<span class="number">0x000</span> InLoadOrderLinks : _LIST_ENTRY<span class="comment">//代表按加载顺序构成的模块双向链表</span></span><br><span class="line">      +<span class="number">0x000</span> Flink            : Ptr32 </span><br><span class="line">      +<span class="number">0x004</span> Blink            : Ptr32 </span><br><span class="line">   +<span class="number">0x008</span> InMemoryOrderLinks : _LIST_ENTRY<span class="comment">//代表按内存顺序构成的模块双向链表</span></span><br><span class="line">      +<span class="number">0x000</span> Flink            : Ptr32 </span><br><span class="line">      +<span class="number">0x004</span> Blink            : Ptr32 </span><br><span class="line">   +<span class="number">0x010</span> InInitializationOrderLinks : _LIST_ENTRY<span class="comment">//代表按初始化顺序构成的模块双向链表</span></span><br><span class="line">      +<span class="number">0x000</span> Flink            : Ptr32 </span><br><span class="line">      +<span class="number">0x004</span> Blink            : Ptr32 </span><br><span class="line">   +<span class="number">0x018</span> DllBase          : Ptr32 <span class="comment">//该模块的基地址</span></span><br><span class="line">   +<span class="number">0x01c</span> EntryPoint       : Ptr32  <span class="comment">//该模块的入口</span></span><br><span class="line">   +<span class="number">0x020</span> SizeOfImage      : Uint4B	<span class="comment">//该模块的映像大小</span></span><br><span class="line">   +<span class="number">0x024</span> FullDllName      : _UNICODE_STRING <span class="comment">//内嵌包含路径的模块名的结构体</span></span><br><span class="line">      +<span class="number">0x000</span> Length           : Uint2B</span><br><span class="line">      +<span class="number">0x002</span> MaximumLength    : Uint2B</span><br><span class="line">      +<span class="number">0x004</span> Buffer           : Ptr32 </span><br><span class="line">   +<span class="number">0x02c</span> BaseDllName      : _UNICODE_STRING <span class="comment">//内嵌不包含路径的模块名的结构体</span></span><br><span class="line">      +<span class="number">0x000</span> Length           : Uint2B</span><br><span class="line">      +<span class="number">0x002</span> MaximumLength    : Uint2B</span><br><span class="line">      +<span class="number">0x004</span> Buffer           : Ptr32 </span><br><span class="line">   +<span class="number">0x034</span> Flags            : Uint4B</span><br><span class="line">   +<span class="number">0x038</span> LoadCount        : Uint2B	<span class="comment">//该模块的引用次数</span></span><br><span class="line">   +<span class="number">0x03a</span> TlsIndex         : Uint2B</span><br><span class="line">   +<span class="number">0x03c</span> HashLinks        : _LIST_ENTRY</span><br><span class="line">      +<span class="number">0x000</span> Flink            : Ptr32 </span><br><span class="line">      +<span class="number">0x004</span> Blink            : Ptr32 </span><br><span class="line">   +<span class="number">0x03c</span> SectionPointer   : Ptr32 </span><br><span class="line">   +<span class="number">0x040</span> CheckSum         : Uint4B</span><br><span class="line">   +<span class="number">0x044</span> TimeDateStamp    : Uint4B</span><br><span class="line">   +<span class="number">0x044</span> LoadedImports    : Ptr32 </span><br><span class="line">   +<span class="number">0x048</span> EntryPointActivationContext : Ptr32 </span><br><span class="line">   +<span class="number">0x04c</span> PatchInformation : Ptr32</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">@Windows <span class="number">7</span> <span class="built_in">Ultimate</span> (x64) (<span class="number">6.1</span>, Build <span class="number">7600</span>)</span><br><span class="line"></span><br><span class="line">lkd&gt; dt -b _LDR_DATA_TABLE_ENTRY</span><br><span class="line">nt!_LDR_DATA_TABLE_ENTRY</span><br><span class="line">   +<span class="number">0x000</span> InLoadOrderLinks : _LIST_ENTRY</span><br><span class="line">      +<span class="number">0x000</span> Flink            : Ptr64 </span><br><span class="line">      +<span class="number">0x008</span> Blink            : Ptr64 </span><br><span class="line">   +<span class="number">0x010</span> InMemoryOrderLinks : _LIST_ENTRY</span><br><span class="line">      +<span class="number">0x000</span> Flink            : Ptr64 </span><br><span class="line">      +<span class="number">0x008</span> Blink            : Ptr64 </span><br><span class="line">   +<span class="number">0x020</span> InInitializationOrderLinks : _LIST_ENTRY</span><br><span class="line">      +<span class="number">0x000</span> Flink            : Ptr64 </span><br><span class="line">      +<span class="number">0x008</span> Blink            : Ptr64 </span><br><span class="line">   +<span class="number">0x030</span> DllBase          : Ptr64 </span><br><span class="line">   +<span class="number">0x038</span> EntryPoint       : Ptr64 </span><br><span class="line">   +<span class="number">0x040</span> SizeOfImage      : Uint4B</span><br><span class="line">   +<span class="number">0x048</span> FullDllName      : _UNICODE_STRING</span><br><span class="line">      +<span class="number">0x000</span> Length           : Uint2B</span><br><span class="line">      +<span class="number">0x002</span> MaximumLength    : Uint2B</span><br><span class="line">      +<span class="number">0x008</span> Buffer           : Ptr64 </span><br><span class="line">   +<span class="number">0x058</span> BaseDllName      : _UNICODE_STRING</span><br><span class="line">      +<span class="number">0x000</span> Length           : Uint2B</span><br><span class="line">      +<span class="number">0x002</span> MaximumLength    : Uint2B</span><br><span class="line">      +<span class="number">0x008</span> Buffer           : Ptr64 </span><br><span class="line">   +<span class="number">0x068</span> Flags            : Uint4B</span><br><span class="line">   +<span class="number">0x06c</span> LoadCount        : Uint2B</span><br><span class="line">   +<span class="number">0x06e</span> TlsIndex         : Uint2B</span><br><span class="line">   +<span class="number">0x070</span> HashLinks        : _LIST_ENTRY</span><br><span class="line">      +<span class="number">0x000</span> Flink            : Ptr64 </span><br><span class="line">      +<span class="number">0x008</span> Blink            : Ptr64 </span><br><span class="line">   +<span class="number">0x070</span> SectionPointer   : Ptr64 </span><br><span class="line">   +<span class="number">0x078</span> CheckSum         : Uint4B</span><br><span class="line">   +<span class="number">0x080</span> TimeDateStamp    : Uint4B</span><br><span class="line">   +<span class="number">0x080</span> LoadedImports    : Ptr64 </span><br><span class="line">   +<span class="number">0x088</span> EntryPointActivationContext : Ptr64 </span><br><span class="line">   +<span class="number">0x090</span> PatchInformation : Ptr64 </span><br><span class="line">   +<span class="number">0x098</span> ForwarderLinks   : _LIST_ENTRY</span><br><span class="line">      +<span class="number">0x000</span> Flink            : Ptr64 </span><br><span class="line">      +<span class="number">0x008</span> Blink            : Ptr64 </span><br><span class="line">   +<span class="number">0x0a8</span> ServiceTagLinks  : _LIST_ENTRY</span><br><span class="line">      +<span class="number">0x000</span> Flink            : Ptr64 </span><br><span class="line">      +<span class="number">0x008</span> Blink            : Ptr64 </span><br><span class="line">   +<span class="number">0x0b8</span> StaticLinks      : _LIST_ENTRY</span><br><span class="line">      +<span class="number">0x000</span> Flink            : Ptr64 </span><br><span class="line">      +<span class="number">0x008</span> Blink            : Ptr64 </span><br><span class="line">   +<span class="number">0x0c8</span> ContextInformation : Ptr64 </span><br><span class="line">   +<span class="number">0x0d0</span> OriginalBase     : Uint8B</span><br><span class="line">   +<span class="number">0x0d8</span> LoadTime         : _LARGE_INTEGER</span><br><span class="line">      +<span class="number">0x000</span> LowPart          : Uint4B</span><br><span class="line">      +<span class="number">0x004</span> HighPart         : Int4B</span><br><span class="line">      +<span class="number">0x000</span> u                : &lt;unnamed-tag&gt;</span><br><span class="line">         +<span class="number">0x000</span> LowPart          : Uint4B</span><br><span class="line">         +<span class="number">0x004</span> HighPart         : Int4B</span><br><span class="line">      +<span class="number">0x000</span> QuadPart         : Int8B</span><br></pre></td></tr></table></figure>

<p>每个加载到进程中的DLL模块都对应一个_LDR_DATA_TABLE_ENTRY结构体，这些结构体相互链接，最终形成了_LIST_ENTRY双向链表。_PEB_LDR_DATA结构体中存在3种_LIST_ENTRY双向链表，也就是说，存在多个_LDR_DATA_TABLE_ENTRY结构体，并且有三种链接方法可以将它们链接起来。</p>
<p>结构示意图：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210707145837215.png" alt="image-20210707145837215"></p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210707150201266.png" alt="image-20210707150201266"></p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210707150256851.png" alt="image-20210707150256851"></p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210707153018376.png" alt="image-20210707153018376"></p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210707153029369.png" alt="image-20210707153029369"></p>
<p>上面的图实际上都不是那么准确，下面这张图才是真正的结构。</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210707155954691.png" alt="image-20210707155954691"></p>
<h6 id="UNICODE-STRING的定义"><a href="#UNICODE-STRING的定义" class="headerlink" title="_UNICODE_STRING的定义"></a>_UNICODE_STRING的定义</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_UNICODE_STRING</span></span><br><span class="line">&#123;</span><br><span class="line">	USHORT Length;</span><br><span class="line">	USHORT MaximumLength;</span><br><span class="line">	PWSTR Buffer;</span><br><span class="line">&#125;UNICODE_STRING,*PUNICOID_STRING;</span><br></pre></td></tr></table></figure>

<h5 id="DefaultHeap与NtGlobalFlag反调试相关（只对XP有效）"><a href="#DefaultHeap与NtGlobalFlag反调试相关（只对XP有效）" class="headerlink" title="DefaultHeap与NtGlobalFlag反调试相关（只对XP有效）"></a>DefaultHeap与NtGlobalFlag反调试相关（只对XP有效）</h5><p>EB.ProcessHeap与PEB.NtGlobalFlag成员（像PEB.BeingDebugged成员一样）应用于反调试技术。若进程处于调试状态，则ProcessHeap与NtGlobalFlag成员就持有特定值。由于它们具有这一个特征，所以常常应用于反调试技术。<br>PEB.ProcessHeap成员是指向HEAP结构体的指针，HEAP结构体如下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+<span class="number">0</span>×<span class="number">000</span> Entry	:_HEAP_ENTRY</span><br><span class="line">+<span class="number">0</span>×<span class="number">008</span> Signature	:Uint4B</span><br><span class="line">+<span class="number">0</span>×<span class="number">00</span>c Flags	:Uint4B</span><br><span class="line">+<span class="number">0</span>×<span class="number">010</span> ForceFlags	:Uint4B</span><br><span class="line">+<span class="number">0</span>×<span class="number">014</span> VirtualMemoryThreshold 	:Uint4B</span><br><span class="line">+<span class="number">0</span>×<span class="number">018</span> SegmentReserve	:Uint4B</span><br><span class="line">+<span class="number">0</span>×<span class="number">01</span>c SegmentCommit	:Uint4B</span><br><span class="line">+<span class="number">0</span>×<span class="number">020</span> DeCommitFreeBlockThreshold	 :Uint4B</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>进程处于被调试状态时，Flags(+0xC)与Force Flags(+ox10)成员被设置成特定的值。<br>PEB.ProcessHeap（PEB结构体中偏移0x18的位置）成员既可以从PEB结构体中直接获得，也可以通过GetProcessHeap() API获得。</p>
<p><strong>当进程运行正常时Heap.Flagsh成员的值为0x2,Heap. ForceFlags成员的值位0x0，进程处于被调试状态时这些值也会随之改变</strong></p>
<p><strong>破解之法</strong><br>只要将HEAP.Flags与HEAP.ForceFlags的值重新设置为2与0即可（HEAP.Flags&#x3D;2，HEAP.ForceFlags&#x3D;0）。<br>注意：该方法仅在WindowsXP系统中有效，Windows7系统不存在以上特征。此外，将运行中的进程附加到调试器时，也不会出现上述特征。</p>
<h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WinTool::hideModuleByCutLink32</span><span class="params">(LPTSTR szModuleName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//取ldr成员</span></span><br><span class="line">	_PEB_LDR_DATA* ldr;</span><br><span class="line">	_LIST_ENTRY* head, *cur;<span class="comment">//头尾指针</span></span><br><span class="line">	LDR_DATA_TABLE_ENTRY* ldm;</span><br><span class="line">	<span class="comment">//通过模块句柄来确定遍历的时候找到当前模块</span></span><br><span class="line">	HMODULE hMod = <span class="built_in">GetModuleHandle</span>(szModuleName);</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		mov eax,fs:[<span class="number">0x30</span>]</span><br><span class="line">		mov eax,[eax+<span class="number">0x0C</span>]</span><br><span class="line">		mov ldr,eax</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//取头和尾指针</span></span><br><span class="line">	head = &amp;(ldr-&gt;InLoadOrderModuleList);</span><br><span class="line">	cur = head-&gt;Flink;</span><br><span class="line">	<span class="comment">//遍历链表</span></span><br><span class="line">	<span class="keyword">do</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//宏 CONTAINING_RECORD 根据结构体中的某成员的地址来推算出该结构体整体的地址</span></span><br><span class="line">		ldm = <span class="built_in">CONTAINING_RECORD</span>(cur, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);</span><br><span class="line">		<span class="keyword">if</span> (hMod == ldm-&gt;DllBase)<span class="comment">//模块句柄就是内存中模块的地址</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//找到了，进行断链操作</span></span><br><span class="line">			ldm-&gt;InLoadOrderLinks.Blink-&gt;Flink = ldm-&gt;InLoadOrderLinks.Flink;</span><br><span class="line">			ldm-&gt;InLoadOrderLinks.Flink-&gt;Blink = ldm-&gt;InLoadOrderLinks.Blink;</span><br><span class="line">			ldm-&gt;InInitializationOrderLinks.Blink-&gt;Flink = ldm-&gt;InInitializationOrderLinks.Flink;</span><br><span class="line">			ldm-&gt;InInitializationOrderLinks.Flink-&gt;Blink = ldm-&gt;InInitializationOrderLinks.Blink;</span><br><span class="line">			ldm-&gt;InMemoryOrderLinks.Blink-&gt;Flink = ldm-&gt;InMemoryOrderLinks.Flink;</span><br><span class="line">			ldm-&gt;InMemoryOrderLinks.Flink-&gt;Blink = ldm-&gt;InMemoryOrderLinks.Blink;</span><br><span class="line">		&#125;</span><br><span class="line">		cur = cur-&gt;Flink;</span><br><span class="line">	&#125; <span class="keyword">while</span> (cur!=head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main函数</span></span><br><span class="line">WinTool myTool;</span><br><span class="line">myTool.<span class="built_in">showModuleFromPIDByAPI32</span>(<span class="built_in">GetCurrentProcessId</span>());</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;按任意键隐藏kernel32.dll模块&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="built_in">getchar</span>();</span><br><span class="line">myTool.<span class="built_in">hideModuleByCutLink32</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;kernel32.dll&quot;</span>));</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;隐藏成功&quot;</span>&lt;&lt;endl;</span><br><span class="line">myTool.<span class="built_in">showModuleFromPIDByAPI32</span>(<span class="built_in">GetCurrentProcessId</span>());</span><br><span class="line"><span class="built_in">getchar</span>();</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210706162954067.png" alt="image-20210706162954067"></p>
<h2 id="模块隐藏之VAD树"><a href="#模块隐藏之VAD树" class="headerlink" title="模块隐藏之VAD树"></a>模块隐藏之VAD树</h2><p>PEB中，断链只可以让API访问不到该module</p>
<p>但是VAD树是内核层访问的，依然可以在里面找到断链后的module</p>
<p><strong>即使VAD树也隐藏了自己想隐藏的模块，但是依然可以遍历内存搜索PE指纹。</strong></p>
<h2 id="试图模块彻底隐藏"><a href="#试图模块彻底隐藏" class="headerlink" title="试图模块彻底隐藏"></a>试图模块彻底隐藏</h2><p>通杀99%的隐藏模块的方法有三步：</p>
<ol>
<li>PEB断链指定模块信息</li>
<li>VAD树去除指定模块信息</li>
<li>找到内存中指定模块的位置，修改PE指纹（不会影响程序运行）</li>
</ol>
<p>上述操作相对简单的操作：先注入dll，再复制一份dll，再通过代码释放原来的dll，然后在原位置申请内存，再把复制的dll拷贝回去（就不需要重定位了）。再修改特征码，这样VAD树和PEB中就没有记录了</p>
<p>hook LoadLibrary三环和零环对应函数来检测是否有DLL被加载</p>
<p>最好的隐藏：无模块注入，也就是<strong>代码注入</strong>，连模块都没有。</p>
<p>代码注入的弊端：工作量特别大</p>
<h1 id="代码注入"><a href="#代码注入" class="headerlink" title="代码注入"></a>代码注入</h1><p>避免了所有模块的特征。</p>
<p>远线程执行CreateFileA系统函数的案例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CreateFileParam</span></span><br><span class="line">&#123;</span><br><span class="line">	LPVOID CreateFileAddress;<span class="comment">//CreateFileA函数地址</span></span><br><span class="line">	<span class="comment">//下面是CreateFileA需要用到的参数。</span></span><br><span class="line">    <span class="type">char</span> fileName[<span class="number">9</span>];</span><br><span class="line">	DWORD  dwDesiredAccess;</span><br><span class="line">	DWORD  dwShareMode;</span><br><span class="line">	LPSECURITY_ATTRIBUTES lpSecurityAttributes;</span><br><span class="line">	DWORD dwCreationDisposition;</span><br><span class="line">	DWORD dwFlagsAndAttributes;</span><br><span class="line">	HANDLE hTemplateFile;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myThreadCreateFileFunc</span><span class="params">(LPVOID pParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">typedef</span> <span class="title">HANDLE</span><span class="params">(*PCreateFile)</span><span class="params">(LPCSTR  lpFileName,</span></span></span><br><span class="line"><span class="params"><span class="function">		DWORD  dwDesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">		DWORD  dwShareMode,</span></span></span><br><span class="line"><span class="params"><span class="function">		LPSECURITY_ATTRIBUTES lpSecurityAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">		DWORD dwCreationDisposition,</span></span></span><br><span class="line"><span class="params"><span class="function">		DWORD dwFlagsAndAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">		HANDLE hTemplateFile)</span></span>;</span><br><span class="line">	CreateFileParam* tmpStruct = (CreateFileParam*)pParam;</span><br><span class="line">	PCreateFile createFileFunc = (PCreateFile)(tmpStruct-&gt;CreateFileAddress);</span><br><span class="line">	<span class="comment">//线程函数中调用MessageBoxA</span></span><br><span class="line">	(*createFileFunc)(tmpStruct-&gt;fileName, tmpStruct-&gt;dwDesiredAccess, tmpStruct-&gt;dwShareMode, tmpStruct-&gt;lpSecurityAttributes,tmpStruct-&gt;dwCreationDisposition,tmpStruct-&gt;dwFlagsAndAttributes,tmpStruct-&gt;hTemplateFile);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	WinTool myTool;</span><br><span class="line">	DWORD pid = myTool.<span class="built_in">getProcessIdByName</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;target.exe&quot;</span>));</span><br><span class="line">	<span class="comment">//往目标注入代码执行MessageBoxA函数</span></span><br><span class="line">	CreateFileParam param;</span><br><span class="line">	param.hTemplateFile = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memcpy</span>(param.fileName, <span class="string">&quot;C:\\A.txt&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;C:\\A.txt&quot;</span>)+<span class="number">1</span>);</span><br><span class="line">	param.dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL;</span><br><span class="line">	param.dwCreationDisposition = CREATE_NEW;</span><br><span class="line">	param.dwShareMode = <span class="literal">NULL</span>;</span><br><span class="line">	param.dwDesiredAccess = GENERIC_READ | GENERIC_WRITE;</span><br><span class="line">	HMODULE hModule=<span class="built_in">GetModuleHandleA</span>(<span class="string">&quot;kernel32.dll&quot;</span>);</span><br><span class="line">	LPVOID CreateFileAddress =<span class="built_in">GetProcAddress</span>(hModule, <span class="string">&quot;CreateFileA&quot;</span>);</span><br><span class="line">	param.CreateFileAddress = CreateFileAddress;</span><br><span class="line">	param.lpSecurityAttributes = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//存储参数(API需要用到的参数)</span></span><br><span class="line">	LPVOID targetParam=myTool.<span class="built_in">remoteInjectMemory</span>(pid, &amp;param, <span class="built_in">sizeof</span>(CreateFileParam));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//修正线程函数起始地址</span></span><br><span class="line">	DWORD realThreadFunc = (DWORD)myThreadCreateFileFunc;</span><br><span class="line">	<span class="keyword">if</span> (*(BYTE*)realThreadFunc ==<span class="number">0xE9</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		realThreadFunc = realThreadFunc + <span class="number">5</span> + *(DWORD*)(realThreadFunc + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> threadFuncSize = <span class="number">0x55</span>;<span class="comment">//手动算出线程函数的二字节大小</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//存储线程函数(线程函数本身)</span></span><br><span class="line">	LPVOID targetThreadFunc = myTool.<span class="built_in">remoteInjectMemory</span>(pid, (PVOID)realThreadFunc, threadFuncSize);</span><br><span class="line"></span><br><span class="line">	HANDLE hProcess=<span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS,<span class="literal">NULL</span>, pid);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//启动远线程</span></span><br><span class="line">	HANDLE hThread= <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)targetThreadFunc, targetParam, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">WaitForSingleObject</span>(hThread, INFINITE);</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;执行结束&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【注意】上面代码要把项目属性中的代码生成中的基本运行时检查选项设为默认值</p>
<p><strong>将函数转换成shellCode的时候要注意：</strong></p>
<p>上面的代码也可以实现代码注入，但是非常的<strong>繁琐</strong>，因此可以直接注入ShellCode</p>
<h2 id="注入ShellCode"><a href="#注入ShellCode" class="headerlink" title="注入ShellCode"></a>注入ShellCode</h2><p>什么是ShellCode？</p>
<p>ShellCode：<strong>不依赖环境，放到任何地方都可以执行的机器码</strong>。</p>
<p><strong>ShellCode的编写原则</strong>：</p>
<ol>
<li>不能有全局变量</li>
<li>不能使用常量字符串</li>
<li>不能使用系统调用（因为系统调用是间接调用，call的地址要等到exe启动的时候由操作系统根据导入表填写的）</li>
<li>不能嵌套调用其他函数（<strong>把整个模块按照ShellCode写过去</strong>，暂时还做不到）</li>
</ol>
<ul>
<li>Q：为什么不能使用系统调用</li>
<li>A：导入表要目标进程本身就使用了这个系统调用，而且目标进程的该系统调用间接存放点也要这么巧刚好是这个地址，才能使用系统调用。。。(概率几乎为0)</li>
</ul>
<p>解决上述痛点的方式：</p>
<ol>
<li><p>不写就解决了</p>
</li>
<li><p>用局部数组写字符串</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210607170623362.png" alt="image-20210607170623362"></p>
</li>
<li><p>因为调用其他PE的函数都是采用间接CALL的调用方式，实际上是由编译器填写的。系统调用都是在其他DLL中的，所以ShellCode中不能使用系统调用。</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210607172332382.png" alt="image-20210607172332382"></p>
</li>
</ol>
<p>类似kernel32.dll中的函数，在同一个操作系统中，其在各个进程中的函数地址是一样的。可以现在别的进程找好要用的函数地址，把函数地址送进去目标进程。</p>
<p>shellCode通过PEB找到kernel32.dll的模块句柄，然后通过PE中的导出表找到GetProcAddress函数，就可以确定GetProcAddress在目标进程中的真实函数地址。到这一步就可以配合PEB中的所有模块句柄遍历找到所有函数。</p>
<h2 id="shellCode案例"><a href="#shellCode案例" class="headerlink" title="shellCode案例"></a>shellCode案例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//提前准备自己要使用的DLL和函数的字符串</span></span><br><span class="line">	<span class="type">char</span> szKernel32[] = &#123; <span class="string">&#x27;K&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>,<span class="string">&#x27;R&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>,<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>,<span class="string">&#x27;L&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>,<span class="string">&#x27;L&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>,<span class="string">&#x27;L&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>,<span class="number">0</span>,<span class="number">0</span> &#125;;</span><br><span class="line">	<span class="type">char</span> szUser32[] = &#123; <span class="string">&#x27;U&#x27;</span>,<span class="string">&#x27;S&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;R&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="number">0</span> &#125;;</span><br><span class="line">	<span class="type">char</span> szGetProcAddr[] = &#123; <span class="string">&#x27;G&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;P&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="number">0</span> &#125;;</span><br><span class="line">	<span class="type">char</span> szMessageBoxA[] = &#123; <span class="string">&#x27;M&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="number">0</span> &#125;;</span><br><span class="line">	<span class="type">char</span> szLoadLibraryA[] = &#123; <span class="string">&#x27;L&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;L&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//准备要找的函数的函数类型</span></span><br><span class="line">	<span class="function"><span class="keyword">typedef</span> <span class="title">FARPROC</span><span class="params">(*PGETPROCADDRESS)</span><span class="params">(HMODULE hModule, LPCSTR  lpProcName)</span></span>;</span><br><span class="line">	PGETPROCADDRESS pGetProcAddress;</span><br><span class="line">	<span class="function"><span class="keyword">typedef</span> <span class="title">HMODULE</span><span class="params">(*PLOADLIBRARYA)</span><span class="params">(LPCSTR lpLibFileName)</span></span>;</span><br><span class="line">	PLOADLIBRARYA pLoadLibraryA;</span><br><span class="line">	<span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*PMESSAGEBOXA)</span><span class="params">(HWND   hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT   uType)</span></span>;</span><br><span class="line">	PMESSAGEBOXA pMessageBoxA;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//准备结构体</span></span><br><span class="line">	_LDR_DATA_TABLE_ENTRY* pBeg, *pPLD;</span><br><span class="line">	DWORD dwKernelBase;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//==通过PEB先找到</span></span><br><span class="line">	<span class="comment">//获取链表  TEB-&gt;PEB-&gt;_PEB_LDR_DATA-&gt;_LDR_DATA_TABLE_TABLE_ENTRY</span></span><br><span class="line"></span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		mov eax, fs:[<span class="number">0x30</span>]  <span class="comment">//PEB</span></span><br><span class="line">		mov eax, [eax + <span class="number">0x0c</span>] <span class="comment">//PEB-&gt;ldr _PEB_LDR_DATA</span></span><br><span class="line">			add eax, <span class="number">0x0c</span>	   <span class="comment">//_PEB_LDR_DATA ldr-&gt;InLoadOrderModuleList</span></span><br><span class="line">			mov pBeg, eax	   <span class="comment">//记录开头节点</span></span><br><span class="line">			mov eax, [eax]</span><br><span class="line">			mov pPLD, eax	   <span class="comment">//记录_LDR_DATA_TABLE_ENTRY</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历找到kernel32.dll</span></span><br><span class="line">	<span class="keyword">while</span> (pPLD != pBeg)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//比较字符串(不能使用库函数)</span></span><br><span class="line">		WORD* pLast = (WORD*)pPLD-&gt;BaseDllName.Buffer;</span><br><span class="line">		<span class="comment">//wcout&lt;&lt; pPLD-&gt;BaseDllName.Buffer &lt;&lt;endl;//调试用，查看dll名称</span></span><br><span class="line">		WORD* pFirst = (WORD*)szKernel32;</span><br><span class="line">		<span class="keyword">while</span> (*pFirst&amp;&amp;*pFirst == *pLast)</span><br><span class="line">			pFirst++, pLast++;</span><br><span class="line">		<span class="keyword">if</span> (*pFirst == *pLast)</span><br><span class="line">		&#123;</span><br><span class="line">			dwKernelBase = (DWORD)pPLD-&gt;DllBase;<span class="comment">//找到了Kernel32字符串则记录下来</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		pPLD = (_LDR_DATA_TABLE_ENTRY*)pPLD-&gt;InLoadOrderLinks.Flink;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历KERNEL32.DLL的导出表，找到GetProcAddr函数的地址</span></span><br><span class="line">	IMAGE_DOS_HEADER *pIDH = (IMAGE_DOS_HEADER *)dwKernelBase;</span><br><span class="line">	<span class="comment">//通过DOS头找到PE文件头</span></span><br><span class="line">	IMAGE_NT_HEADERS *pINGs = (IMAGE_NT_HEADERS *)((DWORD)dwKernelBase + pIDH-&gt;e_lfanew);</span><br><span class="line">	<span class="comment">//找到导出表的地址</span></span><br><span class="line">	IMAGE_EXPORT_DIRECTORY* pIED = (IMAGE_EXPORT_DIRECTORY*)((DWORD)dwKernelBase + pINGs-&gt;OptionalHeader.DataDirectory[<span class="number">0</span>].VirtualAddress);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//导出函数地址表</span></span><br><span class="line">	DWORD *pAddOfFun_Raw = (DWORD*)((DWORD)dwKernelBase + pIED-&gt;AddressOfFunctions);</span><br><span class="line">	<span class="comment">//导出函数序号表</span></span><br><span class="line">	WORD* pAddOfOrd_Raw = (WORD*)((DWORD)dwKernelBase + pIED-&gt;AddressOfNameOrdinals);</span><br><span class="line">	<span class="comment">//导出函数名称表</span></span><br><span class="line">	DWORD* pAddOfNames_Raw = (DWORD*)((DWORD)dwKernelBase + pIED-&gt;AddressOfNames);</span><br><span class="line">	DWORD dwCnt = <span class="number">0</span>;<span class="comment">//计数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//在函数名称表中找目标名称的函数</span></span><br><span class="line">	<span class="type">char</span>* pFinded = <span class="literal">NULL</span>, *pSrc = szGetProcAddr;</span><br><span class="line">	<span class="keyword">for</span> (; dwCnt &lt; pIED-&gt;NumberOfNames; dwCnt++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//要找的函数名首地址</span></span><br><span class="line">		pFinded = (<span class="type">char</span>*)((DWORD)dwKernelBase + pAddOfNames_Raw[dwCnt]);</span><br><span class="line">		<span class="keyword">while</span> (*pFinded&amp;&amp;*pFinded == *pSrc)</span><br><span class="line">			pFinded++, pSrc++;</span><br><span class="line">		<span class="keyword">if</span> (*pFinded == *pSrc)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//通过函数名称表中要找的函数的下标找到要找的函数地址</span></span><br><span class="line">			pGetProcAddress = (PGETPROCADDRESS)((DWORD)dwKernelBase + pAddOfFun_Raw[pAddOfOrd_Raw[dwCnt]]);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		pSrc = szGetProcAddr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//有了GetProcAddr 就可以得到任何API函数了</span></span><br><span class="line">	pLoadLibraryA = (PLOADLIBRARYA)<span class="built_in">pGetProcAddress</span>((HMODULE)dwKernelBase, szLoadLibraryA);</span><br><span class="line">	HMODULE hUser32 = <span class="built_in">pLoadLibraryA</span>(szUser32);</span><br><span class="line">	pMessageBoxA = (PMESSAGEBOXA)<span class="built_in">pGetProcAddress</span>(hUser32, szMessageBoxA);</span><br><span class="line">	<span class="comment">//调用弹框</span></span><br><span class="line">	<span class="built_in">pMessageBoxA</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>该案例的代码放到哪里都可以跑</p>
<p><strong>什么是ShellCode？</strong></p>
<p>ShellCode：<strong>不依赖环境，放到任何地方都可以执行的机器码</strong>。</p>
<p><strong>ShellCode的编写原则</strong>：</p>
<ol>
<li>不能有全局变量</li>
<li>不能使用常量字符串</li>
<li>不能使用系统调用</li>
<li>不能嵌套调用其他函数（把整个模块按照ShellCode写过去，暂时还做不到）</li>
</ol>
<p>解决上述痛点的方式：</p>
<ol>
<li><p>不写就解决了</p>
</li>
<li><p>用局部数组写字符串</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210607170623362.png" alt="image-20210607170623362"></p>
</li>
<li><p>因为调用其他PE的函数都是采用间接CALL的调用方式，实际上是由编译器填写的。系统调用都是在其他DLL中的，所以ShellCode中不能使用系统调用。</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210607172332382.png" alt="image-20210607172332382"></p>
</li>
</ol>
<h1 id="HOOK"><a href="#HOOK" class="headerlink" title="HOOK"></a>HOOK</h1><p>Virtual Tabel Hook</p>
<h2 id="什么是HOOK"><a href="#什么是HOOK" class="headerlink" title="什么是HOOK"></a>什么是HOOK</h2><p>HOOK是用来获取，更改程序执行时的某些数据，或者是用于更改程序执行流程的一种技术。</p>
<p>HOOK的两种主要形式</p>
<ol>
<li><p><strong>改函数代码</strong></p>
<p>INLINE HOOK</p>
</li>
<li><p><strong>改函数地址</strong>（其实就是改表）</p>
<p>IAT HOOK（3环的表，只影响一个进程）</p>
<p>VT HOOK(虚表，C++的结构)</p>
<p>SSDT HOOK(这个以及下面3个表都是0环的表)</p>
<p>IDT HOOK</p>
<p>EAT HOOK</p>
<p>IRP HOOK</p>
<p>…</p>
</li>
</ol>
<h2 id="虚表HOOK（VT-HOOK）"><a href="#虚表HOOK（VT-HOOK）" class="headerlink" title="虚表HOOK（VT HOOK）"></a>虚表HOOK（VT HOOK）</h2><p>虚表hook是通过更改虚表</p>
<p>有虚函数就有虚表</p>
<p>实现原理如下图</p>
<p>没改前：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210707174332826.png" alt="image-20210707174332826"></p>
<p>修改后：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210707174410932.png" alt="image-20210707174410932"></p>
<h3 id="虚表HOOK案例"><a href="#虚表HOOK案例" class="headerlink" title="虚表HOOK案例"></a>虚表HOOK案例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;我是base&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myHookFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;你被hook了&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Base* base=<span class="keyword">new</span> Base;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">sizeof</span>(base)&lt;&lt;endl;</span><br><span class="line">	DWORD vtAddress = *(DWORD*)base;</span><br><span class="line">	DWORD oldFunAddress = *(DWORD*)vtAddress;</span><br><span class="line">	DWORD oldProtect;</span><br><span class="line">    <span class="comment">//因为表本身是只读的，所以要先修改成可读可写</span></span><br><span class="line">	<span class="built_in">VirtualProtect</span>((DWORD*)vtAddress, <span class="number">4</span>, PAGE_READWRITE, &amp;oldProtect);</span><br><span class="line">	*(DWORD*)vtAddress = (DWORD)myHookFunc;</span><br><span class="line">	base-&gt;<span class="built_in">Print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210707184145923.png" alt="image-20210707184145923"></p>
<p>缺点：只能HOOK虚表中的函数</p>
<h2 id="IAT-HOOK"><a href="#IAT-HOOK" class="headerlink" title="IAT HOOK"></a>IAT HOOK</h2><p>Import Address Table 由于导入函数就是被程序调用但其执行代码又不在程序中的函数，这些函数的代码位于一个或者多个DLL 中.当PE 文件被装入内存的时候，Windows 装载器才将DLL 装入，并将调用导入函数的指令和函数实际所处的地址联系起来(动态连接)，这操作就需要导入表完成.其中导入地址表就<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%8C%87%E7%A4%BA%E5%87%BD%E6%95%B0/3774265">指示函数</a>实际地址。</p>
<p>任何一个进程中都存在一张表，这张表会把当前进程用到的所有API都放到导入地址表中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">WinTool::setIATHook</span><span class="params">(DWORD dwOldAddress, DWORD dwNewAddress)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BOOL bFlag = FALSE;</span><br><span class="line">	PDWORD pFuncAddr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//得到模块基址</span></span><br><span class="line">	<span class="comment">//得到当前模块是从什么时候开始的</span></span><br><span class="line">	DWORD dwImageBase = (DWORD)<span class="built_in">GetModuleHandleA</span>(<span class="literal">NULL</span>);</span><br><span class="line">	PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)(dwImageBase + ((PIMAGE_DOS_HEADER)dwImageBase)-&gt;e_lfanew);</span><br><span class="line">	IMAGE_OPTIONAL_HEADER32 optionHeader = (IMAGE_OPTIONAL_HEADER32)(pNtHeader-&gt;OptionalHeader);</span><br><span class="line">	PIMAGE_IMPORT_DESCRIPTOR pImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)(dwImageBase + optionHeader.DataDirectory[<span class="number">1</span>].VirtualAddress);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//PIMAGE_IMPORT_DESCRIPTOR pImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)(dwImageBase + pNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历IAT表，找到这个函数的地址</span></span><br><span class="line">	<span class="keyword">while</span> (pImportDescriptor-&gt;FirstThunk != <span class="number">0</span> &amp;&amp; bFlag == FALSE)</span><br><span class="line">	&#123;</span><br><span class="line">		pFuncAddr = (PDWORD)(dwImageBase + pImportDescriptor-&gt;FirstThunk);</span><br><span class="line">		<span class="keyword">while</span> (*pFuncAddr)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (dwOldAddress == *pFuncAddr)</span><br><span class="line">			&#123;</span><br><span class="line">				DWORD dwOldProtect;</span><br><span class="line">				<span class="comment">//若找到要HOOK的函数，先修改内存页的属性，不然修改不可写内存程序会闪退</span></span><br><span class="line">				<span class="built_in">VirtualProtect</span>(pFuncAddr, <span class="built_in">sizeof</span>(DWORD), PAGE_READWRITE, &amp;dwOldProtect);</span><br><span class="line">				*pFuncAddr = dwNewAddress;</span><br><span class="line">				<span class="comment">//恢复内存页的属性</span></span><br><span class="line">				<span class="built_in">VirtualProtect</span>(pFuncAddr, <span class="built_in">sizeof</span>(DWORD), dwOldProtect, <span class="literal">NULL</span>);</span><br><span class="line">				bFlag = TRUE;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			pFuncAddr++;</span><br><span class="line">		&#125;</span><br><span class="line">		pImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)pImportDescriptor + <span class="built_in">sizeof</span>(IMAGE_IMPORT_DESCRIPTOR));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//要返回原来的地址，方便以后恢复回去;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (bFlag)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> dwOldAddress;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DWORD g_oldAddress;<span class="comment">//记录原函数地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//格式要定义成一样的，不然栈不平衡程序会崩溃</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">myMessageBoxA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	HWND   hWnd,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPCSTR lpText,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPCSTR lpCaption,</span></span></span><br><span class="line"><span class="params"><span class="function">	UINT   uType</span></span></span><br><span class="line"><span class="params"><span class="function">	)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//修改MessageBoxA中显示的信息</span></span><br><span class="line">	<span class="type">char</span> myText[]= &#123; <span class="string">&#x27;z&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="number">0</span> &#125;;</span><br><span class="line">	<span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*PMESSAGEBOXA)</span><span class="params">(HWND   hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT   uType)</span></span>;</span><br><span class="line">	PMESSAGEBOXA pMessageBoxA = (PMESSAGEBOXA)g_oldAddress;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">pMessageBoxA</span>(hWnd, myText, lpCaption, uType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WinTool myTool;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;未HOOK前调用MessageBoxA(0,0,0,0)函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">MessageBoxA</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;执行IAT HOOK，HOOK MessageBoxA函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">	HMODULE hModule = <span class="built_in">GetModuleHandleA</span>(<span class="string">&quot;user32.dll&quot;</span>);</span><br><span class="line">	DWORD pMessageBoxAAddr=(DWORD)<span class="built_in">GetProcAddress</span>(hModule, <span class="string">&quot;MessageBoxA&quot;</span>);</span><br><span class="line">	g_oldAddress=myTool.<span class="built_in">setIATHook</span>(pMessageBoxAAddr, (DWORD)myMessageBoxA);<span class="comment">//在IAT中并未找到需要处理的函数</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;按回车键调用IAT HOOK后的MessageBoxA(0,0,0,0)函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="built_in">MessageBoxA</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;解除IAT HOOK&quot;</span>&lt;&lt;endl;</span><br><span class="line">	myTool.<span class="built_in">setIATHook</span>((DWORD)myMessageBoxA, g_oldAddress);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;按回车键调用解除IAT HOOK后的MessageBoxA(0,0,0,0)函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="built_in">MessageBoxA</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显示结果：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210708190212173.png" alt="image-20210708190212173"><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210708190233787.png" alt="image-20210708190233787"><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210708190305081.png" alt="image-20210708190305081"></p>
<p>IAT HOOK的缺点：</p>
<ol>
<li>容易被检测到</li>
<li>只能HOOK IAT表里的函数(即<strong>非自身模块的函数</strong>)</li>
</ol>
<h2 id="INLINE-HOOK"><a href="#INLINE-HOOK" class="headerlink" title="INLINE HOOK"></a>INLINE HOOK</h2><p>inline hook是最有价值的HOOK</p>
<p>手动HOOK的流程如下：</p>
<p>找到要HOOK的函数头部：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">119</span>: <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">   120: &#123;</span></span><br><span class="line"><span class="number">00702730</span> <span class="number">55</span>                   push        ebp  </span><br><span class="line"><span class="number">00702731</span> <span class="number">8B</span> EC                mov         ebp,esp  </span><br><span class="line"><span class="number">00702733</span> <span class="number">83</span> EC <span class="number">40</span>             sub         esp,<span class="number">40</span>h  </span><br><span class="line"><span class="number">00702736</span> <span class="number">53</span>                   push        ebx  </span><br><span class="line"><span class="number">00702737</span> <span class="number">56</span>                   push        esi  </span><br><span class="line"><span class="number">00702738</span> <span class="number">57</span>                   push        edi  </span><br><span class="line">   <span class="number">121</span>: 	cout&lt;&lt;a+b&lt;&lt;endl;</span><br><span class="line"><span class="number">00702739</span> <span class="number">68</span> AF <span class="number">10</span> <span class="number">70</span> <span class="number">00</span>       push        offset std::endl&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt; &gt; (<span class="number">07010</span>AFh)  </span><br><span class="line"><span class="number">0070273</span>E <span class="number">8B</span> <span class="number">45</span> <span class="number">08</span>             mov         eax,dword ptr [a]  </span><br><span class="line"><span class="number">00702741</span> <span class="number">03</span> <span class="number">45</span> <span class="number">0</span>C             add         eax,dword ptr [b]  </span><br><span class="line"><span class="number">00702744</span> <span class="number">50</span>                   push        eax  </span><br><span class="line"><span class="number">00702745</span> <span class="number">8B</span> <span class="number">0</span>D <span class="number">7</span>C E1 <span class="number">70</span> <span class="number">00</span>    mov         ecx,dword ptr [_imp_?cout@std@@<span class="number">3</span>V?$basic_ostream@DU?$char_traits@D@std@@@<span class="number">1</span>@<span class="built_in">A</span> (<span class="number">070E17</span>Ch)]  </span><br><span class="line"><span class="number">0070274B</span> FF <span class="number">15</span> <span class="number">70</span> E1 <span class="number">70</span> <span class="number">00</span>    call        dword ptr [__imp_std::basic_ostream&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt; &gt;::<span class="keyword">operator</span>&lt;&lt; (<span class="number">070E170</span>h)]  </span><br><span class="line"><span class="number">00702751</span> <span class="number">8B</span> C8                mov         ecx,eax  </span><br><span class="line"><span class="number">00702753</span> FF <span class="number">15</span> <span class="number">6</span>C E1 <span class="number">70</span> <span class="number">00</span>    call        dword ptr [__imp_std::basic_ostream&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt; &gt;::<span class="keyword">operator</span>&lt;&lt; (<span class="number">070E16</span>Ch)]  </span><br><span class="line">   <span class="number">122</span>: &#125;</span><br><span class="line"><span class="number">00702759</span> <span class="number">5F</span>                   pop         edi  </span><br><span class="line"><span class="number">0070275</span>A <span class="number">5</span>E                   pop         esi  </span><br><span class="line"><span class="number">0070275B</span> <span class="number">5B</span>                   pop         ebx  </span><br><span class="line"><span class="number">0070275</span>C <span class="number">8B</span> E5                mov         esp,ebp  </span><br><span class="line"><span class="number">0070275</span>E <span class="number">5</span>D                   pop         ebp  </span><br><span class="line"><span class="number">0070275F</span> C3                   ret  </span><br></pre></td></tr></table></figure>

<p>将函数头部的5个字节修改为，我们自己添加的函数假如在70E89D处</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">119</span>: <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">   120: &#123;</span></span><br><span class="line"><span class="number">00702730</span> E9 <span class="number">68</span>C10000          JMP        <span class="number">0070E89</span>D  </span><br><span class="line"><span class="number">00702735</span> <span class="number">90</span>             	  nop<span class="comment">//此处由于实际上改了3行命令共6个字节，多了一个无用字节填90，即nop,此处不改也可以，反正跳到那边后再跳回来是跳到00702736</span></span><br><span class="line"><span class="number">00702736</span> <span class="number">53</span>                   push        ebx  </span><br><span class="line"><span class="number">00702737</span> <span class="number">56</span>                   push        esi  </span><br><span class="line"><span class="number">00702738</span> <span class="number">57</span>                   push        edi  </span><br></pre></td></tr></table></figure>

<p>70E89D处添加自己要做的事情，并补齐前面修改的代码，再跳回原来修改位置的下一行代码地址00702736处</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//00702736地址处</span></span><br><span class="line"><span class="number">0070E89</span>D C74424 <span class="number">04</span> <span class="number">02000000</span>  MOV DWORD [ESP+<span class="number">4</span>],<span class="number">2</span><span class="comment">//修改加法函数的两个参数</span></span><br><span class="line"><span class="number">0070E8</span>A5 C74424 <span class="number">08</span> <span class="number">03000000</span>  MOV DWORD [ESP+<span class="number">8</span>],<span class="number">3</span></span><br><span class="line"><span class="comment">//执行原来修改掉的代码</span></span><br><span class="line"><span class="number">0070E8</span>AD <span class="number">55</span> 			    PUSH 	EBP</span><br><span class="line"><span class="number">0070E8</span>AE <span class="number">8B</span> EC 			    MOV 	EBP,ESP</span><br><span class="line"><span class="number">0070E8</span>B0 <span class="number">83</span> EC <span class="number">40</span> 		    SUP 	ESP,<span class="number">40</span>h</span><br><span class="line"><span class="comment">//跳回原来修改位置的下一行代码地址00702736处</span></span><br><span class="line"><span class="number">0070E8</span>B3 E9 <span class="number">7E3</span>EFFFF		JMP		 <span class="number">00702736</span></span><br></pre></td></tr></table></figure>

<h3 id="Inline-Hook案例"><a href="#Inline-Hook案例" class="headerlink" title="Inline Hook案例"></a>Inline Hook案例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//准备要INLINE HOOK的目标函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; <span class="string">&quot;+&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;=&quot;</span> &lt;&lt; a + b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里必须是裸函数，不然升栈操作会崩溃。</span></span><br><span class="line"><span class="type">void</span> _declspec(naked) <span class="built_in">myInLineHookFunc</span>()</span><br><span class="line">&#123;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;   </span><br><span class="line">			mov[esp + <span class="number">4</span>], <span class="number">3</span></span><br><span class="line">			mov[esp + <span class="number">8</span>], <span class="number">4</span></span><br><span class="line">			<span class="comment">//补上之前修改掉的代码</span></span><br><span class="line">			push ebp</span><br><span class="line">			mov ebp, esp</span><br><span class="line">			sub esp, <span class="number">40</span>h</span><br><span class="line">			<span class="comment">//跳回原来修改掉的指令的下一句指令的地址</span></span><br><span class="line">			jmp add+<span class="number">6</span> </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;未HOOK之前调用add(1,2)函数,结果为:&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//未HOOK之前调用add(1,2)函数</span></span><br><span class="line">	<span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">	<span class="comment">//inline hook add函数</span></span><br><span class="line">	DWORD oldProtect;</span><br><span class="line">	WinTool myTool;</span><br><span class="line">	<span class="built_in">VirtualProtect</span>((LPVOID)add, <span class="number">5</span>, PAGE_EXECUTE_READWRITE, &amp;oldProtect);<span class="comment">//因为是代码段，所以必须是PAGE_EXECUTE_READWRITE权限，不然会出现访问错误(如下图)</span></span><br><span class="line">	<span class="comment">//修改跳转到裸函数</span></span><br><span class="line">	*(BYTE*)add = <span class="number">0xE9</span>;</span><br><span class="line">	*(DWORD*)(((BYTE*)add) + <span class="number">1</span>) = (DWORD)myInLineHookFunc - <span class="number">5</span> - (DWORD)add;</span><br><span class="line">	<span class="built_in">VirtualProtect</span>((LPVOID)add, <span class="number">5</span>, oldProtect, <span class="literal">NULL</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Inline HOOK之后调用add(1,2)函数,结果为:&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//Inline HOOK之后调用add(1,2)函数</span></span><br><span class="line">	<span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210709000121629.png" alt="image-20210709000121629"></p>
<p>发现此处不需要修正函数地址，add函数名称直接是add的真实地址。目测是VS2015有自动修正。</p>
<p>上面代码的VirtualProtect中PAGE_EXECUTE_READWRITE改为PAGE_READWRITE会报错：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210709002047122.png" alt="image-20210709002047122"></p>
<p>裸函数不可以有局部变量！</p>
<h4 id="Inline-HOOK注入dll版"><a href="#Inline-HOOK注入dll版" class="headerlink" title="Inline HOOK注入dll版"></a>Inline HOOK注入dll版</h4><p>写在DLL中：</p>
<h5 id="InlineHook-h"><a href="#InlineHook-h" class="headerlink" title="InlineHook.h"></a>InlineHook.h</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InlineHook</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">InlineHook</span>();</span><br><span class="line">	~<span class="built_in">InlineHook</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置HOOK</span></span><br><span class="line">	<span class="function">BOOL <span class="title">SetHook</span><span class="params">(LPSTR moduleName, LPSTR funcName, PROC hookFunc)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//卸载HOOK</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">UnHook</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重装HOOK</span></span><br><span class="line">	<span class="function">BOOL <span class="title">ReHook</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span> oldMem[<span class="number">5</span>] ;</span><br><span class="line">	<span class="type">char</span> newMem[<span class="number">5</span>] ;</span><br><span class="line">	PROC funcAddress=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>InlineHook.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;InlineHook.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">InlineHook::<span class="built_in">InlineHook</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">memset</span>(newMem, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">	<span class="built_in">memset</span>(oldMem, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">InlineHook::~<span class="built_in">InlineHook</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">UnHook</span>();</span><br><span class="line">	<span class="built_in">memset</span>(newMem, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">	<span class="built_in">memset</span>(oldMem, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">	funcAddress = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">InlineHook::SetHook</span><span class="params">(LPSTR moduleName, LPSTR funcName,PROC hookFunc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	funcAddress=<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandleA</span>(moduleName), funcName);</span><br><span class="line">	<span class="keyword">if</span> (!funcAddress)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	DWORD retHaveRead;</span><br><span class="line">	<span class="built_in">ReadProcessMemory</span>(<span class="built_in">GetCurrentProcess</span>(), funcAddress, &amp;oldMem, <span class="number">5</span>, &amp;retHaveRead);</span><br><span class="line">	<span class="keyword">if</span> (retHaveRead!=<span class="number">5</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	newMem[<span class="number">0</span>] = <span class="number">0xE9</span>;</span><br><span class="line">	*(DWORD*)(&amp;newMem[<span class="number">1</span>]) = (DWORD)hookFunc- (DWORD)funcAddress<span class="number">-5</span>;</span><br><span class="line">	DWORD retHaveWritten;</span><br><span class="line">	<span class="comment">/*DWORD oldProtect;</span></span><br><span class="line"><span class="comment">	VirtualProtect(funcAddress, 5, PAGE_EXECUTE_READWRITE, &amp;oldProtect);*/</span></span><br><span class="line">	<span class="built_in">WriteProcessMemory</span>(<span class="built_in">GetCurrentProcess</span>(), funcAddress, &amp;newMem, <span class="number">5</span>, &amp;retHaveWritten);</span><br><span class="line">	<span class="comment">//VirtualProtect(funcAddress, 5, oldProtect, NULL);</span></span><br><span class="line">	<span class="keyword">if</span> (retHaveWritten != <span class="number">5</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InlineHook::UnHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (funcAddress!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*DWORD oldProtect;</span></span><br><span class="line"><span class="comment">		VirtualProtect(funcAddress, 5, PAGE_EXECUTE_READWRITE, &amp;oldProtect);*/</span></span><br><span class="line">		<span class="built_in">WriteProcessMemory</span>(<span class="built_in">GetCurrentProcess</span>(), funcAddress, &amp;oldMem, <span class="number">5</span>, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="comment">//VirtualProtect(funcAddress, 5, oldProtect, NULL);</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">InlineHook::ReHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (funcAddress != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*DWORD oldProtect;</span></span><br><span class="line"><span class="comment">		VirtualProtect(funcAddress, 5, PAGE_EXECUTE_READWRITE, &amp;oldProtect);*/</span></span><br><span class="line">		<span class="built_in">WriteProcessMemory</span>(<span class="built_in">GetCurrentProcess</span>(), funcAddress, &amp;newMem, <span class="number">5</span>, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="comment">//VirtualProtect(funcAddress, 5, oldProtect, NULL);</span></span><br><span class="line">		<span class="keyword">return</span> TRUE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="dllmain-cpp"><a href="#dllmain-cpp" class="headerlink" title="dllmain.cpp"></a>dllmain.cpp</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;InlineHook.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">InlineHook myHook;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> WINAPI <span class="title">MyMessageBoxA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ HWND hWnd,</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ LPCSTR lpText,</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ LPCSTR lpCaption,</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ UINT uType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	myHook.<span class="built_in">UnHook</span>();</span><br><span class="line">	<span class="built_in">MessageBoxA</span>(hWnd, <span class="string">&quot;HOOK成功&quot;</span>, <span class="string">&quot;提示&quot;</span>, MB_OK);</span><br><span class="line">	myHook.<span class="built_in">ReHook</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">( HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">                       DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="params"><span class="function">                       LPVOID lpReserved</span></span></span><br><span class="line"><span class="params"><span class="function">					 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">		myHook.<span class="built_in">SetHook</span>(<span class="string">&quot;User32.dll&quot;</span>, <span class="string">&quot;MessageBoxA&quot;</span>, (PROC)MyMessageBoxA);</span><br><span class="line">			</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">		myHook.<span class="built_in">UnHook</span>();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>未HOOK前：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210710150602775.png" alt="image-20210710150602775"></p>
<p>HOOK后：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210710150629920.png" alt="image-20210710150629920"></p>
<h3 id="Inline-HOOK改进版"><a href="#Inline-HOOK改进版" class="headerlink" title="Inline HOOK改进版"></a>Inline HOOK改进版</h3><p>裸函数不会帮你生成任何汇编代码，所以不可以使用局部变量。</p>
<p>改进版Inline HOOK</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PATCH_LENGTH 6<span class="comment">//hook影响到的正常指令的大小</span></span></span><br><span class="line">DWORD g_realAddTargetAddr;<span class="comment">//真实addTarget函数地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//准备要INLINE HOOK的目标函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addTarget</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; <span class="string">&quot;+&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;=&quot;</span> &lt;&lt; a + b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunc</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//这里面就可以写局部变量了,注意：如果把这个代码注入到别的进程跑的话，还是要堆栈</span></span><br><span class="line">	<span class="type">char</span> str[]= &#123; <span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;S&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;!&#x27;</span>,<span class="number">0</span> &#125;;</span><br><span class="line">	<span class="built_in">MessageBoxA</span>(<span class="number">0</span>, str, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _declspec(naked) <span class="built_in">myInLineHookFunc</span>()</span><br><span class="line">&#123;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//保存寄存器</span></span><br><span class="line">		pushad</span><br><span class="line">		pushfd</span><br><span class="line">		<span class="comment">//传入上层需要使用的数据，用新函数的参数接收</span></span><br><span class="line">		push [esp+<span class="number">0x28</span>]</span><br><span class="line">		push [esp+<span class="number">0x30</span>]<span class="comment">//由于上一条push使ESP-=4了，所以第二个参数应该是esp+0x30的位置</span></span><br><span class="line">		call myFunc</span><br><span class="line">		add esp,<span class="number">0x8</span></span><br><span class="line">		<span class="comment">//恢复寄存器</span></span><br><span class="line">		popfd</span><br><span class="line">		popad</span><br><span class="line">		<span class="comment">//补上之前修改掉的代码</span></span><br><span class="line">		push ebp</span><br><span class="line">		mov ebp, esp</span><br><span class="line">		sub esp, <span class="number">40</span>h</span><br><span class="line">		<span class="comment">//跳回原来修改掉的指令的下一句指令的地址(避免用jmp的方式)</span></span><br><span class="line">		push g_realAddTargetAddr</span><br><span class="line">		add [esp],PATCH_LENGTH</span><br><span class="line">		retn</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;未HOOK之前调用addTarget(1,2)函数,结果为:&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//未HOOK之前调用addTarget(1,2)函数</span></span><br><span class="line">	<span class="built_in">addTarget</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">	<span class="comment">//inline hook addTarget函数</span></span><br><span class="line">	WinTool myTool;</span><br><span class="line">	g_realAddTargetAddr = (DWORD)myTool.<span class="built_in">repairFuncAddr</span>((DWORD)addTarget);</span><br><span class="line">	DWORD oldProtect;</span><br><span class="line">	<span class="built_in">VirtualProtect</span>((LPVOID)g_realAddTargetAddr, <span class="number">5</span>, PAGE_EXECUTE_READWRITE, &amp;oldProtect);</span><br><span class="line">	<span class="comment">//修改跳转到裸函数</span></span><br><span class="line">	*(BYTE*)g_realAddTargetAddr = <span class="number">0xE9</span>;</span><br><span class="line">	*(DWORD*)(((BYTE*)g_realAddTargetAddr) + <span class="number">1</span>) = (DWORD)myInLineHookFunc - <span class="number">5</span> - (DWORD)g_realAddTargetAddr;</span><br><span class="line">	<span class="built_in">VirtualProtect</span>((LPVOID)g_realAddTargetAddr, <span class="number">5</span>, oldProtect, <span class="literal">NULL</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Inline HOOK之后调用addTarget(1,2)函数,结果为:&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//Inline HOOK之后调用addTarget(1,2)函数</span></span><br><span class="line">	<span class="built_in">addTarget</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210709163413382.png" alt="image-20210709163413382"></p>
<p>结果：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210709162621067.png" alt="image-20210709162621067"></p>
<p><strong>通过这种间接调用函数的方式，就可以实现在上面代码的myFunc函数体中使用局部变量了！</strong></p>
<p>很多时候，防守的一方都会通过检测E9，即JMP来判断自己的程序是否被HOOK了</p>
<p>因此将JMP过去再JMP回来的方式改为<strong>CALL过去再RET回来</strong>的方式实现</p>
<p><code>jmp是E9，CALL是E8</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PATCH_LENGTH 6<span class="comment">//hook影响到的正常指令的大小</span></span></span><br><span class="line">DWORD g_realAddTargetAddr;<span class="comment">//真实addTarget函数地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//准备要INLINE HOOK的目标函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addTarget</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; <span class="string">&quot;+&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;=&quot;</span> &lt;&lt; a + b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunc</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//这里面就可以写局部变量了,注意：如果把这个代码注入到别的进程跑的话，还是要堆栈</span></span><br><span class="line">	<span class="type">char</span> str[]= &#123; <span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;S&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;!&#x27;</span>,<span class="number">0</span> &#125;;</span><br><span class="line">	<span class="built_in">MessageBoxA</span>(<span class="number">0</span>, str, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _declspec(naked) <span class="built_in">myInLineHookFunc</span>()</span><br><span class="line">&#123;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//由于是call跳转过来的，清掉堆栈最上面的call返回到的地址！！！！！！！！！！！</span></span><br><span class="line">		add esp, <span class="number">4</span></span><br><span class="line">		<span class="comment">//保存寄存器</span></span><br><span class="line">		pushad</span><br><span class="line">		pushfd</span><br><span class="line">		<span class="comment">//传入上层需要使用的数据，用新函数的参数接收</span></span><br><span class="line">		push [esp+<span class="number">0x28</span>]</span><br><span class="line">		push [esp+<span class="number">0x30</span>]<span class="comment">//由于上一条push使ESP-=4了，所以第二个参数应该是esp+0x30的位置</span></span><br><span class="line">		call myFunc</span><br><span class="line">		add esp,<span class="number">0x8</span></span><br><span class="line">		<span class="comment">//恢复寄存器</span></span><br><span class="line">		popfd</span><br><span class="line">		popad</span><br><span class="line">		<span class="comment">//补上之前修改掉的代码</span></span><br><span class="line">		push ebp</span><br><span class="line">		mov ebp, esp</span><br><span class="line">		sub esp, <span class="number">40</span>h</span><br><span class="line">		<span class="comment">//跳回原来修改掉的指令的下一句指令的地址(避免用jmp的方式)</span></span><br><span class="line">		push g_realAddTargetAddr</span><br><span class="line">		add [esp],PATCH_LENGTH</span><br><span class="line">		retn</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;未HOOK之前调用addTarget(1,2)函数,结果为:&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//未HOOK之前调用addTarget(1,2)函数</span></span><br><span class="line">	<span class="built_in">addTarget</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">	<span class="comment">//inline hook addTarget函数</span></span><br><span class="line">	WinTool myTool;</span><br><span class="line">	g_realAddTargetAddr = (DWORD)myTool.<span class="built_in">repairFuncAddr</span>((DWORD)addTarget);</span><br><span class="line">	DWORD oldProtect;</span><br><span class="line">	<span class="built_in">VirtualProtect</span>((LPVOID)g_realAddTargetAddr, <span class="number">5</span>, PAGE_EXECUTE_READWRITE, &amp;oldProtect);</span><br><span class="line">	<span class="comment">//修改跳转到裸函数</span></span><br><span class="line">	*(BYTE*)g_realAddTargetAddr = <span class="number">0xE8</span>;<span class="comment">//E8为call操作码(避免用jmp E9方式)！！！！！！！！！！！</span></span><br><span class="line">	*(DWORD*)(((BYTE*)g_realAddTargetAddr) + <span class="number">1</span>) = (DWORD)myInLineHookFunc - <span class="number">5</span> - (DWORD)g_realAddTargetAddr;</span><br><span class="line">	<span class="built_in">VirtualProtect</span>((LPVOID)g_realAddTargetAddr, <span class="number">5</span>, oldProtect, <span class="literal">NULL</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Inline HOOK之后调用addTarget(1,2)函数,结果为:&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//Inline HOOK之后调用addTarget(1,2)函数</span></span><br><span class="line">	<span class="built_in">addTarget</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上只修改了！！！！！！！！！！！标识的两处位置</p>
<h3 id="Inline-HOOK攻防-重点"><a href="#Inline-HOOK攻防-重点" class="headerlink" title="Inline HOOK攻防(重点)"></a>Inline HOOK攻防(重点)</h3><h4 id="阶段1"><a href="#阶段1" class="headerlink" title="阶段1"></a>阶段1</h4><ul>
<li>（防）检测JMP(原函数无E9)，检测跳转范围（原函数有E9）</li>
<li>（破）想方设法绕</li>
</ul>
<h4 id="阶段2"><a href="#阶段2" class="headerlink" title="阶段2"></a>阶段2</h4><ul>
<li><p>（防）写个线程全代码校验&#x2F;CRC校验</p>
<p><code>全代码校验就是将代码存到另一个地方，一个一个比对</code></p>
</li>
<li><p>（攻）修改检测代码，挂起检测函数(终止的动作更大，挂起安全一点)</p>
</li>
</ul>
<h5 id="寻找检测代码"><a href="#寻找检测代码" class="headerlink" title="寻找检测代码"></a>寻找检测代码</h5><p><strong>OD跳转到检测代码必须用硬件访问断点，内存断点的本质是修改当前命令第一个字节为CC，即int 3，也会触发检测代码，因此必须要硬件访问断点。</strong></p>
<p><strong>在OD的代码段中只能下硬件执行断点，但内存跟踪窗口可以下硬件访问断点，所以用内存跟踪窗口跟到代码段再下硬件访问断点就可以了</strong></p>
<h5 id="CRC循环冗余校验码"><a href="#CRC循环冗余校验码" class="headerlink" title="CRC循环冗余校验码"></a>CRC循环冗余校验码</h5><p>一种比全代码校验的更优秀的代码校验算法</p>
<p><strong>CRC</strong>，即**循环冗余校验码(Cyclic Redundancy Check)**：是数据通信领域中最常用的一种查错校验码</p>
<p>计算机网络中<strong>数据链路层的差错控制技术</strong></p>
<p>循环冗余检查（CRC）是一种数据传输检错功能，对数据进行多项式计算，并将得到的结果附在帧的后面，接收设备也执行类似的算法，以保证数据传输的正确性和完整性。</p>
<p><strong>FCS</strong>是添加在数据后面的冗余码。FCS可以用CRC这种方法得出，但CRC并非用来获得FCS的唯一方法。</p>
<p>CRC最重要的是<strong>模二运算</strong>。模二运算就是不进位的运算，<strong>模二减法和模二加法本质上就是异或运算</strong>，模二乘法与模二除法过程中涉及到的加减也就是模二加法与模二减法。</p>
<p><strong>异或运算</strong>的本质：A 异或 B ：就相当于A按照B二进制表示中的1所对应的位进行反转。（即B中的1表示A对应位要反转）</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210714143816162.png" alt="image-20210714143816162"></p>
<img src="https://raw.githubusercontent.com/che77a38/blogImage/main/WonderFox_Video_Recording_001_001.gif" style="zoom: 100%" />

<p>实际工程中多使用CRC-16校验</p>
<h4 id="阶段3"><a href="#阶段3" class="headerlink" title="阶段3"></a>阶段3</h4><p>大多数现在的程序采用的手段</p>
<ul>
<li>（防）先对相关API全代码校验（防止提前修改好API），多个线程互相检测，并检测线程是否在活动中</li>
<li>（破）使用瞬时HOOK&#x2F;硬件HOOK</li>
</ul>
<p>A线程-&gt;B线程-&gt;C线程-&gt;要保护的代码</p>
<p>A检测B是否被挂起并且代码是否被修改，B检测C是是否被挂起并且代码否被修改，C检测要保护的代码是否被挂起并且代码是否被修改</p>
<p>实际上解决上面检测的方向只有两种</p>
<ol>
<li>与当前检测线程死磕（找漏洞，检测线程无论如何逻辑上一定有漏洞！）：瞬时HOOK</li>
<li>不改代码，但又把想做的事情做了：硬件HOOK</li>
</ol>
<p>循环检测的伪代码：(下图相当于上面的C线程)</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210710163925510.png" alt="image-20210710163925510"></p>
<p>该循环检测本身也被B线程CRC检测中，所以不能直接修改上图中的表层二进制代码。</p>
<h5 id="瞬时HOOK-临时HOOK"><a href="#瞬时HOOK-临时HOOK" class="headerlink" title="瞬时HOOK(临时HOOK)"></a>瞬时HOOK(临时HOOK)</h5><p>瞬时HOOK是属于与当前检测线程死磕的情况</p>
<p>瞬时HOOK要针对具体的检测代码来实现。</p>
<p>对于上图的循环检测来讲，VirtualProtect函数并未被检测的情况下，我们就可以在VirtualProtect函数中做文章，HOOK Virtual Protect函数中的头部对堆栈进行回溯看是不是A处调用的他，如果不是就什么额外动作也不做；如果是A调用的他，则这个时候给ExitProcess挂钩子，钩子函数内容为检测是否是A调用的他（堆栈回溯），若不是则什么额外的都不做，如果是则取消自己给ExitProcess下的钩子。</p>
<p>如下线程保护，以下代码也被保护中，该如何破解：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UINT <span class="title">CMFCtestDlg::ThreadFunc</span><span class="params">(LPVOID pParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//线程函数实现</span></span><br><span class="line">	<span class="built_in">AfxMessageBox</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;线程开始执行&quot;</span>));</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//检测ExitProcess</span></span><br><span class="line">		u16 tmpExitCRC = <span class="built_in">crc16_MAXIM</span>((u8*)exitProcessAddr, <span class="number">0x13</span>);</span><br><span class="line">		<span class="comment">//检测messageBoxAAddr</span></span><br><span class="line">		u16 tmpTarget = <span class="built_in">crc16_MAXIM</span>((u8*)messageBoxAAddr, <span class="number">0x49</span>);</span><br><span class="line">		<span class="keyword">if</span> (compareTarget != tmpTarget|| compareExit!= tmpExitCRC)</span><br><span class="line">		&#123;</span><br><span class="line">			::<span class="built_in">MessageBoxW</span>(<span class="number">0</span>, <span class="string">L&quot;检测到hook&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">			<span class="built_in">ExitProcess</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210715194421171.png" alt="image-20210715194421171"></p>
<h3 id="HOOK相关练习（高并发hook，了解cmpxchg8b指令）"><a href="#HOOK相关练习（高并发hook，了解cmpxchg8b指令）" class="headerlink" title="HOOK相关练习（高并发hook，了解cmpxchg8b指令）"></a>HOOK相关练习（高并发hook，了解cmpxchg8b指令）</h3><h4 id="在多核环境下，如何保证对一个高并发的内核函数进行HOOK而不会出错？"><a href="#在多核环境下，如何保证对一个高并发的内核函数进行HOOK而不会出错？" class="headerlink" title="在多核环境下，如何保证对一个高并发的内核函数进行HOOK而不会出错？"></a>在多核环境下，如何保证对一个高并发的内核函数进行HOOK而不会出错？</h4><p>问题出在当hook位置处于高并发状态下的时候，由于一次要修改5个字节，因此当一条指令修改4个字节的时候，第五个字节还未修改的时候，其他线程依然正在执行，则导致错误</p>
<p>两种解决办法</p>
<ol>
<li>先进行一个短跳中转一下（比较麻烦）</li>
<li>找一种可以一次修改大于等于5个字节的指令：cmpxchg8b&#x2F;cmpxchg16b</li>
</ol>
<p><strong>但还有低概率的问题可能发生</strong></p>
<p>形如如下的情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//每个push占两个字节</span><br><span class="line">push 1;</span><br><span class="line">;hook位置：</span><br><span class="line">push 1;</span><br><span class="line">push 1;</span><br><span class="line">push 1;</span><br><span class="line">call xxxxxxxx;</span><br></pre></td></tr></table></figure>

<p>上面情况</p>
<p>CPU在执行完第一个hook位置后第一个push，正好进行hook。</p>
<p>会导致执行出无法预料的问题（执行的代码都会被识别成完全不同的代码），并且堆栈百分百不平衡</p>
<p>如图，对于执行到中途被HOOK代码处的线程，会将硬编码解读成完全不一样的指令：（解读成了下方右图的代码）</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20211124154438711.png" alt="image-20211124154438711"><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20211124154455104.png" alt="image-20211124154455104"></p>
<p>解决方案就是不要hook这样的位置，找不影响堆栈的地方，找单条的长指令hook，或者短跳(2字节)，甚至用中断(2字节)。</p>
<p>该问题主要处在内核层，因为内核层高并发，并且内核出问题直接蓝屏。</p>
<h4 id="如何卸载高并发HOOK"><a href="#如何卸载高并发HOOK" class="headerlink" title="如何卸载高并发HOOK"></a>如何卸载高并发HOOK</h4><p>卸载HOOK的前提是：没有任何线程在我们的HOOK代码中才能卸载</p>
<p>对于足够高并发的程序来说，没有什么好办法</p>
<p>对于驱动级而言，关机重启更简单。程序则是关了重开。。。</p>
<h1 id="API小列表"><a href="#API小列表" class="headerlink" title="API小列表"></a>API小列表</h1><table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>CreateProcess</td>
<td>创建进程</td>
</tr>
<tr>
<td>OpenProcess</td>
<td>通过进程id获得进程句柄</td>
</tr>
<tr>
<td>TerminateProcess</td>
<td>通过进程句柄强制终止进程</td>
</tr>
<tr>
<td>ResumeThead</td>
<td>恢复线程挂起计数</td>
</tr>
<tr>
<td>CloseHandle</td>
<td>关闭内核对象句柄，减少内核对象计数</td>
</tr>
<tr>
<td>GetModuleFileName</td>
<td>根据模块名得到模块文件路径</td>
</tr>
<tr>
<td>GetCurrentDirectory</td>
<td>获取当前进程工作目录路径</td>
</tr>
<tr>
<td>GetCurrentProcessId</td>
<td>获取当前进程ID</td>
</tr>
<tr>
<td>GetCurrentProcess</td>
<td>获取当前进程句柄</td>
</tr>
<tr>
<td>GetCommandLine</td>
<td>获取当前进程命令行</td>
</tr>
<tr>
<td>GetStartupInfo</td>
<td>获取当前进程的启动信息</td>
</tr>
<tr>
<td>GetCurrentThreadId</td>
<td>获取线程id</td>
</tr>
<tr>
<td>EnumProcesses</td>
<td>遍历进程ID</td>
</tr>
<tr>
<td>CreateToolhelp32Snapshot</td>
<td>快照</td>
</tr>
<tr>
<td>CreateThread</td>
<td>创建线程</td>
</tr>
<tr>
<td>Sleep</td>
<td>当前线程停止多少毫秒</td>
</tr>
<tr>
<td>SuspendThread</td>
<td>挂起别的线程</td>
</tr>
<tr>
<td>WaitForSingleObject</td>
<td>等待单个内核对象状态发生变化</td>
</tr>
<tr>
<td>WaitForMultipleObjects</td>
<td>等待多个内核对象状态发生变化</td>
</tr>
<tr>
<td>GetExitCodeThread</td>
<td>获取线程回调函数的返回结果</td>
</tr>
<tr>
<td>GetThreadContext</td>
<td>获取线程上下文</td>
</tr>
<tr>
<td>SetThreadContext</td>
<td>设置线程上下文</td>
</tr>
<tr>
<td>CreateMutex</td>
<td>创建或打开互斥体</td>
</tr>
<tr>
<td>GetLastError</td>
<td>获取错误码</td>
</tr>
<tr>
<td>CreateEvent</td>
<td>创建或打开事件</td>
</tr>
<tr>
<td>SetEvent</td>
<td>指定事件设为有信号（优先wait线程）</td>
</tr>
<tr>
<td>ResetEvent</td>
<td>指定事件设为无信号（优先wait线程）</td>
</tr>
<tr>
<td>GDI等一大批函数</td>
<td>绘图</td>
</tr>
<tr>
<td>CreateWindow</td>
<td>创建窗口并创建消息队列</td>
</tr>
<tr>
<td>ShowWindow</td>
<td>显示窗口</td>
</tr>
<tr>
<td>GetMessage</td>
<td>从消息队列取消息</td>
</tr>
<tr>
<td>DispatchMessage</td>
<td>分发消息，通知操作系统调用对应窗口回调</td>
</tr>
<tr>
<td>TranslateMessage</td>
<td>使键盘按下产生WM_CHAR消息</td>
</tr>
<tr>
<td>OutputDebugString</td>
<td>显示调试信息</td>
</tr>
<tr>
<td>SeTDlgItemText</td>
<td>设置控件的标题或文本</td>
</tr>
<tr>
<td>PostQuitMessage</td>
<td>向系统指示线程已请求终止（退出）。它通常用于响应<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/winmsg/wm-destroy">WM_DESTROY</a>消息。</td>
</tr>
<tr>
<td>VirtualAlloc</td>
<td>给自己申请私有内存</td>
</tr>
<tr>
<td>VirtualAllocEx</td>
<td>给别的进程申请私有内存</td>
</tr>
<tr>
<td>VirtualFree</td>
<td>释放私有内存或仅释放物理页</td>
</tr>
<tr>
<td>CreateFileMapping</td>
<td>创建或打开文件映射内核对象用于：申请物理页或者申请物理页并把文件映射到物理页</td>
</tr>
<tr>
<td>MapViewOfFile</td>
<td>物理页映射到虚拟地址函数</td>
</tr>
<tr>
<td>UnmapViewOfFile</td>
<td>取消物理页到虚拟地址函数的映射关系</td>
</tr>
<tr>
<td>GetLogicalDrives</td>
<td>获取卷(有哪些卷，是什么)</td>
</tr>
<tr>
<td>GetLogicalDriveStrings</td>
<td>获取一个卷的盘符的字符串</td>
</tr>
<tr>
<td>GetDriveType</td>
<td>获取卷的类型</td>
</tr>
<tr>
<td>GetVolumeInformation</td>
<td>获取卷的信息(可查看文件系统等)</td>
</tr>
<tr>
<td>CreateDirectory</td>
<td>创建目录</td>
</tr>
<tr>
<td>RemoveDirectory</td>
<td>删除现有空目录</td>
</tr>
<tr>
<td>MoveFile</td>
<td>移动文件或目录（可改名）</td>
</tr>
<tr>
<td>GetCurrentDirectory&#x2F;SetCurrentDirectory</td>
<td>获取&#x2F;设置当前程序工作目录</td>
</tr>
<tr>
<td>CreateFile</td>
<td>创建或打开文件或 I&#x2F;O 设备</td>
</tr>
<tr>
<td>GetFileSize</td>
<td>获取文件大小</td>
</tr>
<tr>
<td>GetFileAttributes()&#x2F;GetFileAttributesEx</td>
<td>检索指定文件或目录的属性。</td>
</tr>
<tr>
<td>ReadFile()&#x2F;WriteFile()&#x2F;CopyFile()&#x2F;DeleteFile</td>
<td>读&#x2F;写&#x2F;复制&#x2F;删除文件</td>
</tr>
<tr>
<td>FindFirstFile()&#x2F;FindNextFile</td>
<td>查找文件或目录</td>
</tr>
<tr>
<td>FlushViewOfFile</td>
<td>将文件映射指定范围的字节即刻写入硬盘</td>
</tr>
<tr>
<td>LoadLibrary</td>
<td>加载动态链接库</td>
</tr>
<tr>
<td>FreeLibrary</td>
<td>卸载动态链接库</td>
</tr>
<tr>
<td>FreeLibraryAndExitThread</td>
<td>当前由动态链接库创建的线程卸载动态链接库并退出线程</td>
</tr>
<tr>
<td>GetProcAddress</td>
<td>获取导出函数在对应模块中的地址</td>
</tr>
<tr>
<td>CreateRemoteThread</td>
<td>创建远线程</td>
</tr>
<tr>
<td>WriteProcessMemory</td>
<td>写进程内存</td>
</tr>
<tr>
<td>ReadProcessMemory</td>
<td>读内存进程</td>
</tr>
<tr>
<td>GetModuleHandle</td>
<td>获取模块句柄</td>
</tr>
<tr>
<td>VirtualProtect</td>
<td>更改对调用进程虚拟地址空间中已提交页面区域的保护。</td>
</tr>
<tr>
<td>VirtualProtectEx</td>
<td>更改对别的进程调用进程虚拟地址空间中已提交页面区域的保护</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="自定义消息"><a href="#自定义消息" class="headerlink" title="自定义消息"></a>自定义消息</h1><p>Windows程序与其它类型程序的区别就是使用消息，例如键盘或鼠标消息等，在dos系统下的程序没有定义消息。在windows操作系统中，消息不但可以用于进程内的通信，也可以用于进程间的通信。而我这篇博文将讲使用自定义消息实现进程间的通信。</p>
<p>​    我们都知道，在windows中消息分为两种，即系统消息和用户自定义消息，系统消息定义从0到0x3ff，可以使用0x400到0x7fff定义自己的消息。windows把0x400定义为WM_USER，如果想定义自己的一个消息，可以在WM_USER上加上一个值。当然了，还有另外一种方法，这里就不讲了，而是使用RegisterWindowsMessage()函数。</p>
<p>​    <strong>要想用消息实现进程间通信，则需要在这两个程序中定义或注册相同的消息，才能保证数据通信顺利进行。</strong></p>
<p>　　<strong>使用这种方式实现进程间通信，但是传送的数据只能是长整型的数据，不能是字符串。所以这个就是这种方式的局限。</strong></p>
<h1 id="键鼠模拟"><a href="#键鼠模拟" class="headerlink" title="键鼠模拟"></a>键鼠模拟</h1><p>用户按下按键—–键盘驱动程序将此事件传递给操作系统—–操作系统将键盘事件插入消息队列—–键盘消息被发送到当前活动窗口</p>
<p>模拟键盘的方法有三种：</p>
<ol>
<li>keybd_event() </li>
<li>PostMessage() &#x2F;SendMessage()</li>
<li>SendInput()</li>
</ol>
<p>keybd_event是<strong>全局模拟按键的，只对前台窗口</strong>（即当前的活动窗口）才可以，但是如果模拟的按键正好也是某个窗口的全局热键消息，那该窗口也能接收到的</p>
<p>而SendMessage 、PostMessage是对指定句柄窗口都其作用的，对于做一些一外挂是非常有用的。例如可以做成这样的效果：即用SendMessage&#x2F;PostMessage在某一个窗口模拟动作，而同时自己可以在其他窗口做其他事情，互不影响的！</p>
<p>PostMessage中的窗口句柄参数，可以设置为HWND_BROADCAST，即广播，但不要理所当然地认为是对所有的窗口都起作用！！！它只对系统的顶层窗口起作用，子窗口是收不到这个消息的！！！</p>
<p>SendMessage是没有HWND_BROADCAST参数的，那是因为，SendMessage总是等发送的消息在对应的窗口消息队列 中处理完毕后才返回的（这是一种负责的行为）</p>
<p><strong>SendMessage和PostMessage的区别</strong>是PostMessage函数直接把消息仍给目标程序就不管了，而SendMessage把消息发出去后，还要等待目标程序返回些什么东西才好。这里要注意的是，模拟键盘消息一定要用PostMessage函数才好，用SendMessage是不正确的(因为模拟键盘消息是不需要返回值的，不然目标程序会没反应)</p>
<p>**如果用PostMessage发送局部消息模拟按键不成功的话，你可以试一试全局级的键盘消息keybd_event() **</p>
<h2 id="PostMessageA"><a href="#PostMessageA" class="headerlink" title="PostMessageA"></a>PostMessageA</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟鼠标</span></span><br><span class="line"><span class="built_in">PostMessage</span>(</span><br><span class="line">	hwnd, 					<span class="comment">// 目标窗口句柄</span></span><br><span class="line">	WM_RBUTTONDOWN, 		<span class="comment">// 更多鼠标事件宏定义类型参考 ： https://docs.microsoft.com/en-us/windows/win32/inputdev/mouse-input-notifications</span></span><br><span class="line">	<span class="number">0</span>,</span><br><span class="line">	<span class="built_in">MAKELPARAM</span>(<span class="number">200</span>,<span class="number">200</span>)		<span class="comment">// x = 200,y = 200（相对于窗口的坐标，而不是屏幕的坐标）</span></span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟键盘</span></span><br><span class="line"><span class="built_in">PostMessage</span>(</span><br><span class="line">	hwnd,					<span class="comment">// 目标窗口句柄</span></span><br><span class="line">	WM_KEYDOWN,				<span class="comment">// 更多键盘事件共定义参考 ： https://docs.microsoft.com/en-us/windows/win32/inputdev/keyboard-input</span></span><br><span class="line">	<span class="number">0x41</span>,					<span class="comment">// 更多按键种类宏定义参考 ： https://docs.microsoft.com/zh-cn/windows/win32/inputdev/virtual-key-codes</span></span><br><span class="line">	<span class="number">0</span></span><br><span class="line">	);</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/win32/inputdev/virtual-key-codes">虚拟键码VK_code查询</a></p>
<h2 id="keybd-event"><a href="#keybd-event" class="headerlink" title="keybd_event()"></a>keybd_event()</h2><p>这个函数对大部分的窗口程序都有效，可是仍然有一部分游戏对它产生的键盘事件熟视无睹，这时候，你就要用上bScan这个参数了。一般的，bScan都传0，但是如果目标程序是一些DirectX游戏，那么你就需要正确使用这个参数传入扫描码，用了它可以产生正确的硬件事件消息，以被游戏识别。</p>
<h2 id="SendInput"><a href="#SendInput" class="headerlink" title="SendInput()"></a>SendInput()</h2><p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-sendinput">SendInput函数</a>也可以模拟全局键盘事件。SendInput可以直接把一条消息插入到消息队列中，算是比较底层的了</p>
<h2 id="钩子模拟键鼠操作"><a href="#钩子模拟键鼠操作" class="headerlink" title="钩子模拟键鼠操作"></a>钩子模拟键鼠操作</h2><p>  除了以上这些，用全局钩子也可以模拟键盘消息。如果你对windows中消息钩子的用法已经有所了解，那么你可以通过设置一个全局HOOK来模拟键盘消息，比如，你可以用WH_JOURNALPLAYBACK这个钩子来模拟按键。WH_JOURNALPLAYBACK是一个系统级的全局钩子，它和WH_JOURNALRECORD的功能是相对的，常用它们来记录并回放键盘鼠标操作。WH_JOURNALRECORD钩子用来将键盘鼠标的操作忠实地记录下来，记录下来的信息可以保存到文件中，而WH_JOURNALPLAYBACK则可以重现这些操作。当然亦可以单独使用WH_JOURNALPLAYBACK来模拟键盘操作。你需要首先声明SetWindowsHookEx函数，它可以用来安装消息钩子：<br>Declare Function SetWindowsHookEx Lib “user32” Alias “SetWindowsHookExA” (ByVal idHook As Long,ByVal lpfn As Long, ByVal hmod As Long, ByVal dwThreadId As Long) As Long<br>先安装WH_JOURNALPLAYBACK这个钩子，然后你需要自己写一个钩子函数，在系统调用它时，把你要模拟的事件传递给钩子参数lParam所指向的EVENTMSG区域，就可以达到模拟按键的效果。不过用这个钩子模拟键盘事件有一个副作用，就是它会锁定真实的鼠标键盘，不过如果你就是想在模拟的时候不会受真实键盘操作的干扰，那么用用它倒是个不错的主意。</p>
<h2 id="驱动级模拟"><a href="#驱动级模拟" class="headerlink" title="驱动级模拟"></a>驱动级模拟</h2><p>直接读写键盘的硬件端口</p>
<p>有一些使用DirectX接口的游戏程序，它们在读取键盘操作时绕过了windows的消息机制，而使用DirectInput.这是因为有些游戏对实时性控制的要求比较高，比如赛车游戏，要求以最快速度响应键盘输入。而windows消息由于是队列形式的，消息在传递时会有不少延迟，有时1秒钟也就传递十几条消息，这个速度达不到游戏的要求。而DirectInput则绕过了windows消息，直接与键盘驱动程序打交道，效率当然提高了不少。因此也就造成，对这样的程序无论用PostMessage或者是keybd_event都不会有反应，因为这些函数都在较高层。对于这样的程序，只好用直接读写键盘端口的方法来模拟硬件事件了。要用这个方法来模拟键盘，需要先了解一下键盘编程的相关知识。</p>
<p>我的理解：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210608224348679.png" alt="image-20210608224348679"></p>
<p>全局到局部窗口的消息由操作系统进程分发</p>
<h1 id="全局理解点"><a href="#全局理解点" class="headerlink" title="全局理解点"></a>全局理解点</h1><p><strong>进程结束的时候，操作系统会在进程之后进行全面的清除，使得所有操作系统资源都不会保留下来。这意味着进程使用的所有内存均被释放，所有打开的文件全部关闭，所有内核对象的使用计数均被递减，同时所有的用户对象和GDI对象均被撤消。</strong></p>
<h1 id="图形图像处理"><a href="#图形图像处理" class="headerlink" title="图形图像处理"></a>图形图像处理</h1><p>easyx库 &#96;&#96;</p>
<p>bmp格式的图片如何描述</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagBITMAPFILEHEADER</span> &#123;</span></span><br><span class="line">        WORD    bfType;<span class="comment">//类型</span></span><br><span class="line">        DWORD   bfSize;<span class="comment">//大小</span></span><br><span class="line">        WORD    bfReserved1;</span><br><span class="line">        WORD    bfReserved2;</span><br><span class="line">        DWORD   bfOffBits;<span class="comment">//偏移</span></span><br><span class="line">&#125; BITMAPFILEHEADER, FAR *LPBITMAPFILEHEADER, *PBITMAPFILEHEADER;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagBITMAPINFOHEADER</span>&#123;</span></span><br><span class="line">        DWORD      biSize;</span><br><span class="line">        LONG       biWidth;</span><br><span class="line">        LONG       biHeight;</span><br><span class="line">        WORD       biPlanes;<span class="comment">//调色板</span></span><br><span class="line">        WORD       biBitCount;<span class="comment">//比特位总计</span></span><br><span class="line">        DWORD      biCompression;<span class="comment">//描述</span></span><br><span class="line">        DWORD      biSizeImage;<span class="comment">//Image图像的大小</span></span><br><span class="line">        LONG       biXPelsPerMeter;</span><br><span class="line">        LONG       biYPelsPerMeter;</span><br><span class="line">        DWORD      biClrUsed;</span><br><span class="line">        DWORD      biClrImportant;</span><br><span class="line">&#125; BITMAPINFOHEADER, FAR *LPBITMAPINFOHEADER, *PBITMAPINFOHEADER;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这两个结构体描述bmp图片有关的信息</span></span><br><span class="line"><span class="comment">//一张bmp图片的二进制格式为: (首)BITMAPFILEHEADER+BITMAPINFOHEADER+图片像素点数据(尾)</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/win32/api/wingdi/ns-wingdi-bitmapinfoheader?f1url=?appId=Dev14IDEF1&l=ZH-CN&k=k(wingdi%252FtagBITMAPINFOHEADER);k(tagBITMAPINFOHEADER);k(DevLang-C%252B%252B);k(TargetOS-Windows)&rd=true">tagBITMAPINFOHEADER官方信息查阅</a></p>
<p>bmp文件是的像素点数据是反的,最先的像素点数据在文件最末尾.</p>
<p>一个像素是3个字节</p>
<p><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_8081755/3354801">坐标关系转换相关查阅</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/blog/tags/%E5%BC%80%E5%8F%91/" rel="tag"># 开发</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/blog/2022/04/20/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/" rel="prev" title="驱动开发">
      <i class="fa fa-chevron-left"></i> 驱动开发
    </a></div>
      <div class="post-nav-item">
    <a href="/blog/2022/05/05/64%E4%BD%8D%E9%80%86%E5%90%91/" rel="next" title="64位逆向">
      64位逆向 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Win32%E8%AF%BE%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E5%86%85%E5%AE%B9"><span class="nav-number">1.</span> <span class="nav-text">Win32课程有哪些内容</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81"><span class="nav-number">2.</span> <span class="nav-text">字符编码</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ANSI%E7%BC%96%E7%A0%81"><span class="nav-number">2.1.</span> <span class="nav-text">ANSI编码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%A7%8B%E7%9A%84ASCII%E7%BC%96%E7%A0%81"><span class="nav-number">2.1.1.</span> <span class="nav-text">原始的ASCII编码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ASCII%E7%BC%96%E7%A0%81%E7%9A%84%E6%8B%93%E5%B1%95%EF%BC%9AGB2312%EF%BC%88GBK%EF%BC%89%E6%88%96GB2312-80"><span class="nav-number">2.1.2.</span> <span class="nav-text">ASCII编码的拓展：GB2312（GBK）或GB2312-80</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">实现原理：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">缺点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UNICODE%E7%BC%96%E7%A0%81"><span class="nav-number">2.2.</span> <span class="nav-text">UNICODE编码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#UNICODE%E7%BC%96%E7%A0%81%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="nav-number">2.2.1.</span> <span class="nav-text">UNICODE编码的存储方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#UTF-16"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">UTF-16</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UTF-8"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">UTF-8</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UTF-32"><span class="nav-number">2.2.1.3.</span> <span class="nav-text">UTF-32</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BOM%E5%AD%97%E8%8A%82%E9%A1%BA%E5%BA%8F%E6%A0%87%E8%AF%86"><span class="nav-number">2.2.2.</span> <span class="nav-text">BOM字节顺序标识</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%AE%BD%E5%AD%97%E7%AC%A6"><span class="nav-number">2.3.</span> <span class="nav-text">C语言中的宽字符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%BD%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.3.1.</span> <span class="nav-text">宽字符类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="nav-number">2.3.2.</span> <span class="nav-text">字符常用函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#win32%E7%9A%84API"><span class="nav-number">3.</span> <span class="nav-text">win32的API</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#win32%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.</span> <span class="nav-text">win32的类型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#WIN32%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">5.</span> <span class="nav-text">WIN32中使用字符串</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B"><span class="nav-number">6.</span> <span class="nav-text">进程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">6.1.</span> <span class="nav-text">进程的创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CreateProcess%E5%87%BD%E6%95%B0"><span class="nav-number">6.2.</span> <span class="nav-text">CreateProcess函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LPSTARTUPINFO%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">6.2.1.</span> <span class="nav-text">LPSTARTUPINFO结构体指针指向的结构体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LPPROCESS-INFORMATION%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">6.2.2.</span> <span class="nav-text">LPPROCESS_INFORMATION结构体指针指向的结构体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LPSECURITY-ATTRIBUTES%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">6.2.3.</span> <span class="nav-text">LPSECURITY_ATTRIBUTES结构体指针指向的结构体</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#main%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0"><span class="nav-number">6.3.</span> <span class="nav-text">main函数的参数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%A5%E6%9F%84%E8%A1%A8%EF%BC%88%E4%B8%8E%E4%B8%8A%E4%B8%80%E7%AB%A0%E7%B4%A7%E5%AF%86%E7%9B%B8%E8%BF%9E%EF%BC%89"><span class="nav-number">7.</span> <span class="nav-text">句柄表（与上一章紧密相连）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1"><span class="nav-number">7.1.</span> <span class="nav-text">内核对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1"><span class="nav-number">7.1.1.</span> <span class="nav-text">如何管理内核对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%A5%E6%9F%84%E8%A1%A8"><span class="nav-number">7.2.</span> <span class="nav-text">句柄表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AF%8F%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E9%83%BD%E6%9C%89%E4%B8%80%E4%B8%AA%E5%8F%A5%E6%9F%84%E8%A1%A8"><span class="nav-number">7.2.1.</span> <span class="nav-text">每一个进程都有一个句柄表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%85%B1%E4%BA%AB%E4%B8%80%E4%B8%AA%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1"><span class="nav-number">7.2.2.</span> <span class="nav-text">多进程共享一个内核对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%A5%E6%9F%84%E5%8F%AF%E4%BB%A5%E8%A2%AB%E7%BB%A7%E6%89%BF"><span class="nav-number">7.2.3.</span> <span class="nav-text">句柄可以被继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WIN32%E4%B8%AD%E5%8F%A5%E6%9F%84%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="nav-number">7.2.4.</span> <span class="nav-text">WIN32中句柄的种类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8BID%E4%B8%8E%E7%BA%BF%E7%A8%8BID"><span class="nav-number">8.</span> <span class="nav-text">进程ID与线程ID</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B"><span class="nav-number">9.</span> <span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="nav-number">9.1.</span> <span class="nav-text">创建线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%84%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="nav-number">9.1.1.</span> <span class="nav-text">创建线程的各种方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#C-11%E4%B9%8B%E5%89%8D"><span class="nav-number">9.1.1.1.</span> <span class="nav-text">C++11之前</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-11%E4%B9%8B%E5%90%8E"><span class="nav-number">9.1.1.2.</span> <span class="nav-text">C++11之后</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#thread-%EF%BC%88thread-h%E4%B8%AD%EF%BC%89"><span class="nav-number">9.1.1.3.</span> <span class="nav-text">thread　（thread.h中）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="nav-number">9.2.</span> <span class="nav-text">线程回调函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-number">9.3.</span> <span class="nav-text">线程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A9%E7%BA%BF%E7%A8%8B%E5%81%9C%E4%B8%8B"><span class="nav-number">9.3.1.</span> <span class="nav-text">让线程停下</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%89%E5%BE%85%E7%BA%BF%E7%A8%8B%E7%BB%93%E6%9D%9F"><span class="nav-number">9.3.2.</span> <span class="nav-text">等待线程结束</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#WaitForSingleObject"><span class="nav-number">9.3.2.1.</span> <span class="nav-text">WaitForSingleObject()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WaitForMultipleObjects"><span class="nav-number">9.3.2.2.</span> <span class="nav-text">WaitForMultipleObjects();</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GetExitCodeThread"><span class="nav-number">9.3.2.3.</span> <span class="nav-text">GetExitCodeThread()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="nav-number">9.3.3.</span> <span class="nav-text">线程上下文</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="nav-number">9.4.</span> <span class="nav-text">线程安全问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B4%E7%95%8C%E5%8C%BA%E4%B9%8B%E7%BA%BF%E7%A8%8B%E9%94%81%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">9.4.1.</span> <span class="nav-text">临界区之线程锁的代码实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E4%BD%93"><span class="nav-number">10.</span> <span class="nav-text">互斥体</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%BA%92%E6%96%A5%E4%BD%93"><span class="nav-number">10.1.</span> <span class="nav-text">创建互斥体</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#bInitialOwner%E5%8F%82%E6%95%B0"><span class="nav-number">10.1.1.</span> <span class="nav-text">bInitialOwner参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E4%BD%93%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E4%B8%B4%E7%95%8C%E5%8C%BA%E4%BB%A3%E7%A0%81"><span class="nav-number">10.1.2.</span> <span class="nav-text">互斥体方式实现临界区代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E4%BD%93%E5%AE%9E%E7%8E%B0%E4%B8%B4%E7%95%8C%E5%8C%BA%E4%B8%8E%E7%BA%BF%E7%A8%8B%E9%94%81%E5%AE%9E%E7%8E%B0%E4%B8%B4%E7%95%8C%E5%8C%BA%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">10.1.3.</span> <span class="nav-text">互斥体实现临界区与线程锁实现临界区的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E4%BD%93%E5%8F%AF%E4%BB%A5%E7%94%A8%E4%BA%8E%E5%AE%9E%E7%8E%B0%E5%8F%AA%E8%83%BD%E5%AE%9E%E4%BE%8B%E5%8C%96%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B"><span class="nav-number">10.1.4.</span> <span class="nav-text">互斥体可以用于实现只能实例化一个进程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6"><span class="nav-number">11.</span> <span class="nav-text">事件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E4%BA%8B%E4%BB%B6%E6%9C%89%E6%97%A0%E4%BF%A1%E5%8F%B7"><span class="nav-number">11.1.</span> <span class="nav-text">设置事件有无信号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">11.2.</span> <span class="nav-text">线程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%BA%92%E6%96%A5"><span class="nav-number">11.2.1.</span> <span class="nav-text">线程互斥</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5-1"><span class="nav-number">11.2.2.</span> <span class="nav-text">线程同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%AA%E5%90%8C%E6%AD%A5%E4%B8%8E%E7%9C%9F%E5%90%8C%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="nav-number">11.2.3.</span> <span class="nav-text">伪同步与真同步的区别（重点）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3"><span class="nav-number">12.</span> <span class="nav-text">窗口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#HWND%E7%AA%97%E5%8F%A3%E5%8F%A5%E6%9F%84"><span class="nav-number">12.1.</span> <span class="nav-text">HWND窗口句柄</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GDI-%E5%9B%BE%E5%BD%A2%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3"><span class="nav-number">12.2.</span> <span class="nav-text">GDI  图形设备接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-number">12.3.</span> <span class="nav-text">消息队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AAwindows%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F"><span class="nav-number">12.4.</span> <span class="nav-text">第一个windows窗口程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#WNDCLASS%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">12.4.1.</span> <span class="nav-text">WNDCLASS结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#lpfnWndProc%E6%88%90%E5%91%98%EF%BC%88%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%EF%BC%89"><span class="nav-number">12.4.1.1.</span> <span class="nav-text">lpfnWndProc成员（窗口函数）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CreateWindow%E5%88%9B%E5%BB%BA%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="nav-number">12.4.2.</span> <span class="nav-text">CreateWindow创建窗口函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ShowWindow%E6%98%BE%E7%A4%BA%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="nav-number">12.4.3.</span> <span class="nav-text">ShowWindow显示窗口函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GetMessage%E5%87%BD%E6%95%B0"><span class="nav-number">12.4.4.</span> <span class="nav-text">GetMessage函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DispatchMessage%E5%88%86%E5%8F%91%E6%B6%88%E6%81%AF%E5%87%BD%E6%95%B0"><span class="nav-number">12.4.5.</span> <span class="nav-text">DispatchMessage分发消息函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TranslateMessage%E8%BD%AC%E6%8D%A2%E6%B6%88%E6%81%AF%E5%87%BD%E6%95%B0"><span class="nav-number">12.4.6.</span> <span class="nav-text">TranslateMessage转换消息函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#windows%E7%A8%8B%E5%BA%8F%E8%B0%83%E8%AF%95%E4%BF%A1%E6%81%AF%E7%9A%84%E8%BE%93%E5%87%BA"><span class="nav-number">12.4.7.</span> <span class="nav-text">windows程序调试信息的输出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MSG%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">12.4.8.</span> <span class="nav-text">MSG结构体</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%90%E7%AA%97%E5%8F%A3"><span class="nav-number">12.5.</span> <span class="nav-text">子窗口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AD%90%E7%AA%97%E5%8F%A3"><span class="nav-number">12.5.1.</span> <span class="nav-text">创建子窗口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SeTDlgItemText%E5%87%BD%E6%95%B0"><span class="nav-number">12.5.2.</span> <span class="nav-text">SeTDlgItemText函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3"><span class="nav-number">13.</span> <span class="nav-text">内存相关</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%B8%8E%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98"><span class="nav-number">13.1.</span> <span class="nav-text">虚拟内存与物理内存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="nav-number">13.1.1.</span> <span class="nav-text">虚拟内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98"><span class="nav-number">13.1.2.</span> <span class="nav-text">物理内存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A7%81%E6%9C%89%E5%86%85%E5%AD%98%E4%B8%8E%E7%94%B3%E8%AF%B7%E9%87%8A%E6%94%BE"><span class="nav-number">13.2.</span> <span class="nav-text">私有内存与申请释放</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%81%E6%9C%89%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7%E4%B8%8E%E9%87%8A%E6%94%BE"><span class="nav-number">13.2.1.</span> <span class="nav-text">私有内存申请与释放</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AC%E6%9C%89%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7%E9%87%8A%E6%94%BE"><span class="nav-number">13.3.</span> <span class="nav-text">公有内存申请释放</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AC%E6%9C%89%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7%E9%87%8A%E6%94%BE%E6%A1%88%E4%BE%8B"><span class="nav-number">13.3.1.</span> <span class="nav-text">公有内存申请释放案例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CreateFileMapping%E5%87%BD%E6%95%B0%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="nav-number">13.3.2.</span> <span class="nav-text">CreateFileMapping函数（重点）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MapViewOfFile%E7%89%A9%E7%90%86%E9%A1%B5%E6%98%A0%E5%B0%84%E5%88%B0%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%87%BD%E6%95%B0"><span class="nav-number">13.3.3.</span> <span class="nav-text">MapViewOfFile物理页映射到虚拟地址函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">14.</span> <span class="nav-text">文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3API"><span class="nav-number">14.1.</span> <span class="nav-text">文件相关API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%B7%E7%9B%B8%E5%85%B3API"><span class="nav-number">14.1.1.</span> <span class="nav-text">卷相关API</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#GetLogicalDrives"><span class="nav-number">14.1.1.1.</span> <span class="nav-text">GetLogicalDrives</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GetLogicalDriveStrings"><span class="nav-number">14.1.1.2.</span> <span class="nav-text">GetLogicalDriveStrings</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GetDriveType"><span class="nav-number">14.1.1.3.</span> <span class="nav-text">GetDriveType</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GetVolumeInformation"><span class="nav-number">14.1.1.4.</span> <span class="nav-text">GetVolumeInformation</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="nav-number">14.1.1.4.1.</span> <span class="nav-text">使用案例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95%E7%9B%B8%E5%85%B3API"><span class="nav-number">14.1.2.</span> <span class="nav-text">目录相关API</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CreateDirectory"><span class="nav-number">14.1.2.1.</span> <span class="nav-text">CreateDirectory</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RemoveDirectory"><span class="nav-number">14.1.2.2.</span> <span class="nav-text">RemoveDirectory</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MoveFile"><span class="nav-number">14.1.2.3.</span> <span class="nav-text">MoveFile</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GetCurrentDirectory-x2F-SetCurrentDirectory"><span class="nav-number">14.1.2.4.</span> <span class="nav-text">GetCurrentDirectory&#x2F;SetCurrentDirectory</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3API-1"><span class="nav-number">14.1.3.</span> <span class="nav-text">文件相关API</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CreateFile"><span class="nav-number">14.1.3.1.</span> <span class="nav-text">CreateFile</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B"><span class="nav-number">14.1.3.1.1.</span> <span class="nav-text">案例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GetFileSize"><span class="nav-number">14.1.3.2.</span> <span class="nav-text">GetFileSize</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GetFileAttributes-x2F-GetFileAttributesEx"><span class="nav-number">14.1.3.3.</span> <span class="nav-text">GetFileAttributes()&#x2F;GetFileAttributesEx</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ReadFile-x2F-WriteFile-x2F-CopyFile-x2F-DeleteFile"><span class="nav-number">14.1.3.4.</span> <span class="nav-text">ReadFile()&#x2F;WriteFile()&#x2F;CopyFile()&#x2F;DeleteFile</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E6%A1%88%E4%BE%8B"><span class="nav-number">14.1.3.4.1.</span> <span class="nav-text">读取文件案例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%99%E6%96%87%E4%BB%B6%E6%A1%88%E4%BE%8B"><span class="nav-number">14.1.3.4.2.</span> <span class="nav-text">写文件案例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6%E5%92%8C%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E6%A1%88%E4%BE%8B"><span class="nav-number">14.1.3.4.3.</span> <span class="nav-text">拷贝文件和删除文件案例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FindFirstFile-x2F-FindNextFile"><span class="nav-number">14.1.3.5.</span> <span class="nav-text">FindFirstFile()&#x2F;FindNextFile</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#WIN32-FIND-DATA%E7%BB%93%E6%9E%84"><span class="nav-number">14.1.3.5.1.</span> <span class="nav-text">WIN32_FIND_DATA结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6%E6%A1%88%E4%BE%8B"><span class="nav-number">14.1.3.5.2.</span> <span class="nav-text">查找文件案例</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6"><span class="nav-number">15.</span> <span class="nav-text">内存映射文件实现读写文件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#FlushViewOfFile"><span class="nav-number">15.1.</span> <span class="nav-text">FlushViewOfFile</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9%EF%BC%88%E9%87%8D%E7%82%B9%E7%90%86%E8%A7%A3%EF%BC%89"><span class="nav-number">15.2.</span> <span class="nav-text">系统文件共享的注意点（重点理解）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5%E5%BA%93"><span class="nav-number">16.</span> <span class="nav-text">链接库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93"><span class="nav-number">16.1.</span> <span class="nav-text">静态链接库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E6%96%87%E4%BB%B6"><span class="nav-number">16.1.1.</span> <span class="nav-text">编写静态链接库文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8-%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">16.1.2.</span> <span class="nav-text">静态链接库的使用(两种方式)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93"><span class="nav-number">16.2.</span> <span class="nav-text">动态链接库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DLL%E7%9A%84%E5%85%A5%E5%8F%A3%E7%82%B9"><span class="nav-number">16.2.1.</span> <span class="nav-text">DLL的入口点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93-%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="nav-number">16.2.2.</span> <span class="nav-text">创建动态链接库(两种方法)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93-%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="nav-number">16.2.3.</span> <span class="nav-text">使用动态链接库(两种方法)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%BE%E7%A4%BA%E9%93%BE%E6%8E%A5"><span class="nav-number">16.2.3.1.</span> <span class="nav-text">显示链接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E9%93%BE%E6%8E%A5"><span class="nav-number">16.2.3.2.</span> <span class="nav-text">隐式链接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E9%93%BE%E6%8E%A5%E5%92%8C%E6%98%BE%E7%A4%BA%E9%93%BE%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">16.2.3.3.</span> <span class="nav-text">隐式链接和显示链接的区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93%E5%9C%A8%E6%B1%87%E7%BC%96%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="nav-number">16.3.</span> <span class="nav-text">静态库和动态库在汇编的不同</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8B%E7%BA%BF%E7%A8%8B"><span class="nav-number">17.</span> <span class="nav-text">远程线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#CreateRemoteThread"><span class="nav-number">17.1.</span> <span class="nav-text">CreateRemoteThread</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9C%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%85%A5"><span class="nav-number">17.2.</span> <span class="nav-text">远线程注入</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="nav-number">18.</span> <span class="nav-text">进程间通信</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E7%8E%AF%E9%81%8D%E5%8E%86%E8%BF%9B%E7%A8%8B%E4%BB%A3%E7%A0%81"><span class="nav-number">19.</span> <span class="nav-text">三环遍历进程代码</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E9%9A%90%E8%97%8F"><span class="nav-number">20.</span> <span class="nav-text">模块隐藏</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E9%9A%90%E8%97%8F%E4%B9%8B%E6%96%AD%E9%93%BE"><span class="nav-number">20.1.</span> <span class="nav-text">模块隐藏之断链</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TEB"><span class="nav-number">20.1.1.</span> <span class="nav-text">TEB</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#NtTib%E6%88%90%E5%91%98"><span class="nav-number">20.1.1.1.</span> <span class="nav-text">NtTib成员</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PEB"><span class="nav-number">20.1.2.</span> <span class="nav-text">PEB</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#PEB-LDR-DATA"><span class="nav-number">20.1.2.1.</span> <span class="nav-text">_PEB_LDR_DATA</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#LIST-ENTRY"><span class="nav-number">20.1.2.1.1.</span> <span class="nav-text">LIST_ENTRY</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#LDR-DATA-TABLE-ENTRY"><span class="nav-number">20.1.2.1.2.</span> <span class="nav-text">_LDR_DATA_TABLE_ENTRY</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#UNICODE-STRING%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">20.1.2.1.2.1.</span> <span class="nav-text">_UNICODE_STRING的定义</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#DefaultHeap%E4%B8%8ENtGlobalFlag%E5%8F%8D%E8%B0%83%E8%AF%95%E7%9B%B8%E5%85%B3%EF%BC%88%E5%8F%AA%E5%AF%B9XP%E6%9C%89%E6%95%88%EF%BC%89"><span class="nav-number">20.1.2.1.3.</span> <span class="nav-text">DefaultHeap与NtGlobalFlag反调试相关（只对XP有效）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81"><span class="nav-number">20.1.3.</span> <span class="nav-text">实现代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E9%9A%90%E8%97%8F%E4%B9%8BVAD%E6%A0%91"><span class="nav-number">20.2.</span> <span class="nav-text">模块隐藏之VAD树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%95%E5%9B%BE%E6%A8%A1%E5%9D%97%E5%BD%BB%E5%BA%95%E9%9A%90%E8%97%8F"><span class="nav-number">20.3.</span> <span class="nav-text">试图模块彻底隐藏</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5"><span class="nav-number">21.</span> <span class="nav-text">代码注入</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E5%85%A5ShellCode"><span class="nav-number">21.1.</span> <span class="nav-text">注入ShellCode</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#shellCode%E6%A1%88%E4%BE%8B"><span class="nav-number">21.2.</span> <span class="nav-text">shellCode案例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HOOK"><span class="nav-number">22.</span> <span class="nav-text">HOOK</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFHOOK"><span class="nav-number">22.1.</span> <span class="nav-text">什么是HOOK</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E8%A1%A8HOOK%EF%BC%88VT-HOOK%EF%BC%89"><span class="nav-number">22.2.</span> <span class="nav-text">虚表HOOK（VT HOOK）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E8%A1%A8HOOK%E6%A1%88%E4%BE%8B"><span class="nav-number">22.2.1.</span> <span class="nav-text">虚表HOOK案例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IAT-HOOK"><span class="nav-number">22.3.</span> <span class="nav-text">IAT HOOK</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#INLINE-HOOK"><span class="nav-number">22.4.</span> <span class="nav-text">INLINE HOOK</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Inline-Hook%E6%A1%88%E4%BE%8B"><span class="nav-number">22.4.1.</span> <span class="nav-text">Inline Hook案例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Inline-HOOK%E6%B3%A8%E5%85%A5dll%E7%89%88"><span class="nav-number">22.4.1.1.</span> <span class="nav-text">Inline HOOK注入dll版</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#InlineHook-h"><span class="nav-number">22.4.1.1.1.</span> <span class="nav-text">InlineHook.h</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#dllmain-cpp"><span class="nav-number">22.4.1.1.2.</span> <span class="nav-text">dllmain.cpp</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Inline-HOOK%E6%94%B9%E8%BF%9B%E7%89%88"><span class="nav-number">22.4.2.</span> <span class="nav-text">Inline HOOK改进版</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Inline-HOOK%E6%94%BB%E9%98%B2-%E9%87%8D%E7%82%B9"><span class="nav-number">22.4.3.</span> <span class="nav-text">Inline HOOK攻防(重点)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%B6%E6%AE%B51"><span class="nav-number">22.4.3.1.</span> <span class="nav-text">阶段1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%B6%E6%AE%B52"><span class="nav-number">22.4.3.2.</span> <span class="nav-text">阶段2</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%BB%E6%89%BE%E6%A3%80%E6%B5%8B%E4%BB%A3%E7%A0%81"><span class="nav-number">22.4.3.2.1.</span> <span class="nav-text">寻找检测代码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CRC%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A0%A1%E9%AA%8C%E7%A0%81"><span class="nav-number">22.4.3.2.2.</span> <span class="nav-text">CRC循环冗余校验码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%B6%E6%AE%B53"><span class="nav-number">22.4.3.3.</span> <span class="nav-text">阶段3</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9E%AC%E6%97%B6HOOK-%E4%B8%B4%E6%97%B6HOOK"><span class="nav-number">22.4.3.3.1.</span> <span class="nav-text">瞬时HOOK(临时HOOK)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HOOK%E7%9B%B8%E5%85%B3%E7%BB%83%E4%B9%A0%EF%BC%88%E9%AB%98%E5%B9%B6%E5%8F%91hook%EF%BC%8C%E4%BA%86%E8%A7%A3cmpxchg8b%E6%8C%87%E4%BB%A4%EF%BC%89"><span class="nav-number">22.4.4.</span> <span class="nav-text">HOOK相关练习（高并发hook，了解cmpxchg8b指令）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E5%A4%9A%E6%A0%B8%E7%8E%AF%E5%A2%83%E4%B8%8B%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%AF%B9%E4%B8%80%E4%B8%AA%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E5%86%85%E6%A0%B8%E5%87%BD%E6%95%B0%E8%BF%9B%E8%A1%8CHOOK%E8%80%8C%E4%B8%8D%E4%BC%9A%E5%87%BA%E9%94%99%EF%BC%9F"><span class="nav-number">22.4.4.1.</span> <span class="nav-text">在多核环境下，如何保证对一个高并发的内核函数进行HOOK而不会出错？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%8D%B8%E8%BD%BD%E9%AB%98%E5%B9%B6%E5%8F%91HOOK"><span class="nav-number">22.4.4.2.</span> <span class="nav-text">如何卸载高并发HOOK</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#API%E5%B0%8F%E5%88%97%E8%A1%A8"><span class="nav-number">23.</span> <span class="nav-text">API小列表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B6%88%E6%81%AF"><span class="nav-number">24.</span> <span class="nav-text">自定义消息</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%94%AE%E9%BC%A0%E6%A8%A1%E6%8B%9F"><span class="nav-number">25.</span> <span class="nav-text">键鼠模拟</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#PostMessageA"><span class="nav-number">25.1.</span> <span class="nav-text">PostMessageA</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#keybd-event"><span class="nav-number">25.2.</span> <span class="nav-text">keybd_event()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SendInput"><span class="nav-number">25.3.</span> <span class="nav-text">SendInput()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%92%A9%E5%AD%90%E6%A8%A1%E6%8B%9F%E9%94%AE%E9%BC%A0%E6%93%8D%E4%BD%9C"><span class="nav-number">25.4.</span> <span class="nav-text">钩子模拟键鼠操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A9%B1%E5%8A%A8%E7%BA%A7%E6%A8%A1%E6%8B%9F"><span class="nav-number">25.5.</span> <span class="nav-text">驱动级模拟</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E7%90%86%E8%A7%A3%E7%82%B9"><span class="nav-number">26.</span> <span class="nav-text">全局理解点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%BE%E5%BD%A2%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86"><span class="nav-number">27.</span> <span class="nav-text">图形图像处理</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ZEROKO14</p>
  <div class="site-description" itemprop="description">你好，欢迎来到ZEROKO14的个人博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZEROKO14</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>-->

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/muse.js"></script>


<script src="/blog/js/next-boot.js"></script>


  <script defer src="/blog/lib/three/three.min.js"></script>
    <script defer src="/blog/lib/three/three-waves.min.js"></script>


  















  

  

</body>
</html>
