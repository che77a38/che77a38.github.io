<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zeroko14.gitee.io","root":"/blog/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Q：什么是保护模式？">
<meta property="og:type" content="article">
<meta property="og:title" content="保护模式">
<meta property="og:url" content="http://zeroko14.gitee.io/blog/2022/05/05/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/index.html">
<meta property="og:site_name" content="ZEROKO14的个人博客">
<meta property="og:description" content="Q：什么是保护模式？">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210803161045133.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210721202744811.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210722134228056.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210722135330345.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210722140422465.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210722145554924.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210722141112675.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210722143157677.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210722142547813.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210722145936297.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210722142840195.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210722150950760.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210722143157677.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210722144832857.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210722145152427.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210722145334493.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210820185552204.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/20140711174502103.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210803164459681.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210803145809961.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210816220946809.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210716115523846.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/GDTR-300x103.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210716151328569.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/d6ca7bcb0a46f21fbe09bc4ba26d7c600c33874400db.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/v2-2664817822c89c64a9e8adc8c34495cc_hd.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210716152133226.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210716152630988.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/20180914112453186.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/1226829-20200409145558030-1848157450.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/20180914111021493.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210719173833659.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/20200924170933342.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210720135717758.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210720142837575.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/825979-20180526000445198-633418260.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/825979-20180526000556126-973886506.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/20190117135616418_.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210720150013578.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210720164312737.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210803172413552.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210803202153149.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210803202642190.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210803203101666.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210803203453670.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210803203741984.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210803204001574.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210803204042928.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210803204413648.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210803204541096.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210803204617396.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210804140440130.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210804140726695.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210804141821855.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210804142949147.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/196406-20191230101816343-1359964647.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/196406-20191230101855524-2036155359.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210804145505767.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210804163643397.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210804170022297.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210804170558502.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210804170729597.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210804170914485.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210804181052839.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210804181623445.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210804181720817.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210804183542660.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210804183704599.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210804201255485.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210807195216123.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210804230009598.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210804230204980.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210804230311195.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210804230456028.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210804230842907.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210804231548046.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210804232559040.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210804232907329.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210806163434767.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/2018121811050612.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210806113112935.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210607203904224.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210806171727490.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/20181213133543199.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210806194755824.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210806195008729.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210806195231834.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210806195925841.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210806200039623.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210806200514018.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210806201413231.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210806202256635.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210811145502207.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210808163723779.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/1342712354_1402.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/196406-20200102102107308-1624147754.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/48588_1282618334lclL.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210813135407001.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210813144727834.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210813144750275.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210808175145728.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/123.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/12313213213213.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/20181217172756828.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210814132256597.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210814132349732.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210814132525309.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210814133359037.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210814133524278.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210814134241466.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210814140654925.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210814141149228.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210814142148937.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210810155043085.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210810155400565.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210816225541578.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210816223122790.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210816213131908.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210816223047078.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210816223308855.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210810152110148.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210816174502207.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/2018121811050612.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210816170139162.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210810155043085.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210816171357608.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/67da19ce25a32b127b6e42f82ed6b0a3.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/196406-20200102102107308-1624147754.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210816173952057.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210816174123638.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210816190000468.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210816190714434.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210816190840273.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210817122234616.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/20200220223113225.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/20200221184557778.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/20200221211315395.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210816135130139.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210816164118935.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210816163834960.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210816164556502.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210816164830888.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210816164938808.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210820144620796.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210817141821836.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210817141832675.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210817143849226.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210817151041469.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210818201133076.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210818111918749.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210818120306245.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210822152334263.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210821182319577.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210821192154718.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210819130503077.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210819132944697.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210819142745181.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210819143625209.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210822194231558.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210822211646330.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210822212611498.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210822213911198.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210819144239301.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210819144958741.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210819151236597.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210819151523802.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210819194408894.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210819215515748.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210820124123585.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210820133141085.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210820134644415.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210820135304899.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210820165939064.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210820171447027.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210820171507433.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210820172028590.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210820173459803.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210820173746701.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210820174741733.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210820175813882.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210820180052860.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210820180519008.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210820181214528.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210820181901011.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210824161101189.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210824161159229.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210822171000712.png">
<meta property="article:published_time" content="2022-05-05T07:29:14.974Z">
<meta property="article:modified_time" content="2023-02-10T11:01:15.577Z">
<meta property="article:author" content="ZEROKO14">
<meta property="article:tag" content="内核相关">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210803161045133.png">

<link rel="canonical" href="http://zeroko14.gitee.io/blog/2022/05/05/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>保护模式 | ZEROKO14的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ZEROKO14的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">zeroko14's blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zeroko14.gitee.io/blog/2022/05/05/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="ZEROKO14">
      <meta itemprop="description" content="你好，欢迎来到ZEROKO14的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZEROKO14的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          保护模式
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-05 15:29:14" itemprop="dateCreated datePublished" datetime="2022-05-05T15:29:14+08:00">2022-05-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-10 19:01:15" itemprop="dateModified" datetime="2023-02-10T19:01:15+08:00">2023-02-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Q：什么是保护模式？</p>
<span id="more"></span>

<p>A：x86 CPU的3个模式：</p>
<ol>
<li>实模式</li>
<li>保护模式（虚拟8086模式）</li>
<li>系统管理模式</li>
</ol>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210803161045133.png" alt="image-20210803161045133"></p>
<p>现在的操作系统大多数都是运行于保护模式下的</p>
<p>保护模式就是指给操作系统添加的保护特性，保护的目标是硬件资源和OS内核。</p>
<h1 id="学习前的环境配置"><a href="#学习前的环境配置" class="headerlink" title="学习前的环境配置"></a><strong>学习前的环境配置</strong></h1><p>由于本人使用的操作系统是win10 1909，因此开发当前版本的驱动需要<code>vs2019+Windows 10 WDK 2004(10.0.19041.1) + Windows 10 SDK 2004(10.0.19041.1)</code></p>
<blockquote>
<p>或者10.0.18362.1版本,vs安装要设置<code>C++的桌面开发</code>,<code>通用Windows平台开发(勾选Windows 10 SDK(10.0.18362.0))</code>,<code>Visual Studio拓展开发</code>,完事了wdk也安装10.0.18362版本</p>
</blockquote>
<p><a href="#https://visualstudio.microsoft.com/zh-hans/thank-you-downloading-visual-studio/?sku=Professional&rel=16">vs2019版本安装链接跳转</a></p>
<p>要注意在单个组件中选上：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210721202744811.png" alt="image-20210721202744811"></p>
<p>环境配置的<a target="_blank" rel="noopener" href="https://blog.csdn.net/psbeond/article/details/108780644">参考网址</a></p>
<p>【小注意点】微软官网下载vs2019时有bug，必须等他一段时间弹出下载，不要再点重新下载，不然重新下载的是vs2017，而不是vs2019</p>
<p>下载完毕后，再到微软官网下载Windows 10 WDK 2004(10.0.19041.1)。</p>
<p>至此<code>vs2019+Windows 10 WDK 2004(10.0.19041.1) + Windows 10 SDK 2004(10.0.19041.1)</code>环境就装好了。</p>
<p><a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-257955.htm">虚拟机和符号表对应下载</a></p>
<h2 id="双机调试配置"><a href="#双机调试配置" class="headerlink" title="双机调试配置"></a><strong>双机调试配置</strong></h2><p>由于系统调试要下断点，下断点后系统将只有调试子系统继续运行，因此不能直接调试本机的系统。因此需要<strong>双机调试配置</strong></p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210722134228056.png" alt="image-20210722134228056"></p>
<p>配置双机调试流程</p>
<ol>
<li><p>在本机安装windbg(上述配环境的时候装WDK，里面自带有windbg)</p>
</li>
<li><p>在虚拟机中(WinXP)修改boot.ini（修改系统启动项）</p>
<p>C盘显示隐藏文件，找到boot.ini打开</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210722135330345.png" alt="image-20210722135330345"></p>
<p>原内容：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210722140422465.png" alt="image-20210722140422465"></p>
<p>新内容</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210722145554924.png" alt="image-20210722145554924"></p>
<p>红线为添加行，<code>/debug</code>表示调试模式，第一段黄标为名字，可以随便起；<code>/debugport=com2</code>表示指定的调试串口为com2，下图可见原本只有com1一个串口（黄标）。com2是为后续步骤虚拟机设置步骤中添加的串口</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210722141112675.png" alt="image-20210722141112675"></p>
<p>自己添加的启动项如下图黄标</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210722143157677.png" alt="image-20210722143157677"></p>
</li>
<li><p>设置虚拟机（为虚拟机新增一个串口设备）</p>
<p>添加步骤：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210722142547813.png" alt="image-20210722142547813"></p>
<p>P.s.打印机也会占用一个串口</p>
<p>添加好后查看设备管理器：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210722145936297.png" alt="image-20210722145936297"></p>
<p>黄标为我们刚添加的新串口。</p>
</li>
<li><p>修改Windbg运行参数，指向虚拟机。</p>
<p>Windbg的选择简单参考：调试机器是32位系统就用32位windbg，64位系统就64位windbg(<a target="_blank" rel="noopener" href="https://blog.csdn.net/mergerly/article/details/8602008">实则更为复杂</a>)</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210722142840195.png" alt="image-20210722142840195"><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210722150950760.png" alt="image-20210722150950760"></p>
</li>
</ol>
<p>p.s.   WDK,Windows Driver Kit,用于开发驱动的驱动开发包</p>
<p><strong>准备工作做好后</strong></p>
<h2 id="开始双机调试"><a href="#开始双机调试" class="headerlink" title="开始双机调试"></a>开始双机调试</h2><p>必须在下图界面的时候先别按回车</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210722143157677.png" alt="image-20210722143157677"></p>
<p>本机上打开设置好的windbg，显示正在连接，再到虚拟机中点击回车系统进入调试模式。</p>
<p>此时成功断下，效果如下：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210722144832857.png" alt="image-20210722144832857"></p>
<p>此时系统是断下状态，因此是类似黑屏</p>
<p>此时在windbg命令行中输入g，表示让系统继续执行</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210722145152427.png" alt="image-20210722145152427"></p>
<p>之后还想中断的话，按下图按钮。</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210722145334493.png" alt="image-20210722145334493"></p>
<p>至此双机调试配置成功！</p>
<p>保护模式学习的时候尽量虚拟机要设置为单核，防止干扰。</p>
<h2 id="WinDbg的退出"><a href="#WinDbg的退出" class="headerlink" title="WinDbg的退出"></a>WinDbg的退出</h2><p>通过 <code>q</code> 或者 <code>ALT + F4</code> 退出调试并销毁被调试进程：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">q</span></span><br></pre></td></tr></table></figure>

<p>通过 <code>qd</code> 退出调试，但被调试进程继续运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">qd</span></span><br></pre></td></tr></table></figure>

<p><strong>部分使用方式</strong></p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210820185552204.png" alt="image-20210820185552204"></p>
<p>一些细节：</p>
<ul>
<li>8086CPU不支持将数据直接送入寄存器的操作， <code>mov ds, 1000H</code> 这条指令是非法的。想要将 <code>1000H</code> 送入DS，需要使用一个寄存器进行中转，先将 <code>1000H</code> 送入一个一般的寄存器，再将这个寄存器中的内容送入DS</li>
<li>8086的入栈和出栈操作都是以 <strong>字</strong> 为单位进行的</li>
<li>栈空的时候 <code>SS:SP</code> 指向栈空间最高地址单元的下一个单元，如果把 <code>10000H-1000FH</code> 这段空间当作栈，初始状态栈是空的的时候 <code>SS:SP</code> &#x3D; <code>1000:0010</code></li>
<li>用 <code>xor ax, ax</code> 或者 <code>sub ax, ax</code> 而不是 <code>mov ax, 0</code> 来将 <code>ax</code> 清零的主要原因是前两个（在32位下）的机器码是3个字节，而 <code>mov ax,0</code> 的机器码是4个字节。</li>
<li>执行 <code>push</code> 时，CPU要进行两步操作：先改变 <code>SP</code> ，后向 <code>SS:SP</code> 处传送。执行 <code>POP</code> 时，CPU先读取 <code>SS:SP</code> 处的数据，然后改变 <code>sp</code> 。</li>
<li>一个栈段最大64K（在8086CPU环境下），因为栈顶的变化范围是 <code>0-FFFFH</code> 。如果一直压栈的话栈顶将环绕，覆盖原来栈中的内容</li>
<li><strong>在汇编源程序中，数据不能以字母开头，所以要在前面加0</strong></li>
</ul>
<hr>
<ul>
<li>Q：为什么不直接学习x64</li>
<li>A：x86是由Intel推出的一种复杂指令集，能够生产支持这种指令集。CPU公司主要是Intel和AMD。AMD在1999年的时候，拓展了这套指令集，称为x86-64，后改名为AMD64，Intel也兼容了这个产品，称为Intel 64。但AMD64和Intel64几乎是一样的，所以在很多资料中统称为x64。而这套指令集是对x86的拓展，向下兼容的。</li>
</ul>
<p><strong>保护模式有什么特点？</strong></p>
<ol>
<li>段的机制</li>
<li>页的机制</li>
</ol>
<p>通过这两种机制来达到保护<code>系统的一些数据结构，还有一些关键的寄存器</code>的目的。</p>
<ul>
<li>Q：学习保护模式有什么用？</li>
<li>A：真正理解内核是如何运作的</li>
</ul>
<p>参考书：**&lt;Intel 白皮书第三卷&gt;**，3,4,5,6,7章</p>
<p>p.s.</p>
<ol>
<li>Intel白皮书第二卷是查指令的</li>
<li>Intel 白皮书第三卷是讲保护模式的</li>
</ol>
<h1 id="保护模式–段"><a href="#保护模式–段" class="headerlink" title="保护模式–段"></a>保护模式–段</h1><p>保护模式的2种重要机制：</p>
<ul>
<li>段</li>
<li>页</li>
</ul>
<p>保护模式知识结构总览：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/20140711174502103.jpg" alt="20140711174502103"></p>
<p>段的机制非常复杂，想了解段的机制要先了解段寄存器。</p>
<p>为何需要段的机制？16位系统的寄存器为16位二进制，只可以寻址64KB（2的16次方除以1024等于64）的大小内存，<code>左移四位再加一千来索引1MB内存</code>，因此出现了段的机制可以解决这个问题。</p>
<p>由于32位系统寄存器是32位，所以上述功能（base的功能)已经被弱化了，仅留下重要的是权限检查机制。</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210803164459681.png" alt="image-20210803164459681"></p>
<p>32位以后，现在除了FS寄存器以外，其他段寄存器的base字段已经全部设置为0了</p>
<h2 id="段寄存器结构"><a href="#段寄存器结构" class="headerlink" title="段寄存器结构"></a>段寄存器结构</h2><p>段寄存器有哪些</p>
<p>ES CS SS DS FS GS LDTR TR GDTR IDTR等等</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210803145809961.png" alt="image-20210803145809961"></p>
<ul>
<li><p>代码段寄存器CS（Code Segment）</p>
<p>​		存放当前正在运行的程序代码所在段的段基址，表示当前使用的指令代码可以从该段寄存器指定的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E5%99%A8">存储器</a>段中取得，相应的偏移量则由IP提供。</p>
</li>
<li><p>数据段寄存器DS（Data Segment）</p>
<p>​		指出当前程序使用的数据所存放段的最低地址，即存放数据段的段基址。</p>
</li>
<li><p>堆栈段寄存器SS（Stack Segment）</p>
<p>​		指出当前堆栈的底部地址，即存放堆栈段的段基址。</p>
</li>
<li><p>附加段寄存器ES（Extra Segment）</p>
<p>​		指出当前程序使用附加<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E6%AE%B5">数据段</a>的段基址，该段是串操作指令中目的串所在的段。</p>
</li>
</ul>
<h3 id="段寄存器的结构"><a href="#段寄存器的结构" class="headerlink" title="段寄存器的结构"></a>段寄存器的结构</h3><p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210816220946809.png" alt="image-20210816220946809"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SegMent</span></span><br><span class="line">&#123;</span><br><span class="line">	WORD Selector;	<span class="comment">//16位Selecter（可见部分），段选择子</span></span><br><span class="line">	WORD Attributes;	<span class="comment">//12位Attribute</span></span><br><span class="line">	DWORD Base;		<span class="comment">//32位Base</span></span><br><span class="line">	DWORD Limit;	<span class="comment">//32位Limit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们能看到的段寄存器的值只有可见部分的16位。</p>
<blockquote>
<p>段寄存器中有16位是可见部分，有八十位是不可见部分，一共92位。<br>可见部分为16位的Selector部分<br>12位的Attribute为这个段寄存器的属性，它的意义为：表示该段寄存器是可读还是可写还是可执行的。<br>32位的Base表示该段是从哪里开始的。<br>32位的Limit表示整个段的长度有多少。</p>
</blockquote>
<h3 id="段寄存器的读写"><a href="#段寄存器的读写" class="headerlink" title="段寄存器的读写"></a>段寄存器的读写</h3><h4 id="读段寄存器"><a href="#读段寄存器" class="headerlink" title="读段寄存器"></a>读段寄存器</h4><p>比如：MOV AX,ES	<strong>读的时候，只能读16位的可见部分（必须写rX,不能写其他如ErX）</strong></p>
<p>读写LDTR的指令为：SLDT&#x2F;LLDT</p>
<p>读写TR的指令为：STR&#x2F;LTR</p>
<h4 id="写段寄存器"><a href="#写段寄存器" class="headerlink" title="写段寄存器"></a>写段寄存器</h4><p>比如：MOV DS,AX	<strong>写时是写92位</strong></p>
<h4 id="段寄存器属性探测"><a href="#段寄存器属性探测" class="headerlink" title="段寄存器属性探测"></a>段寄存器属性探测</h4><table>
<thead>
<tr>
<th>段寄存器</th>
<th>Selector</th>
<th>Attribute</th>
<th>Base</th>
<th>Limit</th>
</tr>
</thead>
<tbody><tr>
<td>ES</td>
<td><em><code>0023</code></em></td>
<td>可读可写</td>
<td>0</td>
<td>0xFFFFFFFF</td>
</tr>
<tr>
<td>CS</td>
<td><em><code>001B</code></em></td>
<td>可读可执行</td>
<td>0</td>
<td>0xFFFFFFFF</td>
</tr>
<tr>
<td>SS</td>
<td><em><code>0023</code></em></td>
<td>可读可写</td>
<td>0</td>
<td>0xFFFFFFFF</td>
</tr>
<tr>
<td>DS</td>
<td><em><code>0023</code></em></td>
<td>可读可写</td>
<td>0</td>
<td>0xFFFFFFFF</td>
</tr>
<tr>
<td>FS</td>
<td><em><code>003B</code></em></td>
<td>可读可写</td>
<td><em><code>0x7FFDE000</code></em></td>
<td>0xFFF</td>
</tr>
<tr>
<td>GS</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<p>上图中有这个*<code>标记</code>*的表示他在不同操作系统的该值不一致</p>
<p>GS在windows中不使用，所以用短横杠填写。</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210716115523846.png" alt="image-20210716115523846"></p>
<p>上图的原因是ds段寄存器此时实际上是cs寄存器，cs寄存器不可写。</p>
<p>把cs换成es就不会报错，因为es段是可写的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> var=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm</span><br><span class="line">	&#123;</span><br><span class="line">    	mov ax,fs</span><br><span class="line">    	mov gs,ax</span><br><span class="line">    	mov eax,dword ptr ds:[<span class="number">0x1000</span>]</span><br><span class="line">    	<span class="comment">//上面相当于mov eax,dword ptr fs:[0x1000]</span></span><br><span class="line">    	<span class="comment">//由于fs的limit为0xFFF,0x1000&gt;0xFFF，所以访问报错</span></span><br><span class="line">    	mov dword ptr ds:[var],eax</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写一个段寄存器的时候我们只给了16位，那么剩下的76位来自于哪里呢？</p>
<h3 id="段描述符与段选择子"><a href="#段描述符与段选择子" class="headerlink" title="段描述符与段选择子"></a>段描述符与段选择子</h3><p><strong>保护模式下三个重要的系统表——GDT、LDT和IDT</strong></p>
<ul>
<li>GDT全局描述符表</li>
<li>LDT局部描述符表(在windows中没有使用)</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/davytitan/p/12094857.html">中断描述符表 IDT</a></li>
</ul>
<p>当我们执行类似MOV DS,AX指令时，CPU会查表，根据AX的值来决定查找GDT还是LDT，查表的什么位置，查出多少数据。</p>
<p>gdtr是一个寄存器（48位），存储的是表的开始位置（32位）和长度(16位)</p>
<p>GDTR寄存器中存放的是GDT在内存中的基地址和其表长界限。</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/GDTR-300x103.jpg" alt="GDTR-300x103"></p>
<p>前16位是保存GDT里面的限长，后17到42位保存的是段基址</p>
<p>ldtr和gdtr有区别，存的是段选择子。</p>
<p>汇编指令LGDT和SGDT分别用于加载和保存GDTR寄存器的内容。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kd&gt;r gdtr<span class="comment">//查看gdtr寄存器，gdt这样表在哪里。（r表示查看寄存器）</span></span><br><span class="line">gtdr=<span class="number">8003f</span>000</span><br><span class="line">kd&gt;r gdtl<span class="comment">//查看的也是gdtr寄存器，查看gdt表有多长。</span></span><br><span class="line">gdtl=<span class="number">000003F</span>F</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210716151328569.png" alt="image-20210716151328569"></p>
<p>图中dd命令罗列出来的就是GDT表。</p>
<p>剩下的76位来自于GDT表，表里存储的元素我们叫<strong>段描述符</strong></p>
<h4 id="段描述符"><a href="#段描述符" class="headerlink" title="段描述符"></a>段描述符</h4><p>每个段描述符是8个字节，即64位。</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/d6ca7bcb0a46f21fbe09bc4ba26d7c600c33874400db.png" alt="d6ca7bcb0a46f21fbe09bc4ba26d7c600c33874400db"></p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/v2-2664817822c89c64a9e8adc8c34495cc_hd.png" alt="v2-2664817822c89c64a9e8adc8c34495cc_hd"></p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210716152133226.png" alt="image-20210716152133226"></p>
<p>黄色荧光笔标记出来的是图解中的低32位。</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210716152630988.png" alt="image-20210716152630988"></p>
<p>dq是按照qword（8字节）来分组，后接的L40表示显示0x40组。</p>
<h4 id="段选择子"><a href="#段选择子" class="headerlink" title="段选择子"></a>段选择子</h4><p>段选择子是一个16位的段描述符，该描述符指向了定义该段的段描述符。</p>
<p>写段寄存器的时候写的就是段选择子。</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/20180914112453186.png" alt="20180914112453186"></p>
<ul>
<li><p>RPL:请求特权级别</p>
</li>
<li><p>TI:</p>
<ul>
<li>TI&#x3D;0查GDT表</li>
<li>TI&#x3D;1查LDT表（Windows没有使用）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/1226829-20200409145558030-1848157450.png" alt="1226829-20200409145558030-1848157450"></p>
</li>
<li><p>INDEX： 处理器将索引值乘以8再加上GDT表的基址，就是要加载的段描述符</p>
</li>
</ul>
<h5 id="加载段描述符到段寄存器"><a href="#加载段描述符到段寄存器" class="headerlink" title="加载段描述符到段寄存器"></a>加载段描述符到段寄存器</h5><p>除了MOV指令，我们还可以使用LES，LSS，LDS，LFS，LGS指令修改寄存器（L表示load，LES表示load ES即加载ES段寄存器）</p>
<p>CS不能通过上述的指令进行修改，<strong>CS为代码段，CS的改变会导致EIP实际指向的代码的改变</strong>，要改变CS，必须要保证CS与EIP一起改，后面会讲。</p>
<p><strong>LES的使用案例</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buffer[<span class="number">6</span>];</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">    les ecx,fword ptr ds:[buffer]<span class="comment">//fword表示6个字节，高2个字节(段选择子)给es，低四个字节给ecx</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//提供的RPL&lt;=DPL（数值上）,才能成功</span></span><br></pre></td></tr></table></figure>

<h4 id="段描述符的属性"><a href="#段描述符的属性" class="headerlink" title="段描述符的属性"></a>段描述符的属性</h4><p>段寄存器的值是通过<strong>段描述符填充</strong>的</p>
<p>但段描述符只有64位，如何从64位变成76位(76位是92位撇去段选择子的16位)</p>
<p>LIMIT多了12位。(参考下方G位的讲解)</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/20180914111021493.png" alt="20180914111021493"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegMent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	WORD Selector;	<span class="comment">//16位Selecter（可见部分），段选择子</span></span><br><span class="line">	WORD Attributes;	<span class="comment">//12位Attribute</span></span><br><span class="line">	DWORD Base;		<span class="comment">//32位Base</span></span><br><span class="line">	DWORD Limit;	<span class="comment">//32位Limit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Attributes</strong>对应的是高4字节从第8位开始到第15位，第20位开始到23位结束共12位。</li>
<li><strong>Base</strong>是【高4字节的24<del>31位】+【高四字节的第0</del>7位】+【低四字节的16~31位】共同组成的32位</li>
<li><strong>Limit</strong>是【高4字节的16<del>19位】+【低4字节的0</del>15】确定了20位，<strong>剩下的12位依赖G位</strong>(下有详情)</li>
</ul>
<h5 id="P位和G位"><a href="#P位和G位" class="headerlink" title="P位和G位"></a>P位和G位</h5><h6 id="P位"><a href="#P位" class="headerlink" title="P位"></a>P位</h6><ul>
<li>P&#x3D;1	表示段描述符有效</li>
<li>P&#x3D;0	表示段描述符无效</li>
</ul>
<p>当我们将一个段描述符加载到段寄存器的时候，CPU做的第一件事就是检查P位，如果P为0，后续的检查就不做了，若P为1，后续的检查才做。</p>
<h6 id="G位"><a href="#G位" class="headerlink" title="G位"></a>G位</h6><ul>
<li>G&#x3D;0	表示limit的单位是字节。<strong>在前面填充0x000</strong>补齐32位，此时LIMIT的值就是0x000XXXXX的字节大小。</li>
<li>G&#x3D;1	表示limit的单位是4Kb，4kb的地址为0~0xFFF(十进制4095)，如果是G&#x3D;1的话，<strong>在后面填充0xFFF</strong>。此时LIMIT为0xXXXXXFFF</li>
</ul>
<p>p.s.  FS对应的段描述符比较特殊，查分后的值与段寄存器中的值不符合，讲到操作系统(线程)的时候会有解释。</p>
<h5 id="S位和TYPE域"><a href="#S位和TYPE域" class="headerlink" title="S位和TYPE域"></a>S位和TYPE域</h5><h6 id="S位"><a href="#S位" class="headerlink" title="S位"></a>S位</h6><p>当我们将一个段描述符加载到段寄存器的时候，CPU做的第一件事就是检查P位，第二件事就是判断该段描述符是<code>[数据或代码段描述符]</code>还是<code>[系统段描述符]</code></p>
<ul>
<li>S&#x3D;1	代码段或者数据段描述符</li>
<li>S&#x3D;0	系统段描述符</li>
</ul>
<p>P位为1，并且S位为1，DPL只有两种情况(即要么是全0，要么全1)，所以可知GDT中，下图标黄部<strong>如果是9(二进制1001)或者F(二进制1111)表示此段是代码段或者数据段描述符</strong>。</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210719173833659.png" alt="image-20210719173833659"></p>
<h6 id="TYPE域"><a href="#TYPE域" class="headerlink" title="TYPE域"></a>TYPE域</h6><p><strong>type域的含义根据S位来变化</strong></p>
<ol>
<li><strong>当S&#x3D;1时</strong></li>
</ol>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/20200924170933342.png" alt="20200924170933342"></p>
<p>TYPE域中的第一位，也就是段描述符高4字节的第11位，区分该段到底是代码段还是数据段。如果有是1，则表示代码段，如果是0，表示数据段。</p>
<p><strong>SS与FS都属于数据段</strong>。</p>
<p>这意味着下图标黄的16进制位，如果<strong>大于等于8，则表示是代码段，否则是数据段</strong>。</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210720135717758.png" alt="image-20210720135717758"></p>
<p><strong>A 访问位</strong>：表示该位最后一次被操作系统清零后，该段是否被访问过。每当处理器将该段选择符置入某个段寄存器时，就将该位置1。</p>
<p><strong>C 表示一致位</strong></p>
<ul>
<li>C&#x3D;1	一致代码段</li>
<li>C&#x3D;0	非一致代码段</li>
</ul>
<p><strong>E 拓展方向</strong></p>
<ul>
<li>E&#x3D;0	向上拓展</li>
<li>E&#x3D;1	向下拓展</li>
</ul>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210720142837575.png" alt="image-20210720142837575"></p>
<p>图中橙色部分表示段所在位置。向上拓展是从fs.Base到fs.Base+Limit的区间，而向下拓展是该区间取反的区间</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/825979-20180526000445198-633418260.png" alt="825979-20180526000445198-633418260"><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/825979-20180526000556126-973886506.png" alt="825979-20180526000556126-973886506"></p>
<ol start="2">
<li><strong>当S&#x3D;0时</strong></li>
</ol>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/20190117135616418_.png" alt="20190117135616418_"></p>
<h5 id="D-x2F-B位"><a href="#D-x2F-B位" class="headerlink" title="D&#x2F;B位"></a>D&#x2F;B位</h5><p>D&#x2F;B位对三种段有影响。</p>
<ol>
<li><p>对CS段的影响</p>
<p>​	D&#x3D;1	采用32位寻址方式</p>
<p>​	D&#x3D;0	采用16位寻址方式</p>
<p>​	（前缀67	改变寻址方式	方便观察16位寻址方式是什么样的）</p>
</li>
<li><p>对SS段的影响（数据段的段描述符加载到SS段里他就是SS段了，但本质还是数据段）</p>
<p>​	D&#x3D;1	隐式堆栈访问指令(如：PUSH POP CALL)使用32位堆栈指针寄存器ESP</p>
<p>​	D&#x3D;0	隐式堆栈访问指令(如：PUSH POP CALL)使用16位堆栈指针寄存器SP</p>
</li>
<li><p>向下拓展的数据段</p>
<p>​	D&#x3D;1	向下拓展段上限为4GB</p>
<p>​	D&#x3D;0	向下拓展段上限为64KB</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210720150013578.png" alt="image-20210720150013578"></p>
</li>
</ol>
<p>红色表示该段的区间。D&#x3D;0表示上图右侧，两块红色相加为64KB。</p>
<h5 id="AVL属性"><a href="#AVL属性" class="headerlink" title="AVL属性"></a>AVL属性</h5><p>AVL属性占1个比特，该属性的意义可由操作系统、应用程序自行定义。<br>Intel保证该位不会被占用作为其他用途。</p>
<h5 id="段权限检查（CPL，RPL-DPL）"><a href="#段权限检查（CPL，RPL-DPL）" class="headerlink" title="段权限检查（CPL，RPL,DPL）"></a>段权限检查（CPL，RPL,DPL）</h5><p>段选择子加载到段寄存器中，要进行段权限检查。</p>
<p><strong>CPU分级</strong></p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210720164312737.png" alt="image-20210720164312737"></p>
<p>windows只使用了三环和零环。</p>
<p><strong>R3与R0的理解</strong></p>
<p>R0不能调用R3的函数，但是R0可以访问R3的内存空间，因此可以把函数拷贝到R0的内存空间再通过函数指针的方式调用，还要切换CR3，涉及后续课程知识。</p>
<h6 id="如何查看程序处于几环"><a href="#如何查看程序处于几环" class="headerlink" title="如何查看程序处于几环"></a>如何查看程序处于几环</h6><p><strong>CPL</strong>（Current Privilege Level）：<strong>当前特权级</strong></p>
<p>段选择子后<strong>2位</strong>(段选择子后两位为RPL，但CS和SS的段选择子的后两位比较特殊，表示CPL)：当前环数。</p>
<p>x86规定了CS和SS的后两位一定是一样的。</p>
<p><strong>DPL</strong>（Descriptor Privilege Level）：<strong>描述符特权级别</strong></p>
<p>DPL存储在段描述符中，规定了访问该段所需要的特权级别是什么</p>
<blockquote>
<p>通俗的理解：</p>
<p>如果你想访问我，那么你应该具备什么特权。</p>
<p>举例说明：</p>
<p>mov DS,AX</p>
<p>如果AX指向的段DPL &#x3D; 0	但当前程序的CPL &#x3D; 3	这行指令是不会成功的（因为权限检查的时候通不过）</p>
</blockquote>
<p><strong>RPL</strong>（Request Privilege Level）：<strong>请求的特权级别</strong></p>
<p>RPL是针对段选择子而言的，每个段的选择子都有自己的RPL</p>
<h6 id="数据段的权限检查"><a href="#数据段的权限检查" class="headerlink" title="数据段的权限检查"></a>数据段的权限检查</h6><p>参考如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比如当前程序处于0环，也就是说CPL=0</span></span><br><span class="line">Mov ax<span class="number">.000B</span>		<span class="comment">//1011	RPL=3</span></span><br><span class="line">Mov ds,ax		<span class="comment">//ax指向的段描述符的DPL=0</span></span><br></pre></td></tr></table></figure>

<p><strong>数据段的权限检查流程</strong><br>$$<br>CPL &lt;&#x3D; DPL	并且	RPL &lt;&#x3D; DPL (数值上的比较)<br>$$<br>由于上面代码中RPL&gt;DPL，所以权限检查无法通过。</p>
<p>注意：</p>
<p>代码段和系统段描述符中的检查方式并不一样，具体参考后面课程。（上面仅为数据段的权限流程检查）</p>
<h6 id="词汇总结"><a href="#词汇总结" class="headerlink" title="词汇总结"></a>词汇总结</h6><ul>
<li>CPL	CPU当前的权限级别</li>
<li>DPL	如果你想访问我，你应该具备什么样的权限</li>
<li>RPL	用什么权限去访问一个段</li>
</ul>
<h2 id="代码跨段"><a href="#代码跨段" class="headerlink" title="代码跨段"></a>代码跨段</h2><p><strong>本质就是修改CS段寄存器</strong></p>
<p>段寄存器：</p>
<p>ES,CS,SS,DS,FS,GS,LDTR,TR</p>
<p>段寄存器读写：除CS，LDTR,TR外，其他的段寄存器都可以通过MOV,LES,LSS,LSD,LFS,LGS指令进行修改。</p>
<p>CS为什么不可以直接修改呢？</p>
<p>CS(代码段)的改变意味着EIP的改变，改变CS的同时必须修改EIP，所以我们无法使用上面的指令来进行修改。</p>
<h3 id="代码间的跳转-段间跳转非调用门之类的"><a href="#代码间的跳转-段间跳转非调用门之类的" class="headerlink" title="代码间的跳转(段间跳转	非调用门之类的)"></a>代码间的跳转(段间跳转	非调用门之类的)</h3><p>段间跳转，有2种情况，即要跳转的段是一致代码还是非一致代码段。</p>
<ul>
<li>同时修改CS与EIP的指令：<code>JMP FAR</code> &#x2F; <code>CALL FAR</code> &#x2F; <code>RETF</code> &#x2F; <code>INT</code> &#x2F; <code>IRETD</code>&#x2F; <code>IRET</code></li>
<li>【注意】只修改EIP的指令：<code>JMP</code> &#x2F; <code>CALL</code> &#x2F; <code>JCC</code> &#x2F; <code>RET</code></li>
</ul>
<p>p.s.以前IRETD<code>/ </code>IRET&#96;这两个指令前者是32位，后者是16位的，但现在根据D&#x2F;B位已经没有区别了，默认都是32位。</p>
<h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JMP 0x20:0x004183D7	--CPU如何执行该指令(长跳转/段间跳转)</span><br></pre></td></tr></table></figure>

<ol>
<li><p>段选择子拆分</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x20</span>	对应二进制形式	<span class="number">0000</span> <span class="number">0000</span> <span class="number">0010</span> <span class="number">0000</span></span><br><span class="line">    RPL=<span class="number">00</span></span><br><span class="line">    TI=<span class="number">0</span></span><br><span class="line">    Index=<span class="number">4</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查表得到段描述符</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)TI=<span class="number">0</span>，所以查GDT表</span><br><span class="line">(<span class="number">2</span>)Index=<span class="number">4</span>，所以找到对应的段描述符（四种情况的段描述符才可以跳转：代码段，调用门，TSS任务段，任务门）</span><br></pre></td></tr></table></figure>
</li>
<li><p>权限检查</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果是非一致代码段，要求：CPL == DPL 并且 RPL &lt;= DPL(数值上)</span><br><span class="line">如果是一致代码段，要求：CPL &gt;= DPL(数值上)</span><br></pre></td></tr></table></figure>

<p>​	一致代码段（又名共享段）的理解：这个代码段是提供一些功能让应用层直接可以访问而不破坏内核的代码，就用一致代码段来修饰。</p>
<p>​	反之不想应用层访问，就用非一致代码段修饰。</p>
</li>
<li><p>加载段描述符</p>
<p>​	通过上面的权限检查后，CPU会将0x20段选择子对应的段描述符加载到CS段寄存器中</p>
</li>
<li><p>代码执行</p>
<p>​	CPU将CS.Base+Offset的值写入EIP，然后执行CS:EIP处的代码，段间跳转结束</p>
</li>
</ol>
<h4 id="【总结】"><a href="#【总结】" class="headerlink" title="【总结】"></a>【总结】</h4><p>对于<strong>一致代码段</strong>，也就是共享的段</p>
<ul>
<li>特权级高的程序不允许访问特权级低的数据：核心态不允许访问用户态的数据</li>
<li>特权级低的程序可以访问到特权级高的数据，但特权级不会改变：用户态还是用户态</li>
</ul>
<p>对于普通代码段，也就是<strong>非一致代码段</strong></p>
<ul>
<li>只允许同级访问</li>
<li>绝对禁止不同级别的访问：核心态不能访问用户态，用户态不能访问核心态。</li>
</ul>
<p>直接对代码段进行JMP或者CALL的操作，无论目标是一致代码段还是非一致代码段，CPL都不会发生改变。如果要提升CPL的权限，只能通过<strong>调用门</strong>。</p>
<h4 id="【最终总结】"><a href="#【最终总结】" class="headerlink" title="【最终总结】"></a>【最终总结】</h4><ol>
<li>为了对数据进行保护，普通代码段是禁止不同级别进行访问的。用户态的代码不能访问内核的数据，同样，内核态的代码也不能访问用户态的数据。</li>
<li>如果想提供一些通用的功能，而且这些功能并不会破坏内核数据，那么可以选择一致代码段，这些低级别的程序可以在不提升CPL权限等级的情况下既可以访问。</li>
<li>如果想访问普通代码段，只有通过“调用门”等提升CPL权限，才能访问。</li>
</ol>
<h4 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h4><p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210803172413552.png" alt="image-20210803172413552"></p>
<p>黄标表示如何查找gdt表。</p>
<p>eq表示往某地址写入某内存。</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210803202153149.png" alt="image-20210803202153149"></p>
<p>虚拟机中xp系统中的OD进行测试</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210803202642190.png" alt="image-20210803202642190"></p>
<p>004B表示段选择子，index为9(二进制1001)，索引的段寄存器正是上上图黄标位置的段描述符。</p>
<p>单步执行看是否可以跳转到44E082地址</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210803203101666.png" alt="image-20210803203101666"></p>
<p>成功跳转。</p>
<p>将段描述符的RPL修改为0环。此时预测权限验证应该会失败。</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210803203453670.png" alt="image-20210803203453670"></p>
<p>修改后，再次尝试跳转</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210803203741984.png" alt="image-20210803203741984"></p>
<p>单步执行</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210803204001574.png" alt="image-20210803204001574"></p>
<p>按shift+F7</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210803204042928.png" alt="image-20210803204042928"></p>
<p>进入ntdll了，即进入异常模块了。和预期的结果一致，权限验证失败。</p>
<p>将对应段描述符修改为一致代码段</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210803204413648.png" alt="image-20210803204413648"></p>
<p>od中执行同一条指令：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210803204541096.png" alt="image-20210803204541096"></p>
<p>单步执行</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210803204617396.png" alt="image-20210803204617396"></p>
<p>成功跳转，一句话总结实验：<strong>低权限(CPL&#x3D;3)代码段用零环的权限(RPL&#x3D;0)访问低权限代码段(DPL&#x3D;3)成功</strong>，因为是一致代码段</p>
<blockquote>
<p>如果是非一致代码段，要求：CPL &#x3D;&#x3D; DPL 并且 RPL &lt;&#x3D; DPL<br>如果是一致代码段，要求：CPL &gt;&#x3D; DPL</p>
</blockquote>
<h2 id="长调用与短调用"><a href="#长调用与短调用" class="headerlink" title="长调用与短调用"></a>长调用与短调用</h2><p>我们通过JMP FAR可以实现段间的跳转，如果要实现跨段的调用就必须要学习CALL FAR，也就是长调用。</p>
<p>CALL FAR比JMP FAR要复杂，JMP并不影响堆栈，但CALL指令会影响堆栈，所以长调用比长跳转要复杂。</p>
<h3 id="短调用"><a href="#短调用" class="headerlink" title="短调用"></a>短调用</h3><p>指令格式：CALL 立即数&#x2F;寄存器&#x2F;内存</p>
<p>短CALL是push了一个返回地址，EIP修改为调用位置。</p>
<p>发生改变的寄存器：ESP和EIP。</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210804140440130.png" alt="image-20210804140440130"></p>
<h3 id="长调用-跨段不提权"><a href="#长调用-跨段不提权" class="headerlink" title="长调用(跨段不提权)"></a>长调用(跨段不提权)</h3><p>指令格式：CALL CS:EIP(EIP是废弃的)</p>
<p>【注意】：长调用的调用地址并不是由EIP决定的，而是<strong>通过CS段选择子找到段描述符(该段描述符必须是一个调用门)算出来的</strong>。</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210804140726695.png" alt="image-20210804140726695"></p>
<p>发生改变的寄存器：ESP EIP CS</p>
<p>通过长调用执行完代码后是通过长返回<strong>RETF</strong>返回。返回的时候，会将上图红色的调用者CS重新赋值给CS段寄存器</p>
<h3 id="长调用-跨段并提权"><a href="#长调用-跨段并提权" class="headerlink" title="长调用(跨段并提权)"></a>长调用(跨段并提权)</h3><p>指令格式：CALL CS:EIP(EIP是废弃的)</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210804141821855.png" alt="image-20210804141821855"></p>
<p>ESP3表示当前执行的权限为3环。堆栈发生了切换，<strong>右边的堆栈已经不是左边的堆栈了，而是一个零环的堆栈了</strong>。</p>
<p>发生改变的寄存器：ESP EIP CS SS</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210804142949147.png" alt="image-20210804142949147"></p>
<h3 id="【总结】-1"><a href="#【总结】-1" class="headerlink" title="【总结】"></a>【总结】</h3><ol>
<li>跨段调用时，一旦有权限切换，就会切换堆栈</li>
<li>CS的权限一旦改变，SS的权限也要随着改变，CS与SS的等级必须一样</li>
<li>JMP FAR只能跳转到同级非一致代码段，但CALL FAR可以通过调用门提权，提升CPL的权限。</li>
</ol>
<p>SS与ESP从哪里来？参见TSS段。</p>
<h2 id="调用门"><a href="#调用门" class="headerlink" title="调用门"></a>调用门</h2><p>调用门执行六项功能：</p>
<ol>
<li>它指定要访问的代码段。</li>
<li>它为指定代码段中的过程定义了一个入口点。</li>
<li>它指定尝试访问过程的调用者所需的权限级别。</li>
<li>如果发生堆栈切换，则指定要在堆栈之间复制的可选参数的数量。</li>
<li>它定义了要推送到目标堆栈上的值的大小：16 位门强制 16 位推送，32 位门强制 32 位推送。</li>
<li>它指定调用门描述符是否有效。</li>
</ol>
<h3 id="调用门-无参"><a href="#调用门-无参" class="headerlink" title="调用门(无参)"></a>调用门(无参)</h3><p>调用门最大的好处就是提权，但提权的方式不仅仅是调用门</p>
<h4 id="门描述符的结构"><a href="#门描述符的结构" class="headerlink" title="门描述符的结构"></a>门描述符的结构</h4><p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/196406-20191230101816343-1359964647.png" alt="196406-20191230101816343-1359964647"></p>
<p>门描述符是系统段描述符的一类，所以S字段必须是0，type域为1100表示调用门。</p>
<p><strong>调用门中存储了另一个代码段段的选择子</strong>指的就是上图<code>段选择符</code>字段</p>
<p><strong>【重点】调用门真正要调用的地址：</strong><code>段选择符</code>中存的段选择子指向的那个段描述符中的base  +  上图中的两段<code>段中偏移值</code>拼接而成的值</p>
<p>不同门的TYPE：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/196406-20191230101855524-2036155359.png" alt="196406-20191230101855524-2036155359"></p>
<h4 id="调用门指令流程"><a href="#调用门指令流程" class="headerlink" title="调用门指令流程"></a>调用门指令流程</h4><p>为了访问调用门，在 CALL 或 JMP 指令中提供了一个指向该门的远指针作为目标操作数。来自该指针的段选择器标识了调用门（JMP还未亲自实验过）；指针的偏移量(下面的EIP)是必需的，但不被处理器使用或检查。（偏移量可以设置为任何值。）</p>
<p>指令格式：JMP&#x2F;CALL CS:EIP(EIP是废弃的)</p>
<p>执行步骤：</p>
<ol>
<li>根据CS的值查GDT表，找到对应的段描述符，这个描述符是一个调用门。</li>
<li>在调用门描述符中存储另一个代码段段的选择子</li>
<li>选择子指向的段   段.Base+偏移地址  就是真正要执行的地址。</li>
</ol>
<h5 id="【重点】调用门权限相关"><a href="#【重点】调用门权限相关" class="headerlink" title="【重点】调用门权限相关"></a>【重点】调用门权限相关</h5><p><strong>调用门的执行流程涉及到的权限</strong></p>
<ul>
<li>CPL（当前特权级别）。</li>
<li>调用门的选择器的 RPL（请求者的特权级别）。</li>
<li>调用门描述符的 DPL（描述符特权级别）。</li>
<li>目标代码段的段描述符的 DPL。</li>
</ul>
<p><strong>权限检查规则在 CALL 和 JMP 指令之间有所不同</strong>，如下表所示。</p>
<table>
<thead>
<tr>
<th><strong>指令</strong></th>
<th><strong>特权检查规则</strong></th>
</tr>
</thead>
<tbody><tr>
<td>CALL</td>
<td>CPL ≤ 调用门 DPL；RPL ≤ 调用门 DPL目标一致代码段 DPL ≤ CPL 目标非一致代码段 DPL ≤ CPL</td>
</tr>
<tr>
<td>JMP</td>
<td>CPL ≤ 调用门 DPL；RPL ≤ 调用门 DPL目标一致代码段 DPL ≤ CPL 目标非一致代码段 DPL &#x3D; CPL</td>
</tr>
</tbody></table>
<p>上图说明，<strong>只有 CALL 指令可以使用调用门将程序控制转移到更高特权（数字特权级别更低）的非一致性代码段</strong></p>
<ul>
<li>如果调用更高特权（数字特权级别更低）的非一致目标代码段，则 CPL 将降低到目标代码段的 DPL 并发生堆栈切换。</li>
<li>如果调用或跳转到更高特权的一致目标代码段，则 CPL 不会更改，也不会发生堆栈切换。</li>
</ul>
<h4 id="实验-1"><a href="#实验-1" class="headerlink" title="实验"></a>实验</h4><p><strong>windows内并没有使用调用门</strong>。</p>
<p>所以自己构造一个调用门（无参，提权）</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210804145505767.png" alt="image-20210804145505767"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//x部分表示还不确定的部分。</span></span><br><span class="line">高<span class="number">32</span>位：xxxx xxxx xxxx xxxx <span class="number">1</span>(P) <span class="number">11</span>(DPL) <span class="number">0</span> <span class="number">1100</span> <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line"><span class="comment">//p为1表示该段描述符有效，DPL为11表示三环，否则三环测试连敲门的权限都没有了。</span></span><br><span class="line">高<span class="number">32</span>位<span class="number">16</span>进制：XXXXEC00</span><br><span class="line">    </span><br><span class="line">低<span class="number">32</span>位：(xxxx xxxx xxxx xxxx) (xxxx xxxx xxxx xxxx)</span><br><span class="line"><span class="comment">//段选择符指向的段描述符如果是比当前CPL小的DPL的则表示要提权，否则表示无需提权。</span></span><br><span class="line">低<span class="number">32</span>位<span class="number">16</span>进制：XXXXXXXX</span><br></pre></td></tr></table></figure>

<p>查看段描述符</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210804163643397.png" alt="image-20210804163643397"></p>
<p>尝试用调用门调用上图黄标的段描述符的零环权限来<strong>提权</strong>。</p>
<p>所以构造的调用门低32位16进制为：0008XXXX(index为1，指向的正是上图黄标段描述符)</p>
<p>虚拟机上的xp系统上执行如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __declspec(naked) <span class="built_in">GetRegister</span>()</span><br><span class="line">&#123;</span><br><span class="line">	_asm</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> <span class="number">3</span><span class="comment">//断点，由于是通过调用门提权为零环，该代码段和内核同权限，所以会断到windbg中，而不是断在IDE。</span></span><br><span class="line">		retf</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> buff[<span class="number">6</span>];<span class="comment">//下断点！！！！！！！！！！！！！！！！！！！！！</span></span><br><span class="line">	*(DWORD*)&amp;buff[<span class="number">0</span>]=<span class="number">0x12345678</span>;<span class="comment">//随便输入</span></span><br><span class="line">	*(WORD*)&amp;buff[<span class="number">4</span>]=<span class="number">0x48</span>;<span class="comment">//段选择子，0x48对应的段描述符为空，所以用此位置装手动添加的调用门段描述符</span></span><br><span class="line">	_asm</span><br><span class="line">	&#123;</span><br><span class="line">		call fword ptr[buff]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码的<code>下断点！！！！！！！！！！！！！！！！！！！！！</code>处下断点。然后执行代码断到此处断点，进入反汇编找到GetRegister裸函数的函数地址。</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210804170022297.png" alt="image-20210804170022297"></p>
<p>上图黄标可知跳转目标地址为00401010</p>
<p>所以构造的调用门段描述符为0040EC00&#96;00081010</p>
<p>windbg下断点，修改gdt中0x48段选择子对应的位置内容为0040EC00&#96;00081010</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210804170558502.png" alt="image-20210804170558502"></p>
<p>执行call fword ptr[buff]代码前的寄存器情况：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210804170729597.png" alt="image-20210804170729597"></p>
<p>执行call fword ptr[buff]代码后，成功跳转了GetRegister裸函数代码中的int 3，所以windbg断了下来。</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210804170914485.png" alt="image-20210804170914485"></p>
<p>在00401010地址处因为int 3断了下来。</p>
<p><code>发现寄存器窗口为空，查明是有bug</code>，<a target="_blank" rel="noopener" href="https://blog.csdn.net/forchoosen/article/details/107074378">解决方案</a>（参考命令：!WingDbg.regfix）</p>
<p>此时windbg断下，查看windbg的寄存器显示（与执行call fword ptr[buff]前的寄存器比较）：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210804181052839.png" alt="image-20210804181052839"></p>
<p>对应颜色画笔标记为修改了的部分，其中ESP从0012FF28修改为B2B69DD0，直接从低2G空间跳转到高2G内核空间。CS变为8是因为我们在调用门描述符中设置为跳转到08段选择子对应的段描述符。</p>
<p>有部分其他寄存器也被改了，原因是系统底层代码写死了的部分修改，另外还有int 3的干扰。</p>
<p>windbg此时查看B2B69DD0处堆栈</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210804181623445.png" alt="image-20210804181623445"><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210804181720817.png" alt="image-20210804181720817"></p>
<p>到此已验证完毕！</p>
<p>将代码修改为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line">BYTE GDT[<span class="number">6</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">DWORD dwH2GValue;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __declspec(naked) <span class="built_in">GetRegister</span>()</span><br><span class="line">&#123;</span><br><span class="line">	_asm</span><br><span class="line">	&#123;</span><br><span class="line">         <span class="comment">//此代码段的代码有内核权限,可以直接访问高2G内存空间。</span></span><br><span class="line">		pushad</span><br><span class="line">         pushfd</span><br><span class="line">            </span><br><span class="line">         mov eax,<span class="number">0x8003f00c</span><span class="comment">//读取高2G内存</span></span><br><span class="line">         mov ebx,[eax]</span><br><span class="line">         mov dwH2GValue,ebx</span><br><span class="line">         sgdt GDT;<span class="comment">//sdgt指令的含义为读取gdtr寄存器(读取出6个字节的数据,两个字节的limit和4个字节的GDT起始地址)(该指令在三环也能使用)</span></span><br><span class="line">         </span><br><span class="line">         popfd</span><br><span class="line">         popad</span><br><span class="line">		retf<span class="comment">//注意长返回</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> buff[<span class="number">6</span>];<span class="comment">//下断点！！！！！！！！！！！！！！！！！！！！！</span></span><br><span class="line">	*(DWORD*)&amp;buff[<span class="number">0</span>]=<span class="number">0x12345678</span>;<span class="comment">//随便输入</span></span><br><span class="line">	*(WORD*)&amp;buff[<span class="number">4</span>]=<span class="number">0x48</span>;<span class="comment">//段选择子，0x48对应的段描述符为空，所以用此位置装手动添加的调用门段描述符</span></span><br><span class="line">	_asm</span><br><span class="line">	&#123;</span><br><span class="line">		call fword ptr[buff]</span><br><span class="line">	&#125;</span><br><span class="line">    DWORD GDT_BASE=*(PDWORD)(&amp;GDT[<span class="number">2</span>]);<span class="comment">//GDT表的地址</span></span><br><span class="line">    WORD GDT_LIMIT=*(PDWORD)(&amp;GDT[<span class="number">0</span>]);<span class="comment">//GDT表有多长</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x %x %x\n&quot;</span>,dwH2GValue,GDT_BASE,GDT_LIMIT);</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于代码修改了，所以GetRegister函数的首地址也修改了，因此要修改调用门段描述符的段中偏移值。</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210804183542660.png" alt="image-20210804183542660"></p>
<p>构造的调用门段描述符为0040EC00&#96;00081020</p>
<p>修改：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210804183704599.png" alt="image-20210804183704599"></p>
<p>执行代码，不能用单步执行的方式执行，而是直接不断点按F5</p>
<p>结果如图：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210804201255485.png" alt="image-20210804201255485"></p>
<p>实验成功，提权成功！</p>
<h3 id="调用门-有参"><a href="#调用门-有参" class="headerlink" title="调用门(有参)"></a>调用门(有参)</h3><p>调用门有权限切换时堆栈变化：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210807195216123.png" alt="image-20210807195216123"></p>
<p>R3堆栈的参数1,2,3需要手动push，如果没有手动push，则R3堆栈不存在参数1,2,3。R0堆栈的参数1,2,3取决于调用门描述符中的参数个数，没有手动push的话，R0堆栈的参数1,2,3均为0。</p>
<h4 id="实验-2"><a href="#实验-2" class="headerlink" title="实验"></a>实验</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DWORD x;<span class="comment">//用来存传入的参数1</span></span><br><span class="line">DWORD y;<span class="comment">//参数2</span></span><br><span class="line">DWORD z;<span class="comment">//参数3</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __declspec(naked) <span class="built_in">CateProc</span>()</span><br><span class="line">&#123;</span><br><span class="line">	_asm</span><br><span class="line">    &#123;</span><br><span class="line">        pushad</span><br><span class="line">        pushfd</span><br><span class="line">        mov eax,[esp+<span class="number">0x24</span>+<span class="number">0x8</span>+<span class="number">0x8</span>]<span class="comment">//读参数赋值给x,y,z</span></span><br><span class="line">        mov dword ptr ds:[x],eax</span><br><span class="line">        mov eax,[esp+<span class="number">0x24</span>+<span class="number">0x8</span>+<span class="number">0x4</span>]</span><br><span class="line">        mov dword ptr ds:[y],eax</span><br><span class="line">        mov eax,[esp+<span class="number">0x24</span>+<span class="number">0x8</span>]</span><br><span class="line">        mov dword ptr ds:[z],eax</span><br><span class="line">        popfd</span><br><span class="line">        popad</span><br><span class="line">     	retf <span class="number">0xC</span> <span class="comment">//注意堆栈平衡，写错直接蓝屏。三个参数，所以为参数平栈为0xC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> buff[<span class="number">6</span>];</span><br><span class="line">    *(DWORD*)&amp;buff[<span class="number">0</span>]=<span class="number">0x12345678</span>;<span class="comment">//断点！！！！！！！！！！！！！！！</span></span><br><span class="line">    *(WORD*)&amp;buff[<span class="number">4</span>]=<span class="number">0x48</span>;</span><br><span class="line">    _asm</span><br><span class="line">    &#123;</span><br><span class="line">         push <span class="number">1</span></span><br><span class="line">         push <span class="number">2</span></span><br><span class="line">         push <span class="number">3</span></span><br><span class="line">		call fword ptr[buff]</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%x,%x,%x\n&quot;</span>,x,y,z);</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>断点！！！！！！！！！！！！！！！</code>处断点，查看断点处地址</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210804230009598.png" alt="image-20210804230009598"></p>
<p>构造调用门段描述符为0040EC03&#96;00081020(3表示3个参数)</p>
<p>修改gdt第10个段描述符：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210804230204980.png" alt="image-20210804230204980"></p>
<p>修改后F5执行</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210804230311195.png" alt="image-20210804230311195"></p>
<p>CateProc函数头加个int 3，来查看一下堆栈情况。</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210804230456028.png" alt="image-20210804230456028"></p>
<p>地址未变，段描述符不需要改，直接执行，windbg执行到int 3断下</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210804230842907.png" alt="image-20210804230842907"></p>
<p>此时windbg中查看堆栈情况：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210804231548046.png" alt="image-20210804231548046"></p>
<p>int 3断下时候的堆栈结构</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210804232559040.png" alt="image-20210804232559040"></p>
<p>pushad和pushfd后的堆栈结构（参数此时的相对ESP位置结构）：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210804232907329.png" alt="image-20210804232907329"></p>
<h4 id="【总结】-2"><a href="#【总结】-2" class="headerlink" title="【总结】"></a>【总结】</h4><ol>
<li>当通过门，<strong>权限不变的时候，只会PUSH两个值：CS和返回地址</strong>。新的CS的值由调用门决定。</li>
<li>当通过门，权限改变的时候，会PUSH四个值，<code>SS,ESP,CS,返回地址</code>，新的CS的值由调用门决定，<strong>新的SS和ESP由TSS提供</strong>。</li>
<li>通过门调用时，要执行哪行代码由调用门决定，但使用RETF返回时，由堆栈中压入的值决定，这就是说，<strong>进门时只能按照指定路线走，出门时可以翻墙</strong>（只要改变堆栈里面的值就可以想去哪去哪）</li>
<li>可不可以再建个门出去呢？当然可以了，前门进，后门出</li>
</ol>
<h2 id="中断门"><a href="#中断门" class="headerlink" title="中断门"></a>中断门</h2><p>Windows没有使用调用门，但是使用了中断门。</p>
<p>windows系统使用了中断门的两种情况：</p>
<ol>
<li>系统调用（老cpu使用中断门，新cpu已经不使用中断门了，而是使用快速调用）</li>
<li>调试（软件断点int 3就是用来执行中断门的）</li>
</ol>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210806163434767.png" alt="image-20210806163434767"></p>
<ul>
<li>键盘鼠标显示器等外部设备都是可屏蔽中断</li>
<li>电源等是不可屏蔽中断，无法操作。</li>
<li>现在的中断大多都是用的APIC实现，APIC编程强一些。</li>
</ul>
<p>执行调用门的指令：CALL CS:EIP</p>
<p>但当CPU 执行如下指令：INT N（int 0表示0号中断；int 1表示1号中断…）</p>
<p>查询的却是另一张表，这张表叫IDT</p>
<h3 id="中断指令"><a href="#中断指令" class="headerlink" title="中断指令"></a>中断指令</h3><p>$$<br>INT\ N<br>$$</p>
<p>其中，N是索引，X*8+IDT的基址 就是具体的中断门描述符</p>
<p>保护模式下的中断和异常表解释</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/2018121811050612.png" alt="2018121811050612"></p>
<p>终止就是蓝屏</p>
<h3 id="中断门的堆栈和返回"><a href="#中断门的堆栈和返回" class="headerlink" title="中断门的堆栈和返回"></a>中断门的堆栈和返回</h3><ol>
<li>在没有权限切换时，会向堆栈PUSH3个值，分别是：<strong>CS EFLAG EIP(返回地址)</strong></li>
<li>在有权限切换时，会向堆栈PUSH5个值，分别是：<strong>SS ESP EFLAGS CS EIP(返回地址)</strong></li>
</ol>
<p>在中断门中，不能通过RETF返回(其实也可以)，而应该通过<strong>IRET&#x2F;IRETD</strong>指令返回。IRET是16位，而IRETD是32位</p>
<p>裸函数的话必须写IRETD，部分IDE会自动根据D&#x2F;B位在IRET&#x2F;IRETD中变换。</p>
<h3 id="IDT"><a href="#IDT" class="headerlink" title="IDT"></a>IDT</h3><p>IDT即<strong>中断描述符表</strong>，<em>结构同GDT一样</em>，IDT也是由一系列描述符组成的，每个描述符占8个字节。但要注意的是，<strong>IDT表中的第一个元素不是NULL</strong>。</p>
<p>IDT表中存的中断描述符按照中断编号从0号开始排序下去。</p>
<p>在Windbg中查看IDT表的基址和长度：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210806113112935.png" alt="image-20210806113112935"></p>
<h4 id="IDT表的构成"><a href="#IDT表的构成" class="headerlink" title="IDT表的构成"></a>IDT表的构成</h4><p>IDT表可以包含3种门描述符</p>
<ol>
<li>任务门描述符</li>
<li>中断门描述符</li>
<li>陷阱门描述符</li>
</ol>
<h3 id="中断门描述符"><a href="#中断门描述符" class="headerlink" title="中断门描述符"></a>中断门描述符</h3><p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210607203904224.png" alt="image-20210607203904224"></p>
<p>高4字节的0~4位固定为0。</p>
<p>64进制中断门描述符表示：XXXXEE00&#96;XXXXXXXX</p>
<h4 id="中断门提权实验"><a href="#中断门提权实验" class="headerlink" title="中断门提权实验"></a>中断门提权实验</h4><p>参考流程图</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210806171727490.png" alt="image-20210806171727490"></p>
<p><strong>提权与否取决于：中断门描述符的段选择子指向的段描述符的DPL</strong>。</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/20181213133543199.png" alt="20181213133543199"></p>
<p>实验：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __declspec(naked) <span class="built_in">test</span>()</span><br><span class="line">&#123;</span><br><span class="line">	_asm</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="number">3</span></span><br><span class="line">        iretd<span class="comment">//中断门要用这个返回。如果不是裸函数的话写iret也可以，因为IDE会根据D/B位调成iretd</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _asm</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//32是后续知道idt的空位后回来补上的。IDT表中的第33个中断描述符(编号从0开始)</span></span><br><span class="line">        <span class="type">int</span> <span class="number">32</span>;<span class="comment">//断点！！！！！！！！！！！！！！</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>断点！！！！！！！！！！！！！！</code>处断下反汇编查看test的函数地址。</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210806194755824.png" alt="image-20210806194755824"></p>
<p>在IDT中找空的位置构造中断门描述符（空位如下图）</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210806195008729.png" alt="image-20210806195008729"></p>
<p>构造的中断门描述符：0040EE00&#96;00081020</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210806195231834.png" alt="image-20210806195231834"></p>
<p>中断门的段选择子0x0008指向的是DPL为0的内核代码段。</p>
<p>int32之前的堆栈情况：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210806195925841.png" alt="image-20210806195925841"></p>
<p>断到int3上：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210806200039623.png" alt="image-20210806200039623"></p>
<p>查看寄存器变化：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210806200514018.png" alt="image-20210806200514018"></p>
<p>有部分其他寄存器也被改了，原因是系统底层代码写死了的部分修改，另外还有int 3的干扰。</p>
<p>查看堆栈：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210806201413231.png" alt="image-20210806201413231"><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210806202256635.png" alt="image-20210806202256635"></p>
<p>调用中断门的R3堆栈没有变化。</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210811145502207.png" alt="image-20210811145502207"></p>
<h4 id="调用门与中断门的区别"><a href="#调用门与中断门的区别" class="headerlink" title="调用门与中断门的区别"></a>调用门与中断门的区别</h4><ol>
<li>调用门通过CALL FAR指令执行，但中断门通过INT指令</li>
<li>调用门查询GDT表，中断门查询IDT表</li>
<li>CALL CS:EIP中的CS是段选择子，由3部分组成。但INT N指令中的N只是索引，中断门不检查RPL，只检查CPL</li>
<li>调用门可以有参数，但中断门没有参数</li>
</ol>
<h4 id="【重点理解】各种返回加深理解"><a href="#【重点理解】各种返回加深理解" class="headerlink" title="【重点理解】各种返回加深理解"></a>【重点理解】各种返回加深理解</h4><p>iret可以理解为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pop eip</span><br><span class="line">pop cs</span><br><span class="line">popfd</span><br></pre></td></tr></table></figure>

<p>各种返回</p>
<ul>
<li>RET 及其同义词 RETN，从堆栈中弹出 IP 或 EIP(返回地址) 并将控制权转移到新地址。可选的，如果提供了数字二的操作数，它们会在弹出返回地址后将堆栈指针再增加 imm16(16位即两个字节) 字节。</li>
<li>RETF 执行远返回：在弹出 IP&#x2F;EIP(返回地址)后，它会弹出 CS，然后通过可选参数（如果存在）递增堆栈指针，如果返回到另一个特权级别，IRET指令还会在恢复程序执行之前从堆栈中弹出SP(或ESP)和SS，最后将参数计数（以从 RETF  指令获得的字节数）添加到当前 ESP&#x2F;SP 寄存器值。</li>
<li>IRETW 将 IP、CS 和flags弹出为 每个2 个字节，总共从堆栈中取出 6 个字节，如果返回到另一个特权级别，IRET指令还会在恢复程序执行之前从堆栈中弹出SP和SS。</li>
<li>IRETD 将 EIP 弹出为 4 个字节(返回地址)。再弹出 4 个字节，其中前两个被丢弃，后两个进入 CS，并将eflags也弹出为 4 个字节，从堆栈中取出 12 个字节，如果返回到另一个特权级别，IRET指令还会在恢复程序执行之前从堆栈中弹出ESP和SS。</li>
<li><strong>IRET 是 IRETW 或 IRETD 的简写，具体取决于当时的默认 BITS 设置。</strong></li>
</ul>
<h5 id="【实验】在调用门中实现使用IRETD返回，在中断门中实现用RETF返回"><a href="#【实验】在调用门中实现使用IRETD返回，在中断门中实现用RETF返回" class="headerlink" title="【实验】在调用门中实现使用IRETD返回，在中断门中实现用RETF返回"></a><strong>【实验】</strong>在调用门中实现使用IRETD返回，在中断门中实现用RETF返回</h5><h6 id="中断门用RETF返回"><a href="#中断门用RETF返回" class="headerlink" title="中断门用RETF返回"></a>中断门用RETF返回</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&quot;stdafx.h&quot;</span><br><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line"></span><br><span class="line">void __declspec(naked) test()</span><br><span class="line">&#123;</span><br><span class="line">	_asm</span><br><span class="line">    &#123;</span><br><span class="line">        RETF 0x4//中断门用RETF返回（反其道行之）</span><br><span class="line">		</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;%x&quot;,&amp;test);</span><br><span class="line">	getchar();</span><br><span class="line">    _asm</span><br><span class="line">    &#123;</span><br><span class="line">        int 32;//32编号对应位置的中断门段描述符为0040ee00`0008100f</span><br><span class="line">		sub esp,4//因为RETF在返回后还会再add ESP，4（根据RETF 0x4）</span><br><span class="line">    &#125;</span><br><span class="line">    getchar();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="调用门用iretd-返回"><a href="#调用门用iretd-返回" class="headerlink" title="调用门用iretd 返回"></a>调用门用iretd 返回</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> __declspec(naked) <span class="built_in">test</span>()</span><br><span class="line">&#123;</span><br><span class="line">	_asm</span><br><span class="line">    &#123;</span><br><span class="line">        iretd<span class="comment">//调用门用iretd返回（反其道行之）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> buff[<span class="number">6</span>]=&#123;<span class="number">0x78</span>,<span class="number">0x56</span>,<span class="number">0x34</span>,<span class="number">0x12</span>,<span class="number">0x48</span>,<span class="number">0</span>&#125;;<span class="comment">//指向的调用门描述符为0040EC01`0008100F</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%x&quot;</span>,&amp;test);</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">    _asm</span><br><span class="line">    &#123;</span><br><span class="line">        call fword ptr[buff];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="陷阱门"><a href="#陷阱门" class="headerlink" title="陷阱门"></a>陷阱门</h2><p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210808163723779.png" alt="image-20210808163723779"></p>
<p>陷阱门段描述符：XXXXEF00&#96;XXXXXXXX</p>
<p><strong>陷阱门与中断门几乎一样</strong>，陷阱门与中断门唯一的区别：</p>
<p>中断门执行时，会将<strong>IF</strong>位清零，但陷阱门不会。</p>
<p>IF位：eflags下标为9的位置。</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/1342712354_1402.jpg" alt="1342712354_1402"></p>
<p><strong>IF的含义：</strong></p>
<p>IF标志用于控制处理器对可屏蔽中断请求的响应。置1以响应可屏蔽中断，反之则禁止可屏蔽中断。</p>
<ul>
<li>IF&#x3D;0	CPU不再接受可屏蔽中断</li>
<li>IF&#x3D;1	CPU接受可屏蔽中断</li>
</ul>
<p><code>p.s.不可屏蔽中断不受IF位影响，比如说断电，就是电源通过电源管理器向CPU发送一个请求，这就是一个不可屏蔽中断。(CPU有电容，即使是断电了也能跑一会儿，执行一些清理工作)</code></p>
<p><strong>通过中断门与陷阱门打印EFLAG寄存器的值</strong></p>
<ul>
<li>执行前：216</li>
<li>执行中<ol>
<li>陷阱门：216</li>
<li>中断门：16</li>
</ol>
</li>
</ul>
<h2 id="任务段TSS-难点非重点"><a href="#任务段TSS-难点非重点" class="headerlink" title="任务段TSS(难点非重点)"></a>任务段TSS(难点非重点)</h2><p>在调用门，中断门与陷阱门中，一旦出现权限切换，那么就会有堆栈的切换。而且，由于CS的CPL发生改变，也导致了SS也必须要切换。(CS和SS的权限级别永远都是一致的)</p>
<p>切换时，会有新的ESP和SS（CS是由中断门或者调用门指定）这2个值从哪里来的呢？</p>
<p>答案：<strong>TSS</strong>（Task-state segment），任务状态段。</p>
<h3 id="TSS和TR寄存器"><a href="#TSS和TR寄存器" class="headerlink" title="TSS和TR寄存器"></a>TSS和TR寄存器</h3><p>一块<strong>大于等于104字节</strong>的内存结构。（强调：不在CPU中，就是内存中）</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/196406-20200102102107308-1624147754.png" alt="196406-20200102102107308-1624147754"></p>
<p>I&#x2F;O权限位图：I&#x2F;O Map Base Address（没什么用，和硬件是相关的）</p>
<p>CR3：页目录基地址寄存器CR3（PDBR）</p>
<p> 指向前一个任务段（TSS）的链接（<strong>如果不为空的话，存的是前一个TSS段的段选择子</strong>）：Previous Task Link</p>
<p>LDT Segment Selector：LDT段选择子,会加载到LDTR寄存器中。</p>
<p>tss中的ss0,ss1,ss2修改是没用的，即使修改了，也会变回去，因为是系统填写的。</p>
<p>一个TSS对应一个LDT表。LDTR描述的是LDT表的地址和大小。</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/48588_1282618334lclL.jpg" alt="48588_1282618334lclL"></p>
<p>LDT和GDT从本质上说是相同的，只是LDT嵌套在GDT之中。LDTR记录局部描述符表的起始位置，<strong>与GDTR不同LDTR的内容是一个段选择子</strong>。由于LDT本身同样是一段内存，也是一个段，所以它也有个描述符描述它，这个描述符就存储在GDT中，对应这个描述符也会有一个选择子，LDTR装载的就是这样一个选择子。LDTR可以在程序中随时改变，通过使用lldt指令。如上图，如果装载的是Selector 2则LDTR指向的是表LDT2。</p>
<p>LDT描述符</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210813135407001.png" alt="image-20210813135407001"></p>
<p>windows 32位以后实际上没有使用LDT。因为用不着这么多段了</p>
<p>更多关于LDT的内容可以<a target="_blank" rel="noopener" href="http://www.techbulo.com/708.html">参考此处</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">nt!_KTSS</span><br><span class="line">+<span class="number">0x000</span> Backlink : Uint2B</span><br><span class="line">+<span class="number">0x002</span> Reserved0 : Uint2B</span><br><span class="line">+<span class="number">0x004</span> Esp0 : Uint4B</span><br><span class="line">+<span class="number">0x008</span> Ss0 : Uint2B</span><br><span class="line">+<span class="number">0x00a</span> Reserved1 : Uint2B</span><br><span class="line">+<span class="number">0x00c</span> NotUsed1 : [<span class="number">4</span>] Uint4B</span><br><span class="line">+<span class="number">0x01c</span> CR3 : Uint4B<span class="comment">//重点寄存器CR3，后续会讲</span></span><br><span class="line">+<span class="number">0x020</span> Eip : Uint4B</span><br><span class="line">+<span class="number">0x024</span> EFlags : Uint4B</span><br><span class="line">+<span class="number">0x028</span> Eax : Uint4B</span><br><span class="line">+<span class="number">0x02c</span> Ecx : Uint4B</span><br><span class="line">+<span class="number">0x030</span> Edx : Uint4B</span><br><span class="line">+<span class="number">0x034</span> Ebx : Uint4B</span><br><span class="line">+<span class="number">0x038</span> Esp : Uint4B</span><br><span class="line">+<span class="number">0x03c</span> Ebp : Uint4B</span><br><span class="line">+<span class="number">0x040</span> Esi : Uint4B</span><br><span class="line">+<span class="number">0x044</span> Edi : Uint4B</span><br><span class="line">+<span class="number">0x048</span> Es : Uint2B</span><br><span class="line">+<span class="number">0x04a</span> Reserved2 : Uint2B</span><br><span class="line">+<span class="number">0x04c</span> Cs : Uint2B</span><br><span class="line">+<span class="number">0x04e</span> Reserved3 : Uint2B</span><br><span class="line">+<span class="number">0x050</span> Ss : Uint2B</span><br><span class="line">+<span class="number">0x052</span> Reserved4 : Uint2B</span><br><span class="line">+<span class="number">0x054</span> Ds : Uint2B</span><br><span class="line">+<span class="number">0x056</span> Reserved5 : Uint2B</span><br><span class="line">+<span class="number">0x058</span> Fs : Uint2B</span><br><span class="line">+<span class="number">0x05a</span> Reserved6 : Uint2B</span><br><span class="line">+<span class="number">0x05c</span> Gs : Uint2B</span><br><span class="line">+<span class="number">0x05e</span> Reserved7 : Uint2B</span><br><span class="line">+<span class="number">0x060</span> LDT : Uint2B</span><br><span class="line">+<span class="number">0x062</span> Reserved8 : Uint2B</span><br><span class="line">+<span class="number">0x064</span> Flags : Uint2B</span><br><span class="line">+<span class="number">0x066</span> IoMapBase : Uint2B</span><br><span class="line">+<span class="number">0x068</span> IoMaps : [<span class="number">1</span>] _KiIoAccessMap</span><br><span class="line">+<span class="number">0x208c</span> IntDirectionMap : [<span class="number">32</span>] UChar</span><br></pre></td></tr></table></figure>

<p> <em>TSS的地址就是TSS段描述符描述的基地址，因此我们通过 dg tr 查看其Base为 80042000。</em>对于查看TSS段，有一个单独的指令。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dg tr</span><br><span class="line">dt _KTSS <span class="number">80042000</span><span class="comment">//Base</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210813144727834.png" alt="image-20210813144727834"><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210813144750275.png" alt="image-20210813144750275"></p>
<h4 id="TSS的作用"><a href="#TSS的作用" class="headerlink" title="TSS的作用"></a>TSS的作用</h4><p>CPU层面的<strong>任务</strong>就是系统层面上的<strong>线程</strong></p>
<p><strong>Intel CPU设计思想的初衷</strong>：TSS就是实现任务切换（操作系统中也就是线程切换，CPU中没有线程的概念）</p>
<p><strong>操作系统的设计思想</strong>：TSS的任务切换在操作系统中其实就是同时换掉”一堆“寄存器，与线程切换无关。windows和linux系统实际上只使用了ss和esp.</p>
<p>本质：<strong>不要把TSS与“线程切换“联系到一起</strong>，TSS的意义仅在于可以同时换掉”一堆“寄存器</p>
<h4 id="CPU是如何找到TSS的"><a href="#CPU是如何找到TSS的" class="headerlink" title="CPU是如何找到TSS的"></a>CPU是如何找到TSS的</h4><p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210808175145728.png" alt="image-20210808175145728"></p>
<blockquote>
<p>任务寄存器TR，16位寄存器。  其内保存的是任务状态段<strong>TSS的16位段选择子</strong>。每项任务都配有一个任务状态段TSS，用来描述该任务的运行状态。就用16位的选择子来检索任务状态段。总是将当前任务的TSS的选择符放在TR中，而TSS的描述符放在TSS描述符高速缓冲寄存器中（<strong>就是段描述符除了16位的端选择子部分的其他80位</strong>）(针对这句话一下说明)。</p>
<p>在保护方式下，选择器寄存器的D1 D0是特权标志，D2为描述符表类型标志，高13位是选择码，指出本段的描述符在由D2指出的描述符表中的逻辑排序。当一个段第一次被访问时，首先根据指令给出选择器的D2位及高13位，到内存中相应的描述符表内取出相应的描述符(64位)，送入对应的描述符高速缓冲寄存器(64位)，再从描述符中取出段基址进行逻辑到线性地址的变换。以后再访问该段时，直接从描述符寄存器(64位)中取地址信息，免去从内存中选取描述符的过程，实现加速。</p>
<p>在系统中 GDT，IDT 只有一个，所以GDTR,IDTR中存放的是该表入口地址；而任务不只一个，所以LDTR，TR存放的是当前任务的选择符。</p>
</blockquote>
<h4 id="TSS段描述符"><a href="#TSS段描述符" class="headerlink" title="TSS段描述符"></a>TSS段描述符</h4><p>TSS段描述符是系统段描述符的一种，在GDT中。</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/123.png" alt="123"></p>
<p>TSS的limit以字节为单位的，所以上图高4字节的23位的G代表0，含义是limit以字节为单位。</p>
<p><strong>TYPE为1011和1001都表示TSS段描述符</strong>。</p>
<ul>
<li>1001(0x9)表示当前的TSS段描述符没有加载到TR寄存器中。</li>
<li>1011(0xB)表示已经加载了（忙碌状态）</li>
</ul>
<p><strong>加载前TYPE是0xB，加载后0x9</strong></p>
<ul>
<li>构造TSS段描述符(零环已使用)：<strong>XX008BXX&#96;XXXX0068</strong></li>
<li>构造TSS段描述符(零环未使用)：<strong>XX0089XX&#96;XXXX0068</strong></li>
<li>构造TSS段描述符(三环已使用)：<strong>XX00EBXX&#96;XXXX0068</strong></li>
<li>构造TSS段描述符(三环未使用)：<strong>XX00E9XX&#96;XXXX0068</strong>（下面实验使用这个才能成功）</li>
</ul>
<p>之前的段描述符G位都是填1，TSS段描述符填的是0，表示按字节为单位</p>
<p>TSS段描述符</p>
<h4 id="TR寄存器的读写"><a href="#TR寄存器的读写" class="headerlink" title="TR寄存器的读写"></a>TR寄存器的读写</h4><p><strong>1）将TSS段描述符加载到TR寄存器</strong></p>
<p>指令：LTR</p>
<ul>
<li>用LTR指令去装载的话，仅仅是改变TR寄存器的值(92位)，并没有真正改变TSS</li>
<li>LTR指令只能在系统层使用（ltr是特权指令，CPU权限零环）</li>
<li>加载后TSS段描述符会状态位发生改变（加载完后，TYPE会从0x9变成0xB）</li>
</ul>
<p><strong>2）读TR寄存器</strong></p>
<p>指令：STR</p>
<p>如果用STR去读的话，只读了TR的0~15位，也就是选择子。</p>
<h4 id="修改TR寄存器"><a href="#修改TR寄存器" class="headerlink" title="修改TR寄存器"></a>修改TR寄存器</h4><ol>
<li><p>在Ring0，我们可以通过LTR指令去修改TR寄存器</p>
</li>
<li><p>在Ring3，我们可以<strong>通过CALL FAR或者JMP FAR指令来修改</strong>(不但改TR寄存器，还会通过TSS改所有的寄存器)</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/12313213213213.jpg" alt="12313213213213"></p>
</li>
</ol>
<ul>
<li><p>用JMP去访问一个代码段的时候，改变的是CS和EIP：</p>
<p>​		JMP 0x48:0x123456,如果0x48是代码段</p>
<p>​		执行后：CS-&gt;0x48   EIP-&gt;0x123456</p>
</li>
<li><p>用JMP去访问一个任务段的时候</p>
<p>​		如果0x48是TSS段描述符，先修改TR寄存器，<strong>再用TR.Base指向的TSS中的值修改当前的各种寄存器（TSS涉及的寄存器）</strong>。</p>
</li>
</ul>
<h4 id="CALL-FAR或者JMP-FAR一个任务段描述符的不同点（重点）"><a href="#CALL-FAR或者JMP-FAR一个任务段描述符的不同点（重点）" class="headerlink" title="CALL FAR或者JMP FAR一个任务段描述符的不同点（重点）"></a><strong>CALL FAR或者JMP FAR一个任务段描述符的不同点</strong>（重点）</h4><ol>
<li>第一个不同点在于<strong>Previous Task Link</strong><ul>
<li><strong>CALL FAR调用了TSS段之后，Previous Task Link会被填入前一个TSS段的段选择子</strong></li>
<li><strong>JMP FAR调用了TSS段之后，Previous Task Link不会被改变。</strong></li>
</ul>
</li>
<li>第二个不同点在于<strong>nt位</strong>（EFLAGS的第14位）<ul>
<li>CALL FAR调用了TSS段之后，<strong>nt位会置一</strong></li>
<li>JMP FAR调用了TSS段之后，<strong>nt位清0</strong></li>
</ul>
</li>
</ol>
<p><strong>nt位（EFLAGS的第14位）（保护模式下）的理解：</strong></p>
<ol>
<li>NT&#x3D;0时，iret为中断返回，会在<strong>堆栈中找返回值</strong>返回</li>
<li>NT&#x3D;1时，iret不是中断返回，会找<strong>TSS中的Previous Task Link</strong>返回</li>
</ol>
<p> nt位（eflags有部分位）不允许被应用程序所修改</p>
<p>注意：int也会把nt位清零（<strong>无法实验证实</strong>）。所以call的方式调用任务段跳转到代码后用int会导致蓝屏，而jmp却可以。</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/20181217172756828.png" alt="20181217172756828"></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37375427/article/details/85051515">jmp call 中断详解（对理解有一定帮助）</a></p>
<h4 id="TSS段描述符实验"><a href="#TSS段描述符实验" class="headerlink" title="TSS段描述符实验"></a>TSS段描述符实验</h4><p>不管跳几环，TSS中一定要改ss，cs，fs这三个段寄存器</p>
<p>使用CALL和JMP去访问一个任务段，并能正确返回。</p>
<h5 id="CALL实验返回"><a href="#CALL实验返回" class="headerlink" title="CALL实验返回"></a>CALL实验返回</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line">DWORD dwOK;</span><br><span class="line">DWORD dwESP;</span><br><span class="line">DWORD dwCS;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __declspec(naked) <span class="built_in">test</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//dwOK = 1;</span></span><br><span class="line">	_asm</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//int 3</span></span><br><span class="line">        mov eax,esp;</span><br><span class="line">        mov dwESP,eax;</span><br><span class="line">        mov ax,cs;</span><br><span class="line">        mov word ptr[dwCS],ax;</span><br><span class="line">        iretd</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> bu[<span class="number">0x10</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> iCr3;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input CR3:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%x&quot;</span>,&amp;iCr3);<span class="comment">//通过windbg工具!process 0 0指令获取</span></span><br><span class="line">    </span><br><span class="line">    DWORD iTss[<span class="number">0x68</span>]=&#123;<span class="comment">//用栈空间构造TSS，TSS段描述符中的Base填该数组的首地址</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//link</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//esp0   也可填((DWORD)bu)-0x10，照常运行</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//ss0</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//esp1</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//ss1</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//esp2</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//ss2</span></span><br><span class="line">        (DWORD)iCr3,<span class="comment">//cr3</span></span><br><span class="line">        (DWORD)test,<span class="comment">//eip   此处要填入跳转位置的地址</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//eflags</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//eax</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//ecx</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//edx</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//ebx</span></span><br><span class="line">        ((DWORD)bu)<span class="number">-0x10</span>,<span class="comment">//esp   -0x10是因为esp是往小地址升栈的。</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//ebp</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//esi</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//edi</span></span><br><span class="line">        <span class="number">0x00000023</span>,<span class="comment">//es</span></span><br><span class="line">        <span class="number">0x00000008</span>,<span class="comment">//cs	0x1B（cs段选择子决定是否升了权限，由于0x8选择子指向的段描述符是0环权限，所以此处是提权了的）</span></span><br><span class="line">        <span class="number">0x00000010</span>,<span class="comment">//ss	0x23</span></span><br><span class="line">        <span class="number">0x00000023</span>,<span class="comment">//ds</span></span><br><span class="line">        <span class="number">0x00000030</span>,<span class="comment">//fs	0x3B</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//gs</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//ldt(如果想使用LDT的话，可以自己构造LDT使用)</span></span><br><span class="line">        <span class="number">0x20ac0000</span> <span class="comment">//I/O Map Base Address</span></span><br><span class="line">	&#125;;</span><br><span class="line">    <span class="comment">/*__asm&#123;</span></span><br><span class="line"><span class="comment">        int 0x20</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>,iTss);</span><br><span class="line">    <span class="type">char</span> buff[<span class="number">6</span>]=&#123;<span class="number">0x78</span>,<span class="number">0x56</span>,<span class="number">0x34</span>,<span class="number">0x12</span>,<span class="number">0x48</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    _asm</span><br><span class="line">    &#123;</span><br><span class="line">        call fword ptr[buff];</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ok=%d ESP=%x CS=%x \n&quot;</span>,dwOK,dwESP,dwCS);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在windbg中断下，输入!process 0 0指令，根据程序名查看CR3：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210814132256597.png" alt="image-20210814132256597"></p>
<p>g放开内核断点，控制台输入上图黄标,得到iTss的地址，长调用之前调试器断下：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210814132349732.png" alt="image-20210814132349732"></p>
<p>windbg再次断下，构造TSS段描述符：0000E912&#96;FDCC0068</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210814132525309.png" alt="image-20210814132525309"></p>
<p>修改好后，确保iTss字符数组首地址不会变的时候，不下断点重新运行（否则会出现如下图的单步运行异常），填入新的CR3</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210814133359037.png" alt="image-20210814133359037"></p>
<p>p.s.单步运行异常是可以用windbg单步调试的状态，p指令单步走，r指令查看寄存器。</p>
<p>输入CR3时的寄存器情况</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210814133524278.png" alt="image-20210814133524278"></p>
<p>重新运行结果：（下图左边寄存器为返回后的值）</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210814134241466.png" alt="image-20210814134241466"></p>
<p>再次运行程序在test函数头加int3观察</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210814140654925.png" alt="image-20210814140654925"></p>
<p>与我们的修改完全一致，只是如果在test函数头加int3，会导致蓝屏，无法正常返回。</p>
<p><strong>后面的实验发现CALL过去的方式不能在test函数头加int3(蓝屏)是因为int会将nt位清0，导致iretd在堆栈中找返回值(实则没有，所以蓝屏)</strong></p>
<p><strong>可以在CALL实验中将test函数中的int 3用pushfd和popfd包裹起来</strong>（防止int 3修改eflags寄存器），避免蓝屏。（已实验证实可以）</p>
<p><strong>JMP过去的方式可以加int 3不蓝屏。</strong></p>
<h5 id="JMP实验返回"><a href="#JMP实验返回" class="headerlink" title="JMP实验返回"></a>JMP实验返回</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> trs[<span class="number">6</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __declspec(naked)  <span class="built_in">test</span>()</span><br><span class="line">&#123;</span><br><span class="line">        __asm</span><br><span class="line">        &#123;</span><br><span class="line">                jmp fword ptr trs;</span><br><span class="line">                <span class="comment">//iretd;</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> stack[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        DWORD cr3=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;cr3:&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%X&quot;</span>,&amp;cr3);</span><br><span class="line"></span><br><span class="line">        DWORD tss[<span class="number">0x68</span>]=&#123;</span><br><span class="line">                <span class="number">0x0</span>,</span><br><span class="line">                <span class="number">0x0</span>,</span><br><span class="line">                <span class="number">0x0</span>,</span><br><span class="line">                <span class="number">0x0</span>,</span><br><span class="line">                <span class="number">0x0</span>,</span><br><span class="line">                <span class="number">0x0</span>,</span><br><span class="line">                <span class="number">0x0</span>,</span><br><span class="line">                cr3,</span><br><span class="line">                (DWORD)test,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                ((DWORD)stack) - <span class="number">100</span>,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                <span class="number">0x23</span>,</span><br><span class="line">                <span class="number">0x08</span>,</span><br><span class="line">                <span class="number">0x10</span>,</span><br><span class="line">                <span class="number">0x23</span>,</span><br><span class="line">                <span class="number">0x30</span>,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                <span class="number">0x20ac0000</span></span><br><span class="line">        &#125;;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%X\n&quot;</span>,tss);</span><br><span class="line">        WORD rs=<span class="number">0</span>;</span><br><span class="line">        _asm</span><br><span class="line">        &#123;</span><br><span class="line">                str ax;<span class="comment">//str指令为保存当前TSS的段选择子到ax中</span></span><br><span class="line">                mov rs,ax;</span><br><span class="line">        &#125;</span><br><span class="line">        *(WORD*)&amp;trs[<span class="number">4</span>]=rs;<span class="comment">//保存跳回来的jmp的目标段选择子和目标地址</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">6</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x48</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        __asm</span><br><span class="line">        &#123;</span><br><span class="line">                jmp fword ptr buf;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;zsaddfsafdsa\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210814141149228.png" alt="image-20210814141149228"></p>
<p>构造tss段描述符：0000E912&#96;FD780068</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eq gdtr+0x48 0000E912`FD780068</span><br></pre></td></tr></table></figure>

<p>获取CR3后输入，成功执行</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210814142148937.png" alt="image-20210814142148937"></p>
<h6 id="JMP实验中test头添加int观察实验"><a href="#JMP实验中test头添加int观察实验" class="headerlink" title="JMP实验中test头添加int观察实验"></a><strong>JMP实验中test头添加int观察实验</strong></h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> trs[<span class="number">6</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __declspec(naked)  <span class="built_in">test</span>()</span><br><span class="line">&#123;</span><br><span class="line">        __asm</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="number">3</span><span class="comment">//！！！！和上个实验唯一的区别：添加int 3！！！！！</span></span><br><span class="line">            jmp fword ptr trs;</span><br><span class="line">            <span class="comment">//iretd;</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="type">char</span> stack[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        DWORD cr3=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;cr3:&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%X&quot;</span>,&amp;cr3);</span><br><span class="line">        DWORD tss[<span class="number">0x68</span>]=&#123;</span><br><span class="line">                <span class="number">0x0</span>,</span><br><span class="line">                <span class="number">0x0</span>,</span><br><span class="line">                <span class="number">0x0</span>,</span><br><span class="line">                <span class="number">0x0</span>,</span><br><span class="line">                <span class="number">0x0</span>,</span><br><span class="line">                <span class="number">0x0</span>,</span><br><span class="line">                <span class="number">0x0</span>,</span><br><span class="line">                cr3,</span><br><span class="line">                (DWORD)test,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                ((DWORD)stack) - <span class="number">100</span>,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                <span class="number">0x23</span>,</span><br><span class="line">                <span class="number">0x08</span>,</span><br><span class="line">                <span class="number">0x10</span>,</span><br><span class="line">                <span class="number">0x23</span>,</span><br><span class="line">                <span class="number">0x30</span>,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                <span class="number">0x20ac0000</span></span><br><span class="line">        &#125;;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%X\n&quot;</span>,tss);</span><br><span class="line">        WORD rs=<span class="number">0</span>;</span><br><span class="line">        _asm</span><br><span class="line">        &#123;</span><br><span class="line">                str ax;<span class="comment">//str指令为保存当前TSS的段选择子到ax中</span></span><br><span class="line">                mov rs,ax;</span><br><span class="line">        &#125;</span><br><span class="line">        *(WORD*)&amp;trs[<span class="number">4</span>]=rs;<span class="comment">//保存跳回来的jmp的目标段选择子和目标地址</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">6</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x48</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        __asm</span><br><span class="line">        &#123;</span><br><span class="line">                jmp fword ptr buf;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;zsaddfsafdsa\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正常执行。</p>
<h2 id="任务门"><a href="#任务门" class="headerlink" title="任务门"></a>任务门</h2><p>这里主要介绍如何通过任务门去访问任务段</p>
<p><strong>有了任务段为什么还要有任务门？</strong></p>
<p>答：任务门为异常(INT)提供了可切换任务的机制，是一种被动的机制，而单纯的任务段必须被主动调用(CALL JMP)</p>
<p>任务门描述符可以放在GDT,LDT和IDT中</p>
<h3 id="任务门描述符"><a href="#任务门描述符" class="headerlink" title="任务门描述符"></a>任务门描述符</h3><p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210810155043085.png" alt="image-20210810155043085"></p>
<p>TSS Segment Selector指向一个TSS段描述符。</p>
<p>任务门描述符的构造：0000E500&#96;XXXX0000</p>
<h3 id="任务门的执行过程"><a href="#任务门的执行过程" class="headerlink" title="任务门的执行过程"></a>任务门的执行过程</h3><p><strong>INT N—&gt;查IDT表，找到任务门描述符—&gt;通过中断门描述符，查GDT表，找到任务段描述符—&gt;使用TSS段中的值修改寄存器—&gt;IRETD返回。</strong></p>
<p>任务门描述符不一定在IDT中。多个任务门可以指向同一个TSS段描述符(如下图)</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210810155400565.png" alt="image-20210810155400565"></p>
<h3 id="课后练习：实现任务门进1环。"><a href="#课后练习：实现任务门进1环。" class="headerlink" title="课后练习：实现任务门进1环。"></a>课后练习：实现任务门进1环。</h3><p>实验流程图：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210816225541578.png" alt="image-20210816225541578"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __declspec(naked) <span class="built_in">test</span>()</span><br><span class="line">&#123;</span><br><span class="line">	_asm</span><br><span class="line">    &#123;</span><br><span class="line">        iretd</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> bu[<span class="number">0x10</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> iCr3;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input CR3:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%x&quot;</span>,&amp;iCr3);<span class="comment">//通过windbg工具!process 0 0指令获取</span></span><br><span class="line">    </span><br><span class="line">    DWORD iTss[<span class="number">0x68</span>]=&#123;<span class="comment">//用栈空间构造TSS，TSS段描述符中的Base填该数组的首地址</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//link</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//esp0</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//ss0</span></span><br><span class="line">        ((DWORD)bu)<span class="number">-0x10</span>,<span class="comment">//esp1  esp1必须修改，不然会蓝屏（不知为何任务段处做的零环实验，esp0可以不填）</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//ss1</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//esp2</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//ss2</span></span><br><span class="line">        (DWORD)iCr3,<span class="comment">//cr3</span></span><br><span class="line">        (DWORD)test,<span class="comment">//eip   此处要填入跳转位置的地址</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//eflags</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//eax</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//ecx</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//edx</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//ebx</span></span><br><span class="line">        ((DWORD)bu)<span class="number">-0x10</span>,<span class="comment">//esp   -0x10是因为esp是往小地址升栈的。</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//ebp</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//esi</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//edi</span></span><br><span class="line">        <span class="number">0x00000023</span>,<span class="comment">//es</span></span><br><span class="line">        <span class="number">0x00000091</span>,<span class="comment">//cs	0x1B（cs段选择子决定是否升了权限，由于0x91选择子指向的段描述符是1环权限，所以此处是提权了的）</span></span><br><span class="line">        <span class="number">0x00000099</span>,<span class="comment">//ss	0x23</span></span><br><span class="line">        <span class="number">0x00000023</span>,<span class="comment">//ds</span></span><br><span class="line">        <span class="number">0x000000A9</span>,<span class="comment">//fs	0x3B</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//gs</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//ldt(如果想使用LDT的话，可以自己构造LDT使用)</span></span><br><span class="line">        <span class="number">0x20ac0000</span> <span class="comment">//I/O Map Base Address</span></span><br><span class="line">	&#125;;</span><br><span class="line">    <span class="comment">/*__asm&#123;</span></span><br><span class="line"><span class="comment">        int 0x20</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;iTss:%x\n&quot;</span>,iTss);</span><br><span class="line">    _asm</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="number">0x20</span>;<span class="comment">//放入任务门</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造任务门放进IDT中第33个位置,即int 0x20对应的位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eq 8003f500 0000E500`00480000</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210816223122790.png" alt="image-20210816223122790"></p>
<p>在GDT的0x48位置构造TSS段描述符</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210816213131908.png" alt="image-20210816213131908"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eq 8003f048 0000E912`fdcc0068</span><br></pre></td></tr></table></figure>

<p>将原本<code>0x1B选择的CS</code>，<code>0x23选择的SS</code>和<code>0x3B选择的FS</code>三个段描述符复制后到GDT表的空的空间中，仅修改DPL为01b（因为目的是要进1环）。</p>
<ul>
<li><p>CS</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eq <span class="number">8003f</span>090 <span class="number">00</span>cfbb00`<span class="number">0000f</span>fff<span class="comment">//CS在TSS中修改为0x91</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>SS</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eq <span class="number">8003f</span>098 <span class="number">00</span>cfb300`<span class="number">0000f</span>fff<span class="comment">//SS在TSS中修改xin为0x99</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>FS</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eq <span class="number">8003f</span>0a8 <span class="number">0040b</span>300`<span class="number">00000f</span>ff<span class="comment">//FS在TSS中修改为0xA9</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>修改后的gdt表：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210816223047078.png" alt="image-20210816223047078"></p>
<p>成功执行：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210816223308855.png" alt="image-20210816223308855"></p>
<h3 id="逆向int-8实验"><a href="#逆向int-8实验" class="headerlink" title="逆向int 8实验"></a>逆向int 8实验</h3><p>下图第三题</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210810152110148.png" alt="image-20210810152110148"></p>
<p>windbg指令U</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">U　　//这个命令主要用于反汇编某个地址，其后面可以跟函数名和地址。</span><br></pre></td></tr></table></figure>

<p><strong>uf</strong>命令可以看到跳转等的下文。(更有用)</p>
<p><strong>实验流程图</strong>：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210816174502207.png" alt="image-20210816174502207"></p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/2018121811050612.png" alt="2018121811050612"></p>
<p>查看idt表吗，下图黄标为int 8的中断门描述符</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210816170139162.png" alt="image-20210816170139162"><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210810155043085.png" alt="image-20210810155043085"></p>
<p>0x85拆解为1000 0101b，type为0101b，发现int 8指向的是任务门描述符。可知TSS段选择子为0x0050,拆解为：0101 0000b，IT位为0，因此在gdt表中找gdtr+0x50的位置为TSS段描述符(如下图黄标)</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210816171357608.png" alt="image-20210816171357608"><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/67da19ce25a32b127b6e42f82ed6b0a3.jpeg" alt="67da19ce25a32b127b6e42f82ed6b0a3"></p>
<p>由TSS段描述符可知，TSS内存的所在位置为0x8054af00。</p>
<p>查看TSS内存：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/196406-20200102102107308-1624147754.png" alt="196406-20200102102107308-1624147754"></p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210816173952057.png" alt="image-20210816173952057"><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210816174123638.png" alt="image-20210816174123638"></p>
<p>上图黄标为EIP地址，0x805404ce。</p>
<p>windbg反汇编EIP地址，则找到了int 8将执行的目标代码：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210816190000468.png" alt="image-20210816190000468"></p>
<p>黄标就是蓝屏</p>
<p>CLI表示禁止中断发生，STL允许中断发生</p>
<p>IDA中找该函数：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210816190714434.png" alt="image-20210816190714434"></p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210816190840273.png" alt="image-20210816190840273"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; uf <span class="number">0x805404ce</span></span><br><span class="line">nt!KiTrap08:</span><br><span class="line"><span class="number">805404</span>ce fa              cli	<span class="comment">//IF位清零，即禁止中断发生</span></span><br><span class="line"><span class="number">805404</span>cf <span class="number">8b</span>0d3cf0dfff    mov     ecx,dword ptr ds:[<span class="number">0F</span>FDFF03Ch]</span><br><span class="line"><span class="number">805404</span>d5 <span class="number">8</span>d4150          lea     eax,[ecx+<span class="number">50</span>h]</span><br><span class="line"><span class="number">805404</span>d8 c6400589        mov     byte ptr [eax+<span class="number">5</span>],<span class="number">89</span>h<span class="comment">//改变任务段描述符状态为空闲，试图修改TSS段描述符中type中的忙位为0,</span></span><br><span class="line"><span class="number">805404</span>dc <span class="number">9</span>c              pushfd</span><br><span class="line"><span class="number">805404</span>dd <span class="number">812424f</span>fbfffff  <span class="keyword">and</span>     dword ptr [esp],<span class="number">0F</span>FFFBFFFh<span class="comment">//NT清0，不清楚意义何在</span></span><br><span class="line"><span class="number">805404e4</span> <span class="number">9</span>d              popfd</span><br><span class="line"><span class="number">805404e5</span> a13cf0dfff      mov     eax,dword ptr ds:[FFDFF03Ch]<span class="comment">//eax是GDT表首地址</span></span><br><span class="line"><span class="comment">//下面几步取TSS内存基址放入ecx中</span></span><br><span class="line"><span class="number">805404</span>ea <span class="number">8</span>a6857          mov     ch,byte ptr [eax+<span class="number">57</span>h]</span><br><span class="line"><span class="number">805404</span>ed <span class="number">8</span>a4854          mov     cl,byte ptr [eax+<span class="number">54</span>h]</span><br><span class="line"><span class="number">805404f</span>0 c1e110          shl     ecx,<span class="number">10</span>h</span><br><span class="line"><span class="number">805404f</span>3 <span class="number">668b</span>4852        mov     cx,word ptr [eax+<span class="number">52</span>h]<span class="comment">//此后ecx是gdtr+0x50的任务段描述符中的tss地址</span></span><br><span class="line"><span class="number">805404f</span>7 a140f0dfff      mov     eax,dword ptr ds:[FFDFF040h]<span class="comment">//似乎无用</span></span><br><span class="line"><span class="number">805404f</span>c <span class="number">890</span>d40f0dfff    mov     dword ptr ds:[<span class="number">0F</span>FDFF040h],ecx<span class="comment">//gdtr+0x50的任务段描述符中的tss地址放入[当前KPCR存TSS地址的地址中]</span></span><br><span class="line"></span><br><span class="line">nt!KiTrap08+<span class="number">0x34</span>:<span class="comment">//!!!!!!!!!!!!!!!!!</span></span><br><span class="line"><span class="number">80540502</span> <span class="number">6</span>a00            push    <span class="number">0</span></span><br><span class="line"><span class="number">80540504</span> <span class="number">6</span>a00            push    <span class="number">0</span></span><br><span class="line"><span class="number">80540506</span> <span class="number">6</span>a00            push    <span class="number">0</span></span><br><span class="line"><span class="number">80540508</span> <span class="number">50</span>              push    eax</span><br><span class="line"><span class="number">80540509</span> <span class="number">6</span>a08            push    <span class="number">8</span></span><br><span class="line"><span class="number">8054050b</span> <span class="number">6</span>a7f            push    <span class="number">7F</span>h</span><br><span class="line"><span class="number">8054050</span>d e8048dfbff      call    nt!<span class="built_in">KeBugCheck2</span> (<span class="number">804f</span>9216)</span><br><span class="line"><span class="number">80540512</span> ebee            jmp     nt!KiTrap08+<span class="number">0x34</span> (<span class="number">80540502</span>)  Branch<span class="comment">//循环至!!!!!!!!!!!!!!!!!</span></span><br></pre></td></tr></table></figure>

<p>上面代码分析不一定正确。</p>
<p>p.s.我取了内核态和用户态FS的值，在内核态FS&#x3D;0x30, 在用户态FS&#x3D;0x3B。</p>
<p>远程执行思路图：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210817122234616.png" alt="image-20210817122234616"></p>
<p>略（未实验）</p>
<h2 id="LDT相关"><a href="#LDT相关" class="headerlink" title="LDT相关"></a>LDT相关</h2><p>LDT段描述符结构</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/20200220223113225.jpg" alt="20200220223113225"></p>
<p>LDTR结构</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/20200221184557778.jpg" alt="20200221184557778"></p>
<p>与其他结构的关系</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/20200221211315395.jpg" alt="20200221211315395"></p>
<h3 id="自己构建LDT表和其中的数据段描述符实验"><a href="#自己构建LDT表和其中的数据段描述符实验" class="headerlink" title="自己构建LDT表和其中的数据段描述符实验"></a>自己构建LDT表和其中的数据段描述符实验</h3><ol>
<li>LLDT<br>LLDT的作用是装载局部描述符表寄存器LDTR。</li>
<li>SLDT<br>SLDT的作用是读取局部描述符表寄存器LDTR中的内容读取出来并存储。</li>
<li>LGDT<br>LGDT的作用是装载全局描述符表寄存器GDTR。</li>
<li>SGDT<br>SGDT的作用是读取全局描述符表寄存器GDTR中的内容读取出来并存储。</li>
</ol>
<p>LDT为什么叫局部描述符，是因为和程序挂钩，也就是用本程序的CR3才能获取到地址，所以应该放到三环。想看的话只能通过物理地址去看。</p>
<p>别的程序访问效果如下：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210816135130139.png" alt="image-20210816135130139"></p>
<p>实验代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> ldtTable[<span class="number">0x3ff</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> gdtr[<span class="number">6</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">__declspec(naked) <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		pushad;<span class="comment">//[去掉不影响实验成功]</span></span><br><span class="line">		pushfd;<span class="comment">//[去掉不影响实验成功]</span></span><br><span class="line">		lea eax,[gdtr+<span class="number">2</span>];<span class="comment">//读gdtTable的首地址所在地址</span></span><br><span class="line">		mov eax,[eax];<span class="comment">//读gdtTable的首地址</span></span><br><span class="line">        <span class="comment">//------开始构造ldt段描述符低4字节-------</span></span><br><span class="line">		lea eax,[eax+<span class="number">0x90</span>];<span class="comment">//eax为gdtTable的首地址+0x90的地址</span></span><br><span class="line">		lea ecx,ldtTable;<span class="comment">//ecx存自己构建的ldtTable的首地址</span></span><br><span class="line">		mov bx,cx;<span class="comment">//存到bx中，只取cx就够了</span></span><br><span class="line">		shl ebx,<span class="number">0x10</span>;<span class="comment">//左移16位(补零)</span></span><br><span class="line">		mov bx,<span class="number">0x03ff</span>;<span class="comment">//ebx为[cx]+03ff</span></span><br><span class="line">		mov dword ptr ds:[eax],ebx;<span class="comment">//构造好的ebx放进[gdtTable的首地址+0x90的地址]</span></span><br><span class="line">        <span class="comment">//------开始构造ldt段描述符高4字节-------</span></span><br><span class="line">		lea eax,[eax+<span class="number">4</span>];<span class="comment">//eax调整为[gdtTable的首地址+0x94的地址]</span></span><br><span class="line">		shr ecx,<span class="number">0x10</span>;<span class="comment">//将存放着自己构建的ldtTable的地址右移16位，即只保留高位的16位</span></span><br><span class="line">		mov byte ptr ds:[eax],cl;<span class="comment">//cx低8位放进[gdtTable的首地址+0x94的地址]</span></span><br><span class="line">		mov byte ptr ds:[eax+<span class="number">1</span>],<span class="number">0xe2</span>;<span class="comment">//0xe2放到[gdtTable的首地址+0x95的地址]   0xE2的拆解:P=1 DPL=11 S=0 TYPE=0010</span></span><br><span class="line">		mov byte ptr ds:[eax+<span class="number">4</span>],ch;<span class="comment">//cx高8位放进[gdtTable的首地址+0x98的地址]</span></span><br><span class="line">        <span class="comment">//-------ldt段描述符高4字节为[cl]+0xe2+0x00+[ch]------</span></span><br><span class="line">		mov ax,<span class="number">0x93</span>;</span><br><span class="line">		lldt ax;<span class="comment">//加载段选择子为0x93的ldt段描述符</span></span><br><span class="line">		popfd;<span class="comment">//[去掉不影响实验成功]</span></span><br><span class="line">		popad;<span class="comment">//[去掉不影响实验成功]</span></span><br><span class="line">		retf;<span class="comment">//调用门提权返回</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> buf[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x48</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="type">char</span> cldtr[]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b=<span class="number">0</span>;</span><br><span class="line">	*((<span class="type">unsigned</span> <span class="type">int</span> *)(ldtTable+<span class="number">8</span>))=<span class="number">0x0000ffff</span>;<span class="comment">//构造ldt表中的数据段描述符</span></span><br><span class="line">	*((<span class="type">unsigned</span> <span class="type">int</span> *)(ldtTable+<span class="number">0xc</span>))=<span class="number">0x00cFF300</span>;<span class="comment">//0x00cFF300是三环，0x00cf9300为0环</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%X,ldtTable=%X\n&quot;</span>,test,ldtTable);</span><br><span class="line">	</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		sgdt gdtr;</span><br><span class="line">		push fs;<span class="comment">//[去掉不影响实验成功]</span></span><br><span class="line">		call fword ptr buf;<span class="comment">//调用门提权，用于提权后构造ldt表与其内的数据段描述符</span></span><br><span class="line">		sldt cldtr;</span><br><span class="line">		pop fs;<span class="comment">//[去掉不影响实验成功]</span></span><br><span class="line">		mov ax,<span class="number">0x0f</span>;</span><br><span class="line">		mov ds,ax;<span class="comment">//加载ldt表内的数据段描述符</span></span><br><span class="line">		mov eax,a;<span class="comment">//尝试读</span></span><br><span class="line">		mov b,eax;<span class="comment">//尝试写(读a的值写入b)</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实验图解：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210816164118935.png" alt="image-20210816164118935"></p>
<p>运行程序</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210816163834960.png" alt="image-20210816163834960"></p>
<p>401000为test地址，可知构造的调用门描述符为</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eq gdtr+0x48 0040ec00`00081000</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210816164556502.png" alt="image-20210816164556502"></p>
<p>运行，下图成功将b改为10了，实验成功。</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210816164830888.png" alt="image-20210816164830888"></p>
<p>此时查看gdt表：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210816164938808.png" alt="image-20210816164938808"></p>
<p>0x90的位置(蓝色区域)已被修改为ldt段描述符</p>
<p>可进一步实验，将LDT中的数据段描述符改成DPL改为零环，则数据读写失败(略，已证明)</p>
<h1 id="保护模式–页"><a href="#保护模式–页" class="headerlink" title="保护模式–页"></a>保护模式–页</h1><p>实模式下访问的内存地址都是<strong>物理内存地址</strong>，保护模式下访问的内存地址都是<strong>线性地址</strong></p>
<p>物理内存的大小等同于内存条，但物理内存不是内存条，之间还有映射关系</p>
<p>线性地址，有效地址，物理地址的概念理解</p>
<p>如下指令：</p>
<p>MOV eax,dword ptr ds:[0x12345678]</p>
<p>其中，0x12345678是<strong>有效地址</strong></p>
<p>ds.Base+0x12345678是<strong>线性地址</strong>(通常有效地址和线性地址是一个值，因为ds.Base为0)</p>
<ul>
<li>线性地址转换成物理地址的方式在x86 cpu下有两种模式，一种是10-10-12，另一种是2-9-9-12的形式。</li>
<li>如果是64位CPU的话，还有第三种更加复杂的方式。(类似2-9-9-12)</li>
</ul>
<hr>
<ul>
<li>Q：两个进程都存在0x12345678的线性地址，为什么找到的内容不一样</li>
<li>A：因为<strong>每个进程都有各自的一堆表（存储着该进程线性地址到物理内存的映射关系）</strong></li>
</ul>
<h2 id="10-10-12分页"><a href="#10-10-12分页" class="headerlink" title="10-10-12分页"></a>10-10-12分页</h2><p>10-10-12分页的内核模块是ntoskrnl.exe</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210820144620796.png" alt="image-20210820144620796"></p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210817141821836.png" alt="image-20210817141821836"></p>
<p><strong>修改10-10-12分页的方式</strong>：boot.ini中的**&#x2F;execute&#x3D;optin**表示10-10-12分页</p>
<p>每个进程都有一个CR3（准确来说是CR3中的值）</p>
<p>CR3本身是一个寄存器，一个CPU核只有一套寄存器。</p>
<p>CR3指向一个物理页(所有寄存器中，只有CR3存的是物理地址，其他寄存器存的都是线性地址)，一共4096字节(4KB)，如图：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210817141832675.png" alt="image-20210817141832675"></p>
<p>将线性地址的32位拆分为10位，10位，12位。其中，第一个10位就代表了第一级内在什么位置。</p>
<p>windbg查看物理地址指令是<br>$$<br>!dd<br>$$<br>找第一级的物理地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!dd DirBase(低3位十六进制清零)+线性地址第一个十位*4</span><br></pre></td></tr></table></figure>

<p>将里面取得的值的低3位16进制置为0，因为低3位16进制代表的是属性</p>
<p>找第二级物理地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!dd 上一步取到的值(低3位十六进制清零)+线性地址第二个十位*4</span><br></pre></td></tr></table></figure>

<p>再次将取得的值的低3位16进制置为0</p>
<p>找到对应物理地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">要找的物理地址=上一步取到的值(低3位十六进制清零)+线性地址第三个12位</span><br></pre></td></tr></table></figure>

<p>取物理地址里存的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!dd 要找的物理地址</span><br></pre></td></tr></table></figure>



<h3 id="PDE与PTE"><a href="#PDE与PTE" class="headerlink" title="PDE与PTE"></a>PDE与PTE</h3><p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210817143849226.png" alt="image-20210817143849226"></p>
<p>页目录表（占4KB）中每个页目录表项占4个字节，每个页目录项又指向一个4KB的页表，每个页表项占4个字节。因此每个页表有1024个页表项。</p>
<p>无论是PDE还是PTE，里面记录的前20位*2的12次方(后面添加12位0)是<strong>物理地址</strong>，后面12位是属性。</p>
<p><strong>PTE的特点</strong></p>
<ul>
<li>PTE可以没有物理页(P位为0即无效，也就是没有物理页)，且只能对应一个物理页</li>
<li>多个PTE可以指向同一个物理页</li>
</ul>
<p><strong>10-10-12一些细节</strong></p>
<ol>
<li>一个物理页是4KB（4096个字节），刚好是2的12次方个字节，所以需要12个二进制位索引4KB大小的物理页，说明了10-10-12中最后一个为什么是12。</li>
<li>页表是1024个页表项，即2的10次方个成员，所以需要10个二进制位索引，说明了10-10-12的中间的10的由来。</li>
<li>同理页目录项。</li>
<li>10-10-12分页决定了当前CPU物理内存的最大值就是4GB(1024*1024*4096(B)&#x3D;4GB)</li>
</ol>
<p><strong>同一个进程的两个线性地址只要前5位16进制是一样的，那么他们就一定在一个物理页上。因为PDE与PTE都一样，而后三位十六进制只决定他们在物理页上的偏移。</strong></p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210817151041469.png" alt="image-20210817151041469"><br>$$<br>物理页的属性&#x3D;PDE属性\ &amp;\  PTE属性<br>$$</p>
<table>
<thead>
<tr>
<th><strong>位</strong></th>
<th><strong>功能描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>P</strong></td>
<td>有效位：1-有效    0-无效    决定是否存在物理页</td>
</tr>
<tr>
<td><strong>R&#x2F;W</strong></td>
<td>0-只读(常量区)	1-可读可写</td>
</tr>
<tr>
<td><strong>U&#x2F;S</strong></td>
<td>权限位：0-特权用户(-1环【VT】和0环)	1-普通用户(1,2,3环)</td>
</tr>
<tr>
<td><strong>P&#x2F;S</strong></td>
<td>只对PDE有意义，PS(PageSize)的意思，当PS&#x3D;&#x3D;1时，表示PDE指向大物理页(4MB)，即不需要拆分PTE了，<strong>PDE的低22位直接是物理页的页内偏移。</strong></td>
</tr>
<tr>
<td><strong>PAT</strong></td>
<td>页属性表（也是用来控制页属性的，但是对CPU有要求）</td>
</tr>
<tr>
<td><strong>A</strong></td>
<td>是否被访问(读或者写)过 访问过置1，即使只访问一个字节也会导致PDE，PTE置1</td>
</tr>
<tr>
<td><strong>D</strong></td>
<td>脏位：是否被写过   0-没有被写过     1-被写过</td>
</tr>
<tr>
<td><strong>G</strong></td>
<td>1-全局页(全局TLB)   0-相对TLB，只有P&#x2F;S位等于1的时候(大页)，他才有效。P&#x2F;S为零的时候，G位永远为零。<strong>全局页不会随进程切换清空TLB</strong></td>
</tr>
<tr>
<td><strong>PWT</strong></td>
<td>-</td>
</tr>
<tr>
<td><strong>PCD</strong></td>
<td>-</td>
</tr>
</tbody></table>
<p><strong>有效位</strong>,CPU没有使用，操作系统使用了，用来判断缺页。CPU寻址的时候发现P位为0就触发0xE号中断，此时操作系统得以发挥，在9~11位的有效位判断到底是没分物理页，还是缺页将此页挪到文件里了(然后再给补上页)。（具体的细节后面会有更详细的解读）</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210818201133076.png" alt="image-20210818201133076"></p>
<p><code>-的部分学完控制寄存器与TLB才能理解，此处先略过(后面有讲)</code></p>
<p>可见10-10-12分页没有可执行属性，但在2-9-9-12有个位对这种情况做了补充</p>
<p>页有两种</p>
<ul>
<li>小页单位：4KB</li>
<li>大页单位：4MB（只有系统里面一部分经常使用的内存才会使用大页）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov dword ptr ds:[<span class="number">0</span>]</span><br><span class="line"><span class="comment">//cpu两步判断这个线性地址可写：</span></span><br><span class="line"><span class="comment">//1. 判断ds段描述符是否可写</span></span><br><span class="line"><span class="comment">//2. 通过PDE&amp;PTE的R/W属性判断该物理地址是否可写</span></span><br><span class="line"><span class="number">0</span>的线性地址如果不可写，直接意味着<span class="number">0</span>x~<span class="number">0xFFF</span>的线性地址都不可写，因为前<span class="number">5</span>位<span class="number">16</span>进制一致，即都在同一个物理页上</span><br></pre></td></tr></table></figure>

<ol>
<li>2G以上是内核才能访问的原因是U&#x2F;S位的设置问题，如果将内核的某个页设置为1，就可以在R3访问了</li>
<li>0,1,2是系统环，可以访问系统页和用户页，0环是特权环；1,2环虽然不是特权级环，但是是系统环；3环是用户环，可以访问用户页</li>
</ol>
<h3 id="页目录表PDT基址-线性地址"><a href="#页目录表PDT基址-线性地址" class="headerlink" title="页目录表PDT基址(线性地址)"></a>页目录表PDT基址(线性地址)</h3><ul>
<li>Q：如果系统要保证某个线性地址是有效的，那么必须为其填充正确的PDE与PTE，如果我们想填充PDE与PTE，那么必须能够访问PDT与PTT。那么是谁帮我们填好了PDE与PTE呢？</li>
<li>A：操作系统；如果A进程创建B进程，那么是A进程帮B进程填好PDT和PTT</li>
</ul>
<p>在程序中，我们是不能直接访问物理页的，想要访问物理页，必须通过线性地址。</p>
<p>CR3中存储的是物理地址，不能在程序中直接读取的。如果想读取，也要把Cr3<br>的值挂到PDT和PTT中才能访问，那么怎么通过线性地址访问PDT和PTT呢？</p>
<p><strong>拆解4G线性内存：</strong></p>
<ol>
<li>低2G(0~7FFFFFFF) 各个进程几乎不同</li>
<li>高2G(80000000~FFFFFFFF) 各个进程几乎相同</li>
<li>0~7FFFFFFF的前64K和后64K都是没有映射的</li>
</ol>
<p>发现：<br>$$<br>0xC0300000线性地址存储的值就是PDT的基址<br>$$</p>
<ol>
<li><p>通过0xC0300000(这个线性地址是一定存在的，如果它不存在，系统也没办法访问这个表)找到的物理页就是页目录表</p>
</li>
<li><p>这个物理页即是页目录表，本身也是页表</p>
</li>
<li><p>页目录表是一张特殊的页表，每一项PTE指向的不是普通的物理页，而是指向其他的页表</p>
</li>
<li><p>如果我们要访问低N个PDE，公式如下：<br>$$<br>0xC0300000+N*4<br>$$</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210818111918749.png" alt="image-20210818111918749"></p>
</li>
</ol>
<p><strong>CR3中的值+0xC00该物理地址中存的就是CR3中的值</strong></p>
<p><strong>PDT是PTT中的一个（如图红色区域就是PDT）</strong>。</p>
<h3 id="页表PTT基址-线性地址"><a href="#页表PTT基址-线性地址" class="headerlink" title="页表PTT基址(线性地址)"></a>页表PTT基址(线性地址)</h3><ul>
<li>0xC0000000对应的是第一个PTT的基地址</li>
<li>0xC0001000对应的是第二个PTT的基地址</li>
<li>每个PTT基地址之间隔着0x1000（4KB）（物理地址不连续，但线性地址是连续的）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210818120306245.png" alt="image-20210818120306245"></p>
<ol>
<li>页表被映射到了从0xC0000000到0xC03FFFFF的4M地址空间</li>
<li>在这1024个表中有一张特殊的表：<strong>页目录表（页表中的第0x300项）</strong></li>
<li>页目录表被映射到了0xC0300000开始处的4K地址空间</li>
</ol>
<p><strong>0xC0300000实际上是通过0xC0000000算出来的：</strong><br>$$<br>VirtualAddr对应的PDE线性地址&#x3D;(VirtualAddr &gt;&gt; 12) * 4+0xC0000000<br>$$<br><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210822152334263.png" alt="image-20210822152334263"></p>
<blockquote>
<p>Windows 把所有页表映射到0xC0000000到0xC03FFFFF 这4MB的地址空间中，对于这4M的地址空间也有一个页目录表与之对应。不妨设为Px。既然Windows 把全部页表都映射到上述的4M地址空间，那么页目录表Px自然也在其中。第一个页表对应的线性地址为0xC0000000H，即用上述公式应该能找到第一张页表对应的PDE所在线性地址。利用公式PDE_Addr &#x3D; (VirtualAddr &gt;&gt; 12) * 4 + 0xC0000000，将0xC0000000H带入其中，可以求得第一个PDE地址：PDE_Addr &#x3D;C0300000H。</p>
<p>C0300000H-0xC0300FFF的页表映射了0xC0000000到0xC03FFFFF 这4MB的地址空间的物理内存。而这4m地址空间恰恰是页目录表的物理地址。所以说C0300000H-0xC0300FFF对应的4k地址空间就是页目录。</p>
</blockquote>
<p>windbg拆解线性地址命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">！vtop 3a37a000(CR3) 0xXXXXXXXX(要拆解的线性地址)</span><br></pre></td></tr></table></figure>

<h4 id="小实验"><a href="#小实验" class="headerlink" title="小实验"></a>小实验</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DWORD result1;</span><br><span class="line">DWORD result2;</span><br><span class="line">DWORD result3;</span><br><span class="line"></span><br><span class="line"> __declspec(naked) <span class="function"><span class="type">void</span> <span class="title">callGate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;	</span><br><span class="line">		pushad</span><br><span class="line">		pushfd</span><br><span class="line">		mov eax,dword ptr ds:[<span class="number">0xC0300000</span>];</span><br><span class="line">		mov result1,eax;</span><br><span class="line">		mov eax,dword ptr ds:[<span class="number">0xC0000000</span>];</span><br><span class="line">		mov result2,eax;</span><br><span class="line">		mov eax,dword ptr ds:[<span class="number">0xC0001000</span>];</span><br><span class="line">		mov result3,eax;</span><br><span class="line">		popfd</span><br><span class="line">		popad</span><br><span class="line">		retf</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;callGateFunc address:%X\n&quot;</span>,callGate);</span><br><span class="line">	<span class="type">char</span> gate[<span class="number">6</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x48</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">	_asm</span><br><span class="line">	&#123;</span><br><span class="line">		call fword ptr ds:[gate];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;0xC0300000 result:%X\n&quot;</span>,result1);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;0xC0000000 result:%X\n&quot;</span>,result2);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;0xC0001000 result:%X\n&quot;</span>,result3);</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210821182319577.png" alt="image-20210821182319577"></p>
<h4 id="掌握一个进程所有的物理内存读写权限【公式总结】"><a href="#掌握一个进程所有的物理内存读写权限【公式总结】" class="headerlink" title="掌握一个进程所有的物理内存读写权限【公式总结】"></a>掌握一个进程所有的物理内存读写权限<strong>【公式总结】</strong></h4><p>10-10-12		PDI-PTI-物理页内偏移</p>
<ul>
<li>PDI：页目录索引</li>
<li>PTI：页表索引</li>
</ul>
<ol>
<li><p><strong>访问页目录表项PDE地址的公式：</strong><br>$$<br>0xC0300000+PDI*4<br>$$</p>
</li>
<li><p><strong>访问页表项PTE地址的公式：</strong><br>$$<br>0xC0000000+PDI<em>4096+PTI</em>4<br>$$</p>
</li>
</ol>
<p>$$<br>0xC0000000+PDI<em>2的10次方</em>4+PTI<em>4&#x3D;0xC0000000+(PDI</em>2的10次方+PTI)*4<br>$$</p>
<p>$$<br>0xC0000000+PDI拼接PTI部分*4<br>$$</p>
<h5 id="实验-3"><a href="#实验-3" class="headerlink" title="实验"></a>实验</h5><p>将buf的物理页挂到0线性地址那附近，通过<code>0 + buf的物理页偏移部分</code>的地址调用MessageBoxW函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">push 0</span></span><br><span class="line"><span class="comment">push 0</span></span><br><span class="line"><span class="comment">push 0</span></span><br><span class="line"><span class="comment">push 0</span></span><br><span class="line"><span class="comment">call 0</span></span><br><span class="line"><span class="comment">retn</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">char</span> buf[]=&#123;<span class="number">0x6a</span>,<span class="number">0x00</span>,<span class="number">0x6a</span>,<span class="number">0</span>,<span class="number">0x6a</span>,<span class="number">0</span>,<span class="number">0x6a</span>,<span class="number">0</span>,<span class="number">0xE8</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0xc3</span>&#125;;</span><br><span class="line"></span><br><span class="line">__declspec(naked) <span class="function"><span class="type">void</span> <span class="title">callGate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;	</span><br><span class="line">		</span><br><span class="line">		push <span class="number">0x30</span>;<span class="comment">//手动修改fs框架1</span></span><br><span class="line">		pop fs;<span class="comment">//手动修改fs框架2</span></span><br><span class="line">		pushad;</span><br><span class="line">		pushfd;</span><br><span class="line">		</span><br><span class="line">		lea eax,buf;</span><br><span class="line">		mov ebx,dword ptr ds:[<span class="number">0xc0300000</span>];</span><br><span class="line">		test ebx,ebx;</span><br><span class="line">		je __gpPDE;<span class="comment">//PDE为0则跳转</span></span><br><span class="line"></span><br><span class="line">		shr eax,<span class="number">12</span>;<span class="comment">//去掉buf地址的最后12位物理页偏移</span></span><br><span class="line">		<span class="keyword">and</span> eax,<span class="number">0xfffff</span>;<span class="comment">//取buf地址前20位</span></span><br><span class="line">		shl eax,<span class="number">2</span>;<span class="comment">//buf地址前20位乘4</span></span><br><span class="line"></span><br><span class="line">		add eax, <span class="number">0xc0000000</span>;<span class="comment">//buf的PTE对应地址</span></span><br><span class="line">		mov eax,[eax];<span class="comment">//buf对应的PTE</span></span><br><span class="line">		mov dword ptr ds:[<span class="number">0xc0000000</span>],eax;<span class="comment">//将buf对应PTE放到0线性地址对应的PTE位置中</span></span><br><span class="line">		jmp __retR;</span><br><span class="line"></span><br><span class="line">__gpPDE:		<span class="comment">//如果0线性地址对应的PDE是0的话跳转到这里来</span></span><br><span class="line">		shr eax,<span class="number">22</span>;</span><br><span class="line">		<span class="keyword">and</span> eax,<span class="number">0x3ff</span>;<span class="comment">//取第一个10位</span></span><br><span class="line">		shl eax,<span class="number">2</span>;<span class="comment">//第一个10位乘4</span></span><br><span class="line">		</span><br><span class="line">		add eax, <span class="number">0xc0300000</span>;<span class="comment">//找到对应PDE的地址</span></span><br><span class="line">		mov eax,[eax];<span class="comment">//找到对应PDE</span></span><br><span class="line">		mov dword ptr ds:[<span class="number">0xc0300000</span>],eax;<span class="comment">//将buf对应PDE放到0线性地址对应的PDE位置中，PDE就换了，所以后面的PTE也就不用换了，反正整个PTT表都换了</span></span><br><span class="line">__retR:	</span><br><span class="line">		popfd;</span><br><span class="line">		popad;</span><br><span class="line">		retf;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> functionAddress = (<span class="type">unsigned</span> <span class="type">int</span>)MessageBox;<span class="comment">//获取MessageBox地址</span></span><br><span class="line">	<span class="type">int</span> offset1=((<span class="type">unsigned</span> <span class="type">int</span>)buf) &amp; <span class="number">0xfff</span>;<span class="comment">//获取buf本身的物理页上的偏移</span></span><br><span class="line">	<span class="comment">//修正EIP,调用MessageBoxW函数</span></span><br><span class="line">	*((<span class="type">unsigned</span> <span class="type">int</span> *)&amp;buf[<span class="number">9</span>])= functionAddress - (<span class="number">13</span> + offset1); </span><br><span class="line">	<span class="type">char</span> segmentGate[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x48</span>,<span class="number">0</span>&#125;;<span class="comment">//调用门,0040EC00`00081000</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;MessageBox:%X  callGate = %X,buf=%X\n&quot;</span>,MessageBox,callGate,buf);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		call fword ptr segmentGate;</span><br><span class="line">		push <span class="number">0x3b</span>;<span class="comment">//手动修正fs框架1</span></span><br><span class="line">		pop fs;<span class="comment">//手动修正fs框架2</span></span><br><span class="line">		mov eax,offset1;</span><br><span class="line">		call eax;<span class="comment">//调用offset地址</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210821192154718.png" alt="image-20210821192154718"></p>
<h4 id="10-10-12内核逆向分析MmIsAddressValid函数"><a href="#10-10-12内核逆向分析MmIsAddressValid函数" class="headerlink" title="10-10-12内核逆向分析MmIsAddressValid函数"></a>10-10-12内核逆向分析MmIsAddressValid函数</h4><p>一个用于判断虚拟内存地址是否有效的API，逆向该函数可以知道操作系统是怎么找PDE和PTE的。</p>
<h5 id="用IDA"><a href="#用IDA" class="headerlink" title="用IDA"></a>用IDA</h5><p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210819130503077.png" alt="image-20210819130503077"></p>
<p>可以将内核文件放入IDA分析。</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210819132944697.png" alt="image-20210819132944697"></p>
<h5 id="用windbg"><a href="#用windbg" class="headerlink" title="用windbg"></a>用windbg</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uf MmIsAddressValid</span><br></pre></td></tr></table></figure>

<p>尝试逆向：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; uf MmIsAddressValid</span><br><span class="line">nt!MmIsAddressValid:</span><br><span class="line"><span class="number">804e4661</span> <span class="number">8b</span>ff            mov     edi,edi</span><br><span class="line"><span class="number">804e4663</span> <span class="number">55</span>              push    ebp</span><br><span class="line"><span class="number">804e4664</span> <span class="number">8b</span>ec            mov     ebp,esp</span><br><span class="line"><span class="number">804e4666</span> <span class="number">8b</span>4d08          mov     ecx,dword ptr [ebp+<span class="number">8</span>]<span class="comment">//要检查的线性地址存入ecx</span></span><br><span class="line"><span class="number">804e4669</span> <span class="number">8b</span>c1            mov     eax,ecx</span><br><span class="line"><span class="number">804e466</span>b c1e814          shr     eax,<span class="number">14</span>h<span class="comment">//要检查的线性地址右移20位，相当于右移22位再左移2位，即乘4,下一句修正后两位</span></span><br><span class="line"><span class="number">804e466</span>e bafc0f0000      mov     edx,<span class="number">0F</span>FCh</span><br><span class="line"><span class="number">804e4673</span> <span class="number">23</span>c2            <span class="keyword">and</span>     eax,edx<span class="comment">//(要检查的线性地址前12位)的后两位清零</span></span><br><span class="line"><span class="number">804e4675</span> <span class="number">2</span>d0000d03f      sub     eax,<span class="number">3F</span>D00000h<span class="comment">//等同于add eax,0xc0300000</span></span><br><span class="line"><span class="number">804e467</span>a <span class="number">8b</span>00            mov     eax,dword ptr [eax]<span class="comment">//此后eax为PDE的值</span></span><br><span class="line"><span class="number">804e467</span>c a801            test    al,<span class="number">1</span><span class="comment">//检测PDE末尾（P位）是否为1</span></span><br><span class="line"><span class="number">804e467</span>e <span class="number">0f</span>84d2f10000    je      nt!MmIsAddressValid+<span class="number">0x4f</span> (<span class="number">804f</span>3856)  Branch<span class="comment">//P位不为1就跳</span></span><br><span class="line"></span><br><span class="line">nt!MmIsAddressValid+<span class="number">0x1f</span>:</span><br><span class="line"><span class="number">804e4684</span> <span class="number">84</span>c0            test    al,al</span><br><span class="line"><span class="number">804e4686</span> <span class="number">7824</span>            js      nt!MmIsAddressValid+<span class="number">0x53</span> (<span class="number">804e46</span>ac)  Branch<span class="comment">//判断PDE后8位的首位(P/S位)是否1，是1就跳，表示指向大物理页，不用拆pte了</span></span><br><span class="line"></span><br><span class="line">nt!MmIsAddressValid+<span class="number">0x23</span>:</span><br><span class="line"><span class="number">804e4688</span> c1e90a          shr     ecx,<span class="number">0</span>Ah<span class="comment">//要检查的线性地址右移10位，相当于左移12位后右移两位，因为要乘4,下一句修正后两位</span></span><br><span class="line"><span class="number">804e468</span>b <span class="number">81e1</span>fcff3f00    <span class="keyword">and</span>     ecx,<span class="number">3F</span>FFFCh<span class="comment">//右移后的线性地址的后两位清零</span></span><br><span class="line"><span class="number">804e4691</span> <span class="number">81e900000040</span>    sub     ecx,<span class="number">40000000</span>h<span class="comment">//等同于add ecx,0xc0000000</span></span><br><span class="line"><span class="number">804e4697</span> <span class="number">8b</span>c1            mov     eax,ecx</span><br><span class="line"><span class="number">804e4699</span> <span class="number">8b</span>08            mov     ecx,dword ptr [eax]<span class="comment">//此后ecx是PTE的值</span></span><br><span class="line"><span class="number">804e469</span>b f6c101          test    cl,<span class="number">1</span><span class="comment">//判断P位</span></span><br><span class="line"><span class="number">804e469</span>e <span class="number">0f</span>84b2f10000    je      nt!MmIsAddressValid+<span class="number">0x4f</span> (<span class="number">804f</span>3856)  Branch<span class="comment">//P位不为1就跳</span></span><br><span class="line"></span><br><span class="line">nt!MmIsAddressValid+<span class="number">0x3b</span>:</span><br><span class="line"><span class="number">804e46</span>a4 <span class="number">84</span>c9            test    cl,cl<span class="comment">//判断PAT位</span></span><br><span class="line"><span class="number">804e46</span>a6 <span class="number">0f</span>88b6de0300    js      nt!MmIsAddressValid+<span class="number">0x3f</span> (<span class="number">80522562</span>)  Branch<span class="comment">//PAT位是1就跳，即PAT为0则一定是有效的</span></span><br><span class="line"></span><br><span class="line">nt!MmIsAddressValid+<span class="number">0x53</span>:</span><br><span class="line"><span class="number">804e46</span>ac b001            mov     al,<span class="number">1</span><span class="comment">//al置1，因为eax是默认返回值，返回1，线性地址有效</span></span><br><span class="line"></span><br><span class="line">nt!MmIsAddressValid+<span class="number">0x55</span>:<span class="comment">//返回</span></span><br><span class="line"><span class="number">804e46</span>ae <span class="number">5</span>d              pop     ebp</span><br><span class="line"><span class="number">804e46</span>af c20400          ret     <span class="number">4</span></span><br><span class="line">    </span><br><span class="line"> nt!MmIsAddressValid+<span class="number">0x4f</span>:<span class="comment">//PDE或PTE的P位检查未通过</span></span><br><span class="line"><span class="number">804f</span>3856 <span class="number">32</span>c0            <span class="keyword">xor</span>     al,al<span class="comment">//al置0，因为eax是默认返回值，返回0，线性地址无效</span></span><br><span class="line"><span class="number">804f</span>3858 e9510effff      jmp     nt!MmIsAddressValid+<span class="number">0x55</span> (<span class="number">804e46</span>ae)  Branch</span><br><span class="line"></span><br><span class="line">nt!MmIsAddressValid+<span class="number">0x3f</span>:<span class="comment">//PAT位=1的处理</span></span><br><span class="line"><span class="number">80522562</span> <span class="number">23</span>c2            <span class="keyword">and</span>     eax,edx<span class="comment">//edx：0FFCh，eax：PTE的线性地址</span></span><br><span class="line">    <span class="comment">//比如说0xC0000XXX变成XXX</span></span><br><span class="line"><span class="number">80522564</span> <span class="number">8b</span>80000030c0    mov     eax,dword ptr [eax<span class="number">-3F</span>D00000h]<span class="comment">//比如说0xC0000XXX变成0xC0300XXX，自己实验中发现0xC0300XXX地址中为0</span></span><br><span class="line"><span class="number">8052256</span>a <span class="number">66258100</span>        <span class="keyword">and</span>     ax,<span class="number">81</span>h</span><br><span class="line"><span class="number">8052256</span>e <span class="number">3</span>c81            cmp     al,<span class="number">81</span>h<span class="comment">//第0位和第7位必须为1内存地址才有效</span></span><br><span class="line"><span class="number">80522570</span> <span class="number">0f</span>853621fcff    jne     nt!MmIsAddressValid+<span class="number">0x53</span> (<span class="number">804e46</span>ac)  Branch</span><br><span class="line"></span><br><span class="line">nt!MmIsAddressValid+<span class="number">0x53</span>:<span class="comment">//检查未通过</span></span><br><span class="line"><span class="number">80522576</span> e9db12fdff      jmp     nt!MmIsAddressValid+<span class="number">0x4f</span> (<span class="number">804f</span>3856)  Branch</span><br></pre></td></tr></table></figure>

<blockquote>
<p>sub     eax,3FD00000h等同于add eax,0xc0300000详解：</p>
<p>因为3FD00000h+0xc0300000&#x3D;0x100000000</p>
<p>eax+0xc0300000&#x3D;eax+0x100000000-3FD00000h，0x100000000装不下所以会溢出等同于没有。</p>
</blockquote>
<h2 id="2-9-9-12分页"><a href="#2-9-9-12分页" class="headerlink" title="2-9-9-12分页"></a>2-9-9-12分页</h2><p>2-9-9-12分页的内核模块是ntkrnlpa.exe</p>
<p>在之前的课程中我们讲解了<strong>10-10-12分页</strong>方式，在这种分页方式下，物理地址最多可达4GB，但随着硬件发展，4GB的物理地址范围已经无法满足要求，Intel在1996年就已经意识到这个问题了，所以设计了新的分页方式。也就是我们本节课要讲的<strong>2-9-9-12分页</strong>，又称为<strong>PAE（物理地址拓展）分页</strong>。</p>
<p>与64位比较相似。</p>
<p><strong>为什么是10-10-12</strong></p>
<ol>
<li>先确定了物理页的大小为4K，所以后面的12位的功能就确定了。</li>
<li>当初的物理内存比较小，所以4个字节的PTE就够了，加上页的尺寸是4K，所以一个页能存储1024个PTE，也就是2的10次方，第二个10位确定了。</li>
<li>剩下的10位为PDI，10+10+12&#x3D;32。</li>
</ol>
<p><strong>为什么是2-9-9-12</strong></p>
<ol>
<li><p>物理页的大小是确定的，4KB不能随便改，所以后面的12位确定了</p>
</li>
<li><p>如果想增大物理内存的访问范围，就需要增大PTE，增大多少了呢，考虑对齐的因素，增加到8个字节。</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210819142745181.png" alt="image-20210819142745181"></p>
<p>因为一个物理页就4KB，由于PTE由4字节变成8字节，所以项数由1024项缩小为512项。</p>
<p>而512项需要9个二进制位进行索引，所以PTI是9。</p>
</li>
<li><p>同理PDI也是9位(2的9次方) </p>
</li>
<li><p>最后，32 - 9 - 9 - 12 还差2位 所以就再做一级 叫PDPI</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210819143625209.png" alt="image-20210819143625209"></p>
<p>因为只有两位，所以PDPTE只有4个。</p>
<p>2-9-9-12可以最大允许的物理内存为：2的36次方(PDE是36位的物理地址宽度)，即<strong>64G</strong>。</p>
<p>2-9-9-12 VirtualAddr对应的PDE线性地址&#x3D;(VirtualAddr &gt;&gt; 12) * 8+0xC0000000</p>
<p>代入第一个PTE的地址0xC0000000可知：PDT地址为0xC0600000</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210822194231558.png" alt="image-20210822194231558"></p>
<p>第4个PDPTE指向了一个PDT表，此表的前四项指向了PDPTE的每一个元素。</p>
<ul>
<li>C0600000是第一个PDT表的首地址</li>
<li>C0601000是第二个PDT表的首地址</li>
<li>C0602000是第三个PDT表的首地址</li>
<li>C0603000是第四个PDT表的首地址</li>
</ul>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210822211646330.png" alt="image-20210822211646330"></p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210822212611498.png" alt="image-20210822212611498"></p>
<p>在同一个PDT中相邻两个PTT首地址间隔为0x1000</p>
<p>通过0xC0603000线性地址读取第四个PDT的第一个PDE内容成功：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210822213911198.png" alt="image-20210822213911198"></p>
<ol>
<li><p><strong>访问页目录表项PDE地址的公式：</strong></p>
<ul>
<li>0xC0000000+PDI*4</li>
<li>0xC0100000+PDI*4</li>
<li>0xC0200000+PDI*4</li>
<li>0xC0300000+PDI*4</li>
</ul>
</li>
<li><p><strong>访问页表项PTE地址的公式：</strong><br>$$<br>0xC0000000+PDI<em>4096+PTI</em>8<br>$$</p>
</li>
</ol>
<h3 id="页目录指针表项Page-Dircetory-Point-Table-Entry"><a href="#页目录指针表项Page-Dircetory-Point-Table-Entry" class="headerlink" title="页目录指针表项Page-Dircetory-Point-Table Entry"></a>页目录指针表项Page-Dircetory-Point-Table Entry</h3><p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210819144239301.png" alt="image-20210819144239301"></p>
<p>Avail：CPU设计给操作系统用的，操作系统设计者爱用不用</p>
<p>35~12位存储的是页目录表PDT的物理基址，低12位补零，共36位，即页目录表基址。</p>
<p>存的项也是占用8字节</p>
<h3 id="PDE结构"><a href="#PDE结构" class="headerlink" title="PDE结构"></a>PDE结构</h3><p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210819144958741.png" alt="image-20210819144958741"></p>
<table>
<thead>
<tr>
<th><strong>位</strong></th>
<th><strong>功能描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>P</strong></td>
<td>有效位：1-有效    0-无效    决定是否存在物理页</td>
</tr>
<tr>
<td><strong>R&#x2F;W</strong></td>
<td>0-只读(常量区)	1-可读可写</td>
</tr>
<tr>
<td><strong>U&#x2F;S</strong></td>
<td>权限位：0-特权用户(-1环【VT】和0环)	1-普通用户(1,2,3环)</td>
</tr>
<tr>
<td><strong>P&#x2F;S</strong></td>
<td>只对PDE有意义，PS(PageSize)的意思，当PS&#x3D;&#x3D;1时，表示PDE指向大物理页(2MB)</td>
</tr>
<tr>
<td><strong>PAT</strong></td>
<td>页属性表（也是用来控制页属性的，但是对CPU有要求）</td>
</tr>
<tr>
<td><strong>A</strong></td>
<td>是否被访问(读或者写)过 访问过置1，即使只访问一个字节也会导致PDE，PTE置1</td>
</tr>
<tr>
<td><strong>D</strong></td>
<td>脏位：是否被写过   0-没有被写过     1-被写过</td>
</tr>
<tr>
<td><strong>G</strong></td>
<td>1-全局页(全局TLB)   0-相对TLB，只有P&#x2F;S位等于1的时候(大页)，他才有效。P&#x2F;S为零的时候，G位永远为零。</td>
</tr>
<tr>
<td><strong>PWT</strong></td>
<td>-</td>
</tr>
<tr>
<td><strong>PCD</strong></td>
<td>-</td>
</tr>
</tbody></table>
<p>2-9-9-12结构下的两种页</p>
<ol>
<li>小页	4KB</li>
<li>大页    2MB（和10-10-12分页的4MB不一样，2的(9+12)次方）</li>
</ol>
<h3 id="PTE结构"><a href="#PTE结构" class="headerlink" title="PTE结构"></a>PTE结构</h3><p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210819151236597.png" alt="image-20210819151236597"></p>
<p>小实验：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//12FF7C地址中存了一个100</span></span><br><span class="line"><span class="comment">//拆分线性地址：</span></span><br><span class="line"><span class="comment">//00</span></span><br><span class="line"><span class="comment">//0 0000 0000</span></span><br><span class="line"><span class="comment">//1 0010 1111  =0x12F  *8=0x978</span></span><br><span class="line"><span class="comment">//F7C</span></span><br><span class="line"></span><br><span class="line">Failed to get VadRoot</span><br><span class="line">PROCESS <span class="number">818</span>eeb70  SessionId: <span class="number">0</span>  Cid: <span class="number">0714</span>    Peb: <span class="number">7f</span>fde000  ParentCid: <span class="number">0648</span></span><br><span class="line">    DirBase: <span class="number">089</span>c02e0  ObjectTable: e118dde0  HandleCount:  <span class="number">15.</span></span><br><span class="line">    Image: test.exe</span><br><span class="line"></span><br><span class="line">kd&gt; !dq <span class="number">089</span>c02e0</span><br><span class="line"># <span class="number">89</span>c02e0 <span class="number">00000000</span>`<span class="number">18116001</span> <span class="number">00000000</span>`<span class="number">18057001</span></span><br><span class="line"># <span class="number">89</span>c02f0 <span class="number">00000000</span>`<span class="number">18058001</span> <span class="number">00000000</span>`<span class="number">18095001</span></span><br><span class="line"># <span class="number">89</span>c0300 <span class="number">00000000</span>`<span class="number">17</span>d7b001 <span class="number">00000000</span>`<span class="number">17</span>efc001</span><br><span class="line"># <span class="number">89</span>c0310 <span class="number">00000000</span>`<span class="number">17f</span>bd001 <span class="number">00000000</span>`<span class="number">17f</span>fa001</span><br><span class="line"># <span class="number">89</span>c0320 <span class="number">00000000</span>`<span class="number">15886001</span> <span class="number">00000000</span>`<span class="number">15707001</span></span><br><span class="line"># <span class="number">89</span>c0330 <span class="number">00000000</span>`<span class="number">155</span>c8001 <span class="number">00000000</span>`<span class="number">158</span>c5001</span><br><span class="line"># <span class="number">89</span>c0340 <span class="number">00000000</span>`f8d0e360 <span class="number">00000000</span>`<span class="number">164</span>cc001</span><br><span class="line"># <span class="number">89</span>c0350 <span class="number">00000000</span>`<span class="number">166</span>cd001 <span class="number">00000000</span>`<span class="number">1674</span>a001</span><br><span class="line">kd&gt; !dq <span class="number">18116000</span></span><br><span class="line">#<span class="number">18116000</span> <span class="number">00000000</span>`<span class="number">17b</span>fe067 <span class="number">00000000</span>`<span class="number">18019067</span></span><br><span class="line">#<span class="number">18116010</span> <span class="number">00000000</span>`<span class="number">17f</span>3d067 <span class="number">00000000</span>`<span class="number">00000000</span></span><br><span class="line">#<span class="number">18116020</span> <span class="number">00000000</span>`<span class="number">00000000</span> <span class="number">00000000</span>`<span class="number">00000000</span></span><br><span class="line">#<span class="number">18116030</span> <span class="number">00000000</span>`<span class="number">00000000</span> <span class="number">00000000</span>`<span class="number">00000000</span></span><br><span class="line">#<span class="number">18116040</span> <span class="number">00000000</span>`<span class="number">00000000</span> <span class="number">00000000</span>`<span class="number">00000000</span></span><br><span class="line">#<span class="number">18116050</span> <span class="number">00000000</span>`<span class="number">00000000</span> <span class="number">00000000</span>`<span class="number">00000000</span></span><br><span class="line">#<span class="number">18116060</span> <span class="number">00000000</span>`<span class="number">00000000</span> <span class="number">00000000</span>`<span class="number">00000000</span></span><br><span class="line">#<span class="number">18116070</span> <span class="number">00000000</span>`<span class="number">00000000</span> <span class="number">00000000</span>`<span class="number">00000000</span></span><br><span class="line">kd&gt; !dq <span class="number">17b</span>fe000+<span class="number">0x12F</span>*<span class="number">8</span></span><br><span class="line">#<span class="number">17b</span>fe978 <span class="number">80000000</span>`<span class="number">17f</span>92067 <span class="number">80000000</span>`<span class="number">0e2</span>c3025</span><br><span class="line">#<span class="number">17b</span>fe988 <span class="number">80000000</span>`<span class="number">0e244025</span> <span class="number">00000000</span>`<span class="number">00000000</span></span><br><span class="line">#<span class="number">17b</span>fe998 <span class="number">00000000</span>`<span class="number">00000000</span> <span class="number">00000000</span>`<span class="number">00000000</span></span><br><span class="line">#<span class="number">17b</span>fe9a8 <span class="number">00000000</span>`<span class="number">00000000</span> <span class="number">00000000</span>`<span class="number">00000000</span></span><br><span class="line">#<span class="number">17b</span>fe9b8 <span class="number">00000000</span>`<span class="number">00000000</span> <span class="number">00000000</span>`<span class="number">00000000</span></span><br><span class="line">#<span class="number">17b</span>fe9c8 <span class="number">00000000</span>`<span class="number">00000000</span> <span class="number">00000000</span>`<span class="number">00000000</span></span><br><span class="line">#<span class="number">17b</span>fe9d8 <span class="number">00000000</span>`<span class="number">00000000</span> <span class="number">00000000</span>`<span class="number">00000000</span></span><br><span class="line">#<span class="number">17b</span>fe9e8 <span class="number">00000000</span>`<span class="number">00000000</span> <span class="number">00000000</span>`<span class="number">00000000</span></span><br><span class="line">kd&gt; !dd <span class="number">17f</span>92000+<span class="number">0xF7C</span></span><br><span class="line">#<span class="number">17f</span>92f7c 【<span class="number">00000064</span>】 <span class="number">0012f</span>fc0 <span class="number">00401309</span> <span class="number">00000001</span><span class="comment">//【】中确实为100</span></span><br><span class="line">#<span class="number">17f</span>92f8c <span class="number">00380b</span>90 <span class="number">00380</span>c08 <span class="number">00380039</span> <span class="number">00360032</span></span><br><span class="line">#<span class="number">17f</span>92f9c <span class="number">7f</span>fde000 <span class="number">00000006</span> b2cded04 <span class="number">0012f</span>f94</span><br><span class="line">#<span class="number">17f</span>92fac <span class="number">8061850</span>d <span class="number">0012f</span>fe0 <span class="number">00404950</span> <span class="number">00410278</span></span><br><span class="line">#<span class="number">17f</span>92fbc <span class="number">00000000</span> <span class="number">0012f</span>ff0 <span class="number">7</span>c817067 <span class="number">00380039</span></span><br><span class="line">#<span class="number">17f</span>92fcc <span class="number">00360032</span> <span class="number">7f</span>fde000 <span class="number">80545b</span>fd <span class="number">0012f</span>fc8</span><br><span class="line">#<span class="number">17f</span>92fdc <span class="number">8197</span>eb40 ffffffff <span class="number">7</span>c839ac0 <span class="number">7</span>c817070</span><br><span class="line">#<span class="number">17f</span>92fec <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00401220</span></span><br></pre></td></tr></table></figure>

<h3 id="X-x2F-D标志位"><a href="#X-x2F-D标志位" class="headerlink" title="X&#x2F;D标志位"></a>X&#x2F;D标志位</h3><p>在AMD中称为NX，即No Excetion</p>
<p><strong>PDE&#x2F;PTE结构如下</strong></p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210819151523802.png" alt="image-20210819151523802"></p>
<ul>
<li>段的属性有可读，可写和可执行</li>
<li>页的属性只有可读，可写</li>
</ul>
<p>当RET执行返回的时候，如果我修改堆栈里面的数据指向一个我提前准备好的数据(把数据当做代码来执行，漏洞都是依赖这点)</p>
<p>所以，Intel就做了硬件保护，做了一个不可执行位，XD&#x3D;1时，那么你的软件溢出了也没关系，即使你的EIP蹦到了危险的“数据区“，也是不可以执行的！</p>
<p><strong>在PAE(2-9-9-12)分页模式下，PDE或PTE的最高位为XD&#x2F;NX位,为1表示该内存只可在代码段执行。</strong>数据段不可执行</p>
<p>0x8开头的就是被保护的，因为首位二进制为1,进0环了直接改了就是了</p>
<h3 id="2-9-9-12内核逆向分析MmIsAddressValid函数"><a href="#2-9-9-12内核逆向分析MmIsAddressValid函数" class="headerlink" title="2-9-9-12内核逆向分析MmIsAddressValid函数"></a>2-9-9-12内核逆向分析MmIsAddressValid函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">nt!MmIsAddressValid:</span><br><span class="line"><span class="number">80511980</span> <span class="number">8b</span>ff            mov     edi,edi</span><br><span class="line"><span class="number">80511982</span> <span class="number">55</span>              push    ebp</span><br><span class="line"><span class="number">80511983</span> <span class="number">8b</span>ec            mov     ebp,esp</span><br><span class="line"><span class="number">80511985</span> <span class="number">51</span>              push    ecx</span><br><span class="line"><span class="number">80511986</span> <span class="number">51</span>              push    ecx</span><br><span class="line"><span class="number">80511987</span> <span class="number">8b</span>4d08          mov     ecx,dword ptr [ebp+<span class="number">8</span>]<span class="comment">//ecx取到要判断是否有效的线性地址</span></span><br><span class="line"><span class="number">8051198</span>a <span class="number">56</span>              push    esi<span class="comment">//push esi代表后面要用esi</span></span><br><span class="line"><span class="number">8051198b</span> <span class="number">8b</span>c1            mov     eax,ecx<span class="comment">//eax也为要判断是否有效的线性地址</span></span><br><span class="line"><span class="number">8051198</span>d c1e812          shr     eax,<span class="number">12</span>h<span class="comment">//右移18位</span></span><br><span class="line"><span class="number">80511990</span> bef83f0000      mov     esi,<span class="number">3F</span>F8h</span><br><span class="line"><span class="number">80511995</span> <span class="number">23</span>c6            <span class="keyword">and</span>     eax,esi<span class="comment">//与11 1111 1111 1000，此后eax为pdi部分</span></span><br><span class="line"><span class="number">80511997</span> <span class="number">2</span>d0000a03f      sub     eax,<span class="number">3F</span>A00000h<span class="comment">//add eax,C0600000，eax此后为线性地址对应的PDE地址</span></span><br><span class="line"><span class="number">8051199</span>c <span class="number">8b</span>10            mov     edx,dword ptr [eax]<span class="comment">//edx为pde低64位</span></span><br><span class="line"><span class="number">8051199</span>e <span class="number">8b</span>4004          mov     eax,dword ptr [eax+<span class="number">4</span>]<span class="comment">//eax为pde高64位</span></span><br><span class="line"><span class="number">805119</span>a1 <span class="number">8945f</span>c          mov     dword ptr [ebp<span class="number">-4</span>],eax<span class="comment">//pde高64位存进局部变量1中</span></span><br><span class="line"><span class="number">805119</span>a4 <span class="number">8b</span>c2            mov     eax,edx<span class="comment">//eax为pde低64位</span></span><br><span class="line"><span class="number">805119</span>a6 <span class="number">57</span>              push    edi<span class="comment">//要用edi</span></span><br><span class="line"><span class="number">805119</span>a7 <span class="number">83e001</span>          <span class="keyword">and</span>     eax,<span class="number">1</span><span class="comment">//eax为PDE的p位</span></span><br><span class="line"><span class="number">805119</span>aa <span class="number">33f</span>f            <span class="keyword">xor</span>     edi,edi<span class="comment">//edi清零</span></span><br><span class="line"><span class="number">805119</span>ac <span class="number">0b</span>c7            <span class="keyword">or</span>      eax,edi<span class="comment">//判断PDE的p位是否为0</span></span><br><span class="line"><span class="number">805119</span>ae <span class="number">7461</span>            je      nt!MmIsAddressValid+<span class="number">0x91</span> (<span class="number">80511</span>a11)  Branch<span class="comment">//PDE的p位为零则跳</span></span><br><span class="line"></span><br><span class="line">nt!MmIsAddressValid+<span class="number">0x30</span>:<span class="comment">//PDE的p位不是零</span></span><br><span class="line"><span class="number">805119b</span>0 bf80000000      mov     edi,<span class="number">80</span>h</span><br><span class="line"><span class="number">805119b</span>5 <span class="number">23</span>d7            <span class="keyword">and</span>     edx,edi<span class="comment">//取pde的PS位，判断是否大页</span></span><br><span class="line"><span class="number">805119b</span>7 <span class="number">6</span>a00            push    <span class="number">0</span></span><br><span class="line"><span class="number">805119b</span>9 <span class="number">8955f</span>8          mov     dword ptr [ebp<span class="number">-8</span>],edx<span class="comment">//pde的PS位存入局部变量2空间</span></span><br><span class="line"><span class="number">805119b</span>c <span class="number">58</span>              pop     eax<span class="comment">//eax清零</span></span><br><span class="line"><span class="number">805119b</span>d <span class="number">7404</span>            je      nt!MmIsAddressValid+<span class="number">0x43</span> (<span class="number">805119</span>c3)  Branch<span class="comment">//PS位为0，即小页就跳转</span></span><br><span class="line"></span><br><span class="line">nt!MmIsAddressValid+<span class="number">0x3f</span>:<span class="comment">//大页，则不用判断PTE</span></span><br><span class="line"><span class="number">805119b</span>f <span class="number">85</span>c0            test    eax,eax</span><br><span class="line"><span class="number">805119</span>c1 <span class="number">7452</span>            je      nt!MmIsAddressValid+<span class="number">0x95</span> (<span class="number">80511</span>a15)  Branch<span class="comment">//百分百跳转到线性地址有效后返回</span></span><br><span class="line"></span><br><span class="line">nt!MmIsAddressValid+<span class="number">0x43</span>:<span class="comment">//PDE PS位为0，为小页则跳转</span></span><br><span class="line"><span class="number">805119</span>c3 c1e909          shr     ecx,<span class="number">9</span><span class="comment">//线性地址右移9位，相当于右移12位，再左移3位(*8)</span></span><br><span class="line"><span class="number">805119</span>c6 <span class="number">81e1</span>f8ff7f00    <span class="keyword">and</span>     ecx,<span class="number">7F</span>FFF8h<span class="comment">//后三位置零，此后ecx为(pdpte+pdi+pti)部分</span></span><br><span class="line"><span class="number">805119</span>cc <span class="number">8b</span>81040000c0    mov     eax,dword ptr [ecx<span class="number">-3F</span>FFFFFCh]<span class="comment">//mov eax,[ecx+0xC0000004],此后eax为PTE高64位</span></span><br><span class="line"><span class="number">805119</span>d2 <span class="number">81e900000040</span>    sub     ecx,<span class="number">40000000</span>h<span class="comment">//mov eax,[ecx+0xC0000000],此后ecx为PTE低64位地址</span></span><br><span class="line"><span class="number">805119</span>d8 <span class="number">8b</span>11            mov     edx,dword ptr [ecx]<span class="comment">//edx为PTE低64位</span></span><br><span class="line"><span class="number">805119</span>da <span class="number">8945f</span>c          mov     dword ptr [ebp<span class="number">-4</span>],eax<span class="comment">//高64位部分存入局部变量1</span></span><br><span class="line"><span class="number">805119</span>dd <span class="number">53</span>              push    ebx<span class="comment">//临时保存ebx，要用</span></span><br><span class="line"><span class="number">805119</span>de <span class="number">8b</span>c2            mov     eax,edx<span class="comment">//eax为PTE低64位</span></span><br><span class="line"><span class="number">805119e0</span> <span class="number">33</span>db            <span class="keyword">xor</span>     ebx,ebx<span class="comment">//ebx清零</span></span><br><span class="line"><span class="number">805119e2</span> <span class="number">83e001</span>          <span class="keyword">and</span>     eax,<span class="number">1</span><span class="comment">//取PTE的P位</span></span><br><span class="line"><span class="number">805119e5</span> <span class="number">0b</span>c3            <span class="keyword">or</span>      eax,ebx<span class="comment">//判断PTE的P位是否为0</span></span><br><span class="line"><span class="number">805119e7</span> <span class="number">5b</span>              pop     ebx<span class="comment">//还原ebx</span></span><br><span class="line"><span class="number">805119e8</span> <span class="number">7427</span>            je      nt!MmIsAddressValid+<span class="number">0x91</span> (<span class="number">80511</span>a11)  Branch<span class="comment">//PTE的P位是零就跳</span></span><br><span class="line"></span><br><span class="line">nt!MmIsAddressValid+<span class="number">0x6a</span>:<span class="comment">//PTE的P位不是零</span></span><br><span class="line"><span class="number">805119</span>ea <span class="number">23</span>d7            <span class="keyword">and</span>     edx,edi<span class="comment">//edx为PTE的PAT位是否为0</span></span><br><span class="line"><span class="number">805119</span>ec <span class="number">6</span>a00            push    <span class="number">0</span></span><br><span class="line"><span class="number">805119</span>ee <span class="number">8955f</span>8          mov     dword ptr [ebp<span class="number">-8</span>],edx<span class="comment">//PTE的PAT位存入局部变量2</span></span><br><span class="line"><span class="number">805119f</span>1 <span class="number">58</span>              pop     eax<span class="comment">//eax清零</span></span><br><span class="line"><span class="number">805119f</span>2 <span class="number">7421</span>            je      nt!MmIsAddressValid+<span class="number">0x95</span> (<span class="number">80511</span>a15)  Branch<span class="comment">//PTE的PAT位为0就跳到函数有效返回部分</span></span><br><span class="line"></span><br><span class="line">nt!MmIsAddressValid+<span class="number">0x74</span>:<span class="comment">//无用</span></span><br><span class="line"><span class="number">805119f</span>4 <span class="number">85</span>c0            test    eax,eax</span><br><span class="line"><span class="number">805119f</span>6 <span class="number">751</span>d            jne     nt!MmIsAddressValid+<span class="number">0x95</span> (<span class="number">80511</span>a15)  Branch<span class="comment">//绝对不跳</span></span><br><span class="line"></span><br><span class="line">nt!MmIsAddressValid+<span class="number">0x78</span>:<span class="comment">//PTE的PAT位为1的处理</span></span><br><span class="line"><span class="number">805119f</span>8 <span class="number">23</span>ce            <span class="keyword">and</span>     ecx,esi<span class="comment">//and PTE低64位地址,3FF8h,可能是取PTE低64位地址的PDI部分</span></span><br><span class="line"><span class="number">805119f</span>a <span class="number">8b</span>89000060c0    mov     ecx,dword ptr [ecx<span class="number">-3F</span>A00000h]<span class="comment">//mov ecx,[ecx+C060 0000h]，？？？</span></span><br><span class="line"><span class="number">80511</span>a00 b881000000      mov     eax,<span class="number">81</span>h</span><br><span class="line"><span class="number">80511</span>a05 <span class="number">23</span>c8            <span class="keyword">and</span>     ecx,eax<span class="comment">//ecx为[(PTE低64位地址&amp;3FF8h)+C060 0000h]&amp;81h</span></span><br><span class="line"><span class="number">80511</span>a07 <span class="number">33</span>d2            <span class="keyword">xor</span>     edx,edx<span class="comment">//edx清零</span></span><br><span class="line"><span class="number">80511</span>a09 <span class="number">3b</span>c8            cmp     ecx,eax</span><br><span class="line"><span class="number">80511</span>a0b <span class="number">7508</span>            jne     nt!MmIsAddressValid+<span class="number">0x95</span> (<span class="number">80511</span>a15)  Branch<span class="comment">//判断[(PTE低64位地址&amp;3FF8h)+C060 0000h]的第7和第0位是否均为1，若有一个不是1，跳转。</span></span><br><span class="line"></span><br><span class="line">nt!MmIsAddressValid+<span class="number">0x8d</span>:<span class="comment">//无用</span></span><br><span class="line"><span class="number">80511</span>a0d <span class="number">85</span>d2            test    edx,edx</span><br><span class="line"><span class="number">80511</span>a0f <span class="number">7504</span>            jne     nt!MmIsAddressValid+<span class="number">0x95</span> (<span class="number">80511</span>a15)  Branch<span class="comment">//绝对不跳</span></span><br><span class="line"></span><br><span class="line">nt!MmIsAddressValid+<span class="number">0x91</span>:<span class="comment">//PDE P位为零的处理</span></span><br><span class="line"><span class="number">80511</span>a11 <span class="number">32</span>c0            <span class="keyword">xor</span>     al,al<span class="comment">//返回0，线性地址无效</span></span><br><span class="line"><span class="number">80511</span>a13 eb02            jmp     nt!MmIsAddressValid+<span class="number">0x97</span> (<span class="number">80511</span>a17)  Branch</span><br><span class="line"></span><br><span class="line">nt!MmIsAddressValid+<span class="number">0x95</span>:</span><br><span class="line"><span class="number">80511</span>a15 b001            mov     al,<span class="number">1</span><span class="comment">//返回1，线性地址有效</span></span><br><span class="line"></span><br><span class="line">nt!MmIsAddressValid+<span class="number">0x97</span>:<span class="comment">//退出函数</span></span><br><span class="line"><span class="number">80511</span>a17 <span class="number">5f</span>              pop     edi</span><br><span class="line"><span class="number">80511</span>a18 <span class="number">5</span>e              pop     esi</span><br><span class="line"><span class="number">80511</span>a19 c9              leave<span class="comment">//？</span></span><br><span class="line"><span class="number">80511</span>a1a c20400          ret     <span class="number">4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="旁路转换缓冲TLB"><a href="#旁路转换缓冲TLB" class="headerlink" title="旁路转换缓冲TLB"></a>旁路转换缓冲TLB</h2><p>每次访问一个物理页，查表的过程特别繁琐，举个例子，2-9-9-12分页模式下读一个四字节实际上会读24个字节，如果<strong>跨页读</strong>可能更多。</p>
<p>CPU内部做了一个表，来记录这些东西，这个表格是<strong>CPU内部的(不在内存中)<strong>，和寄存器一样快，这个表格：</strong>TLB（Translation Lookaside Buffer）</strong>即<strong>旁路转换缓冲</strong>,或称为<strong>页表缓冲</strong>。</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210819194408894.png" alt="image-20210819194408894"></p>
<p>说明：</p>
<ol>
<li>ATTR(属性)：属性是PDPE，PDE，PTE三个属性AND起来的。如果是10-10-12就是PDE and PTE</li>
<li>不同的CPU，这个表的大小不一样</li>
<li>只要CR3变了，TLB立马刷新，一核一套TLB</li>
<li>LRU(统计信息)，记录每个地址的读写情况，确定哪个地址访问更频繁</li>
<li>存的是线性地址的前20位对应物理地址。</li>
</ol>
<p>操作系统的高2G映射基本不变，如果CR3改了，TLB刷新，重建高2G以上内存很浪费。所以PDE和PTE中有个G标志位，<strong>如果G位为1，刷新TLB时将不会刷新PDE&#x2F;PTE的G位为1的页</strong>。当TLB满了，根据统计信息将不常用的地址废弃，最近最常用的保留。</p>
<p><strong>高两G有大量G位为1的PDE</strong>，低2G也有G为1</p>
<h3 id="TLB种类"><a href="#TLB种类" class="headerlink" title="TLB种类"></a>TLB种类</h3><p>TLB在X86体系的CPU里的实际应用最早是从Intel的486PU开始的，在X86体系的CPU里边，<strong>每个核</strong>都设有如下4组TLB：</p>
<ol>
<li>缓存一般页表(4K字节页面)的指令页表缓存(Instruction-TLB)</li>
<li>缓存一般页表(4K字节页面)的数据页表缓存(Data-TLB)</li>
<li>缓存大尺寸页表(2M&#x2F;4M字节页面)的指令页表缓存(Instruction-TLB)</li>
<li>缓存大尺寸页表(2M&#x2F;4M字节页面)的数据页表缓存(Data-TLB)</li>
</ol>
<p>CPU能区分是读一个内存地址还是执行一个内存地址</p>
<p>如果是mov指令访问的内存放入数据页表缓存（读一个内存地址），如果是call&#x2F;jmp等指令访问的内存放入指令页表缓存（执行一个内存地址）。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/MousseLee/p/14404074.html">Shadow Walker，一种隐藏内存的技术。</a></p>
<p>可以用于过代码校验，在指令页表缓存中给目标地址修改为新的物理页。当执行的时候是到物理页执行，可是读的时候，读的还是原来的位置，即未被修改。</p>
<p>这种解决方案适合处理零环（也有点不稳定）而不适合处理三环，因为三环内存老是刷新（非常不稳定）。</p>
<p>三环有更好的方案挂钩子防止对方检测到(无痕hook)</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210819215515748.png" alt="image-20210819215515748"></p>
<h3 id="TLB相关实验"><a href="#TLB相关实验" class="headerlink" title="TLB相关实验"></a>TLB相关实验</h3><h4 id="体验TLB的存在"><a href="#体验TLB的存在" class="headerlink" title="体验TLB的存在"></a>体验TLB的存在</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DWORD result;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __declspec(naked) <span class="built_in">func</span>()</span><br><span class="line">&#123;</span><br><span class="line">	_asm</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//给零地址挂物理页，可能会蓝屏（有可能被用着中）   0x01234867(G=0)  0x01234967(G=1)</span></span><br><span class="line">		mov dword ptr ds:[<span class="number">0xc0000000</span>],<span class="number">0x01234867</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//给零地址赋值</span></span><br><span class="line">		mov dword ptr ds:[<span class="number">0</span>],<span class="number">0x11111111</span></span><br><span class="line">            </span><br><span class="line">		<span class="comment">//将物理页改了，随便改成别的物理页</span></span><br><span class="line">		mov dword ptr ds:[<span class="number">0xc0000000</span>],<span class="number">0x02345867</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//再次读线性地址</span></span><br><span class="line">		mov eax,dword ptr ds:[<span class="number">0</span>]</span><br><span class="line">		mov result,eax</span><br><span class="line">		</span><br><span class="line">		retf</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;func address:%X\n&quot;</span>,func);</span><br><span class="line">	<span class="type">char</span> buff[<span class="number">6</span>]=&#123;<span class="number">0x11</span>,<span class="number">0x11</span>,<span class="number">0x11</span>,<span class="number">0x11</span>,<span class="number">0x48</span>,<span class="number">0</span>&#125;;<span class="comment">//调用门描述符0040EC00`00081000</span></span><br><span class="line">	_asm</span><br><span class="line">	&#123;</span><br><span class="line">		call fword ptr[buff]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;result:%X\n&quot;</span>,result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210820124123585.png" alt="image-20210820124123585"></p>
<p>进程切换后，结果被刷新：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DWORD result;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __declspec(naked) <span class="built_in">func</span>()</span><br><span class="line">&#123;</span><br><span class="line">	_asm</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//给零地址挂物理页，可能会蓝屏   0x01234867(G=0)  0x01234967(G=1)</span></span><br><span class="line">		mov dword ptr ds:[<span class="number">0xc0000000</span>],<span class="number">0x01234867</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//给零地址赋值</span></span><br><span class="line">		mov dword ptr ds:[<span class="number">0</span>],<span class="number">0x11111111</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//进程切换，只要有加载CR3的操作，那么就会清除TLB（除了G=1的内存）</span></span><br><span class="line">		mov eax,cr3</span><br><span class="line">		mov cr3,eax</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将物理页改了，随便改成别的物理页</span></span><br><span class="line">		mov dword ptr ds:[<span class="number">0xc0000000</span>],<span class="number">0x02345867</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//再次读线性地址</span></span><br><span class="line">		mov eax,dword ptr ds:[<span class="number">0</span>]</span><br><span class="line">		mov result,eax</span><br><span class="line">		</span><br><span class="line">		retf</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;func address:%X\n&quot;</span>,func);</span><br><span class="line">	<span class="type">char</span> buff[<span class="number">6</span>]=&#123;<span class="number">0x11</span>,<span class="number">0x11</span>,<span class="number">0x11</span>,<span class="number">0x11</span>,<span class="number">0x48</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	_asm</span><br><span class="line">	&#123;</span><br><span class="line">		call fword ptr[buff]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;result:%X\n&quot;</span>,result);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210820133141085.png" alt="image-20210820133141085"></p>
<p>结果中的0是因为新物理页中的值就是0</p>
<h4 id="全局页的意义"><a href="#全局页的意义" class="headerlink" title="全局页的意义"></a>全局页的意义</h4><p>上面的代码修改为全局页：</p>
<p> 把上述代码中的mov dword ptr ds:[0xc0000000],0x01234867从0x01234867修改为0x01234967</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210820134644415.png" alt="image-20210820134644415"></p>
<p>因此可知，全局页不会随进程切换清空TLB</p>
<h4 id="INVLPG指令的意义"><a href="#INVLPG指令的意义" class="headerlink" title="INVLPG指令的意义"></a>INVLPG指令的意义</h4><p>INVLPG dword ptr ds:[0]&#x2F;&#x2F;手动清空0线性地址对应在TLB的一条缓存。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DWORD result;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __declspec(naked) <span class="built_in">func</span>()</span><br><span class="line">&#123;</span><br><span class="line">	_asm</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//给零地址挂物理页，可能会蓝屏   0x01234867(G=0)  0x01234967(G=1)</span></span><br><span class="line">		mov dword ptr ds:[<span class="number">0xc0000000</span>],<span class="number">0x01234967</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//给零地址赋值</span></span><br><span class="line">		mov dword ptr ds:[<span class="number">0</span>],<span class="number">0x11111111</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//进程切换</span></span><br><span class="line">		mov eax,cr3</span><br><span class="line">		mov cr3,eax</span><br><span class="line"></span><br><span class="line">		INVLPG dword ptr ds:[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将物理页改了，随便改成别的物理页</span></span><br><span class="line">		mov dword ptr ds:[<span class="number">0xc0000000</span>],<span class="number">0x02345867</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//再次读线性地址</span></span><br><span class="line">		mov eax,dword ptr ds:[<span class="number">0</span>]</span><br><span class="line">		mov result,eax</span><br><span class="line">		</span><br><span class="line">		retf</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;func address:%X\n&quot;</span>,func);</span><br><span class="line">	<span class="type">char</span> buff[<span class="number">6</span>]=&#123;<span class="number">0x11</span>,<span class="number">0x11</span>,<span class="number">0x11</span>,<span class="number">0x11</span>,<span class="number">0x48</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	_asm</span><br><span class="line">	&#123;</span><br><span class="line">		call fword ptr[buff]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;result:%X\n&quot;</span>,result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210820135304899.png" alt="image-20210820135304899"></p>
<p>手动清空缓存成功，读出新物理页的值。</p>
<h1 id="中断与异常"><a href="#中断与异常" class="headerlink" title="中断与异常"></a>中断与异常</h1><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p><strong>什么是中断？</strong></p>
<p><strong>中断的本质目的就是改变CPU执行的路线</strong></p>
<ol>
<li><p>中断通常是由CPU外部的输入输出设备(硬件)所触发的，供外部设备通知CPU“有事情需要处理”，因此又叫中断请求（Interrupt Request）</p>
</li>
<li><p>中断请求的目的是希望CPU暂时停止执行当前正在执行的程序，转而去执行中断请求所对应的中断处理例程(中断处理程序在哪由IDT表决定)</p>
</li>
<li><p>80x86有两条中断请求线</p>
<p>​		非屏蔽中断线，称为NMI(NonMaskable Interrupt)</p>
<p>​		可屏蔽中断线，称为INTR(Interrupt Require)</p>
</li>
</ol>
<p><strong>非可屏蔽中断如何处理</strong></p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210820165939064.png" alt="image-20210820165939064"></p>
<p>当非可屏蔽中断产生时，CPU在执行完当前指令后会从里面进入中断处理程序</p>
<p>非可屏蔽中断不受EFLAG寄存器中IF位的影响，一旦发生，CPU必须 处理</p>
<p>非可屏蔽中断处理程序位于IDT表中的2号位置</p>
<p><strong>可屏蔽中断</strong></p>
<p>在硬件级，可屏蔽中断是由一块专门的芯片来管理的，通常称为<strong>中断控制器</strong>。它负责分配中断资源和管理各个中断源发出的中断请求。为了便于标识各个中断请求，中断管理器通常用<strong>IRQ（Interrupt Request）</strong>后面加上数字来表示不同的中断。</p>
<p>比如：在Windows中，时钟中断（即下图的系统计时器）的IRQ编号为0，也就是：IRQ0</p>
<p>win10查看IRQ：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210820171447027.png" alt="image-20210820171447027"><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210820171507433.png" alt="image-20210820171507433"></p>
<p>大多数操作系统时钟在10<del>100ms之间，Windows系统为10</del>20MS。</p>
<p>时钟中断只是操作系统进行线程切换的一个机会。哪怕是一个无限循环的程序，一个单核系统，CPU依然有机会线程切换。</p>
<p><strong>可屏蔽中断如何处理</strong></p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210820172028590.png" alt="image-20210820172028590"></p>
<ol>
<li><p>如果自己的程序执行时，不希望CPU去处理这些中断</p>
<p>​		用<strong>CLI</strong>指令<strong>清空</strong>EFLAG寄存器中的IF位</p>
<p>​		用<strong>STI</strong>指令<strong>设置</strong>EFLAG寄存器中的IF位</p>
</li>
<li><p>硬件中断与IDT表中的对应关系并非固定不变的，参见<strong>APIC（高级可编程中断控制器）</strong></p>
</li>
</ol>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>异常通常是CPU在执行指令时检测到的某些错误，比如除0，访问无效页面等。</p>
<p><strong>中断与异常的区别：</strong></p>
<ol>
<li><strong>中断</strong>来自于外部设备，是中断源(比如键盘)发起的，CPU是被动的。</li>
<li><strong>异常</strong>来自于CPU本身，是CPU主动产生的(cpu在执行的时候发现错误了)。</li>
<li>INT N虽然被称为“软件中断”，但其本质是异常。<strong>EFLAG的IF位对INT N无效</strong>。</li>
</ol>
<p><strong>异常处理</strong></p>
<p>无论是<code>由硬件设备触发的中断请求</code>还是<code>由CPU产生的异常</code>，<strong>处理程序都在IDT表</strong>。</p>
<p>常见的异常处理程序如下：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210820173459803.png" alt="image-20210820173459803"></p>
<p><strong>举例缺页异常</strong></p>
<p>缺页异常的产生，比如：</p>
<ol>
<li>当PDE&#x2F;PTE的P&#x3D;0时</li>
<li>当PDE&#x2F;PTE的属性为只读，但程序试图写入的时候</li>
</ol>
<p>一旦发生缺页异常，CPU会执行IDT表中的0xE号中断处理程序，由操作系统来接管。</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210820173746701.png" alt="image-20210820173746701"></p>
<h1 id="控制寄存器CR"><a href="#控制寄存器CR" class="headerlink" title="控制寄存器CR"></a>控制寄存器CR</h1><p>控制寄存器用于控制和确定CPU的操作模式</p>
<p>共5个 <strong>CR0,CR1,CR2,CR3,CR4</strong></p>
<p>CR1-保留，CR3-页目录表基址（不同分页模式不一样）</p>
<h2 id="CR0寄存器"><a href="#CR0寄存器" class="headerlink" title="CR0寄存器"></a>CR0寄存器</h2><p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210820174741733.png" alt="image-20210820174741733"></p>
<table>
<thead>
<tr>
<th>位</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>PE</strong></td>
<td>CR0的位是启用保护标志位(Protection Enable).。PE&#x3D;1保护模式    PE&#x3D;0实地址模式，该标志仅开启段级保护，而并没有启用分页机制。若要启用分页机制，PE和PG标志位都要置位</td>
</tr>
<tr>
<td><strong>PG</strong></td>
<td>设置该位时即开启了分页机制。在开启这个标志位之前必须已经或同时开启PE标志</td>
</tr>
<tr>
<td><strong>WP</strong></td>
<td>对于Intel 80x86或以上的CPU，CR0的位16是写保护(Write Protect)标志，<strong>当设置该标志时，处理器会禁止超级用户程序(例如特权级0的程序)向用户级只读页面执行写操作</strong>。只要是写别人的内存，不管是干嘛的，首先把这个位设置0，写完了再改回来1。</td>
</tr>
<tr>
<td><strong>AM</strong></td>
<td>管理三环下的字节对齐检查。设置为1的时候，用户态当EFLAGS寄存器中的AC标志为1时候是按照段描述的D\B位字节对齐检查的。</td>
</tr>
<tr>
<td><strong>CD</strong></td>
<td>禁止写Cache总开关，相当于PDE,PTE中的PWT和PCD位的总控</td>
</tr>
</tbody></table>
<ol>
<li>PG&#x3D;0且PE&#x3D;0时，处理器工作在实地址模式</li>
<li>PG&#x3D;0且PE&#x3D;1时，处理器工作在没有开启分页机制的保护模式下(目前为止没有任何一个操作系统工作在这个模式)</li>
<li>PG&#x3D;1且PE&#x3D;0时，这种情况不存在，在PE没有开启的情况下，无法开启PG</li>
<li>PG&#x3D;1且PE&#x3D;1时，处理器工作在开启了分页机制的保护模式下</li>
</ol>
<p><strong>当CPL&lt;3的时候</strong></p>
<ul>
<li>如果WP&#x3D;0	可以读写任意用户级物理页，只要线性地址有效</li>
<li>如果WP&#x3D;1	可以读取任意用户即物理页，但对于只读的物理页，则不可以写</li>
</ul>
<h2 id="CR2寄存器"><a href="#CR2寄存器" class="headerlink" title="CR2寄存器"></a>CR2寄存器</h2><p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210820175813882.png" alt="image-20210820175813882"></p>
<p>当CPU访问某个无效页面时，会产生缺页异常，此时，CPU会将引起异常的线性地址存放在CR2中。</p>
<p>int 0xE里面有这个函数（函数非常长）的处理流程。</p>
<h2 id="CR4寄存器"><a href="#CR4寄存器" class="headerlink" title="CR4寄存器"></a>CR4寄存器</h2><p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210820180052860.png" alt="image-20210820180052860"></p>
<table>
<thead>
<tr>
<th>位</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>PAE</td>
<td>PAE&#x3D;1是2-9-9-12分页  PAE&#x3D;0是10-10-12分页</td>
</tr>
<tr>
<td>PSE</td>
<td>大页的总开关，PDE中的PS位的总开关，只有当PSE为1的时候，PDE中的PS位才有意义。仅PSE和PS位都是1的时候，该PDE指向的物理页才是大页</td>
</tr>
<tr>
<td>PGE</td>
<td>全局页总开关，PTE和PDE的G位总开关。PGE&#x3D;1时，G位才有效。把PGE设为0，进程切换就会刷新全部TLB</td>
</tr>
</tbody></table>
<hr>
<p><strong>控制寄存器更多的细节参考白皮书第三卷</strong></p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210820180519008.png" alt="image-20210820180519008"></p>
<h1 id="PDE-PTE中的PWT和PCD位"><a href="#PDE-PTE中的PWT和PCD位" class="headerlink" title="PDE,PTE中的PWT和PCD位"></a>PDE,PTE中的PWT和PCD位</h1><p><strong>cpu缓存Cache</strong></p>
<ol>
<li>CPU缓存是位于CPU与物理内存之间的临时存储器，它的容量比内存小的多，但是交换速度却比内存要快得多。</li>
<li>CPU缓存可以做的很大，有几K，几十K，几百K，甚至上M的也有。</li>
</ol>
<p>CPU缓存与TLB存储的东西的区别</p>
<ul>
<li>TLB：线性地址《—–》物理地址</li>
<li>CPU缓存：物理地址《—–》内容</li>
</ul>
<p>关于Cache的更多细节可以了解因特尔白皮书第三卷</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210820181214528.png" alt="image-20210820181214528"></p>
<p><strong>PWT：Page Write Through</strong></p>
<p>PWT&#x3D;1时。写Cache的时候也要讲数据写入内存中</p>
<p>PWT&#x3D;1时。写Cache的时候只写入Cache</p>
<p><strong>PCS：Page Cache Disable</strong></p>
<p>PCD&#x3D;1时，禁止某个页的写入Cache，直接写内存。</p>
<p>比如：做页表用的页，已经存储在TLB中了，可能不需要再缓存了，因此他们的PCS都是置1的。</p>
<h1 id="保护模式阶段总结"><a href="#保护模式阶段总结" class="headerlink" title="保护模式阶段总结"></a>保护模式阶段总结</h1><p>参见因特尔白皮书第三卷的第3章到第11章</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210820181901011.png" alt="image-20210820181901011"></p>
<p><strong>保护模式实验(两道题)：</strong></p>
<h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 给定一个线性地址，和长度，读取内容；</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ReadMemory</span><span class="params">(OUT BYTE* buffer,IN DWORD dwAddr,IN DWORD dwLeght)</span></span></span><br><span class="line"><span class="function">要求：</span></span><br><span class="line"><span class="function">1) 可以自己指定分页方式。</span></span><br><span class="line"><span class="function">2) 页不存在，要提示，不能报错。</span></span><br><span class="line"><span class="function">3) 可以正确读取数据。</span></span><br></pre></td></tr></table></figure>

<p>残缺版，并未实现所有功能：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __declspec(naked) <span class="built_in">callGate</span>()</span><br><span class="line">&#123;</span><br><span class="line">	_asm</span><br><span class="line">	&#123;</span><br><span class="line">		pushfd;</span><br><span class="line">		pushad;</span><br><span class="line">		mov esi,[esp+<span class="number">0x24</span>+<span class="number">0x8</span>+<span class="number">0x8</span>];<span class="comment">//dwLeght</span></span><br><span class="line">        mov eax,[esp+<span class="number">0x24</span>+<span class="number">0x8</span>+<span class="number">0x4</span>];<span class="comment">//dwAddr</span></span><br><span class="line">        mov ecx,[esp+<span class="number">0x24</span>+<span class="number">0x8</span>];<span class="comment">//buffer</span></span><br><span class="line">		mov edx,eax;</span><br><span class="line">		<span class="comment">//取gdi</span></span><br><span class="line">		shr edx,<span class="number">21</span>;</span><br><span class="line">		<span class="keyword">and</span> edx,<span class="number">0x1FF</span>;</span><br><span class="line">		shl edx,<span class="number">3</span>;<span class="comment">//*8</span></span><br><span class="line">		mov edx,dword ptr ds:[edx+<span class="number">0xc0600000</span>];</span><br><span class="line">		test edx,<span class="number">1</span>;</span><br><span class="line">		jz __PERROR;</span><br><span class="line">		test dl,dl;</span><br><span class="line">		<span class="comment">//js __bigPage;</span></span><br><span class="line">		<span class="comment">//取gti</span></span><br><span class="line">		mov edx,eax</span><br><span class="line">		shr edx,<span class="number">12</span>;</span><br><span class="line">		<span class="keyword">and</span> edx,<span class="number">0xFFFFF</span>;</span><br><span class="line">		shl edx,<span class="number">3</span>;<span class="comment">//*8</span></span><br><span class="line">		mov edx,dword ptr ds:[edx+<span class="number">0xc0000000</span>];</span><br><span class="line">		test edx,<span class="number">1</span>;</span><br><span class="line">		jz __PERROR;</span><br><span class="line">		<span class="comment">//读数据</span></span><br><span class="line">		mov result,<span class="number">1</span>;</span><br><span class="line">__for:</span><br><span class="line">		mov dl,byte ptr ds:[eax];</span><br><span class="line">		inc eax;</span><br><span class="line">		mov byte ptr ds:[ecx],dl;</span><br><span class="line">		inc ecx;</span><br><span class="line">		dec esi;</span><br><span class="line">		cmp esi,<span class="number">0</span>;</span><br><span class="line">		jnz __for;</span><br><span class="line">		jmp __ret;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//__bigPage:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">__PERROR:</span><br><span class="line">		mov result,<span class="number">0</span></span><br><span class="line">__ret:</span><br><span class="line">		popad;</span><br><span class="line">		popfd;</span><br><span class="line">		retf <span class="number">0xC</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ReadMemory</span><span class="params">(BYTE* buffer,DWORD dwAddr,DWORD dwLeght)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//此处需要对线性地址做是否跨页的判断,决定下面校验几次.</span></span><br><span class="line">	<span class="type">char</span> buff[<span class="number">6</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x48</span>,<span class="number">0</span>&#125;;<span class="comment">//0040EC03`0008100A</span></span><br><span class="line">	_asm</span><br><span class="line">	&#123;</span><br><span class="line">		push dwLeght</span><br><span class="line">		push dwAddr</span><br><span class="line">		push buffer</span><br><span class="line">		call fword ptr[buff];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result;<span class="comment">// 返回值取决于全局变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//构造测试用例</span></span><br><span class="line">	<span class="type">int</span> x=(<span class="type">int</span>)<span class="number">0x12345678</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%X\n&quot;</span>,callGate);</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">	BYTE a[<span class="number">4</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="type">int</span> iRet=<span class="built_in">ReadMemory</span>(a,(DWORD)&amp;x,<span class="number">4</span>);</span><br><span class="line">	<span class="keyword">if</span>(!iRet)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;内存无效\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;用函数读到:%X\n&quot;</span>,*(DWORD*)a);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210824161101189.png" alt="image-20210824161101189"></p>
<p>改成读取0x12345678地址：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210824161159229.png" alt="image-20210824161159229"></p>
<h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.</span> 申请长度为<span class="number">100</span>的DWORD的数组,且每项用该项的地址初始化；</span><br><span class="line">把这个数组所在的物理页挂到<span class="number">0x1000</span>的地址上;</span><br><span class="line">定义一个指针，指向<span class="number">0x1000</span>这个页里的数组所在的地址,用<span class="number">0x1000</span>这个页的线性地址打印出这数组的值；</span><br><span class="line"></span><br><span class="line">要求：</span><br><span class="line">数组所在的物理页，是同一个页；</span><br></pre></td></tr></table></figure>

<p>略</p>
<h1 id="补充知识点"><a href="#补充知识点" class="headerlink" title="补充知识点"></a>补充知识点</h1><h2 id="CPU信息查询"><a href="#CPU信息查询" class="headerlink" title="CPU信息查询"></a>CPU信息查询</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov eax,80000008;//通过eax设置cpuid的参数</span><br><span class="line">cpuid;</span><br><span class="line">;//此后eax获取到的值为0x00003028</span><br><span class="line">;//解读：0x30为线性地址位数，0x28为物理地址位数。</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210822171000712.png" alt="image-20210822171000712"></p>
<p>支持很多cpu信息查询，包括是否支持VT也通过该指令查找</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax,1;</span><br><span class="line">cpuid;</span><br><span class="line">;//此后ecx的第五位为1的话表示CPU支持VT</span><br></pre></td></tr></table></figure>



<h2 id="MDL？物理页地址映射？"><a href="#MDL？物理页地址映射？" class="headerlink" title="MDL？物理页地址映射？"></a>MDL？物理页地址映射？</h2>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/blog/tags/%E5%86%85%E6%A0%B8%E7%9B%B8%E5%85%B3/" rel="tag"># 内核相关</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/blog/2022/05/05/%E4%BA%8B%E4%BB%B6%E7%AD%89%E5%BE%85/" rel="prev" title="事件等待">
      <i class="fa fa-chevron-left"></i> 事件等待
    </a></div>
      <div class="post-nav-item">
    <a href="/blog/2022/05/05/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/" rel="next" title="系统调用">
      系统调用 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%A6%E4%B9%A0%E5%89%8D%E7%9A%84%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="nav-number">1.</span> <span class="nav-text">学习前的环境配置</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8C%E6%9C%BA%E8%B0%83%E8%AF%95%E9%85%8D%E7%BD%AE"><span class="nav-number">1.1.</span> <span class="nav-text">双机调试配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%80%E5%A7%8B%E5%8F%8C%E6%9C%BA%E8%B0%83%E8%AF%95"><span class="nav-number">1.2.</span> <span class="nav-text">开始双机调试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WinDbg%E7%9A%84%E9%80%80%E5%87%BA"><span class="nav-number">1.3.</span> <span class="nav-text">WinDbg的退出</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%93%E6%AE%B5"><span class="nav-number">2.</span> <span class="nav-text">保护模式–段</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84"><span class="nav-number">2.1.</span> <span class="nav-text">段寄存器结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">2.1.1.</span> <span class="nav-text">段寄存器的结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E8%AF%BB%E5%86%99"><span class="nav-number">2.1.2.</span> <span class="nav-text">段寄存器的读写</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">读段寄存器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%99%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">写段寄存器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%E5%B1%9E%E6%80%A7%E6%8E%A2%E6%B5%8B"><span class="nav-number">2.1.2.3.</span> <span class="nav-text">段寄存器属性探测</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E6%AE%B5%E9%80%89%E6%8B%A9%E5%AD%90"><span class="nav-number">2.1.3.</span> <span class="nav-text">段描述符与段选择子</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="nav-number">2.1.3.1.</span> <span class="nav-text">段描述符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AE%B5%E9%80%89%E6%8B%A9%E5%AD%90"><span class="nav-number">2.1.3.2.</span> <span class="nav-text">段选择子</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%88%B0%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">2.1.3.2.1.</span> <span class="nav-text">加载段描述符到段寄存器</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="nav-number">2.1.3.3.</span> <span class="nav-text">段描述符的属性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#P%E4%BD%8D%E5%92%8CG%E4%BD%8D"><span class="nav-number">2.1.3.3.1.</span> <span class="nav-text">P位和G位</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#P%E4%BD%8D"><span class="nav-number">2.1.3.3.1.1.</span> <span class="nav-text">P位</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#G%E4%BD%8D"><span class="nav-number">2.1.3.3.1.2.</span> <span class="nav-text">G位</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#S%E4%BD%8D%E5%92%8CTYPE%E5%9F%9F"><span class="nav-number">2.1.3.3.2.</span> <span class="nav-text">S位和TYPE域</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#S%E4%BD%8D"><span class="nav-number">2.1.3.3.2.1.</span> <span class="nav-text">S位</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#TYPE%E5%9F%9F"><span class="nav-number">2.1.3.3.2.2.</span> <span class="nav-text">TYPE域</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#D-x2F-B%E4%BD%8D"><span class="nav-number">2.1.3.3.3.</span> <span class="nav-text">D&#x2F;B位</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AVL%E5%B1%9E%E6%80%A7"><span class="nav-number">2.1.3.3.4.</span> <span class="nav-text">AVL属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AE%B5%E6%9D%83%E9%99%90%E6%A3%80%E6%9F%A5%EF%BC%88CPL%EF%BC%8CRPL-DPL%EF%BC%89"><span class="nav-number">2.1.3.3.5.</span> <span class="nav-text">段权限检查（CPL，RPL,DPL）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E7%A8%8B%E5%BA%8F%E5%A4%84%E4%BA%8E%E5%87%A0%E7%8E%AF"><span class="nav-number">2.1.3.3.5.1.</span> <span class="nav-text">如何查看程序处于几环</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%AE%B5%E7%9A%84%E6%9D%83%E9%99%90%E6%A3%80%E6%9F%A5"><span class="nav-number">2.1.3.3.5.2.</span> <span class="nav-text">数据段的权限检查</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AF%8D%E6%B1%87%E6%80%BB%E7%BB%93"><span class="nav-number">2.1.3.3.5.3.</span> <span class="nav-text">词汇总结</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E8%B7%A8%E6%AE%B5"><span class="nav-number">2.2.</span> <span class="nav-text">代码跨段</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E9%97%B4%E7%9A%84%E8%B7%B3%E8%BD%AC-%E6%AE%B5%E9%97%B4%E8%B7%B3%E8%BD%AC%E9%9D%9E%E8%B0%83%E7%94%A8%E9%97%A8%E4%B9%8B%E7%B1%BB%E7%9A%84"><span class="nav-number">2.2.1.</span> <span class="nav-text">代码间的跳转(段间跳转	非调用门之类的)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">执行流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E3%80%90%E6%80%BB%E7%BB%93%E3%80%91"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">【总结】</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E3%80%90%E6%9C%80%E7%BB%88%E6%80%BB%E7%BB%93%E3%80%91"><span class="nav-number">2.2.1.3.</span> <span class="nav-text">【最终总结】</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C"><span class="nav-number">2.2.1.4.</span> <span class="nav-text">实验</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%95%BF%E8%B0%83%E7%94%A8%E4%B8%8E%E7%9F%AD%E8%B0%83%E7%94%A8"><span class="nav-number">2.3.</span> <span class="nav-text">长调用与短调用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9F%AD%E8%B0%83%E7%94%A8"><span class="nav-number">2.3.1.</span> <span class="nav-text">短调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%95%BF%E8%B0%83%E7%94%A8-%E8%B7%A8%E6%AE%B5%E4%B8%8D%E6%8F%90%E6%9D%83"><span class="nav-number">2.3.2.</span> <span class="nav-text">长调用(跨段不提权)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%95%BF%E8%B0%83%E7%94%A8-%E8%B7%A8%E6%AE%B5%E5%B9%B6%E6%8F%90%E6%9D%83"><span class="nav-number">2.3.3.</span> <span class="nav-text">长调用(跨段并提权)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%80%90%E6%80%BB%E7%BB%93%E3%80%91-1"><span class="nav-number">2.3.4.</span> <span class="nav-text">【总结】</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E9%97%A8"><span class="nav-number">2.4.</span> <span class="nav-text">调用门</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E9%97%A8-%E6%97%A0%E5%8F%82"><span class="nav-number">2.4.1.</span> <span class="nav-text">调用门(无参)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%A8%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">2.4.1.1.</span> <span class="nav-text">门描述符的结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E9%97%A8%E6%8C%87%E4%BB%A4%E6%B5%81%E7%A8%8B"><span class="nav-number">2.4.1.2.</span> <span class="nav-text">调用门指令流程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E3%80%90%E9%87%8D%E7%82%B9%E3%80%91%E8%B0%83%E7%94%A8%E9%97%A8%E6%9D%83%E9%99%90%E7%9B%B8%E5%85%B3"><span class="nav-number">2.4.1.2.1.</span> <span class="nav-text">【重点】调用门权限相关</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C-1"><span class="nav-number">2.4.1.3.</span> <span class="nav-text">实验</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E9%97%A8-%E6%9C%89%E5%8F%82"><span class="nav-number">2.4.2.</span> <span class="nav-text">调用门(有参)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C-2"><span class="nav-number">2.4.2.1.</span> <span class="nav-text">实验</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E3%80%90%E6%80%BB%E7%BB%93%E3%80%91-2"><span class="nav-number">2.4.2.2.</span> <span class="nav-text">【总结】</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E9%97%A8"><span class="nav-number">2.5.</span> <span class="nav-text">中断门</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E6%8C%87%E4%BB%A4"><span class="nav-number">2.5.1.</span> <span class="nav-text">中断指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E9%97%A8%E7%9A%84%E5%A0%86%E6%A0%88%E5%92%8C%E8%BF%94%E5%9B%9E"><span class="nav-number">2.5.2.</span> <span class="nav-text">中断门的堆栈和返回</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IDT"><span class="nav-number">2.5.3.</span> <span class="nav-text">IDT</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#IDT%E8%A1%A8%E7%9A%84%E6%9E%84%E6%88%90"><span class="nav-number">2.5.3.1.</span> <span class="nav-text">IDT表的构成</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E9%97%A8%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="nav-number">2.5.4.</span> <span class="nav-text">中断门描述符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E9%97%A8%E6%8F%90%E6%9D%83%E5%AE%9E%E9%AA%8C"><span class="nav-number">2.5.4.1.</span> <span class="nav-text">中断门提权实验</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E9%97%A8%E4%B8%8E%E4%B8%AD%E6%96%AD%E9%97%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.5.4.2.</span> <span class="nav-text">调用门与中断门的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E3%80%90%E9%87%8D%E7%82%B9%E7%90%86%E8%A7%A3%E3%80%91%E5%90%84%E7%A7%8D%E8%BF%94%E5%9B%9E%E5%8A%A0%E6%B7%B1%E7%90%86%E8%A7%A3"><span class="nav-number">2.5.4.3.</span> <span class="nav-text">【重点理解】各种返回加深理解</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E3%80%90%E5%AE%9E%E9%AA%8C%E3%80%91%E5%9C%A8%E8%B0%83%E7%94%A8%E9%97%A8%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%BD%BF%E7%94%A8IRETD%E8%BF%94%E5%9B%9E%EF%BC%8C%E5%9C%A8%E4%B8%AD%E6%96%AD%E9%97%A8%E4%B8%AD%E5%AE%9E%E7%8E%B0%E7%94%A8RETF%E8%BF%94%E5%9B%9E"><span class="nav-number">2.5.4.3.1.</span> <span class="nav-text">【实验】在调用门中实现使用IRETD返回，在中断门中实现用RETF返回</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E9%97%A8%E7%94%A8RETF%E8%BF%94%E5%9B%9E"><span class="nav-number">2.5.4.3.1.1.</span> <span class="nav-text">中断门用RETF返回</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E9%97%A8%E7%94%A8iretd-%E8%BF%94%E5%9B%9E"><span class="nav-number">2.5.4.3.1.2.</span> <span class="nav-text">调用门用iretd 返回</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%B7%E9%98%B1%E9%97%A8"><span class="nav-number">2.6.</span> <span class="nav-text">陷阱门</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E6%AE%B5TSS-%E9%9A%BE%E7%82%B9%E9%9D%9E%E9%87%8D%E7%82%B9"><span class="nav-number">2.7.</span> <span class="nav-text">任务段TSS(难点非重点)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TSS%E5%92%8CTR%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">2.7.1.</span> <span class="nav-text">TSS和TR寄存器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TSS%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">2.7.1.1.</span> <span class="nav-text">TSS的作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CPU%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0TSS%E7%9A%84"><span class="nav-number">2.7.1.2.</span> <span class="nav-text">CPU是如何找到TSS的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TSS%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="nav-number">2.7.1.3.</span> <span class="nav-text">TSS段描述符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TR%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E8%AF%BB%E5%86%99"><span class="nav-number">2.7.1.4.</span> <span class="nav-text">TR寄存器的读写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9TR%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">2.7.1.5.</span> <span class="nav-text">修改TR寄存器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CALL-FAR%E6%88%96%E8%80%85JMP-FAR%E4%B8%80%E4%B8%AA%E4%BB%BB%E5%8A%A1%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%9A%84%E4%B8%8D%E5%90%8C%E7%82%B9%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="nav-number">2.7.1.6.</span> <span class="nav-text">CALL FAR或者JMP FAR一个任务段描述符的不同点（重点）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TSS%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%AE%9E%E9%AA%8C"><span class="nav-number">2.7.1.7.</span> <span class="nav-text">TSS段描述符实验</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#CALL%E5%AE%9E%E9%AA%8C%E8%BF%94%E5%9B%9E"><span class="nav-number">2.7.1.7.1.</span> <span class="nav-text">CALL实验返回</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#JMP%E5%AE%9E%E9%AA%8C%E8%BF%94%E5%9B%9E"><span class="nav-number">2.7.1.7.2.</span> <span class="nav-text">JMP实验返回</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#JMP%E5%AE%9E%E9%AA%8C%E4%B8%ADtest%E5%A4%B4%E6%B7%BB%E5%8A%A0int%E8%A7%82%E5%AF%9F%E5%AE%9E%E9%AA%8C"><span class="nav-number">2.7.1.7.2.1.</span> <span class="nav-text">JMP实验中test头添加int观察实验</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E9%97%A8"><span class="nav-number">2.8.</span> <span class="nav-text">任务门</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E9%97%A8%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="nav-number">2.8.1.</span> <span class="nav-text">任务门描述符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E9%97%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-number">2.8.2.</span> <span class="nav-text">任务门的执行过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0%EF%BC%9A%E5%AE%9E%E7%8E%B0%E4%BB%BB%E5%8A%A1%E9%97%A8%E8%BF%9B1%E7%8E%AF%E3%80%82"><span class="nav-number">2.8.3.</span> <span class="nav-text">课后练习：实现任务门进1环。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%86%E5%90%91int-8%E5%AE%9E%E9%AA%8C"><span class="nav-number">2.8.4.</span> <span class="nav-text">逆向int 8实验</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LDT%E7%9B%B8%E5%85%B3"><span class="nav-number">2.9.</span> <span class="nav-text">LDT相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%B7%B1%E6%9E%84%E5%BB%BALDT%E8%A1%A8%E5%92%8C%E5%85%B6%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%AE%9E%E9%AA%8C"><span class="nav-number">2.9.1.</span> <span class="nav-text">自己构建LDT表和其中的数据段描述符实验</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%93%E9%A1%B5"><span class="nav-number">3.</span> <span class="nav-text">保护模式–页</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#10-10-12%E5%88%86%E9%A1%B5"><span class="nav-number">3.1.</span> <span class="nav-text">10-10-12分页</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#PDE%E4%B8%8EPTE"><span class="nav-number">3.1.1.</span> <span class="nav-text">PDE与PTE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E7%9B%AE%E5%BD%95%E8%A1%A8PDT%E5%9F%BA%E5%9D%80-%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80"><span class="nav-number">3.1.2.</span> <span class="nav-text">页目录表PDT基址(线性地址)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E8%A1%A8PTT%E5%9F%BA%E5%9D%80-%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80"><span class="nav-number">3.1.3.</span> <span class="nav-text">页表PTT基址(线性地址)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%8F%E5%AE%9E%E9%AA%8C"><span class="nav-number">3.1.3.1.</span> <span class="nav-text">小实验</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%8C%E6%8F%A1%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E6%89%80%E6%9C%89%E7%9A%84%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E8%AF%BB%E5%86%99%E6%9D%83%E9%99%90%E3%80%90%E5%85%AC%E5%BC%8F%E6%80%BB%E7%BB%93%E3%80%91"><span class="nav-number">3.1.3.2.</span> <span class="nav-text">掌握一个进程所有的物理内存读写权限【公式总结】</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C-3"><span class="nav-number">3.1.3.2.1.</span> <span class="nav-text">实验</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-10-12%E5%86%85%E6%A0%B8%E9%80%86%E5%90%91%E5%88%86%E6%9E%90MmIsAddressValid%E5%87%BD%E6%95%B0"><span class="nav-number">3.1.3.3.</span> <span class="nav-text">10-10-12内核逆向分析MmIsAddressValid函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%A8IDA"><span class="nav-number">3.1.3.3.1.</span> <span class="nav-text">用IDA</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%A8windbg"><span class="nav-number">3.1.3.3.2.</span> <span class="nav-text">用windbg</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-9-9-12%E5%88%86%E9%A1%B5"><span class="nav-number">3.2.</span> <span class="nav-text">2-9-9-12分页</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E7%9B%AE%E5%BD%95%E6%8C%87%E9%92%88%E8%A1%A8%E9%A1%B9Page-Dircetory-Point-Table-Entry"><span class="nav-number">3.2.1.</span> <span class="nav-text">页目录指针表项Page-Dircetory-Point-Table Entry</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PDE%E7%BB%93%E6%9E%84"><span class="nav-number">3.2.2.</span> <span class="nav-text">PDE结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PTE%E7%BB%93%E6%9E%84"><span class="nav-number">3.2.3.</span> <span class="nav-text">PTE结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#X-x2F-D%E6%A0%87%E5%BF%97%E4%BD%8D"><span class="nav-number">3.2.4.</span> <span class="nav-text">X&#x2F;D标志位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-9-9-12%E5%86%85%E6%A0%B8%E9%80%86%E5%90%91%E5%88%86%E6%9E%90MmIsAddressValid%E5%87%BD%E6%95%B0"><span class="nav-number">3.2.5.</span> <span class="nav-text">2-9-9-12内核逆向分析MmIsAddressValid函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%81%E8%B7%AF%E8%BD%AC%E6%8D%A2%E7%BC%93%E5%86%B2TLB"><span class="nav-number">3.3.</span> <span class="nav-text">旁路转换缓冲TLB</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TLB%E7%A7%8D%E7%B1%BB"><span class="nav-number">3.3.1.</span> <span class="nav-text">TLB种类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TLB%E7%9B%B8%E5%85%B3%E5%AE%9E%E9%AA%8C"><span class="nav-number">3.3.2.</span> <span class="nav-text">TLB相关实验</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%93%E9%AA%8CTLB%E7%9A%84%E5%AD%98%E5%9C%A8"><span class="nav-number">3.3.2.1.</span> <span class="nav-text">体验TLB的存在</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E9%A1%B5%E7%9A%84%E6%84%8F%E4%B9%89"><span class="nav-number">3.3.2.2.</span> <span class="nav-text">全局页的意义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#INVLPG%E6%8C%87%E4%BB%A4%E7%9A%84%E6%84%8F%E4%B9%89"><span class="nav-number">3.3.2.3.</span> <span class="nav-text">INVLPG指令的意义</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%BC%82%E5%B8%B8"><span class="nav-number">4.</span> <span class="nav-text">中断与异常</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD"><span class="nav-number">4.1.</span> <span class="nav-text">中断</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8"><span class="nav-number">4.2.</span> <span class="nav-text">异常</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8CR"><span class="nav-number">5.</span> <span class="nav-text">控制寄存器CR</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#CR0%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">5.1.</span> <span class="nav-text">CR0寄存器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CR2%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">5.2.</span> <span class="nav-text">CR2寄存器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CR4%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">5.3.</span> <span class="nav-text">CR4寄存器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#PDE-PTE%E4%B8%AD%E7%9A%84PWT%E5%92%8CPCD%E4%BD%8D"><span class="nav-number">6.</span> <span class="nav-text">PDE,PTE中的PWT和PCD位</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93"><span class="nav-number">7.</span> <span class="nav-text">保护模式阶段总结</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E9%A2%98"><span class="nav-number">7.1.</span> <span class="nav-text">第一题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E9%A2%98"><span class="nav-number">7.2.</span> <span class="nav-text">第二题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="nav-number">8.</span> <span class="nav-text">补充知识点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#CPU%E4%BF%A1%E6%81%AF%E6%9F%A5%E8%AF%A2"><span class="nav-number">8.1.</span> <span class="nav-text">CPU信息查询</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MDL%EF%BC%9F%E7%89%A9%E7%90%86%E9%A1%B5%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%EF%BC%9F"><span class="nav-number">8.2.</span> <span class="nav-text">MDL？物理页地址映射？</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ZEROKO14</p>
  <div class="site-description" itemprop="description">你好，欢迎来到ZEROKO14的个人博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZEROKO14</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>-->

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/muse.js"></script>


<script src="/blog/js/next-boot.js"></script>


  <script defer src="/blog/lib/three/three.min.js"></script>
    <script defer src="/blog/lib/three/three-waves.min.js"></script>


  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
