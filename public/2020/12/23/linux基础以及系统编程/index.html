<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zeroko14.gitee.io","root":"/blog/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="linux基础 熟悉Linux下目录结构和常见目录的作用 熟练使用linux下的相对路径和绝对路径 熟练使用Linux下常用文件和目录操作相关的命令 熟练使用修改用户权限,用户和用户组相关的命令 熟练使用文件的查找和检索相关的命令 熟练掌握Ubuntu下的软件安装和卸载 熟练使用压缩工具完成文件或目录的压缩解压缩">
<meta property="og:type" content="article">
<meta property="og:title" content="linux系统编程">
<meta property="og:url" content="http://zeroko14.gitee.io/blog/2020/12/23/linux%E5%9F%BA%E7%A1%80%E4%BB%A5%E5%8F%8A%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="ZEROKO14的个人博客">
<meta property="og:description" content="linux基础 熟悉Linux下目录结构和常见目录的作用 熟练使用linux下的相对路径和绝对路径 熟练使用Linux下常用文件和目录操作相关的命令 熟练使用修改用户权限,用户和用户组相关的命令 熟练使用文件的查找和检索相关的命令 熟练掌握Ubuntu下的软件安装和卸载 熟练使用压缩工具完成文件或目录的压缩解压缩">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/202203051532095.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/202203051536768.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/202203051541990.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/202203051545251.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/202203051546536.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/202203051601037.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/202203051700028.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/202203051716573.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/202203051654788.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/202203051713214.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/202203071702227.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/202203061013559.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/202203061013391.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/202203061016986.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/202203061051478.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/202203061123384.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/202203061124397.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202206231654467.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202208151816868.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/202203101341712.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/202203101457076.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/202203101458023.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/202203151108150.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/202203151556250.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/202203151552248.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/202203151557180.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/202203151556430.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/202203151559245.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/202203151133735.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/202203151352511.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/202203151407768.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/202203151415703.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/202203151410036.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/202203181010547.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/202203181021902.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/202203181021952.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/202203181022007.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/202203151556250.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/202203151628263.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/202203151627052.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/202203151628443.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/202203151629202.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202206061447162.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202206061447137.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202206061507063.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202206061718536.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202206061728121.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202206081601488.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202206061447137.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202206121613690.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202206121550194.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202206181305314.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202206211417434.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202206211418742.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202206211433823.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202206211525270.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202206211528595.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202206211529165.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202206231907967.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202206241336368.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207031544810.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207041029498.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207041143653.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207041258197.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207041259218.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207041858586.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207051217507.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207051510703.jpeg">
<meta property="og:image" content="http://zeroko14.gitee.io/Users/zeroko/Desktop/%E6%88%AA%E5%B1%8F2022-07-05%2015.07.15.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207051749198.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207131704167.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207141503278.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207151104023.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207151303644.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207151512599.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202206231654467.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207161004027.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207181155330.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207161343792.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207161856627.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207181413469.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207191501937.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207191533978.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207201125224.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202208211822664.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207201055606.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207201059397.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207201100698.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207201311701.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207201405870.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207201629974.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207211142513.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207211347215.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207261331774.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207261332625.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207281613821.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207281613562.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207291415036.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207291421675.png">
<meta property="og:image" content="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207291421450.png">
<meta property="article:published_time" content="2020-12-23T14:51:13.000Z">
<meta property="article:modified_time" content="2022-08-28T10:16:53.926Z">
<meta property="article:author" content="ZEROKO14">
<meta property="article:tag" content="linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/che77a38/blogImage/main/202203051532095.png">

<link rel="canonical" href="http://zeroko14.gitee.io/blog/2020/12/23/linux%E5%9F%BA%E7%A1%80%E4%BB%A5%E5%8F%8A%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>linux系统编程 | ZEROKO14的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ZEROKO14的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">zeroko14's blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zeroko14.gitee.io/blog/2020/12/23/linux%E5%9F%BA%E7%A1%80%E4%BB%A5%E5%8F%8A%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="ZEROKO14">
      <meta itemprop="description" content="你好，欢迎来到ZEROKO14的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZEROKO14的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          linux系统编程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-23 22:51:13" itemprop="dateCreated datePublished" datetime="2020-12-23T22:51:13+08:00">2020-12-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-28 18:16:53" itemprop="dateModified" datetime="2022-08-28T18:16:53+08:00">2022-08-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="linux基础"><a href="#linux基础" class="headerlink" title="linux基础"></a>linux基础</h1><ul>
<li>熟悉Linux下目录结构和常见目录的作用</li>
<li>熟练使用linux下的相对路径和绝对路径</li>
<li>熟练使用Linux下常用文件和目录操作相关的命令</li>
<li>熟练使用修改用户权限,用户和用户组相关的命令</li>
<li>熟练使用文件的查找和检索相关的命令</li>
<li>熟练掌握Ubuntu下的软件安装和卸载</li>
<li>熟练使用压缩工具完成文件或目录的压缩解压缩</li>
</ul>
<span id="more"></span>

<h2 id="命令解释器"><a href="#命令解释器" class="headerlink" title="命令解释器"></a>命令解释器</h2><ul>
<li>shell就是命令解释器</li>
<li>作用:对用户输入到终端的命令进行解析,调用对应的执行程序</li>
</ul>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/202203051532095.png" alt="1212121212"></p>
<p>用户在终端输入命令,由shell命令解释器对命令进行解析(按照$PATH环境变量搜索命令),解析成内核能够识别的指令,然后有内核执行命令,最后由终端显示命令执行的结果给用户</p>
<p>shell在寻找命令的时候是按照$PATH环境变量去查找的,如果找到了就执行对应的命令,若找不到就报错,执行<code>echo $PATH</code>可以查看PATH环境变量的值</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/202203051536768.png" alt="image-20220305153637492"></p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/202203051541990.png" alt="1212121212"></p>
<p>常见的命令解析器:</p>
<ul>
<li>shell – Bourne Shell     (/bin/sh)   不支持tab键补全</li>
<li>bash – Bourne Again Shell      (/bin/bash)</li>
</ul>
<p>查看当前电脑有几个命令解析器:<code>cat /etc/shells</code></p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/202203051545251.png" alt="image-20220305154519666"></p>
<p>查看当前系统使用的shell:<code>echo $SHELL</code></p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/202203051546536.png" alt="image-20220305154621265"></p>
<h2 id="Linux下常用快捷键"><a href="#Linux下常用快捷键" class="headerlink" title="Linux下常用快捷键"></a>Linux下常用快捷键</h2><ul>
<li><p>tab键</p>
<p>补齐命令,补齐文件</p>
</li>
<li><p>上下方向键</p>
<p>遍历输入的历史命令</p>
<p>使用<code>history</code>命令可以显示用户输入的所有命令</p>
</li>
<li><p>光标移动</p>
<p>ctrl+b光标后移</p>
<p>ctrl+f光标前移</p>
<p>ctrl+a光标移动到行首</p>
<p>ctrl+e光标移动到行末</p>
</li>
<li><p>删除字符</p>
<p>ctrl+h(backspace)删除光标左边字符</p>
<p>ctrl+d删除光标右边(覆盖的)字符</p>
<p>ctrl+u删除光标前所有内容</p>
<p>ctrl+k删除光标前后有内容</p>
</li>
</ul>
<h2 id="Linux下目录结构"><a href="#Linux下目录结构" class="headerlink" title="Linux下目录结构"></a>Linux下目录结构</h2><p>Linux系统的目录结构是一个倒立的树状结构,根目录用<code>/</code>表示,对比Windows目录结构理解Linux的目录结构</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/202203051601037.png" alt="捕获"></p>
<ul>
<li><p><code>/bin</code> binary,二进制文件,可执行程序,shell命令</p>
<p>如:ls,rm,mv,cp等常用命令</p>
</li>
<li><p><code>/sbin</code> s是Super User的意思,这里存放的是系统管理员使用的系统管理程序</p>
<p>如:ifconfig,halt,shutdown,reboot等系统命令</p>
</li>
<li><p><code>/dev</code> device设备,在linux下一切皆文件</p>
<p>硬盘,显卡,显示器</p>
<p>字符设备文件,块设备文件</p>
<p>如:在input目录下执行:sudo cat mouse0,移动鼠标会显示有输入</p>
</li>
<li><p><code>/lib</code> linux运行的时候需要加载的一些动态库</p>
<p>如:libc.so,libpthread.so等</p>
</li>
<li><p><code>/mnt</code> 手动的挂载目录,如U盘等</p>
</li>
<li><p><code>/media</code> 外设的自动挂载目录,如光驱等</p>
</li>
<li><p><code>/root</code> linux的超级用户root的家目录(家目录:切换到不同用户时跳转到的目录)</p>
</li>
<li><p><code>/usr</code> unix system resource – 类似于Windows的programe files目录</p>
<ul>
<li>include目录里存放头文件,如:stdio.h,stdlib.h,string.h,pthread.h</li>
<li>games目录下的小游戏,如:小火车游戏</li>
</ul>
</li>
<li><p><code>/etc</code> 存放系统级别的配置文件</p>
<ul>
<li><p><code>/etc/passwd</code></p>
<p>man 5 passwd可以查看passwd文件的格式信息</p>
</li>
<li><p><code>/etc/group</code></p>
<p>man 5 group可以查看group文件的格式信息</p>
</li>
<li><p><code>/etc/profile</code></p>
<p>系统的配置文件,修改该文件会影响这个系统下面的所有的用户</p>
</li>
</ul>
</li>
<li><p><code>/opt</code> 安装第三方应用程序</p>
<p>比如安装oracle数据库可以在这个目录下</p>
</li>
<li><p><code>/home</code> linux操作系统所有用户的家目录</p>
<p>用户家目录:(宿主目录或主目录)  /home/你的用户名</p>
</li>
<li><p><code>/tmp</code> 存放临时文件</p>
<p>这个目录下的文件会在系统重启后自动清除</p>
</li>
</ul>
<h2 id="相对路径和绝对路径"><a href="#相对路径和绝对路径" class="headerlink" title="相对路径和绝对路径"></a>相对路径和绝对路径</h2><ul>
<li><p>绝对路径</p>
<p>从根目录开始表示的路径,也就是从 <code>/</code> 开始</p>
</li>
<li><p>相对路径</p>
<ul>
<li>从当前所处的目录开始表示的路径</li>
<li><code>.</code> 表示当前目录</li>
<li><code>..</code> 表示当前目录的上一级目录</li>
</ul>
</li>
<li><p>linux中的命令提示符</p>
<p><code>zeroko14@deMacBook-Pro:~/test/course/day1$</code></p>
<ul>
<li><p><code>zeroko</code>:当前登录的用户</p>
</li>
<li><p><code>@</code>:英文at,在的意思</p>
</li>
<li><p><code>deMacBook-Pro</code>:主机名(主机名在/etc/hosts这个文件中)</p>
</li>
<li><p><code>~/test/course/day1</code> 当前工作目录,~表示宿主目录(家目录或主目录)</p>
<p>可以通过 <code>echo ~</code> 或者 <code>echo $HOME</code> 查看当前用户的宿主目录</p>
</li>
<li><p><code>$</code>:表示当前用户为普通用户,<code>#</code> 表示当前用户为root用户</p>
</li>
</ul>
</li>
</ul>
<h2 id="文件和目录操作相关的命令"><a href="#文件和目录操作相关的命令" class="headerlink" title="文件和目录操作相关的命令"></a>文件和目录操作相关的命令</h2><h3 id="tree命令"><a href="#tree命令" class="headerlink" title="tree命令"></a>tree命令</h3><p>以树状形式查看指定目录内容(结构层次清晰),使用该命令需安装软件tree</p>
<p>安装方式:<code>sudo apt-get update</code>     <code>sudo apt-get install tree</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tree <span class="comment">//树形结构显示当前目录下的文件信息</span></span><br><span class="line">tree 目录<span class="comment">//树形结构显示指定目录下的文件信息</span></span><br></pre></td></tr></table></figure>

<h3 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h3><p>查看指定目录下的文件信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls  <span class="comment">//显示当前目录下文件信息</span></span><br><span class="line">ls 目录或文件名<span class="comment">//显示指定目录下文件信息</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>列出当前目录下的所有文件(包含.开头的隐藏文件)</td>
</tr>
<tr>
<td>-R</td>
<td>递归方式列出所有目录中的内容</td>
</tr>
<tr>
<td>-l</td>
<td>列出文件的详细信息(<code>ls -l</code>简写:<code>ll</code>)</td>
</tr>
<tr>
<td>-t</td>
<td>按照时间排序显示内容</td>
</tr>
<tr>
<td>-r</td>
<td>反转顺序显示</td>
</tr>
<tr>
<td>-i</td>
<td>查看inode节点lili</td>
</tr>
</tbody></table>
<p>参数之间可以结合使用,如:<code>ls -ltr</code> 按照时间逆向显示所有内容详细信息</p>
<p>-a所有文件包含:隐藏文件(以.开头的文件名和普通文件和.还有..)</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/202203051700028.png" alt="image-20220305170027550"></p>
<p>-l列出的详细信息包含7部分内容</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/202203051716573.png" alt="图片1"></p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/202203051654788.png" alt="image-20220305165430053"></p>
<ul>
<li><p>文件类型(第1个字符)</p>
<ul>
<li><code>-</code> 普通文件</li>
<li><code>d</code> 目录directory</li>
<li><code>l</code>  符号链接link,相当于Windows的快捷方式</li>
<li><code>s</code> 套接字socket</li>
<li><code>p</code>  管道pipe</li>
<li><code>b</code> 块设备block</li>
<li><code>c</code> 字符设备 character</li>
</ul>
</li>
<li><p>用户的操作权限(2~10个字符)</p>
<p>r:可读;w:可写;x:可执行</p>
<ul>
<li><p>文件所有者对文件的操作权限(第2,3,4字符)</p>
</li>
<li><p>文件所属组用户对文件的操作权限(第5,6,7字符)</p>
</li>
<li><p>其他人对文件的操作权限(第8,9,10字符)</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/202203051713214.png" alt="捕获"></p>
</li>
</ul>
</li>
<li><p>硬链接计数</p>
<ul>
<li>对于<strong>目录</strong>来说,<strong>链接计数</strong>等于<strong>该目录下所有的目录总数(包含.和..)</strong>,但是不包含该目录的子目录下的目录文件数量(执行ls -la命令可以进行查看)</li>
<li>对于<strong>文件</strong>来说,指的是该文件所有的<strong>硬链接文件数量</strong></li>
</ul>
</li>
<li><p>文件所有者:zeroko或root</p>
</li>
<li><p>文件所属组:wheel(mac中具有管理员性质的用户位于wheel组中,可以用su切换到root的用户集合)</p>
</li>
<li><p>文件大小</p>
<ul>
<li>如果是<strong>目录</strong>:只表示目录大小,不包含目录中的内容,目录大小为4k</li>
<li>如果是<strong>文件</strong>:表示文件大小</li>
</ul>
</li>
<li><p>文件的创建日期或最后修改时间:<code>3  4  22:51</code>:表示创建或最后修改于3月4日22:51</p>
</li>
<li><p>文件名:DidFinish.txt</p>
</li>
</ul>
<h3 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h3><p>切换目录(change directory),命令使用方式:<code>cd + (相对或绝对)路径</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd <span class="comment">//切换到家目录</span></span><br><span class="line">cd -<span class="comment">//切换到上一个目录cd切换过来的源目录</span></span><br></pre></td></tr></table></figure>

<h3 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h3><p>查看用户当前所处的工作目录printf working directroy</p>
<h3 id="which命令"><a href="#which命令" class="headerlink" title="which命令"></a>which命令</h3><p>显示命令所在的目录,如:which ls</p>
<h3 id="touch命令"><a href="#touch命令" class="headerlink" title="touch命令"></a>touch命令</h3><p>如果文件不存在,创建新文件,如果文件存在,更新文件的最后修改时间.</p>
<p>使用方式:<code>touch + 文件名</code></p>
<h3 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h3><p>创建新目录,make directory</p>
<p>使用方式:<code>mkdir 目录名</code></p>
<p>创建多级目录需要添加参数 <code>-p</code></p>
<p>创建多级目录例子:<code>mkdir -p ~/test/hello/world/aa</code></p>
<h3 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h3><p>删除文件:<code>rm  文件名</code></p>
<p>删除目录:<code>rm -r  目录名</code></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-r</td>
<td>递归删除目录,删除目录必须添加此参数</td>
</tr>
<tr>
<td>-i</td>
<td>提示用户是否删除文件或目录</td>
</tr>
<tr>
<td>-f</td>
<td>强制删除</td>
</tr>
</tbody></table>
<p><strong>[注意]</strong> 使用rm命令删除的文件或目录不会放入回收站中,数据不易恢复</p>
<h3 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h3><p>拷贝命令copy</p>
<p>使用方式: <code>cp 源目录或文件 目标目录或文件</code></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-r</td>
<td><strong>若有目录的拷贝(拷贝对象是目录)需要使用该参数</strong></td>
</tr>
<tr>
<td>-a</td>
<td>保留被拷贝文件的一些属性信息</td>
</tr>
</tbody></table>
<p>有下面几种情况</p>
<ul>
<li><code>cp file1 file(不存在)</code>  ==&gt;  创建file,将file1内容拷贝到file</li>
<li><code>cp file1 file</code>  ==&gt;  file1覆盖file</li>
<li><code>cp file dir</code>  ==&gt;  拷贝file到dir目录</li>
<li><code>cp -r dir dir1</code>  ==&gt;  将dir目录拷贝到dir1目录中(包含dir目录本身)</li>
<li><code>cp -r dir dir1(不存在)</code>  ==&gt;  创建dir1, 将dir中的内容拷贝到dir1目录中(不包含dir目录本身)</li>
</ul>
<h3 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h3><p>改名或移动文件</p>
<p>使用方式: </p>
<ul>
<li>改名<ul>
<li><code>mv file file2</code>  若file2存在则覆盖并将<strong>file改名为file2</strong>,file2不存在则没有覆盖</li>
<li><code>mv dir dir2(不存在)</code></li>
</ul>
</li>
<li>移动(<strong>第二个参数一定是存在的目录文件</strong>)<ul>
<li><code>mv file dir(存在)</code> 文件移动到目录中</li>
<li><code>mv dir dir2(存在)</code>   整个目录移动</li>
</ul>
</li>
</ul>
<h3 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h3><p>将文件内容一次性输出到终端</p>
<p>使用方式:<code>cat 文件名</code></p>
<p>缺点:终端显示的内容有限,如果文件太长无法全部显示</p>
<p>可用于文件重定向:<code>cat file1&gt;file2</code> (一个<code>&gt;</code>是覆盖,两个<code>&gt;</code>是末尾追加)相当于 <code>cp file1 file2</code></p>
<h3 id="more命令"><a href="#more命令" class="headerlink" title="more命令"></a>more命令</h3><p>文件内容分页显示到终端,但是智能一直向下浏览,不能回退</p>
<p>使用方法:<code>more 文件名</code></p>
<p>相关操作</p>
<ul>
<li>显示下一行:回车</li>
<li>显示下一页:空格</li>
<li>退出:q(ctrl+c)</li>
</ul>
<h3 id="less命令"><a href="#less命令" class="headerlink" title="less命令"></a>less命令</h3><p>文件内容分页显示到终端,可以自由上下浏览</p>
<p>使用方式:<code>less 文件名</code></p>
<p>相关操作:</p>
<ul>
<li>显示下一行:回车,ctrl+p,向下方向键</li>
<li>显示上一行:ctrl+n,向上方向键</li>
<li>显示下一页:空格,PageDown</li>
<li>显示上一页:PageUp</li>
<li>退出:q</li>
</ul>
<h3 id="head命令"><a href="#head命令" class="headerlink" title="head命令"></a>head命令</h3><p>从文件头部开始查看前n行的内容</p>
<p>使用方式:<code>head-n[行数] 文件名</code>  如:<code>head -20 hello.txt</code></p>
<p>如果没有指定行数,默认显示前10行内容</p>
<h3 id="tail命令"><a href="#tail命令" class="headerlink" title="tail命令"></a>tail命令</h3><p>从文件尾部向上查看最后n行的内容</p>
<p>使用方式:<code>tail  -n[行数]  文件名</code></p>
<p>如果没有指定行数,默认显示最后10行内容</p>
<p>一个比较重要的应用:显示日志: <code>tail -f test.log</code> (<code>-f</code> 是阻塞的意思,表示堵塞实时显示文件内容)</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/202203071702227.jpeg" alt="截屏2022-03-07 16.59.55"></p>
<h3 id="链接相关命令"><a href="#链接相关命令" class="headerlink" title="链接相关命令"></a>链接相关命令</h3><h4 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h4><p>软链接类似于windows下的快捷方式</p>
<p>创建软链接方式:</p>
<ul>
<li><p>创建文件软链接: <code>ln -s 文件名  快捷方式的名字</code></p>
<p>如: <code>ln -s  aa  aa.soft</code></p>
</li>
<li><p>创建目录软链接: <code>ln -s  目录  快捷方式的名字</code></p>
<p>如: <code>ln -s  tmp  tmp.link</code></p>
</li>
</ul>
<p><strong>[注意事项]</strong></p>
<p>ln创建软链接要用<strong>绝对路径</strong>,因为如果不使用绝对路径,一旦这个链接文件发生位置变动,就不能找到那个文件了.<br>$$<br>软链接文件的大小为: 路径+文件名的总字节数<br>$$</p>
<h4 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h4><p>使用方式: <code>ln 文件名 硬链接的名字</code>          如: <code>ln test.log test.log.hard</code></p>
<p><strong>[注意事项]</strong></p>
<ol>
<li><p>硬链接<strong>不能建在目录上</strong></p>
</li>
<li><p>硬链接对绝对路径没有要求</p>
</li>
<li><p>硬链接不能跨文件系统</p>
<p>硬链接文件的源文件的inode是相同的,文件系统的inode要求唯一,跨文件系统可能会使inode不同,所以硬链接不能跨文件系统</p>
</li>
</ol>
<blockquote>
<p><strong>硬链接的本质</strong></p>
<p>硬链接的本质是不同的文件名所在的inode节点是相同的,相同的inode节点指向了相同的数据块,所以他们的文件内容是一样的,文件内容会同步.</p>
</blockquote>
<p>查看文件的i节点(inode): <code>ls -i 文件名</code> </p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/202203061013559.png" alt="image-20220306101335367"></p>
<p>查看i节点信息: <code>stat 文件名</code></p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/202203061013391.png" alt="image-20220306101354149"></p>
<p>如下图,file.hard是file的硬链接,这两个文件指向了同一个inode,同一个inode指向了相同的数据块(文件内容)</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/202203061016986.png" alt="捕获"></p>
<ul>
<li>当新创建了一个文件,硬链接计数为1</li>
<li>给文件创建一个硬链接后,硬链接计数加1</li>
<li>删除一个硬链接后,硬链接计数减1</li>
<li>如果删除硬链接后,硬链接计数为0,则该文件会删除</li>
</ul>
<p><strong>硬链接的应用场合</strong></p>
<ul>
<li><p>可以起到同步文件的作用</p>
<p>修改file的内容,会在其余三个硬链接文件上同步</p>
</li>
<li><p>可以起到保护文件的作用</p>
<p>删除文件的时候,只要硬链接计数不为0,不会真正被删除,起到保护文件的作用</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/202203061051478.png" alt="捕获"></p>
<p>只有删除这4个文件,文件才会真正被删除</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/352347364">软硬链接和mac上的替身的区别详解</a></p>
<h3 id="wc命令"><a href="#wc命令" class="headerlink" title="wc命令"></a>wc命令</h3><p>显示文件行数,字节数,单词数</p>
<ul>
<li><code>wc -l file</code> 显示文件的总行数</li>
<li><code>wc -c file</code> 显示文件的总字节数</li>
<li><code>wc -w file</code> 显示文件的总单词数</li>
<li><code>wc file</code> 显示文件的总行数,单词数和总字节数</li>
</ul>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/202203061123384.png" alt="image-20220306112350129"></p>
<h3 id="whoami命令"><a href="#whoami命令" class="headerlink" title="whoami命令"></a>whoami命令</h3><p>显示当前登录的用户名</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/202203061124397.png" alt="image-20220306112431190"></p>
<h3 id="man命令"><a href="#man命令" class="headerlink" title="man命令"></a>man命令</h3><p>$$<br>使用方式:\ \ man(选项)(参数)<br>$$</p>
<p><strong>选项</strong></p>
<ul>
<li>-a：在所有的man帮助手册中搜索;</li>
<li>-f：等价于whatis指令，显示给定关键字的简短描述信息;</li>
<li>-P：指定内容时使用分页程序;</li>
<li>-M：指定man手册搜索的路径。</li>
</ul>
<p><strong>参数</strong></p>
<ul>
<li>1是普通的命令</li>
<li>2是系统调用,如open,write之类的(通过这个，至少可以很方便的查到调用这个函数，需要加什么头文件)</li>
<li>3是库函数,如printf,fread</li>
<li>4是特殊文件,也就是/dev下的各种设备文件</li>
<li>5是指文件的格式,比如passwd,就会说明这个文件中各个字段的含义</li>
<li>6是给游戏留的,由各个游戏自己定义</li>
<li>7是附件还有一些变量,比如向environ这种全局变量在这里就有说明</li>
<li>8是系统管理用的命令,这些命令只能由root使用,如ifconfig</li>
</ul>
<p><a href="#%E5%BA%93%E5%87%BD%E6%95%B0%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0%E7%9A%84%E5%85%B3%E7%B3%BB">了解库函数与系统函数的关系</a></p>
<p>man文档中函数后头写了POSIX.1,表示符合POSIX.1这个标准,即linux也可以用,unix也可以用</p>
<p><code>POSIX</code> 表示 可移植操作系统接口（Portable Operating System Interface of UNIX，缩写为 POSIX ），POSIX标准定义了操作系统应该为应用程序提供的接口标准.</p>
<h2 id="用户权限-用户和用户组相关命令"><a href="#用户权限-用户和用户组相关命令" class="headerlink" title="用户权限,用户和用户组相关命令"></a>用户权限,用户和用户组相关命令</h2><h3 id="chmod命令"><a href="#chmod命令" class="headerlink" title="chmod命令"></a>chmod命令</h3><p>修改文件权限 change mode</p>
<p>linux是通过权限对文件进行控制的,通过使用chmod命令可以修改文件相关的权限</p>
<h4 id="文字设定法"><a href="#文字设定法" class="headerlink" title="文字设定法"></a>文字设定法</h4><p>命令: <code>chmod [who] [+|-|=] [mode] 文件名</code></p>
<p>例子:<code>chmod ug+wr file.txt</code>  给文件file.txt的所有者和所属组添加读写权限</p>
<ul>
<li>操作对象[who]  <strong>[注意]</strong> 如果chmod未设置ugo的话,此时默认设置为a,此设置受<a target="_blank" rel="noopener" href="https://blog.csdn.net/yangzhengquan19/article/details/83055686">umask</a>限制影响<ul>
<li>u – 用户(user)</li>
<li>g – 同组用户(group)</li>
<li>o – 其他用户(other)</li>
<li>a – 所有用户(all) [默认]</li>
</ul>
</li>
<li>操作符[+|-|=]<ul>
<li><code>+</code>  添加权限</li>
<li><code>-</code>  取消权限</li>
<li><code>=</code>  赋予给定权限并取消其他权限</li>
</ul>
</li>
<li>权限[mode]<ul>
<li>r – 读权限</li>
<li>w – 写权限</li>
<li>x – 执行权限</li>
</ul>
</li>
</ul>
<h4 id="数字设定法"><a href="#数字设定法" class="headerlink" title="数字设定法"></a>数字设定法</h4><p>数字表示的含义</p>
<ul>
<li>0 – 没有权限(-)</li>
<li>1 – 执行权限(x)</li>
<li>2 – 写权限(w)</li>
<li>4 – 读权限(r)</li>
</ul>
<p>例子:<code>chmod 764 file.txt</code>  给file.txt文件设置权限为rwx-rw-r</p>
<p><strong>[注意]</strong> 使用数字设定法,一定要使用3位的8进制数:如:066</p>
<h3 id="chown命令"><a href="#chown命令" class="headerlink" title="chown命令"></a>chown命令</h3><p>change owner</p>
<ul>
<li><p>修改文件所有者</p>
<p>用法: <code>chown 文件所有者 文件名</code></p>
<p>例: <code>sudo chown mytest file.txt</code></p>
</li>
<li><p>修改文件所有者和所属组</p>
<p>用法:<code>chown 文件所有者:文件所属组 文件名</code>(<code>:</code>也行, <code>.</code>也行,意思一样)</p>
<p>例:<code>sudo chown mytest.mytest file.txt</code></p>
</li>
</ul>
<p>普通用户需要使用<strong>管理员用户权限</strong>执行该命令(若系统没有其他用户,可以使用 <code>sudo adduser 用户名</code> 创建一个新用户)</p>
<h3 id="chgrp命令"><a href="#chgrp命令" class="headerlink" title="chgrp命令"></a>chgrp命令</h3><p>修改文件所属组 change group</p>
<p>使用方法: <code>chgrp 用户组 文件或目录名</code></p>
<p>例: <code>sudo chgrp mytest file.txt</code>  修改文件所述组为mytest</p>
<p>普通用户需要使用管理员权限执行该命令</p>
<h3 id="id命令"><a href="#id命令" class="headerlink" title="id命令"></a>id命令</h3><p>用于查看id相关信息,组id,用户id等等</p>
<h2 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h2><ul>
<li><p><code>-name</code> 按文件名查询</p>
<p>格式:<code>find 路径 -name &quot;文件名&quot;</code></p>
<p>例:<code>find /home -name &quot;*.c&quot;</code></p>
</li>
<li><p><code>-type</code> 按文件类型查询</p>
<p>格式:<code>find 路径 -type 类型</code></p>
<p>类型盘点:</p>
<ul>
<li><code>f</code> 普通文件类型</li>
<li><code>d</code> 目录</li>
<li><code>l</code> 符号链接</li>
<li><code>b</code> 块设备文件</li>
<li><code>c</code> 字符设备文件</li>
<li><code>s</code> socket文件</li>
<li><code>p</code> 管道文件</li>
</ul>
<p>例:<code>find /home -type f</code> 查找指定目录下的普通文件</p>
</li>
<li><p><code>-size</code> 按文件大小查询</p>
<p>格式: <code>find 路径 -size 范围</code></p>
<p>范围:</p>
<ul>
<li><code>+</code> 大于</li>
<li><code>-</code> 小于</li>
<li><code>不需要添加符号</code> 等于</li>
</ul>
<p>大小:</p>
<ul>
<li>M必须大写,表示1024*1024字节的单位</li>
<li>k必须小写,表示1024字节的单位</li>
<li>c表示字节数</li>
</ul>
<p>例:<code>find ~/ -size +50k -size -100k</code>  查找家目录中大于50k,小于100k的文件</p>
</li>
<li><p>按文件日期查询</p>
<p><code>-ctime -n/+n</code>(<code>-n</code> n天以内; <code>+n</code> n天以外) </p>
<ul>
<li>按创建日期查询 <code>-ctime -n/+n </code>  create time</li>
<li>按修改日期查询 <code>-mtime -n/+n</code> <em>modificate</em>d time  </li>
<li>按访问日期查询 <code>-atime -n/+n </code>  access time</li>
</ul>
</li>
<li><p>按深度查询</p>
<ul>
<li><p>-maxdepth n(层数)</p>
<p>搜索&lt;=n层目录</p>
</li>
<li><p>-mindepth n(层数)    </p>
<p>搜索&gt;=n层的目录</p>
</li>
</ul>
</li>
<li><p>高级查询</p>
<ul>
<li><p>格式1 <code>find 路径 -type d -exec shell命令 &#123;&#125; \;</code></p>
<p>例: <code>find ./ -type d -exec ls -l &#123;&#125; \;</code></p>
</li>
<li><p>格式2 <code>find 路径 -type d -ok shell命令 &#123;&#125; \;</code>(<code>-ok</code> 会显示找到的文件问你是否确认执行输入的shell命令)</p>
<p>例: <code>find ./ -type d -ok ls -l &#123;&#125; \;</code></p>
</li>
<li><p>格式3 <code>find 路径 -type d | xargs shell命令</code></p>
</li>
<li><p>例: <code>find ./ -type d | xargs ls -l</code></p>
</li>
</ul>
<p>注意:</p>
<ul>
<li>上面的{}中间不能有空格</li>
<li>ok最安全(因为会显示搜索结果问你是否确认执行shell命令),特别是在执行rm删除文件的时候</li>
</ul>
<p><code>|</code>表示管道,从管道读到的信息通过xargs作为shell命令的参数使用</p>
</li>
</ul>
<h2 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h2><p>查找文件中按照行为单位查询是否包含内容</p>
<p>格式: <code>grep -r(有目录的话) &quot;查找的内容&quot; 搜索的路径</code></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-r</td>
<td>若是搜索目录必须加这个参数,可进行递归搜索</td>
</tr>
<tr>
<td>-n</td>
<td>显示该查找内容所在的行号</td>
</tr>
<tr>
<td>-i</td>
<td>忽略大小写进行查找</td>
</tr>
<tr>
<td>-v</td>
<td>不显示含有某字符的行</td>
</tr>
</tbody></table>
<p>例子: <code>grep -r -i -n &quot;HELLO world&quot; ./</code>  搜索当前目录下包含HELLO world(忽略大小写)并且显示行号</p>
<h3 id="find和grep命令结合使用"><a href="#find和grep命令结合使用" class="headerlink" title="find和grep命令结合使用"></a>find和grep命令结合使用</h3><p>先使用find命令查找文件, 然后使用grep命令查找哪些文件包含某个字符串     <code>find . -name &quot;*.c&quot; | xargs grep -n &quot;main&quot;</code></p>
<h2 id="linux中常用的解压缩工具"><a href="#linux中常用的解压缩工具" class="headerlink" title="linux中常用的解压缩工具"></a>linux中常用的解压缩工具</h2><h3 id="gzip和bzip2"><a href="#gzip和bzip2" class="headerlink" title="gzip和bzip2"></a>gzip和bzip2</h3><p>不能压缩目录,只能一个一个文件进行压缩,压缩之后会使原文件消失</p>
<ul>
<li><code>gzip *</code> 压缩当前目录下所有的文件,但是目录不能压缩</li>
<li><code>gunzip*</code> 解压当前目录下所有的.gz文件</li>
<li><code>bzip2 *</code> 压缩当前目录下所有的文件,但是目录不能压缩</li>
<li><code>bunzip2 *</code> 解压当前目录下所有的.bz2文件</li>
</ul>
<h3 id="tar工具"><a href="#tar工具" class="headerlink" title="tar工具"></a>tar工具</h3><p>参数:</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>z</td>
<td>用gzip来压缩/解压缩文件</td>
</tr>
<tr>
<td>j</td>
<td>用bzip2来压缩/解压缩文件</td>
</tr>
<tr>
<td>c</td>
<td>create,创建新的压缩文件,与x互斥使用</td>
</tr>
<tr>
<td>x</td>
<td>从压缩文件中释放文件,与c互斥使用</td>
</tr>
<tr>
<td>v</td>
<td>详细报告tar处理的文件信息</td>
</tr>
<tr>
<td>f</td>
<td>指定压缩文件的名字</td>
</tr>
<tr>
<td>t</td>
<td>查看压缩包中有哪些文件</td>
</tr>
<tr>
<td>-C(大写) 解压目录</td>
<td>解压到指定目录</td>
</tr>
</tbody></table>
<p>压缩</p>
<ul>
<li>``tar cvf 压缩包名字.tar 原材料(要打包压缩的文件或目录)`  (只打包,不压缩)</li>
<li><code>tar zcvf 压缩包名字.tar.gz 原材料(要打包压缩的文件或目录) </code></li>
<li><code>tar jcvf 压缩包名字.tar.bz2 原材料(要打包压缩的文件或目录)</code></li>
</ul>
<p>解压缩</p>
<ul>
<li><code>tar xvf 已有的压缩包.tar.gz</code></li>
<li><code>tar zxvf 已有的压缩包.tar.gz</code></li>
<li><code>tar jxvf 已有的压缩包.tar.bz2</code></li>
</ul>
<p>解压缩到指定目录: <code>tar zxvf test.tar.gz -C ./</code></p>
<p>查看压缩包中有哪些文件 <code>tar -tvf 压缩包.tar</code></p>
<h3 id="rar工具"><a href="#rar工具" class="headerlink" title="rar工具"></a>rar工具</h3><p>使用前需要安装rar工具 <code>sudo apt-get install rar</code></p>
<ul>
<li><p>压缩</p>
<p>命令: <code>rar a -r 要压缩的文件(含文件或者目录)</code></p>
<p>压缩目录需要使用参数: -r</p>
<p>例: <code>rar a -r my aa bb dir</code>  将aa,bb,dir压缩到my.rar文件中(打包的生成的新文件不需要指定后缀)</p>
</li>
<li><p>解压缩</p>
<p>命令: <code>rar x xxx.rar [解压到的目录]</code> 解压目录[到指定位置]</p>
<p>例: <code>rar x my.rar TAR</code> 将my.rar解压到TAR目录下</p>
<p>注意:若解压目录不存在会报错</p>
</li>
</ul>
<p><code>rar v 压缩文件名.rar</code> 查看压缩文件内容</p>
<h3 id="zip工具"><a href="#zip工具" class="headerlink" title="zip工具"></a>zip工具</h3><ul>
<li><p>压缩: <code>zip -r 压缩包名 要压缩的文件(含文件或目录)</code></p>
<p>压缩目录需要使用参数 <code>-r</code></p>
<p>使用该命令不需要指定压缩包后缀</p>
<p>例: <code>zip -r xxx file dir</code>    生成xxx.zip文件</p>
</li>
<li><p>解压缩: <code>unzip 压缩包名</code></p>
<p>解压缩到指定目录: 添加参数 <code>-d 解压目录</code></p>
<p>注意:解压目录若不存在则会创建</p>
</li>
</ul>
<h2 id="软件的安装和卸载"><a href="#软件的安装和卸载" class="headerlink" title="软件的安装和卸载"></a>软件的安装和卸载</h2><p>在线安装</p>
<ul>
<li><p>软件安装 <code>sudo apt-get install 软件名</code></p>
</li>
<li><p>软件卸载 <code>sudo apt-get remove 软件名</code></p>
</li>
<li><p>更新软件列表 <code>sudo apt-get update</code></p>
</li>
<li><p>清理安装包 <code>sudo apt-get clean</code></p>
<p> 清理的是缓存路径: <code>/var/cache/apt/archives</code></p>
</li>
</ul>
<p>软件包本地安装</p>
<ul>
<li>在ubuntu下系统下必须有deb格式的安装包</li>
<li>软件安装: <code>sudo dpkg -i xxx.deb</code></li>
<li>软件卸载: <code>sudo dpkg -r 软件名</code></li>
</ul>
<p>dpkg == Debian package</p>
<h2 id="进程相关命令"><a href="#进程相关命令" class="headerlink" title="进程相关命令"></a>进程相关命令</h2><p>ps和<a href="#kill%E5%87%BD%E6%95%B0/%E5%91%BD%E4%BB%A4">kill命令</a></p>
<p>linux绝大多数命令都有对应的函数,例如</p>
<p><code>man kill</code>查询的是命令,<code>man 2 kill</code>查看kill函数 <code>int kill(pid_t pid,int sig);</code></p>
<h3 id="ps命令"><a href="#ps命令" class="headerlink" title="ps命令"></a>ps命令</h3><ul>
<li><p>使用权限：所有使用者</p>
</li>
<li><p>使用方式：ps [options] [–help]</p>
</li>
<li><p>说明：显示瞬间行程 (process) 的动态</p>
</li>
<li><p>常用参数：(ps的参数非常多, 在此仅列出几个常用的参数并大略介绍含义)</p>
<ul>
<li><code>-A</code> 显示所有进程（等价于-e）(utility)</li>
<li><code>-w</code>    显示加宽可以显示较多的资讯</li>
<li><code>-u</code>：查看进程所有者及其他一些信息</li>
<li><code>-a</code> 显示一个终端的所有进程，除了会话引线</li>
<li><code>-N</code> 忽略选择。</li>
<li><code>-d</code> 显示所有进程，但省略所有的会话引线(utility)</li>
<li><code>-x</code> 显示没有控制终端的进程，同时显示各个命令的具体路径。dx不可合用。（utility）</li>
<li><code>-p pid</code> 进程使用cpu的时间</li>
<li><code>-u uid or username</code> 选择有效的用户id或者是用户名</li>
<li><code>-g gid or groupname</code> 显示组的所有进程。</li>
<li><code>U username</code> 显示该用户下的所有进程，且显示各个命令的详细路径。如:ps U zhang;(utility)</li>
<li><code>-f</code> 全部列出，通常和其他选项联用。如：ps -fa or ps -fx and so on.</li>
<li><code>-l</code> 长格式（有F,wchan,C 等字段）</li>
<li><code>-j</code>  列出与作业控制相关的信息</li>
<li><code>-o</code> 用户自定义显示哪些信息。如:<code>ps -o pid,ppid</code>只显示pid和ppid信息</li>
<li><code>v</code> 以虚拟存储器格式显示</li>
<li><code>s</code> 以信号格式显示</li>
<li><code>-m</code> 显示所有的线程</li>
<li><code>-H</code> 显示进程的层次(和其它的命令合用，如：ps -Ha)（utility）</li>
<li><code>e</code> 命令之后显示环境（如：ps -d e; ps -a e）(utility)</li>
<li><code>h</code> 不显示第一行</li>
</ul>
</li>
<li><p>常用用法</p>
<ul>
<li><p><code>ps -ef</code>   </p>
</li>
<li><p><code>ps aux | grep &quot;xxx&quot;</code>   最常用的方法是<code>ps -aux</code>,然后再利用一个管道符号导向到grep去查找特定的进程,然后再对特定的进程进行操作。</p>
</li>
<li><p><code>ps ajx | grep &quot;xxx&quot;</code>  </p>
</li>
</ul>
</li>
<li><p>Head标头</p>
<ul>
<li><code>USER</code>    用户名</li>
<li><code>UID</code>    用户ID（User ID）</li>
<li><code>PID</code>    进程ID（Process ID）</li>
<li><code>PPID</code>    父进程的进程ID（Parent Process id）</li>
<li><code>SID</code>    会话ID（Session id）</li>
<li><code>%CPU</code>    进程的cpu占用率</li>
<li><code>%MEM</code>    进程的内存占用率</li>
<li><code>VSZ</code>    进程所使用的虚存的大小（Virtual Size）</li>
<li><code>RSS</code>    进程使用的驻留集大小或者是实际内存的大小，Kbytes字节。</li>
<li><code>TTY</code>    与进程关联的终端（tty）</li>
<li><code>STAT</code>    进程的状态：进程状态使用字符表示的（STAT的状态码）</li>
<li><code>R</code> 运行    Runnable (on run queue)            正在运行或在运行队列中等待。</li>
<li><code>S</code> 睡眠    Sleeping                休眠中, 受阻, 在等待某个条件的形成或接受到信号。</li>
<li><code>I</code> 空闲    Idle</li>
<li><code>Z</code> 僵死    Zombie（a defunct process)        进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放。</li>
<li><code>D</code> 不可中断    Uninterruptible sleep (ususally IO)    收到信号不唤醒和不可运行, 进程必须等待直到有中断发生。</li>
<li><code>T</code> 终止    Terminate                进程收到SIGSTOP, SIGSTP, SIGTIN, </li>
<li><code>SIGTOU</code>信号后停止运行运行。</li>
<li><code>P</code> 等待交换页</li>
<li><code>W</code> 无驻留页    has no resident pages        没有足够的记忆体分页可分配。</li>
<li>X 死掉的进程</li>
<li><code>&lt;</code> 高优先级进程                    高优先序的进程</li>
<li><code>N</code> 低优先    级进程                    低优先序的进程</li>
<li><code>L</code> 内存锁页    Lock                有记忆体分页分配并缩在记忆体内</li>
<li><code>s</code> 进程的领导者（在它之下有子进程）；</li>
<li><code>l</code> 多进程的（使用 CLONE_THREAD, 类似 NPTL pthreads）</li>
<li><code>+</code> 位于后台的进程组 </li>
<li><code>START</code>    进程启动时间和日期</li>
<li><code>TIME</code>    进程使用的总cpu时间</li>
<li><code>COMMAND</code>    正在执行的命令行命令</li>
<li><code>NI</code>    优先级(Nice)</li>
<li><code>PRI</code>    进程优先级编号(Priority)</li>
<li><code>WCHAN</code>    进程正在睡眠的内核函数名称；该函数的名称是从/root/system.map文件中获得的。</li>
<li><code>FLAGS</code>    与进程相关的数字标识</li>
</ul>
</li>
</ul>
<h3 id="kill命令"><a href="#kill命令" class="headerlink" title="kill命令"></a>kill命令</h3><p>kill 终止（杀死）进程，有十几种控制进程的方法，下面是一些常用的方法:</p>
<ul>
<li><p><code>kill -l</code> 查看系统有哪些信号   </p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202206231654467.jpeg" alt="信号图"></p>
</li>
<li><p><code>kill -STOP [pid]</code> 发送SIGSTOP (17,19,23)停止一个进程，而并不消灭这个进程。</p>
</li>
<li><p><code>kill -CONT [pid]</code> 发送SIGCONT (19,18,25)重新开始一个停止的进程。</p>
</li>
<li><p><code>kill -KILL [pid]/kill -9 [pid]</code> 发送SIGKILL (9)强迫进程立即停止，并且不实施清理操作。</p>
</li>
</ul>
<p>SIGKILL 和 SIGSTOP 信号不能被捕捉、封锁或者忽略，但是，其它的信号可以。所以这是你的终极武器。</p>
<h2 id="linux脚本"><a href="#linux脚本" class="headerlink" title="linux脚本"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43705953/article/details/119137570">linux脚本</a></h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43705953/article/details/119137570">点击跳转</a></p>
<h2 id="linux定时任务"><a href="#linux定时任务" class="headerlink" title="linux定时任务"></a>linux定时任务</h2><p>linux系统,通过修改 <code>/etc/crontab</code>文件(系统任务调度)添加定时任务.</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202208151816868.png"></p>
<p>例子:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">30</span> <span class="number">21</span> * * * /usr/local/etc/rc.d/lighttpd restart       <span class="comment">#每晚的21:30重启apache。</span></span><br><span class="line"><span class="number">45</span> <span class="number">4</span> <span class="number">1</span>,<span class="number">10</span>,<span class="number">22</span> * * /usr/local/etc/rc.d/lighttpd restart  <span class="comment">#每月1、10、22日的4 : 45重启apache。</span></span><br><span class="line"><span class="number">10</span> <span class="number">1</span> * * <span class="number">6</span>,<span class="number">0</span> /usr/local/etc/rc.d/lighttpd restart      <span class="comment">#每周六、周日的1 : 10重启apache</span></span><br><span class="line"><span class="number">0</span>,<span class="number">30</span> <span class="number">18</span>-<span class="number">23</span> * * * /usr/local/etc/rc.d/lighttpd restart  <span class="comment">#每天18 : 00至23 : 00之间每隔30分钟重启apache。</span></span><br><span class="line"><span class="number">0</span> <span class="number">23</span> * * <span class="number">6</span> /usr/local/etc/rc.d/lighttpd restart        <span class="comment">#每星期六的11 : 00 pm重启apache。</span></span><br><span class="line">* */<span class="number">1</span> * * * /usr/local/etc/rc.d/lighttpd restart       <span class="comment">#每一小时重启apache</span></span><br><span class="line">* <span class="number">23</span>-<span class="number">7</span>/<span class="number">1</span> * * * /usr/local/etc/rc.d/lighttpd restart    <span class="comment">#晚上11点到早上7点之间，每隔一小时重启apache</span></span><br><span class="line"><span class="number">0</span> <span class="number">11</span> <span class="number">4</span> * mon-wed /usr/local/etc/rc.d/lighttpd restart  <span class="comment">#每月的4号与每周一到周三的11点重启apache</span></span><br><span class="line"><span class="number">0</span> <span class="number">4</span> <span class="number">1</span> jan * /usr/local/etc/rc.d/lighttpd restart       <span class="comment">#一月一号的4点重启apache</span></span><br><span class="line">*/<span class="number">30</span> * * * * /usr/sbin/ntpdate <span class="number">210.72</span><span class="number">.145</span><span class="number">.44</span>           <span class="comment">#每半小时同步一下时间</span></span><br></pre></td></tr></table></figure>



<h2 id="其他命令盘点"><a href="#其他命令盘点" class="headerlink" title="其他命令盘点"></a>其他命令盘点</h2><p><code>alias</code>  起别名(不加任何东西是查看所有别名)    E.g.  <code>alias psj=&#39;ps -ef |grep jenkins&#39;</code></p>
<p><code>unalias</code> 取消别名   E.g. <code>unalias psj</code></p>
<h1 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h1><blockquote>
<p>vi是”visual interface”的简称, 它在Linux上的地位就仿佛Windows中的记事本一样. 它可以执行编辑、删除、查找、替换、块操作等众多文本操作, 而且用户可以根据自己的需要对其进行定制. vi是一个文本编辑程序, 没有菜单, 只有命令. </p>
<p>vim更高级一些, 可以理解是vi的高级版本.</p>
<p>​    vim需要自行安装, 在shell中输入vimtutor命令可以查看相关的帮助文档.</p>
</blockquote>
<h2 id="vim的三种模式"><a href="#vim的三种模式" class="headerlink" title="vim的三种模式"></a>vim的三种模式</h2><p>Vi有三种基本工作模式: 命令模式、文本输入模式、末行模式。</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/202203101341712.png" alt="image-20220310134131345"></p>
<h3 id="命令模式下的操作"><a href="#命令模式下的操作" class="headerlink" title="命令模式下的操作"></a>命令模式下的操作</h3><p>用户按下esc键, 就可以使vi进入命令模式下; 当使用vi打开一个新文件开始也是进入命令模式下</p>
<h4 id="保存退出"><a href="#保存退出" class="headerlink" title="保存退出"></a>保存退出</h4><table>
<thead>
<tr>
<th>快捷键</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>ZZ</td>
<td>保存退出</td>
</tr>
</tbody></table>
<h4 id="代码的格式化"><a href="#代码的格式化" class="headerlink" title="代码的格式化"></a>代码的格式化</h4><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td align="left">gg=G</td>
<td>代码的格式化</td>
</tr>
</tbody></table>
<h4 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h4><table>
<thead>
<tr>
<th>快捷键</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>h</td>
<td>光标左移</td>
</tr>
<tr>
<td>j</td>
<td>光标下移</td>
</tr>
<tr>
<td>k</td>
<td>光标上移</td>
</tr>
<tr>
<td>l</td>
<td>光标右移</td>
</tr>
<tr>
<td>w</td>
<td>移动一个单词</td>
</tr>
<tr>
<td>gg</td>
<td>光标移动到文件开头</td>
</tr>
<tr>
<td>G</td>
<td>光标移动到文件末尾</td>
</tr>
<tr>
<td>0</td>
<td>光标移动到行首</td>
</tr>
<tr>
<td>$</td>
<td>光标移动到行尾</td>
</tr>
<tr>
<td>nG</td>
<td>行跳转,例:12G,跳转到12行处</td>
</tr>
</tbody></table>
<h4 id="删除命令"><a href="#删除命令" class="headerlink" title="删除命令"></a>删除命令</h4><table>
<thead>
<tr>
<th>快捷键</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>x</td>
<td>删除光标后一个字符,相当于Del</td>
</tr>
<tr>
<td>X</td>
<td>删除光标前一个字符,相当于Backspace</td>
</tr>
<tr>
<td>dw</td>
<td>delete word删除光标开始位置的字,包含光标所在字符</td>
</tr>
<tr>
<td>d0</td>
<td>删除光标前本行所有内容,包含光标所在字符</td>
</tr>
<tr>
<td>D或者是d$</td>
<td>删除光标后本行所有内容,包含光标所在字符</td>
</tr>
<tr>
<td>dd</td>
<td>删除光标所在行(本质其实是剪切)</td>
</tr>
<tr>
<td>ndd</td>
<td>从光标当前行向下删除指定的行数,如:15dd</td>
</tr>
<tr>
<td>v/ctrl+v</td>
<td>使用h,j,k,l移动选择内容,然后按d删除(其中ctrl+v是列模式,v为非列模式)</td>
</tr>
</tbody></table>
<h4 id="撤销和反撤销命令"><a href="#撤销和反撤销命令" class="headerlink" title="撤销和反撤销命令"></a>撤销和反撤销命令</h4><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td align="left">u</td>
<td>一步一步撤销,相当于word文档的ctrl+z</td>
</tr>
<tr>
<td align="left">ctrl+r</td>
<td>反撤销,相当于word文档的ctrl+y</td>
</tr>
</tbody></table>
<h4 id="复制和粘贴"><a href="#复制和粘贴" class="headerlink" title="复制和粘贴"></a>复制和粘贴</h4><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td align="left">yy</td>
<td>复制当前行</td>
</tr>
<tr>
<td align="left">nyy</td>
<td>复制n行,如10yy</td>
</tr>
<tr>
<td align="left">p</td>
<td>在光标所在位置向下开辟一行,粘贴</td>
</tr>
<tr>
<td align="left">P</td>
<td>在光标所在位置向上开辟一行,粘贴</td>
</tr>
<tr>
<td align="left">剪切操作</td>
<td>按dd或ndd山删除,将删除的行保存到剪贴板中,然后按p/P就可以粘贴了</td>
</tr>
</tbody></table>
<h4 id="可视模式"><a href="#可视模式" class="headerlink" title="可视模式"></a>可视模式</h4><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td align="left">v/ctrl+v</td>
<td>使用h、j、k、l移动选择内容;使用d删除;使用y复制,使用p粘贴到光标的后面;使用P粘贴到光标的前面</td>
</tr>
</tbody></table>
<h4 id="替换操作"><a href="#替换操作" class="headerlink" title="替换操作"></a>替换操作</h4><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td align="left">r</td>
<td>替换当前字符</td>
</tr>
<tr>
<td align="left">R</td>
<td>替换当前行光标后的字符</td>
</tr>
</tbody></table>
<h4 id="查找命令"><a href="#查找命令" class="headerlink" title="查找命令"></a>查找命令</h4><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td align="left">/</td>
<td>/xxxx,从光标所在的位置开始搜索,按n向下搜索,按N向上搜索</td>
</tr>
<tr>
<td align="left">?</td>
<td>?xxxx从光标所在的位置开始搜索,按n向下搜索,按N向上搜索</td>
</tr>
<tr>
<td align="left">#</td>
<td>将光标移动到待搜索的的字符串上,然后按n向上搜索,按N向下搜索</td>
</tr>
<tr>
<td align="left">shift+k</td>
<td>在待搜索的字符串上按shift+k或者K,可以查看相关的帮助文档</td>
</tr>
</tbody></table>
<h4 id="快速翻屏"><a href="#快速翻屏" class="headerlink" title="快速翻屏"></a>快速翻屏</h4><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ctrl+u</td>
<td>向下翻半屏(up)–光标向上移动</td>
</tr>
<tr>
<td align="left">ctrl+d</td>
<td>向上翻半屏(down)–光标向下移动</td>
</tr>
<tr>
<td align="left">ctrl+f</td>
<td>向上翻一屏(front)</td>
</tr>
<tr>
<td align="left">ctrl+b</td>
<td>向后翻一屏(back)</td>
</tr>
</tbody></table>
<h4 id="快速定位"><a href="#快速定位" class="headerlink" title="快速定位"></a>快速定位</h4><p><code>shift+%</code>    快速定位到一组括号其中一个对应的另一个括号</p>
<h4 id="切换到文本输入模式"><a href="#切换到文本输入模式" class="headerlink" title="切换到文本输入模式"></a>切换到文本输入模式</h4><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td align="left">i</td>
<td>在光标前插入</td>
</tr>
<tr>
<td align="left">a</td>
<td>在光标后插入</td>
</tr>
<tr>
<td align="left">I</td>
<td>在光标所在行的行首插入</td>
</tr>
<tr>
<td align="left">A</td>
<td>在光标所在行的行尾插入</td>
</tr>
<tr>
<td align="left">o</td>
<td>在光标所在的行的下面新创建一行,行首插入</td>
</tr>
<tr>
<td align="left">O</td>
<td>在光标所在的行的上面新创建一行,行首插入</td>
</tr>
<tr>
<td align="left">s</td>
<td>删除光标后边的字符,从光标当前位置插入</td>
</tr>
<tr>
<td align="left">S</td>
<td>删除光标所在当前行,从行首插入</td>
</tr>
<tr>
<td align="left">按列模式插入</td>
<td>先按ctrl+v进入列模式,按hjkl移动选定某列,按I或者A插入,然后输入字符,最后按两次esc(实现多行同时输入的效果)</td>
</tr>
</tbody></table>
<h4 id="切换到末行模式"><a href="#切换到末行模式" class="headerlink" title="切换到末行模式"></a>切换到末行模式</h4><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td align="left">:</td>
<td>切换到末行模式</td>
</tr>
</tbody></table>
<h3 id="末行模式下的操作"><a href="#末行模式下的操作" class="headerlink" title="末行模式下的操作"></a>末行模式下的操作</h3><p>从命令模式切换到末行模式, 输入冒号(:)</p>
<h4 id="保存退出-1"><a href="#保存退出-1" class="headerlink" title="保存退出"></a>保存退出</h4><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td align="left">q</td>
<td>退出</td>
</tr>
<tr>
<td align="left">q!</td>
<td>强制退出,不保存修改内容</td>
</tr>
<tr>
<td align="left">w</td>
<td>保存修改内容,不退出</td>
</tr>
<tr>
<td align="left">wq</td>
<td>保存并退出</td>
</tr>
<tr>
<td align="left">x</td>
<td>相当于wq</td>
</tr>
</tbody></table>
<h4 id="替换操作-1"><a href="#替换操作-1" class="headerlink" title="替换操作"></a>替换操作</h4><p>下面表格中 <code>old</code> 表示原字符串, <code>new</code> 表示新字符串</p>
<table>
<thead>
<tr>
<th align="left">快捷键</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td align="left">:s/old/new/</td>
<td>光标<strong>所在行</strong>的第一个old替换为new</td>
</tr>
<tr>
<td align="left">:s/old/new/g</td>
<td>光标<strong>所在行</strong>的所有old替换为new</td>
</tr>
<tr>
<td align="left">:m,ns/old/new/g</td>
<td>将第m行至第n行之间的old全部替换为new</td>
</tr>
<tr>
<td align="left">:%s/old/new/g</td>
<td>当前文件的所有old替换为new</td>
</tr>
<tr>
<td align="left">:1,%s/old/new/g</td>
<td>当前文件的所有old替换为new</td>
</tr>
<tr>
<td align="left">:%s/old/new/gc</td>
<td>同上,但是每次替换需要用户确认</td>
</tr>
</tbody></table>
<h4 id="末行模式下执行shell命令"><a href="#末行模式下执行shell命令" class="headerlink" title="末行模式下执行shell命令"></a>末行模式下执行shell命令</h4><p><code>!shell命令</code></p>
<p>按下两次esc可以回到命令模式</p>
<h4 id="分屏操作"><a href="#分屏操作" class="headerlink" title="分屏操作"></a>分屏操作</h4><h5 id="打开文件之前分屏"><a href="#打开文件之前分屏" class="headerlink" title="打开文件之前分屏"></a>打开文件之前分屏</h5><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td align="left">sp</td>
<td>当前文件水平分屏</td>
</tr>
<tr>
<td align="left">vsp</td>
<td>当前文件垂直分屏</td>
</tr>
<tr>
<td align="left">sp 文件名</td>
<td>当前文件和另一个文件水平分屏</td>
</tr>
<tr>
<td align="left">vsp 文件名</td>
<td>当前文件和另一个文件垂直分屏</td>
</tr>
<tr>
<td align="left">Ctrl+w两次</td>
<td>在多个窗口切换光标</td>
</tr>
<tr>
<td align="left">wall/wqall/xall/qall/qall!</td>
<td>保存/保存退出/保存退出/退出/强制退出分屏窗口</td>
</tr>
</tbody></table>
<h5 id="打开文件之后分屏"><a href="#打开文件之后分屏" class="headerlink" title="打开文件之后分屏"></a>打开文件之后分屏</h5><p>分屏: vim -on file1 file2 …  </p>
<p>垂直分屏: vim -On file1 file2…  </p>
<p>注意: n表示分几个屏,可以省略, 有几个文件就分几屏</p>
<h4 id="从末行模式切换回命令模式"><a href="#从末行模式切换回命令模式" class="headerlink" title="从末行模式切换回命令模式"></a>从末行模式切换回命令模式</h4><p>按两次ESC, 退格(backspace)或者回车键</p>
<h2 id="vim的配置文件"><a href="#vim的配置文件" class="headerlink" title="vim的配置文件"></a>vim的配置文件</h2><ul>
<li><p><strong>用户级别配置文件</strong></p>
<p>~/.vimrc, 修改用户级别的配置文件只会影响当前用户, 不会影响其他的用户.</p>
<p>例如: 在用户的家目录下的.vimrc文件中添加</p>
<ul>
<li>set tabstop=4  —-设置缩进4个空格</li>
<li>set nu     —-设置行号</li>
<li>set shiftwidth=4  —设置gg=G缩进4个空格, 默认是缩进8个空格</li>
</ul>
</li>
<li><p><strong>系统级别配置文件</strong></p>
<p>etc/vim/vimrc, 修改了系统级别的配置文件将影响系统下的所有用户.</p>
<p>说明: 由于linux是多用户操作系统, 建议只在用户级别的配置文件下进行修改, 不要影响其他用户.</p>
</li>
</ul>
<h1 id="gcc编译器"><a href="#gcc编译器" class="headerlink" title="gcc编译器"></a>gcc编译器</h1><p>gcc编译器将c源文件到生成一个可执行程序，中间一共经历了四个步骤：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/202203101457076.png" alt="image-20220310145713407"></p>
<p>四个步骤并不是gcc独立完成的，而是在内部调用了其他工具，从而完成了整个工作流程, 其中编译最耗时, 因为要逐行检查语法.</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/202203101458023.png" alt="image-20220310145857517"></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#下面以test.c为例介绍gcc的四个步骤:</span></span><br><span class="line">gcc -E test.c -o test.i</span><br><span class="line">gcc -S test.i -o test.s</span><br><span class="line">gcc -c test.s -o test.o</span><br><span class="line">gcc test.o -o test</span><br><span class="line"><span class="comment">#一步生成最终的可执行程序: </span></span><br><span class="line">gcc test.c -o test</span><br></pre></td></tr></table></figure>

<h2 id="gcc常用参数"><a href="#gcc常用参数" class="headerlink" title="gcc常用参数"></a>gcc常用参数</h2><ul>
<li><p><strong>-v</strong>  查看gcc版本号, –version也可以</p>
</li>
<li><p><strong>-E</strong>  生成预处理文件</p>
</li>
<li><p><strong>-S</strong>  生成汇编文件</p>
</li>
<li><p><strong>-c</strong>  <strong>只编译,</strong> <strong>生成.o文件, 通常称为目标文件</strong></p>
</li>
<li><p><strong>-I</strong>  指定头文件所在的路径</p>
</li>
<li><p><strong>-L</strong>  <strong>指定库文件所在的路径</strong></p>
</li>
<li><p><strong>-l</strong>  <strong>指定库的名字</strong></p>
</li>
<li><p> <strong>-o</strong>  指定生成的目标文件的名字</p>
</li>
<li><p> <strong>-g</strong>  <strong>包含调试信息, 使用gdb调试需要添加-g参数</strong></p>
</li>
<li><p><strong>-On</strong> n=0∼3 编译优化,n越大优化得越多</p>
</li>
<li><p><strong>-Wall</strong> 提示更多警告信息</p>
</li>
<li><p><strong>-D</strong>  编译时定义宏</p>
<p>例:<code>gcc -o test test.c -D MAX=10</code></p>
</li>
</ul>
<p>DEBUG和RELEASE版本的差异</p>
<h1 id="静态库和共享-动态-库"><a href="#静态库和共享-动态-库" class="headerlink" title="静态库和共享(动态)库"></a>静态库和共享(动态)库</h1><blockquote>
<p><em><strong>什么是库</strong></em></p>
<p>  库是二进制文件, 是源代码文件的另一种表现形式, 是加了密的源代码; </p>
<p>是一些功能相近或者是相似的函数的集合体.</p>
</blockquote>
<p>使用库有什么好处</p>
<ul>
<li>提高代码的可重用性, 而且还可以提高程序的健壮性.</li>
<li>可以减少开发者的代码开发量, 缩短开发周期.</li>
</ul>
<p><strong>库制作完成后, 如何给用户使用</strong></p>
<ul>
<li>头文件—包含了库函数的声明</li>
<li>库文件—包含了库函数的代码实现</li>
</ul>
<p>注意: 库不能单独使用, 只能作为其他执行程序的一部分完成某些功能, 也就是说只能被其他程序调用才能使用.</p>
<p>库可分</p>
<ul>
<li>静态库(static library)</li>
<li>共享库(shared library)</li>
</ul>
<h2 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h2><p>静态库可以认为是一些目标代码的集合, 是在可执行程序运行前就已经加入到执行码中, 成为执行程序的一部分. 按照习惯, 一般以.a做为文件后缀名.</p>
<p>静态库的命名一般分为三个部分：</p>
<ul>
<li>前缀：lib</li>
<li>库名称：自定义即可, 如test</li>
<li>后缀：.a</li>
</ul>
<p>所以最终的静态库的名字应该为：libtest.a</p>
<h3 id="静态库的制作"><a href="#静态库的制作" class="headerlink" title="静态库的制作"></a><strong>静态库的制作</strong></h3><p>下面以fun1.c , fun2.c和head.h三个文件为例讲述静态库的制作和使用, 其中head.h文件中有函数的声明,  fun1.c和fun2.c中有函数的实现.</p>
<ul>
<li><p>将c源文件生成对应的.o文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">	gcc -c fun1.c fun2.c</span><br><span class="line"><span class="comment">//或者分别生成.o文件:</span></span><br><span class="line">	gcc -c fun1.c -o fun1.o</span><br><span class="line">	gcc -c fun2.c -o fun2.o</span><br></pre></td></tr></table></figure></li>
<li><p>使用打包工具ar将准备好的.o文件打包为.a文件 </p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  在使用ar工具是时候需要添加参数rcs</span></span><br><span class="line"><span class="comment">#  r更新、c创建、s建立索引</span></span><br><span class="line"><span class="comment">#  命令：ar rcs 静态库名 .o文件</span></span><br><span class="line">ar rcs libtest1.a fun1.o fun2.o</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/202203151108150.png" alt="image-20220315110819829"></p>
</li>
</ul>
<h3 id="静态库的使用"><a href="#静态库的使用" class="headerlink" title="静态库的使用"></a><strong>静态库的使用</strong></h3><p><strong>静态库制作完成之后, 需要将.a文件和头文件一定发布给用户.</strong></p>
<p><strong>[使用静态库时用到的参数]</strong></p>
<ul>
<li><code>-L</code>：指定要连接的库的所在目录</li>
<li><code>-l</code>：指定链接时需要的静态库, 去掉前缀和后缀</li>
<li><code>-I</code>: 指定main.c文件用到的头文件head.h所在的路径</li>
</ul>
<p>假设测试文件为main.c, 静态库文件为libtest1.a, 头文件为head.h</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o main1 main.c -L./ -ltest1 -I./</span><br></pre></td></tr></table></figure>

<h3 id="实际案例"><a href="#实际案例" class="headerlink" title="[实际案例]"></a>[实际案例]</h3><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/202203151556250.jpeg" alt="截屏2022-03-15 15.51.09" style="zoom: 50%;" />

<img src="https://raw.githubusercontent.com/che77a38/blogImage/main/202203151552248.png" style="zoom: 50%;" />

<img src="https://raw.githubusercontent.com/che77a38/blogImage/main/202203151557180.jpeg" alt="截屏2022-03-15 15.53.27" style="zoom: 50%;" />

<img src="https://raw.githubusercontent.com/che77a38/blogImage/main/202203151556430.jpeg" alt="截屏2022-03-15 15.55.14" style="zoom: 50%;" />

<img src="https://raw.githubusercontent.com/che77a38/blogImage/main/202203151559245.jpeg" alt="截屏2022-03-15 15.58.57" style="zoom:50%;" />

<h3 id="静态库的优缺点"><a href="#静态库的优缺点" class="headerlink" title="静态库的优缺点"></a>静态库的优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li><p>函数库最终被打包到应用程序中，实现是函数本地化，寻址方便、速度快。</p>
<p>（库函数调用效率==自定义函数使用效率）</p>
</li>
<li><p>程序在运行时与函数库再无瓜葛，移植方便。</p>
</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>消耗系统资源较大, 每个进程使用静态库都要复制一份, 无端浪费内存。</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/202203151133735.png" alt="image-20220315113303414"></p>
<p>静态库会给程序的更新、部署和发布带来麻烦。如果静态库libxxx.a更新了，所有使用它的应用程序都需要重新编译、发布给用户（对于玩家来说，可能是一个很小的改动，却导致整个程序重新下载）。</p>
<h2 id="共享库-动态库"><a href="#共享库-动态库" class="headerlink" title="共享库/动态库"></a>共享库/动态库</h2><blockquote>
<p>共享库在程序编译时并不会被连接到目标代码中, 而是在程序运行是才被载入. 不同的应用程序如果调用相同的库, 那么在内存里只需要有一份该共享库的拷贝, 规避了空间浪费问题.动态库在程序运行时才被载入, 也解决了静态库对程序的更新、部署和发布会带来麻烦. 用户只需要更新动态库即可, 增量更新. 为什么需要动态库, 其实也是静态库的特点导致. </p>
</blockquote>
<p>照习惯, 一般以”.so”做为文件后缀名. 共享库的命名一般分为三个部分：</p>
<ul>
<li>前缀：lib</li>
<li>库名称：自己定义即可, 如test</li>
<li>后缀：.so</li>
</ul>
<p>所以最终的静态库的名字应该为：libtest.so</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/202203151352511.png" alt="image-20220315135210177"></p>
<h3 id="共享库的制作"><a href="#共享库的制作" class="headerlink" title="共享库的制作"></a><strong>共享库的制作</strong></h3><ul>
<li><p>生成目标文件.o, 此时要加编译选项：-fPIC（fpic）</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -fpic -c fun1.c fun2.c</span><br><span class="line"><span class="comment">#参数：-fpic创建与地址无关的编译程序(pic, position independent code), 目的就是为了能够在多个应用程序间共享.</span></span><br></pre></td></tr></table></figure></li>
<li><p>生成共享库, 此时要加链接器选项: -shared（指定生成动态链接库<strong>）</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared fun1.o fun2.o -o libtest2.so</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="共享库的使用"><a href="#共享库的使用" class="headerlink" title="共享库的使用"></a><strong>共享库的使用</strong></h3><p>引用动态库编译成可执行文件（跟静态库方式一样）：</p>
<p>用到的参数：</p>
<ul>
<li><code>-L</code>：指定要连接的库的所在目录</li>
<li><code>-l</code>：指定链接时需要的动态库, 去掉前缀和后缀</li>
<li><code>-I</code>: 指定main.c文件用到的头文件head.h所在的路径</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -I./ -L./ -ltest2 -o main2</span><br></pre></td></tr></table></figure>

<p>然后运行：<code>./main2</code>，发现竟然报错了.</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/202203151407768.png" alt="image-20220315140737562"></p>
<p><strong>分析为什么在执行的时候找不到libtest2.so库</strong></p>
<p>当系统加载可执行代码时候, 能够知道其所依赖的库的名字, 但是<strong>还需要知道所依赖的库的绝对路径</strong>。此时就需要系统动态载入器(dynamic linker/loader)。</p>
<p><strong>ldd</strong>命令可以查看可执行文件依赖的库文件, 执行<code>ldd main2</code>,可以发现libtest2.so找不到.</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/202203151415703.png" alt="image-20220315141518461"></p>
<p>对于elf格式(windows可执行程序是pe格式的)的可执行程序，是由<strong>ld-linux.so</strong>来完成的, 它先后搜索elf文件的 DT_RPATH段 — 环境变量LD_LIBRARY_PATH — /etc/ld.so.cache文件列表 — /lib/, /usr/lib目录找到库文件后将其载入内存。</p>
<p><strong>使用file命令可以查看文件的类型: <code>file main2</code></strong></p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/202203151410036.png" alt="image-20220315141032823"></p>
<h3 id="让系统找到共享库"><a href="#让系统找到共享库" class="headerlink" title="让系统找到共享库"></a><strong>让系统找到共享库</strong></h3><ul>
<li><p>拷贝自己制作的共享库到<code>/lib</code>或<code>/usr/lib</code></p>
<p>(不推荐,因为里面存放的是系统动态库,尽量不操作这两个文件夹防止出问题)</p>
</li>
<li><p>临时设置LD_LIBRARY_PATH:</p>
<p><code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:库路径</code></p>
</li>
<li><p>永久设置(项目开发基本都是这么做),把<code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:库路径</code>设置到<code>~/.bashrc</code>文件中,然后再执行下列三种办法之一:(mac下环境初始化顺序参考<a href="#mac%E4%B8%8B%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F">此链接</a>)</p>
<ul>
<li><p>执行 <code>. ~/.bashrc</code>使配置文件生效(第一个.后面会有一个空格)</p>
</li>
<li><p>执行 <code>source ~/.bashrc</code>配置文件生效</p>
</li>
<li><p>退出当前终端,然后再次登录也可以使配置文件生效</p>
<img src="https://raw.githubusercontent.com/che77a38/blogImage/main/202203181010547.jpg" alt="截屏2022-03-18 10.07.53" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/che77a38/blogImage/main/202203181021902.jpg" alt="截屏2022-03-18 10.09.34" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/che77a38/blogImage/main/202203181021952.jpeg" alt="截屏2022-03-18 10.08.09" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/che77a38/blogImage/main/202203181022007.jpeg" alt="截屏2022-03-18 10.22.35" style="zoom: 50%;" /></li>
</ul>
</li>
<li><p>永久设置,把<code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:库路径</code>设置到<code>/etc/profile</code>文件中</p>
</li>
<li><p>将其添加到/etc/ld.so.cache文件中</p>
<ol>
<li>编辑 <code>/etc/ld.so.conf</code>文件,加入库文件所在目录的路径</li>
<li>运行 <code>sudo ldconfig -v</code>,该命令会重建 <code>/etc/ld.so.cache</code> 文件</li>
</ol>
</li>
</ul>
<h3 id="实际案例-1"><a href="#实际案例-1" class="headerlink" title="[实际案例]"></a>[实际案例]</h3><img src="https://raw.githubusercontent.com/che77a38/blogImage/main/202203151556250.jpeg" alt="截屏2022-03-15 15.51.09" style="zoom: 50%;" />

<img src="https://raw.githubusercontent.com/che77a38/blogImage/main/202203151628263.jpeg" alt="截屏2022-03-15 16.25.11" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/che77a38/blogImage/main/202203151627052.jpeg" alt="截屏2022-03-15 16.25.30" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/che77a38/blogImage/main/202203151628443.jpeg" alt="截屏2022-03-15 16.25.46" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/che77a38/blogImage/main/202203151629202.jpeg" alt="截屏2022-03-15 16.26.34" style="zoom:50%;" />

<h3 id="mac下环境初始化顺序"><a href="#mac下环境初始化顺序" class="headerlink" title="mac下环境初始化顺序"></a>mac下环境初始化顺序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/etc/profile</span><br><span class="line">/etc/paths</span><br><span class="line">~/.bash_profile</span><br><span class="line">~/.bash_login</span><br><span class="line">~/.profile</span><br><span class="line">~/.bashrc</span><br></pre></td></tr></table></figure>

<p>其中<code>/etc/profile</code>和<code>/etc/paths</code>是系统级别的，系统启动就会加载，<br>后几个是当前用户级的环境变量。后面3个按照从前往后的顺序读取，如果<code>/.bash_profile</code>文件存在，则后面的几个文件就会被忽略不读了，如果<code>/.bash_profile</code>文件不存在，才会以此类推读取后面的文件。<br><code>~/.bashrc</code>没有上述规则，它是bash shell打开的时候载入的。<br>也就是说在当前用户的目录下，如果有了<code>.bash_profile</code>文件就不会去加载<code>.bashrc</code>文件。</p>
<p><strong>上述修改时针对终端时bash的修改，假如终端是<code>zsh</code>的话，需要找到用户目录下的<code>.zlogin</code>文件，加入上述代码</strong></p>
<h3 id="共享库的特点"><a href="#共享库的特点" class="headerlink" title="共享库的特点"></a>共享库的特点</h3><ul>
<li>动态库把对一些库函数的链接载入推迟到程序运行的时期。</li>
<li>可以实现进程之间的资源共享。（因此动态库也称为共享库）</li>
<li>将一些程序升级变得简单。(增量更新)</li>
<li>甚至可以真正做到链接载入完全由程序员在程序代码中控制（显示调用）</li>
</ul>
<h2 id="比较静态库和动态库的优缺点"><a href="#比较静态库和动态库的优缺点" class="headerlink" title="比较静态库和动态库的优缺点"></a>比较静态库和动态库的优缺点</h2><h3 id="静态库-1"><a href="#静态库-1" class="headerlink" title="静态库"></a>静态库</h3><p>优点:</p>
<ol>
<li> 执行速度快, 是因为静态库已经编译到可执行文件内部了</li>
<li>移植方便, 不依赖域其他的库文件</li>
</ol>
<p> 缺点: </p>
<ol>
<li> 耗费内存, 是由于每一个静态库的可执行程序都会加载一次</li>
<li>部署更新麻烦, 因为静态库修改以后所有的调用到这个静态库的可执行文件都需要重新编译</li>
</ol>
<h3 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h3><p>优点:</p>
<ol>
<li> 节省内存</li>
<li>部署升级更新方便, 只需替换动态库即可, 然后再重启服务.</li>
</ol>
<p> 缺点: </p>
<ol>
<li> 加载速度比静态库慢</li>
<li>移植性差, 需要把所有用到的动态库都移植.</li>
</ol>
<p>由于由静态库生成的可执行文件是把静态库加载到了其内部, 所以静态库生成的可执行文件一般会比动态库大.</p>
<h1 id="linux系统API相关"><a href="#linux系统API相关" class="headerlink" title="linux系统API相关"></a>linux系统API相关</h1><h2 id="C库IO理解"><a href="#C库IO理解" class="headerlink" title="C库IO理解"></a>C库IO理解</h2><p><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202206061447162.jpeg" alt="1">exit函数会自动刷新flush</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202206061447137.jpeg" alt="2"></p>
<p>c语言操作文件相关问题:<br>使用fopen函数打开一个文件, 返回一个FILE* fp, 这个指针指向的结构体有三个重要的成员.</p>
<ul>
<li><strong>文件描述符</strong>: 通过文件描述可以找到文件的inode, 通过inode可以找到对应的数据块</li>
<li><strong>文件指针</strong>: 读和写共享一个文件指针, 读或者写都会引起文件指针的变化</li>
<li><strong>文件缓冲区</strong>: 读或者写会先通过文件缓冲区, 主要目的是为了减少对磁盘的读写次数, 提高读写磁盘的效率.</li>
</ul>
<p>备注:</p>
<ul>
<li>头文件stdio.h 的第48行处:  <code>typedef struct _IO_FILE FILE</code>;</li>
<li>头文件libio.h 的第241行处:  <code>struct \_IO_FILE</code>, 这个接头体定义中有一个<code>_fileno</code>成员, 这个就是文件描述符</li>
</ul>
<h2 id="库函数与系统函数的关系"><a href="#库函数与系统函数的关系" class="headerlink" title="库函数与系统函数的关系"></a>库函数与系统函数的关系</h2><p><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202206061507063.jpeg" alt="1.jpg"></p>
<p>FD是file descriptor文件描述符,唯一指向文件块.(类似于windows的句柄)</p>
<p><strong>库函数 是 系统API的进一步封装</strong>,他们的关系是<strong>调用与被调用的关系</strong>.</p>
<p><strong>[系统调用]</strong>: 由操作系统实现并提供给外部应用程序的编程接口,<br>(Application Programming Interface, API), 是应用程序同系统之间数据交互的桥梁.</p>
<h2 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h2><p><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202206061718536.jpeg" alt="1"></p>
<p>读写受保护的地址会导致Segmentation fault.</p>
<p>进程的虚拟地址空间分为用户区和内核区, 其中内核区是受保护的, 用户是不能够对其进行读写操作的;<br>内核区中很重要的一个就是进程管理, 进程管理中有一个区域就是PCB(本质是一个结构体);<br>PCB中有文件描述符表, 文件描述符表中存放着打开的文件描述符, 涉及到文件的IO操作都会用到这个文件描述符.</p>
<h2 id="PCB和文件描述符表"><a href="#PCB和文件描述符表" class="headerlink" title="PCB和文件描述符表"></a>PCB和文件描述符表</h2><p><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202206061728121.jpeg" alt="1"></p>
<p>备注:<br>pcb：结构体:<code>task_stuct</code>, 该结构体在:<br><code>/usr/src/linux-headers-4.4.0-97/include/linux/sched.h:624</code>(linux-headers-4.4.0-97和行号不同版本系统 不一样)<br><strong>一个进程有一个文件描述符表</strong>：1024项</p>
<p><a href="#PCB%E8%AF%A6%E8%A7%A3">PCB详解</a></p>
<ul>
<li>前三个被占用, 分别是STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO  <a target="_blank" rel="noopener" href="https://dontla.blog.csdn.net/article/details/121200247?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1-121200247-blog-116029986.pc_relevant_aa&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1-121200247-blog-116029986.pc_relevant_aa&utm_relevant_index=1">标准输入输出详解</a></li>
<li><strong>文件描述符作用</strong>：通过文件描述符找到inode, 通过inode找到磁盘数据块.</li>
</ul>
<p>虚拟地址空间-&gt;内核区-&gt;PCB-&gt;文件描述表-&gt;文件描述符-&gt;文件IO操作使用文件描述符</p>
<p>文件描述符FD和文件指针是一对一的关系,存在函数 <code>int fileno(FILE *stream);</code> 通过文件指针找到文件描述符</p>
<h2 id="文件IO函数"><a href="#文件IO函数" class="headerlink" title="文件IO函数"></a>文件IO函数</h2><p><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202206081601488.jpeg" alt="1"></p>
<p>每一个FILE文件流（标准C库函数）都有一个缓冲区buffer，默认大小8192Byte。Linux系统的IO函数默认是没有缓冲区.</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202206061447137.jpeg" alt="2"></p>
<p>需要的头文件用 <code>man 2 函数名</code>来查询</p>
<h3 id="open-close"><a href="#open-close" class="headerlink" title="open/close"></a>open/close</h3><p>调用open函数可以打开或创建一个文件, 得到一个文件描述符</p>
<p><strong>open函数</strong></p>
<p>功能:打开或者新建一个文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数参数：<ul>
<li>pathname参数是要打开或创建的文件名,和fopen一样, pathname既可以是相对路径也可以是绝对路径。 </li>
<li>flags参数,表示打开文件所采取的动作,有一系列常数值可供选择, 可以同时选择多个常数用按位或运算符连接起来, 所以这些常数的宏定义都以O_开头,表示or。<ul>
<li>必选项:以下三个常数中必须指定一个, 且仅允许指定一个。<ul>
<li><code>O_RDONLY</code> 只读打开</li>
<li><code>O_WRONLY</code> 只写打开</li>
<li><code>O_RDWR</code> 可读可写打开</li>
</ul>
</li>
<li>以下可选项可以同时指定0个或多个, 和必选项按位或起来作为flags参数。可选项有很多, 这里只介绍几个常用选项：<ul>
<li><code>O_APPEND</code> 表示追加。如果文件已有内容, 这次打开文件所写的数据附加到文件的末尾而不覆盖原来的内容。</li>
<li><code>O_CREAT</code> 若此文件不存在则创建它。使用此选项时需要提供第三个参数mode, 表示该文件的访问权限。</li>
</ul>
</li>
</ul>
</li>
<li>mode参数,设置文件访问权限的初始值(第三个参数是在第二个参数中有<code>O_CREAT</code>时才有作用)<ul>
<li><code>O_EXCL</code> 如果同时指定了<code>O_CREAT</code>,并且文件已存在,则出错返回。</li>
<li><code>O_TRUNC</code> 如果文件已存在, 将其长度截断为为0字节。</li>
<li><code>O_NONBLOCK</code> 对于设备文件, 以O_NONBLOCK方式打开可以做非阻塞I/O(NonblockI/O),非阻塞I/O。</li>
</ul>
</li>
</ul>
</li>
<li>文件最终权限：<code>mode &amp; ~umask</code>  (umark控制如何为新创建的文件设置文件权限掩码,文件初始默认权限为0666，目录为0777,若用户umask为0002,则新创建的文件或目录在没有指定的情况下默认权限分别为0664,0775))   <a target="_blank" rel="noopener" href="https://blog.csdn.net/yangzhengquan19/article/details/83055686">umask详解</a></li>
<li><strong>函数返回值</strong>:<ul>
<li>成功: 返回一个最小且未被占用的文件描述符</li>
<li>失败: 返回-1, 并设置errno值.</li>
</ul>
</li>
</ul>
<p><strong>close函数</strong></p>
<p>功能: 关闭文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数参数:  fd文件描述符</li>
<li>函数返回值:<ul>
<li>成功返回0</li>
<li>失败返回-1, 并设置errno值.</li>
</ul>
</li>
</ul>
<p>需要说明的是,当一个进程终止时, 内核对该进程所有尚未关闭的文件描述符调用close关闭,所以即使用户程序不调用close, 在终止时内核也会自动关闭它打开的所有文件。但是对于一个长年累月运行的程序(比如网络服务器), 打开的文件描述符一定要记得关闭, 否则随着打开的文件越来越多, 会占用大量文件描述符和系统资源。</p>
<h3 id="read-write"><a href="#read-write" class="headerlink" title="read/write"></a>read/write</h3><p><strong>read函数</strong></p>
<p>从打开的设备或文件中读取数据</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数参数:<ul>
<li>fd: 文件描述符</li>
<li>buf: 读上来的数据保存在缓冲区buf中</li>
<li>count: buf缓冲区存放的最大字节数</li>
</ul>
</li>
<li>函数返回值:<ul>
<li><code>&gt;0</code>：读取到的字节数</li>
<li><code>0</code>：文件读取完毕</li>
<li><code>-1</code>： 出错，并设置errno</li>
</ul>
</li>
</ul>
<ol>
<li><a href="#%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E">read函数的默认堵塞状况详细跳转</a></li>
<li><a href="#%E7%AE%A1%E9%81%93%E7%9A%84%E8%AF%BB%E5%86%99%E8%A1%8C%E4%B8%BA">管道read的详细堵塞状况详细跳转</a></li>
</ol>
<p>当read读文件描述符为非阻塞状态的时候, 若对方没有发送数据, 会立刻返回, errno设置为<code>EAGAIN</code>, 这个错误我们要忽略.</p>
<p><strong>write函数</strong></p>
<p>向打开的设备或文件中写数据</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数参数： <ul>
<li>fd：文件描述符</li>
<li>buf：缓冲区，要写入文件或设备的数据</li>
<li>count：buf中数据的长度</li>
</ul>
</li>
<li>函数返回值:<ul>
<li>成功：返回写入的字节数</li>
<li>错误：返回-1并设置errno</li>
</ul>
</li>
</ul>
<h3 id="lseek函数"><a href="#lseek函数" class="headerlink" title="lseek函数"></a>lseek函数</h3><p>功能:移动文件指针</p>
<p>所有打开的文件都有一个<strong>当前文件偏移量(current file offset)</strong>,以下简称为cfo. cfo通常是一个非负整数, 用于表明文件开始处到文件当前位置的字节数. 读写操作通常开始于 cfo, 并且使 cfo 增大, 增量为读写的字节数. 文件被打开时, cfo 会被初始化为 0, 除非使用了 O_APPEND.<br>使用 lseek 函数可以改变文件的 cfo.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">off_t</span> <span class="title">lseek</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数参数：<ul>
<li>fd：文件描述符</li>
<li>参数 offset 的含义取决于参数 whence：<ul>
<li>如果 whence 是 SEEK_SET，文件偏移量将设置为 offset。</li>
<li>如果 whence 是 SEEK_CUR，文件偏移量将被设置为 cfo 加上 offset，offset 可以为正也可以为负。</li>
<li>如果 whence 是 SEEK_END，文件偏移量将被设置为文件长度加上 offset，offset 可以为正也可以为负。</li>
</ul>
</li>
</ul>
</li>
<li>函数返回值: 若lseek成功执行, 则返回新的偏移量。</li>
</ul>
<p>常用操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件指针移动到头部</span></span><br><span class="line">lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line"><span class="comment">//获取文件指针当前位置</span></span><br><span class="line"><span class="keyword">int</span> len = lseek(fd, <span class="number">0</span>, SEEK_CUR);</span><br><span class="line"><span class="comment">//获取文件长度</span></span><br><span class="line"><span class="keyword">int</span> len = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line"><span class="comment">//lseek实现文件拓展</span></span><br><span class="line"><span class="keyword">off_t</span> currpos;</span><br><span class="line"><span class="comment">// 从文件尾部开始向后拓展1000个字节</span></span><br><span class="line">currpos = lseek(fd, <span class="number">1000</span>, SEEK_END); </span><br><span class="line"><span class="comment">// 额外执行一次写操作，否则文件无法完成拓展</span></span><br><span class="line">write(fd, “a”, <span class="number">1</span>);	<span class="comment">// 数据随便写</span></span><br></pre></td></tr></table></figure>

<h3 id="perror和errno"><a href="#perror和errno" class="headerlink" title="perror和errno"></a>perror和errno</h3><p>errno是一个<strong>全局变量</strong>(需要头文件 <code>#include&lt;errno.h&gt;</code>,可以使用命令 <code>man errno</code>查询 ),当系统调用后若出错会对errno进行设置,perror可以将errno对应的错误描述信息打印出来.</p>
<p>errno宏:在 <code>/usr/include/asm-generic/errno.h</code>包含了errno所有的宏和对应的错误描述信息</p>
<p>如: <code>perror(&quot;open&quot;);</code>  打印出来的结果为:  <code>open:(空格)错误信息</code></p>
<h3 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h3><p>阻塞和非阻塞是文件本身的属性, 不是read函数的属性</p>
<ul>
<li>普通文件：hello.c<ul>
<li>默认是非阻塞的</li>
</ul>
</li>
<li>终端设备：如 /dev/tty<ul>
<li>默认阻塞</li>
</ul>
</li>
<li>管道和套接字<ul>
<li><a href="%E7%AE%A1%E9%81%93%E7%9A%84%E8%AF%BB%E5%86%99%E8%A1%8C%E4%B8%BA">默认阻塞(点击跳转详解)</a></li>
</ul>
</li>
</ul>
<p><code>STDIN_FILENO,STDOUT_FILENO,STDERR_FILENO</code>三个已经默认打开的文件描述符的宏,可以直接拿来使用,无需<code>open函数</code></p>
<h3 id="stat-lstat函数"><a href="#stat-lstat函数" class="headerlink" title="stat/lstat函数"></a>stat/lstat函数</h3><p>获取文件的属性</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, struct stat *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lstat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, struct stat *buf)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数返回值： <ul>
<li>成功返回 0</li>
<li>失败返回 -1</li>
</ul>
</li>
</ul>
<p>参数pathname是文件路径</p>
<p>参数 buf是输出参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">	    <span class="keyword">dev_t</span>          st_dev;        <span class="comment">//文件的设备编号</span></span><br><span class="line">	    <span class="keyword">ino_t</span>           st_ino;        <span class="comment">//节点</span></span><br><span class="line">	    <span class="keyword">mode_t</span>         st_mode;      <span class="comment">//文件的类型和存取的权限</span></span><br><span class="line">	    <span class="keyword">nlink_t</span>         st_nlink;     <span class="comment">//连到该文件的硬连接数目，刚建立的文件值为1</span></span><br><span class="line">	    <span class="keyword">uid_t</span>           st_uid;       <span class="comment">//用户ID</span></span><br><span class="line">	    <span class="keyword">gid_t</span>           st_gid;       <span class="comment">//组ID</span></span><br><span class="line">	    <span class="keyword">dev_t</span>          st_rdev;      <span class="comment">//(设备类型)若此文件为设备文件，则为其设备编号</span></span><br><span class="line">	    <span class="keyword">off_t</span>          st_size;      <span class="comment">//文件字节数(文件大小)</span></span><br><span class="line">	    <span class="keyword">blksize_t</span>       st_blksize;   <span class="comment">//块大小(文件系统的I/O 缓冲区大小)</span></span><br><span class="line">	    <span class="keyword">blkcnt_t</span>        st_blocks;    <span class="comment">//块数</span></span><br><span class="line">	    <span class="keyword">time_t</span>         st_atime;     <span class="comment">//最后一次访问时间</span></span><br><span class="line">	    <span class="keyword">time_t</span>         st_mtime;     <span class="comment">//最后一次修改时间(较有用)</span></span><br><span class="line">	    <span class="keyword">time_t</span>         st_ctime;     <span class="comment">//最后一次改变时间(指属性)</span></span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>

<p>上述结构体中有一个成员叫<code>st_mode</code> </p>
<p><strong><code>st_mode</code>详解</strong>    16位整形   表示文件的类型和存取的权限(文件类型互斥,权限非互斥)</p>
<ul>
<li><p>0~2位    其他人权限   </p>
<ul>
<li><code>S_IROTH</code>     00004       读权限        </li>
<li><code>S_IWOTH</code>    00002       写权限        </li>
<li><code>S_IXOTH</code>      00001       执行权限   </li>
<li><code>S_IRWXO</code>     00007        掩码,过滤去掉st_mode中除其他人权限以外的信息</li>
</ul>
</li>
<li><p>3~5位     所属组权限</p>
<ul>
<li><code>S_IRGRP</code>       00040       读权限</li>
<li><code>S_IWGRP</code>      00020       写权限</li>
<li><code>S_IXGRP</code>       00010       执行权限   </li>
<li><code>S_IRWXG</code>      00070        掩码, 过滤去掉 st_mode中除所属组权限以外的信息</li>
</ul>
</li>
<li><p>6-8 位    文件所有者权限</p>
<ul>
<li><p><code>S_IRUSR</code>    00400    读权限</p>
</li>
<li><p><code>S_IWUSR</code>   00200    写权限</p>
</li>
<li><p><code>S_IXUSR</code>    00100     执行权限</p>
</li>
<li><p><code>S_IRWXU</code>   00700    掩码, 过滤去掉 st_mode中除文件所有者权限以外的信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">If (st_mode &amp; S_IRUSR)   -----为真表明所有者可读</span><br><span class="line">If (st_mode &amp; S_IWUSR)  ------为真表明所有者可写</span><br><span class="line">If (st_mode &amp; S_IXUSR)   ------为真表明所有者可执行</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>12-15 位   文件类型   下面属性互斥</p>
<ul>
<li><p><code>S_IFSOCK</code>         0140000 套接字</p>
</li>
<li><p><code>S_IFLNK</code>          0120000 符号链接（软链接）</p>
</li>
<li><p><code>S_IFREG</code>          0100000 普通文件</p>
</li>
<li><p><code>S_IFBLK</code>           0060000 块设备</p>
</li>
<li><p><code>S_IFDIR</code>           0040000 目录</p>
</li>
<li><p><code>S_IFCHR</code>           0020000 字符设备</p>
</li>
<li><p><code>S_IFIFO</code>           0010000 管道</p>
</li>
<li><p><code>S_IFMT</code>              0170000 掩码,过滤去掉 st_mode中除文件类型以外的信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">If ((st_mode &amp; S_IFMT)==S_IFREG) ----为真普通文件</span><br><span class="line"><span class="keyword">if</span>(S_ISREG(st_mode))   ------为真表示普通文件</span><br><span class="line"><span class="keyword">if</span>(S_ISDIR(st.st_mode))  ------为真表示目录文件</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="文件类型获取案例"><a href="#文件类型获取案例" class="headerlink" title="文件类型获取案例"></a>文件类型获取案例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((sb.st_mode &amp; S_IFMT) == S_IFREG)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//是普通文件</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>((sb.st_mode &amp; S_IFMT) == S_IFDIR)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//目录文件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用宏的用法</span></span><br><span class="line"><span class="keyword">if</span>(S_ISREG(sb.st_mode))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//是普通文件</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(S_ISDIR(sb.st_mode))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//目录文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>stat函数和lstat函数的区别</strong></p>
<ul>
<li>stat函数获取链接文件属性,获取到的是链接文件<strong>指向的文件的属性</strong></li>
<li>lstat函数获取链接文件属性,获取到的是链接文件<strong>本身的属性</strong></li>
</ul>
<h3 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h3><p>主要函数如下:</p>
<ul>
<li>打开目录  <code>opendir</code></li>
<li>读目录  <code>readdir</code></li>
<li>关闭目录 <code>closedir</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DIR *pDir = opendir(<span class="string">&quot;dir&quot;</span>);  <span class="comment">//打开目录</span></span><br><span class="line">dirent p=<span class="literal">NULL</span>;<span class="comment">//用于接受readdir的返回值,dirent结构体</span></span><br><span class="line"><span class="keyword">while</span>((p = readdir(pDir))!=<span class="literal">NULL</span>)&#123;&#125;  <span class="comment">//循环读取文件</span></span><br><span class="line">closedir(pDir);  <span class="comment">//关闭目录</span></span><br></pre></td></tr></table></figure>

<h4 id="opendir函数"><a href="#opendir函数" class="headerlink" title="opendir函数"></a>opendir函数</h4><p>打开一个目录 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DIR *<span class="title">opendir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数返回值: 指向目录的指针</li>
<li>函数参数: 要遍历的目录(相对路径或者绝对路径)</li>
</ul>
<h4 id="readdir函数"><a href="#readdir函数" class="headerlink" title="readdir函数"></a>readdir函数</h4><p>读取目录内容–目录项</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct dirent *<span class="title">readdir</span><span class="params">(DIR *dirp)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数返回值: 读取的目录项指针</li>
<li>函数参数: opendir函数的返回值</li>
</ul>
<h5 id="dirent结构体"><a href="#dirent结构体" class="headerlink" title="dirent结构体"></a>dirent结构体</h5><p>记录目录项信息</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202206121613690.jpeg" alt="无标题"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//linux</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">ino_t</span> d_ino;             <span class="comment">// 此目录进入点的inode</span></span><br><span class="line">  <span class="keyword">off_t</span> d_off;              <span class="comment">// 目录文件开头至此目录进入点的位移</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">short</span> <span class="keyword">int</span> d_reclen;   <span class="comment">// d_name 的长度, 不包含NULL 字符</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> d_type;     <span class="comment">// d_name 所指的文件类型 </span></span><br><span class="line">  <span class="keyword">char</span> d_name[<span class="number">256</span>];	    <span class="comment">// 文件名</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//mac</span></span><br><span class="line"><span class="comment">//dirent结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> __<span class="title">DARWIN_STRUCT_DIRENTRY</span>;</span></span><br><span class="line"><span class="comment">//64位系统下:</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __DARWIN_STRUCT_DIRENTRY &#123; \</span></span><br><span class="line"><span class="meta">	__uint64_t  d_ino;      <span class="comment">/* file number of entry */</span> \</span></span><br><span class="line"><span class="meta">	__uint64_t  d_seekoff;  <span class="comment">/* seek offset (optional, used by servers) */</span> \</span></span><br><span class="line"><span class="meta">	__uint16_t  d_reclen;   <span class="comment">/* length of this record */</span> \</span></span><br><span class="line"><span class="meta">	__uint16_t  d_namlen;   <span class="comment">/* length of string in d_name */</span> \</span></span><br><span class="line"><span class="meta">	__uint8_t   d_type;     <span class="comment">/* 文件类型file type, see below */</span> \</span></span><br><span class="line"><span class="meta">	char      d_name[__DARWIN_MAXPATHLEN]; <span class="comment">/* 文件名entry name (up to MAXPATHLEN bytes) */</span> \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure>

<p>d_type的取值: </p>
<ul>
<li><code>DT_BLK</code> - 块设备</li>
<li><code>DT_CHR</code> - 字符设备</li>
<li><code>DT_DIR</code> - 目录</li>
<li><code>DT_LNK</code> - 软连接</li>
<li><code>DT_FIFO</code> - 管道</li>
<li><code>DT_REG</code> - 普通文件</li>
<li><code>DT_SOCK</code> - 套接字</li>
<li><code>DT_UNKNOWN</code> - 未知</li>
</ul>
<h4 id="closedir函数"><a href="#closedir函数" class="headerlink" title="closedir函数"></a>closedir函数</h4><p>关闭目录</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">closedir</span><span class="params">(DIR *dirp)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数返回值: 成功返回0, 失败返回-1</li>
<li>函数参数: opendir函数的返回值</li>
</ul>
<h4 id="案例实现代码"><a href="#案例实现代码" class="headerlink" title="案例实现代码"></a><strong>案例实现代码</strong></h4><p>此处代码不是递归遍历,如果是递归遍历,需要特别注意: <strong>递归遍历指定目录下的所有文件的时候, 要过滤掉.和..文件, 否则会进入死循环</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DIR *pDir = opendir(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(pDir==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;opendir  error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dirent* pDirent = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>((pDirent = readdir(pDir))!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;==================&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; pDirent-&gt;d_name &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">         <span class="comment">//打印类型</span></span><br><span class="line">    <span class="keyword">switch</span>(pDirent-&gt;d_type)</span><br><span class="line">        &#123;</span><br><span class="line">         <span class="keyword">case</span> DT_REG:</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;普通文件&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> DT_DIR:</span><br><span class="line">             <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;目录文件&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> DT_LNK:</span><br><span class="line">             <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;链接文件&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202206121550194.jpeg" alt="截屏2022-06-12 15.49.25"></p>
<h3 id="dup-dup2-fcntl"><a href="#dup-dup2-fcntl" class="headerlink" title="dup/dup2/fcntl"></a>dup/dup2/fcntl</h3><p><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202206181305314.jpeg" alt="无标题"></p>
<p>当调用dup函数之后,newfd和fd都指向了同一个文件,内核会在内部维护一个计数,此时计数为2,当close一个文件描述符之后,这个计数变为1,<strong>只有当计数为0时,文件才会被真正关闭</strong></p>
<h4 id="dup函数"><a href="#dup函数" class="headerlink" title="dup函数"></a>dup函数</h4><p>复制文件描述符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> oldfd)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数参数: oldfd -要复制的文件描述符</li>
<li>函数返回值:<ul>
<li>成功: 返回最小且没被占用的文件描述符</li>
<li>失败: 返回-1, 设置errno值</li>
</ul>
</li>
</ul>
<h4 id="dup2函数"><a href="#dup2函数" class="headerlink" title="dup2函数"></a>dup2函数</h4><p>复制文件描述符(可用于标准输入输出重定向)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> oldfd, <span class="keyword">int</span> newfd)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数参数: <ul>
<li>oldfd-原来的文件描述符</li>
<li>newfd-复制成的新的文件描述符</li>
</ul>
</li>
<li>函数返回值:<ul>
<li>成功: 将oldfd复制给newfd, 两个文件描述符指向同一个文件</li>
<li>失败: 返回-1, 设置errno值</li>
</ul>
</li>
<li>假设newfd已经指向了一个文件，<strong>首先close原来打开的文件</strong>(无需自己手动close)，然后newfd指向oldfd指向的文件.</li>
<li>若newfd没有被占用，<strong>newfd指向oldfd指向的文件</strong>.(newfd重定向到oldfd)</li>
</ul>
<p><strong>dup2实现标准输出重定向到文件案例</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(argv[<span class="number">1</span>],O_RDWR | O_CREAT , <span class="number">777</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;       </span><br><span class="line">    dup2(fd,STDOUT_FILENO);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;hello world!&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    close(fd);</span><br><span class="line">  	close(STDOUT_FILENO);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标准输入 : <code>dup2(xxxfd,STDIN_FILENO);</code>标准输入重定向后,依然需要写标准输入函数来供用户输入,输入的内容重定向到xxxfd</p>
<h4 id="fcntl函数"><a href="#fcntl函数" class="headerlink" title="fcntl函数"></a>fcntl函数</h4><p>改变已经打开的文件的属性</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ... <span class="comment">/* arg */</span> )</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>若cmd为<code>F_DUPFD</code>, 复制文件描述符, 与dup相同</p>
</li>
<li><p>若cmd为<code>F_GETFL</code>, 获取文件描述符的flag属性值</p>
</li>
<li><p>若cmd为 <code>F_SETFL</code>, 设置文件描述符的flag属性</p>
</li>
<li><p>函数返回值:返回值取决于cmd</p>
<ul>
<li>成功<ul>
<li>若cmd为<code>F_DUPFD</code>, 返回一个新的文件描述符</li>
<li>若cmd为<code>F_GETFL</code>, 返回文件描述符的flags值</li>
<li>若cmd为 <code>F_SETFL</code>, 返回0</li>
</ul>
</li>
<li>失败返回-1, 并设置errno值.</li>
</ul>
</li>
<li><p>fcntl函数常用的操作:</p>
<ul>
<li><p>1 复制一个新的文件描述符:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> newfd = fcntl(fd, F_DUPFD, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>2 获取文件的属性标志</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> flag = fcntl(fd, F_GETFL, <span class="number">0</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>3 设置文件状态标志(flags就是调用<a href="#open/close">open函数</a>提供的参数flags)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flag = flag | O_APPEND;</span><br><span class="line">fcntl(fd, F_SETFL, flag);</span><br></pre></td></tr></table></figure></li>
<li><p>4 常用的属性标志</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">O_APPEND-----设置文件打开为末尾添加</span><br><span class="line">O_NONBLOCK-----设置打开的文件描述符为非阻塞</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>学习目标</p>
<ul>
<li>了解进程相关概念</li>
<li>掌握<strong>fork</strong>/getpid/getppid函数的使用</li>
<li>数量掌握ps/kill命令的使用</li>
<li>熟练掌握execl/execlp函数的使用</li>
<li>了解孤儿进程和僵尸进程</li>
<li><strong>wait</strong>函数和<strong>waitpid</strong>函数</li>
</ul>
<p>程序和进程</p>
<ul>
<li>程序:编译好的二进制文件,占用磁盘空间,是一个静态概念</li>
<li>进程:一个启动的程序,占用的是系统资源,如:物理内存,CPU,终端等</li>
</ul>
<h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><ul>
<li><p><strong>并发</strong>:在一个时间段内,是在同一个cpu上,运行多个进程</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202206211417434.jpeg" alt="无标题"></p>
</li>
<li><p><strong>并行</strong>:多个程序在同一时刻发生(需要有多颗cpu)</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202206211418742.jpeg" alt="无标题"></p>
</li>
</ul>
<h3 id="PCB详解"><a href="#PCB详解" class="headerlink" title="PCB详解"></a>PCB详解</h3><p>每个进程在内核中都有一个进程控制块（PCB）来维护进程相关的信息，Linux内核的进程控制块是task_struct结构体。</p>
<p>pcb记录了如下信息:</p>
<ul>
<li><p><strong>进程id</strong>。系统中每个进程有唯一的id，在C语言中用pid_t类型表示，其实就是一个非负整数。</p>
</li>
<li><p><strong>进程的状态</strong>，有就绪、运行、挂起、停止等状态。</p>
</li>
<li><p>进程切换时需要保存和恢复的一些CPU寄存器。</p>
</li>
<li><p>描述虚拟地址空间的信息。</p>
</li>
<li><p>描述控制终端的信息。</p>
</li>
<li><p><strong>当前工作目录</strong>（Current Working Directory）。</p>
<ul>
<li><code>getcwd(获取当前工作目录函数) -- chdir(修改当前工作目录函数) --pwd(linux命令)</code></li>
</ul>
</li>
<li><p>**<a target="_blank" rel="noopener" href="https://blog.csdn.net/yangzhengquan19/article/details/83055686">umask掩码</a>**。</p>
</li>
<li><p><strong>文件描述符表</strong>，包含很多指向file结构体的指针。</p>
</li>
<li><p>和信号相关的信息。</p>
</li>
<li><p>用户id和组id。</p>
</li>
<li><p>会话（Session）和进程组。</p>
</li>
<li><p>进程可以使用的资源上限（Resource Limit）。</p>
<ul>
<li><p><code>ulimit -a</code></p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202206211433823.jpeg" alt="截屏2022-06-21 14.31.56"></p>
</li>
</ul>
</li>
</ul>
<h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>进程基本的状态有5种</p>
<ul>
<li>初始态(进程准备阶段,常与就绪态结合来看)</li>
<li>就绪态</li>
<li>运行态</li>
<li>挂起态</li>
<li>终止态</li>
</ul>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202206211525270.jpeg" alt="无标题"></p>
<p>SIGSTOP是个信号</p>
<h3 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h3><p>fork函数</p>
<p>复制创建子进程(<a href="#%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4">用户区内存</a>完全一样)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<ul>
<li>调用成功: <strong>父进程返回子进程的PID，子进程返回0</strong>；</li>
<li>调用失败: 返回-1，设置errno值。</li>
</ul>
<p>fork代码案例(箭头标识执行时机)</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202206211528595.jpeg" alt="无标题"></p>
<p>子进程从fork函数后一句开始执行.(因为,fork出来的子进程与父进程用户区是复制出来的,因此fork出来的子进程开始的变量与调用fork函数后的父进程此时变量完全一样)</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202206211529165.jpeg" alt="无标题"></p>
<ul>
<li>linux提供了函数供子进程获取其父进程,但父进程要获取子进程pid只能在创建的时候获取.</li>
<li>父子进程谁先抢到cpu时间片,谁先执行.</li>
<li>子进程的pid和父进程不一样，是新分配的。子进程的ppid会设置为父进程的pid，也就是说子进程和父进程各自的“父进程”是不一样的。</li>
<li><strong><a href="#PCB%E5%92%8C%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8">描述符表</a>是按进程的</strong>，因此系统中的每个进程都可以在每个描述符表槽中打开一个不同的文件 但实际上它有点复杂。如果两个进程独立地打开一个文件，那么它们每个进程都有完全独立的文件访问权限，并且有自己的读写指针，只有当它们都写入同一个文件时才会进行交互。 但是<strong>当进程fork的时候，父和子的描述符指向同一个文件表条目</strong>，因此它们在文件中共享一个指针位置。这使Unix进程可以共享对输入流的访问，而无需了解这种情况。</li>
</ul>
<p><strong>[注意]<strong>父进程先于子进程被终止的话,子</strong>进程会被1号pid进程接管</strong>(子进程的新父进程pid为1),<strong>1号pid的进程的父进程pid为0</strong></p>
<p><a href="#%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4">进程相关命令跳转</a></p>
<p><strong>fork注意点</strong>:<strong>如果在循环中fork一定要注意避免未预期的递归fork情况.</strong></p>
<h3 id="进程相关函数"><a href="#进程相关函数" class="headerlink" title="进程相关函数"></a>进程相关函数</h3><h4 id="exit-函数"><a href="#exit-函数" class="headerlink" title="exit()函数"></a>exit()函数</h4><p>退出整个进程,包括所有进程下线程.但不影响子进程与父进程.</p>
<h4 id="getpid和getppid"><a href="#getpid和getppid" class="headerlink" title="getpid和getppid"></a>getpid和getppid</h4><p><code>pid_t getpid(void);</code>  获取自身进程id</p>
<p><code>pid_t getppid(void);</code>  获取父进程id</p>
<h4 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a>exec函数族</h4><p>需要在一个进程里面<strong>执行其他的命令或者是用户自定义的应用程序</strong>，此时就用到了exec函数族当中的函数。</p>
<h5 id="execl函数"><a href="#execl函数" class="headerlink" title="execl函数"></a>execl函数</h5><p>execl函数一般<strong>执行自己写的程序</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ... <span class="comment">/* (char  *) NULL */</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>参数介绍：<ul>
<li><strong>path</strong>: 要执行的程序的绝对/相对路径</li>
<li>变参arg: 要执行的程序的需要的参数</li>
<li>arg:占位，通常写命令的名字(除非有意让别人看不到)</li>
<li>arg后面的: 命令的参数</li>
<li>NULL结尾(最后一个参数)</li>
</ul>
</li>
<li>返回值：<ul>
<li>若是成功，则不返回，不会再执行exec函数后面的代码；若是失败，会执行execl后面的代码，可以用perror打印错误原因。</li>
</ul>
</li>
</ul>
<h5 id="execlp函数"><a href="#execlp函数" class="headerlink" title="execlp函数"></a>execlp函数</h5><p>execlp函数一般是<strong>执行系统自带的程序或者是命令</strong>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...<span class="comment">/* (char  *) NULL */</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>参数介绍：<ul>
<li><strong>file</strong>: 执行命令的名字, 根据PATH环境变量来搜索该命令</li>
<li>arg:占位，通常写应用程序的名字(除非有意让别人看不到)</li>
<li>arg后面的: 命令的参数</li>
<li>NULL结尾(最后一个参数)</li>
</ul>
</li>
<li>返回值：<ul>
<li>若是成功，则不返回，不会再执行exec函数后面的代码；<strong>若是失败，会执行exec后面的代码</strong>，可以用perror打印错误原因。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">execl(<span class="string">&quot;/bin/ls&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-l&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//上面等同于下面</span></span><br><span class="line">execlp(<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-l&quot;</span>,<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<h5 id="exec函数族原理"><a href="#exec函数族原理" class="headerlink" title="exec函数族原理"></a>exec函数族原理</h5><p><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202206231907967.jpeg" alt="无标题"></p>
<p><strong>[注意]<strong>当execl和execlp函数执行成功后，</strong>不返回</strong>，并且<strong>不会执行execl后面的代码逻辑，原因是调用execl函数成功以后，exec函数指定的代码段已经将原有的代码段替换了</strong>。</p>
<p>因此一般先fork一个子进程,在子进程中调用exec函数族.</p>
<h4 id="进程回收函数"><a href="#进程回收函数" class="headerlink" title="进程回收函数"></a>进程回收函数</h4><h5 id="wait函数"><a href="#wait函数" class="headerlink" title="wait函数"></a>wait函数</h5><p>作用:</p>
<ul>
<li><strong>阻塞</strong>并等待子进程退出 </li>
<li>回收子进程残留资源 </li>
<li>获取子进程结束状态(退出原因)。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> *status)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>返回值：<ul>
<li>成功：清理掉的子进程ID；</li>
<li>失败：-1 (没有子进程)</li>
</ul>
</li>
<li><strong>status参数</strong>：子进程的退出状态(<strong>不关心可以写NULL</strong>) – <strong>传出参数</strong><ul>
<li><code>WIFEXITED(status)</code>：为非0        → 进程正常结束</li>
<li><code>WEXITSTATUS(status)</code>：获取进程退出状态 </li>
<li><code>WIFSIGNALED(status)</code>：为非0 → 进程异常终止</li>
<li><code>WTERMSIG(status)</code>：取得进程终止的信号编号。</li>
</ul>
</li>
</ul>
<h5 id="waitpid函数"><a href="#waitpid函数" class="headerlink" title="waitpid函数"></a>waitpid函数</h5><p>作用同<a href="#wait%E5%87%BD%E6%95%B0">wait函数</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *status, in options)</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li><p><strong>pid</strong>：</p>
<ul>
<li><p>pid = -1 等待任一子进程。与wait等效。</p>
</li>
<li><p>pid &gt; 0 等待其进程ID与pid相等的子进程。</p>
</li>
<li><p>pid = 0 等待进程组ID与目前进程相同的任何子进程，也就是说任何和调用</p>
<p>waitpid()函数的进程在同一个进程组的进程。</p>
</li>
<li><p>pid &lt; -1 等待其组ID等于pid的绝对值的任一子进程。(适用于子进程在其他组的情况)</p>
</li>
</ul>
</li>
<li><p><strong>status</strong>: 子进程的退出状态，用法同<a href="#wait%E5%87%BD%E6%95%B0">wait函数</a>。</p>
</li>
<li><p><strong>options</strong>：设置为WNOHANG，函数非阻塞，设置为0，函数阻塞。</p>
</li>
</ul>
<p>函数返回值</p>
<ul>
<li><code>&gt;0</code>：返回回收掉的子进程ID；</li>
<li><code>-1</code>：无子进程(实际上官方文档中是错误返回-1,但无子进程的错误也是返回-1,没别的情况)</li>
<li><code>=0</code>：参3为WNOHANG，且子进程正在运行。</li>
</ul>
<p><strong>案例</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid&gt;<span class="number">0</span>)<span class="comment">//父进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> status;</span><br><span class="line">        <span class="keyword">pid_t</span> wpid = waitpid(<span class="number">-1</span>,&amp;status,<span class="number">0</span>);<span class="comment">//堵塞</span></span><br><span class="line">        <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;孩子正常退出   status=&quot;</span>&lt;&lt;WEXITSTATUS(status)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(wpid==<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;子进程还在运行&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(wpid==<span class="number">-1</span>)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;子进程已全部正常退出&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(WIFSIGNALED(status))</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;孩子被信号杀死  信号编号为:&quot;</span>&lt;&lt;WTERMSIG(status)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;father over!&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="comment">//子进程</span></span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;son over!&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>[注意]wali或waitpid调用一次只能清理一个子进程</strong></p>
<h3 id="进程回收"><a href="#进程回收" class="headerlink" title="进程回收"></a>进程回收</h3><p>当一个进程退出之后，进程能够回收自己的用户区的资源，但是不能回收内核空间的PCB资源，<strong>必须由它的父进程调用wait或者waitpid函数完成对子进程的回收</strong>，避免造成系统资源的浪费。</p>
<h4 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h4><p><strong>[孤儿进程的概念]<strong>：若</strong>子进程的父进程已经死掉，而子进程还存活着</strong>，这个进程就成了孤儿进程。</p>
<p>为了保证每个进程都有一个父进程，孤儿进程会被init进程(pid为1)领养，init进程成为了孤儿进程的养父进程，当孤儿进程退出之后，由init进程完成对孤儿进程的回收。</p>
<h4 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h4><p><strong>[僵尸进程的概念]</strong>:   若<strong>子进程死了，父进程还活着</strong>， 但是父进程没有调用wait或waitpid函数完成对子进程的回收，则该子进程就成了僵尸进程。</p>
<blockquote>
<p>僵尸进程是一种早已死亡的进程,僵尸进程的用户空间内存已经释放掉了,然而内核空间内存还有残留.僵尸进程已经放弃了几乎所有的内存空间,没有任何可执行代码,也不能被调度,仅仅在进程列表中保留一个位置,记载该进程的退出状态信息供其他进程收集.除此之外,僵尸进程不再占有任何存储变量.他需要他的父进程来为他收尸.子进程执行完毕后发送一个Exit信号然后死掉,这个Exit信号需要被父进程读取,父进程随后调用wait命令来读取子进程的退出状态,并将子进程从进程表中剔除.如果他的父进程没有安装SIGCHLD信号处理函数调用wait或waitpid()等待子进程结束或者父进程未能读取到子进程的Exit信号,则这个子进程虽然完成执行处于死亡状态,但也不会从进程表中剔除,那么他就一直保持僵尸状态.</p>
</blockquote>
<p>如何解决僵尸进程</p>
<ul>
<li>由于僵尸进程是一个已经死亡的进程，所以不能使用kill命令将其杀死</li>
<li><strong>通过杀死其父进程的方法可以消除僵尸进程。</strong><br><strong>杀死其父进程后，这个僵尸进程会被init进程领养，由init进程完成对僵尸进程的回收。</strong></li>
</ul>
<p><code>ps -ef</code>中CMD属性后有<code>&lt;defunct&gt;</code>,表示该进程是僵尸进程</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202206241336368.jpeg" alt="截屏2022-06-24 13.34.06"></p>
<p>如何找到defunct僵尸进程: <code>ps -ef |grep defunct_process_pid</code></p>
<p><a href="#%E8%BF%9B%E7%A8%8B%E5%9B%9E%E6%94%B6%E5%87%BD%E6%95%B0">进程回收相关函数跳转</a></p>
<p>完善的进程回收案例应该参考<a href="#%E4%BD%BF%E7%94%A8SIGCHLD%E4%BF%A1%E5%8F%B7%E5%AE%8C%E6%88%90%E5%AF%B9%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9B%9E%E6%94%B6%E6%A1%88%E4%BE%8B">此处</a></p>
<h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a><strong>进程间通信</strong></h3><p>目标:</p>
<ul>
<li>熟练使用pipe进行父子进程间通信</li>
<li>熟练使用pipe进行兄弟进程间通信</li>
<li>熟练使用fifo进行无血缘关系的进程间通信</li>
<li>使用mmap进行有血缘关系的进程间通信</li>
<li>使用mmap进行无血缘关系的进程间通信</li>
</ul>
<blockquote>
<p>Linux环境下，进程地址空间相互独立，每个进程各自有不同的用户地址空间。任何一个进程的全局变量在另一个进程中都看不到，所以进程和进程之间不能相互访问，要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为<strong>进程间通信</strong>（<strong>IPC</strong>，InterProcess Communication）。</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207031544810.png" alt="image-20220703154459626"></p>
</blockquote>
<p>在进程间完成数据传递需要借助操作系统提供特殊的方法，如：文件、管道、信号、共享内存、消息队列、套接字、命名管道等。随着计算机的蓬勃发展，一些方法由于自身设计缺陷被淘汰或者弃用。现今常用的进程间通信方式有：</p>
<ul>
<li>管道 (使用最简单)</li>
<li>信号 (开销最小)</li>
<li>共享映射区 (无血缘关系)</li>
<li>本地套接字 (最稳定)</li>
</ul>
<h4 id="管道pipe"><a href="#管道pipe" class="headerlink" title="管道pipe"></a>管道pipe</h4><p>管道pipe是一种最基本的IPC机制,也称为<strong>匿名管道</strong>,应用于有血缘关系的进程之间,完成数据传递.调用pipe函数即可创建一个管道.</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207041029498.png" alt="image-20220704102905251"></p>
<p><strong>有如下特质：</strong></p>
<ul>
<li>管道的本质是一块<strong>内核缓冲区</strong> </li>
<li>由两个文件描述符引用，一个表示读端，一个表示写端。(<code>read</code>,<code>write</code>操作)</li>
<li>规定数据从管道的写端流入管道，从读端流出。</li>
<li>当两个进程都终结的时候，管道也自动消失。(可以无需<code>close</code>)</li>
<li>管道的读端和写端<strong>默认都是阻塞的</strong>。</li>
</ul>
<p><strong>管道的原理</strong></p>
<ul>
<li>管道的实质是内核缓冲区，内部使用<strong>环形队列实现</strong>。</li>
<li>默认缓冲区大小为4K，可以使用<code>ulimit -a</code>命令获取大小(pipe)。</li>
<li>实际操作过程中缓冲区会根据数据压力做适当调整。</li>
</ul>
<p><strong>管道的局限性</strong></p>
<ul>
<li>数据一旦被读走,便不在管道中存在,<strong>不可反复读取</strong>.</li>
<li>数据只能在一个方向上流动,若要实现<strong>双向流动，必须使用两个管道</strong></li>
<li><strong>只能在有血缘关系的进程间使用管道</strong>。(因为另一个进程无法获得管道的文件描述符)</li>
</ul>
<p><strong>查看管道缓冲区的大小</strong></p>
<ul>
<li><p>命令</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -a</span><br></pre></td></tr></table></figure></li>
<li><p>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fpathconf</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">int</span> name)</span></span>;</span><br><span class="line"><span class="comment">//E.g.</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pipe size==%ld\n&quot;</span>,fpathconf(fd[<span class="number">0</span>],_PC_PIPE_BUF));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pipe size==%ld\n&quot;</span>,fpathconf(fd[<span class="number">1</span>],_PC_PIPE_BUF));</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="创建管道pipe函数"><a href="#创建管道pipe函数" class="headerlink" title="创建管道pipe函数"></a>创建管道pipe函数</h5><p>创建一个管道</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数参数:<ul>
<li>若函数调用成功，fd[0]存放管道的读端，fd[1]存放管道的写端</li>
</ul>
</li>
<li>返回值:<ul>
<li>成功返回0；</li>
<li>失败返回-1，并设置errno值。</li>
</ul>
</li>
</ul>
<p><strong>fd[0]是读端， fd[1]是写端</strong>，向管道读写数据是通过使用这<strong>两个文件描述符</strong>进行的，读写管道的实质是操作内核缓冲区。</p>
<p>管道创建成功以后，创建该管道的进程（父进程）同时掌握着管道的读端和写端。如何实现父子进程间通信呢？</p>
<p><strong>管道通信步骤</strong></p>
<ol>
<li><p>父进程创建管道</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207041143653.png" alt="image-20220704114315454"></p>
</li>
<li><p>父进程fork出子进程</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207041258197.png" alt="image-20220704125814879"></p>
</li>
<li><p>父进程关闭fd[0]，子进程关闭fd[1]</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207041259218.png" alt="image-20220704125938674"></p>
</li>
<li><p>进行通信(父进程可以向管道中写入数据，子进程将管道中的数据读出)</p>
</li>
</ol>
<h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><p>兄弟进程间通信, 实现ps aux | grep bash<br>使用execlp函数和dup2函数<br>父进程要调用waitpid函数完成对子进程的回收</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;开始&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span>(pipe(fd)==<span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;创建管道失败!&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> pid =<span class="number">-1</span>;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="comment">//创建临时文件</span></span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)<span class="comment">//子进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        close(fd[<span class="number">0</span>]);<span class="comment">//关闭管道读端</span></span><br><span class="line">        dup2(fd[<span class="number">1</span>],STDOUT_FILENO);</span><br><span class="line">        execlp(<span class="string">&quot;ps&quot;</span>,<span class="string">&quot;ps&quot;</span>,<span class="string">&quot;aux&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line">        perror(<span class="string">&quot;error1!&quot;</span>);</span><br><span class="line">      	close(fd[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;<span class="comment">//主进程</span></span><br><span class="line">        <span class="keyword">int</span> pid2 = <span class="number">-1</span>;</span><br><span class="line">        pid2 = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid2==<span class="number">0</span>)<span class="comment">//子进程1</span></span><br><span class="line">        &#123;</span><br><span class="line">            close(fd[<span class="number">1</span>]);<span class="comment">//关闭管道写端</span></span><br><span class="line">            dup2(fd[<span class="number">0</span>],STDIN_FILENO);</span><br><span class="line">            execlp(<span class="string">&quot;grep&quot;</span>,<span class="string">&quot;grep&quot;</span>,<span class="string">&quot;bash&quot;</span>,<span class="string">&quot;--color=auto&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line">            perror(<span class="string">&quot;error2!&quot;</span>);</span><br><span class="line">          	close(fd[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid2&gt;<span class="number">0</span>)<span class="comment">//主进程</span></span><br><span class="line">        &#123;</span><br><span class="line">            close(fd[<span class="number">0</span>]);<span class="comment">//不关闭的话,read会堵塞</span></span><br><span class="line">            close(fd[<span class="number">1</span>]);</span><br><span class="line">            wait(<span class="literal">NULL</span>);<span class="comment">//此处是堵塞的等待,也可以设置非堵塞的等待,手动写while循环,以此实现更细致的控制</span></span><br><span class="line">            wait(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="管道的读写行为"><a href="#管道的读写行为" class="headerlink" title="管道的读写行为"></a>管道的读写行为</h5><p>默认为堵塞状态下的情况</p>
<h6 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h6><ul>
<li><p>有数据</p>
<p>read正常读,返回读出的字节数</p>
</li>
<li><p>无数据</p>
<ul>
<li><p>写端全部关闭</p>
<p>read解除阻塞,返回0,相当于读文件读到了尾部</p>
</li>
<li><p>没有全部关闭</p>
<p>read阻塞</p>
</li>
</ul>
</li>
</ul>
<h6 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h6><ul>
<li><p>读端全部关闭</p>
<p>管道破裂,进程终止,内核给当前进程发SIGPIPE信号</p>
</li>
<li><p>读端没全部关闭</p>
<ul>
<li><p>缓冲区写满了</p>
<p>write阻塞</p>
</li>
<li><p>缓冲区没有满</p>
<p>继续write</p>
</li>
</ul>
</li>
</ul>
<h6 id="设置管道为非堵塞"><a href="#设置管道为非堵塞" class="headerlink" title="设置管道为非堵塞"></a>设置管道为非堵塞</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> flags = fcntl(fd[<span class="number">0</span>],F_GETFL,<span class="number">0</span>);</span><br><span class="line">flags |= O_NONBLOCK;</span><br><span class="line">fcntl(fd[<span class="number">0</span>],F_SETFL,flags);<span class="comment">//设置为非堵塞</span></span><br></pre></td></tr></table></figure>

<p><strong>读端设置为非堵塞:</strong></p>
<ul>
<li>写端未关闭<ul>
<li>管道中无数据可读,read返回<code>-1</code></li>
<li>管道中有数据可读,read返回实际读到的字节数</li>
</ul>
</li>
<li>写端已关闭<ul>
<li>管道中无数据可读,read返回<code>0</code></li>
<li>管道中有数据可读,read返回实际读到的字节数</li>
</ul>
</li>
</ul>
<h4 id="命名管道FIFO"><a href="#命名管道FIFO" class="headerlink" title="命名管道FIFO"></a>命名管道FIFO</h4><p>FIFO常被称为<strong>命名管道</strong>，以区分管道(pipe)。管道(pipe)只能用于“有血缘关系”的进程间通信。但通过FIFO，<strong>不相关的进程也能交换数据</strong>。<br>FIFO是Linux基础文件类型中的一种（文件类型为p(<code>ls -l</code>第一个类型)，可通过ls -l查看文件类型）。但FIFO文件在磁盘上没有数据块，文件大小为0，仅仅用来标识内核中一条通道。进程可以打开这个文件进行read/write，实际上是在读写内核缓冲区，这样就实现了进程间通信。</p>
<h5 id="创建FIFO管道"><a href="#创建FIFO管道" class="headerlink" title="创建FIFO管道"></a>创建FIFO管道</h5><ul>
<li><p>命令方式</p>
<p>命令格式： <code>mkfifo 管道名</code>              例如：<code>mkfifo myfifo</code></p>
</li>
<li><p>函数方式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="comment">//参数:pathname为fifo管道文件的路径,mode可参考stat/open等函数的mode参数,用于表示权限</span></span><br><span class="line"><span class="comment">//返回值:成功返回0,失败返回-1并设置errno</span></span><br><span class="line"><span class="comment">//更详细的参数说明和返回值查看man 2 mkfifo</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><a href="#open/close">点击跳转参考open函数mode参数</a></p>
<p>当创建了一个FIFO，就可以使用open函数打开它，常见的文件I/O函数都可用于FIFO。如：close、read、write、unlink等。</p>
<p>FIFO严格遵循<strong>先进先出（first in first out）</strong>，对FIFO的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们<strong>不支持诸如lseek()等文件定位操作</strong>(因为实质上该fifo文件是没有内容的)。</p>
<p><strong>两个进程间FIFO通信思路</strong></p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207041858586.png" alt="image-20220704185821340"></p>
<p>进程A：</p>
<ul>
<li>access函数确定fifo文件是否存在,若不存在创建一个fifo文件：myfifo</li>
<li>调用open函数打开myfifo文件</li>
<li>调用write函数写入一个字符串如：“hello world”（其实是将数据写入到了内核缓冲区）</li>
<li>调用close函数关闭myfifo文件</li>
</ul>
<p>进程B：</p>
<ul>
<li>access函数确定fifo文件是否存在,若不存在创建一个fifo文件：myfifo</li>
<li>调用open函数打开myfifo文件</li>
<li>调用read函数读取文件内容（其实就是从内核中读取数据）</li>
<li>打印显示读取的内容</li>
<li>调用close函数关闭myfifo文件</li>
</ul>
<h4 id="内存映射区"><a href="#内存映射区" class="headerlink" title="内存映射区"></a>内存映射区</h4><p>​    存储映射I/O (Memory-mapped I/O) 使一个磁盘文件与存储空间中的一个缓冲区相映射。从内存缓冲区中取数据，就相当于读文件中的相应字节；将数据写入内存缓冲区，则会将数据写入文件。这样，就可在不使用read和write函数的情况下，使用地址（指针）完成I/O操作。<br>使用存储映射这种方法，首先应通知内核，将一个指定文件映射到存储区域中。这个映射工作可以通过<strong>mmap</strong>函数来实现。</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207051217507.png" alt="image-20220705121725756"></p>
<h5 id="mmap函数"><a href="#mmap函数" class="headerlink" title="mmap函数"></a>mmap函数</h5><p>建立存储映射区</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数返回值：<ul>
<li>成功：返回创建的映射区首地址；</li>
<li>失败：MAP_FAILED宏(实际上就是<code>(void*)-1</code>)</li>
</ul>
</li>
<li>参数：    <ul>
<li><code>addr</code>:     指定映射的起始地址, <strong>通常设为NULL</strong>, 由系统指定</li>
<li><code>length</code>：映射到内存的文件长度,要**&gt;0**</li>
<li><code>prot</code>：    映射区的保护方式, 最常用的:<ul>
<li>读：<code>PROT_READ</code></li>
<li>写：<code>PROT_WRITE</code></li>
<li>读写：<code>PROT_READ | PROT_WRITE</code></li>
</ul>
</li>
<li><code>flags</code>：    映射区的特性, 可以是<ul>
<li><code>MAP_SHARED</code>: 写入映射区的数据<strong>会写回文件</strong>, 且允许其他映射该文件的进程共享。</li>
<li><code>MAP_PRIVATE</code>: 对映射区的写入操作会产生一个映射区的复制(copy-on-write), 对此区域所做的修改<strong>不会写回原文件</strong>。</li>
<li><code>MAP_ANONYMOUS</code>:<a href="#%E5%8C%BF%E5%90%8D%E6%98%A0%E5%B0%84">匿名映射相关跳转</a></li>
</ul>
</li>
<li><code>fd</code>：由open返回的文件描述符, 代表要映射的文件。</li>
<li><code>offset</code>：以文件开始处的偏移量, 必须是<strong>4k的整数倍</strong>, 通常为0, 表示从文件头开始映射。</li>
</ul>
</li>
</ul>
<p><strong>注意点:</strong></p>
<ul>
<li><p>创建映射区的过程中，隐含着一次对映射文件的读操作，将文件内容读取到映射区</p>
</li>
<li><p>当MAP_SHARED时，要求：映射区的权限应 &lt;=文件打开的权限(出于对映射区的保护)。而MAP_PRIVATE则无所谓，因为mmap中的权限是对内存的限制。</p>
</li>
<li><p>映射区的释放与文件关闭无关，只要映射建立成功，文件可以立即关闭。</p>
</li>
<li><p><strong>[特别注意]当映射的目标文件大小为0时，不能创建映射区</strong>。所以，用于映射的文件必须要有实际大小；否则会出现总线错误(bus error)(至少要写入一点东西,文件大小不能为0,不然导致下图错误)。</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207051510703.jpeg" alt="截屏2022-07-05 15.09.57" style="zoom: 33%;" /><img src="/Users/zeroko/Desktop/%E6%88%AA%E5%B1%8F2022-07-05%2015.07.15.jpg" alt="截屏2022-07-05 15.07.15" style="zoom: 33%;" /></p>
<p>因此不可以open的时候用<code>O_CREAT</code>方式打开一个新文件来创建映射区,不然总线错误</p>
</li>
<li><p>munmap传入的地址一定是mmap的返回地址。坚决杜绝指针++操作。</p>
</li>
<li><p>文件偏移量必须为0或者4K的整数倍(否则函数失败)</p>
</li>
<li><p>mmap创建映射区出错概率非常高，<strong>一定要检查返回值</strong>，确保映射区建立成功再进行后续操作。</p>
</li>
</ul>
<h5 id="munmap函数"><a href="#munmap函数" class="headerlink" title="munmap函数"></a>munmap函数</h5><p>释放由mmap函数建立的存储映射区</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>返回值：<ul>
<li>成功：返回0</li>
<li>失败：返回-1，设置errno值</li>
</ul>
</li>
<li>函数参数:<ul>
<li>addr：调用mmap函数成功返回的映射区首地址</li>
<li>length：映射区大小（mmap函数的第二个参数）</li>
</ul>
</li>
</ul>
<h5 id="父子进程间通信"><a href="#父子进程间通信" class="headerlink" title="父子进程间通信"></a>父子进程间通信</h5><p><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207051749198.png" alt="image-20220705174939006"></p>
<ul>
<li>调用mmap函数创建存储映射区，返回映射区首地址ptr</li>
<li>调用fork函数创建子进程，子进程也拥有了映射区首地址</li>
<li>父子进程可以通过映射区首地址指针ptr完成通信</li>
<li>调用munmap函数释放存储映射区</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;./1.log&quot;</span>,O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd&lt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;wrong!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span>* mAddr = mmap(<span class="literal">NULL</span>,<span class="number">4096</span>,PROT_READ|PROT_WRITE,MAP_SHARED,fd,<span class="number">0</span>);</span><br><span class="line">    close(fd);</span><br><span class="line">     <span class="keyword">if</span>(mAddr==MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;wrong!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//父进程写</span></span><br><span class="line">        <span class="built_in">memcpy</span>(mAddr,<span class="string">&quot;zeroko14&quot;</span>,<span class="built_in">strlen</span>(<span class="string">&quot;zeroko14&quot;</span>)+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="comment">//子进程读</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;(<span class="keyword">char</span>*)mAddr&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    munmap(mAddr,<span class="number">4096</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面案例存在疑问:程序执行后,<code>cat 1.log</code>命令显示出来不完整,为 <code>z%     </code></p>
<h5 id="无血缘关系进程间通信"><a href="#无血缘关系进程间通信" class="headerlink" title="无血缘关系进程间通信"></a>无血缘关系进程间通信</h5><p>两个进程都打开相同的文件，然后调用mmap函数建立存储映射区，这样两个进程共享同一个存储映射区。</p>
<h5 id="匿名映射"><a href="#匿名映射" class="headerlink" title="匿名映射"></a>匿名映射</h5><p>匿名映射不需要任何文件的支持</p>
<p>由于没有文件,所以匿名映射只适用于有血缘关系的进程间通信</p>
<p><strong><code>MAP_ANONYMOUS</code>使用要求:</strong></p>
<p>他的容量初始化为0,文件描述符和偏移参数均忽略,然而一些可移植性应用程序实现要求<strong>保证fd为-1</strong>.<strong>MAP_ANONYMOUS必须结合MAP_SHARED使用</strong>(存疑)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用案例</span></span><br><span class="line">mmap(<span class="literal">NULL</span>, <span class="number">4096</span>, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h4 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h4><ul>
<li>了解信号中的基本概念</li>
<li>熟练使用信号相关的函数</li>
<li>参考文档使用信号集操作相关函数</li>
<li>熟练使用信号捕捉函数 <code>signal</code></li>
<li>熟练使用信号捕捉函数 <code>sigaction</code></li>
<li>熟练掌握使用信号完成子进程的回收</li>
</ul>
<p><strong>[概念]</strong>  信号是信息的载体，Linux/UNIX 环境下，古老、经典的通信方式， 现下依然是主要的通信手段。</p>
<p><strong>信号的特点</strong></p>
<ul>
<li>简单</li>
<li>不能携带大量信息</li>
<li>满足某个特点条件才会产生</li>
</ul>
<h5 id="信号的机制"><a href="#信号的机制" class="headerlink" title="信号的机制"></a>信号的机制</h5><p>进程A给进程B发送信号，进程B收到信号之前执行自己的代码，收到信号后，不管执行到程序的什么位置，都要暂停运行，去处理信号，处理完毕后再继续执行。<strong>与硬件中断类似——异步模式。但信号是软件层面上实现的中断，早期常被称为“软中断”。</strong></p>
<p>每个进程收到的所有信号，都是由内核负责发送的。</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207131704167.png" alt="image-20220713161342554"></p>
<h6 id="信号的状态"><a href="#信号的状态" class="headerlink" title="信号的状态"></a>信号的状态</h6><p><strong>信号有三种状态：</strong></p>
<ul>
<li><strong>产生</strong></li>
<li><strong>未决</strong></li>
<li><strong>递达</strong></li>
</ul>
<p><strong>信号的产生</strong></p>
<ul>
<li>按键产生，如：<code>Ctrl+c</code>(终止/中断,终止程序,信号:SIGINT)、<code>Ctrl+z</code>(暂停/停止,类似挂起程序,信号:SIGTSTP)、<code>Ctrl+\</code>(退出,退出程序并转储错误信息(<a target="_blank" rel="noopener" href="https://blog.csdn.net/lucien_zhou/article/details/72614749">查看方式</a>),信号:SIGQUIT)</li>
<li>系统调用产生，如：<code>kill</code>、<code>raise</code>、<code>abort</code></li>
<li>软件条件产生，如：定时器alarm</li>
<li>硬件异常产生，如：非法访问内存(段错误)、除0(浮点数例外)、内存对齐出错(总线错误)</li>
<li>命令产生，如：kill命令</li>
</ul>
<p><strong>未决</strong>：产生和递达之间的状态。主要由于阻塞(屏蔽)导致该状态。 </p>
<p><strong>递达</strong>：递送并且到达进程。</p>
<h6 id="信号的处理方式"><a href="#信号的处理方式" class="headerlink" title="信号的处理方式"></a>信号的处理方式</h6><ul>
<li>执行默认动作 </li>
<li>忽略信号(丢弃不处理)</li>
<li>捕捉信号(调用用户的自定义的处理函数)</li>
</ul>
<h6 id="信号的特质"><a href="#信号的特质" class="headerlink" title="信号的特质"></a>信号的特质</h6><p>信号的实现手段导致信号有很强的<strong>延时性</strong>，但对于用户来说，时间非常短，不易察觉。<br>Linux内核的进程控制块PCB是一个结构体，task_struct, 除了包含进程id，状态，工作目录，用户id，组id，文件描述符表，还包含了信号相关的信息，主要指<strong>阻塞信号集和未决信号集</strong>。</p>
<p><strong>阻塞信号集和未决信号集</strong></p>
<p> Linux内核的进程控制块PCB是一个结构体，这个结构体里面包含了信号相关的信息，主要有阻塞信号集和未决信号集。</p>
<ul>
<li>阻塞信号集中保存的都是被当前进程阻塞的信号。若当前进程收到的是阻塞信号集中的某些信号，这些信号需要暂时被阻塞，不予处理。</li>
<li>信号产生后由于某些原因(主要是阻塞)不能抵达，这类信号的集合称之为未决信号集。<strong>在屏蔽解除前，信号一直处于未决状态；若是信号从阻塞信号集中解除阻塞，则该信号会被处理，并从未决信号集中去除。</strong></li>
</ul>
<p>**<code>man 7 signal</code>**可以查看更详细的信息,<strong>包含所有信号的盘点</strong>.</p>
<ol>
<li>信号的编号<ul>
<li>使用<code>kill -l</code>命令可以查看当前系统有哪些信号，不存在编号为0的信号。其中<strong>1-31号信号称之为常规信号</strong>（也叫普通信号或标准信号），34-64称之为实时信号，驱动编程与硬件相关。</li>
</ul>
</li>
<li>信号的名称</li>
<li>产生信号的事件</li>
<li>信号的默认处理动作<ul>
<li><code>Term</code>：终止进程</li>
<li><code>Ign</code>：忽略信号 (默认即时对该种信号忽略操作)</li>
<li><code>Core</code>：终止进程，生成Core文件。(查验死亡原因，用于gdb调试)</li>
<li><code>Stop</code>：停止（暂停）进程</li>
<li><code>Cont</code>：继续运行进程</li>
</ul>
</li>
</ol>
<p><strong>特别需要注意的是</strong>：The signals <code>SIGKILL</code> and <code>SIGSTOP</code> cannot be caught, blocked, or ignored.</p>
<p>几个常用到的信号:<br><code>SIGINT、SIGQUIT、SIGKILL、SIGSEGV、SIGUSR1、SIGUSR2、SIGPIPE、SIGALRM、SIGTERM、SIGCHLD、SIGSTOP、SIGCONT</code></p>
<p>常见信号一览</p>
<table>
<thead>
<tr>
<th>信号宏名</th>
<th>信号编号</th>
<th>说明</th>
<th>系统默认处理方式</th>
</tr>
</thead>
<tbody><tr>
<td>SIGABRT</td>
<td>6</td>
<td>终止进程，调用abort函数时产生</td>
<td>终止，产生core文件</td>
</tr>
<tr>
<td>SIGALRM</td>
<td>14</td>
<td>超时，调用alarm函数时产生</td>
<td>终止</td>
</tr>
<tr>
<td>SIGBUS</td>
<td>7</td>
<td>硬件故障</td>
<td>终止，产生core文件</td>
</tr>
<tr>
<td>SIGCHLD</td>
<td>17</td>
<td>子进程状态改变</td>
<td>忽略</td>
</tr>
<tr>
<td>SIGINT</td>
<td>2</td>
<td>终止进程(Ctrl+C)</td>
<td>终止</td>
</tr>
<tr>
<td>SIGIO</td>
<td>29</td>
<td>异步通知信号</td>
<td>终止</td>
</tr>
<tr>
<td>SIGKILL</td>
<td>9</td>
<td>无条件终止一个进程，不可以被捕获或忽略(与SIGTERM区分开来)</td>
<td>终止</td>
</tr>
<tr>
<td>SIGPIPE</td>
<td>13</td>
<td>写没有读权限的管道文件时</td>
<td>终止</td>
</tr>
<tr>
<td>SIGPOLL</td>
<td>8</td>
<td>轮训事件，涉及POLL机制</td>
<td>终止</td>
</tr>
<tr>
<td>SIGTERM</td>
<td>15</td>
<td>kill PID时默认发送的信号</td>
<td>终止</td>
</tr>
<tr>
<td>SIGQUIT</td>
<td>3</td>
<td>终止进程( Ctrl+\ )</td>
<td>终止，产生core文件</td>
</tr>
<tr>
<td>SIGSEGV</td>
<td>11</td>
<td>无效存储访问(指针错误)</td>
<td>终止</td>
</tr>
<tr>
<td>SIGUSER1</td>
<td>10</td>
<td>用户自定义信号1</td>
<td>终止</td>
</tr>
<tr>
<td>SIGUSER2</td>
<td>10</td>
<td>用户自定义信号2</td>
<td>终止</td>
</tr>
</tbody></table>
<h5 id="信号相关函数"><a href="#信号相关函数" class="headerlink" title="信号相关函数"></a>信号相关函数</h5><ul>
<li><a href="#signal%E5%87%BD%E6%95%B0"><code>signal</code>函数</a></li>
<li><a href="#kill%E5%87%BD%E6%95%B0/%E5%91%BD%E4%BB%A4"><code>kill</code>函数/命令函数</a></li>
<li><a href="#abort%E5%87%BD%E6%95%B0"><code>abort</code>函数</a></li>
<li><a href="#raise%E5%87%BD%E6%95%B0"><code>raise</code>函数</a></li>
<li><a href="#alarm%E5%87%BD%E6%95%B0"><code>alarm</code>函数</a></li>
<li><a href="#setitimer%E5%87%BD%E6%95%B0"><code>setitimer</code>函数</a></li>
</ul>
<h6 id="signal函数"><a href="#signal函数" class="headerlink" title="signal函数"></a>signal函数</h6><p>注册信号捕捉函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler)</span></span>;</span><br></pre></td></tr></table></figure>

<p>函数参数</p>
<ul>
<li><p><code>signum</code>：信号编号(用宏)</p>
</li>
<li><p><code>handler</code>：信号处理函数</p>
<p>​    信号处理函数格式: <code>void 自定义信号处理函数名称(int signo)</code></p>
</li>
</ul>
<h6 id="kill函数-命令"><a href="#kill函数-命令" class="headerlink" title="kill函数/命令"></a>kill函数/命令</h6><p>**给指定进程发送指定信号  **     (注意:并不是简单的杀死功能)</p>
<p><strong>kill命令：</strong><code>kill -SIGKILL 进程PID</code></p>
<p><strong>kill函数原型:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sig)</span></span>;	</span><br></pre></td></tr></table></figure>

<p><strong>函数返回值：</strong></p>
<ul>
<li>成功：0；</li>
<li>失败：-1，设置errno</li>
</ul>
<p><strong>函数参数：</strong></p>
<ul>
<li><code>sig</code>信号参数：不推荐直接使用数字，应使用宏名，因为不同操作系统信号编号可能不同，但名称一致。</li>
<li><code>pid</code>参数：<ul>
<li><code>pid &gt; 0</code>: <strong>发送信号给指定的进程。(最常用)</strong></li>
<li><code>pid = 0</code>: 发送信号给与调用kill函数进程属于同一进程组的所有进程。</li>
<li><code>pid &lt; -1</code>:  取|pid|发给对应进程组。</li>
<li><code>pid = -1</code>：发送给进程有权限发送的系统中所有进程。</li>
</ul>
</li>
</ul>
<blockquote>
<p>进程组：每个进程都属于一个进程组，进程组是一个或多个进程集合，他们相互关联，共同完成一个实体任务，每个进程组都有一个进程组长，<strong>默认进程组ID与进程组长ID相同</strong>。</p>
</blockquote>
<h6 id="abort函数"><a href="#abort函数" class="headerlink" title="abort函数"></a>abort函数</h6><p>给自己发送异常终止信号 6) SIGABRT，并产生core文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void abort(void); </span><br></pre></td></tr></table></figure>

<p>函数说明: <code>abort() == kill(getpid(), SIGABRT);</code></p>
<h6 id="raise函数"><a href="#raise函数" class="headerlink" title="raise函数"></a>raise函数</h6><p>给当前进程发送指定信号(自己给自己发)    </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raise</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数返回值：成功:0，失败:非0值</li>
<li>函数说明：<code>raise(signo) == kill(getpid(), signo);</code></li>
</ul>
<h6 id="alarm函数"><a href="#alarm函数" class="headerlink" title="alarm函数"></a>alarm函数</h6><p>设置定时器(闹钟)。在指定seconds后，内核会给当前进程发送14）SIGALRM信号。进程收到该信号，<strong>默认动作终止</strong>。<strong>每个进程都有且只有唯一的一个定时器</strong>。(弄两个的话,后一个有效,前一个被覆盖)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span>; </span><br></pre></td></tr></table></figure>

<p>函数返回值：返回0或剩余的秒数，无失败。例如：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207141503278.png" alt="image-20220714150216760"></p>
<p>常用操作:<strong>取消定时器</strong> <code>alarm(0)</code>,返回旧闹钟余下秒数.</p>
<p>alarm使用的是自然定时法,与进程状态无关,就绪,运行,挂起(阻塞,暂停),终止,僵尸…无论进程处于何种状态,alarm都计时.</p>
<p><strong>time命令</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time ./main     <span class="comment">//执行./main可执行程序并且最后打印时间结果</span></span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207151104023.jpeg" style="zoom:33%;" />
$$
实际执行时间(total/real) = 系统时间(system) + 用户时间(user) + 损耗时间
$$

<blockquote>
<p>使用time命令查看程序执行的时间。程序运行的瓶颈在于IO，优化程序，首选优化IO。</p>
<p><strong>损耗的时间</strong>主要来自文件IO操作，IO操作会有用户区到内核区的切换，切换的次数越多越耗时。</p>
</blockquote>
<p>调用<code>printf</code>函数打印数字遇到<code>\n</code>才会打印,打印过程涉及到从用户区到内核区的切换,切换次数越多消耗的时间越长,效率越低;</p>
<p>而使用文件重定向,由于文件操作是带缓冲的,所以涉及到用户区到内核区的切换次数大大减少,从而使损耗时间降低</p>
<h6 id="setitimer函数"><a href="#setitimer函数" class="headerlink" title="setitimer函数"></a>setitimer函数</h6><p>设置定时器(闹钟),可代替alarm函数,精度微秒us,<strong>默认动作终止</strong>,可以实现<strong>周期定时</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setitimer</span><span class="params">(<span class="keyword">int</span> which, <span class="keyword">const</span> struct itimerval *new_value, struct itimerval *old_value)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>函数返回值</strong></p>
<ul>
<li>成功：0；</li>
<li>失败：-1，设置errno值</li>
</ul>
<p><strong>函数参数</strong></p>
<ul>
<li><p><code>which</code>：指定定时方式</p>
<ul>
<li><strong>自然定时</strong>：<code>ITIMER_REAL</code> → 14）SIGALRM计算自然时间**(最常用)**</li>
<li>**虚拟空间计时(用户空间)**：<code>ITIMER_VIRTUAL</code> → 26）SIGVTALRM  只计算进程占用cpu的时间</li>
<li>**运行时计时(用户+内核)**：<code>ITIMER_PROF</code> → 27）SIGPROF计算占用cpu及执行系统调用的时间</li>
</ul>
</li>
<li><p><code>new_value</code>：<code>struct itimerval</code>结构, 负责设定timeout时间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> &#123;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timerval</span> <span class="title">it_interval</span>;</span> <span class="comment">// 闹钟触发周期(设定第一次执行function所延迟的时间)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timerval</span> <span class="title">it_value</span>;</span> <span class="comment">// 闹钟触发时间(设定以后每几秒执行function)</span></span><br><span class="line"> &#125;; </span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span> </span><br><span class="line">    <span class="keyword">long</span> tv_sec; 			<span class="comment">// 秒</span></span><br><span class="line">    <span class="keyword">long</span> tv_usec; 			<span class="comment">// 微秒</span></span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure></li>
<li><p><code>old_value</code>： 存放旧的timeout值，一般指定为NULL</p>
</li>
</ul>
<p><strong>案例</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从第三秒开始,每隔1秒打印一个&quot;触发!&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">alarmFunc</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;触发!&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    signal(SIGALRM,alarmFunc);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">tm</span>;</span></span><br><span class="line">    <span class="comment">//周期性时间赋值</span></span><br><span class="line">    tm.it_interval.tv_sec = <span class="number">1</span>;</span><br><span class="line">    tm.it_interval.tv_usec =<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//第一次触发的时间赋值</span></span><br><span class="line">    tm.it_value.tv_sec= <span class="number">3</span>;</span><br><span class="line">    tm.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">    setitimer(ITIMER_REAL,&amp;tm,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)<span class="comment">//防止主线程退出,导致整个程序退出</span></span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="信号集相关"><a href="#信号集相关" class="headerlink" title="信号集相关"></a>信号集相关</h5><h6 id="未决信号集和阻塞信号集的关系"><a href="#未决信号集和阻塞信号集的关系" class="headerlink" title="未决信号集和阻塞信号集的关系"></a>未决信号集和阻塞信号集的关系</h6><p>阻塞信号集是当前进程要阻塞的信号的集合，未决信号集是当前进程中还处于未决状态的信号的集合，这两个集合存储在内核的PCB中。</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207151303644.png" alt="image-20220715130337216"></p>
<blockquote>
<p>下面以SIGINT为例说明信号未决信号集和阻塞信号集的关系：</p>
<p>当进程收到一个SIGINT信号（信号编号为2），首先这个信号会保存在未决信号集合中，此时对应的2号编号的这个位置上置为1，表示处于未决状态；在这个信号需要被处理之前首先要在阻塞信号集中的编号为2的位置上去检查该值是否为1：</p>
<ul>
<li>如果为1，表示SIGNIT信号被当前进程阻塞了，这个信号暂时不被处理，所以未决信号集上该位置上的值保持为1，表示该信号处于未决状态；</li>
<li>如果为0，表示SIGINT信号没有被当前进程阻塞，这个信号需要被处理，内核会对SIGINT信号进行处理（执行默认动作，忽略或者执行用户自定义的信号处理函数），并将未决信号集中编号为2的位置上将1变为0，表示该信号已经处理了，这个时间非常短暂，用户感知不到。</li>
</ul>
<p>当SIGINT信号从阻塞信号集中解除阻塞之后，该信号就会被处理。</p>
</blockquote>
<h6 id="信号集相关函数"><a href="#信号集相关函数" class="headerlink" title="信号集相关函数"></a>信号集相关函数</h6><p>由于信号集属于内核的一块区域，用户不能直接操作内核空间，为此，内核提供了一些信号集相关的接口函数，使用这些函数用户就可以完成对信号集的相关操作。</p>
<p>信号集是一个能表示多个信号的数据类型，<code>sigset_t set</code>，set即一个信号集。既然是一个集合，就需要对集进行添加、删除等操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sigset_t类型的定义在signal.h文件中的第49行处:</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> _SIGSET_NWORDS (1024 / (8 * sizeof (unsigned long int)))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> __val[_SIGSET_NWORDS];</span><br><span class="line">&#125; <span class="keyword">__sigset_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上述变量类型的定义的查找有个小窍门： 可以执行gcc的预处理命令：</span></span><br><span class="line"><span class="comment">//gcc -E test.c -o test.i 这样头文件就会展开，可以直接到test.i文件中看到相关变量类型的定义。</span></span><br></pre></td></tr></table></figure>

<p><strong>信号集相关函数</strong></p>
<ul>
<li><code>int sigemptyset(sigset_t *set);</code><ul>
<li>函数说明：将某个信号集<strong>全部清0</strong>             </li>
<li>函数返回值：成功：0；失败：-1，设置errno</li>
</ul>
</li>
<li><code>int sigfillset(sigset_t *set);</code><ul>
<li>函数说明：将某个信号集<strong>全部置1</strong>                  </li>
<li>函数返回值：成功：0；失败：-1，设置errno</li>
<li><code>int sigaddset(sigset_t *set, int signum);</code>    </li>
<li>函数说明：将某个信号<strong>加入</strong>信号集合中,即<strong>单个置1</strong></li>
<li>函数返回值：成功：0；失败：-1，设置errno</li>
</ul>
</li>
<li><code>int sigdelset(sigset_t *set, int signum);</code>        <ul>
<li>函数说明：将某信号从信号<strong>清出</strong>信号集,即<strong>单个清零</strong></li>
<li>函数返回值：成功：0；失败：-1，设置errno</li>
</ul>
</li>
<li><code>int sigismember(const sigset_t *set, int signum);</code><ul>
<li>函数说明：判断某个信号<strong>是否在</strong>信号集中</li>
<li>函数返回值：在：1；不在：0；出错：-1，设置errno</li>
</ul>
</li>
<li><code>int sigpending(sigset_t *set);</code>   <ul>
<li>函数说明：<strong>读取当前进程的未决信号集</strong></li>
<li>函数参数：set传出参数</li>
<li>函数返回值：成功：0；失败：-1，设置errno</li>
</ul>
</li>
</ul>
<p><strong>sigprocmask函数</strong></p>
<p>用来屏蔽信号、解除屏蔽也使用该函数。其本质，读取或修改进程控制块中的信号屏蔽字（阻塞信号集）。</p>
<p><strong>特别注意，屏蔽信号只是将信号处理延后执行(延至解除屏蔽)；而忽略表示将信号丢弃处理。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="keyword">int</span> how, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">sigset_t</span> *oldset)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数返回值：成功：0；失败：-1，设置errno</li>
<li>函数参数：</li>
<li><code>how</code>参数取值：假设当前的信号屏蔽字为mask<ul>
<li><code>SIG_BLOCK</code>: 当how设置为此值，set表示需要屏蔽的信号。相当于 mask = mask|set</li>
<li><code>SIG_UNBLOCK</code>: 当how设置为此，set表示需要解除屏蔽的信号。相当于 mask = mask &amp; ~set</li>
<li><code>SIG_SETMASK</code>: 当how设置为此，set表示用于替代原始屏蔽及的新屏蔽集。相当于mask = set若，调用sigprocmask解除了对当前若干个信号的阻塞，则在sigprocmask返回前，至少将其中一个信号递达。</li>
</ul>
</li>
<li><code>set</code>：传入参数，是一个自定义信号集合。由参数how来指示如何修改当前信号屏蔽字。</li>
<li><code>oldset</code>：传出参数，保存旧的信号屏蔽字。</li>
</ul>
<p><strong>案例</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置阻塞信号集并把所有常规信号的未决状态打印至屏幕。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">  sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">  sigpending(&amp;<span class="built_in">set</span>);</span><br><span class="line">  sigaddset(&amp;<span class="built_in">set</span>,SIGHUP);<span class="comment">//将SIGHUP和SIGSYS信号手动设置为1,方便看出效果</span></span><br><span class="line">  sigaddset(&amp;<span class="built_in">set</span>,SIGSYS);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">        <span class="keyword">if</span>(sigismember(&amp;<span class="built_in">set</span>,i)==<span class="number">1</span>)</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;信号为1&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(sigismember(&amp;<span class="built_in">set</span>,i)==<span class="number">0</span>)</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;信号为0&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;信号出错&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207151512599.jpeg" style="zoom:25%;" /><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202206231654467.jpeg" alt="信号图" style="zoom: 25%;" /></p>
<h5 id="信号捕捉函数"><a href="#信号捕捉函数" class="headerlink" title="信号捕捉函数"></a>信号捕捉函数</h5><p><a href="#signal%E5%87%BD%E6%95%B0">signal函数跳转</a></p>
<h6 id="sigaction函数"><a href="#sigaction函数" class="headerlink" title="sigaction函数"></a>sigaction函数</h6><p>注册一个信号处理函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">const</span> struct sigaction *act, struct sigaction *oldact)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>函数返回值</strong>：成功：0；失败：-1，设置errno</p>
<p><strong>函数参数</strong></p>
<ul>
<li>signum：捕捉的信号</li>
<li>act：    传入参数，新的处理方式。</li>
<li>oldact： 传出参数，旧的处理方式</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sigaction结构体详解</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">       <span class="keyword">void</span>  (*sa_handler)(<span class="keyword">int</span>);	<span class="comment">// 信号处理函数</span></span><br><span class="line">       <span class="keyword">void</span>  (*sa_sigaction)(<span class="keyword">int</span>, <span class="keyword">siginfo_t</span> *, <span class="keyword">void</span> *); <span class="comment">//信号处理函数(一般不用)</span></span><br><span class="line">       <span class="keyword">sigset_t</span>  sa_mask; <span class="comment">//信号处理函数执行期间需要阻塞的信号集,如果不需要阻塞任何一个,用sigemptyset函数初始化该结构就可以了</span></span><br><span class="line">       <span class="keyword">int</span>      sa_flags; <span class="comment">//通常为0，表示使用默认标识</span></span><br><span class="line">       <span class="keyword">void</span>     (*sa_restorer)(<span class="keyword">void</span>);<span class="comment">//已废弃</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>参数详解</p>
<ul>
<li><code>sa_handler</code>：指定信号捕捉后的处理函数名(即注册函数)。也可赋值为<code>SIG_IGN</code>表忽略 或 <code>SIG_DFL</code>表执行默认动作</li>
<li><code>sa_mask</code>: 用来指定在信号处理函数执行期间需要被屏蔽的信号，特别是<strong>当某个信号被处理时，它自身会被自动放入进程的信号掩码，因此在信号处理函数执行期间这个信号不会再度发生</strong>。注意：仅在处理函数被调用期间屏蔽生效，是临时性设置。</li>
<li><code>sa_flags</code>：通常设置为0，使用默认属性。</li>
<li><code>sa_restorer</code>：已不再使用    </li>
</ul>
<p><strong>[知识点] 信号处理不支持排队:</strong></p>
<ul>
<li>在XXX信号处理函数执行期间, XXX信号是被阻塞的, 如果该信号产生了多次, 在XXX信号处理函数结束之后,  该XXX信号只被处理一次.</li>
<li>在XXX信号处理函数执行期间,如果阻塞了YYY信号, 若YYY信号产生了多次, 当XXX信号处理函数结束后, YYY信号只会被处理一次.</li>
</ul>
<p><strong>内核实现信号捕捉的过程</strong></p>
<p>如果信号的处理动作是用户自定义函数，在信号递达时就调用这个函数，这称为捕捉信号。由于信号处理函数的代码是在用户空间的，处理过程比较复杂，举例如下：</p>
<ol>
<li>用户程序注册了SIGQUIT信号的处理函数sighandler。</li>
<li>当前正在执行main函数，这时发生中断或异常切换到内核态。</li>
<li>在中断处理完毕后要返回用户态的main函数之前检查到有信号SIGQUIT递达。</li>
<li>内核决定返回用户态后不是恢复main函数的上下文继续执行，而是执行sighandler函数，sighandler和main函数使用不同的堆栈空间，它们之间不存在调用和被调用的关系，是两个独立的控制流程。</li>
<li>sighandler函数返回后自动执行特殊的系统调用sigreturn再次进入内核态。</li>
<li>如果没有新的信号要递达，这次再返回用户态就是恢复main函数的上下文继续执行了。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207161004027.png" alt="image-20220716100353613"></p>
<p>执行信号处理函数后,<code>errno</code>会被设置为<code>EINTR</code>.但如果执行信号处理函数后,发起信号的线程处于<strong>另一个sleep</strong>中(如果仅一个sleep延续至今则依旧导致<code>EINTR</code>,并且会打断当前堵塞),则会导致 <code>ETIMEDOUT</code>错误</p>
<h5 id="信号直接结束当前阻塞"><a href="#信号直接结束当前阻塞" class="headerlink" title="信号直接结束当前阻塞"></a>信号直接结束当前阻塞</h5><p><strong>[重点]</strong>  <strong>阻塞函数遇到信号都会被中断,信号处理完后继续执行后续命令</strong>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    signal(SIGALRM,sigFunc);</span><br><span class="line">    alarm(<span class="number">2</span>);</span><br><span class="line">    sleep(<span class="number">60</span>);<span class="comment">//此处60秒的等待时间并没有真正阻塞60秒,而是仅仅堵塞了两秒就被信号打断直接结束阻塞了</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;执行完毕&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207181155330.jpeg" alt="截屏2022-07-18 11.52.44" style="zoom:33%;" />

<h5 id="SIGCHLD信号"><a href="#SIGCHLD信号" class="headerlink" title="SIGCHLD信号"></a>SIGCHLD信号</h5><p>主要作用: <strong>父进程利用该信号完成对子进程的回收</strong></p>
<h6 id="产生SIGCHLD信号的条件"><a href="#产生SIGCHLD信号的条件" class="headerlink" title="产生SIGCHLD信号的条件"></a>产生SIGCHLD信号的条件</h6><ul>
<li>子进程结束的时候</li>
<li>子进程收到SIGSTOP信号</li>
<li>当子进程停止时，收到SIGCONT信号</li>
</ul>
<h6 id="SIGCHLD信号的作用"><a href="#SIGCHLD信号的作用" class="headerlink" title="SIGCHLD信号的作用"></a>SIGCHLD信号的作用</h6><p>子进程退出后，内核会给它的父进程发送SIGCHLD信号，父进程收到这个信号后可以对子进程进行回收(回收函数<code>wait/waitpid</code>只有真正子进程结束之后才能回收,所以<code>SIGSTOP</code>和<code>SIGCONT</code>信号导致的产生<code>SIGCHLD</code>可以忽视)。<br>    使用SIGCHLD信号完成对子进程的回收可以避免父进程阻塞等待而不能执行其他操作，只有当父进程收到SIGCHLD信号之后才去调用信号捕捉函数完成对子进程的回收，未收到SIGCHLD信号之前可以处理其他操作。</p>
<h6 id="使用SIGCHLD信号完成对子进程的回收案例"><a href="#使用SIGCHLD信号完成对子进程的回收案例" class="headerlink" title="使用SIGCHLD信号完成对子进程的回收案例"></a>使用SIGCHLD信号完成对子进程的回收案例</h6><p>父进程创建三个子进程，然后让父进程捕获SIGCHLD信号完成对子进程的回收。</p>
<p><strong>[注意点]</strong></p>
<ul>
<li>可能还未完成信号处理函数的注册三个子进程都退出了。<ul>
<li>解决办法：可以在fork之前先将SIGCHLD信号阻塞，当完成信号处理函数的注册后再解除阻塞。</li>
</ul>
</li>
<li>当SIGCHLD信号函数处理期间, SIGCHLD信号若再次产生是被阻塞的,而且若产生了多次, 则该信号只会被处理一次, 这样可能会产生僵尸进程。(根本原因是信号不支持排队)<ul>
<li>解决办法: 可以在信号处理函数里面使用while(1)循环回收, 这样就有可能出现捕获一次SIGCHLD信号但是回收了多个子进程的情况，从而可以避免产生僵尸进程。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigFunc</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//对子进程进行回收</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;getpid()&lt;&lt;<span class="string">&quot;对子进程进行回收,所处信号为:&quot;</span>&lt;&lt;signo&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> iRet=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">       iRet = waitpid(<span class="number">-1</span>,<span class="literal">NULL</span>,WNOHANG);</span><br><span class="line">       <span class="keyword">if</span>(iRet&gt;<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;回收子进程&quot;</span>&lt;&lt;iRet&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((iRet!=<span class="number">0</span>)&amp;&amp;(iRet!=<span class="number">-1</span>));<span class="comment">//只要不是子进程正在运行和无子进程状态即继续循环,防止因为执行期间信号屏蔽产生僵尸进程</span></span><br><span class="line">    <span class="keyword">if</span> (iRet==<span class="number">-1</span>)<span class="comment">//全部子进程回收完毕,释放自身</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;全部子进程回收完毕,结束&quot;</span>&lt;&lt;getpid()&lt;&lt;<span class="string">&quot;自身&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//先注册信号回收函数(也可以在fork前先屏蔽SIGCHLD信号)</span></span><br><span class="line">  	<span class="comment">//当前的情况下,该信号处理函数的注册,同样会被子进程继承</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sg</span>;</span></span><br><span class="line">    sigemptyset(&amp;sg.sa_mask);</span><br><span class="line">    sg.__sigaction_u.__sa_handler=sigFunc;</span><br><span class="line">    sg.sa_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> iRet= sigaction(SIGCHLD,&amp;sg,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(!iRet)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;getpid()&lt;&lt;<span class="string">&quot;主进程回收子进程回调注册成功&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//创建子进程</span></span><br><span class="line">    <span class="keyword">int</span> newPId = <span class="number">1</span>;<span class="comment">//保证父进程第一次fork执行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)<span class="comment">//父进程循环fork三次</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(newPId&gt;<span class="number">0</span>)<span class="comment">//只有父进程会fork</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;第&quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;次:正在fork&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            newPId = fork();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(newPId==<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;我是子进程&quot;</span>&lt;&lt;getpid()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(newPId&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;父进程阻塞状态...&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207161343792.jpeg" style="zoom: 25%;" />

<p><strong>信号实现进程间通信案例</strong></p>
<p>两个进程之间可以用信号来通信,但<strong>绝对不推荐用</strong>.</p>
<p>实现通信通过<code>SIGUSR1</code>和<code>SIGUSR2</code>自定义信号处理函数,因为系统不会主动发该信号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两个进程间着输出,等着对方的信号才输出</span></span><br><span class="line"><span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigFunc</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    flag = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;父进程消息回调&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    sleep(<span class="number">1</span>);<span class="comment">//强行拖慢速度,方便观察</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigFunc2</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    flag =<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;子进程消息回调&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    sleep(<span class="number">1</span>);<span class="comment">//强行拖慢速度,方便观察</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newPid = fork();</span><br><span class="line">    <span class="keyword">if</span>(newPid&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;我是父进程&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">//父进程</span></span><br><span class="line">        signal(SIGUSR1,sigFunc);</span><br><span class="line">        flag =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(flag)</span><br><span class="line">            &#123;</span><br><span class="line">                kill(newPid,SIGUSR2);</span><br><span class="line">                flag=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(newPid==<span class="number">0</span>)<span class="comment">//子进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;我是子进程&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        signal(SIGUSR2,sigFunc2);</span><br><span class="line">        flag =<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(flag)</span><br><span class="line">            &#123;</span><br><span class="line">                kill(getppid(),SIGUSR1);</span><br><span class="line">                flag=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207161856627.jpeg" style="zoom:25%;" />

<h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><ul>
<li>说出守护进程的特点</li>
<li>独立完成守护进程的创建</li>
</ul>
<p>Daemon(精灵)进程，是Linux中的后台服务进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。<strong>一般采用以d结尾的名字</strong>，如<code>vsftpd</code></p>
<p>Linux后台的一些系统服务进程，没有控制终端，不能直接和用户交互。不受用户登录、注销的影响，一直在运行着，他们都是守护进程。如：<em>预读入缓输出机制的实现；ftp服务器；nfs服务器等。</em></p>
<p><strong>总结守护进程的特点</strong></p>
<ul>
<li>Linux后台服务进程</li>
<li>独立于控制终端</li>
<li>周期性的执行某种任务</li>
<li>不受用户登陆和注销的影响</li>
<li>一般采用以d结尾的名字</li>
</ul>
<h4 id="进程组和会话"><a href="#进程组和会话" class="headerlink" title="进程组和会话"></a>进程组和会话</h4><ul>
<li><p>进程组</p>
<ul>
<li><p>进程组是一个或者多个进程的集合，每个进程都属于一个进程组，引入进程组是为了简化对进程的管理。当父进程创建子进程的时候，<strong>默认子进程与父进程属于同一个进程组</strong>。</p>
<p>进程组ID==第一个进程ID（组长进程）。如父进程创建了多个子进程，父进程和多个子进程同属于一个组，而由于父进程是进程组里的第一个进程，所以父进程就是这个组的组长, <strong>组长ID==父进程ID</strong>。</p>
</li>
<li><p>可以使用<code>kill -SIGKILL -进程组ID(负的)</code>来将整个进程组内的进程全部杀死。</p>
</li>
<li><p>只要进程组中<strong>有一个进程存在，进程组就存在，与组长进程是否终止无关。</strong></p>
</li>
<li><p>进程组生存期：从进程组创建到最后一个进程离开</p>
</li>
</ul>
</li>
<li><p>会话</p>
<ul>
<li>一个会话是<strong>一个或多个进程组的集合</strong>。</li>
<li><strong>[硬性规则]</strong> <strong>创建会话的进程不能是进程组组长</strong></li>
<li><strong>创建会话的进程成为一个进程组的组长进程，同时也成为会话的会长。</strong></li>
<li>需要有root权限（ubuntu不需要）</li>
<li><strong>新创建的会话丢弃原有的控制终端</strong></li>
<li>建立新会话时，先调用<code>fork</code>, 父进程终止，子进程调用<code>setsid</code>函数</li>
</ul>
</li>
</ul>
<p>使用<code>ps ajx</code>来查看进程组ID和会话ID</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207181413469.png" alt="image-20220718141339967"></p>
<h4 id="创建守护进程模型"><a href="#创建守护进程模型" class="headerlink" title="创建守护进程模型"></a>创建守护进程模型</h4><ol>
<li><p>fork子进程，父进程退出     <strong>(必要)</strong></p>
<p>子进程继承了父进程的进程组ID, 但具有一个新的进程ID,这样就保证了子进程不是一个进程组的组长ID,这对于下面要做的<code>setsid</code>函数的调用是必要的前提条件</p>
</li>
<li><p>子进程调用<code>setsid</code>函数创建新会话   <strong>(必要)</strong></p>
<p>调用这个函数以后</p>
<ul>
<li>该进程成为新会话的首进程，即会话的会长</li>
<li>成为一个新进程组的组长进程，即进程组组长</li>
<li>不受控制终端的影响</li>
</ul>
</li>
<li><p>改变当前工作目录<code>int chdir(const char *path);</code>  (非必要)</p>
<p>如：a.out在U盘上，启动这个程序，这个程序的当前的工作目录就是这个u盘，如果u盘拔掉后进程的当前工作目录将消失，a.out将不能正常工作。</p>
</li>
<li><p>重设文件掩码   <code>mode &amp; ~umask</code>    (非必要)</p>
<ul>
<li>子进程会继承父进程的掩码</li>
<li>增加子进程程序操作的灵活性</li>
<li>重设文件掩码函数: <code> mode_t umask(mode_t cmask);</code>     <code>umask(0000);</code>    </li>
</ul>
</li>
<li><p>关闭文件描述符    (非必要)</p>
<p>守护进程不受控制终端的影响所以可以关闭，以释放资源 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">close(STDIN_FILENO);</span><br><span class="line">close(STDOUT_FILENO);</span><br><span class="line">close(STDERR_FILENO);</span><br></pre></td></tr></table></figure></li>
<li><p>执行核心工作</p>
<p>守护进程的核心代码逻辑</p>
</li>
</ol>
<h5 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h5><p>遍写一个守护进程,每隔2s获取一次系统时间,并将这个时间写入磁盘文件.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigFunc</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;信号处理函数执行&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">time_t</span> tmp;</span><br><span class="line">    time(&amp;tmp);<span class="comment">//获取当前系统时间</span></span><br><span class="line">    <span class="keyword">char</span>* timeStr = ctime(&amp;tmp);<span class="comment">//time_t类型转换为字符串</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;1.log&quot;</span>,O_WRONLY | O_CREAT ,<span class="number">0755</span>);</span><br><span class="line">    write(fd,timeStr,<span class="built_in">strlen</span>(timeStr)+<span class="number">1</span>);</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newPid = fork();</span><br><span class="line">    <span class="keyword">if</span>(newPid&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;守护进程pid为&quot;</span>&lt;&lt;newPid&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//父进程退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sid = setsid();   <span class="comment">//子进程创建会话</span></span><br><span class="line">    <span class="comment">//重设文件掩码(不设也行)</span></span><br><span class="line">    umask(<span class="number">0000</span>);</span><br><span class="line">    <span class="comment">//关闭文件描述符(不设也行)</span></span><br><span class="line">    close(STDIN_FILENO);</span><br><span class="line">    close(STDOUT_FILENO);</span><br><span class="line">    close(STDERR_FILENO);</span><br><span class="line">    signal(SIGALRM,sigFunc);</span><br><span class="line">    itimerval itmv;</span><br><span class="line">    itmv.it_interval.tv_sec=<span class="number">2</span>;</span><br><span class="line">    itmv.it_interval.tv_usec=<span class="number">0</span>;</span><br><span class="line">    itmv.it_value.tv_sec=<span class="number">2</span>;</span><br><span class="line">    itmv.it_value.tv_usec=<span class="number">0</span>;</span><br><span class="line">    setitimer(ITIMER_REAL,&amp;itmv,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程相关"><a href="#线程相关" class="headerlink" title="线程相关"></a>线程相关</h2><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul>
<li><p>轻量级的进程（LWP：light weight process），在<strong>Linux环境下线程的本质仍是进程</strong>。</p>
</li>
<li><p>进程：拥有独立的地址空间，拥有PCB，相当于独居。</p>
</li>
<li><p>线程：有PCB，但没有独立的地址空间，多个线程共享进程空间，相当于合租。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207191501937.png" alt="image-20220719150101951"></p>
<p>一个进程空间对应一个pid,同一个进程空间的线程有同一个pid,但是他们各自有各自的线程id</p>
<ul>
<li><strong>线程</strong>：最小的执行单位</li>
<li><strong>进程</strong>：最小分配资源单位，可看成是只有一个线程的进程。</li>
</ul>
<p><strong>线程的特点</strong></p>
<ul>
<li>类Unix系统中，早期是没有“线程”概念的，80年代才引入，借助进程机制实现出了线程的概念。因此在这类系统中，进程和线程关系密切。</li>
<li>线程是<strong>轻量级进程</strong>(<strong>light-weight process,简称LWP</strong>)，也有PCB，创建线程使用的底层函数和进程一样，都是<code>clone</code></li>
<li>从内核里看进程和线程是一样的，都有各自不同的PCB.</li>
<li>进程可以蜕变成线程</li>
<li>在linux下，线程最是小的执行单位；进程是最小的分配资源单位</li>
<li><strong>主线程退出，整个进程空间都会被回收，子线程没有了生存空间，所以也就得不到执行。</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207191533978.png" alt="image-20220719153308706"></p>
<p>查看指定进程的所有的LWP号： <code>ps –Lf pid</code></p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207201125224.jpeg" alt="截屏2022-07-20 11.24.10"></p>
<p>NLWP表示线程数,STAT表示线程状态,LWP表示线程号(不同于线程id,线程id是给程序员看的)</p>
<p>实际上，无论是创建进程的fork，还是创建线程的pthread_create(C库函数)，底层实现都是调用同一个内核函数 <code>clone</code>。</p>
<ul>
<li>如果复制对方的地址空间，那么就产出一个“进程”；</li>
<li>如果共享对方的地址空间，就产生一个“线程”。</li>
</ul>
<p>所以：<strong>Linux内核是不区分进程和线程的</strong>, 只在用户层面上进行区分。</p>
<p>所以，<strong>线程所有操作函数 <code>pthread_*</code> 是库函数</strong>，而非系统调用。</p>
<h4 id="线程独立资源"><a href="#线程独立资源" class="headerlink" title="线程独立资源"></a>线程独立资源</h4><ul>
<li>线程id</li>
<li>处理器现场和栈指针(内核栈)</li>
<li>独立的栈空间(用户空间栈)</li>
<li>errno变量(多线程编程中,不应该用<code>perror()</code>,应该改用<code>strerror(errno)</code>函数,因为<code>perror</code>是调用进程的全局错误号，不适合单独线程的错误分析，所以只能使用<code>strerror</code>。)</li>
<li>信号屏蔽字</li>
<li>调度优先级</li>
</ul>
<h4 id="线程共享资源"><a href="#线程共享资源" class="headerlink" title="线程共享资源"></a>线程共享资源</h4><p><strong>实际上本进程所有内存都可以读取</strong></p>
<p>p.s. 线程之间（包含主线程和子线程）可以共享同一变量，包含全局变量或者非全局变量（但是非全局变量必须在其有效的生存期内）</p>
<ul>
<li><strong>文件描述符</strong></li>
<li>每种信号的处理方式</li>
<li>当前工作目录</li>
<li>用户ID和组ID</li>
<li>内存地址空间(.text/.data/.bss/heap/共享库)</li>
<li>等等</li>
</ul>
<h4 id="线程优-缺点"><a href="#线程优-缺点" class="headerlink" title="线程优/缺点"></a>线程优/缺点</h4><ul>
<li>优点：    <ul>
<li>提高程序并发性    </li>
<li>开销小    </li>
<li>数据通信、共享数据方便</li>
</ul>
</li>
<li>缺点：    <ul>
<li>库函数，不稳定    </li>
<li><strong>gdb调试、编写困难</strong>    </li>
<li><strong>对信号支持不好</strong></li>
</ul>
</li>
</ul>
<p>优点相对突出，缺点均不是硬伤。Linux下由于实现方法导致进程、线程差别不是很大。</p>
<p>一般来说,业务处理,数据库操作用进程操作,网络通信用线程操作.</p>
<h4 id="windows和linux线程的函数比较"><a href="#windows和linux线程的函数比较" class="headerlink" title="windows和linux线程的函数比较"></a>windows和linux线程的函数比较</h4><p><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202208211822664.jpeg" alt="img"></p>
<p>linux也有Semaphore信号量(上图有误)</p>
<h3 id="线程相关函数"><a href="#线程相关函数" class="headerlink" title="线程相关函数"></a>线程相关函数</h3><ul>
<li><a href="#pthread_create%E5%87%BD%E6%95%B0">创建子线程</a>    <code>pthread_create</code></li>
<li>获取子线程id  <code>pthread_self</code></li>
<li><a href="#pthread_exit%E5%87%BD%E6%95%B0">线程退出 </a>    <code>pthread_exit</code></li>
<li><a href="#pthread_join%E5%87%BD%E6%95%B0">回收子线程 </a>   <code>pthread_join</code></li>
<li><a href="#pthread_join%E5%87%BD%E6%95%B0">设置子线程为分离属性</a>    <code>pthread_detach</code></li>
<li><a href="#pthread_cancel%E5%87%BD%E6%95%B0">杀死线程</a>    <code>pthread_cancel</code></li>
<li>设置线程取消点    <code>pthread_testcancel</code></li>
</ul>
<h4 id="pthread-create函数"><a href="#pthread-create函数" class="headerlink" title="pthread_create函数"></a>pthread_create函数</h4><p>创建一个新线程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *thread, <span class="comment">//可以理解为传出线程操作的标识,但目前实际上就是线程id,以后可能改写成结构体</span></span></span></span><br><span class="line"><span class="params"><span class="function">								<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">void</span> *(*start_routine) (<span class="keyword">void</span> *),<span class="comment">//回调函数</span></span></span></span><br><span class="line"><span class="params"><span class="function">  							<span class="keyword">void</span> *arg)</span></span>;<span class="comment">//回调函数的参数</span></span><br></pre></td></tr></table></figure>

<p>返回值</p>
<ul>
<li>成功，返回0</li>
<li>失败，返回错误号</li>
</ul>
<p>函数参数：</p>
<ul>
<li><code>pthread_t</code>：传出参数，保存系统为我们分配好的线程ID<ul>
<li>当前Linux中可理解为：**<code>typedef unsigned long int pthread_t</code>**。(在mac中,理解成<code>typedef int64_t  pthread_t</code>)</li>
</ul>
</li>
<li><code>attr</code>：通常传NULL，表示使用线程默认属性。若想使用具体属性也可以修改该参数。</li>
<li><code>start_routine</code>：函数指针，指向线程主函数(线程体)，该函数运行结束，则线程结束。</li>
<li><code>arg</code>：线程主函数执行期间所使用的参数。</li>
</ul>
<img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207201055606.jpeg" alt="截屏2022-07-20 10.53.32" style="zoom: 33%;" />

<p>注意:</p>
<ul>
<li>由于<code>pthread_create</code>的错误码不保存在<code>errno</code>中，因此不能直接用<code>perror()</code>打印错误信息，可以先用<code>strerror()</code>把错误码转换成错误信息再打印。</li>
<li>**如果任意一个线程调用了<code>exit</code>或<code>_exit</code>，则整个进程的所有线程都终止，由于从<code>main</code>函数<code>return</code>也相当于调用<code>exit</code>**，为了防止新创建的线程还没有得到执行就终止，我们在main函数return之前延时1秒，这只是一种权宜之计，即使主线程等待1秒，内核也不一定会调度新创建的线程执行，下一节我们会看到更好的办法。</li>
<li>创建的线程,谁先执行没法确定</li>
</ul>
<p><strong>创建线程案例</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主线程循环创建5个子线程，并让子线程判断自己是第几个子线程,该案例有bug,用于展示特性,后续有解决</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">threadFunc</span><span class="params">(<span class="keyword">void</span>* numAdd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;我是第&quot;</span>&lt;&lt;*(<span class="keyword">int</span>*)numAdd&lt;&lt;<span class="string">&quot;个子线程,线程id为&quot;</span>&lt;&lt;pthread_self()&lt;&lt;<span class="string">&quot; pid为&quot;</span>&lt;&lt;getpid()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        <span class="keyword">int</span> iRet = pthread_create(&amp;tid,<span class="literal">NULL</span>,threadFunc,&amp;i);</span><br><span class="line">        <span class="keyword">if</span>(iRet !=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;strerror(iRet)&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sleep(<span class="number">1</span>);<span class="comment">//让打印错开,不然两串打印黏合在一起</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;我是主线程,线程id为:&quot;</span>&lt;&lt;pthread_self()&lt;&lt;<span class="string">&quot; pid为&quot;</span>&lt;&lt;getpid()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    sleep(<span class="number">1</span>);<span class="comment">//让主线程晚一点退出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207201059397.jpeg" alt="截屏2022-07-20 10.59.36" style="zoom:25%;" /><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207201100698.png" alt="image-20220720110017321"></p>
<blockquote>
<p><strong>为什么打印出来的值是5</strong>:</p>
<p>是由于主线程可能会在一个cpu时间片内连续创建了5个子线程，此时变量i的值变成了5，当主线程失去cpu的时间片后，子线程得到cpu的时间片，子线程访问的是变量i的内存空间的值，所以打印出来值为5.</p>
</blockquote>
<p>解决方案:  “多线程不访问同一个内存地址”  或者  “不传内存地址,而是直接传值本身”.</p>
<h4 id="pthread-exit函数"><a href="#pthread-exit函数" class="headerlink" title="pthread_exit函数"></a>pthread_exit函数</h4><p>将单个线程退出</p>
<p>在线程中禁止调用<code>exit</code>函数，否则会导致整个进程退出，取而代之的是调用<code>pthread_exit</code>函数，这个函数是使一个线程退出</p>
<p><strong>如果主线程调用<code>pthread_exit</code>函数也不会使整个进程退出，不影响其他线程的执行</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *retval)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong>:  <code>retval</code>表示线程退出状态,传出参数，通常传NULL</p>
<p><strong>注意</strong>: <code>pthread_exit</code>或者<code>return</code>返回的指针所指向的内存单元必须是全局的或者是用malloc分配的(但不一定要返回指针,也可以直接返回常数)，不能在线程函数的栈上分配，因为当其它线程得到这个返回指针时线程函数已经退出了，栈空间就会被回收。</p>
<p>在子线程中，当执行结束， <code>return</code> 和 <code>pthread_exit()</code> 都可以给返回值到主线程，主线程中的 <code>pthread_join()</code> 函数都可以接收到线程的返回值。</p>
<p>如果直接在多线程环境中使用<code>pthread_exit</code>退出主线程,那么剩下的线程会成为<strong>僵尸线程</strong>,如何避免僵尸线程,用<a href="#pthread_join%E5%87%BD%E6%95%B0"><code>pthread_join</code></a>函数</p>
<h4 id="pthread-join函数"><a href="#pthread-join函数" class="headerlink" title="pthread_join函数"></a>pthread_join函数</h4><p>阻塞等待线程退出，<strong>获取线程退出状态</strong>。其作用，对应进程中的waitpid() 函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">void</span> **retval)</span></span>; </span><br></pre></td></tr></table></figure>

<ul>
<li>函数返回值：<ul>
<li>成功：0；</li>
<li>失败：错误号</li>
</ul>
</li>
<li>函数参数： <ul>
<li><code>thread</code>：线程ID</li>
<li><code>retval</code>：传出参数,双重指针,为<strong>指向<code>pthread_exit</code>函数的retval的指针</strong>,存储线程结束状态，[整个指针指向的]和pthread_exit的参数是同一块内存地址。</li>
</ul>
</li>
</ul>
<p>一般先定义<code>void *ptr;</code> 然后<code>pthread_join(threadid, &amp;ptr);</code></p>
<p><strong>案例</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* tmp;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">threadFunc</span><span class="params">(<span class="keyword">void</span>* numAdd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;我是第&quot;</span>&lt;&lt;*(<span class="keyword">int</span>*)numAdd&lt;&lt;<span class="string">&quot;个子线程,线程id为&quot;</span>&lt;&lt;pthread_self()&lt;&lt;<span class="string">&quot; pid为&quot;</span>&lt;&lt;getpid()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    tmp = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(<span class="string">&quot;helloworld!&quot;</span>)+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(tmp,<span class="number">0</span>,<span class="built_in">strlen</span>(<span class="string">&quot;helloworld!&quot;</span>)+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(tmp,<span class="string">&quot;helloworld!&quot;</span>);</span><br><span class="line">    <span class="comment">//return tmp;//也可以</span></span><br><span class="line">    pthread_exit(tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        <span class="keyword">int</span> iRet = pthread_create(&amp;tid,<span class="literal">NULL</span>,threadFunc,&amp;i);</span><br><span class="line">        <span class="keyword">if</span>(iRet !=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;strerror(iRet)&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sleep(<span class="number">1</span>);<span class="comment">//让打印错开,不然两串打印黏合在一起</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;我是主线程,线程id为:&quot;</span>&lt;&lt;pthread_self()&lt;&lt;<span class="string">&quot; pid为&quot;</span>&lt;&lt;getpid()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">void</span>* ptr;</span><br><span class="line">    pthread_join(tid,&amp;ptr);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;收到子线程返回的数据为:&quot;</span>&lt;&lt;(<span class="keyword">char</span>*)ptr&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">free</span>(tmp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>pthread_self</code>函数用于获取自身线程id</p>
<img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207201311701.jpeg" alt="截屏2022-07-20 13.10.44" style="zoom: 33%;" />

<h4 id="pthread-detach函数"><a href="#pthread-detach函数" class="headerlink" title="pthread_detach函数"></a>pthread_detach函数</h4><p>实现线程分离</p>
<p>线程分离状态：指定该状态，线程主动与主控线程断开关系。线程结束后，其退出状态不由其他线程获取，而直接自己自动释放。<strong>网络、多线程服务器常用。</strong></p>
<p>进程若有该机制，将不会产生僵尸进程。僵尸进程的产生主要由于进程死后，大部分资源被释放，一点残留资源仍存于系统中，导致内核认为该进程仍存在。<br>也可使用 pthread_create函数的**参2(线程属性)**来设置线程分离。而<code>pthread_detach</code>函数是在创建线程之后调用的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数返回值<ul>
<li>成功：0；</li>
<li>失败：错误号</li>
</ul>
</li>
</ul>
<p>一般情况下，线程终止后，其终止状态一直保留到其它线程调用<code>pthread_join</code>获取它的状态为止。<strong>但是线程也可以被置为<code>detach</code>状态，这样的线程一旦终止就立刻回收它占用的所有资源，而不保留终止状态。</strong>不能对一个已经处于<code>detach</code>状态的线程调用<code>pthread_join</code>，这样的调用将直接返回<code>EINVAL</code>错误。也就是说，如果已经对一个线程调用了<code>pthread_detach</code>就不能再调用<code>pthread_join</code>了。</p>
<p>如果线程已经设置了分离状态，则再调用pthread_join就会失败，可用这个方法验证是否已成功设置分离状态</p>
<h4 id="pthread-cancel函数"><a href="#pthread-cancel函数" class="headerlink" title="pthread_cancel函数"></a>pthread_cancel函数</h4><p>杀死(取消)线程。其作用，对应进程中 <code>kill()</code> 函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数返回值<ul>
<li>成功：0；</li>
<li>失败：错误号</li>
</ul>
</li>
</ul>
<p><strong>【注意】</strong> 线程的取消并<strong>不是实时的</strong>，而<strong>有一定的延时</strong>。需要等待线程到达某个<strong>取消点</strong>(检查点)。</p>
<p><strong>取消点</strong>：是线程检查是否被取消，并按请求进行动作的一个位置。通常是一些系<strong>统调用</strong><code>creat，open，pause，close，read，write.....</code> 执行命令<code>man 7 pthreads</code>可以查看具备这些取消点的系统调用列表。可粗略认为一个系统调用(进入内核)即为一个取消点。还以通过调用<code>pthread_testcancel</code>函数设置一个取消点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置一个取消点函数,是用于要被取消的线程的回调中,如果有系统调用就不必写这个了</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_testcancel</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>案例</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">threadFunc</span><span class="params">(<span class="keyword">void</span>* numAdd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="comment">//pthread_testcancel();//设置取消点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        <span class="keyword">int</span> iRet = pthread_create(&amp;tid,<span class="literal">NULL</span>,threadFunc,&amp;i);</span><br><span class="line">        <span class="keyword">if</span>(iRet !=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;strerror(iRet)&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sleep(<span class="number">1</span>);<span class="comment">//让打印错开,不然两串打印黏合在一起</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;我是主线程,线程id为:&quot;</span>&lt;&lt;pthread_self()&lt;&lt;<span class="string">&quot; pid为&quot;</span>&lt;&lt;getpid()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    pthread_cancel(tid);</span><br><span class="line">    pthread_join(tid,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;子线程真正退出&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面案例阻塞,如下图:</p>
<img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207201405870.jpeg" alt="截屏2022-07-20 14.04.24" style="zoom:25%;" />

<p>原因是子线程没有取消点,所以在 <code>pthread_join</code>函数处阻塞住了.</p>
<p>把<code>pthread_testcancel</code>加到子线程回调中,就不会阻塞了,子线程将被成功释放.</p>
<h4 id="pthread-equal函数"><a href="#pthread-equal函数" class="headerlink" title="pthread_equal函数"></a>pthread_equal函数</h4><p>比较两个线程ID是否相等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_equal</span><span class="params">(<span class="keyword">pthread_t</span> t1, <span class="keyword">pthread_t</span> t2)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>返回值<ul>
<li><code>0</code>     不相等</li>
<li><code>不为0</code>    相等</li>
</ul>
</li>
</ul>
<p>注意：这个函数是为了以能够扩展使用的， 有可能Linux在未来线程ID pthread_t 类型被修改为结构体实现。</p>
<h4 id="进程函数和线程函数比较"><a href="#进程函数和线程函数比较" class="headerlink" title="进程函数和线程函数比较"></a>进程函数和线程函数比较</h4><table>
<thead>
<tr>
<th>进程</th>
<th>线程</th>
</tr>
</thead>
<tbody><tr>
<td>fork</td>
<td>pthread_create</td>
</tr>
<tr>
<td>exit</td>
<td>pthread_exit</td>
</tr>
<tr>
<td>wait/waitpid</td>
<td>pthread_join</td>
</tr>
<tr>
<td>kill</td>
<td>pthread_cancel</td>
</tr>
<tr>
<td>getpid</td>
<td>pthread_self</td>
</tr>
</tbody></table>
<h3 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h3><p>linux下线程的属性是可以根据实际项目需要，进行设置，之前讨论的线程都是采用线程的默认属性，默认属性已经可以解决绝大多数开发时遇到的问题，如果对程序的性能提出更高的要求，则需要设置线程属性</p>
<p>线程的分离状态决定一个线程以什么样的方式来终止自己，有两种状态：</p>
<ul>
<li>非分离状态：线程的默认属性是非分离状态，这种情况下，原有的线程等待创建的线程结束。只有当pthread_join()函数返回时，创建的线程才算终止，才能释放自己占用的系统资源。</li>
<li>分离状态：分离线程没有被其他的线程所等待，自己运行结束了，线程也就终止了，马上释放系统资源。应该根据自己的需要，选择适当的分离状态。</li>
</ul>
<p>设置线程属性分为以下步骤:</p>
<ol>
<li><p>定义线程属性类型类型的变量</p>
<p><code>pthread_attr_t  attr;</code></p>
</li>
<li><p>对线程属性变量进行初始化</p>
<p><code>int pthread_attr_init (pthread_attr_t* attr);</code></p>
</li>
<li><p>设置线程为分离属性</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setdetachstate</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">pthread_attr_t</span> *attr, </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">int</span> detachstate)</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数:</p>
<ul>
<li><code>attr</code>: 线程属性</li>
<li><code>detachstate</code>:<ul>
<li>PTHREAD_CREATE_DETACHED(分离)</li>
<li>PTHREAD_CREATE_JOINABLE（非分离)</li>
</ul>
</li>
</ul>
<p>注意：这一步完成之后调用pthread_create函数创建线程，</p>
<pre><code>            则创建出来的线程就是分离线程；其实上述三步就是
            pthread_create的第二个参数做准备工作。
</code></pre>
</li>
<li><p>释放线程属性资源</p>
<p><code>int pthread_attr_destroy(pthread_attr_t *attr);</code></p>
<p>参数：线程属性</p>
</li>
</ol>
<p>验证：设置为分离属性的线程是不能够被pthread_join函数回收的，<br>可以通过调用pthread_join函数测试该线程是否已经是分离属性的线程。</p>
<p><strong>案例</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_t</span> tid;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">threadFunc</span><span class="params">(<span class="keyword">void</span>* numAdd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;子线程为&quot;</span>&lt;&lt;pthread_self()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//以分离状态创建子线程</span></span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr,PTHREAD_CREATE_DETACHED);</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        <span class="keyword">int</span> iRet = pthread_create(&amp;tid,&amp;attr,threadFunc,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(iRet !=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;strerror(iRet)&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    sleep(<span class="number">1</span>);<span class="comment">//让打印错开,不然两串打印黏合在一起</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;我是主线程,线程id为:&quot;</span>&lt;&lt;pthread_self()&lt;&lt;<span class="string">&quot; pid为&quot;</span>&lt;&lt;getpid()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    iRet = pthread_join(tid,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(iRet!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;pthread_join error :&quot;</span>&lt;&lt;strerror(iRet)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;子线程真正退出&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//释放线程属性</span></span><br><span class="line">    pthread_attr_destroy(&amp;attr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>案例效果为:子线程设置为分离线程后,子线程虽然还未结束,但<code>pthread_join</code>也不会阻塞.</strong></p>
<img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207201629974.jpeg" alt="截屏2022-07-20 16.27.48" style="zoom: 33%;" />

<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p><strong>线程同步</strong>，指一个线程发出某一功能调用时，在没有得到结果之前，该调用不返回。同时其它线程为保证数据一致性，不能调用该功能。</p>
<p><strong>多线程数据混乱的原因</strong></p>
<ul>
<li>资源共享（独享资源则不会）    </li>
<li>调度随机（线程操作共享资源的先后顺序不确定）    </li>
<li>线程间缺乏必要的同步机制。</li>
</ul>
<p>以上3点中，前两点不能改变，欲提高效率，传递数据，资源必须共享。只要共享资源，就一定会出现竞争。只要存在竞争关系，数据就很容易出现混乱。所以只能从第三点着手解决。使多个线程在访问共享资源的时候，出现<strong>互斥</strong>。</p>
<ul>
<li><p>原子操作的概念</p>
<p>原子操作指的是该操作要么不做，要么就完成。</p>
</li>
<li><p>使用互斥锁解决同步问题</p>
<p>使用互斥锁其实是模拟原子操作，互斥锁示意图：</p>
</li>
</ul>
<p>Linux中提供一把互斥锁mutex（也称之为互斥量）。每个线程在对资源操作前都尝试先加锁，成功加锁才能操作，操作结束解锁。</p>
<p>资源还是共享的，线程间也还是竞争的，但<strong>通过“锁”就将资源的访问变成互斥操作</strong>，而后与时间有关的错误也不会再产生了。</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207211142513.png" alt="image-20220721114209334"></p>
<p>线程1访问共享资源的时候要先判断锁是否锁着，如果锁着就阻塞等待；若锁是解开的就将这把锁加锁，此时可以访问共享资源，访问完成后释放锁，这样其他线程就有机会获得锁。</p>
<p>使用互斥锁之后，两个线程由<strong>并行操作变成了串行操作</strong>，<strong>效率降低了，但是数据不一致的问题得到解决了。</strong></p>
<p><a href="#windows%E5%92%8Clinux%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%87%BD%E6%95%B0%E6%AF%94%E8%BE%83">windows和linux线程相关函数比较跳转</a></p>
<h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><h5 id="互斥锁相关函数"><a href="#互斥锁相关函数" class="headerlink" title="互斥锁相关函数"></a>互斥锁相关函数</h5><p><strong>pthread_mutex_t 类型</strong></p>
<p>其本质是一个结构体，为简化理解，应用时可忽略其实现细节，简单当成整数看待。</p>
<p><code>pthread_mutex_t mutex;</code> 变量mutex只有两种取值1、0。</p>
<h5 id="pthread-mutex-init函数"><a href="#pthread-mutex-init函数" class="headerlink" title="pthread_mutex_init函数"></a>pthread_mutex_init函数</h5><p>初始化一个互斥锁(互斥量) —&gt; 初值可看作1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>函数参数</strong></p>
<ul>
<li><p><code>mutex</code>：传出参数，调用时应传 <code>&amp;mutex</code>    </p>
</li>
<li><p><code>attr</code>：互斥锁属性。是一个传入参数，通常传NULL，选用默认属性(线程间共享)。</p>
<p><code>restrict</code>关键字：只用于限制指针，告诉编译器，所有修改该指针指向内存中内容的操作，只能通过本指针完成。不能通过除本指针以外的其他变量或指针修改互斥量mutex的两种初始化方式：</p>
<ul>
<li><p>静态初始化：如果互斥锁 mutex 是静态分配的（定义在全局，或加了static关键字修饰），可以直接使用宏进行初始化。</p>
<p><code>pthead_mutex_t muetx = PTHREAD_MUTEX_INITIALIZER;</code></p>
</li>
<li><p>动态初始化：局部变量应采用动态初始化。</p>
<p><code>pthread_mutex_init(&amp;mutex, NULL)</code></p>
</li>
</ul>
</li>
</ul>
<p><strong>返回值</strong></p>
<ul>
<li><code>0</code>          成功</li>
<li>不为0   失败,并且设置错误号</li>
</ul>
<h5 id="pthread-mutex-destroy函数"><a href="#pthread-mutex-destroy函数" class="headerlink" title="pthread_mutex_destroy函数"></a>pthread_mutex_destroy函数</h5><p>销毁一个互斥锁</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure>

<p>函数参数<br>    mutex—互斥锁变量</p>
<p>返回值</p>
<ul>
<li><code>0</code>          成功</li>
<li>不为0   失败,并且设置错误号</li>
</ul>
<h5 id="pthread-mutex-lock函数"><a href="#pthread-mutex-lock函数" class="headerlink" title="pthread_mutex_lock函数"></a>pthread_mutex_lock函数</h5><p>对互斥锁加锁，可理解为将<code>mutex--</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure>

<p>函数参数<br>    mutex—互斥锁变量</p>
<p>返回值</p>
<ul>
<li><code>0</code>          成功</li>
<li>不为0   失败,并且设置错误号</li>
</ul>
<h5 id="pthread-mutex-unlock函数"><a href="#pthread-mutex-unlock函数" class="headerlink" title="pthread_mutex_unlock函数"></a>pthread_mutex_unlock函数</h5><p>对互斥锁解锁，可理解为将<code>mutex ++</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure>

<p>函数参数<br>    mutex—互斥锁变量</p>
<p>返回值</p>
<ul>
<li><code>0</code>          成功</li>
<li>不为0   失败,并且设置错误号</li>
</ul>
<h5 id="pthread-mutex-trylock函数"><a href="#pthread-mutex-trylock函数" class="headerlink" title="pthread_mutex_trylock函数"></a>pthread_mutex_trylock函数</h5><p>尝试加锁</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure>

<p>函数参数<br>    mutex—互斥锁变量</p>
<p>返回值</p>
<ul>
<li><code>0</code>          成功</li>
<li>不为0   失败,并且设置错误号</li>
</ul>
<h5 id="加锁和解锁"><a href="#加锁和解锁" class="headerlink" title="加锁和解锁"></a>加锁和解锁</h5><ul>
<li>lock尝试加锁，如果加锁不成功，线程阻塞，阻塞到持有该互斥量的其他线程解锁为止。</li>
<li>unlock主动解锁函数，同时将阻塞在该锁上的所有线程全部唤醒，至于哪个线程先被唤醒，取决于优先级、调度。默认：先阻塞、先唤醒。</li>
</ul>
<p><strong>案例</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> number=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> myMutex;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread1Func</span><span class="params">(<span class="keyword">void</span>* numAdd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;myMutex);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;[1]&quot;</span>&lt;&lt;++number&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        pthread_mutex_unlock(&amp;myMutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread2Func</span><span class="params">(<span class="keyword">void</span>* numAdd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;myMutex);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;[2]&quot;</span>&lt;&lt;++number&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        pthread_mutex_unlock(&amp;myMutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pthread_mutex_init(&amp;myMutex,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">pthread_t</span> thread1,thread2;</span><br><span class="line">    pthread_create(&amp;thread1,<span class="literal">NULL</span>,thread1Func,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;thread1,<span class="literal">NULL</span>,thread2Func,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(thread1,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(thread2,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_destroy(&amp;myMutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>未加锁之前:<img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207211347215.jpeg" alt="截屏2022-07-21 13.36.00" style="zoom:25%;" />,加锁之后,输出到<code>2000000</code></p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>死锁并不是linux提供给用户的一种使用方法，而是由于用户使用互斥锁不当引起的一种现象。<br>常见的死锁有两种：</p>
<ol>
<li><p>自己锁自己，如下图代码片段</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207261331774.png" alt="image-20220726133100008"></p>
</li>
<li><p>线程A拥有A锁，请求获得B锁；线程B拥有B锁，请求获得A锁，这样造成线程A和线程B都不释放自己的锁，而且还想得到对方的锁，从而产生死锁，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207261332625.png" alt="image-20220726133159681"></p>
</li>
</ol>
<p>**[如何解决死锁]**：</p>
<ul>
<li>让线程按照一定的顺序去访问共享资源</li>
<li><strong>在访问其他锁的时候，需要先将自己的锁解开</strong></li>
<li>**调用<code>pthread_mutex_trylock</code>**，如果加锁不成功会立刻返回</li>
</ul>
<h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><p>读写锁也叫<code>共享-独占锁</code>。当读写锁以<strong>读模式</strong>锁住时，它是以<strong>共享模式</strong>锁住的；当它以<strong>写模式</strong>锁住时，它是以<strong>独占模式</strong>锁住的。**[写独占、读共享]**。</p>
<p>读写锁<strong>使用场合</strong>:<br>读写锁非常<strong>适合于对数据结构读的次数远大于写的情况</strong>。</p>
<p><strong>读写锁特性</strong></p>
<ul>
<li>读写锁是“写模式加锁”时，解锁前，所有对该锁加锁的线程都会被阻塞。</li>
<li>读写锁是“读模式加锁”时，如果线程以读模式对其加锁会成功；如果线程以写模式加锁会阻塞。</li>
<li>读写锁是“读模式加锁”时， 既有试图以写模式加锁的线程，也有试图以读模式加锁的线程。那么<strong>读写锁会阻塞随后的读模式锁请求</strong>。<strong>优先满足写模式锁。读锁、写锁并行阻塞，写锁优先级高</strong></li>
</ul>
<p><strong>读写锁总结</strong></p>
<p><strong>读并行，写独占，当读写同时等待锁的时候写的优先级高</strong></p>
<h5 id="读写锁主要函数"><a href="#读写锁主要函数" class="headerlink" title="读写锁主要函数"></a>读写锁主要函数</h5><ul>
<li><p>定义一把读写锁 </p>
<p><code>pthread_rwlock_t rwlock;</code></p>
</li>
<li><p>初始化读写锁 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_init</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock,<span class="keyword">const</span> <span class="keyword">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br></pre></td></tr></table></figure>

<p>函数参数:</p>
<ul>
<li>rwlock-读写锁</li>
<li>attr-读写锁属性，传<code>NULL</code>为默认属性</li>
</ul>
</li>
<li><p>销毁读写锁  </p>
<p><code>int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);</code>        </p>
</li>
<li><p>加读锁<br><code>int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);</code>              </p>
</li>
<li><p>尝试加读锁<br><code>int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);</code></p>
</li>
<li><p>加写锁<br><code>int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);</code></p>
</li>
<li><p>尝试加写锁<br><code>int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);</code></p>
</li>
<li><p>解锁<br><code>int pthread_rwlock_unlock(&amp;pthread_rwlock_t *rwlock);</code></p>
</li>
</ul>
<h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><p>条件本身<strong>不是锁</strong>！但它也可以造成线程阻塞。<strong>通常与互斥锁配合使用</strong>。给多线程提供一个会合的场所。</p>
<ul>
<li>使用互斥量保护共享数据;</li>
<li>使用条件变量可以使线程阻塞, 等待某个条件的发生, 当条件满足的时候解除阻塞.</li>
</ul>
<p>条件变量的两个动作:</p>
<ul>
<li>条件不满足, 阻塞线程</li>
<li>条件满足, 通知阻塞的线程解除阻塞, 开始工作.</li>
</ul>
<h5 id="条件变量相关函数"><a href="#条件变量相关函数" class="headerlink" title="条件变量相关函数"></a>条件变量相关函数</h5><p>条件变量类型  <code>pthread_cond_t  cond;</code></p>
<h6 id="pthread-cond-init"><a href="#pthread-cond-init" class="headerlink" title="pthread_cond_init"></a>pthread_cond_init</h6><p>初始化条件变量</p>
<p><code>int pthread_cond_init(pthread_cond_t *restrict cond,const pthread_condattr_t *restrict attr);</code></p>
<p>函数参数:<br>        <code>cond</code>: 条件变量<br>        <code>attr</code>: 条件变量属性, 通常传NULL<br>函数返回值:成功返回0, 失败返回错误号</p>
<h6 id="pthread-cond-destroy"><a href="#pthread-cond-destroy" class="headerlink" title="pthread_cond_destroy"></a>pthread_cond_destroy</h6><p>销毁条件变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure>

<p>函数参数: 条件变量<br>返回值: 成功返回0, 失败返回错误号</p>
<h6 id="pthread-cond-wait"><a href="#pthread-cond-wait" class="headerlink" title="pthread_cond_wait"></a>pthread_cond_wait</h6><ul>
<li>条件不满足, 引起线程阻塞并解锁;</li>
<li>条件满足, 解除线程阻塞, 并加锁</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span></span>;</span><br></pre></td></tr></table></figure>

<p>函数参数:<br>        <code>cond</code>: 条件变量<br>        <code>mutex</code>: <strong>互斥锁变量</strong><br>函数返回值: 成功返回0, 失败返回错误号</p>
<h6 id="pthread-cond-signal"><a href="#pthread-cond-signal" class="headerlink" title="pthread_cond_signal"></a>pthread_cond_signal</h6><p>唤醒至少一个阻塞在该条件变量上的线程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure>

<p>函数参数: 条件变量<br>函数返回值: 成功返回0, 失败返回错误号</p>
<p><strong>案例</strong></p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207281613821.png"><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207281613562.png"></p>
<p>生产者线程调用pthread_cond_signal函数会使消费者线程在pthread_cond_wait处解除阻塞。</p>
<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>信号量相当于多把锁, 可以理解为是加强版的互斥锁</p>
<p>前面的锁同一时间都只能有一个单位持有锁,信号量允许多个单位持有同一把锁.</p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207291415036.png" alt="image-20220729141523246"></p>
<p>可以如上图理解成多部车进同一个车库</p>
<h5 id="信号量相关函数"><a href="#信号量相关函数" class="headerlink" title="信号量相关函数"></a>信号量相关函数</h5><p>定义信号量 <code>sem_t sem;</code></p>
<h6 id="sem-init函数"><a href="#sem-init函数" class="headerlink" title="sem_init函数"></a>sem_init函数</h6><p>初始化信号量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_init</span><span class="params">(<span class="keyword">sem_t</span> *sem, <span class="keyword">int</span> pshared, <span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>;</span><br></pre></td></tr></table></figure>

<p>函数参数:<br>    <code>sem</code>: 信号量变量<br>    <code>pshared</code>: 0表示线程同步, 1表示进程同步<br>    <code>value</code>: <strong>最多有几个线程操作共享数据</strong><br>函数返回值:成功返回0, 失败返回-1, 并设置errno值</p>
<h6 id="sem-wait函数"><a href="#sem-wait函数" class="headerlink" title="sem_wait函数"></a>sem_wait函数</h6><p>调用该函数一次, 相当于sem–, 当<strong>sem为0的时候, 引起阻塞</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_wait</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br></pre></td></tr></table></figure>

<p>函数参数: 信号量变量<br>函数返回值: 成功返回0, 失败返回-1, 并设置errno值</p>
<h6 id="sem-post函数"><a href="#sem-post函数" class="headerlink" title="sem_post函数"></a>sem_post函数</h6><p>调用一次, 相当于sem++</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_post</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br></pre></td></tr></table></figure>

<p>函数参数: 信号量变量<br>函数返回值: 成功返回0, 失败返回-1, 并设置errno值</p>
<h6 id="sem-trywait函数"><a href="#sem-trywait函数" class="headerlink" title="sem_trywait函数"></a>sem_trywait函数</h6><p>尝试加锁, 若失败直接返回, 不阻塞</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_trywait</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br></pre></td></tr></table></figure>

<p>函数参数: 信号量变量<br>函数返回值: 成功返回0, 失败返回-1, 并设置errno值</p>
<h6 id="sem-destroy函数"><a href="#sem-destroy函数" class="headerlink" title="sem_destroy函数"></a>sem_destroy函数</h6><p>销毁信号量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_destroy</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br></pre></td></tr></table></figure>

<p>函数参数: 信号量变量<br>函数返回值: 成功返回0, 失败返回-1, 并设置errno值</p>
<p><strong>案例</strong></p>
<p><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207291421675.png" alt="image-20220729142150009"><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202207291421450.png" alt="image-20220729142154726"></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/blog/tags/linux/" rel="tag"># linux</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/blog/2020/12/23/%E7%AE%97%E6%B3%95/" rel="prev" title="算法">
      <i class="fa fa-chevron-left"></i> 算法
    </a></div>
      <div class="post-nav-item">
    <a href="/blog/2020/12/23/C%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/" rel="next" title="C语言入门">
      C语言入门 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#linux%E5%9F%BA%E7%A1%80"><span class="nav-number">1.</span> <span class="nav-text">linux基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E8%A7%A3%E9%87%8A%E5%99%A8"><span class="nav-number">1.1.</span> <span class="nav-text">命令解释器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux%E4%B8%8B%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="nav-number">1.2.</span> <span class="nav-text">Linux下常用快捷键</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux%E4%B8%8B%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="nav-number">1.3.</span> <span class="nav-text">Linux下目录结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E5%92%8C%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84"><span class="nav-number">1.4.</span> <span class="nav-text">相对路径和绝对路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E7%9B%B8%E5%85%B3%E7%9A%84%E5%91%BD%E4%BB%A4"><span class="nav-number">1.5.</span> <span class="nav-text">文件和目录操作相关的命令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#tree%E5%91%BD%E4%BB%A4"><span class="nav-number">1.5.1.</span> <span class="nav-text">tree命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ls%E5%91%BD%E4%BB%A4"><span class="nav-number">1.5.2.</span> <span class="nav-text">ls命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cd%E5%91%BD%E4%BB%A4"><span class="nav-number">1.5.3.</span> <span class="nav-text">cd命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pwd%E5%91%BD%E4%BB%A4"><span class="nav-number">1.5.4.</span> <span class="nav-text">pwd命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#which%E5%91%BD%E4%BB%A4"><span class="nav-number">1.5.5.</span> <span class="nav-text">which命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#touch%E5%91%BD%E4%BB%A4"><span class="nav-number">1.5.6.</span> <span class="nav-text">touch命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mkdir%E5%91%BD%E4%BB%A4"><span class="nav-number">1.5.7.</span> <span class="nav-text">mkdir命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rm%E5%91%BD%E4%BB%A4"><span class="nav-number">1.5.8.</span> <span class="nav-text">rm命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cp%E5%91%BD%E4%BB%A4"><span class="nav-number">1.5.9.</span> <span class="nav-text">cp命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mv%E5%91%BD%E4%BB%A4"><span class="nav-number">1.5.10.</span> <span class="nav-text">mv命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cat%E5%91%BD%E4%BB%A4"><span class="nav-number">1.5.11.</span> <span class="nav-text">cat命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#more%E5%91%BD%E4%BB%A4"><span class="nav-number">1.5.12.</span> <span class="nav-text">more命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#less%E5%91%BD%E4%BB%A4"><span class="nav-number">1.5.13.</span> <span class="nav-text">less命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#head%E5%91%BD%E4%BB%A4"><span class="nav-number">1.5.14.</span> <span class="nav-text">head命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tail%E5%91%BD%E4%BB%A4"><span class="nav-number">1.5.15.</span> <span class="nav-text">tail命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="nav-number">1.5.16.</span> <span class="nav-text">链接相关命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AF%E9%93%BE%E6%8E%A5"><span class="nav-number">1.5.16.1.</span> <span class="nav-text">软链接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A1%AC%E9%93%BE%E6%8E%A5"><span class="nav-number">1.5.16.2.</span> <span class="nav-text">硬链接</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#wc%E5%91%BD%E4%BB%A4"><span class="nav-number">1.5.17.</span> <span class="nav-text">wc命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#whoami%E5%91%BD%E4%BB%A4"><span class="nav-number">1.5.18.</span> <span class="nav-text">whoami命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#man%E5%91%BD%E4%BB%A4"><span class="nav-number">1.5.19.</span> <span class="nav-text">man命令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90-%E7%94%A8%E6%88%B7%E5%92%8C%E7%94%A8%E6%88%B7%E7%BB%84%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="nav-number">1.6.</span> <span class="nav-text">用户权限,用户和用户组相关命令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#chmod%E5%91%BD%E4%BB%A4"><span class="nav-number">1.6.1.</span> <span class="nav-text">chmod命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E5%AD%97%E8%AE%BE%E5%AE%9A%E6%B3%95"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">文字设定法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E5%AD%97%E8%AE%BE%E5%AE%9A%E6%B3%95"><span class="nav-number">1.6.1.2.</span> <span class="nav-text">数字设定法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#chown%E5%91%BD%E4%BB%A4"><span class="nav-number">1.6.2.</span> <span class="nav-text">chown命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#chgrp%E5%91%BD%E4%BB%A4"><span class="nav-number">1.6.3.</span> <span class="nav-text">chgrp命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#id%E5%91%BD%E4%BB%A4"><span class="nav-number">1.6.4.</span> <span class="nav-text">id命令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#find%E5%91%BD%E4%BB%A4"><span class="nav-number">1.7.</span> <span class="nav-text">find命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#grep%E5%91%BD%E4%BB%A4"><span class="nav-number">1.8.</span> <span class="nav-text">grep命令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#find%E5%92%8Cgrep%E5%91%BD%E4%BB%A4%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8"><span class="nav-number">1.8.1.</span> <span class="nav-text">find和grep命令结合使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#linux%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E8%A7%A3%E5%8E%8B%E7%BC%A9%E5%B7%A5%E5%85%B7"><span class="nav-number">1.9.</span> <span class="nav-text">linux中常用的解压缩工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#gzip%E5%92%8Cbzip2"><span class="nav-number">1.9.1.</span> <span class="nav-text">gzip和bzip2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tar%E5%B7%A5%E5%85%B7"><span class="nav-number">1.9.2.</span> <span class="nav-text">tar工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rar%E5%B7%A5%E5%85%B7"><span class="nav-number">1.9.3.</span> <span class="nav-text">rar工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#zip%E5%B7%A5%E5%85%B7"><span class="nav-number">1.9.4.</span> <span class="nav-text">zip工具</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%8D%B8%E8%BD%BD"><span class="nav-number">1.10.</span> <span class="nav-text">软件的安装和卸载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="nav-number">1.11.</span> <span class="nav-text">进程相关命令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ps%E5%91%BD%E4%BB%A4"><span class="nav-number">1.11.1.</span> <span class="nav-text">ps命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#kill%E5%91%BD%E4%BB%A4"><span class="nav-number">1.11.2.</span> <span class="nav-text">kill命令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#linux%E8%84%9A%E6%9C%AC"><span class="nav-number">1.12.</span> <span class="nav-text">linux脚本</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#linux%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="nav-number">1.13.</span> <span class="nav-text">linux定时任务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4%E7%9B%98%E7%82%B9"><span class="nav-number">1.14.</span> <span class="nav-text">其他命令盘点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#vim"><span class="nav-number">2.</span> <span class="nav-text">vim</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#vim%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.1.</span> <span class="nav-text">vim的三种模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">2.1.1.</span> <span class="nav-text">命令模式下的操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%9D%E5%AD%98%E9%80%80%E5%87%BA"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">保存退出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="nav-number">2.1.1.2.</span> <span class="nav-text">代码的格式化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%89%E6%A0%87%E7%A7%BB%E5%8A%A8"><span class="nav-number">2.1.1.3.</span> <span class="nav-text">光标移动</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E5%91%BD%E4%BB%A4"><span class="nav-number">2.1.1.4.</span> <span class="nav-text">删除命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%92%A4%E9%94%80%E5%92%8C%E5%8F%8D%E6%92%A4%E9%94%80%E5%91%BD%E4%BB%A4"><span class="nav-number">2.1.1.5.</span> <span class="nav-text">撤销和反撤销命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E5%92%8C%E7%B2%98%E8%B4%B4"><span class="nav-number">2.1.1.6.</span> <span class="nav-text">复制和粘贴</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E8%A7%86%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.1.1.7.</span> <span class="nav-text">可视模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9B%BF%E6%8D%A2%E6%93%8D%E4%BD%9C"><span class="nav-number">2.1.1.8.</span> <span class="nav-text">替换操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E5%91%BD%E4%BB%A4"><span class="nav-number">2.1.1.9.</span> <span class="nav-text">查找命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E7%BF%BB%E5%B1%8F"><span class="nav-number">2.1.1.10.</span> <span class="nav-text">快速翻屏</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D"><span class="nav-number">2.1.1.11.</span> <span class="nav-text">快速定位</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%87%E6%8D%A2%E5%88%B0%E6%96%87%E6%9C%AC%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.1.1.12.</span> <span class="nav-text">切换到文本输入模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%87%E6%8D%A2%E5%88%B0%E6%9C%AB%E8%A1%8C%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.1.1.13.</span> <span class="nav-text">切换到末行模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AB%E8%A1%8C%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">2.1.2.</span> <span class="nav-text">末行模式下的操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%9D%E5%AD%98%E9%80%80%E5%87%BA-1"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">保存退出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9B%BF%E6%8D%A2%E6%93%8D%E4%BD%9C-1"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">替换操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%AB%E8%A1%8C%E6%A8%A1%E5%BC%8F%E4%B8%8B%E6%89%A7%E8%A1%8Cshell%E5%91%BD%E4%BB%A4"><span class="nav-number">2.1.2.3.</span> <span class="nav-text">末行模式下执行shell命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%B1%8F%E6%93%8D%E4%BD%9C"><span class="nav-number">2.1.2.4.</span> <span class="nav-text">分屏操作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E4%B9%8B%E5%89%8D%E5%88%86%E5%B1%8F"><span class="nav-number">2.1.2.4.1.</span> <span class="nav-text">打开文件之前分屏</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E4%B9%8B%E5%90%8E%E5%88%86%E5%B1%8F"><span class="nav-number">2.1.2.4.2.</span> <span class="nav-text">打开文件之后分屏</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8E%E6%9C%AB%E8%A1%8C%E6%A8%A1%E5%BC%8F%E5%88%87%E6%8D%A2%E5%9B%9E%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.1.2.5.</span> <span class="nav-text">从末行模式切换回命令模式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vim%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="nav-number">2.2.</span> <span class="nav-text">vim的配置文件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#gcc%E7%BC%96%E8%AF%91%E5%99%A8"><span class="nav-number">3.</span> <span class="nav-text">gcc编译器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#gcc%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0"><span class="nav-number">3.1.</span> <span class="nav-text">gcc常用参数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%85%B1%E4%BA%AB-%E5%8A%A8%E6%80%81-%E5%BA%93"><span class="nav-number">4.</span> <span class="nav-text">静态库和共享(动态)库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%BA%93"><span class="nav-number">4.1.</span> <span class="nav-text">静态库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E5%88%B6%E4%BD%9C"><span class="nav-number">4.1.1.</span> <span class="nav-text">静态库的制作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">4.1.2.</span> <span class="nav-text">静态库的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E9%99%85%E6%A1%88%E4%BE%8B"><span class="nav-number">4.1.3.</span> <span class="nav-text">[实际案例]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">4.1.4.</span> <span class="nav-text">静态库的优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E7%82%B9"><span class="nav-number">4.1.4.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9"><span class="nav-number">4.1.4.2.</span> <span class="nav-text">缺点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%BA%93-%E5%8A%A8%E6%80%81%E5%BA%93"><span class="nav-number">4.2.</span> <span class="nav-text">共享库&#x2F;动态库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%BA%93%E7%9A%84%E5%88%B6%E4%BD%9C"><span class="nav-number">4.2.1.</span> <span class="nav-text">共享库的制作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">4.2.2.</span> <span class="nav-text">共享库的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A9%E7%B3%BB%E7%BB%9F%E6%89%BE%E5%88%B0%E5%85%B1%E4%BA%AB%E5%BA%93"><span class="nav-number">4.2.3.</span> <span class="nav-text">让系统找到共享库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E9%99%85%E6%A1%88%E4%BE%8B-1"><span class="nav-number">4.2.4.</span> <span class="nav-text">[实际案例]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mac%E4%B8%8B%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F"><span class="nav-number">4.2.5.</span> <span class="nav-text">mac下环境初始化顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%BA%93%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">4.2.6.</span> <span class="nav-text">共享库的特点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AF%94%E8%BE%83%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">4.3.</span> <span class="nav-text">比较静态库和动态库的优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%BA%93-1"><span class="nav-number">4.3.1.</span> <span class="nav-text">静态库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93"><span class="nav-number">4.3.2.</span> <span class="nav-text">动态库</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#linux%E7%B3%BB%E7%BB%9FAPI%E7%9B%B8%E5%85%B3"><span class="nav-number">5.</span> <span class="nav-text">linux系统API相关</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#C%E5%BA%93IO%E7%90%86%E8%A7%A3"><span class="nav-number">5.1.</span> <span class="nav-text">C库IO理解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%93%E5%87%BD%E6%95%B0%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">5.2.</span> <span class="nav-text">库函数与系统函数的关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="nav-number">5.3.</span> <span class="nav-text">虚拟地址空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PCB%E5%92%8C%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8"><span class="nav-number">5.4.</span> <span class="nav-text">PCB和文件描述符表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6IO%E5%87%BD%E6%95%B0"><span class="nav-number">5.5.</span> <span class="nav-text">文件IO函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#open-close"><span class="nav-number">5.5.1.</span> <span class="nav-text">open&#x2F;close</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#read-write"><span class="nav-number">5.5.2.</span> <span class="nav-text">read&#x2F;write</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lseek%E5%87%BD%E6%95%B0"><span class="nav-number">5.5.3.</span> <span class="nav-text">lseek函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#perror%E5%92%8Cerrno"><span class="nav-number">5.5.4.</span> <span class="nav-text">perror和errno</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="nav-number">5.5.5.</span> <span class="nav-text">阻塞和非阻塞</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stat-lstat%E5%87%BD%E6%95%B0"><span class="nav-number">5.5.6.</span> <span class="nav-text">stat&#x2F;lstat函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E8%8E%B7%E5%8F%96%E6%A1%88%E4%BE%8B"><span class="nav-number">5.5.6.1.</span> <span class="nav-text">文件类型获取案例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C"><span class="nav-number">5.5.7.</span> <span class="nav-text">目录操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#opendir%E5%87%BD%E6%95%B0"><span class="nav-number">5.5.7.1.</span> <span class="nav-text">opendir函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#readdir%E5%87%BD%E6%95%B0"><span class="nav-number">5.5.7.2.</span> <span class="nav-text">readdir函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#dirent%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">5.5.7.2.1.</span> <span class="nav-text">dirent结构体</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#closedir%E5%87%BD%E6%95%B0"><span class="nav-number">5.5.7.3.</span> <span class="nav-text">closedir函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81"><span class="nav-number">5.5.7.4.</span> <span class="nav-text">案例实现代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dup-dup2-fcntl"><span class="nav-number">5.5.8.</span> <span class="nav-text">dup&#x2F;dup2&#x2F;fcntl</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#dup%E5%87%BD%E6%95%B0"><span class="nav-number">5.5.8.1.</span> <span class="nav-text">dup函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dup2%E5%87%BD%E6%95%B0"><span class="nav-number">5.5.8.2.</span> <span class="nav-text">dup2函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fcntl%E5%87%BD%E6%95%B0"><span class="nav-number">5.5.8.3.</span> <span class="nav-text">fcntl函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-number">5.6.</span> <span class="nav-text">进程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C"><span class="nav-number">5.6.1.</span> <span class="nav-text">并发和并行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PCB%E8%AF%A6%E8%A7%A3"><span class="nav-number">5.6.2.</span> <span class="nav-text">PCB详解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="nav-number">5.6.3.</span> <span class="nav-text">进程状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B"><span class="nav-number">5.6.4.</span> <span class="nav-text">创建进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="nav-number">5.6.5.</span> <span class="nav-text">进程相关函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#exit-%E5%87%BD%E6%95%B0"><span class="nav-number">5.6.5.1.</span> <span class="nav-text">exit()函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#getpid%E5%92%8Cgetppid"><span class="nav-number">5.6.5.2.</span> <span class="nav-text">getpid和getppid</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#exec%E5%87%BD%E6%95%B0%E6%97%8F"><span class="nav-number">5.6.5.3.</span> <span class="nav-text">exec函数族</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#execl%E5%87%BD%E6%95%B0"><span class="nav-number">5.6.5.3.1.</span> <span class="nav-text">execl函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#execlp%E5%87%BD%E6%95%B0"><span class="nav-number">5.6.5.3.2.</span> <span class="nav-text">execlp函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#exec%E5%87%BD%E6%95%B0%E6%97%8F%E5%8E%9F%E7%90%86"><span class="nav-number">5.6.5.3.3.</span> <span class="nav-text">exec函数族原理</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%9B%9E%E6%94%B6%E5%87%BD%E6%95%B0"><span class="nav-number">5.6.5.4.</span> <span class="nav-text">进程回收函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#wait%E5%87%BD%E6%95%B0"><span class="nav-number">5.6.5.4.1.</span> <span class="nav-text">wait函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#waitpid%E5%87%BD%E6%95%B0"><span class="nav-number">5.6.5.4.2.</span> <span class="nav-text">waitpid函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%9B%9E%E6%94%B6"><span class="nav-number">5.6.6.</span> <span class="nav-text">进程回收</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B"><span class="nav-number">5.6.6.1.</span> <span class="nav-text">孤儿进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="nav-number">5.6.6.2.</span> <span class="nav-text">僵尸进程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="nav-number">5.6.7.</span> <span class="nav-text">进程间通信</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%A1%E9%81%93pipe"><span class="nav-number">5.6.7.1.</span> <span class="nav-text">管道pipe</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%AE%A1%E9%81%93pipe%E5%87%BD%E6%95%B0"><span class="nav-number">5.6.7.1.1.</span> <span class="nav-text">创建管道pipe函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B"><span class="nav-number">5.6.7.1.2.</span> <span class="nav-text">案例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%A1%E9%81%93%E7%9A%84%E8%AF%BB%E5%86%99%E8%A1%8C%E4%B8%BA"><span class="nav-number">5.6.7.1.3.</span> <span class="nav-text">管道的读写行为</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AF%BB%E6%93%8D%E4%BD%9C"><span class="nav-number">5.6.7.1.3.1.</span> <span class="nav-text">读操作</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%86%99%E6%93%8D%E4%BD%9C"><span class="nav-number">5.6.7.1.3.2.</span> <span class="nav-text">写操作</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E7%AE%A1%E9%81%93%E4%B8%BA%E9%9D%9E%E5%A0%B5%E5%A1%9E"><span class="nav-number">5.6.7.1.3.3.</span> <span class="nav-text">设置管道为非堵塞</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93FIFO"><span class="nav-number">5.6.7.2.</span> <span class="nav-text">命名管道FIFO</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9B%E5%BB%BAFIFO%E7%AE%A1%E9%81%93"><span class="nav-number">5.6.7.2.1.</span> <span class="nav-text">创建FIFO管道</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E5%8C%BA"><span class="nav-number">5.6.7.3.</span> <span class="nav-text">内存映射区</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#mmap%E5%87%BD%E6%95%B0"><span class="nav-number">5.6.7.3.1.</span> <span class="nav-text">mmap函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#munmap%E5%87%BD%E6%95%B0"><span class="nav-number">5.6.7.3.2.</span> <span class="nav-text">munmap函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="nav-number">5.6.7.3.3.</span> <span class="nav-text">父子进程间通信</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%97%A0%E8%A1%80%E7%BC%98%E5%85%B3%E7%B3%BB%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="nav-number">5.6.7.3.4.</span> <span class="nav-text">无血缘关系进程间通信</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E6%98%A0%E5%B0%84"><span class="nav-number">5.6.7.3.5.</span> <span class="nav-text">匿名映射</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7"><span class="nav-number">5.6.7.4.</span> <span class="nav-text">信号</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%9C%BA%E5%88%B6"><span class="nav-number">5.6.7.4.1.</span> <span class="nav-text">信号的机制</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-number">5.6.7.4.1.1.</span> <span class="nav-text">信号的状态</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-number">5.6.7.4.1.2.</span> <span class="nav-text">信号的处理方式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E7%9A%84%E7%89%B9%E8%B4%A8"><span class="nav-number">5.6.7.4.1.3.</span> <span class="nav-text">信号的特质</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="nav-number">5.6.7.4.2.</span> <span class="nav-text">信号相关函数</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#signal%E5%87%BD%E6%95%B0"><span class="nav-number">5.6.7.4.2.1.</span> <span class="nav-text">signal函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#kill%E5%87%BD%E6%95%B0-%E5%91%BD%E4%BB%A4"><span class="nav-number">5.6.7.4.2.2.</span> <span class="nav-text">kill函数&#x2F;命令</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#abort%E5%87%BD%E6%95%B0"><span class="nav-number">5.6.7.4.2.3.</span> <span class="nav-text">abort函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#raise%E5%87%BD%E6%95%B0"><span class="nav-number">5.6.7.4.2.4.</span> <span class="nav-text">raise函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#alarm%E5%87%BD%E6%95%B0"><span class="nav-number">5.6.7.4.2.5.</span> <span class="nav-text">alarm函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#setitimer%E5%87%BD%E6%95%B0"><span class="nav-number">5.6.7.4.2.6.</span> <span class="nav-text">setitimer函数</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%9B%86%E7%9B%B8%E5%85%B3"><span class="nav-number">5.6.7.4.3.</span> <span class="nav-text">信号集相关</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9C%AA%E5%86%B3%E4%BF%A1%E5%8F%B7%E9%9B%86%E5%92%8C%E9%98%BB%E5%A1%9E%E4%BF%A1%E5%8F%B7%E9%9B%86%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">5.6.7.4.3.1.</span> <span class="nav-text">未决信号集和阻塞信号集的关系</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%9B%86%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="nav-number">5.6.7.4.3.2.</span> <span class="nav-text">信号集相关函数</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89%E5%87%BD%E6%95%B0"><span class="nav-number">5.6.7.4.4.</span> <span class="nav-text">信号捕捉函数</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#sigaction%E5%87%BD%E6%95%B0"><span class="nav-number">5.6.7.4.4.1.</span> <span class="nav-text">sigaction函数</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E7%9B%B4%E6%8E%A5%E7%BB%93%E6%9D%9F%E5%BD%93%E5%89%8D%E9%98%BB%E5%A1%9E"><span class="nav-number">5.6.7.4.5.</span> <span class="nav-text">信号直接结束当前阻塞</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SIGCHLD%E4%BF%A1%E5%8F%B7"><span class="nav-number">5.6.7.4.6.</span> <span class="nav-text">SIGCHLD信号</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BA%A7%E7%94%9FSIGCHLD%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="nav-number">5.6.7.4.6.1.</span> <span class="nav-text">产生SIGCHLD信号的条件</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#SIGCHLD%E4%BF%A1%E5%8F%B7%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">5.6.7.4.6.2.</span> <span class="nav-text">SIGCHLD信号的作用</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8SIGCHLD%E4%BF%A1%E5%8F%B7%E5%AE%8C%E6%88%90%E5%AF%B9%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9B%9E%E6%94%B6%E6%A1%88%E4%BE%8B"><span class="nav-number">5.6.7.4.6.3.</span> <span class="nav-text">使用SIGCHLD信号完成对子进程的回收案例</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="nav-number">5.6.8.</span> <span class="nav-text">守护进程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%84%E5%92%8C%E4%BC%9A%E8%AF%9D"><span class="nav-number">5.6.8.1.</span> <span class="nav-text">进程组和会话</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">5.6.8.2.</span> <span class="nav-text">创建守护进程模型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B-1"><span class="nav-number">5.6.8.2.1.</span> <span class="nav-text">案例</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3"><span class="nav-number">5.7.</span> <span class="nav-text">线程相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B"><span class="nav-number">5.7.1.</span> <span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%8B%AC%E7%AB%8B%E8%B5%84%E6%BA%90"><span class="nav-number">5.7.1.1.</span> <span class="nav-text">线程独立资源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90"><span class="nav-number">5.7.1.2.</span> <span class="nav-text">线程共享资源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%BC%98-%E7%BC%BA%E7%82%B9"><span class="nav-number">5.7.1.3.</span> <span class="nav-text">线程优&#x2F;缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#windows%E5%92%8Clinux%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%87%BD%E6%95%B0%E6%AF%94%E8%BE%83"><span class="nav-number">5.7.1.4.</span> <span class="nav-text">windows和linux线程的函数比较</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="nav-number">5.7.2.</span> <span class="nav-text">线程相关函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#pthread-create%E5%87%BD%E6%95%B0"><span class="nav-number">5.7.2.1.</span> <span class="nav-text">pthread_create函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pthread-exit%E5%87%BD%E6%95%B0"><span class="nav-number">5.7.2.2.</span> <span class="nav-text">pthread_exit函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pthread-join%E5%87%BD%E6%95%B0"><span class="nav-number">5.7.2.3.</span> <span class="nav-text">pthread_join函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pthread-detach%E5%87%BD%E6%95%B0"><span class="nav-number">5.7.2.4.</span> <span class="nav-text">pthread_detach函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pthread-cancel%E5%87%BD%E6%95%B0"><span class="nav-number">5.7.2.5.</span> <span class="nav-text">pthread_cancel函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pthread-equal%E5%87%BD%E6%95%B0"><span class="nav-number">5.7.2.6.</span> <span class="nav-text">pthread_equal函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%87%BD%E6%95%B0%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%87%BD%E6%95%B0%E6%AF%94%E8%BE%83"><span class="nav-number">5.7.2.7.</span> <span class="nav-text">进程函数和线程函数比较</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%B1%9E%E6%80%A7"><span class="nav-number">5.7.3.</span> <span class="nav-text">线程属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">5.7.4.</span> <span class="nav-text">线程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="nav-number">5.7.4.1.</span> <span class="nav-text">互斥锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%94%81%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="nav-number">5.7.4.1.1.</span> <span class="nav-text">互斥锁相关函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#pthread-mutex-init%E5%87%BD%E6%95%B0"><span class="nav-number">5.7.4.1.2.</span> <span class="nav-text">pthread_mutex_init函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#pthread-mutex-destroy%E5%87%BD%E6%95%B0"><span class="nav-number">5.7.4.1.3.</span> <span class="nav-text">pthread_mutex_destroy函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#pthread-mutex-lock%E5%87%BD%E6%95%B0"><span class="nav-number">5.7.4.1.4.</span> <span class="nav-text">pthread_mutex_lock函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#pthread-mutex-unlock%E5%87%BD%E6%95%B0"><span class="nav-number">5.7.4.1.5.</span> <span class="nav-text">pthread_mutex_unlock函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#pthread-mutex-trylock%E5%87%BD%E6%95%B0"><span class="nav-number">5.7.4.1.6.</span> <span class="nav-text">pthread_mutex_trylock函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A0%E9%94%81%E5%92%8C%E8%A7%A3%E9%94%81"><span class="nav-number">5.7.4.1.7.</span> <span class="nav-text">加锁和解锁</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">5.7.4.2.</span> <span class="nav-text">死锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="nav-number">5.7.4.3.</span> <span class="nav-text">读写锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81%E4%B8%BB%E8%A6%81%E5%87%BD%E6%95%B0"><span class="nav-number">5.7.4.3.1.</span> <span class="nav-text">读写锁主要函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="nav-number">5.7.4.4.</span> <span class="nav-text">条件变量</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="nav-number">5.7.4.4.1.</span> <span class="nav-text">条件变量相关函数</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#pthread-cond-init"><span class="nav-number">5.7.4.4.1.1.</span> <span class="nav-text">pthread_cond_init</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#pthread-cond-destroy"><span class="nav-number">5.7.4.4.1.2.</span> <span class="nav-text">pthread_cond_destroy</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#pthread-cond-wait"><span class="nav-number">5.7.4.4.1.3.</span> <span class="nav-text">pthread_cond_wait</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#pthread-cond-signal"><span class="nav-number">5.7.4.4.1.4.</span> <span class="nav-text">pthread_cond_signal</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">5.7.4.5.</span> <span class="nav-text">信号量</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="nav-number">5.7.4.5.1.</span> <span class="nav-text">信号量相关函数</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#sem-init%E5%87%BD%E6%95%B0"><span class="nav-number">5.7.4.5.1.1.</span> <span class="nav-text">sem_init函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#sem-wait%E5%87%BD%E6%95%B0"><span class="nav-number">5.7.4.5.1.2.</span> <span class="nav-text">sem_wait函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#sem-post%E5%87%BD%E6%95%B0"><span class="nav-number">5.7.4.5.1.3.</span> <span class="nav-text">sem_post函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#sem-trywait%E5%87%BD%E6%95%B0"><span class="nav-number">5.7.4.5.1.4.</span> <span class="nav-text">sem_trywait函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#sem-destroy%E5%87%BD%E6%95%B0"><span class="nav-number">5.7.4.5.1.5.</span> <span class="nav-text">sem_destroy函数</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ZEROKO14</p>
  <div class="site-description" itemprop="description">你好，欢迎来到ZEROKO14的个人博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZEROKO14</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>-->

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/muse.js"></script>


<script src="/blog/js/next-boot.js"></script>


  <script defer src="/blog/lib/three/three.min.js"></script>
    <script defer src="/blog/lib/three/three-waves.min.js"></script>


  















  

  

</body>
</html>
