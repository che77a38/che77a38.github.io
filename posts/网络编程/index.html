<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>网络编程 | ZEROKO14的个人博客</title><meta name="keywords" content="网络"><meta name="author" content="ZEROKO14"><meta name="copyright" content="ZEROKO14"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#18171d"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="网络编程"><meta name="application-name" content="网络编程"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#18171d"><meta property="og:type" content="article"><meta property="og:title" content="网络编程"><meta property="og:url" content="https://che77a38.github.io/posts/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/index.html"><meta property="og:site_name" content="ZEROKO14的个人博客"><meta property="og:description" content="网络基础 OSI七层,TCP&amp;#x2F;IP四层模型结构 常见网络协议格式 网络字节序和主机字节序之间的转换(大端法和小端法) tcp服务器端&amp;#x2F;客户端通信流程    网络是如何通信的优质讲解视频 网络怎么变靠谱的优质视频 分层模型网络分层OSI 7层模型OSI是Open System In"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4"><meta property="article:author" content="ZEROKO14"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4"><meta name="description" content="网络基础 OSI七层,TCP&amp;#x2F;IP四层模型结构 常见网络协议格式 网络字节序和主机字节序之间的转换(大端法和小端法) tcp服务器端&amp;#x2F;客户端通信流程    网络是如何通信的优质讲解视频 网络怎么变靠谱的优质视频 分层模型网络分层OSI 7层模型OSI是Open System In"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://che77a38.github.io/posts/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2024/07/27/125766904/ba62475f396df9de3316a08ed9e65d86_5680958632268053399..png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":true,"limitCount":50,"languages":{"author":"作者: ZEROKO14","link":"链接: ","source":"来源: ZEROKO14的个人博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'ZEROKO14的个人博客',
  title: '网络编程',
  postAI: '',
  pageFillDescription: '网络基础, 分层模型, 网络分层OSI 7层模型, TCPx2FIP  4层模型, TCPx2FIP协议分层通讯全过程, 协议, 网络相关名词, 设备相关, 以太网交换机工作原理, 路由表(Routing Table), 路由条目, 缺省路由条目, 路由器工作原理, 其他名词, 半双工x2F全双工, DNS服务器, windows下如何修改hosts文件, 局域网(LAN), 广域网(WAN), MTU, 网络相关命令, 网络程序的设计模式, Cx2FS设计模式, Bx2FS设计模式, tcp原理, 三次握手四次挥手, 建立三次握手的过程, 数据传输的过程, 关闭连接（四次挥手）的过程, tcp状态转换, 滑动窗口, mss和MTU的区别, 以太网帧格式, ARP数据报格式, 抓包命令, IP段格式, ip分片, 路由机制, IPv6, UDP数据报格式, UDP头部格式, udp连接机制, TCP数据流格式, tcp头部结构, 典型选项结构, TCP连接机制, ip地址转换, inet_pton函数, inet_ntop函数, 网络字节序, 大小端转换, 同步与异步, 阻塞与非阻塞, DNS解析过程, URL和URN, 正向x2F反向代理, 正向代理, 反向代理, 防盗链, socket编程, 相关结构体, 主要函数, socket函数, bind函数, listen函数, accept函数, connect函数, 读写相关函数, 确保write和read发送数据完全, 测试工具, nc命令, netstat命令, 案例, 服务器开发流程, 客户端开发流程, linuxx2FMac代码, 服务器, 客户端, , 服务器, 客户端, 网络开发的注意点及完整案例, 防止阻塞被信号打断, 粘包, 多并发服务器, 设置非阻塞实现, 多进程实现, 多线程实现, 半关闭状态, shutdown函数, 端口复用, setsockopt函数, getsockopt函数, 心跳包, 高并发服务器模型select, select函数, select开发服务端代码, 练习, poll与epoll, 多路IO-poll, 多路IO-epoll, 相关函数, epoll_create函数, epoll_ctl函数, epoll_wait函数, 实现案例, ET工作模式, et模式案例, epoll反应堆, 线程池, 实现原理, 案例, 简单版本代码, 复杂版本, UDP通信, 相关函数, recvfrom函数, sendto函数, 案例, udp服务端简单代码, udp客户端简单代码, 本地socket通信, 代码案例, TCP, UDP, 第三方库, libevent库, libevent安装, libevent库的使用, event_base相关结构与函数, event_base函数, event_base_free函数, event_reinit函数, event_get_supported_methods函数, event_base_get_method函数, event_base_loop函数, event_base_dispatch函数, event_base_loopexit函数, event_base_loopbreak函数, 使用libevent库的流程, event相关函数和结构, event_new函数, event_add函数, event_del函数, event_free函数, libevent开发流程, libevent代码案例, bufferevent, bufferevent相关函数, bufferevent_socket_new函数, bufferevent_socket_connect函数, bufferevent_free函数, bufferevent_setcb函数, bufferevent_write函数, bufferevent_write_buffer函数, bufferevent_read函数, bufferevent_read_buffer函数, bufferevent_enable函数, bufferevent_disable函数, bufferevent_get_output函数, bufferevent_get_input函数, evbuffer_get_length函数, 链接监听器, 链接监听器相关函数, evconnlistener_new_bind函数, evconnlistener_new函数, evconnlistener_free函数, evconnlistener_enable函数, evconnlistener_disable函数, bufferevent和链接器服务器流程, 主流程, 客户端连接回调流程, 读回调流程, 最终代码案例, 服务器代码, 客户端代码, 通信效率优化, 客户端优化, 客户端案例, TcpClient.h, TcpClient.cpp, 服务端优化, 服务端案例, TcpServer.h, TcpServer.cpp, web服务器, http协议, http请求消息, 请求类型, 请求头中重要内容, Content-Type, http响应消息, http常见状态码, http常见文件类型分类, 响应头中重要内容, cookie详解, 设置Cookie, 使用Cookie, https协议, TLS握手过程, web测试工具, curl, web服务器开发, 读取到内容后的流程, 基于epoll的web服务器, 基于select的web服务器, 中文汉字编码问题, 一些特殊符号, 基于libevent的web服务器, web服务器框架, Nginx, REST API, CGI, fastCGI, 安装与配置, fastCGI环境变量, fastCGI程序开发, 分布式服务器, 分布式文件系统, FastDFS, FastDFS集群, fastDFS安装, FastDFS启动, 上传下载代码实现, 使用多进程方式实现, 使用fastDFS API实现, fastDFS配合fastCGI项目, 日志实现案例, 源文件, 头文件log.h, 使用方式, 报文编解码, 常用序列化方式, XML, Json, Protocol Buffer, 其他, ASN.1, 相关函数, DER_ItAsn1_WriteInteger, DER_ItAsn1_ReadInteger, DER_ItAsn1_WritePrintableString, DER_ItAsn1_ReadPrintableString, DER_ITCAST_String_To_AnyBuf, EncodeCharx2FDecodeChar, EncodeChar, DecodeChar, 解码上两种方式的区别体现, DER_ItAsn1_WriteSequence, DER_ItAsn1_ReadSequence, DER_ITCAST_FreeQueue, 使用案例, 简单使用案例, 进一步封装, SequenceASN1.h, SequenceASN1.cpp, CSharp网络通信, TcpClientx2FTcpListener, TcpClient, TcpListener, 案例, 服务端, 客户端, 二进制读写, Socket, 常用属性及说明, 常用方法及说明, 案例, 客户端, 服务器, 常用网络相关命令, UDP打洞, 域名相关, 托管域名, DNSChecker网络基础七层四层模型结构常见网络协议格式网络字节序和主机字节序之间的转换大端法和小端法服务器端客户端通信流程网络是如何通信的优质讲解视频网络怎么变靠谱的优质视频分层模型网络分层层模型是的缩写意为开放式系统互联国际标准化组织制定了模型该模型定义了不同计算机互联的标准是设计和描述计算机网络通信的基本框架物理层双绞线光纤传输介质将模拟信号转换为数字信号通过调制解调器数据链路层数据校验定义了网络传输的基本单位帧协议网络层定义网络两台机器之间传输的路径选择点到点的传输协议传输层传输数据端到端的传输不需要考虑中间经过的点协议会话层通过传输层建立数据传输的通道表示层编解码翻译工作应用层为客户提供各种应用服务服务服务服务详解分层功能物理层主要定义物理设备标准如网线的接口类型光纤的接口类型各种传输介质的传输速率等它的主要作用是传输比特流就是由转化为电流强弱来进行传输到达目的地后再转化为也就是我们常说的数模转换与模数转换这一层的数据叫做比特数据链路层定义了如何让格式化数据以帧为单位进行传输以及如何让控制对物理介质的访问这一层通常还提供错误检测和纠正以确保数据的可靠传输如串口通信中使用到的网络层在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择的发展使得从世界各站点访问信息的用户数大大增加而网络层正是管理这种连接的层传输层定义了一些传输数据的协议和端口号端口等如传输控制协议传输效率低可靠性强用于传输可靠性要求高数据量大的数据用户数据报协议与特性恰恰相反用于传输可靠性要求不高数据量小的数据如聊天数据就是通过这种方式传输的主要是将从下层接收的数据进行分段和传输到达目的地址后再进行重组常常把这一层数据叫做段会话层通过传输层端口号传输端口与接收端口建立数据传输的通路主要在你的系统之间发起会话或者接受会话请求设备之间需要互相认识可以是也可以是或者是主机名表示层可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取例如程序与另一台计算机进行通信其中一台计算机使用扩展二一十进制交换码而另一台则使用美国信息交换标准码来表示相同的字符如有必要表示层会通过使用一种通格式来实现多种数据格式之间的转换应用层是最靠近用户的层这一层为用户的应用程序例如电子邮件文件传输和终端仿真提供网络服务层模型上面的模型只是一个理想模型实际上现在应用的是四层模型网络协议栈分为应用层传输层网络层和链路层四层分层的含义如下图传输层及其以下的机制由内核提供应用层由用户进程提供后面将介绍如何使用编写应用程序应用程序对通讯数据的含义进行解释而传输层及其以下处理通讯的细节将数据从一台计算机通过一定的路径发送到另一台计算机应用层数据通过协议栈发到网络上时每层协议都要加上一个数据首部称为封装如下图所示通信过程其实就是发送端层层打包接收方层层解包不同的协议层对数据包有不同的称谓在传输层叫做段在网络层叫做数据报在链路层叫做帧数据封装成帧后发到传输介质上到达目的主机后每层协议再剥掉相应的首部最后将应用层数据交给应用程序处理协议分层通讯全过程链路层有以太网令牌环网等标准链路层负责网卡设备的驱动帧同步即从网线上检测到什么信号算作新帧的开始冲突检测如果检测到冲突就自动重发数据差错校验等工作交换机是工作在链路层的网络设备可以在不同的链路层网络之间转发数据帧比如十兆以太网和百兆以太网之间以太网和令牌环网之间由于不同链路层的帧格式不同交换机要将进来的数据包拆掉链路层首部重新封装之后再转发链路层有以太网令牌环网等标准链路层负责网卡设备的驱动帧同步即从网线上检测到什么信号算作新帧的开始冲突检测如果检测到冲突就自动重发数据差错校验等工作交换机是工作在链路层的网络设备可以在不同的链路层网络之间转发数据帧比如十兆以太网和百兆以太网之间以太网和令牌环网之间由于不同链路层的帧格式不同交换机要将进来的数据包拆掉链路层首部重新封装之后再转发网络层的协议是构成的基础上的主机通过地址来标识上有大量路由器负责根据地址选择合适的路径转发数据包数据包从上的源主机到目的主机往往要经过十多个路由器路由器是工作在第三层的网络设备同时兼有交换机的功能可以在不同的链路层接口之间转发数据包因此路由器需要将进来的数据包拆掉网络层和链路层两层首部并重新封装协议不保证传输的可靠性数据包在传输过程中可能丢失可靠性可以在上层协议或应用程序中提供支持网络层负责点到点的传输这里的点指主机或路由器而传输层负责端到端的传输这里的端指源主机和目的主机传输层可选择或协议是一种面向连接的可靠的协议有点像打电话双方拿起电话互通身份之后就建立了连接然后说话就行了这边说的话那边保证听得到并且是按说话的顺序听到的说完话挂机断开连接也就是说传输的双方需要首先建立连接之后由协议保证数据收发的可靠性丢失的数据包自动重发上层应用程序收到的总是可靠的数据流通讯之后关闭连接是无连接的传输协议不保证可靠性有点像寄信信写好放到邮筒里既不能保证信件在邮递过程中不会丢失也不能保证信件寄送顺序使用协议的应用程序需要自己完成丢包重发消息排序等工作目的主机收到数据包后如何经过各层协议栈最后到达应用程序呢其过程如下图所示以太网驱动程序首先根据以太网首部中的上层协议字段确定该数据帧的有效载荷指除去协议首部之外实际传输的数据是还是协议的数据报然后交给相应的协议处理假如是数据报协议再根据首部中的上层协议字段确定该数据报的有效载荷是还是然后交给相应的协议处理假如是段或段或协议再根据首部或首部的端口号字段确定应该将应用层数据交给哪个用户进程地址是标识网络中不同主机的地址而端口号就是同一台主机上标识不同进程的地址地址和端口号合起来标识网络中唯一的进程虽然和数据报都需要以太网驱动程序来封装成帧但是从功能上划分和属于链路层属于网络层虽然的数据都需要协议来封装成数据报但是从功能上划分与同属于网络层和属于传输层协议协议事先约定好大家共同遵守的一组规则如交通信号灯从应用程序的角度看协议可理解为数据传输和数据解释的规则可以简单的理解为各个主机之间进行通信所使用的共同语言当原始协议经过不断增加完善改进最终形成了一个稳定的完整的传输协议被广泛应用于各种文件传输该协议逐渐就成了一个标准协议几种常见的标准协议传输层常见协议有协议应用层常见的协议有协议协议网络层常见协议有协议协议协议网络接口层常见协议有协议协议协议注重数据的传输协议着重于数据的解释具体协议含义传输控制协议是一种面向连接的可靠的基于字节流的传输层通信协议用户数据报协议是参考模型中一种无连接的传输层协议提供面向事务的简单不可靠信息传送服务超文本传输协议是互联网上应用最为广泛的一种网络协议文件传输协议协议是因特网互联协议协议是控制报文协议它是协议族的一个子协议用于在主机路由器之间传递控制消息协议是组管理协议是因特网协议家族中的一个组播协议该协议运行在主机和组播路由器之间协议是正向地址解析协议通过已知的寻找对应主机的地址是反向地址转换协议通过地址确定地址网络相关名词设备相关路由名词数据包从源地址到目的地址所经过的路径由一系列路由节点组成路由动词某个路由节点为数据包选择投递方向的选路过程路由节点一个具有路由能力的主机或路由器它维护一张路由表通过查询路由表来决定向哪个接口发送数据包以太网交换机工作原理以太网交换机是基于以太网传输数据的交换机以太网采用共享总线型传输媒体方式的局域网以太网交换机的结构是每个端口都直接与主机相连并且一般都工作在全双工方式交换机能同时连通许多对端口使每一对相互通信的主机都能像独占通信媒体那样进行无冲突地传输数据以太网交换机工作于网络参考模型的第二层即数据链路层是一种基于介质访问控制地址识别完成以太网数据帧转发的网络设备交换机刚启动时地址表中无表项当接入的时候交换机开始进行学习地址交换机对数据帧的转发与过滤单播帧的转发发出目的到的单播数据帧交换机根据帧中的目的地址从相应的端口发送出去交换机不在其他端口上转发此单播数据帧广播组播和未知单播帧的转发交换机会把广播组播和未知单播帧从所有其他端口发送出去除了接收到帧的端口交换机原理详解跳转路由表在计算机网络中路由表或称路由择域信息库是一个存储在路由器或者联网计算机中的电子表格文件或类数据库路由表存储着指向特定网络地址的路径路由条目路由表中的一行每个条目主要由目的网络地址子网掩码下一跳地址发送接口四部分组成如果要发送的数据包的目的网络地址匹配路由表中的某一行就按规定的接口发送到下一跳地址缺省路由条目路由表中的最后一行主要由下一跳地址和发送接口两部分组成当目的地址与路由表中其它行都不匹配时就按缺省路由条目规定的接口发送到下一跳地址路由器工作原理路由器是连接因特网中各局域网广域网的设备它会根据信道的情况自动选择和设定路由以最佳路径按前后顺序发送信号的设备传统地路由器工作于七层协议中的第三层其主要任务是接收来自一个网络接口的数据包根据其中所含的目的地址决定转发到下一个目的地址因此路由器首先得在转发路由表中查找它的目的地址若找到了目的地址就在数据包的帧格前添加下一个地址同时数据包头的域也开始减数并重新计算校验和当数据包被送到输出端口时它需要按顺序等待以便被传送到输出链路上路由器在工作时能够按照某种路由通信协议查找设备中的路由表如果到某一特定节点有一条以上的路径则基本预先确定的路由准则是选择最优或最经济的传输路径由于各种网络段和其相互连接情况可能会因环境变化而变化因此路由情况的信息一般也按所使用的路由信息协议的规定而定时更新网络中每个路由器的基本功能都是按照一定的规则来动态地更新它所保持的路由表以便保持路由信息的有效性为了便于在网络间传送报文路由器总是先按照预定的规则把较大的数据分解成适当大小的数据包再将这些数据包分别通过相同或不同路径发送出去当这些数据包按先后秩序到达目的地后再把分解的数据包按照一定顺序包装成原有的报文形式路由器的分层寻址功能是路由器的重要功能之一该功能可以帮助具有很多节点站的网络来存储寻址信息同时还能在网络间截获发送到远地网段的报文起转发作用选择最合理的路由引导通信也是路由器基本功能多协议路由器还可以连接使用不同通信协议的网络段成为不同通信协议网络段之间的通信平台路由和交换之间的主要区别就是交换发生在参考模型第二层数据链路层而路由发生在第三层即网络层这一区别决定了路由和交换在移动信息的过程中需使用不同的控制信息所以两者实现各自功能的方式是不同的如上图图所示路由器和是经过配置的路由在他们的路由表中就保存了相应的网段和接口如果主机要发送数据包给主机因为地址不在同一网段主机就会将数据包发送给本网段的网关路由器路由器接收到数据包查看数据包首部中的目标地址在查找自己的路由表数据包的目标地址是属于网段路由器在路由表中查到网段转发的接口是接口于是路由器就将数据包从接口转发出去每个路由器但是按这个步骤去转发数据的直到到达了路由器用同样的方法从口转发出去主机接受到这个数据包同网段和不同网段主机通信的区别就在于同网段直接查找主机而不同网段需要将数据包发送给网关其他名词集线器半双工全双工全双工全双工是在通道中同时双向数据传输的能力半双工在通道中同时只能沿着一个方向传输数据服务器是域名系统的缩写是因特网的一项核心服务它作为可以将域名和地址相互映射的一个分布式数据库能够使人更方便的访问互联网而不用去记住能够被机器直接读取的地址串它是由解析器以及域名服务器组成的域名服务器是指保存有该网络中所有主机的域名和对应地址并具有将域名转换为地址功能的服务器操作系统中可通过文件手动设置如何解析域名系统文件格式地址域名行表示注释修改后需要刷新缓存使之生效下如何修改文件文件要先修改属性取消只读再修改使用管理员身份运行一个文件编辑程序再打开文件进行修改要么就是修改文件的权限不建议局域网一种覆盖一座或几座大楼一个校园或者一个厂区等地理区域的小范围的计算机网覆盖的地理范围较小只在一个相对独立的局部范围内联如一座或集中的建筑群内使用专门铺设的传输介质进行联网数据传输速率高通信延迟时间短可靠性较高局域网可以支持多种传输介质广域网一种用来实现不同地区的局域网或城域网的互连可提供不同地区城市和国家之间的计算机通信的远程计算机网覆盖的范围比局域网和城域网都广广域网的通信子网主要使用分组交换技术广域网的通信子网可以利用公用分组交换网卫星通信网和无线分组交换网它将分布在不同地区的局域网或计算机系统互连起来达到资源共享的目的如互联网是世界范围内最大的广域网适应大容量与突发性通信的要求适应综合业务服务的要求开放的设备接口与规范化的协议完善的通信服务与网络管理通信术语最大传输单元是指一种通信协议的某一层上面所能通过的最大数据包大小以字节为单位最大传输单元这个参数通常与通信接口有关网络接口卡串口等以下是一些协议的协议字节以太网协议字节协议字节协议字节字节网络相关命令命令查看网络信息下还可以使用命令部分系统需要安装查询路由表查询经过的路由器信息域名域名域名打印公网网络程序的设计模式设计模式传统的网络应用设计模式客户机服务器模式需要在通讯两端各自部署客户机和服务器来完成数据通信优点客户端在本机上可以保证性能可以将数据缓存到本地提高数据的传输效率提高用户体验效果客户端和服务端程序都是由同一个开发团队开发协议选择比较灵活缺点服务器和客户端都需要开发工作量相对较大调试困难开发周期长从用户的角度看需要将客户端安装到用户的主机上对用户主机的安全构成威胁设计模式浏览器服务器模式只需在一端部署服务器而另外一端使用每台都默认配置的浏览器即可完成数据的传输优点无需安装客户端可以使用标准的浏览器作为客户端只需要开发服务器工作量相对较小由于采用标准的客户端所以移植性好不受平台限制相对安全不用安装软件缺点由于没有客户端数据缓冲不尽人意数据传输有限制用户体验较差通信协议选择只能使用协议协议选择不够灵活对于模式来说其优点明显客户端位于目标主机上可以保证性能将数据缓存至客户端本地从而提高数据传输效率且一般来说客户端和服务器程序由一个开发团队创作所以他们之间所采用的协议相对灵活可以在标准协议的基础上根据需求裁剪及定制例如腾讯公司所采用的通信协议即为协议的修改剪裁版因此传统的网络应用程序及较大型的网络应用程序都首选模式进行开发如知名的网络游戏魔兽世界画面数据量庞大使用模式可以提前在本地进行大量数据的缓存处理从而提高观感模式的缺点也较突出由于客户端和服务器都需要有一个开发团队来完成开发工作量将成倍提升开发周期较长另外从用户角度出发需要将客户端安插至用户主机上对用户主机的安全性构成威胁这也是很多用户不愿使用模式应用程序的重要原因模式相比模式而言由于它没有独立的客户端使用标准浏览器作为客户端其工作开发量较小只需开发服务器端即可另外由于其采用浏览器显示数据因此移植性非常好不受平台限制如早期的偷菜游戏在各个平台上都可以完美运行模式的缺点也较明显由于使用第三方浏览器因此网络应用支持受限另外没有客户端放到对方主机上缓存数据不尽如人意从而传输数据量受到限制应用的观感大打折扣第三必须与浏览器一样采用标准协议进行通信协议选择不灵活因此在开发过程中模式的选择由上述各自的特点决定根据实际需求选择应用程序设计模式原理三次握手四次挥手建立连接需要三次握手断开连接需要四次挥手段的箭头上标着表示该段中的位置位序号是该段不携带有效载荷数据字节数为位置位确认序号是带有一个最大报文长度选项值为表示确认序号确认序号的值是对方发送的序号值数据的长度特别注意的是和本身也会占用一位建立三次握手的过程客户端发送一个带标志的报文到服务器这是三次握手过程中的段客户端发出段位表示连接请求序号是这个序号在网络通讯中用作临时的地址每发一个数据字节这个序号要加这样在接收端可以根据序号排出数据包的正确顺序也可以发现丢包的情况另外规定位和位也要占一个序号这次虽然没发数据但是由于发了位因此下次再发送应该用序号表示最大段尺寸如果一个段太大封装成帧后超过了链路层的最大帧长度就必须在层分片为了避免这种情况客户端声明自己的最大段尺寸建议服务器端发来的段不要超过这个长度服务器端回应客户端是三次握手中的第个报文段同时带标志和标志它表示对刚才客户端的回应同时又发送给客户端询问客户端是否准备好进行数据通讯服务器发出段也带有位同时置位表示确认确认序号是表示我接收到序号及其以前所有的段请你下次发送序号为的段也就是应答了客户端的连接请求同时也给客户端发出一个连接请求同时声明最大尺寸为客户必须再次回应服务器端一个报文这是报文段客户端发出段对服务器的连接请求进行应答确认序号是在这个过程中客户端和服务器分别给对方发了连接请求也应答了对方的连接请求其中服务器的请求和应答在一个段中发出因此一共有三个段用于建立连接称为三方握手在建立连接的同时双方协商了一些信息例如双方发送序号的初始值最大段尺寸等在通讯中如果一方收到另一方发来的段读出其中的目的端口号发现本机并没有任何进程使用这个端口就会应答一个包含位的段给另一方例如服务器并没有任何进程使用端口我们却用客户端去连接它服务器收到客户端发来的段就会应答一个段客户端的程序收到段后报告错误数据传输的过程客户端发出段包含从序号开始的个字节数据服务器发出段确认序号为对序号为的数据表示确认收到同时请求发送序号开始的数据服务器在应答的同时也向客户端发送从序号开始的个字节数据这称为客户端发出段对服务器发来的序号为的数据表示确认收到请求发送序号开始的数据在数据传输过程中和确认序号是非常重要的应用程序交给协议发送的数据会暂存在层的发送缓冲区中发出数据包给对方之后只有收到对方应答的段才知道该数据包确实发到了对方可以从发送缓冲区中释放掉了如果因为网络故障丢失了数据包或者丢失了对方发回的段经过等待超时后协议自动将发送缓冲区中的数据包重发关闭连接四次挥手的过程由于连接是全双工的因此每个方向都必须单独进行关闭这原则是当一方完成它的数据发送任务后就能发送一个来终止这个方向的连接收到一个只意味着这一方向上没有数据流动一个连接在收到一个后仍能发送数据首先进行关闭的一方将执行主动关闭而另一方执行被动关闭客户端发出段位表示关闭连接的请求服务器发出段应答客户端的关闭连接请求服务器发出段其中也包含位向客户端发送关闭连接请求客户端发出段应答服务器的关闭连接请求建立连接的过程是三方握手而关闭连接通常需要个段服务器的应答和关闭连接请求通常不合并在一个段中因为有连接半关闭的情况这种情况下客户端关闭连接之后就不能再发送数据给服务器了但是服务器还可以发送数据给客户端直到服务器也关闭连接为止当双方刚好同时关闭的时候概率很低是存在和包合并为同一个发送的情况的这种情况只需要三步挥手便结束了重点的问题理解为什么四次挥手中被动被请求关闭连接的一方要发送一个确认包和一个请求关闭连接包而不能仅仅发一个请求连接包因为第一个确认包仅仅表示收到了对方关闭连接的请求但自身却还可能有未发送完的数据第二个请求关闭连接包才真正表示自身的发送也完成可以关闭了即表示第一个包和第二个包之间依然可以发送未发送完的数据包为什么最先请求关闭连接的一方在第四次挥手发送确认包后还要等待倍时间让四次挥手的过程更可靠确保最后一个发送给对方的到达若对方没有收到应答对方会再次发送请求关闭此时在时间内被动关闭方仍然可以发送给对方补充解释发送的有可能丢失如果丢失另一方会重发关闭连接请求包两个时间可以大幅度增加接收到重发的关闭连接请求包的情况的可能但是情况依旧不完美因为重发的关闭请求包也存在丢失的可能如果也丢失了重发的时间又超过了倍时间那么他将等不到发回来的确定包即等不到关闭的时机脑补应该用心跳包解决为了保证在时间内不能启动相同的一定是出现在主动关闭的一方也就是说是针对主动关闭一方来说的由于有可能存在丢包重传丢包重传若发给了已经断开连接之后相同的该连接是新建的与原来的完全相同双方使用的是相同的和端口这样会对之后的连接造成困扰严重可能引起程序异常因此很多操作系统实现的时候只要端口被占用服务就不能启动通过这个方式尽可能解决该程序异常实际上服务端每次都是使用的同一个端口而客户端一般设置为由内核分配随机端口会避免这种问题发生因此实际上很难发生这样的情况主动断开方查看端口号会发现状态为状态转换的概念客户端与服务端连接其实是一个连接对可以通过使用端口号进行查看他也可以查询是什么进程占用着端口说明上图中粗线表示主动方虚线表示被动方细线部分表示一些特殊情况三次握手过程客户端服务端客户端服务端收到连接请求的时候状态转换数据传输过程中状态不会发生变化一直都是状态四次挥手过程客户端服务端主动关闭方收到被动接收方确认断开连接请求的时候状态转换收到被动接收方的断开请求时候的状态转换被动关闭方收到断开连接请求的时候状态转换主动关闭的端会进入状态并且持续时间长度就是最大分节生命期这是一个数据包能在互联网上生存的最长时间超过这个时间将在网络中消失滑动窗口主要作用滑动窗口主要是进行流量控制的见下图如果发送端发送的速度较快接收端接收到数据后处理的速度较慢而接收缓冲区的大小是固定的就会导致接收缓冲区满而丢失数据协议通过滑动窗口机制解决这一问题发送端发起连接声明最大段尺寸是初始序号是窗口大小是表示我的接收缓冲区还有字节空闲你发的数据不要超过接收端应答连接请求声明最大段尺寸是初始序号是窗口大小是发送端应答三方握手结束发送端发出段每个段带的数据发送端根据窗口大小知道接收端的缓冲区满了因此停止发送数据接收端的应用程序提走数据接收缓冲区又有了空闲接收端发出段在应答已收到数据的同时声明窗口大小为接收端的应用程序又提走数据接收缓冲区有空闲接收端发出段重新声明窗口大小为发送端发出段每个段带数据段同时还包含位接收端应答接收到的数据再加上位占一个序号因此应答序号是连接处于半关闭状态接收端同时声明窗口大小为接收端的应用程序提走数据接收端重新声明窗口大小为接收端的应用程序提走剩下的数据接收缓冲区全空接收端重新声明窗口大小为接收端的应用程序在提走全部数据后决定关闭连接发出段包含位发送端应答连接完全关闭表示告诉对方我这边缓冲区大小是多少表示告诉对方我这边最多一次可以接收多少数据你最好不要超过这个长度在客户端给服务端发包的时候不一定是非要等到服务端返回响应包由于客户端知道服务端的窗口大小所以可以持续多次发送当发送数据达到对方窗口大小了就不再发送需要等到对方进行处理对方处理之后可继续发送从这个例子还可以看出发送端是一一地发送数据而接收端的应用程序可以两两地提走数据当然也有可能一次提走或数据或者一次只提走几个字节的数据也就是说应用程序所看到的数据是一个整体或说是一个流在底层通讯中这些数据可能被拆成很多数据包来发送但是一个数据包有多少字节对应用程序是不可见的因此协议是面向流的协议而是面向消息的协议每个段都是一条消息应用程序必须以消息为单位提取数据不能一次提取任意字节的数据这一点和是很不同的和的区别最大传输单元是指一种通信协议的某一层上面所能通过的最大数据包大小以字节为单位最大传输单元这个参数通常与通信接口有关网络接口卡串口等这个值如果设置为太大会导致丢包重传的时候重传的数据量较大图中的最大值是其实是一个经验值最大报文长度只是在建立连接的时候告诉对方我最大能够接收多少数据在数据通信的过程中就没有了概括来讲是以太网数据链路层中约定的数据载荷部分最大长度数据不超过它时就无需分片是传输层的概念由于数据往往很大会超出所以我们之前在网络层中学习过分片的知识将很大的数据载荷分割为多个分片发送出去为了层不用分片主动将数据包切割为大小一个等式可见他两关系匪浅头大小头大小以太网帧格式以太网帧格式就是包装在网络接口层数据链路层的协议以太网帧的类型为表示类型表示类型其中的源地址和目的地址是指网卡的硬件地址也叫地址长度是位是在网卡出厂时固化的可在中使用命令查看部分就是硬件地址协议字段有三种值分别对应帧尾是校验码以太网帧中的数据长度规定最小字节最大字节和数据包的长度不够字节要在后面补填充位填充位的内容没有定义与具体实现相关最大值称为以太网的最大传输单元不同的网络类型有不同的如果一个数据包从以太网路由到拨号链路上数据包长度大于拨号链路的则需要对数据包进行分片命令输出中也有注意这个概念指数据帧中有效载荷的最大长度不包括帧头长度以为例介绍以太网帧格式数据报格式地址解析协议在网络通讯时源主机的应用程序知道目的主机的地址和端口号却不知道目的主机的硬件地址而数据包首先是被网卡接收到再去处理上层协议的如果接收到的数据包的硬件地址与本机不符则直接丢弃因此在通讯前必须获得目的主机的硬件地址协议就起到这个作用源主机发出请求询问地址是的主机的硬件地址是多少并将这个请求广播到本地网段以太网帧首部的硬件地址填表示广播目的主机接收到广播的请求发现其中的地址与本机相符则发送一个应答数据包给源主机将自己的硬件地址填写在应答包中每台主机都维护一个缓存表可以用命令查看缓存表中的表项有过期时间一般为分钟如果分钟内没有再次使用某个表项则该表项失效下次还要发请求来获得目的主机的硬件地址数据报的格式如下所示源地址目的地址在以太网首部和请求中各出现一次对于链路层为以太网的情况是多余的但如果链路层是其它类型的网络则有可能是必要的硬件类型指链路层网络类型为以太网协议类型指要转换的地址类型为地址后面两个地址长度对于以太网地址和地址分别为和字节字段为表示请求字段为表示应答目的端地址是通过发送端发送广播接收到该数据的主机先判断是否是自己的若是则应答一个应答报文并将地址填入应答报文中若目的不是自己的主机则直接丢弃该请求报文如上图所示协议目的解决同一个局域网上的主机或路由器的地址和硬件地址的映射问题抓包命令抓包命令思考题如果源主机和目的主机不在同一网段请求的广播帧无法穿过路由器源主机如何与目的主机通信那么就要通过找到一个位于本局域网上的某个路由器的硬件地址然后把分组发送个这个路由器让这个路由器把分组转发给下一个网络剩下的工作就由下一个网络来做段格式协议是协议族的基石它为上层提供无状态无连接不可靠的服务无状态指通信双方不同步传输数据的状态信息因此所有数据报的发送传输接收都是相互独立的这种服务最大缺点是无法处理乱序和重复的数据报优点是简单高效和协议与协议相同都是无状态协议无连接指通信双方都不长久的维持对方的任何信息这表示上层协议每次发送数据都需要明确指定对方的地址不可靠指协议不能数据报能准确到达接收端只是会尽最大努力一旦发送失败就通知上层协议而不会试图重发位版本号指定协议的版本对于来说其值为其它扩展版本则具有不同的版本号如协议和协议位头部长度表示头部有多少个字字节因为位最大所以头部最长为字节位服务类型位优先级权字段现已被忽略位字段和位保留字段必须置位字段分别表示最小延迟最大吞吐量最高可靠性和最小费用其中最多个能置为位总长度指整个数据包的长度字节为单位最长字节由于长度超过的数据报将被分片传输所以实际传输的长度没有达到最大值位标识唯一标识主机发送的每个数据报初始值由系统随机生成每发送一个数据报其值加一该值在数据报分片时被复制到每个分片中因此同一个数据报的所有分片标识值都相同位标志第一位保留第二位表示是否禁止分片如果设置了该位数据报长度超过将被丢弃返回错误第三位表示更多分片除了最后一个分片其它都要置它为位分片偏移该分片相较于原始数据报开始处仅指数据部分的偏移实际偏移值是该值左移位得到因此除了最后一个分片每个分片的数据部分长度必须是的整数倍位生存时间数据报到达目的地之前允许经过的路由器跳数每经过一个路由该值减一为时被丢弃并返回错误报文位协议用于区分上层协议为为为位头部校验和由发送端填充接收端对其使用算法检验数据是否被损坏位源端地址标识数据报的发送端在传输过程中保持不变位源目的端地址标识数据报的接收端在传输过程中保持不变选项字段可变长的可选信息最多字节可用的选项有记录路由将数据包经由的所有路由器填入该段时间戳将数据报在每个路由器被转发时的时间填入该段松散源路由选择指定路由器地址列表数据报发送过程中必须经过其中所有路由器严格源路由选择类似上面数据报只能经过被指定的路由器未解决思考题想一想前面讲了以太网帧中的最小数据长度为字节不足字节的要用填充字节补上那么如何界定这字节里前多少个字节是或数据报而后面是填充字节分片当数据报的长度超过帧的时它将被分片传输分片可能发生在发送端也可能发生在中转路由器上而且在传输过程中可能被多次分片只有在最终目标机器上这些分片才会在内核中被模块重新组装头部中的数据报标识标志和片偏移为的分片和重组提供了足够的信息一个数据报的每个分片都具有自己的头部且具有相同的标识但具有不同的片偏移除了最后一个分片之外都设置了标志路由的工作模式模块收到来自数据链路层的数据报首先对数据报的头部做校验无误后开始分析头部具体信息如果数据报头部设置了源站选路选项则模块调用数据报转发子模块来处理该数据报如果该数据报的头部目标地址是本机的某个地址或者广播地址则模块根据数据报协议字段来决定发送给哪个上层应用如果不是本机则掉用数据报转发子模块来处理该数据报数据报转发模块检查系统是否允许转发不允许则丢弃允许则将该数据报执行一些操作就将它交给数据报输出模块数据报根据路由表计算下一跳路由输出队列存放所有等待发送的数据报路由机制查找路由表中和数据报的目标完全匹配的主机地址如果找到就直接使用该项没有就到第二步查找路由表中和目标具有相同的网路的地址如有就使用否则来到第三步选择默认路由项这一般为网关执行命令可查看路由表目标网络或主机网关地址表示目标与本机在同一个网络上不需要路由网络掩码路由标志该路由活动该路由目标是一个主机该路由目标是网关该路由是重定向产生的该路由被重定向修改过路由距离达到目标网络所需的中转数路由项被引用的次数该路由项被使用的次数该路由对应的输出网卡接口由个字节的固定头部和可变长的扩展头部组成位版本号协议版本值为位通信类型指示数据通信类型和优先级位流标志用于某些对连接服务质量有特殊要求的通信位净荷长度指扩展头部和应用程序数据长度之和不包含固定头部长度位下一个包头指紧跟固定头部的包头类型如扩展头或上层协议位跳数限制和的含义相同后两项地址地址一般用进制字符串表示用分割为组每组两个字节数据报格式无连接的不安全不可靠的是一个简单的面向消息的传输层协议尽管提供标头和有效负载的完整性验证通过校验和但它不保证向上层协议提供消息传递并且层在发送后不会保留消息的状态因此有时被称为不可靠的数据报协议如果需要传输可靠性则必须在用户应用程序中实现使用具有最小协议机制的简单无连接通信模型提供数据完整性的校验和以及用于在数据报的源和目标寻址不同函数的端口号它没有握手对话因此将用户的程序暴露在底层网络的任何不可靠的方面如果在网络接口级别需要纠错功能应用程序可以使用为此目的设计的传输控制协议是基于的简单协议不可靠的协议的优点简单轻量化的缺点没有流控制没有应答确认机制不能解决丢包重发错序问题并不是所有使用协议的应用层都是不可靠的应用程序可以自己实现可靠的数据传输通过增加确认和重传机制所以使用协议最大的特点就是速度快其他特点没有拥塞控制网络出现的拥塞不会使源主机的发送速率降低这对某些实时应用是很重要的支持一对一一对多多对一和多对多的交互通信的应用协议一般作为流媒体应用语音交流视频会议所使用的传输层协议还有许多基于互联网的电话服务使用的基于的语音也是基于运行的这些实时应用要求源主机以恒定的速率发送数据并且允许在网络出现拥塞时丢失一部分数据但却不允许数据有太大的时延协议正好适合这种要求头部格式通过地址来确定网络环境中的唯一的一台主机主机上使用端口号来区分不同的应用程序端口唯一确定一台主机上的一个服务应用程序中列出了所有规定的服务端口和对应的传输层协议这是由规定的其中有些服务既可以用也可以用为了清晰规定这样的服务采用相同的或默认端口号而另外一些和的相同端口号却对应不同的服务很多服务有规定的端口号然而客户端程序的端口号却不必是规定的往往是每次运行客户端程序时由系统自动分配一个空闲的端口号用完就释放掉称为的端口号发送端的协议层只管把应用层传来的数据封装成段交给协议层就算完成任务了如果因为网络故障该段无法发到对方协议层也不会给应用层返回任何错误信息接收端的协议层只管把收到的数据根据端口号交给相应的应用程序就算完成任务了如果发送端发来多个数据包并且在网络上经过不同的路由到达接收端时顺序已经错乱了协议层也不保证按发送时的顺序交给应用层通常接收端的协议层将收到的数据放在一个固定大小的缓冲区中等待应用程序来提取和处理如果应用程序提取和处理的速度很慢而发送端发送的速度很快就会丢失数据包协议层并不报告这种错误因此使用协议的应用程序必须考虑到这些可能的问题并实现适当的解决方案例如等待应答超时重发为数据包编号流量控制等一般使用协议的应用程序实现都比较简单只是发送一些对可靠性要求不高的消息而不发送大量的数据例如基于的协议一般只用于传送小文件所以才叫的而基于的协议适用于各种文件的传输举例基于的协议帧以太网首部首部首部协议是基于文本的协议各字段之间用字节分隔开头的表示请求读取一个文件接下来的各字段是抓包连接机制服务器在特定端口上收到数据包时将通过以下两个步骤进行响应服务器首先检查是否有任何当前侦听指定端口请求的程序正在运行如果该端口上没有程序正在接收数据包则服务器将以数据包作为响应以告知发送方目标不可达导致洪水攻击解决方案大多数操作系统限制数据包的响应速率数据流格式稳定的安全的可靠的原理跳转协议用于对即不能用于基于广播和多播的应用程序连接双方的收发数据次数不一定相同即发送多次的数据包可能会被对方次全部接收在发送数据报后必须得到接收方的应答才认为传输成功所以是可靠的采用超时重传机制超过时间没收到应答就会重新发送头部结构位端口号指定数据从哪个端口来发送到哪个端口位序号一次通信中每段字节流的编号如与通信第一个报文中序列值被系统初始化为随机值之后的传输到该序号值将被设定为初始值加上第一个字节在整个字节流中的偏移位确认号用作对另一方发送的报文段的响应其值是收到的报文段序号值加一位头部长度标识该头部有多少个字字节即最长为字节位标志位标识紧急指针是否有效标识确认号是否有效提示接收端应立即从接收缓存区中读走数据表示要求对方重新建立连接表示请求建立一个连接通知对方关闭连接位窗口大小流量控制的一个手段告诉对方本地接收缓存区还能容纳多少字节的数据位校验和由发送端填充接收端对报文段执行算法校验数据是否损坏位紧急指针正的偏移量它和序号字段的值相加表示最后一个紧急数据的下一个字节序号选项为可变长的可选信息典型选项结构说明选项的类型选项的总长度选项的具体信息常见的种选项的常见类型解释选项表结束空操作一般用于将选项的总长度填充为字节的整数倍最大报文段长度选项初次连接双方通过此选项协商最大报文长度通常设置此为字节避免被分片窗口扩大因子选项头部通知窗口为扩大因子为则实际接收通知窗口为的次方且只能出现在同步报文段中否则被忽略选择性确定如果某个报文段丢失则模块会重传最后被确认的报文段后续所有报文段而该选项则可解决这种问题实际工作选项告诉发送端本端已经收到的数据块从而让发送端只发送丢失的数据时间戳提供通信双方较为精确的回路时间连接机制协议未完待续地址转换下面函数名的理解表示点分十进制的字符串形式到表示网络函数将字符串形式的点分十进制转换为大端模式的网络整形字节数参数说明或分别对应和字符串形式的点分十进制的地址存放转换后的变量的地址函数网络转换为字符串形式的点分十进制的参数说明网络的整形的地址转换后的地址一般为字符串数组的长度返回值成功返回指向的指针失败返回并设置另外有两个函数与上面二者类似仅有如下不同和只支持类型的地址转换而和支持和类型的地址转换网络字节序大端低位地址存放高位数据高位地址存放低位数据网络字节序小端低位地址存放低位数据高位地址存放高位数据数据的高低位右边为低位左边为高位为低位数据为高位数据网络传输用的是大端法如果机器用的是小端法则需要进行大小端的转换大小端转换函数名的表示主机表示网络表示表示上述的几个函数如果本来不需要转换函数内部就不会做转换同步与异步同步发送一个请求等待返回然后再发送下一个请求异步发送一个请求不等待返回随时可以再发送下一个请求同步可以避免出现死锁读脏数据的发生一般共享某一资源的时候用如果每个人都有修改权限同时修改一个文件有可能使一个人读取另一个人已经删除的内容就会出错同步就会按顺序来修改异步则是可以提高效率了现在都是双核四核异步处理的话可以同时做多项工作当然必须保证是可以并发处理的实际项目开发中会优先选择异步交互模型四种情况同步非阻塞若客户端发送数据之后函数不阻塞文件描述符设置为非阻塞但是一直循环空转同步阻塞客户端发送数据之后数据若对方不发送应答数据就一直阻塞异步阻塞比如若没有事件发生或者可以一直阻塞异步非阻塞比如将设置非阻塞不管有没有事件发生都会立刻返回异步需要有第三方参与通知才能实现阻塞与非阻塞阻塞和非阻塞的概念描述的是用户线程调用内核操作的方式阻塞是指操作需要彻底完成后才返回到用户空间非阻塞是指操作被调用后立即返回给用户一个状态值无需等到操作彻底完成解析过程在浏览器中输入域名操作系统会先检查自己本地的文件是否有这个网址映射关系如果有就先调用这个地址映射完成域名解析如果里没有这个域名的映射则查找本地解析器缓存是否有这个网址映射关系如果有直接返回完成域名解析和系统都会在本地缓存解析的记录提高速度如果与本地解析器缓存都没有相应的网址映射关系首先会找参数中设置的首选服务器在此我们叫它本地服务器此服务器收到查询时如果要查询的域名包含在本地配置区域资源中则返回解析结果给客户机完成域名解析此解析具有权威性如果要查询的域名不由本地服务器区域解析但该服务器已缓存了此网址映射关系则调用这个地址映射完成域名解析此解析不具有权威性如果本地服务器本地区域文件与缓存解析都失效则根据本地服务器的设置没有设置转发器进行查询如果未用转发模式本地就把请求发至台根根服务器收到请求后会判断这个域名是谁来授权管理并会返回一个负责该顶级域名服务器的一个本地服务器收到信息后将会联系负责域的这台服务器这台负责域的服务器收到请求后如果自己无法解析它就会找一个管理域的下一级服务器地址给本地服务器当本地服务器收到这个地址后就会找域服务器重复上面的动作进行查询直至找到主机如果用的是转发模式设置转发器此服务器就会把请求转发至上一级服务器由上一级服务器进行解析上一级服务器如果不能解析或找根或把转请求转至上上级以此循环不管是本地服务器用是是转发还是根提示最后都是把结果返回给本地服务器由此服务器再返回给客户机域名解析服务器首选备选首选备选阿里首选备选文件存储的是域名和的对应关系目录目录和统一资源定位符表示资源位置的字符串协议地址路径和文件名统一资源名称下载中使用的磁力链接统一资源标识符是一个紧凑的字符串用来标示抽象或物理资源是的一种让能成为的当然就是那个访问机制网络位置可以没有协议没有地址域名和的关系从字面的包含关系上来说包含字符串长度来说包含红色部分绿色部分绿色部分的静态请求的动态请求协议域名服务器端要处理的指令包括这里往下的部分都存在于协议中的请求行的第二部分请求资源中连接符后面的内容是客户端给服务端提交的数据分隔符正向反向代理正向代理是为客户端服务的反向代理是为服务端服务的正向代理正向代理是位于客户端和原始服务器之间的服务器为了能够从原始服务器获取请求的内容客户端需要将请求发送给代理服务器然后再由代理服务器将请求转发给原始服务器原始服务器接受到代理服务器的请求并处理然后将处理好的数据转发给代理服务器之后再由代理服务器转发发给客户端完成整个请求过程正向代理的典型用途就是为在防火墙内的局域网客户端提供访问的途径比如学校的局域网单位局域网访问外部资源反向代理反向代理方式是指代理原始服务器来接受来自的链接请求然后将请求转发给内部网络上的原始服务器并将从原始服务器上得到的结果转发给上请求数据的客户端那么顾名思义反向代理就是位于和原始服务器之间的服务器对于客户端来说就表现为一台服务器客户端所发送的请求都是直接发送给反向代理服务器然后由反向代理服务器统一调配防盗链盗链是指服务提供商自己不提供服务的内容通过技术手段绕过其它有利益的最终用户界面如广告直接在自己的网站上向最终用户提供其它服务提供商的服务内容骗取最终用户的浏览和点击率受益者不提供资源或提供很少的资源而真正的服务提供商却得不到任何的收益编程传统的进程间通信借助内核提供的机制进行但是只能限于本机通信若要跨机通信就必须使用网络通信本质上借助内核内核提供了伪文件的机制实现通信实际上是使用文件描述符这就需要用到内核提供给用户的函数库因为的伪文件机制所以可以使用文件描述符相关的函数如下图一个文件描述符操作两个缓冲区这点跟管道是不同的管道是两个文件描述符操作一个内核缓冲区相关结构体编程用到的重要的结构体结果参数使用结构体变量来填充就可以了内部划分得更细致结构说明结构网络字节序大端模式通过可以查看相关说明在头文件或中定义有时候没有包括而包括在端和端一般要将端口号从主机序转换成网络序那么需要函数就需要头文件就自然不用另一个了可以通过编译啦查询函数所需的头文件用命令但是有些系统是需要而不能是主要函数函数函数函数函数函数读写相关函数函数创建参数说明协议版本本地套接字使用协议类型流式默认使用的协议是协议报式默认使用的是协议一般填表示使用对应类型的默认协议返回值成功返回一个大于的文件描述符失败返回并设置当调用函数以后返回一个文件描述符内核会提供与该文件描述符相对应的读和写缓冲区同时还有两个队列分别是请求连接队列和已连接队列函数将文件描述符和绑定参数说明调用函数返回的文件描述符本地服务器的地址和表示使用本机任意有效的可用服务器可以插狠多张网卡变量的占用的内存大小返回值成功返回失败返回并设置函数将套接字由主动态变为被动态参数说明调用函数返回的文件描述符同时请求连接的最大个数还未建立连接最大是返回值成功返回失败返回并设置函数获得一个连接若当前没有连接则会阻塞等待函数参数调用函数返回的文件描述符传出参数保存客户端的地址信息传入传出参数变量所占内存空间大小返回值成功返回一个新的文件描述符用于和客户端通信失败返回并设置值函数是一个阻塞函数若没有新的连接请求则一直阻塞从已连接队列中获取一个新的连接并获得一个新的文件描述符该文件描述符用于和客户端通信内核会负责将请求队列中的连接拿到已连接队列中函数连接服务器函数参数和函数参数类型一样调用函数返回的文件描述符服务端的地址信息变量的内存大小返回值成功返回失败返回并设置值拒绝连接通常出现在尝试连接受保护的端口如以下的端口时地址已经被使用通常出现在本地地址或远程地址已经被其他进程占用时地址不可用通常出现在尝试连接不存在的本地地址或远程地址时或非阻塞正在尝试连接但连接还没有完成这是一个临时性错误应该重试操作已经处于连接状态无效的文件描述符连接被拒绝通常出现在远程主机处于关闭状态没有进程在监听指定端口防火墙屏蔽了连接请求等情况下指向结构体的指针无效非阻塞正在尝试连接但连接还没有完成这是一个临时性错误应该使用函数等待变为可写状态后再进行下一步操作操作被信号中断应该重试操作已经处于连接状态网络不可达通常出现在远程主机处于离线状态路由不可达等情况下文件描述符不是一个连接超时通常出现在远程主机未响应连接请求网络传输故障等情况下如果远程主机没有响应或者网络故障等情况下阻塞函数会导致程序长时间处于阻塞状态可能会导致程序无响应或者崩溃此外如果在网络连接过程中出现了异常或错误阻塞函数可能会直接返回错误程序需要通过错误处理机制进行处理相比之下非阻塞和的方式可以通过监控连接状态及时处理连接异常收到连接成功后再进行后续的操作从而避免了阻塞和崩溃等问题的出现超时限制也可以避免长时间等待因此使用非阻塞和的方式可以提高程序的健壮性和稳定性读写相关函数读取数据和发送数据对应和这两个函数直接填就可以了阻塞状态下返回表示客户端断开连接读取完毕也可以填写标志可以用来读取套接字接收队列中可读的数据一些情况会用到它比如为了避免不阻塞而先检查套接字接收队列中可读的数据长度再采取相应操作注意如果写缓冲区已满也会阻塞读操作的时候若读缓冲区没有数据会引起阻塞在进行编程中函数用于向连接的另一端发送数据当调用函数后数据并不会立即发送出去而需要等待网络连接稳定缓冲区可用等条件满足后才会实际发送数据这时候如果出现网络故障或者对方出现延迟就可能导致发送数据失败并且可能陷入阻塞状态导致程序无法继续执行因此为了避免函数陷入阻塞状态我们通常使用函数设置发送数据超时时间如果在规定时间内没有发送成功则认为发送失败并中止发送这其实也是一种优化策略如果继续等待缓冲区可用或者网络连接稳定可能会导致程序长时间无响应用户体验也会变得很差另外通过使用函数进行超时检测可以减少的使用率避免空等待占用过多的系统资源提高程序的并发性能和稳定性总之使用对函数进行超时检测是一种优化策略可以避免函数陷入阻塞状态提高程序的响应速度和稳定性函数同理同样需要超时检测优化确保和发送数据完全发送固定字节数数据完全发送缓冲区要读取的字节数成功返回失败返回类中变量读取固定字节数完全文件描述符接收缓冲区要读取的字节数成功返回失败返回读到返回类中变量测试工具命令以客户端的方式连接小工具系统安装方式地址端口号例如作为服务端监听端口号端口号如对外开放端口命令其他功能参考命令测试过程中可以使用命令查看监听状态和连接状态命令表示显示所有表示显示的时候以数字的方式来显示表示显示进程信息进程名和进程一般用端口号来查看该端口对应的连接情况命令查看网络连接情况仅服务器表示链接建立了下命令为简化版用命令取而代之案例服务器开发流程创建返回一个文件描述符该文件描述符用于监听客户端连接将和进行绑定将由主动变为被动监听接受一个新的连接得到一个文件描述符该文件描述符是用于和客户端进行通信的读写关闭文件描述符客户端开发流程创建返回一个文件描述符该文件描述符是用于和服务端通信连接服务器读写关闭文件描述符由于客户端不需要固定的端口号因此不必调用客户端的端口号由内核自动分配注意客户端不是不允许调用只是没有必要调用固定一个端口号服务器也不是必须调用但如果服务器不调用内核会自动给服务器分配监听端口每次启动服务器时端口号都不一样客户端要连接服务器就会遇到麻烦代码服务器表示使用本地任意可用等待客户端链接不关心连接的对方客户端信息客户端已链接开始读写你好世界读数据关闭监听文件描述符和通信文件描述符客户端代码代码上和有一定差异但差异基本不大服务器加载套接字库创建套接字绑定套接字到一个地址和一个端口上将套接字设置为监听模式等待连接请求请求到来后接受连接请求返回一个新的对应于此次连接的套接字用返回的套接字和客户端进行通信返回等待另一个连接请求关闭套接字关闭加载的套接字库初始化创建套接字绑定和端口开始监听循环接收数据等待连接接受到一个连接接收数据发送数据你好客户端客户端加载套接字库创建套接字向服务器发出连接请求和服务器进行通信关闭套接字关闭加载的套接字库连接失败转你好服务端我是客户端用来将数据由指定的传给对方主机为已建立好连接的指向数据内容则为数据长度参数一般设成功则返回实际传送出去的字符数失败返回错误原因存于网络开发的注意点及完整案例当读文件描述符为非阻塞状态的时候若对方没有发送数据会立刻返回设置为这个错误我们要忽略防止阻塞被信号打断像这样的能够引起阻塞的函数若被信号打断由于信号的优先级较高会优先处理信号信号处理完成后会使或者解除阻塞然后返回此时返回值为设置表示连接被打断异常阻塞函数在阻塞期间若收到信号会被信号中断设置为这个错误不应该被视为错误管道写满了也会阻塞参三应该读取的字节数剩余未读取的字节数实际读到的字节数一个个字符读效率不行结束标识为如果这样使用任意将可以连接转换失败头文件粘包接收缓冲区中对方发送数据连续发了两次然后读数据的时候第一次没有读完剩余的数据在第二次读走了这种情况就属于粘包粘包多次数据发送收尾相连接收端接收的时候不能正确区分第一次发送多少第二次发送多少本质上是同一个端口两种业务的数据的区分问题解决方法方案包头数据最推荐如位的数据长度数据其中表示数据长度表示个字节长度的数据另外发送端和接收端可以协商更为复杂的报文结构这个报文结构就相当于双方约定的一个协议方案添加结尾标记如结尾最后一个字符为等方案数据包定长如发送方和接收方约定每次只发送个字节的内容接收方接收定长个字节就可以了学习目标熟练掌握状态转换图熟练掌握端口复用的方法了解半关闭的概念和实现方式了解多路转接模型熟练掌握函数的使用熟练使用相关函数的使用能够编写多路转接模型的代码多并发服务器如何支持多个客户端支持多并发的服务器由于和函数都会阻塞如当的时候不能调用接受新的连接当阻塞等待的时候不能读数据两种思路设置非阻塞可以将和函数设置为非阻塞调用函数可以将文件描述符设置为非阻塞让后再循环中忙轮询多进程让父进程接受新连接然后子进程让子进程处理通信子进程处理完成后退出父进程使用信号回收子进程多线程让主线程接受新连接让子线程处理与客户端通信使用多线程要将线程设置为分离属性让线程在退出之后自己回收资源在一次发送大量数据超过发送缓冲区大小的情况下如果使用阻塞方式程序一直阻塞直到所有的数据都写入到缓冲区中例如要发送字节数据套接字发送缓冲区大小为字节只有当对端向本机返回表明其接收到大于等于字节时才意味着所有的数据都写入到缓冲区中很明显如果一次发送的数据量非常大比如则一次发送过程中本机线程会在一个上阻塞相当长一段时间其他得不到及时处理如果出现发送失败无从得知到底有多少数据发送成功应用程序只能选择重新发送这数据结合考虑网络的稳定性只能呵呵总之上述两点都是无法接受的因此对性能有要求的服务器一般不采用阻塞而采用非阻塞设置非阻塞实现设置文件描述符为非阻塞函数服务器端设置描述符属性为非阻塞表示使用本地任意可用等待客户端链接不关心连接的对方客户端信息获取链接失败客户端已链接查询是否为已连接客户端若未连接则记录文件描述符准备添加的此处限制只能连接两个开始读写你好世界读数据关闭监听文件描述符和通信文件描述符此代码实现了接受多个客服端连接并接受客户端发过来的数据的功能但建立连接的过程必须和读取数据的问题完全分离即先建立指定连接数目的连接然后再开始通信过程此后无法继续建立新连接建立连接和通信是割裂的开始通信后没有一个好的时机供建立新的连接如果是客户端通信内容决定建立连接的时机的话就可以用这种方式而且也没有好的时机做清理工作这种实现方法不是一个好的实现方法但是其实还有方法可以解决上述问题多进程实现不设置非阻塞状态的话都要考虑防止阻塞被信号打断注册子进程回收创建得到一个监听的文件描述符将和和端口进行绑定设置监听进入循环接受新客户端到来子进程收发数据子进程关闭监听文件描述符后收发数据最后要设置关闭描述符退出子进程父进程关闭通信文件描述符下面代码结合了防止阻塞被信号打断的代码防止堵塞被打断的代码对子进程进行回收主进程回收子进程只要不是子进程正在运行和无子进程状态即继续循环防止因为执行期间信号屏蔽产生僵尸进程全部子进程回收完毕全部子进程回收完毕解析结构提取端口字符串服务器端注册子进程回收主进程回收子进程回调注册成功表示使用本地任意可用等待客户端链接不关心连接的对方客户端信息创建子进程收发数据父进程子进程创建子进程与建立连接子进程读数据如下断开连接退出子进程防止其新建子进程多线程实现不设置非阻塞状态的话都要考虑防止阻塞被信号打断注册子进程回收创建得到一个监听的文件描述符将和和端口进行绑定设置监听进入循环接受新客户端到来创建子线程收发数据收发数据关闭传入的描述符设置线程为分离属性退出时自动释放注意主线程和子线程共享文件描述符解析结构提取端口字符串取得通信用的描述符线程退出连接该函数也可以读到的数据为长度等待接受连接设置线程为分离属性接收到连接创建线程处理半关闭状态如果一方另一方没有则认为是半关闭状态处于半关闭状态的时候可以接受数据但是不能发送数据相当于把文件描述符的写缓存区操作关闭了注意半关闭一定是出现在主动关闭的一方函数第一个参数为返回的文件描述符第二个参数可以设置为分别表示关闭接受缓存区关闭发送缓冲区都关闭返回值成功返回失败返回并设置和的区别能够把文件描述符上的读或者写操作关闭而关闭文件描述符只是将连接的引用计数的值减当减到就真正关闭文件描述符了如调用函数或者函数可以复制一个文件描述符其中一个并不影响另一个文件描述符而就不同了一旦了其中一个文件描述符对所有的文件描述符都有影响只是关闭了用户层用户层没法再发了内核层还是可以发的四次挥手最后一个就是这样理解端口复用解决端口复用的问题发生这种情况是在服务端主动关闭连接以后接着立刻启动就会报这种错误测试启动服务端和客户端然后先关闭服务端再次启动服务端此时服务端报错若是先关闭的客户端再关闭的服务端此时启动服务端就不会报这个错误函数返回值成功返回失败返回并设置调用案例返回的套接字通用的套接字选项如果为重用中的地址这个重用端口的也可以但用得比较少根据的不同指向一个数据结构或一个整数比如说一些选项是的非对应选项启用禁用开关指向的对象的大小比如说设置端口复用如下函数说明可参看环境高级编程由于错误是函数报出来的该函数调用要放在之前之后调用函数函数用于获取任意类型任意状态套接口的选项当前值并把结果存入成功它将返回表示获取选项值成功失败它将返回并设置变量来指示错误原因在使用非阻塞时我们通常会使用函数和选项来检查的状态以便在出错时及时处理错误例如当使用或等多路复用函数时我们可以先调用函数来获取的错误状态然后根据错误状态来判断是否可以进行读写操作获取错误状态例子如下心跳包用于检测长连接是否正常的手段长连接和短连接的概念连接建立之后一直不关闭为长连接连接收发数据完毕之后就关闭为短连接长连接通常用于通信双方数据交换频繁的情况下如何检查与对方的网络连接是否正常一般心跳包用于长连接上面为官方提供的方式由于不能实时的检测网络情况一般不用这种方法在应用程序中自己定义心跳包使用灵活能实时把控通信双方需要协商规则协议高并发服务器模型一种多路复用技术同时监听多个文件描述符将监控的操作交给内核去处理优点跨平台使用都支持缺点受最大描述符数量的限制函数函数介绍委托内核监控该文件描述符对应的读写或者错误事件或者连接请求的发生内核收到了告诉程序避免了阻塞只要是文件描述符函数都可以派上用场参数说明最大的文件描述符读文件描述符集合是一个传入传出参数传入指的是告诉内核哪些文件描述符需要监控传出指的是内核告诉应用程序哪些文件描述符发生了变化写文件描述符集合传入传出参数同上异常文件描述符集合传入传出参数同上表示永久阻塞直到有事件发生表示阻塞的时长遇到事件发生或者超时就返回返回值成功返回发生变化的文件描述符的个数表示至少有一个套接字已经准备好了可读可写或异常事件超时限时内没有任何发生变化的文件描述符个数返回失败返回并设置值如果函数返回并且函数返回则表示该套接字已经准备好了可读可写或异常事件此时需要进一步调用函数并检查选项是否为来判断该套接字是否处于异常状态如果的值为则表示该套接字没有发生错误否则的值将是相应的错误码表示该套接字已经发生了错误操作文件描述符集的宏如下将从集合中清除功能描述判断是否在集合中返回值如果在集合中返回否则返回将设置到集合中初始化集合清空在中的定义位置和最简单的方法就是使用预处理将头文件和宏全部替换掉直接就可以看到最终的定义了对应个文件描述符从上面的文件中可以看出这几个宏本质上还是位操作与信号集操作类似开发服务端代码设置端口复用设置给委托内核监控的描述符的范围服务器开启等待连接阻塞监控变化不需要考虑返回的情况因为返回和才会解除堵塞如果最后一个参数填写了超时时间设置的话需要考虑的情况信号被中断出问题返回并未做什么完善的处理有客户端连接请求到来如果有响应客户端连接存在返回接受到新的连接文件描述符为将加入到委托内核监控中调整监控文件描述符范围将新加入的接受到的描述符添加入委托内核监控的范围如果只有一个描述符变化了而且是在有客户端连接请求到来的上下文执行中则此处说明只有这一个连接请求导致的描述符变化因此这样情况下后面代码可以略过如果只剩最后一个就无需在执行后面了有客户端发数据过来表示接受的数据通信存在返回值为有才读所以不需要考虑堵塞吗断开连接返回读到的数据为关于的思考问题如果有效的文件描述符比较少会使循环的次数太多大多数都是初始连接一次就解决办法可以将有效的排除了被取消掉的文件描述符文件描述符放到一个数组当中这样遍历效率就高了连接不频繁而通信频繁也可以针对通信开数组优点一个进程可以支持多个客户端支持跨平台缺点代码编写困难会涉及到用户区到内核区的来回拷贝当客户端多个连接但少数活跃的情况效率较低例如作为极端的一种情况文件描述符全部打开但是只有有发送数据就显得效率低下最大支持个客户端连接最大支持个客户端连接不是有文件描述符表最多可以支持个文件描述符限制的而是由限制的这个文件描述符表中一共有个位使用了该宏当然可以修改内核然后再重新编译内核一般不建议这么做下的模型相关知识外链跳转练习编写代码让监控标准输入监控网络如果标准输入有数据就写入网络如果网络有数据就读出网络数据然后打印到标准输出设置端口复用服务器开启等待连接接受到新的连接文件描述符为如果网络连接描述符有变化如果标准输入有变化与与可以突破最大描述符数量个的限制函数多路模型了解触发模式并实现理解边缘非阻塞模式并实现了解反应堆模型设计思想能看懂反应堆模型的实现代码下常用下常用效率来看多路跟类似监控内核监控事件实现多路但不能跨平台参数说明传入传出参数实际上是一个结构体数组监控的文件描述符要监控的事件不会被修改返回发生变化的事件由内核返回要监控的文件描述符多个之间用或相连读事件写事件异常事件管道断开连接其他更多宏参考返回的事件数组实际有效内容的个数就是数组下标的最大值超时时间单位是毫秒永久阻塞直到监控的事件发生不管是否有事件发生立刻返回直到监控的事件发生或者超时返回值成功返回就绪事件的个数失败返回若函数不阻塞且没有事件发生此时返回并且这种情况不应视为错误说明当函数返回的时候结构体当中的和没有发生变化究竟有没有事件发生由来判断所以是请求和返回分离结构体中的成员若赋值为则不会监控相对于没有本质上的改变但是可以突破的限制如何突破的限制开发流程一般是没有权限改的在查看一个进程可以打开的描述符上限如果需要可以修改配置文件加入如下配置信息然后重启终端即可生效修改的话直接修改处的数字表示可以修改的最大限制代码设置端口复用服务器开启等待连接初始化有客户端连接请求到来接受连接成功将新文件描述符加入监控寻找数组中空出来的位置修改数组下标最大值下面是收到客户端发送数据的情况检测到连接断开的方式之一断开了解这里必须是如果是无法检测到其中的连接断开的情况检测到连接断开的方式之二断开连接读到的数据优化如果只有一个就无需再遍历了多路将检测文件描述符的变化委托给内核去处理然后内核将发生变化的文件描述符对应的事件返回给应用程序底层实现是红黑二叉树优点的并发量大于和缺点只支持系统相关函数函数创建一棵数返回一个树根节点参数最大节点数此参数在已被忽略但必须传递一个大于的数返回值成功返回一个大于的文件描述符代表整个树的树根失败返回并设置值函数将要监听的节点在树上添加删除和修改参数说明树根添加事件节点到树上从树上删除事件节点修改树上对应的事件节点事件节点对应的文件描述符要操作的事件节点结构体如果是要下树的话这里只需要填委托内核监控的文件描述符常用如下多选项通过按位或结合监听可读事件监听可写事件监听异常事件边缘触发就是上面那个结构体客户端关闭既会触发服务器的事件也会触发事件的理解传输大量数据的时候没有办法一次将数据全部发送出去就需要将剩下的数据缓存起来等内核通知缓冲区可写的时候再继续发送事件表示的发送缓冲区可写在一次发送大量数据超过发送缓冲区大小的情况下很有用你需要将一个大小的文件返回给用户那么你简单这个文件是不会成功的这个场景下你的数据返回值不会是而是大约表示你只成功写入了的数据接着调用就会返回告诉你的缓冲区已经满了此时无法继续此时异步程序的正确处理流程是调用当缓冲区中的数据被对方接收之后缓冲区就会有空闲空间可以继续接收数据此时就会返回这个的事件获得这个事件时你就可以继续往中写出数据函数等待内核返回事件发生参数说明树根传出参数其实是一个事件结构体数组数组结构体数组的项最大数量表示永久阻塞立即返回表示超时等待事件返回值成功返回发生事件的个数失败若没有事件发生则返回返回设置值注意的是一个传出参数调用传递给内核什么值当返回的时候内核就传回什么值不会对的结构体变量的值做任何修改实现案例将监听文件描述符上树监听文件描述符上树信号中断有客户端链接请求到来有客户端发送数据过来下监控树可能存在的问题若每一个连接上处理的时间比较长会导致后面的连接上发来的数据得不到及时的处理解决方法可以让主线程处理让子线程收发数据工作模式有两种工作模式和模式水平触发高电平代表默认是模式只要缓冲区内核的读缓冲区中有数据就一直通知边缘触发电平有变化就代表缓冲区中有数据只会通知一次之后再有数据才会通知若是读数据的时候没有读完则剩余的数据不会再通知直到有新的数据到来结构体中的按位或来设置边缘触发边缘非阻塞模式优势提高效率模式案例模式由于只通知一次所以在读的时候要循环读直到读完但是当读完之后就会阻塞所以应该将该文件描述符设置为非阻塞模式函数函数在非阻塞模式下读的时候若返回且为则表示当前资源不可用也就是说缓冲区无数据缓冲区的数据已经读完了或者当返回的读到的数据长度小于请求的数据长度时就可以确定此时缓冲区中已没有数据可读了也就可以认为此时读事件已处理完成的边缘触发模式的非阻塞模式案例将监听文件描述符上树监听文件描述符上树信号中断有客户端链接请求到来新连接的客户端通信描述符上监控树设置为模式将设置为非阻塞有客户端发送数据过来测试按照两个两个读用于测试模式读完数据了跳出读循环对方关闭连接或读异常断开下监控树成功读到数据反应堆反应堆的核心思想是在调用函数的时候将上树的时候利用的成员将一个文件描述符事件和回调函数封装成一个结构体然后让指向这个结构体然后调用函数返回的时候可以得到具体的然后获得结构体中的指针指针指向的结构体中有回调函数最终可以调用这个回调函数其实就是自己定义结构记录回调等信息放入指向中原本用于存放的联合体在中根据通知取信息来自己调用回调以此实现了一个架构体系核心代码如下基于非阻塞事件驱动监听上限数描述就绪文件描述符相关信息要监听的文件描述符对应的监听事件泛型参数回调函数是否在监听在红黑树上监听不在不监听记录每次加入红黑树的时间值全局变量保存返回的文件描述符全局变量保存监听的文件描述符自定义结构体类型数组将结构体成员变量初始化调用函数的时间时间戳向监听的红黑树添加一个文件描述符或已经在红黑树里修改其属性不在红黑树里将其加入红黑树并将置实际添加修改从监听的红黑树中删除一个文件描述符不在红黑树上修改状态从红黑树上将摘除当有文件描述符就绪返回调用该函数与客户端建立链接回调函数监听的文件描述符发送读事件时被调用使用的目的是为了避免使用语句从全局数组中找一个空闲元素类似于中找值为的元素找到第一个能用的跳出避免跳出不执行后续代码将设置为非阻塞避免给设置一个结构体回调函数设置为将添加到红黑树中监听读事件回调函数通信的文件描述符发生读事件时候被调用读取客户端发来的数据读文件描述符数据存入成员中将该节点从红黑树上摘除手动添加字符串结束标记设置该对应的回调函数为将加入红黑树中监听其写事件地址相减得到偏移元素位置回调函数通信的文件描述符发生写事件时候被调用将小写转换为大写发送给客户端发送数据给客户端从红黑树中移除将该的回调函数改为从新添加到红黑树上设为监听读事件关闭链接从红黑树中移除创建初始化创建对事件结构体赋值仅仅是对进行设置将监听文件描述符上树绑定创建红黑树返回给全局初始化并将监听文件描述符上树保存已经满足就绪事件的文件描述符数组超时验证每次测试个链接不测试当客户端秒内没有和服务器通信则关闭此客户端链接当前时间一次循环检测个使用控制检测对象不在红黑树上客户端不活跃的世间关闭与该客户端链接将该客户端从红黑树移除监听红黑树将满足的事件的文件描述符加至数组中秒没有事件满足返回使用自定义结构体类型指针接收联合体的成员读就绪事件调用回调函数写就绪事件调用回调函数关闭文件描述符线程池一个抽象的概念若干个线程组合到一起形成线程池为什么需要线程池多线程版服务器一个客户端就需要创建一个线程若客户端太多显然不太合适什么时候需要创建线程池呢简单的说如果一个应用需要频繁的创建和销毁线程而任务执行的时间又非常短这样线程创建和销毁的带来的开销就不容忽视这时也是线程池该出场的机会了如果线程创建和销毁时间相比任务执行时间可以忽略不计则没有必要使用线程池了此时可以考虑协程实现的时候类似于生产者和消费者参三应该读取的字节数剩余未读取的字节数实际读到的字节数如果这样使用任意将可以连接转换失败实现原理线程池和任务池任务池相当于共享资源所以需要使用互斥锁当任务池中没有任务的时候需要让线程阻塞所以需要使用条件变量如何让线程执行不同的任务使用回调函数在任务中设置任务执行函数这样可以起到不同的任务执行不同的函数线程相关函数创建子线程线程退出设置子线程为分离属性涉及到任务池共享资源的互斥访问因此需要互斥锁相关的函数初始化互斥锁互斥锁加解锁销毁互斥锁若任务池已满主线程应该阻塞等待子线程处理任务若任务池空了子线程应该阻塞等待主线程往任务池中添加任务因此需要涉及条件变量相关函数堵塞唤醒至少一个阻塞在该条件变量上的线程初始化条件变量销毁条件变量唤醒所有条件变量案例基础以及系统编程线程相关函数是支持的线程操作简单版本代码任务编号任务池中的任务项结构任务编号回调函数参数回调函数线程池最大任务数实际任务数任务队列数组入任务队列位置出任务队列位置线程数线程池内线程数组是否关闭线程池的标识表示不摧毁线程池表示摧毁线程池线程池的锁任务队列有位置的条件变量主线程插入时等待有位置插入任务队列不是空的条件变量子线程执行时的等待他不是空此处还要再判断任务数量的原因是会有多个线程堵塞在上面处直接会有多个线程同时过了上一个任务数量检测因此此处才是真正的确保有任务才执行为什么要拷贝避免任务被修改生产者会添加任务模拟循环队列取值执行完一个任务任务数减一通知主线程可以插入新任务了退出线程释放完锁再自己执行自己的任务回调函数创建线程池摧毁线程池让子线程准备自己结束自己通知所有子线程解除阻塞诱杀由于已经设置了线程分离因此下面代码不需要了添加任务到线程池由主线程调用先加锁任务编号为模拟循环队列插入位置往后移动参数指向任务结构体本身设置回调函数通知子线程解除阻塞去执行当前执行任务编号为主线程结束复杂版本比起简单版本添加了动态线程管理检测一次线程空闲情况如果添加新的线程到线程池每次创建和销毁线程的个数任务池中的任务项结构回调函数参数回调函数线程池描述线程池相关信息用于锁住本结构体记录忙状态线程个数的锁锁的目标为当任务队列满时添加任务的线程阻塞等待此条件变量任务队列里不为空时通知等待任务的线程存放线程池中每个线程的数组存管理线程管理者线程工作根据任务数多少动态调节子线程数量任务队列数组首地址线程池最小线程数线程池最大线程数当前存活线程个数忙状态线程个数要销毁的线程个数队头下标执行任务的下标队尾下标插入任务的下标队中实际任务数队列可容纳任务数上限标志位线程池使用状态或线程执行函数用于先存储要执行的任务被管理者线程标记为要删除的线程自己退出如果有需要退出的线程数如果线程池里线程个数大于最小值时可以结束当前线程退出线程准备执行任务忙碌数执行完任务忙碌数判断线程是否还存活发号信号测试线程是否存活线程不存在表示线程未存活调整线程管理线程的执行函数定时执行只是读操作为什么要加锁获取任务数获取存活线程数获取忙碌线程数创建新线程算法任务数大于设置的最小等待任务个数且存活的线程数少于最大线程数在线程数组中找空位或者已经死亡的线程位置插入个新线程销毁多余线程算法忙碌线程小于存活线程的一半并且存活线程大于最小线程就清理一部分线程为自行添加感觉需要一次销毁个线程隨機個即可要销毁的线程数设置为通知处在空闲状态的线程他们会自行终止释放线程池占下了才释放创建线程池任务最大个数为线程数组开辟空间为任务队列开辟空间初始化互斥锁条件变量启动工作线程创建管理者线程此处的结构仅仅是避免使用无需循环作用使代替的作用前面代码调用失败释放存储空间添加任务诱杀工作线程添加任务添加任务后队列不为空唤醒线程池中等待处理任务的线程通知所有空闲线程但是此时可能有线程还未通知所有的空闲线程确定管理者线程已死要确定所有线程均已经退出才能释放内存空间确保每个线程都死了释放线程池执行任务任务编号为模拟耗时任务执行完成任务编号为截取一点点的效果图效果过长通信用户数据报协议面向无连接的不稳定不可靠不安全的数据报传递更像是收发短信传输不需要建立连接传输效率更高在稳定的局域网内环境相对可靠因为不需要维护连接因此天然支持多客户端相关函数函数接收消息调用该函数相当于通信的函数套接字要接受的缓冲区缓冲区的长度标志位一般填传入传出参数原地址传出参数存储发送数据过来的主机的信息传入传出参数发送方地址长度返回值成功返回读到的字节数失败返回设置函数发送数据套接字目的地址决定了发给谁目的地址长度返回值成功返回写入的字节数失败返回设置服务器编码流程创建套接字数据报绑定和端口收消息发消息关闭套接字客户端编码流程创建套接字数据报收消息发消息关闭套接字测试命令号端口号案例下面是服务端收客户端发简单案例服务端简单代码解析结构提取端口字符串创建等待接受信息数据来源长度内容客户端简单代码本地通信也是一种机制进程间通信机制通过查询可以查到本地域通信相关信息需要头文件和本地套接字服务器的流程可以使用的方式必须按照的流程也可以使用的方式必须按照的流程地址域类型地址域类型本地地址域类型唯一的区别只是函数传参数不同本地通信使用的是结构体如下设置文件路径为函数返回的本地套接字服务器流程创建套接字绑定用的结构体是侦听获得新连接循环通信关闭文件描述符本地套接字客户端流程调用创建套接字调用函数将文件描述和文件进行绑定不是必须的若无显示绑定会进行隐式绑定但服务器不知道谁连接了就无法给客户端发送消息原因是网络编程的时候客户端信息操作系统会自动分配而本地通信并不会调用函数连接服务端循环通信关闭文件描述符需要注意的是函数会自动创建文件大小为若在调用函数之前文件已经存在则调用会报错可以使用函数在之前先删除文件测试本地通信文件名代码案例服务端创建删除可能存在的原文件等待接受连接为长度内容客户端要指向服务端创建的文件服务端创建等待接受连接长度内容客户端此处代码只需要服务端收客户端发如果服务端也需要发送数据给指定客户端那么客户端也要创建自己的文件供服务端标识发给谁长度固定为是因为客户端函数传参为固定而应该传这样才会显示内容长度第三方库第三方库的安装方式参考库的安装方式库事件驱动高性能轻量级专注于网络源代码精炼易读跨平台提供了不同的版本支持等支持多种多路复用技术如等支持和信号等事件的核心实现在上其实质就是反应堆是事件驱动反应堆也是事件驱动当要监测的事件发生的时候就会调用事件对应的回调函数执行相应操作特别提醒事件回调函数是由用户开发的但不是由用户显示去调用的而是由去调用的安装官方网址跳转源码下载主要分个大版本系列较为早期版本适合源码学习系列较新的版本代码量比版本多很多功能也更完善从官网上下载安装文件之后将安装文件上传到系统上源码包的安装以版本为例在官网可以下载到源码包安装步骤与第三方库源码包安装方式基本一致解压解压到目录下查看文件该文件里描述了安装的详细步骤可参照这个文件进行安装进入源码目录执行配置检测安装环境生成执行的时候也可以指定路径这样就可以安装到指定的目录下但是这样在进行源代码编译的时候需要指定用头文件的路径和用库文件的路径若默认安装不指定则会安装到系统默认的路径下编译的时候可以不指定头文件和库文件所在的路径执行命令编译整个项目文件通过执行命令会生成一些库文件动态库和静态库和可执行文件执行进行安装安装需要用户权限这一步需要输入当前用户的密码执行这一步可以将刚刚编译成的库文件和可执行文件以及一些头文件拷贝到目录下头文件拷贝到了目录下库文件拷贝到了目录下库的使用进入到下可以查看一些示例源代码文件使用库编写代码在编译程序的时候需要指定库名安装文件的库文件所在路径编写代码的时候用到头文件或者直接参考目录下的源代码文件也可以编译源代码文件以文件为例需要指定库由于安装的时候已经将头文件和库文件拷贝到了系统头文件所在路径和系统库文件所在路径所以这里编译的时候可以不用指定和相关结构与函数结构使用函数之前需要分配一个或者多个结构体每个结构体持有一个事件集合可以检测以确定哪个事件是激活的结构相当于红黑树的树根节点每个都有一种用于检测某种事件已经就绪的方法回调函数通常情况下可以通过函数获得结构相关函数获得结构释放指针重新初始化获得当前系统或者称为平台支持的方法有哪些获得当前节点使用的多路方法进入循环等待事件万能进入循环等待事件常用退出循环等待回调执行结束后终止循环退出循环等待立即终止循环函数获得结构的可以找到返回值成功返回结构体指针失败返回函数释放指针的函数如果有子进程且子进程也要使用则子进程需要对重新初始化此时需要调用函数的函数参数由返回的执行结构的指针返回值成功返回失败返回函数得当前系统或者称为平台支持的方法有哪些返回值返回二维数组类似与函数的第二个参数对于不同系统而言就是调用不同的多路接口去判断事件是否已经被激活对于系统而言核心调用的就是同时支持和编写代码获得当前系统支持的多路方法和当前所使用的方法下打印如下函数获得当前节点使用的多路方法函数参数结构的指针返回值获得当前节点使用的多路方法的指针函数进入循环等待事件该函数一般不用用代替的参数说明由函数返回的指向结构的指针的取值默认不设置时等同于只触发一次如果事件没有被触发阻塞等待非阻塞方式检测事件是否被触发不管事件触发与否都会立即返回函数进入循环等待事件阻塞的函数参数结构的指针调用该函数相当于没有设置标志位的程序将会一直运行直到没有需要检测的事件了或者被结束循环的终止函数退出循环等待回调执行结束后终止循环也就是等待处理完再终止函数参数结构的指针为结构体指针如下如果正在执行激活事件的回调函数那么将在事件回调执行结束后终止循环如果时间非那么将等待设置的时间后立即结束循环而会立即终止循环函数退出循环等待立即终止循环函数参数结构的指针使用库的流程创建根节点设置监听事件和数据可读可写的事件的回调函数设置了事件对应的回调函数以后当事件产生的时候会自动调用回调函数事件循环相当于在循环内部等待事件的发生若有事件发生则会触发事件对应的回调函数释放根节点释放由和创建的资源分别调用和函数事件驱动事件驱动实际上是的核心思想主要几个状态无效的指针此时仅仅是定义了非未决相当于创建了事件但是事件还没有处于被监听状态类似于我们使用的时候定义了并且对的两个字段进行了赋值但是此时尚未调用对事件上树未决就是对事件开始监听暂时未有事件产生相当于调用对要监听的事件上树但是没有事件产生激活代表监听的事件已经产生这时需要处理相当于调用函数有返回当事件被激活以后会调用该事件对应的回调函数相关函数和结构的事件驱动对应的结构体为对应的函数在图上也比较清晰下面介绍一下主要的函数自定义回调函数格式函数创建结构指针同时指定对应的地基对应的文件描述符要监听的是什么事件以及回调函数和回调函数的参数对应的根节点地基要监听的文件描述符或信号要监听的事件超时事件读事件写事件信号事件周期性触发边缘触发如果底层模型支持设置则有效若不支持则无效若要想设置持续的读事件则回调函数原型如下回调函数的参数就对应于函数的和传入上面回调函数的参数函数将非未决态事件转为未决态相当于调用函数开始监听事件是否产生相当于的上树操作调用创建的事件限时等待事件的产生也可以设置为没有限时函数将事件从未决态变为非未决态相当于的下树调用操作操作参数指的是由创建的事件函数释放由申请的节点参数同上开发流程编写一个基于实现的服务器创建设置端口复用绑定设置监听创建地基创建对应的事件该事件编写回调函数为接受新描述符构造新事件处理读写的回调函数并上树第六步事件上树就是上地基进入事件循环退出循环可以写到回调里面释放资源代码案例编写服务端用于记录要下树的对应客户端断开连接将通信文件描述符对应的事件从地基上删除读到接受新的客户端连接客户端连接成功创建通信文件描述符对应的事件并设置回调函数为退出循环将通信文件描述符对应的事件上地基创建设置端口复用绑定监听创建地基支持的方式使用的方式创建监听文件描述符对应的事件将新的事件节点上地基等待连接中进入事件循环等待释放资源实际上也是一个只不过比普通的高级一些它的内部有两个缓冲区以及一个文件描述符网络套接字一个网络套接字有读和写两个缓冲区同样也带有两个缓冲区还有就是事件驱动的核心回调函数那么四个缓冲区以及触发回调的关系如下从图中可以得知一个对应两个缓冲区三个回调函数分别是写回调读回调和事件回调有三个回调函数读回调当将底层读缓冲区的数据读到自身的读缓冲区时触发读事件回调写回调当将自身写缓冲的数据写到底层写缓冲区的时候触发写事件回调由于数据最终是写入了内核的写缓冲区中应用程序已经无法控制这个事件对于应用程序来说基本没什么用只是通知功能事件回调当绑定的连接断开或者异常的时候触发事件回调主要使用的函数如下相关函数注意的读写函数本身就是非堵塞的函数对已经存在创建事件可用于后面讲到的连接监听器的回调函数中对应根节点文件描述符的选项释放自动关闭底层接口当被释放以后文件描述符也随之被使能够在多线程下是安全的函数该函数客户端使用封装了底层的与接口通过调用此函数可以将事件与通信的进行绑定需要提前初始化的事件对端一般指服务端的地址端口协议的结构指针描述的长度说明调用此函数以后通信的与缓冲区做了绑定后面调用了函数以后会对缓冲区的读写操作的事件设置回调函数当往缓冲区中写数据的时候会触发写回调函数当数据从的内核缓冲区读到读缓冲区中的时候会触发读回调函数函数释放函数用于设置的回调函数分别对应了读回调写回调事件回调代表回调函数的参数两种回调函数的函数原型读写回调指针上下文指针事件回调代表对应的事件遇到文件结束指示发生错误比如说客户端连接一个未开启的发生超时请求的过程中连接已经完成比如说客户端连接服务器成功客户端断开连接时为函数将的数据写到的写缓冲区为写多长函数将的数据写到的写缓冲区的另外一个写法实际上的内部的两个缓冲区结构就是函数将的读缓冲区数据读到中同时将读到的数据从的读缓冲清除为要读的最大长度返回实际读到的字节数函数将读缓冲数据读到中接口的另外一种为要读的最大长度返回实际读到的字节数函数设置事件生效使回调会被触发参数参考函数的参数函数设置事件不生效使回调不会被触发同上函数获取里的写缓冲区指针函数获取里的读缓冲区指针函数获取里的缓冲区数据长度链接监听器链接监听器封装了底层的通信相关函数比如这几个函数链接监听器创建后实际上相当于调用了此时等待新的客户端连接到来如果有新的客户端连接那么内部先进行调用处理然后调用用户指定的回调函数可以先看看函数原型了解一下它是怎么运作的所在头文件链接监听器相关函数函数在当前没有套接字的情况下对链接监听器进行初始化最后个参数实际上就是使用的关键参数是函数的关键参数略有不同的是如果是那么监听器会自动选择一个合适的值如果填那么监听器会认为函数已经被调用过了是回调函数的参数是有新连接之后的回调函数但是注意这个回调函数触发的时候链接器已经处理好新连接了并将与新连接通信的描述符交给回调函数回调函数格式需要参考几个值文件描述符为阻塞的关闭时自动释放监听描述符端口复用分配锁线程安全上面的参数注意区分与的参数开头不同函数在当前有套接字的情况下对链接监听器进行初始化函数与前一个函数不同的地方在与后个参数使用本函数时认为已经初始化好并且完成甚至也可以做完所以大多数时候我们都可以使用第一个函数参数说明参考上面两个函数的回调函数回调函数参数是与客户端通信的描述符并非是等待连接的监听的那个描述符所以对应的也是新连接的对端地址信息已经是处理好的函数释放链接监听器函数使链接监听器生效函数使链接监听器失效和链接器服务器流程主流程创建地基创建设置复用监听描述符上树实现监听调用有客户端链接会调用回调函数客户端连接回调流程进入事件循环等待事件发生跳出循环释放资源客户端连接回调流程创建将通信文件描述符和绑定设置回调函数可以是读回调写回调信号事件回调使回调函数生效不写也行默认生效读回调流程读的读缓冲区数据其他业务流程最终代码案例服务器代码编写服务端解析结构提取端口字符串读到有客户端断开连接通过指针将指针传入进来客户端连接成功占用描述符此处的参数位无法将传过去解析地址应该已经被释放了创建地基创建事件连接监听器如果有客户端连接会调用回调函数进入事件循环等待连接中跳出循环客户端代码编写客户端解析结构提取端口字符串监控输入回调读标准输入传入指针目的是为了写到的写缓冲区发给服务端读回调事件回调事件回调连接成功为服务器断开为连接断开发生错误连接成功试图做清理其实此处应该是将传进来跳出循环才对新建监控标准输入事件往回调中传入的指针目的是为了写缓冲区上树循环等待跳出循环通信效率优化通信效率单位时间内客户端或者服务端接收或者发送数据的量多线程处理效率优于多进程多线程更节省资源多路复用技术既不使用多线程也不使用多进程在一个进程或一个线程中让多个客户端同时请求服务都是委托内核进行监控若有事件发生则通知应用程序客户端优化客户端的效率优化单进程只处理一个连接多线程使用同一个连接多线程使用多个连接使用到连接池缺点如果频繁创建连接和销毁连接会有时间消耗连接池线程池避免上述缺点连接池只用于客户端连接池不用于服务端因为连接是只有客户端发起连接请求之后才会有的连接池思想一个数据结构保存连接信息创建连接池操作获取连接池操作如队头取使用完将连接存放的操作如存到队尾可以根据实际需要动态调整连接的数量销毁连接池在网络编程中函数用于建立与远程主机的连接当函数返回时并且被设置为表示连接操作正在进行中但是仍未完成这种情况通常发生在非阻塞模式下调用函数时在非阻塞模式下函数立即返回不会阻塞程序同时设置为此时需要通过或等函数检查套接字的可写性以确定连接是否已经建立如果连接成功建立套接字将变成可写状态如果连接建立失败则套接字将变成可读状态并且被设置为相应的错误码需要注意的是在阻塞模式下调用函数如果连接建立失败函数将会阻塞程序并返回相应的错误码不会设置为客户端案例用于通信的套接字类超时的时间使用一个可以用于通信的套接字实例化套接字对象连接服务器发送数据接收数据断开连接释放内存用于手动释放传出读到的数据所在的空间设置为非阻塞模式设置为阻塞模式读超时检测函数不含读操作写超时检测函数不包含写操作带连接超时的函数每次从缓冲区中读取个字符每次往缓冲区写入个字符用于通信的套接字表示可以正常写了开辟空间容纳待发送的数据头个字节用来存发送的数据长度头个空间放传送数据的长度失败返回超时返回并且先检测一下是否可读读包头个字节多分配一个字节内容兼容可见字符串字符串的真实长度仍然为根据长度读数据多分配一个字节内容兼容可见字符串字符串的真实长度仍然为释放内存并将指针置空写超时检测函数不含写操作等待超时秒数如果为表示不检测超时成功未超时返回失败返回超时返回并且防止信号导致的中断要连接的对方地址等待超时秒数如果为表示正常模式成功未超时返回失败返回超时返回并且设置非阻塞真正的连接函数函数需要用的控制阻塞时间的结构体建立连接属于要监视写事件防止阻塞状态被信号打断返回为表示套接字可写可能有两种情况一种是连接建立成功一种是套接字产生错误此时错误信息不会保存至变量中因此需要调用来获取正常连接读取固定字节数文件描述符接收缓冲区要读取的字节数成功返回失败返回读到返回确保数据发送完全发送缓冲区要读取的字节数成功返回失败返回返回值三态若时间到超时没有检测到读事件返回若返回说明的过程中被别的信号中断可中断睡眠原理若返回出错若返回值表示有事件发生返回事件发生的个数服务端优化服务端案例需配合客户端案例使用超时的时间服务器设置监听等待并接受客户端连接请求默认连接超时时间为用于监听的文件描述符设置端口复用选项为即打开一但检测出有事件发生表示对方完成了三次握手客户端有新连接建立此时再调用将不会堵塞返回已连接套接字服务器能够解析协议的软件的电脑协议请求协议应答协议响应请求请求行请求方式请求地址协议请求头放一写服务器要使用的附加信息请求体一般放一写请求参数响应状态行协议状态码响应头放一些客户端要使用的附加信息响应体服务器返回的真正客户端要用的内容等请求消息我们要开发的服务器与浏览器通信采用的就是协议在浏览器想访问一个资源的时候在浏览器输入访问地址例如地址输入完成后当敲击回车键的时候浏览器就将请求消息发送给服务器服务器收到的数据如下这个消息看起来很乱很复杂对应的就是我们说的请求消息请求消息分为四部分内容请求行说明请求类型要访问的资源请求指令或请求文件等资源如果是类型问号后还会带数据以及使用的版本请求头说明服务器使用的附加信息都是键值对比如表明浏览器类型空行不能省略而且是包括请求行和请求头中每一行都是以结尾是移动到末尾是换行请求体请求数据表明请求的特定数据内容可以省略如登陆时会将用户名和密码内容作为请求数据请求类型协议有很多种请求类型对我们来说常见的用的最多的是和请求常见的请求类型如下请求指定的页面信息请求数据被包含到中并返回实体主体在协议中数据被包含在请求行的要访问资源中由于请求不存在请求体所以他的请求头中没有和键值对向指定资源提交数据进行处理请求例如提交表单或者上传文件数据被包含在请求体请求数据中请求可能会导致新的资源的建立和或已有资源的修改类似于请求但是响应消息没有内容只是获得报头从客户端向浏览器传送的数据取代指定的文档内容请求服务器删除指定的页面协议中预留给能够将连接改为管道方式的代理服务器允许客户端查看浏览器的性能回显服务器收到的请求主要用于测试和诊断和请求都是请求资源而且都会提交数据如果提交密码信息用请求就会在中明文显示而则不会显示出涉密信息请求头中重要内容请求载体的身份标识用啥发送的请求防盗链这次请求是从哪个页面来的往往用于反爬本地字符串数据信息用户登录信息反爬的是服务器为了保存用户状态而创建的一个拥有唯一特殊对象并将它以的方式发送给浏览器当浏览器再次访问此网站时网站的服务器就会依据的找到对应的对象其中是存在服务器上的是存放在用户端的可以类比成酒店前台电脑里的信息相当于房卡如果有请求体则必须有该项表示返回的数据是什么类型的均以结尾如纯文本网页数据表示请求体请求数据的长度协议规定提交的数据必须放在消息主题中但协议并没有规定数据必须使用什么编码方式开发者可以自己决定消息主题的格式数据发送出去还要服务端解析成功才有意义服务端通常是根据请求头中的字段来获知请求中的消息主体是用何种方式编码再对主体进行解析类型盘点跳转四种常用方式请求行请求头空行请求数据向服务器提交的数据传输大文件大数据块常用的格式发送的数据两张图片具体的文件内容具体的文件内容具体的文件内容具体的文件内容上面的具体的文件内容指代具体要传的文件内容响应消息响应消息是代表服务器收到请求消息后给浏览器做的反馈所以响应消息是服务器发送给浏览器的响应消息也分为四部分状态行包括版本号状态码状态信息消息报头说明客户端要使用的一些附加信息也是键值对是必填的空行同样不能省略响应正文服务器返回给客户端的文本信息常见状态码状态码由三位数字组成第一个数字代表响应的类别有五种分类分类描述信息服务器收到请求需要请求者继续执行操作成功操作被成功接收并处理重定向需要进一步的操作以完成请求客户端错误请求包含语法错误或无法完成请求服务器错误服务器在处理请求的过程中发生了错误注意看到开头表示成功看到开头表示是前端的问题看到开头表示后端接口的问题常见的状态码如下状态码含义说明客户端请求成功重定向客户端请求有语法错误不能被服务器所理解请求未经授权这个状态代码必须和报头域一起使用服务器收到请求但是拒绝提供服务请求资源不存在输入了错误的服务器发生不可预期的错误服务器当前不能处理客户端的请求一段时间后可能恢复正常状态码描述继续客户端应继续其请求切换协议服务器根据客户端的请求切换协议只能切换到更高级的协议例如切换到的新版本协议请求成功一般用于与请求已创建成功请求并创建了新的资源已接受已经接受请求但未处理完成非授权信息请求成功但返回的信息不在原始的服务器而是一个副本无内容服务器成功处理但未返回内容在未更新网页的情况下可确保浏览器继续显示当前文档重置内容服务器处理成功用户终端例如浏览器应重置文档视图可通过此返回码清除浏览器的表单域部分内容服务器成功处理了部分请求多种选择请求的资源可包括多个位置相应可返回一个资源特征与地址的列表用于用户终端例如浏览器选择永久移动请求的资源已被永久的移动到新返回信息会包括新的浏览器会自动定向到新今后任何新的请求都应使用新的代替临时移动与类似但资源只是临时被移动客户端应继续使用原有查看其它地址与类似使用和请求查看未修改所请求的资源未修改服务器返回此状态码时不会返回任何资源客户端通常会缓存访问过的资源通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源使用代理所请求的资源必须通过代理访问已经被废弃的状态码临时重定向与类似使用请求重定向客户端请求的语法错误服务器无法理解请求要求用户的身份认证保留将来使用服务器理解请求客户端的请求但是拒绝执行此请求服务器无法根据客户端的请求找到资源网页通过此代码网站设计人员可设置您所请求的资源无法找到的个性页面客户端请求中的方法被禁止服务器无法根据客户端请求的内容特性完成请求请求要求代理的身份认证与类似但请求者应当使用代理进行授权服务器等待客户端发送的请求时间过长超时服务器完成客户端的请求时可能返回此代码服务器处理请求时发生了冲突客户端请求的资源已经不存在不同于如果资源以前有现在被永久删除了可使用代码网站设计人员可通过代码指定资源的新位置服务器无法处理客户端发送的不带的请求信息客户端请求信息的先决条件错误由于请求的实体过大服务器无法处理因此拒绝请求为防止客户端的连续请求服务器可能会关闭连接如果只是服务器暂时无法处理则会包含一个的响应信息请求的过长通常为网址服务器无法处理服务器无法处理请求附带的媒体格式客户端请求的范围无效服务器无法满足的请求头信息服务器内部错误无法完成请求服务器不支持请求的功能无法完成请求作为网关或者代理工作的服务器尝试执行请求时从远程服务器接收到了一个无效的响应由于超载或系统维护服务器暂时的无法处理客户端的请求延时的长度可包含在服务器的头信息中充当网关或代理的服务器未及时从远端服务器获取请求服务器不支持请求的协议的版本无法完成处理常见文件类型分类与浏览器交互时为使浏览器能够识别文件信息所以需要传递文件类型这也是响应消息必填项常见的类型如下普通文件特别说明编码集西欧的编码说明网站采用的编码是英文说明网站采用的编码是简体中文代表世界通用的语言编码可以用到中文韩文日文等世界上所有语言编码上说明网站采用的编码是韩文说明网站采用的编码是繁体中文响应头中重要内容本地字符串数据信息用户登录信息反爬的各种莫名其妙的字符串一般都是字样防止各种攻击和反爬重定向的浏览器收到的响应中如果包含字段则会重定向到指定的地址浏览器自动进行用户不可见详解设置是响应头中的一个字段用于在客户端通常是浏览器上设置一个是一种在客户端存储数据的机制用于跟踪和识别用户会话字段的格式如下设置的键值对用于存储数据指定的过期时间格式为日期时间字符串一旦过期浏览器将删除该指定的最大存活时间以秒为单位在指定的时间过后浏览器将删除该指定的作用域即可以访问该的域名指定的路径即可以访问该的路径表示该只能通过连接传输表示该只能通过协议传输无法访问通过字段服务器可以向客户端发送以便在后续的请求中识别和跟踪用户使用当向服务器发送请求时可以在请求头中使用字段来发送信息下面是一个示例请求头其中包含了使用的部分在上面的示例中字段包含了两个键值对和这些将会被发送到服务器以便服务器可以识别和跟踪用户的会话以为例使用库发送第一次请求并获取返回的信息然后在第二次请求中通过设置参数为第一次请求获取到的信息即可在下一次请求中带上信息发起第一次请求获取获取返回的信息发起第二次请求时带上信息输出第二次请求的响应内容是库中对象的一个方法用于获取响应中的信息并以字典形式返回具体来说方法会将响应中的所有信息转换为一个字典其中键为的名称值为的值这样可以方便地获取和处理响应中的信息并在需要时将其用于下一次请求中这句代码将对象中的所有信息转换为字典格式并将其赋值给变量字典格式的信息以键值对的形式存储其中键是的名称值是的值这种方式可以方便地对进行访问和操作这句代码直接将对象中的所有信息赋值给变量但是此时并不是字典格式而是一个对象它是库中用于存储信息的数据结构虽然对象提供了一些方法来操作但直接访问和操作可能相对繁琐协议参考加密进化的动画解说是的前身现在绝大部分浏览器都不支持而是支持但名声很大所以很多人把名字混用证书保存在服务器上的数据文件表明域名属于谁日期还包含了特定的公钥和私钥要让他生效需要向申请签发证书的过程先会把持有者的公钥途颁发者有效时间等信息打成个包然后对这些信息进行计算得到个值然后会使自己的私钥将该值加密成也就是对证书做了签名最后将添加在件证书上形成数字证书客户端校验服务端的数字证书的过程先客户端会使用同样的算法获取该证书的值数字摘要通常浏览器和操作系统中集成了的公钥信息浏览器收到证书后可以使的公钥解密内容得到个值数字摘要最后较和如果值相同则为可信赖的证书否则则认为证书不可信握手过程具体握手过程随版本变化这里以为例握手在三次握手之后测试工具一个非常实用的用来与服务器之间传输数据的工具支持的协议包括设计为无用户交互下完成工作提供了一大堆非常有用的功能包括代理访问用户认证上传下载连接支持断点续传格式或发送请求发送请求发送格式请求其中代表头是指定什么类型请求代表传输什么数据这几个是最常用的显示连接的详细信息查看所有命令或者更多信息参考可以使用或选项来忽略证书验证如服务器开发实现目标简单功能首先解析浏览器发来的请求数据得到请求的文件名若文件存在判断文件类型若是普通文件则发送文件内容给浏览器若是目录文件则发送文件列表构成的文件给浏览器若文件不存在则发送一个错误页给浏览器我们要开发服务器已经明确要使用协议传送文件那么我们如何搭建我们的服务器呢注意只是应用层协议我们仍然需要选择一个传输层的协议来完成我们的传输数据工作所以开发协议选择是也就是说服务器搭建浏览依照对数据进行解析和响应工作遵循的原则这样我们的思路很清晰编写一个并发服务器只不过收发消息的格式采用的是协议如下图为了支持并发服务器我们可以有多个选择比如多进程服务器多线程服务器等多路工具都可以甚至如果读者觉得非常熟练的话也可以使用进行开发读取到内容后的流程读取到内容后的流程如下注意点浏览器中的每一次访问都是一个独立的访问遇上一次的访问没有关系即浏览器的任何链接跳转都是关闭连接后建立新连接在浏览器中访问的资源是一个中文的名称的话需要进行编码的转换服务端资源目录取决于服务器程序的工作目录可以通过函数切换工作目录若浏览器关闭读端会导致服务器进程退出原因是当浏览器关闭读端后而服务端还继续往一个关闭读端的链接写数据会收到到信号这个信号的默认处理动作是使进程终止解决方案忽略该信号基于的服务器由于我们知道在大量并发少量活跃的情况下效率很高所以本文以为例介绍开发的主体流程参考模型跳转基于的服务器进制单字符转化为进制单字符不会出现和可以指向同一个内存用于判断是否是进制数字一个的中文字符的字符串占个字节转换成进制的中文字符后占个字节字符串变成进制的数值结合上中的总共是通过文件名字获得文件类型自右向左查找字符如不存在返回西欧的编码说明网站采用的编码是英文说明网站采用的编码是简体中文代表世界通用的语言编码可以用到中文韩文日文等世界上所有语言编码上说明网站采用的编码是韩文说明网站采用的编码是繁体中文以下是依据传递进来的文件名使用后缀判断是何种文件类型将对应的文件类型按照定义的关键字发送回去发送响应头发送出去的内容为下面发送响应正文打开文件循环读文件然后发送读取请求行数据分析出要请求的资源文件名为客户端断开链接为异常客户端已断开连接读到的第一行为处理文件名添加点循环读取完剩余的数据判断文件是否存在若文件不存在文件不存在发送错误信息发送错误页成功判断文件类型普通文件文件存在发送头部信息发送文件内容目录文件这是目录文件自己拼接文件拼接文件列表信息下监控如果是目录由于内部是申请的空间因此记得要释放若文件存在判断文件类型普通文件目录文件忽略信号改变当前进程的工作目录设置端口复用设置给委托内核监控的描述符的范围服务器开启等待连接阻塞监控变化不需要考虑返回的情况因为返回和才会解除堵塞信号被中断出问题返回并未做什么完善的处理有客户端连接请求到来如果有响应客户端连接存在返回接受到新的连接文件描述符为设置为非阻塞将加入到委托内核监控中调整监控文件描述符范围将新加入的接受到的描述符添加入委托内核监控的范围如果只有一个描述符变化了而且是在有客户端连接请求到来的上下文执行中则此处说明只有这一个连接请求导致的描述符变化因此这样情况下后面代码可以略过如果只剩最后一个就无需在执行后面了有客户端发数据过来表示接受的数据通信存在返回值为请求完毕中文汉字编码问题举例浏览器请求的是苦瓜服务器收到之后会显示需要进行转换格式的一个中文汉字占个字节首先需要去掉文件名中的然后逐个将字符串形式的例如转换成数值然后保存到数组当中进制单字符转化为进制单字符不会出现和可以指向同一个内存用于判断是否是进制数字一个的中文字符的字符串占个字节转换成进制的中文字符后占个字节字符串字节变成进制的数值字节结合上中的总共是调用把代表的字符串变成真正的编码其实就是进制存储一些特殊符号相关知识中的空格是编码中的空格基于的服务器参考库讲解编写服务端进制单字符转化为进制单字符不会出现和可以指向同一个内存用于判断是否是进制数字一个的中文字符的字符串占个字节转换成进制的中文字符后占个字节字符串变成进制的数值结合上中的总共是通过文件名字获得文件类型自右向左查找字符如不存在返回西欧的编码说明网站采用的编码是英文说明网站采用的编码是简体中文代表世界通用的语言编码可以用到中文韩文日文等世界上所有语言编码上说明网站采用的编码是韩文说明网站采用的编码是繁体中文以下是依据传递进来的文件名使用后缀判断是何种文件类型将对应的文件类型按照定义的关键字发送回去发送响应头发送出去的内容为下面发送响应正文打开文件循环读文件然后发送读取请求行数据分析出要请求的资源文件名读到的第一行为处理文件名添加点循环读取完剩余的数据判断文件是否存在若文件不存在文件不存在发送错误信息发送错误页成功判断文件类型普通文件文件存在发送头部信息发送文件内容目录文件这是目录文件自己拼接文件拼接文件列表信息如果是目录由于内部是申请的空间因此记得要释放若文件存在判断文件类型普通文件目录文件解析结构提取端口字符串有客户端断开连接通过指针将指针传入进来客户端连接成功占用描述符此处的参数位无法将传过去解析地址应该已经被释放了创建地基创建事件连接监听器如果有客户端连接会调用回调函数进入事件循环等待连接中跳出循环与的大同小异对比其实只是将函数相对应换成并将的参数的文件描述符换成服务器框架服务器组织产品开源的免费服务器服务器公司收费的服务器不交费的话访问量受到限制服务器微软公司主推的服务器小巧且高效的服务器也可以做一个高效的负载均衡反向代理邮件服务器其他的还有下面的都可以实现路由到函数的功能一个轻量级高性能的框架具有类似的路由和模板引擎功能一个高性能非阻塞的框架具有类似的路由和中间件功能一个现代高性能的框架具有类似的路由和依赖注入功能一个跨平台高性能的框架具有类似的路由和异步功能是用的框架基本介绍详解跳转是一个用于建立异步应用程序的库它提供了网络编程串口编程进程间通信等功能在这个示例中我们使用了库提供的异步操作来处理请求和响应从而构建一个简单的包含了许多常用的头文件包含了使用进行通信的头文件通用网关接口描述了客户端和服务器程序之间传输数据的一种标准可以让一个客户端从网页浏览器向执行在网络服务器上的程序请求数据独立于任何语言程序可以用任何脚本语言或者是完全独立编程语言实现只要这个语言可以在这个系统上运行用户通过浏览器访问服务器发送了一个请求服务器接受数据并解析对于一些登录数据不知道如何处理将这些数据转发给了程序服务器端会创建一个进程每一个客户端请求都会创建一个进程进程执行后返回结果返还自身销毁回复客户端因此会频繁创建与销毁效率低由此诞生快速通用网关接口是通用网关接口的改进描述了客户端和服务器程序之间传输数据的一种标准致力于减少服务器与程序之间互动的开销从而使服务器可以同时处理更多的请求与为每个请求创建一个新的进程不同使用持续的进程来处理一连串的请求这些进程由进程管理器管理而不是服务器与的区别是短生存期应用程序是长生存期应用程序像一个常驻型的可以一直执行不需要每次都创建与销毁用户通过浏览器访问服务器发送了一个请求服务器接受数据并解析对于一些登录数据不知道如何处理将这些数据通过套接字转发给了进程管理器程序启动不是由服务器直接启动而是通过进程管理器启动程序执行完毕后通过套接字将处理结果返回给服务器服务器回复客户端安装与配置需要安装两个框架根目录根目录进程管理器不能像那样直接执行外部可执行程序但可以作为代理服务器将请求转发给后端服务器这也是的主要作用之一其中就支持代理接受客户端的请求然后将请求转发给后端进程下面介绍如何使用编写并部署到中进程由进程管理器管理而不是这样就需要一个管理器管理我们编写的程序我们使用作为进程管理器是一个通用的进程管理器简单小巧原先是属于的一部分后来由于使用比较广泛所以就迁移出来作为独立新项目了使用模型功能主要是打开监听端口绑定地址然后创建我们编写的应用程序进程退出完成工作应用程序初始化然后进入死循环侦听的连接请求客户端访问发送请求服务器无法处理用户提交的数据转发数据通信过程中的服务器角色被动接受数据在启动的时候给其绑定和端口程序程序员写的可执行程序使用进程管理器启动程序得到一个进程的数据转发配置转发这个数据进程地址信息端口数据转发到地址信息可以为或域名导入与同级目录下的文件其中定义了一些通信的时候用到的环境变量启动前提条件程序员已经写好可执行程序地址端口可执行程序上面的地址和端口需要与前面转发配置中的地址信息和端口对应此处地址此处地址如果返回表示成功如果显示退出返回错误码即程序有问题环境变量环境变量说明脚本文件请求的路径请求的参数如请求的动作请求头中的字段请求头中的字段脚本名称请求的地址不带参数与相同网站的根目录在配置中指令中指定的值请求使用的协议通常是或版本号版本号可修改隐藏客户端客户端端口服务器地址服务器端口服务器名域名在配置中指定的程序开发参考安装的根目录要包含的头文件可选必须开发需要使用到的库文件二选一库文件如何处理数据在程序开发中标准输入和标准输出被重定向到了连接接收到数据后如何处理根据读请求行的第二部分读根据知道长度从标准输入进来的就是请求体请求数据的内容打印到标准输出的就是要返回给请求方的内容简单案例只有在有数据处理的时候才解除阻塞获取请求体长度获取请求头的数据处理结果结果可能是方式方式提交的数据分布式服务器能处理静态请求动态请求无法处理服务器集群之后每台服务器上部署的内容必须相同帮助服务器处理动态请求反向代理服务器客户端并不能直接访问到服务器直接访问到的是反向代理服务器客户端将请求发送给反向代理服务器反向代理服务器将客户端请求转发给服务器关系型数据库存储文件属性信息用户属性信息非关系型数据库提高程序效率存储的是服务器经常要从关系型数据库中读取的数据分布式文件系统存储文件内容供用户下载分布式文件系统文件系统的全部不在同一台主机上而是在很多台主机上多个分散的文件系统组合在一起形成了一个完整的文件系统分布式文件系统需要有网络多台主机不需要在同一地点需要管理者编写应用层的管理程序不需要编写常用分布式文件系统分布式文件系统支持是用语言编写的一款开源的分布式文件系统开发者余庆淘宝的架构师为互联网量身定制充分考虑了冗余备份负载均衡线性扩容等机制注重高可用高性能等指标冗余备份纵向扩容线性扩容横向扩容可以很容易搭建一套高性能的文件服务器集群提供文件上传下载等服务图床网盘框架中的三个角色进程追踪器管理存储节点的管理者守护进程存储节点守护进程客户端通过连接追踪器找到目标存储节点通过连接存储节点进行上传与下载操作文件上传文件下载三者的关系追踪器最先启动追踪器存储节点第二个启动的角色存储节点启动之后会单独开一个线程向追踪器汇报信息汇报当前存储节点的容量和剩余容量汇报数据的同步情况汇报数据被下载的次数客户端最后启动上传连接追踪器询问存储节点的信息我要上传的文件询问那个存储节点有足够的容量追踪器查询得到结果追踪器将查到的存储节点的端口发送给客户端通过得到和端口连接存储节点将文件内容发送给存储节点下载连接追踪器询问存储节点的信息问一下要下载的文件在哪一个存储节点追踪器查询得到结果追踪器将查到的存储节点的端口发送给客户端通过得到和端口连接存储节点下载文件集群集群的优点避免单点故障主要是针对多个靠被轮询工作实现集群的方式修改配置文件管理存储节点的方式通过分组的方式完成集群方式扩容方式横向扩容增加容量添加一台新的主机容量增加新主机作为一个新的组不同的组间的主机之间不需要互相通信纵向扩容数据备份将新的主机放到现有的组中一个组中的多台主机之间的关系是相互备份的关系因此同一个组间的主机之间需要互相通信每一个组的大小组中最小的主机的大小集群存储容量每一个组的大小之和因此上图中集群的最大存储容量为安装源码位置下载源码后按照文件的描述进行安装与配置安装的所有可执行程序位置主要配置项追踪器配置文件将追踪器和部署主机的地址进行绑定也可以不写如果不写会自动绑定当前主机如果为云服务器建议不写追踪器监听的端口默认追踪器存储日志信息的目录文件必须是一个存在的目录并且用户需要对该路径中的文件有读写权限存储节点配置文件当前存储节点对应的主机属于哪一个组当前存储节点和部署主机的进行绑定如果为云服务器建议不写存储节点监听的端口默认监听客户端的连接存储节点存储日志信息的目录文件必须是一个存在的目录并且用户需要对该路径中的文件有读写权限存储节点提供的存储文件的路径个数具体的存储路径上面项为的话存储路径还需要填写设置追踪器的地址与端口该项可以多次即轮询多个追踪器用于多个追踪服务器追踪服务器的值格式为可以是主机名或地址并且可以是用逗号分隔的双或主机名双必须是内部内网和外部外网或两种不同类型的内部内网例如另一个例子客户端配置文件客户端存储日志信息的目录文件必须是一个存在的目录并且用户需要对该路径中的文件有读写权限设置追踪器的地址与端口填写规则同上存储节点配置文件启动启动追踪器启动存储节点启动客户端格式为程序配置文件路径省略表示第一次启动如启动追踪器关闭追踪器重启追踪器启动存储节点重启和停止同追踪器格式运行监控程序用于检测的状态客户端上传文件要上传的文件路径会返回一个字符串表示文件如客户端下载文件要下载的文件的文件上传下载代码实现使用多进程方式实现函数组函数父进程创建子进程执行有结果输出用管道重定向标准输出到管道的写端父进程读管道读端使用实现余庆未提供文档只能通过看调用案例找安装文件夹中有文件夹该文件夹中的是调用案例参考项目中自带的案例来实现配合项目的插件下载链接在存储节点上安装需要交叉编译和的插件交叉编译和的插件在目录中执行下面命令从插件的源码目录的目录中找执行修改参考来修改日志位置配置追踪器的和端口存储节点绑定的端口当前存储节点所属组客户端下载文件时候这个下载的中是否包含组的名字仅在只有同一个组的时候这个选项可以设为存储节点绑定的地址存储节点上存储路径的个数存储路径的详细位置可以多个重新启动后执行发现没有进程查看日志报错如下解决方式如下从源码安装目录找执行下面命令解决方式如下从源码安装目录找执行下面命令资源在存储节点的存储目录中等中需要告诉服务器资源在哪添加由于经常变化并不是固定目录因此告诉服务器资源的位置标记需要通过插件处理添加了之后重启效果如下日志实现案例源文件日志文件初始化也可以通过进行初始化打开日志如果没有应该把目录建上设置默认信息输出信息选项设置默认告警输出信息选项默认信息输出时间格式默认告警输出时间格式自定义日志输出函数系列可以按普通信息及告警信息分类输出程序日志变参的列表会将按照格式输出到输出日志时打印程序名设置日志格式及选项关闭日志文件设置开始时间返回从历时头文件输出日志时打印程序名输出日志时打印进程是否把告警内容输出到不输出程序名不输出进程不输出告警到输出到告警日志文件中输出到普通日志文件中输出到普通和告警日志文件中系统程序运行日志信息文件日志信息时间格式字串程序运行日志信息文件后缀系统程序运行告警日志文件告警信息时间格式字串程序运行告警日志文件后缀写日志函数对日志格式化打开日志文件关闭日志文件设置开始时间返回从历时使用方式日志文件名初始化日志文件或输出内容到日志文件关闭日志文件报文编解码报文网络通信过程中接受发送的数据编码将传输的数据转换为字节流的过程通用的一种编码格式两台机器通信有如下要考虑网络传输的时候需要用大端模式字节序对齐不同比如结构体等等常用序列化方式类似于是一种常用的序列化和反序列化协议具有跨机器跨语言等优点历史悠久其版本早在年就形成标准并被广泛使用至今最初产生的目标是对互联网文档进行标记所以它的设计理念中就包含了对于人和机器都具备可读性但是当这种标记文档的设计被用来序列化对象的时候就显得冗长而复杂基本格式选项一我是徐茅山今年岁男选项二我是李逍遥今年岁男起源于弱类型语言它的产生来自于一种称之为关联数组的概念其本质是采用键值对的方式来描述对象格式保持了的人眼可读的优点非常符合工程师对对象的理解相对于而言序列化后的数据更加简洁所产生序列化之后文件的大小接近的两倍而且其协议比较简单解析速度比较快格式具备的先天性支持所以被广泛应用于的应用场景中是的事实标准协议官网介绍跳转说明对象格式的字符串都是以键值对的形式存在的其中都是以字符串的形式存在的而部分可以包含等多种类型还可以是子对象或者数组在文件中只能是对象和数组不能既有对象也有数组在对象内部可以包含子对象也可以有子数组在数组内部可以有子对象也可以有子数组官方文档简称是公司内部的混合语言数据标准它是一种轻便高效的结构化数据存储格式可以用于结构化数据串行化很适合做数据存储或数据交换格式高效的序列化使用二进制编码相比于文本格式如和它的序列化后的数据体积更小传输效率更高跨平台和语言无关定义了一种独立于语言和平台的数据描述语言可以在不同的编程语言之间进行数据的序列化和反序列化使得不同系统之间的数据交换更加方便可扩展性支持向后兼容和向前兼容的数据格式演化可以在不破坏现有数据结构的情况下进行数据模型的更新和扩展向后兼容性新版本的数据模型可以解析旧版本的数据即新模型可以正确地处理旧数据不会导致解析错误或数据丢失这意味着旧版本的数据可以与新版本的代码一起使用向前兼容性旧版本的数据可以被新版本的数据模型解析即旧模型可以正确地处理新数据不会导致解析错误或数据丢失这意味着新版本的数据可以与旧版本的代码一起使用代码生成提供了代码生成工具命令行工具可以根据定义的数据结构自动生成对应的类代码简化了数据的编码和解码过程提高了开发效率可读性的定义文件采用了类似于接口定义语言的结构可以清晰地描述数据的结构和字段含义便于理解和维护和的主要应用场景区别广泛应用于电信领域安全协议网络管理等场景例如在和中使用被广泛用于分布式系统通信数据存储配置文件等领域其他抽象语法标记序列化的类自定义的格式抽象语法标记是一种标准是描述在网络上传输信息格式的标准方法描述了一种对数据进行表示编码传输和解码的数据格式它提供了一整套正规的格式用于描述对象的结构而不管语言上如何执行及这些数据的具体指代也不用去管到底是什么样的应用程序本质解决的是在网络上传输数据结构的数据有两部分一部分描述信息内数据数据类型及序列格式相当于属性一部分描述如何将各部分组成消息相当于方法标准的编码规则有基本编码规则规范编码规则唯一编码规则压缩编码规则编码规则编码格式格式即组成的格式数据类型数据长度数据的值下面结构体编码图示节点对应的结构体数据的值真正的数据在这里数据长度数据类型指向下一个成员属性编码形成的结点指向上一个成员属性编码形成的结点原理定义一个结点以形式存储编码后的数据被编码对象的每一个成员属性都会成为一个结点从对象的一个成员开始到最后一个成员所有新建的结点会连成一条双向链表便于后续对象成员依次解码整个对象也会被编码即将链表的首结点封装成一个新的节点作为传出参数传出便于解码时以对象为单位进行解码原理图相关函数编解码函数中包括对各种基本数据类型的编解码函数用于对对象的成员属性进行分别编码同时还包括对对象进行编解码的函数即对成员属性编码后形成的链表首结点进行编码整形整形链表发送的字节流接受的字节流链表释放内存功能对整形数进行编码操作函数参数输入参数表示待编码的整形数据传出参数指针的指针编码之后的数据用于构造链表返回值成功或者失败函数说明对整形数据解码参数说明传入参数指针表示待解码的数据传出参数表示解码之后的数据返回值成功或者失败调用例子函数说明编码字符串数据函数参数输入参数指针表示要编码的数据输出参数指针的指针表示编码成链表格式之后的数据用于构造链表返回值成功或者失败函数说明解码函数将类型解码到第二个参数参数说明输入参数指针表示待解码的链表数据输出参数指针的指针存放解码之后的数据返回值成功或者失败函数说明原始字节流转换为类型字节流将类型函数参数传出参数指针的指针传入参数待转换的字符串传入参数的字符串长度返回值成功或者失败函数说明将类型数据进行编码相当于集成了和函数参数输入参数指的是待编码的字符串输入参数指的是的长度输出参数指针的指针格式基本同理某些情况下相当于集成了和又有所区别解码上两种方式的区别体现如下结构体中解码时不可以使用来解码可以原因如下中包含对二级指针的操作会报错由于数组名是指针常量因此不可以修改函数说明序列化链表将链表序列化成类型的字节流数据函数参数输入参数指针类型待序列化的数据输出参数指针的指针类型序列化之后的数据函数说明反序列化将类型的字节流数据反序列化成链表参数说明输入参数开始需要将类型输出参数获得链表头节点函数说明释放内存使用案例简单使用案例在中定义编码结构体编码头结点只要传指针就可以内部会编码编码编码序列化输出参数赋值释放内存解码结构体头结点将反序列化成链表将有疑问此时得到指向的链表解码解码解码此处的中的也要记得在中释放内存解码输出参数赋值释放内存函数路飞我是要成为海贼王的男人编码省去了发送流程直接解码执行结果进一步封装封装图如下其中的部分添加头结点添加后继结点读头结点数据读后继结点数据打包链表解包链表释放链表这句有问题未能解决释放网络通信学习参考链接主要是下面几种方式它们都位于命名空间中和和是中的一个类属于命名空间类型是一个结构用于表示或地址用途它提供了处理地址的功能例如解析字符串形式的地址比较地址获取地址的字节表示等表示一个网络端点它结合了一个地址和一个端口号官方文档参考属性及方法说明属性获取已经从网络接收且可供读取的数据量属性获取或设置基础属性获取一个值该值指示的基础是否已连接到远程主机属性获取或设置接收缓冲区的大小属性获取或设置在初始化一个读取操作后等待接收数据的时间量属性获取或设置发送缓冲区的大小属性获取或设置等待发送操作成功完成的时间量方法开始一个对远程主机连接的异步请求方法释放此实例而不关闭基础连接方法使用指定的主机名和端口号将客户端连接到主机方法异步接受传入的连接尝试方法返回用于发送和接收数据的属性及方法说明属性获取当前的基础属性获取基础网络方法接受挂起的连接请求方法开始一个异步操作来接受一个传入的连接尝试方法异步接受传入的连接尝试并创建新的来处理远程主机通信方法异步接受传入的连接尝试并创建新的来处理远程主机通信方法开始侦听传入的连接请求方法关闭侦听器案例服务端控制台应用定义地址地址监听套接字开始监听服务器启动成功等待用户接入输出消息每接收一个客户端则生成一个获取网络数据流定义流数据读取对象定义流数据写入对象接收消息截取客户端消息有客户端接入客户输出接收的客户端地址来自客户端的消息输出接收的消息我是服务器欢迎光临定义服务端要写入的消息向对方发送消息客户端控制台应用创建一个对象自动分配主机地址和端口号连接服务器其和端口号为和判断是否连接成功连接服务器成功获取数据流定义流数据读取对象定义流数据写入对象存储本机默认值为获取所有地址如果不是地址获取本机地址你好服务器我是客户端向服务器发送消息接收服务器发送的数据来自服务器的消息输出接收的服务器消息接收过程中如果出现异常退出循环连接服务器失败二进制读写和与上面定义一致读取二进制数据假设我们期望接收个字节例如一个整数读取二进制数据将字节数组转换为整数来自服务器的消息接收到的整数是发送二进制数据示例发送一个整数的二进制表示发送二进制数据官方文档参考的优势协议不仅支持还可以处理其他协议如等更精细度的资源管理如可以直接处理底层的协议套接字选项如缓冲区大小超时设置等支持更完整的异步操作可以使用等方法实现非阻塞的网络通信更强的自定义能力如可以直接控制连接的建立数据传输等过程支持更多高级特性比如多播广播队列控制等常用属性及说明属性说明获取的地址族获取已经从网络接收且可供读取的数据量获取一个值该值指示是在上次还是操作时连接到远程主机获取的操作系统句柄获取本地终结点获取的协议类型获取远程终结点获取或设置一个值该值指定之后同步调用将超时的时间长度常用方法及说明方法说明为新建连接创建新的开始一个异步操作来接受一个传入的连接尝试开始一个对远程主机连接的异步请求开始异步请求从远程终结点断开连接开始从连接的中异步接收数据将数据异步发送到连接的将文件异步发送到连接的向特定远程主机异步发送数据关闭连接并释放所有关联的资源建立与远程主机的连接关闭套接字连接并允许重用套接字异步接受传入的连接尝试结束挂起的异步连接请求结束挂起的异步断开连接请求结束挂起的异步读取结束挂起的异步发送结束文件的挂起异步发送结束挂起的向指定位置进行的异步发送将置于侦听状态接收来自绑定的的数据将数据发送到连接的将文件和可选数据异步发送到连接的将数据发送到特定终结点禁用某上的发送和接收案例客户端服务器常用网络相关命令端口号查询端口占用排查端口占用通过端口号查找占用的进程的需要查的端口号通过查进程名称也可以直接打开任务管理器详细信息窗口查看用于测试地址的脚本连通不通打洞点击跳转域名相关托管域名托管域名是指将已注册域名的管理权委托给专业的第三方服务商由其负责域名的解析维护和技术支持使用户无需自行处理复杂的配置其核心功能包括域名解析管理将域名转换为对应的地址确保用户通过域名访问网站时能正确指向服务器记录维护管理记录指向地址记录邮件服务器记录别名等支持灵活配置安全与稳定性保障通过安全扩展防护等措施防止域名劫持或攻击确保服务高可用自动化服务提供域名续费提醒备份恢复等减少人工操作成本记录的定义与作用记录是系统中的一种资源记录用于指定负责解析域名的权威服务器其核心功能包括授权解析权明确域名由哪些服务器管理如指导用户请求的查询路径冗余与负载均衡支持配置多个记录当主服务器故障时备用服务器可接管保障解析不中断子域名管理若子域名需独立解析如可通过记录指向其他服务商示例若域名使用的服务则需在注册商处设置记录为和此后所有查询由处理全球解析检测与诊断工具主要用于验证域名解析记录的全球传播状态检查配置准确性并提供多种网络诊断功能以下是其核心功能与使用场景的详细解析免费且跨平台基于该工具的记录查询网站',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-04-28 16:32:24',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://th.bing.com/th/id/OIP.wtmjepfWPBvn26uz7s18dgHaHa?rs=1&amp;pid=ImgDetMain"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">ZEROKO14的个人博客</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AI/" style="font-size: 1.05rem;">AI<sup>1</sup></a><a href="/tags/C/" style="font-size: 1.05rem;">C#<sup>3</sup></a><a href="/tags/C/" style="font-size: 1.05rem;">C++<sup>5</sup></a><a href="/tags/CSS/" style="font-size: 1.05rem;">CSS<sup>1</sup></a><a href="/tags/CSharp/" style="font-size: 1.05rem;">CSharp<sup>1</sup></a><a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 1.05rem;">C语言<sup>1</sup></a><a href="/tags/FPS/" style="font-size: 1.05rem;">FPS<sup>1</sup></a><a href="/tags/HTML/" style="font-size: 1.05rem;">HTML<sup>1</sup></a><a href="/tags/JavaScript/" style="font-size: 1.05rem;">JavaScript<sup>1</sup></a><a href="/tags/MFC/" style="font-size: 1.05rem;">MFC<sup>1</sup></a><a href="/tags/PE/" style="font-size: 1.05rem;">PE<sup>1</sup></a><a href="/tags/QT/" style="font-size: 1.05rem;">QT<sup>1</sup></a><a href="/tags/WPF/" style="font-size: 1.05rem;">WPF<sup>3</sup></a><a href="/tags/ai/" style="font-size: 1.05rem;">ai<sup>1</sup></a><a href="/tags/cmake/" style="font-size: 1.05rem;">cmake<sup>1</sup></a><a href="/tags/doxygen/" style="font-size: 1.05rem;">doxygen<sup>1</sup></a><a href="/tags/git/" style="font-size: 1.05rem;">git<sup>1</sup></a><a href="/tags/linux/" style="font-size: 1.05rem;">linux<sup>1</sup></a><a href="/tags/nas/" style="font-size: 1.05rem;">nas<sup>1</sup></a><a href="/tags/next/" style="font-size: 1.05rem;">next<sup>1</sup></a><a href="/tags/ppt/" style="font-size: 1.05rem;">ppt<sup>1</sup></a><a href="/tags/python/" style="font-size: 1.05rem;">python<sup>1</sup></a><a href="/tags/slidev/" style="font-size: 1.05rem;">slidev<sup>1</sup></a><a href="/tags/vue/" style="font-size: 1.05rem;">vue<sup>1</sup></a><a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 1.05rem;">代码规范<sup>1</sup></a><a href="/tags/%E5%86%85%E6%A0%B8/" style="font-size: 1.05rem;">内核<sup>2</sup></a><a href="/tags/%E5%86%85%E6%A0%B8%E7%9B%B8%E5%85%B3/" style="font-size: 1.05rem;">内核相关<sup>5</sup></a><a href="/tags/%E5%8A%A0%E8%A7%A3%E5%AF%86/" style="font-size: 1.05rem;">加解密<sup>1</sup></a><a href="/tags/%E5%9F%BA%E7%A1%80/" style="font-size: 1.05rem;">基础<sup>6</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 1.05rem;">多线程<sup>1</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F/" style="font-size: 1.05rem;">并发模式<sup>1</sup></a><a href="/tags/%E5%BC%80%E5%8F%91/" style="font-size: 1.05rem;">开发<sup>4</sup></a><a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 1.05rem;">数学<sup>1</sup></a><a href="/tags/%E6%9D%82%E9%A1%B9/" style="font-size: 1.05rem;">杂项<sup>1</sup></a><a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 1.05rem;">正则表达式<sup>1</sup></a><a href="/tags/%E7%89%A9%E7%90%86/" style="font-size: 1.05rem;">物理<sup>1</sup></a><a href="/tags/%E7%9B%91%E6%8E%A7/" style="font-size: 1.05rem;">监控<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 1.05rem;">网络<sup>3</sup></a><a href="/tags/%E9%80%86%E5%90%91/" style="font-size: 1.05rem;">逆向<sup>5</sup></a><a href="/tags/%E9%AD%94%E6%B3%95/" style="font-size: 1.05rem;">魔法<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/09/"><span class="card-archive-list-date">九月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/02/"><span class="card-archive-list-date">二月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/12/"><span class="card-archive-list-date">十二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/11/"><span class="card-archive-list-date">十一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/09/"><span class="card-archive-list-date">九月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">七月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">14</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/06/"><span class="card-archive-list-date">六月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/04/"><span class="card-archive-list-date">四月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url">技术</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>网络</span></a></span></div></div><h1 class="post-title" itemprop="name headline">网络编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-07-16T04:06:28.976Z" title="发表于 2024-07-16 12:06:28">2024-07-16</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-04-28T08:32:24.259Z" title="更新于 2025-04-28 16:32:24">2025-04-28</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="网络编程"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为新加坡"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>新加坡</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://che77a38.github.io/posts/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><header><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url">技术</a><a href="/tags/%E7%BD%91%E7%BB%9C/" tabindex="-1" itemprop="url">网络</a><h1 id="CrawlerTitle" itemprop="name headline">网络编程</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">ZEROKO14</span><time itemprop="dateCreated datePublished" datetime="2024-07-16T04:06:28.976Z" title="发表于 2024-07-16 12:06:28">2024-07-16</time><time itemprop="dateCreated datePublished" datetime="2025-04-28T08:32:24.259Z" title="更新于 2025-04-28 16:32:24">2025-04-28</time></header><h1 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h1><ul>
<li>OSI七层,TCP&#x2F;IP四层模型结构</li>
<li>常见网络协议格式</li>
<li>网络字节序和主机字节序之间的转换(大端法和小端法)</li>
<li>tcp服务器端&#x2F;客户端通信流程</li>
</ul>
<span id="more"></span>

<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV17x6hYZEzJ/?buvid=XYD48B6D7912B670B40A315F6058A60809B3A">网络是如何通信的优质讲解视频</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1WT6SYXE2S">网络怎么变靠谱的优质视频</a></p>
<h2 id="分层模型"><a href="#分层模型" class="headerlink" title="分层模型"></a>分层模型</h2><h3 id="网络分层OSI-7层模型"><a href="#网络分层OSI-7层模型" class="headerlink" title="网络分层OSI 7层模型"></a>网络分层OSI 7层模型</h3><p><strong>OSI</strong>是Open System Interconnection的缩写, 意为开放式系统互联. 国际标准化组织(ISO)制定了OSI模型, 该模型定义了不同计算机互联的标准, 是设计和描述计算机网络通信的基本框架.</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202207291621467.png" alt="image-20220729162142546"></p>
<ol>
<li><strong>物理层</strong>—双绞线，光纤（传输介质），将<strong>模拟信号转换为数字信号</strong>(通过调制解调器modemn)</li>
<li><strong>数据链路层</strong>—<strong>数据校验</strong>，定义了<strong>网络传输的基本单位</strong>-<strong>帧</strong>     <a href="#%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7%E6%A0%BC%E5%BC%8F">ARP,RARP协议</a></li>
<li><strong>网络层</strong>—定义网络，两台机器之间<strong>传输的路径选择点到点的传输</strong>    IP协议</li>
<li><strong>传输层</strong>—传输数据 TCP，UDP，<strong>端到端的传输</strong> (不需要考虑中间经过的点)    TCP,UDP协议</li>
<li><strong>会话层</strong>—通过传输层建立数据传输的通道.    </li>
<li><strong>表示层</strong>—编解码，翻译工作.</li>
<li><strong>应用层</strong>—为客户提供各种应用服务，email服务，ftp服务，ssh服务</li>
</ol>
<p>详解</p>
<table>
<thead>
<tr>
<th>分层</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>物理层</td>
<td>主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输，到达目的地后再转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。</td>
</tr>
<tr>
<td>数据链路层</td>
<td>定义了如何让格式化数据以帧为单位进行传输，以及如何让控制对物理介质的访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输。如：串口通信中使用到的115200、8、N、1</td>
</tr>
<tr>
<td>网络层</td>
<td>在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。</td>
</tr>
<tr>
<td>传输层</td>
<td>定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。</td>
</tr>
<tr>
<td>会话层</td>
<td>通过传输层(端口号：传输端口与接收端口)建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名）。</td>
</tr>
<tr>
<td>表示层</td>
<td>可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码(EBCDIC)，而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。</td>
</tr>
<tr>
<td>应用层</td>
<td>是最靠近用户的OSI层。这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务。</td>
</tr>
</tbody></table>
<h3 id="TCP-IP-4层模型"><a href="#TCP-IP-4层模型" class="headerlink" title="TCP&#x2F;IP  4层模型"></a>TCP&#x2F;IP  4层模型</h3><p>上面的OSI模型只是一个理想模型,实际上现在应用的是TCP&#x2F;IP四层模型</p>
<p>TCP&#x2F;IP网络协议栈分为应用层（Application）、传输层（Transport）、网络层（Network）和链路层（Link）四层</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202207291657925.png" alt="image-20220729165744363"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202207291658851.png" alt="image-20220729165801715"></p>
<p>分层的含义如下图:</p>
<p>传输层及其以下的机制由内核提供，应用层由用户进程提供（后面将介绍如何使用socket API编写应用程序），应用程序对通讯数据的含义进行解释，而传输层及其以下处理通讯的细节，将数据从一台计算机通过一定的路径发送到另一台计算机。应用层数据通过协议栈发到网络上时，每层协议都要加上一个数据首部（header），称为封装（Encapsulation），如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202208011530002.png" alt="image-20220801153019809"></p>
<p>通信过程: 其实就是发送端层层打包, 接收方层层解包.</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202208011525225.png" alt="image-20220801152504753" />

<p>不同的协议层对数据包有不同的称谓，在传输层叫做<strong>段（segment）</strong>，在网络层叫做<strong>数据报（datagram）</strong>，在链路层叫做<strong>帧（frame）</strong>。数据封装成帧后发到传输介质上，到达目的主机后每层协议再剥掉相应的首部，最后将应用层数据交给应用程序处理。</p>
<h3 id="TCP-IP协议分层通讯全过程"><a href="#TCP-IP协议分层通讯全过程" class="headerlink" title="TCP&#x2F;IP协议分层通讯全过程"></a>TCP&#x2F;IP协议分层通讯全过程</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202208011625011.png" alt="image-20220801162510989" style="zoom: 67%;" /><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202208011625682.png" alt="image-20220801162514898" style="zoom: 67%;" /></p>
<p>​		链路层有以太网、令牌环网等标准，链路层负责网卡设备的驱动、帧同步（即从网线上检测到什么信号算作新帧的开始）、冲突检测（如果检测到冲突就自动重发）、数据差错校验等工作。交换机是工作在链路层的网络设备，可以在不同的链路层网络之间转发数据帧（比如十兆以太网和百兆以太网之间、以太网和令牌环网之间），由于不同链路层的帧格式不同，交换机要将进来的数据包拆掉链路层首部重新封装之后再转发。</p>
<p>​		链路层有以太网、令牌环网等标准，链路层负责网卡设备的驱动、帧同步（即从网线上检测到什么信号算作新帧的开始）、冲突检测（如果检测到冲突就自动重发）、数据差错校验等工作。交换机是工作在链路层的网络设备，可以在不同的链路层网络之间转发数据帧（比如十兆以太网和百兆以太网之间、以太网和令牌环网之间），由于不同链路层的帧格式不同，交换机要将进来的数据包拆掉链路层首部重新封装之后再转发。<br>​		网络层的IP协议是构成Internet的基础。Internet上的主机通过IP地址来标识，Inter-net上有大量路由器负责根据IP地址选择合适的路径转发数据包，数据包从Internet上的源主机到目的主机往往要经过十多个路由器。路由器是工作在第三层的网络设备，同时兼有交换机的功能，可以在不同的链路层接口之间转发数据包，因此路由器需要将进来的数据包拆掉网络层和链路层两层首部并重新封装。IP协议不保证传输的可靠性，数据包在传输过程中可能丢失，可靠性可以在上层协议或应用程序中提供支持。<br>​		网络层负责点到点（ptop，point-to-point）的传输（这里的“点”指主机或路由器），而传输层负责端到端（etoe，end-to-end）的传输（这里的“端”指源主机和目的主机）。传输层可选择TCP或UDP协议。<br>TCP是一种面向连接的、可靠的协议，有点像打电话，双方拿起电话互通身份之后就建立了连接，然后说话就行了，这边说的话那边保证听得到，并且是按说话的顺序听到的，说完话挂机断开连接。也就是说TCP传输的双方需要首先建立连接，之后由TCP协议保证数据收发的可靠性，丢失的数据包自动重发，上层应用程序收到的总是可靠的数据流，通讯之后关闭连接。<br>​		UDP是无连接的传输协议，不保证可靠性，有点像寄信，信写好放到邮筒里，既不能保证信件在邮递过程中不会丢失，也不能保证信件寄送顺序。使用UDP协议的应用程序需要自己完成丢包重发、消息排序等工作。<br>​		目的主机收到数据包后，如何经过各层协议栈最后到达应用程序呢？其过程如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202208011629493.png" alt="image-20220801162904659"></p>
<p>​		以太网驱动程序首先根据以太网首部中的“上层协议”字段确定该数据帧的有效载荷（payload，指除去协议首部之外实际传输的数据）是IP、ARP还是RARP协议的数据报，然后交给相应的协议处理。假如是IP数据报，IP协议再根据IP首部中的“上层协议”字段确定该数据报的有效载荷是TCP、UDP、ICMP还是IGMP，然后交给相应的协议处理。假如是TCP段或UDP段，TCP或UDP协议再根据TCP首部或UDP首部的“端口号”字段确定应该将应用层数据交给哪个用户进程。IP地址是标识网络中不同主机的地址，而端口号就是同一台主机上标识不同进程的地址，IP地址和端口号合起来标识网络中唯一的进程。</p>
<p>​		虽然IP、ARP和RARP数据报都需要以太网驱动程序来封装成帧，但是从功能上划分，ARP和RARP属于链路层，IP属于网络层。虽然ICMP、IGMP、TCP、UDP的数据都需要IP协议来封装成数据报，但是从功能上划分，ICMP、IGMP与IP同属于网络层，TCP和UDP属于传输层。</p>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p><strong>协议事先约定好, 大家共同遵守的一组规则</strong>, 如交通信号灯.从应用程序的角度看, 协议可理解为<strong>数据传输和数据解释的规则</strong>;可以简单的理解为各个主机之间进行通信所使用的共同语言.</p>
<p>当原始协议经过不断增加完善改进, 最终形成了一个稳定的完整的传输协议, 被广泛应用于各种文件传输, 该协议逐渐就成了一个<strong>标准协议</strong>.</p>
<p>几种常见的标准协议</p>
<ul>
<li><strong>传输层</strong> 常见协议有TCP&#x2F;UDP协议。</li>
<li><strong>应用层</strong> 常见的协议有HTTP协议，FTP协议。</li>
<li><strong>网络层</strong> 常见协议有IP协议、ICMP协议、IGMP协议。</li>
<li><strong>网络接口层</strong> 常见协议有ARP协议、RARP协议。</li>
</ul>
<p>TCP协议注重数据的传输。http协议着重于数据的解释。</p>
<p><strong>具体协议含义</strong></p>
<ul>
<li><code>TCP传输控制协议</code>（Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议。</li>
<li><code>UDP用户数据报协议</code>（User Datagram Protocol）是OSI参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。</li>
<li><code>HTTP超文本传输协议</code>（Hyper Text Transfer Protocol）是互联网上应用最为广泛的一种网络协议。</li>
<li><code>FTP文件传输协议</code>（File Transfer Protocol）</li>
<li><code>IP协议是因特网互联协议</code>（Internet Protocol）</li>
<li><code>ICMP协议</code>是Internet控制报文协议（Internet Control Message Protocol）它是TCP&#x2F;IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。</li>
<li><code>IGMP协议</code>是 Internet 组管理协议（Internet Group Management Protocol），是因特网协议家族中的一个组播协议。该协议运行在主机和组播路由器之间。</li>
<li><code>ARP协议</code>是正向地址解析协议（Address Resolution Protocol），通过已知的IP，寻找对应主机的MAC地址。</li>
<li><code>RARP</code>是反向地址转换协议，通过MAC地址确定IP地址。</li>
</ul>
<h2 id="网络相关名词"><a href="#网络相关名词" class="headerlink" title="网络相关名词"></a>网络相关名词</h2><h4 id="设备相关"><a href="#设备相关" class="headerlink" title="设备相关"></a>设备相关</h4><ul>
<li>路由（名词）<br>数据包从源地址到目的地址所经过的路径，由一系列路由节点组成。</li>
<li>路由（动词）<br>某个路由节点为数据包选择投递方向的选路过程。</li>
</ul>
<p><strong>路由节点</strong></p>
<p>一个具有路由能力的主机或路由器，它维护一张路由表，通过查询路由表来决定向哪个接口发送数据包。</p>
<h5 id="以太网交换机工作原理"><a href="#以太网交换机工作原理" class="headerlink" title="以太网交换机工作原理"></a>以太网交换机工作原理</h5><blockquote>
<p>以太网交换机是基于以太网传输数据的交换机，以太网采用共享总线型传输媒体方式的局域网。以太网交换机的结构是每个端口都直接与主机相连，并且一般都工作在全双工方式。交换机能同时连通许多对端口，使每一对相互通信的主机都能像独占通信媒体那样，进行无冲突地传输数据。<br>以太网交换机工作于OSI网络参考模型的第二层（即数据链路层），是一种基于MAC（Media Access Control，介质访问控制）地址识别、完成以太网数据帧转发的网络设备。</p>
</blockquote>
<p>交换机刚启动时，MAC地址表中无表项。当接入PC的时候，交换机开始进行<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/122241071">学习MAC地址</a>.</p>
<p>交换机对数据帧的转发与过滤:</p>
<ul>
<li><p>单播帧的转发：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202208151208471.jpeg"></p>
<ul>
<li>PCA发出目的到PCD的单播数据帧</li>
<li>交换机根据帧中的目的地址，从相应的端口E1&#x2F;0&#x2F;4发送出去</li>
<li>交换机不在其他端口上转发此单播数据帧</li>
</ul>
</li>
<li><p>广播、组播和未知单播帧的转发：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202208151213890.jpeg" alt="img"></p>
<p>​			交换机会把广播、组播和未知单播帧从所有其他端口发送出去（除了接收到帧的端口）</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/122241071">交换机原理详解跳转</a></p>
<h5 id="路由表-Routing-Table"><a href="#路由表-Routing-Table" class="headerlink" title="路由表(Routing Table)"></a>路由表(Routing Table)</h5><p>在计算机网络中，路由表或称路由择域信息库（RIB）是一个存储在路由器或者联网计算机中的电子表格（文件）或类数据库。路由表存储着指向特定网络地址的路径。</p>
<h5 id="路由条目"><a href="#路由条目" class="headerlink" title="路由条目"></a>路由条目</h5><p>路由表中的一行，每个条目主要由**目的网络地址(Destination)、子网掩码(Genmask)、下一跳地址(GateWay)、发送接口(Iface)**四部分组成，如果要发送的数据包的目的网络地址匹配路由表中的某一行，就按规定的接口发送到下一跳地址。</p>
<h5 id="缺省路由条目"><a href="#缺省路由条目" class="headerlink" title="缺省路由条目"></a>缺省路由条目</h5><p>路由表中的最后一行，主要由下一跳地址和发送接口两部分组成，当目的地址与路由表中其它行都不匹配时，就按缺省路由条目规定的接口发送到下一跳地址。</p>
<h5 id="路由器工作原理"><a href="#路由器工作原理" class="headerlink" title="路由器工作原理"></a>路由器工作原理</h5><blockquote>
<p>路由器（Router）是连接因特网中各局域网、广域网的设备，它会根据信道的情况自动选择和设定路由，以最佳路径，按前后顺序发送信号的设备。<br>传统地，路由器工作于OSI七层协议中的第三层，其主要任务是接收来自一个网络接口的数据包，根据其中所含的目的地址，决定转发到下一个目的地址。因此，路由器首先得在转发路由表中查找它的目的地址，若找到了目的地址，就在数据包的帧格前添加下一个MAC地址，同时IP数据包头的TTL（Time To Live）域也开始减数， 并重新计算校验和。当数据包被送到输出端口时，它需要按顺序等待，以便被传送到输出链路上。<br>路由器在工作时能够按照某种路由通信协议查找设备中的路由表。如果到某一特定节点有一条以上的路径，则基本预先确定的路由准则是选择最优（或最经济）的传输路径。由于各种网络段和其相互连接情况可能会因环境变化而变化，因此路由情况的信息一般也按所使用的路由信息协议的规定而定时更新。<br>网络中，每个路由器的基本功能都是按照一定的规则来动态地更新它所保持的路由表，以便保持路由信息的有效性。为了便于在网络间传送报文，路由器总是先按照预定的规则把较大的数据分解成适当大小的数据包，再将这些数据包分别通过相同或不同路径发送出去。当这些数据包按先后秩序到达目的地后，再把分解的数据包按照一定顺序包装成原有的报文形式。路由器的分层寻址功能是路由器的重要功能之一，该功能可以帮助具有很多节点站的网络来存储寻址信息，同时还能在网络间截获发送到远地网段的报文，起转发作用；选择最合理的路由，引导通信也是路由器基本功能；多协议路由器还可以连接使用不同通信协议的网络段，成为不同通信协议网络段之间的通信平台。<br>路由和交换之间的主要区别就是交换发生在OSI参考模型第二层（数据链路层），而路由发生在第三层，即网络层。这一区别决定了路由和交换在移动信息的过程 中需使用不同的控制信息，所以两者实现各自功能的方式是不同的。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202208151132125.png" alt="img"></p>
<p>如上图图所示：路由器A和B是经过配置的路由在他们的路由表中就保存了相应的网段和接口，如果主机1.1要发送数据包给主机3.1：</p>
<ol>
<li>因为IP地址不在同一网段，主机就会将数据包发送给本网段的网关路由器A。</li>
<li>路由器A接收到数据包，查看数据包IP首部中的目标IP地址，在查找自己的路由表。数据包的目标IP地址是3.1.属于3.0网段路由器A在路由表中查到3.0网段转发的接口是S0接口。于是，路由器就将数据包从S0接口转发出去。</li>
<li>每个路由器但是按这个步骤去转发数据的，直到到达了路由器B,用同样的方法，从E0口转发出去，主机3.1接受到这个数据包。</li>
</ol>
<p>[同网段和不同网段主机通信的区别就在于]  <strong>同网段直接查找主机，而不同网段需要将数据包发送给网关。</strong></p>
<h3 id="其他名词"><a href="#其他名词" class="headerlink" title="其他名词"></a>其他名词</h3><p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%9B%86%E7%BA%BF%E5%99%A8/214614?fr=aladdin">集线器</a></p>
<h4 id="半双工-全双工"><a href="#半双工-全双工" class="headerlink" title="半双工&#x2F;全双工"></a>半双工&#x2F;全双工</h4><ul>
<li>Full-duplex（全双工）全双工是在通道中同时双向数据传输的能力。</li>
<li>Half-duplex（半双工）在通道中同时只能沿着一个方向传输数据。</li>
</ul>
<h4 id="DNS服务器"><a href="#DNS服务器" class="headerlink" title="DNS服务器"></a>DNS服务器</h4><p>DNS 是<strong>域名系统 (Domain Name System)</strong> 的缩写，是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个<strong>分布式数据库</strong>，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP地址串。<br>它是由解析器以及域名服务器组成的。域名服务器是指保存有该网络中所有主机的域名和对应IP地址，并<strong>具有将域名转换为IP地址功能</strong>的服务器。</p>
<p>操作系统中可通过<code>hosts</code>文件手动设置如何解析域名</p>
<ul>
<li>Linux&#x2F;Mac: <code>/etc/hosts</code></li>
<li>Windows: <code>C:\Windows\System32\drivers\etc\hosts</code></li>
<li>Android系统： <code>/system/etc/</code></li>
</ul>
<p>hosts文件格式: <code>IP地址  域名</code>(#行表示注释)</p>
<p>修改hosts后需要刷新dns缓存使之生效:</p>
<ul>
<li>Windows: <code>ipconfig/flushdns</code></li>
<li>Mac: <code>sudo killall -HUP mDNSResponder</code></li>
</ul>
<h4 id="windows下如何修改hosts文件"><a href="#windows下如何修改hosts文件" class="headerlink" title="windows下如何修改hosts文件"></a>windows下如何修改hosts文件</h4><p>host文件要先修改属性，取消“只读”再修改</p>
<p>使用管理员身份运行一个文件编辑程序,再打开hosts文件进行修改,要么就是修改hosts文件的权限(不建议)</p>
<h4 id="局域网-LAN"><a href="#局域网-LAN" class="headerlink" title="局域网(LAN)"></a>局域网(LAN)</h4><p>local area network，一种覆盖一座或几座大楼、一个校园或者一个厂区等地理区域的小范围的计算机网。</p>
<ol>
<li>覆盖的地理范围较小，只在一个相对独立的局部范围内联，如一座或集中的建筑群内。</li>
<li>使用专门铺设的传输介质进行联网，数据传输速率高（10Mb&#x2F;s～10Gb&#x2F;s）</li>
<li>通信延迟时间短，可靠性较高</li>
<li>局域网可以支持多种传输介质</li>
</ol>
<h4 id="广域网-WAN"><a href="#广域网-WAN" class="headerlink" title="广域网(WAN)"></a>广域网(WAN)</h4><p>wide area network，一种用来实现不同地区的局域网或城域网的互连，可提供不同地区、城市和国家之间的计算机通信的远程计算机网。<br>覆盖的范围比局域网（LAN）和城域网（MAN）都广。广域网的通信子网主要使用<strong>分组交换技术</strong>。<br>广域网的通信子网可以利用公用分组交换网、卫星通信网和无线分组交换网，它将分布在不同地区的局域网或计算机系统互连起来，达到资源共享的目的。如互联网是世界范围内最大的广域网。</p>
<ol>
<li>适应大容量与突发性通信的要求；</li>
<li>适应综合业务服务的要求；</li>
<li>开放的设备接口与规范化的协议；</li>
<li>完善的通信服务与网络管理。</li>
</ol>
<h4 id="MTU"><a href="#MTU" class="headerlink" title="MTU"></a>MTU</h4><p>MTU:通信术语 <strong>最大传输单元（Maximum Transmission Unit，MTU）</strong><br>是指一种通信协议的某一层上面所能通过的最大数据包大小（以字节为单位）。最大传输单元这个参数通常与通信接口有关（网络接口卡、串口等）。</p>
<p>以下是一些协议的MTU：</p>
<p>FDDI协议：4352字节<br>以太网（Ethernet）协议：1500字节<br>PPPoE（ADSL）协议：1492字节<br>X.25协议（Dial Up&#x2F;Modem）：576字节<br>Point-to-Point：4470字节 </p>
<h2 id="网络相关命令"><a href="#网络相关命令" class="headerlink" title="网络相关命令"></a>网络相关命令</h2><p>ping命令</p>
<p><strong>查看网络信息</strong></p>
<ul>
<li>mac&#x2F;Linux: <code>ifconfig</code>  (interface configuration)  </li>
<li>windows: <code>ipconfig</code></li>
<li>linux下还可以使用 <code>nmcli</code> 命令(NetworkManager)(部分linux系统需要安装)</li>
</ul>
<p><strong>查询路由表</strong></p>
<ul>
<li>Windows: <code>route print</code></li>
<li>Mac: <code>netstat -rn</code></li>
<li>Linux: <code>route -n</code></li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202208151503698.jpeg" alt="截屏2022-08-15 15.02.37" style="zoom:33%;" />

<p><strong>查询经过的路由器信息</strong></p>
<ul>
<li>Mac&#x2F;Linux: <code>traceroute + IP/域名</code></li>
<li>Linux: <code>tracepath + IP/域名</code></li>
<li>Windows: <code>tracert + IP/域名</code></li>
</ul>
<p><strong>打印公网ip</strong></p>
<p>Linux&#x2F;Mac: <code>echo &quot;cat&lt;/dev/tcp/ns1.dnspod.net/6666&quot;|bash</code></p>
<h2 id="网络程序的设计模式"><a href="#网络程序的设计模式" class="headerlink" title="网络程序的设计模式"></a>网络程序的设计模式</h2><h3 id="C-S设计模式"><a href="#C-S设计模式" class="headerlink" title="C&#x2F;S设计模式"></a>C&#x2F;S设计模式</h3><p>传统的网络应用设计模式，客户机(client)&#x2F;服务器(server)模式。需要在通讯两端各自部署客户机和服务器来完成数据通信。</p>
<p>优点:</p>
<ul>
<li>客户端在本机上可以保证性能, 可以将数据缓存到本地, 提高数据的传输效率, 提高用户体验效果.</li>
<li>客户端和服务端程序都是由同一个开发团队开发, 协议选择比较灵活.</li>
</ul>
<p>缺点:</p>
<ul>
<li>服务器和客户端都需要开发，工作量相对较大, 调试困难, 开发周期长;</li>
<li>从用户的角度看, 需要将客户端安装到用户的主机上, 对用户主机的安全构成威胁.</li>
</ul>
<h3 id="B-S设计模式"><a href="#B-S设计模式" class="headerlink" title="B&#x2F;S设计模式"></a>B&#x2F;S设计模式</h3><p>浏览器(browser)&#x2F;服务器(server)模式。只需在一端部署服务器，而另外一端使用每台PC都默认配置的浏览器即可完成数据的传输。</p>
<p>优点:</p>
<ul>
<li>无需安装客户端, 可以使用标准的浏览器作为客户端;</li>
<li>只需要开发服务器，工作量相对较小;</li>
<li>由于采用标准的客户端, 所以移植性好, 不受平台限制.</li>
<li>相对安全，不用安装软件</li>
</ul>
<p>缺点:</p>
<ul>
<li>由于没有客户端, 数据缓冲不尽人意, 数据传输有限制, 用户体验较差;</li>
<li>通信协议选择只能使用HTTP协议，协议选择不够灵活;</li>
</ul>
<blockquote>
<p>对于C&#x2F;S模式来说，其优点明显。客户端位于目标主机上可以保证性能，将数据缓存至客户端本地，从而提高数据传输效率。且，一般来说客户端和服务器程序由一个开发团队创作，所以他们之间所采用的协议相对灵活。可以在标准协议的基础上根据需求裁剪及定制。例如，腾讯公司所采用的通信协议，即为ftp协议的修改剪裁版。<br>    因此，传统的网络应用程序及较大型的网络应用程序都首选C&#x2F;S模式进行开发。如，知名的网络游戏魔兽世界。3D画面，数据量庞大，使用C&#x2F;S模式可以提前在本地进行大量数据的缓存处理，从而提高观感。<br>    C&#x2F;S模式的缺点也较突出。由于客户端和服务器都需要有一个开发团队来完成开发。工作量将成倍提升，开发周期较长。另外，从用户角度出发，需要将客户端安插至用户主机上，对用户主机的安全性构成威胁。这也是很多用户不愿使用C&#x2F;S模式应用程序的重要原因。</p>
<p>​	B&#x2F;S模式相比C&#x2F;S模式而言，由于它没有独立的客户端，使用标准浏览器作为客户端，其工作开发量较小。只需开发服务器端即可。另外由于其采用浏览器显示数据，因此移植性非常好，不受平台限制。如早期的偷菜游戏，在各个平台上都可以完美运行。<br>​	B&#x2F;S模式的缺点也较明显。由于使用第三方浏览器，因此网络应用支持受限。另外，没有客户端放到对方主机上，缓存数据不尽如人意，从而传输数据量受到限制。应用的观感大打折扣。第三，必须与浏览器一样，采用标准http协议进行通信，协议选择不灵活。<br>​	因此在开发过程中，模式的选择由上述各自的特点决定。根据实际需求选择应用程序设计模式。</p>
</blockquote>
<h2 id="tcp原理"><a href="#tcp原理" class="headerlink" title="tcp原理"></a>tcp原理</h2><h3 id="三次握手四次挥手"><a href="#三次握手四次挥手" class="headerlink" title="三次握手四次挥手"></a>三次握手四次挥手</h3><p>建立连接需要三次握手,断开连接需要四次挥手</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202208171311906.png" alt="image-20220817131155533"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202208021259348.png" alt="image-20220802125922013" style="zoom: 67%;" /></p>
<blockquote>
<p>段2的箭头上标着SYN, 8000(0), ACK1001, ，表示该段中的SYN位置1，32位序号是8000，该段不携带有效载荷（数据字节数为0），ACK位置1，32位确认序号是1001，带有一个mss（Maximum Segment Size，最大报文长度）选项值为1024。</p>
</blockquote>
<p>SYS—–&gt;synchronous<br>ACK—–&gt;acknowledgement	<br>FIN——&gt;finish</p>
<p>ACK表示确认序号, 确认序号的值是对方发送的<code>序号值+数据的长度</code>, 	特别注意的是<strong>SYN和FIN本身也会占用一位</strong>.</p>
<h4 id="建立三次握手的过程"><a href="#建立三次握手的过程" class="headerlink" title="建立三次握手的过程"></a>建立三次握手的过程</h4><ol>
<li><p>客户端发送一个带SYN标志的TCP报文到服务器。这是三次握手过程中的段1</p>
<blockquote>
<p>客户端发出段1，SYN位表示连接请求。序号是1000，这个序号在网络通讯中用作临时的地址，每发一个数据字节，这个序号要加1，这样在接收端可以根据序号排出数据包的正确顺序，也可以发现丢包的情况，另外，规定SYN位和FIN位也要占一个序号，这次虽然没发数据，但是由于发了SYN位，因此下次再发送应该用序号1001。mss表示最大段尺寸，如果一个段太大，封装成帧后超过了链路层的最大帧长度，就必须在IP层分片，为了避免这种情况，客户端声明自己的最大段尺寸，建议服务器端发来的段不要超过这个长度。</p>
</blockquote>
</li>
<li><p>服务器端回应客户端，是三次握手中的第2个报文段，同时带ACK标志和SYN标志。它表示对刚才客户端SYN的回应；同时又发送SYN给客户端，询问客户端是否准备好进行数据通讯</p>
<blockquote>
<p>服务器发出段2，也带有SYN位，同时置ACK位表示确认，确认序号是1001，表示“我接收到序号1000及其以前所有的段，请你下次发送序号为1001的段”，也就是应答了客户端的连接请求，同时也给客户端发出一个连接请求，同时声明最大尺寸为1024。</p>
</blockquote>
</li>
<li><p>客户必须再次回应服务器端一个ACK报文，这是报文段3</p>
<blockquote>
<p>客户端发出段3，对服务器的连接请求进行应答，确认序号是8001。在这个过程中，客户端和服务器分别给对方发了连接请求，也应答了对方的连接请求，其中服务器的请求和应答在一个段中发出，因此一共有三个段用于建立连接，称为“三方握手（three-way-handshake）”。在建立连接的同时，双方协商了一些信息，例如双方发送序号的初始值、最大段尺寸等。</p>
</blockquote>
</li>
</ol>
<p>在TCP通讯中，如果一方收到另一方发来的段，读出其中的目的端口号，发现本机并没有任何进程使用这个端口，就会应答一个包含RST位的段给另一方。例如，服务器并没有任何进程使用8080端口，我们却用telnet客户端去连接它，服务器收到客户端发来的SYN段就会应答一个RST段，客户端的telnet程序收到RST段后报告错误<code>Connection refused</code></p>
<h4 id="数据传输的过程"><a href="#数据传输的过程" class="headerlink" title="数据传输的过程"></a>数据传输的过程</h4><ol>
<li>客户端发出段4，包含从序号1001开始的20个字节数据</li>
<li>服务器发出段5，确认序号为1021，对序号为1001-1020的数据表示确认收到，同时请求发送序号1021开始的数据，服务器在应答的同时也向客户端发送从序号8001开始的10个字节数据，这称为piggyback</li>
<li>客户端发出段6，对服务器发来的序号为8001-8010的数据表示确认收到，请求发送序号8011开始的数据</li>
</ol>
<p>在数据传输过程中，<strong>ACK和确认序号是非常重要的</strong>，应用程序交给TCP协议发送的数据会暂存在TCP层的发送缓冲区中，发出数据包给对方之后，只有收到对方应答的ACK段才知道该数据包确实发到了对方，可以从发送缓冲区中释放掉了，如果因为网络故障丢失了数据包或者丢失了对方发回的ACK段，经过等待超时后TCP协议自动将发送缓冲区中的数据包重发。</p>
<h4 id="关闭连接（四次挥手）的过程"><a href="#关闭连接（四次挥手）的过程" class="headerlink" title="关闭连接（四次挥手）的过程"></a>关闭连接（四次挥手）的过程</h4><p>由于TCP连接是<strong>全双工</strong>的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p>
<ol>
<li>客户端发出段7，FIN位表示关闭连接的请求</li>
<li>服务器发出段8，应答客户端的关闭连接请求</li>
<li>服务器发出段9，其中也包含FIN位，向客户端发送关闭连接请求</li>
<li>客户端发出段10，应答服务器的关闭连接请求</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202208171511230.png" alt="image-20220817151120112"></p>
<p>建立连接的过程是三方握手，而关闭连接通常需要4个段，<strong>服务器的应答和关闭连接请求通常不合并在一个段中，因为有连接半关闭的情况，这种情况下客户端关闭连接之后就不能再发送数据给服务器了</strong>，但是服务器还可以发送数据给客户端，直到服务器也关闭连接为止。</p>
<p>当双方刚好同时关闭的时候(概率很低),是存在<code>ACK</code>和<code>FIN,ACK</code>包合并为同一个发送的情况的,<strong>这种情况只需要三步挥手</strong>便结束了.</p>
<p><strong>[重点的问题理解]</strong></p>
<ol>
<li><p>为什么四次挥手中,被动被请求关闭连接的一方要发送**一个确认包和一个请求关闭连接包,**而不能仅仅发一个请求连接包?</p>
<p>因为第一个确认包仅仅表示收到了对方关闭连接的请求,但自身却还可能有未发送完的数据,第二个请求关闭连接包才真正表示自身的发送也完成可以关闭了.即表示第一个包和第二个包之间依然可以发送未发送完的数据包.</p>
</li>
<li><p>为什么最先请求关闭连接的一方在第四次挥手发送确认包后还要<strong>等待2倍MSL时间</strong>?</p>
<ol>
<li><p>让四次挥手的过程更可靠, 确保最后一个发送给对方的ACK到达;</p>
<p>若对方没有收到ACK应答, 对方会再次发送FIN请求关闭, 此时在2MS时间内被动关闭方仍然可以发送ACK给对方</p>
<p>补充解释:发送的ACK有可能丢失,如果ACK丢失,另一方会重发关闭连接请求包,两个MSL时间可以大幅度增加接收到重发的关闭连接请求包的情况的可能.但是情况依旧不完美,因为重发的关闭请求包也存在丢失的可能,如果也丢失了,重发的时间又超过了2倍MSL时间,那么他将等不到发回来的确定包,即等不到关闭的时机.(脑补应该用心跳包解决)</p>
</li>
<li><p>为了保证在2MS时间内, 不能启动相同的SOCKET-PAIR.</p>
<p>​		<code>TIME_WAIT</code>一定是出现在主动关闭的一方, 也就是说2MS是针对主动关闭一方来说的;由于TCP有可能存在丢包重传, 丢包重传若发给了已经断开连接之后相同的socket-pair(该连接是新建的, 与原来的socket-pair完全相同, 双方使用的是相同的IP和端口), 这样会对之后的连接造成困扰, 严重可能引起程序异常.因此很多操作系统实现的时候, 只要端口被占用, 服务就不能启动.通过这个方式尽可能解决该程序异常. (实际上服务端每次都是使用的同一个端口,而客户端一般设置为由内核分配随机端口,会避免这种问题发生.因此实际上很难发生这样的情况)</p>
</li>
</ol>
</li>
</ol>
<p>主动断开方,查看 <code>netstat -anp | grep 端口号</code>会发现状态为<code>TIME_WAIT</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202209251613238.jpg" alt="截屏2022-09-25 16.12.34"></p>
<h3 id="tcp状态转换"><a href="#tcp状态转换" class="headerlink" title="tcp状态转换"></a>tcp状态转换</h3><p>socket-pair的概念: 客户端与服务端连接其实是一个连接对, 可以通过使用<code>netstat -anp | grep 端口号</code>进行查看(linux),他也可以查询是什么进程占用着端口</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202208231155852.png" alt="image-20220823115550841"></p>
<p>说明: 上图中粗线表示主动方, 虚线表示被动方, 细线部分表示一些特殊情况</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202208231157549.png" alt="image-20220823115705716"></p>
<p><strong>三次握手过程</strong></p>
<p>客户端–&gt;服务端</p>
<ul>
<li><p>客户端:<code>SYN_SENT</code>    —     connect()</p>
</li>
<li><p>服务端: </p>
<p><code>LISTEN</code>    —     listen() </p>
<p><code>SYN_RCVD</code>     —     收到连接请求的时候状态转换</p>
</li>
</ul>
<p><strong>数据传输过程中</strong></p>
<p>状态不会发生变化,一直都是<code>ESTABLISHED</code>状态</p>
<p><strong>四次挥手过程</strong></p>
<p>客户端&lt;–&gt;服务端</p>
<ul>
<li><p>主动关闭方</p>
<p><code>FIN_WAIT_1</code>    —     close()</p>
<p><code>FIN_WAIT_2</code>    —     收到被动接收方确认断开连接请求的时候状态转换</p>
<p><code>TIME_WAIT</code>      —     收到被动接收方的断开请求时候的状态转换</p>
</li>
<li><p>被动关闭方</p>
<p><code>CLOSE_WAIT</code>     —     收到断开连接请求的时候状态转换</p>
<p><code>LAST_ACK</code>    —     close()</p>
</li>
</ul>
<p>主动关闭的Socket端会进入<code>TIME_WAIT</code>状态，并且持续2MSL时间长度，MSL就是**<code>maximum segment lifetime</code>(最大分节生命期）**，这是一个IP数据包能在互联网上生存的最长时间，超过这个时间将在网络中消失。</p>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>主要作用: 滑动窗口主要是进行<strong>流量控制</strong>的.<br>见下图:如果发送端发送的速度较快，接收端接收到数据后处理的速度较慢，而接收缓冲区的大小是固定的，就会导致接收缓冲区满而丢失数据。TCP协议通过“滑动窗口（Sliding Window）”机制解决这一问题。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202208171607253.png" alt="image-20220817160708623"></p>
<ol>
<li>   发送端发起连接，声明最大段尺寸是1460，初始序号是0，窗<strong>口大小是4K，表示“我的接收缓冲区还有4K字节空闲</strong>，你发的数据不要超过4K”。接收端应答连接请求，声明最大段尺寸是1024，初始序号是8000，窗口大小是6K。发送端应答，三方握手结束。</li>
<li>   发送端发出段4-9，每个段带1K的数据，发送端根据窗口大小知道接收端的缓冲区满了，因此停止发送数据。</li>
<li>   接收端的应用程序提走2K数据，接收缓冲区又有了2K空闲，接收端发出段10，在应答已收到6K数据的同时声明窗口大小为2K。</li>
<li>   接收端的应用程序又提走2K数据，接收缓冲区有4K空闲，接收端发出段11，重新声明窗口大小为4K。</li>
<li>   发送端发出段12-13，每个段带2K数据，段13同时还包含FIN位。</li>
<li>   接收端应答接收到的2K数据（6145-8192），再加上FIN位占一个序号8193，因此应答序号是8194，连接处于半关闭状态，接收端同时声明窗口大小为2K。</li>
<li>   接收端的应用程序提走2K数据，接收端重新声明窗口大小为4K。</li>
<li>   接收端的应用程序提走剩下的2K数据，接收缓冲区全空，接收端重新声明窗口大小为6K。</li>
<li>   接收端的应用程序在提走全部数据后，决定关闭连接，发出段17包含FIN位，发送端应答，连接完全关闭。</li>
</ol>
<p>win表示告诉对方我这边缓冲区大小是多少, mss表示告诉对方我这边最多一次可以接收多少数据, 你最好不要超过这个长度.</p>
<p>在客户端给服务端发包的时候, 不一定是非要等到服务端返回响应包, 由于客户端知道服务端的窗口大小, 所以可以持续多次发送, 当发送数据达到对方窗口大小了就不再发送, 需要等到对方进行处理, 对方处理之后可继续发送.</p>
<p>从这个例子还可以看出，发送端是一K一K地发送数据，而接收端的应用程序可以两K两K地提走数据，当然也有可能一次提走3K或6K数据，或者一次只提走几个字节的数据。也就是说，应用程序所看到的数据是一个整体，或说是一个流（stream），在底层通讯中这些数据可能被拆成很多数据包来发送，但是一个数据包有多少字节对应用程序是不可见的，因此TCP协议是面向流的协议。而UDP是面向消息的协议，每个UDP段都是一条消息，应用程序必须以消息为单位提取数据，不能一次提取任意字节的数据，这一点和TCP是很不同的。</p>
<h3 id="mss和MTU的区别"><a href="#mss和MTU的区别" class="headerlink" title="mss和MTU的区别"></a>mss和MTU的区别</h3><ul>
<li><p><code>MTU</code>: 最大传输单元  Maximum Transmission Unit，MTU）<br>是指一种通信协议的某一层上面所能通过的最大数据包大小（以字节为	单位). 最大传输单元这个参数通常与通信接口有关（网络接口卡、串	口等), 这个值如果设置为太大会导致丢包重传的时候重传的数据量较大, 	图中的最大值是1500, 其实是一个经验值.</p>
</li>
<li><p><code>mss</code>: 最大报文长度</p>
<p>只是在建立连接的时候, 告诉对方我最大能够接收多少数据, 在数据通信的过程中就没有mss了.</p>
</li>
</ul>
<blockquote>
<p>概括来讲，MTU是<strong>以太网数据链路层中约定的数据载荷部分最大长度，数据不超过它时就无需分片。</strong></p>
<p>MSS是<strong>传输层</strong>的概念，由于数据往往很大，会超出MTU，所以我们之前在网络层中学习过IP分片的知识，将很大的数据载荷分割为多个分片发送出去。</p>
</blockquote>
<p><strong>TCP为了IP层不用分片主动将数据包切割为MSS大小。</strong></p>
<p>一个等式可见他两关系匪浅：<br>$$<br>MSS &#x3D; MTU - IP header头大小 - TCP 头大小<br>$$</p>
<h2 id="以太网帧格式"><a href="#以太网帧格式" class="headerlink" title="以太网帧格式"></a>以太网帧格式</h2><p>以太网帧格式就是<strong>包装在网络接口层(数据链路层)的协议</strong></p>
<p><em>以太网帧的类型为     0x0806: 表示 ARP 类型;0X8035 表示 RARP 类型</em></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202208011604164.png" alt="image-20220801160410607"></p>
<blockquote>
<p>其中的源地址和目的地址是指网卡的硬件地址（也叫MAC地址），长度是48位，是在网卡出厂时固化的。可在shell中使用ifconfig命令查看，“HWaddr 00:15:F2:14:9E:3F”部分就是硬件地址。协议字段有三种值，分别对应IP、ARP、RARP。帧尾是CRC校验码。<br>以太网帧中的数据长度规定最小46字节，最大1500字节，<strong>ARP和RARP数据包的长度不够46字节，要在后面补填充位</strong>(填充位的内容没有定义，与具体实现相关)。最大值1500称为<strong>以太网的最大传输单元（MTU）</strong>，不同的网络类型有不同的MTU，如果一个数据包从以太网路由到拨号链路上，数据包长度大于拨号链路的MTU，则需要对数据包进行分片（fragmentation）。ifconfig命令输出中也有“MTU:1500”。注意，MTU这个概念指数据帧中有效载荷的最大长度，不包括帧头长度。</p>
</blockquote>
<p>以ARP为例介绍以太网帧格式</p>
<h3 id="ARP数据报格式"><a href="#ARP数据报格式" class="headerlink" title="ARP数据报格式"></a>ARP数据报格式</h3><p>地址解析协议ARP  (Address Resolution Protocol)</p>
<p>​		在网络通讯时，源主机的应用程序知道目的主机的IP地址和端口号，却不知道目的主机的硬件地址，而数据包首先是被网卡接收到再去处理上层协议的，如果接收到的数据包的硬件地址与本机不符，则直接丢弃。因此在通讯前必须获得目的主机的硬件地址。ARP协议就起到这个作用。源主机发出ARP请求，询问“IP地址是192.168.0.1的主机的硬件地址是多少”，并将这个请求广播到本地网段（<strong>以太网帧首部的硬件地址填FF:FF:FF:FF:FF:FF表示广播</strong>），目的主机接收到广播的ARP请求，发现其中的IP地址与本机相符，则发送一个ARP应答数据包给源主机，将自己的硬件地址填写在应答包中。<br>​		每台主机都维护一个ARP缓存表，可以用<code>arp -a</code>命令查看。缓存表中的表项有过期时间（一般为20分钟），如果20分钟内没有再次使用某个表项，则该表项失效，下次还要发ARP请求来获得目的主机的硬件地址。</p>
<p>ARP数据报的格式如下所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202208011611692.png" alt="image-20220801161139071"></p>
<p>源MAC地址、目的MAC地址在以太网首部和ARP请求中各出现一次，对于链路层为以太网的情况是多余的，但如果链路层是其它类型的网络则有可能是必要的。<strong>硬件类型指链路层网络类型</strong>，1为以太网，<strong>协议类型指要转换的地址类型</strong>，0x0800为IP地址，后面两个地址长度对于以太网地址和IP地址分别为6和4（字节），<strong>op字段为1表示ARP请求，op字段为2表示ARP应答。</strong></p>
<p>目的端mac地址是通过发送端发送ARP广播, 接收到该ARP数据的主机先判断是否是自己的IP, 若是则应答一个ARP应答报文, 并将mac地址填入应答报文中; 若目的IP不是自己的主机IP, 则直接丢弃该ARP请求报文.</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202208011709059.png" alt="image-20220801170907341"></p>
<p>如上图所示,<strong>ARP协议</strong>目的:解决同一个局域网上的主机或路由器的ip地址和硬件地址的映射问题</p>
<h3 id="抓包命令"><a href="#抓包命令" class="headerlink" title="抓包命令"></a>抓包命令</h3><p>抓包命令: <code>tcpdump -ntx</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202208021541290.png" alt="image-20220802154101644"></p>
<p>思考题：如果源主机和目的主机不在同一网段，ARP请求的广播帧无法穿过路由器，源主机如何与目的主机通信？</p>
<p>那么就要通过ARP找到一个位于本局域网上的某个路由器的硬件地址,然后把分组发送个这个路由器,让这个路由器把分组转发给下一个网络,剩下的工作就由下一个网络来做</p>
<h3 id="IP段格式"><a href="#IP段格式" class="headerlink" title="IP段格式"></a>IP段格式</h3><p>IP协议是TCP&#x2F;IP协议族的基石，它为上层提供无状态、无连接、不可靠的服务</p>
<ul>
<li>无状态：指IP通信双方不同步传输数据的状态信息，因此所有IP数据报的发送，传输，接收都是相互独立的。这种服务最大缺点是无法处理乱序和重复的IP数据报。优点是简单高效，和UDP协议与HTTP协议相同，都是无状态协议。</li>
<li>无连接：指IP通信双方都不长久的维持对方的任何信息。这表示上层协议每次发送数据，都需要明确指定对方的IP地址。</li>
<li>不可靠：指IP协议不能IP数据报能准确到达接收端，只是会尽最大努力。一旦发送失败，就通知上层协议，而不会试图重发。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202208011731994.png" alt="image-20220801173138936"></p>
<ul>
<li><strong>4位版本号</strong>：指定IP协议的版本，对于IPv4来说，其值为4，其它IPv4扩展版本则具有不同的版本号（如SIP协议和PIP协议）</li>
<li><strong>4位头部长度</strong>：表示IP头部有多少个32bit字（4字节）。因为4位最大15，所以IP头部最长为60字节。</li>
<li><strong>8位服务类型</strong>：3位优先级权字段（现已被忽略），4位TOS字段和1位保留字段（必须置0）.4位TOS字段分别表示：最小延迟，最大吞吐量、最高可靠性和最小费用，其中最多1个能置为1。</li>
<li><strong>16位总长度</strong>：指整个IP数据包的长度，字节为单位。最长65535字节，由于长度超过MTU的数据报将被分片传输，所以实际传输的长度没有达到最大值。</li>
<li><strong>16位标识</strong>：唯一标识主机发送的每个数据报。初始值由系统随机生成，每发送一个数据报，其值加一。该值在数据报分片时被复制到每个分片中，因此<strong>同一个数据报的所有分片标识值都相同</strong></li>
<li><strong>3位标志</strong>：第一位保留，第二位表示是否禁止分片，如果设置了该位，IP数据报长度超过MTU将被丢弃，返回错误。第三位表示更多分片，除了最后一个分片，其它都要置它为1.</li>
<li><strong>13位分片偏移</strong>：该分片相较于原始IP数据报开始处（仅指数据部分）的偏移。实际偏移值是该值左移3位得到。因此除了最后一个分片，每个分片的数据部分长度必须是8的整数倍。</li>
<li><strong>8位生存时间</strong>：数据报到达目的地之前允许经过的路由器跳数。每经过一个路由，该值减一，为0时被丢弃。并返回TCMP错误报文。</li>
<li><strong>8位协议</strong>：用于区分上层协议。ICMP为1，TCP为6，UDP为17。</li>
<li><strong>16位头部校验和</strong>：由发送端填充，接收端对其使用CRC算法检验数据是否被损坏。</li>
<li><strong>32位源端IP地址</strong>：标识数据报的发送端。在传输过程中保持不变</li>
<li><strong>32位源目的端IP地址</strong>：标识数据报的接收端。在传输过程中保持不变</li>
<li><strong>选项字段</strong>：可变长的可选信息，最多40字节。可用的IP选项有：<ul>
<li>记录路由：将数据包经由的所有路由器IP填入该段。</li>
<li>时间戳：将数据报在每个路由器被转发时的时间填入该段。</li>
<li>松散源路由选择：指定路由器IP地址列表，数据报发送过程中必须经过其中所有路由器</li>
<li>严格源路由选择：类似上面，数据报只能经过被指定的路由器。</li>
</ul>
</li>
</ul>
<p>&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;未解决&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</p>
<p>思考题：想一想，前面讲了以太网帧中的最小数据长度为46字节，不足46字节的要用填充字节补上，那么如何界定这46字节里前多少个字节是IP、ARP或RARP数据报而后面是填充字节？</p>
<h4 id="ip分片"><a href="#ip分片" class="headerlink" title="ip分片"></a>ip分片</h4><p>当IP数据报的长度超过帧的MTU时，它将被分片传输。分片可能发生在发送端，也可能发生在中转路由器上，而且在传输过程中可能被多次分片，只有在最终目标机器上，这些分片才会在内核中被IP模块重新组装。</p>
<p>IP头部中的数据报标识、标志、和片偏移为IP的分片和重组提供了足够的信息。</p>
<p>一个数据报的每个分片都具有自己的IP头部，且具有相同的标识，但具有不同的片偏移，除了最后一个分片之外都设置了MF标志。</p>
<p><strong>ip路由的工作模式</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202208021649196.png" alt="image-20220802164931881"></p>
<p>IP模块收到来自数据链路层的IP数据报，首先对数据报的头部做CRC校验，无误后开始分析头部具体信息。</p>
<p>如果IP数据报头部设置了源站选路选项，则IP模块调用数据报转发子模块来处理该数据报。</p>
<p>如果该数据报的头部目标IP地址是本机的某个IP地址，或者广播地址，则IP模块根据数据报协议字段来决定发送给哪个上层应用。如果不是本机，则掉用数据报转发子模块来处理该数据报。</p>
<p>数据报转发模块检查系统是否允许转发，不允许则丢弃。允许则将该数据报执行一些操作，就将它交给IP数据报输出模块。</p>
<p>IP数据报根据路由表计算下一跳路由。</p>
<p>IP输出队列存放所有等待发送的IP数据报。</p>
<h4 id="路由机制"><a href="#路由机制" class="headerlink" title="路由机制"></a>路由机制</h4><ol>
<li>查找路由表中和数据报的目标IP完全匹配的主机IP地址，如果找到，就直接使用该项，没有就到第二步</li>
<li>查找路由表中和目标IP具有相同的网路ID的IP地址，如Gateway，有就使用，否则来到第三步</li>
<li>选择默认路由项，这一般为网关。</li>
</ol>
<p>执行<code>route</code>命令可查看路由表</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202208021653124.png" alt="image-20220802165344800"></p>
<ul>
<li><code>Destination</code>：目标网络或主机</li>
<li><code>Gateway</code>：网关地址，*表示目标与本机在同一个网络上，不需要路由。</li>
<li><code>Genmask</code>：网络掩码</li>
<li><code>Flags</code>：路由标志，U：该路由活动，H：该路由目标是一个主机，G：该路由目标是网关，D：该路由是重定向产生的，M：该路由被重定向修改过</li>
<li><code>Metric</code>：路由距离，达到目标网络所需的中转数</li>
<li><code>Ref</code>：路由项被引用的次数</li>
<li><code>Use</code>：该路由项被使用的次数</li>
<li><code>Iface</code>：该路由对应的输出网卡接口</li>
</ul>
<h4 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h4><p>IPv6由40个字节的固定头部和可变长的扩展头部组成。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202208021655270.png" alt="image-20220802165506044"></p>
<ul>
<li>4位版本号：IP协议版本，IPv6值为6</li>
<li>8位通信类型：指示数据通信类型和优先级</li>
<li>20位流标志：用于某些对连接服务质量有特殊要求的通信。</li>
<li>16位净荷长度：指IPv6扩展头部和应用程序数据长度之和，不包含固定头部长度</li>
<li>8位下一个包头：指紧跟IPv6固定头部的包头类型，如扩展头或上层协议。</li>
<li>8位跳数限制：和IPv4的TTL含义相同</li>
<li>后两项IP地址：IPv6地址一般用16进制字符串表示，用‘:’分割为8组，每组两个字节。</li>
</ul>
<h3 id="UDP数据报格式"><a href="#UDP数据报格式" class="headerlink" title="UDP数据报格式"></a>UDP数据报格式</h3><p>无连接的,不安全,不可靠的</p>
<blockquote>
<p>UDP（UserDatagramProtocol）是一个简单的面向消息的传输层协议，尽管UDP提供标头和有效负载的完整性验证（通过校验和），但它不保证向上层协议提供消息传递，并且UDP层在发送后不会保留UDP 消息的状态。因此，UDP有时被称为不可靠的数据报协议。如果需要传输可靠性，则必须在用户应用程序中实现。</p>
<p>UDP使用具有<strong>最小协议机制</strong>的简单无连接通信模型。UDP提供数据完整性的校验和，以及用于在数据报的源和目标寻址不同函数的端口号。它没有握手对话，因此将用户的程序暴露在底层网络的任何不可靠的方面。如果在网络接口级别需要纠错功能，应用程序可以使用为此目的设计的传输控制协议（TCP）。</p>
</blockquote>
<ul>
<li><p>UDP是基于IP的简单协议，不可靠的协议。</p>
</li>
<li><p>UDP的优点：简单，轻量化。</p>
</li>
<li><p>UDP的缺点：没有流控制，没有应答确认机制，不能解决丢包、重发、错序问题。</p>
<p>并不是所有使用UDP协议的应用层都是不可靠的，应用程序可以自己实现可靠的数据传输，通过增加确认和重传机制，所以使用UDP 协议最大的特点就是速度快。</p>
</li>
</ul>
<p>其他特点:</p>
<ul>
<li><p>UDP <strong>没有拥塞控制</strong></p>
<p>网络出现的拥塞不会使源主机的发送速率降低。这对某些实时应用是很重要的。</p>
</li>
<li><p>UDP 支持<strong>一对一、一对多、多对一和多对多</strong>的交互通信。</p>
</li>
</ul>
<p><strong>[UDP的应用]</strong>      UDP协议一般作为流媒体应用、语音交流、视频会议所使用的传输层协议，还有许多基于互联网的电话服务使用的VOIP（基于IP的语音）也是基于UDP运行的.这些<strong>实时应用</strong>要求源主机以恒定的速率发送数据，并且允许在网络出现拥塞时丢失一部分数据，但却不允许数据有太大的时延。UDP 协议正好适合这种要求。</p>
<h4 id="UDP头部格式"><a href="#UDP头部格式" class="headerlink" title="UDP头部格式"></a>UDP头部格式</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202208011752367.png" alt="image-20220801175246809"></p>
<ul>
<li>通过IP地址来确定网络环境中的唯一的一台主机;</li>
<li>主机上使用端口号来区分不同的应用程序.  </li>
<li>[IP+端口] 唯一确定 [一台主机上的一个服务(应用程序)].</li>
</ul>
<blockquote>
<p><code>/etc/services</code>中列出了所有规定的服务端口和对应的传输层协议，这是由IANA（Internet Assigned Numbers Authority）规定的，其中有些服务既可以用TCP也可以用UDP，为了清晰，IANA规定这样的服务采用相同的TCP或UDP默认端口号，而另外一些TCP和UDP的相同端口号却对应不同的服务。</p>
<p>很多服务有规定的端口号，然而客户端程序的端口号却不必是规定的，往往是每次运行客户端程序时由系统自动分配一个空闲的端口号，用完就释放掉，称为ephemeral的端口号</p>
</blockquote>
<p>​		发送端的UDP协议层只管把应用层传来的数据封装成段交给IP协议层就算完成任务了，如果因为网络故障该段无法发到对方，UDP协议层也不会给应用层返回任何错误信息。</p>
<p>​		接收端的UDP协议层只管把收到的数据根据端口号交给相应的应用程序就算完成任务了，如果发送端发来多个数据包并且在网络上经过不同的路由，到达接收端时顺序已经错乱了，UDP协议层也不保证按发送时的顺序交给应用层。<br>通常接收端的UDP协议层将收到的数据放在一个固定大小的缓冲区中等待应用程序来提取和处理，如果应用程序提取和处理的速度很慢，而发送端发送的速度很快，就会丢失数据包，UDP协议层并不报告这种错误。</p>
<p>​		因此，使用UDP协议的应用程序必须考虑到这些可能的问题并实现适当的解决方案，例如等待应答、超时重发、为数据包编号、流量控制等。一般使用UDP协议的应用程序实现都比较简单，只是发送一些对可靠性要求不高的消息，而不发送大量的数据。例如，基于UDP的TFTP协议一般只用于传送小文件（所以才叫trivial的ftp），而基于TCP的FTP协议适用于各种文件的传输。</p>
<p>举例:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于UDP的TFTP协议帧</span></span><br><span class="line"><span class="comment">//以太网首部</span></span><br><span class="line"><span class="number">00</span> <span class="number">05</span> <span class="number">5</span>d <span class="number">67</span> d0 b1 <span class="number">00</span> <span class="number">05</span> <span class="number">5</span>d <span class="number">61</span> <span class="number">58</span> a8 <span class="number">08</span> <span class="number">00</span></span><br><span class="line"><span class="comment">//IP首部</span></span><br><span class="line"><span class="number">45</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">53</span> <span class="number">93</span> <span class="number">25</span> <span class="number">00</span> <span class="number">00</span> <span class="number">80</span> <span class="number">11</span> <span class="number">25</span> ec c0 a8 <span class="number">00</span> <span class="number">37</span> c0 a8</span><br><span class="line"><span class="number">00</span> <span class="number">01</span></span><br><span class="line"><span class="comment">//UDP首部</span></span><br><span class="line"><span class="number">05</span> d4 <span class="number">00</span> <span class="number">45</span> <span class="number">00</span> <span class="number">3f</span> ac <span class="number">40</span></span><br><span class="line"><span class="comment">//TFTP协议</span></span><br><span class="line"><span class="number">00</span> <span class="number">01</span> <span class="string">&#x27;c&#x27;</span><span class="string">&#x27;:&#x27;</span><span class="string">&#x27;\&#x27;&#x27;</span>q<span class="number">&#x27;</span></span><br><span class="line"><span class="string">&#x27;w&#x27;</span><span class="string">&#x27;e&#x27;</span><span class="string">&#x27;r&#x27;</span><span class="string">&#x27;q&#x27;</span><span class="string">&#x27;.&#x27;</span><span class="string">&#x27;q&#x27;</span><span class="string">&#x27;w&#x27;</span><span class="string">&#x27;e&#x27;</span><span class="number">00</span> <span class="string">&#x27;n&#x27;</span><span class="string">&#x27;e&#x27;</span><span class="string">&#x27;t&#x27;</span><span class="string">&#x27;a&#x27;</span><span class="string">&#x27;s&#x27;</span><span class="string">&#x27;c&#x27;</span><span class="string">&#x27;i&#x27;</span></span><br><span class="line"><span class="string">&#x27;i&#x27;</span><span class="number">00</span> <span class="string">&#x27;b&#x27;</span><span class="string">&#x27;l&#x27;</span><span class="string">&#x27;k&#x27;</span><span class="string">&#x27;s&#x27;</span><span class="string">&#x27;i&#x27;</span><span class="string">&#x27;z&#x27;</span><span class="string">&#x27;e&#x27;</span><span class="number">00</span> <span class="string">&#x27;5&#x27;</span><span class="string">&#x27;1&#x27;</span><span class="string">&#x27;2&#x27;</span><span class="number">00</span> <span class="string">&#x27;t&#x27;</span><span class="string">&#x27;i&#x27;</span></span><br><span class="line"><span class="string">&#x27;m&#x27;</span><span class="string">&#x27;e&#x27;</span><span class="string">&#x27;o&#x27;</span><span class="string">&#x27;u&#x27;</span><span class="string">&#x27;t&#x27;</span><span class="number">00</span> <span class="string">&#x27;1&#x27;</span><span class="string">&#x27;0&#x27;</span><span class="number">00</span> <span class="string">&#x27;t&#x27;</span><span class="string">&#x27;s&#x27;</span><span class="string">&#x27;i&#x27;</span><span class="string">&#x27;z&#x27;</span><span class="string">&#x27;e&#x27;</span><span class="number">00</span> <span class="string">&#x27;0&#x27;</span></span><br><span class="line"><span class="comment">//TFTP是基于文本的协议，各字段之间用字节0分隔，开头的00 01表示请求读取一个文件，接下来的各字段是：</span></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202208021707586.png" alt="image-20220802170722364"></p>
<p>wireshark抓包</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202208021723238.png" alt="image-20220802172344382"></p>
<h4 id="udp连接机制"><a href="#udp连接机制" class="headerlink" title="udp连接机制"></a>udp连接机制</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202208021713870.png" alt="image-20220802171337336"></p>
<p>服务器在特定端口上收到UDP 数据包时，将通过以下两个步骤进行响应</p>
<ul>
<li>服务器首先检查是否有任何当前侦听指定端口请求的程序正在运行。</li>
<li>如果该端口上没有程序正在接收数据包，则服务器将以 ICMP (ping) 数据包作为响应，以告知发送方目标不可达。</li>
</ul>
<p>导致&gt;&gt;<strong>UDP洪水攻击</strong>     解决方案:大多数操作系统限制ICMP 数据包的响应速率</p>
<h3 id="TCP数据流格式"><a href="#TCP数据流格式" class="headerlink" title="TCP数据流格式"></a>TCP数据流格式</h3><p>稳定的, 安全的, 可靠的    <a href="#tcp%E5%8E%9F%E7%90%86">TCP原理跳转</a></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202208021713235.png" alt="image-20220802171257567"></p>
<ul>
<li>TCP协议用于<strong>1对1</strong>，即不能用于基于广播和多播的应用程序</li>
<li>TCP连接双方的<strong>收发数据次数不一定相同</strong>，即发送多次的数据包，可能会被对方1次全部接收</li>
<li>TCP在发送数据报后，必须得到接收方的应答，才认为传输成功，所以是<strong>可靠的</strong></li>
<li>TCP采用<strong>超时重传</strong>机制，超过时间没收到应答，就会重新发送。</li>
</ul>
<h4 id="tcp头部结构"><a href="#tcp头部结构" class="headerlink" title="tcp头部结构"></a>tcp头部结构</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202208021259348.png" alt="image-20220802125922013"></p>
<ul>
<li><p>16位端口号：指定数据从哪个端口来，发送到哪个端口。</p>
</li>
<li><p>32位序号：一次TCP通信中，每段字节流的编号。如A与B通信，第一个报文中，序列值被系统初始化为随机值，之后的传输（A到B），该序号值将被设定为初始值加上第一个字节在整个字节流中的偏移。</p>
</li>
<li><p>32位确认号：用作对另一方发送的TCP报文段的响应，其值是收到的TCP报文段序号值加一。</p>
</li>
<li><p>4位头部长度：标识该TCP头部有多少个32bit字（4字节），即最长为60字节</p>
</li>
<li><p>6位标志位：</p>
<p>​	- <code>URG</code>：标识紧急指针是否有效</p>
<p>​	- <code>ACK</code>：标识确认号是否有效</p>
<p>​	- <code>PSH</code>：提示接收端应立即从TCP接收缓存区中读走数据</p>
<p>​	- <code>RST</code>：表示要求对方重新建立连接</p>
<p>​	- <code>SYN</code>：表示请求建立一个连接</p>
<p>​	- <code>FIN</code>：通知对方关闭连接</p>
</li>
<li><p>16位窗口大小：TCP流量控制的一个手段，告诉对方本地TCP接收缓存区还能容纳多少字节的数据</p>
</li>
<li><p>16位校验和：由发送端填充，接收端对TCP报文段执行CRC算法校验数据是否损坏。</p>
</li>
<li><p>16位紧急指针：正的偏移量，它和序号字段的值相加表示最后一个紧急数据的下一个字节序号</p>
</li>
<li><p><a href="#%E5%85%B8%E5%9E%8B%E9%80%89%E9%A1%B9%E7%BB%93%E6%9E%84">选项</a>：为可变长的可选信息</p>
</li>
</ul>
<h5 id="典型选项结构"><a href="#典型选项结构" class="headerlink" title="典型选项结构"></a>典型选项结构</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202208021742241.png" alt="image-20220802174222523"></p>
<ul>
<li>kind：说明选项的类型</li>
<li>length：选项的总长度</li>
<li>info：选项的具体信息</li>
</ul>
<p>常见TCP的7种选项：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202208021743928.png" alt="image-20220802174327208"></p>
<p>kind的常见类型解释</p>
<ol>
<li>kind&#x3D;0：选项表结束</li>
<li>kind&#x3D;1：空操作，一般用于将TCP选项的总长度填充为4字节的整数倍</li>
<li>kind&#x3D;2：最大报文段长度选项，初次连接，双方通过此选项协商最大报文长度，TCP通常设置此为MTU-40字节，避免被分片</li>
<li>kind&#x3D;3：窗口扩大因子选项。TCP头部通知窗口为N，扩大因子为M，则实际接收通知窗口为N*(2的M次方)，且只能出现在同步报文段中，否则被忽略</li>
<li>kind&#x3D;4：选择性确定（Selective Acknowledge，SACK）。如果某个TCP报文段丢失，则TCP模块会重传最后被确认的TCP报文段后续所有报文段。而该选项则可解决这种问题。</li>
<li>kind&#x3D;5：SACK实际工作选项。告诉发送端本端已经收到的数据块，从而让发送端只发送丢失的数据</li>
<li>kind&#x3D;8：时间戳。提供通信双方较为精确的回路时间。</li>
</ol>
<h4 id="TCP连接机制"><a href="#TCP连接机制" class="headerlink" title="TCP连接机制"></a>TCP连接机制</h4><p>&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</p>
<p>tcp协议未完待续</p>
<p>&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</p>
<h2 id="ip地址转换"><a href="#ip地址转换" class="headerlink" title="ip地址转换"></a>ip地址转换</h2><p>下面函数名的理解:</p>
<p>p-&gt;表示点分十进制的字符串形式<br>to-&gt;到<br>n-&gt;表示network网络</p>
<h3 id="inet-pton函数"><a href="#inet-pton函数" class="headerlink" title="inet_pton函数"></a>inet_pton函数</h3><p>将字符串形式的点分十进制IP转换为大端模式的网络IP(整形4字节数)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span>;</span><br><span class="line"><span class="comment">//inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;serv.sin_addr.s_addr);</span></span><br></pre></td></tr></table></figure>

<p>参数说明:<br>        <code>af</code>: AF_INET或AF_INET6,分别对应ipv4和ipv6<br>        <code>src</code>: 字符串形式的点分十进制的IP地址<br>        <code>dst</code>: 存放转换后的变量的地址</p>
<h3 id="inet-ntop函数"><a href="#inet-ntop函数" class="headerlink" title="inet_ntop函数"></a>inet_ntop函数</h3><p>网络IP转换为字符串形式的点分十进制的IP</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, <span class="type">socklen_t</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p>参数说明:<br>        <code>af</code>: AF_INET<br>        <code>src</code>: 网络的整形的IP地址<br>        <code>dst</code>: 转换后的IP地址,一般为字符串数组<br>        <code>size</code>: dst的长度<br>返回值:<br>        成功–返回指向dst的指针<br>        失败–返回NULL, 并设置errno</p>
<p>另外有两个函数,与上面二者类似,仅有如下不同:<code>inet_aton</code>和<code>inet_ntoa</code>只支持ipv4类型的地址转换,而<code>inet_pton</code>和<code>inet_ntop</code>支持ipv4和ipv6类型的地址转换</p>
<h2 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h2><ul>
<li>大端: 低位地址存放高位数据, 高位地址存放低位数据(网络字节序)</li>
<li>小端: 低位地址存放低位数据, 高位地址存放高位数据</li>
</ul>
<p>数据的高低位:右边为低位,左边为高位,<code>E.g.  0x1234,34为低位数据,12为高位数据</code></p>
<p>网络传输用的是大端法, 如果机器用的是小端法, 则需要进行大小端的转换.</p>
<h3 id="大小端转换"><a href="#大小端转换" class="headerlink" title="大小端转换"></a>大小端转换</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line">       <span class="type">uint32_t</span> <span class="title function_">htonl</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span>;</span><br><span class="line">       <span class="type">uint16_t</span> <span class="title function_">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span>;</span><br><span class="line">       <span class="type">uint32_t</span> <span class="title function_">ntohl</span><span class="params">(<span class="type">uint32_t</span> netlong)</span>;</span><br><span class="line">       <span class="type">uint16_t</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">uint16_t</span> netshort)</span>;</span><br><span class="line"><span class="comment">//函数名的h表示主机host, n表示网络network, s表示short, l表示long</span></span><br></pre></td></tr></table></figure>

<p>上述的几个函数, 如果本来不需要转换函数内部就不会做转换.</p>
<h2 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h2><ul>
<li>同步 : 发送一个请求,等待返回,然后再发送下一个请求</li>
<li>异步 : 发送一个请求,不等待返回,随时可以再发送下一个请求</li>
</ul>
<p>同步可以**避免出现<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%AD%BB%E9%94%81&spm=1001.2101.3001.7020">死锁</a>**，读脏数据的发生，一般共享某一资源的时候用，如果每个人都有修改权限，同时修改一个文件，有可能使一个人读取另一个人已经删除的内容，就会出错，同步就会按顺序来修改。</p>
<p>异步则是可以<strong>提高效率</strong>了，现在cpu都是双核，四核，异步处理的话可以同时做多项工作，当然必须保证是可以并发处理的。</p>
<p><strong>实际项目开发中会优先选择异步交互模型</strong></p>
<p>四种情况</p>
<ul>
<li>同步非阻塞: 若客户端发送数据之后, read函数不阻塞(文件描述符设置为非阻塞,但是一直循环read空转) </li>
<li>同步阻塞:客户端发送数据之后, read数据, 若对方不发送应答数据, 就一直阻塞.</li>
<li>异步阻塞: 比如: select poll epoll, 若没有事件发生, select 或者epoll可以一直阻塞</li>
<li>异步非阻塞: 比如: 将epoll设置非阻塞, 不管有没有事件发生都会立刻返回</li>
</ul>
<p>异步需要有第三方参与通知才能实现</p>
<h2 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h2><p>阻塞和非阻塞的概念描述的是用户线程调用内核IO操作的方式:</p>
<ul>
<li>阻塞是指IO操作需要彻底完成后才返回到用户空间</li>
<li>非阻塞是指IO操作被调用后立即返回给用户一个状态值,无需等到IO操作彻底完成</li>
</ul>
<h2 id="DNS解析过程"><a href="#DNS解析过程" class="headerlink" title="DNS解析过程"></a>DNS解析过程</h2><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202306061126867.png" alt="image-20230606112624290" style="zoom:67%;" />

<ol>
<li><p>在浏览器中输入<a target="_blank" rel="noopener" href="http://www.magedu.com域名,操作系统会先检查自己本地的hosts文件是否有这个网址映射关系,如果有,就先调用这个ip地址映射,完成域名解析./">www.magedu.com域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。</a></p>
</li>
<li><p>如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。</p>
<p>Windows和Linux系统都会在本地缓存dns解析的记录，提高速度。</p>
</li>
<li><p>如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找 TCP&#x2F;IP 参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。</p>
</li>
<li><p>如果要查询的域名，不由本地DNS服务器区域解析，但该DNS服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。</p>
</li>
<li><p>如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（没有设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责 .com域的这台服务器。这台负责 .com域的服务器收到请求后，如果自己无法解析，它就会找一个管理 .com域的下一级DNS服务器地址(magedu.com)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找magedu.com域服务器，重复上面的动作进行查询，直至找到<a target="_blank" rel="noopener" href="http://www.magedu.com主机./">www.magedu.com主机。</a></p>
</li>
<li><p>如果用的是转发模式（设置转发器），此DNS服务器就会把请求转发至上一级ISP DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。</p>
</li>
</ol>
<p>域名解析服务器</p>
<ul>
<li>Pod DNS+:<ul>
<li>首选：119.29.29.29</li>
<li>备选：182.254.116.116</li>
</ul>
</li>
<li>114DNS:<ul>
<li>首选：114.114.114.114</li>
<li>备选：114.114.114.115</li>
</ul>
</li>
<li>阿里 AliDNS:<ul>
<li>首选：223.5.5.5</li>
<li>备选：223.6.6.6</li>
</ul>
</li>
</ul>
<p><strong>hosts文件</strong>:存储的是域名和IP的对应关系</p>
<ul>
<li>windows目录: <code>C:\Windows\System32\drivers\etc\hosts</code></li>
<li>mac&#x2F;linux目录:<code>/etc/hosts</code></li>
</ul>
<h2 id="URL和URN"><a href="#URL和URN" class="headerlink" title="URL和URN"></a>URL和URN</h2><ul>
<li><p><strong>URL</strong>（Uniform Resource Locator）: 统一资源定位符</p>
<p>表示资源位置的字符串:<code>协议://IP地址/路径和文件名</code></p>
<ul>
<li><code>http://www.ietf.org/rfc/rfc2396.txt</code></li>
<li><code>telnet://192.0.2.16:80/</code></li>
<li><code>ftp://ftp.is.co.za/rfc/rfc1808.txt</code></li>
</ul>
</li>
<li><p><strong>URN</strong>（Uniform Resource Name）: 统一资源名称</p>
<p>P2P下载中使用的磁力链接</p>
</li>
<li><p><strong>URI</strong>（Uniform Resource Identifier）: 统一资源标识符</p>
<p>是一个紧凑的字符串用来标示抽象或物理资源, URL是URI的一种</p>
<p>让URI能成为URL的当然就是那个“访问机制”，“网络位置”。e.g. <code>http://</code> or <code>ftp://</code> </p>
<p>URI可以没有协议,没有地址(IP&#x2F;域名)</p>
</li>
</ul>
<p><strong>URI和URL的关系</strong></p>
<ul>
<li><p>从字面的包含关系上来说,URI包含URL</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202306061150237.png" alt="image-20230606115008324" style="zoom: 33%;" />
</li>
<li><p>字符串长度来说,URL包含URI</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202306061200249.png" alt="image-20230606120007734" style="zoom:33%;" />

<p>红色部分+绿色部分 &#x3D; URL</p>
<p>绿色部分 &#x3D; URI</p>
</li>
</ul>
<p>URL的静态请求:  <code>http://localhost/login.html</code></p>
<p>URL的动态请求:  <code>http://localhost/login?user=zhang&amp;age=12</code></p>
<ul>
<li><code>http</code>:协议</li>
<li><code>localhost</code>:域名</li>
<li><code>/login</code>:服务器端要处理的指令(包括这里往下的部分都存在于http协议中的请求行的第二部分请求资源中)</li>
<li><code>?</code>:连接符,后面的内容是客户端给服务端提交的数据</li>
<li><code>&amp;</code>:分隔符</li>
</ul>
<h2 id="正向-反向代理"><a href="#正向-反向代理" class="headerlink" title="正向&#x2F;反向代理"></a>正向&#x2F;反向代理</h2><ul>
<li>正向代理是为客户端服务的</li>
<li>反向代理是为服务端服务的</li>
</ul>
<h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202306051556419.png" alt="image-20230605155633306" style="zoom:50%;" />

<p>正向代理是位于客户端和原始服务器之间的服务器，为了能够从原始服务器获取请求的内容，客户端需要将请求发送给代理服务器，然后再由代理服务器将请求转发给原始服务器，原始服务器接受到代理服务器的请求并处理，然后将处理好的数据转发给代理服务器，之后再由代理服务器转发发给客户端，完成整个请求过程。</p>
<p><strong>正向代理的典型用途就是为在防火墙内的局域网客户端提供访问Internet的途径</strong> , 比如:</p>
<ul>
<li>学校的局域网</li>
<li>单位局域网访问外部资源</li>
</ul>
<h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>反向代理方式是指代理原始服务器来接受来自Internet的链接请求，然后将请求转发给内部网络上的原始服务器，并将从原始服务器上得到的结果转发给Internet上请求数据的客户端。那么顾名思义，反向代理就是位于Internet和原始服务器之间的服务器，对于客户端来说就表现为一台服务器，客户端所发送的请求都是直接发送给反向代理服务器，然后由反向代理服务器统一调配</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202306051702967.png" alt="image-20230605170249203" style="zoom: 50%;" />



<h2 id="防盗链"><a href="#防盗链" class="headerlink" title="防盗链"></a>防盗链</h2><blockquote>
<p><strong>盗链</strong> 是指服务提供商自己不提供服务的内容，通过技术手段绕过其它有利益的最终用户界面（如广告），直接在自己的网站上向最终用户提供其它服务提供商的服务内容，骗取最终用户的浏览和点击率。受益者不提供资源或提供很少的资源，而真正的服务提供商却得不到任何的收益。</p>
</blockquote>
<h1 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h1><p>传统的进程间通信借助内核提供的IPC机制进行, 但是只能限于本机通信, 若要跨机通信, 就必须使用网络通信.( 本质上借助内核-内核提供了socket伪文件的机制实现通信—-实际上是使用文件描述符), 这就需要用到内核提供给用户的socket API函数库.因为socket的伪文件机制, 所以可以使用文件描述符相关的函数read write</p>
<p>如下图, 一个文件描述符操作两个缓冲区, 这点跟管道是不同的, 管道是两个文件描述符操作一个内核缓冲区.</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202208031101069.png" alt="image-20220803110150586"></p>
<h2 id="相关结构体"><a href="#相关结构体" class="headerlink" title="相关结构体"></a>相关结构体</h2><p>socket编程用到的重要的结构体:<code>struct sockaddr</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202208031146839.png" alt="image-20220803114648128"></p>
<p>sockaddr结果参数使用sockaddr_in结构体变量来填充就可以了,内部划分得更细致</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//struct sockaddr结构说明:</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">        <span class="type">sa_family_t</span> sa_family;</span><br><span class="line">        <span class="type">char</span>     sa_data[<span class="number">14</span>];</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//struct sockaddr_in结构:</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">         <span class="type">sa_family_t</span>    sin_family; <span class="comment">/* address family: AF_INET */</span></span><br><span class="line">         <span class="type">in_port_t</span>      sin_port;   <span class="comment">/* port in network byte order */</span></span><br><span class="line">         <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>   <span class="comment">/* internet address */</span></span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Internet address. */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">         <span class="type">uint32_t</span>  s_addr;     <span class="comment">/* address in network byte order */</span></span><br><span class="line">   &#125;;	 <span class="comment">//网络字节序IP--大端模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过man 7 ip可以查看相关说明</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>sockaddr_in</strong>在<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%A4%B4%E6%96%87%E4%BB%B6&spm=1001.2101.3001.7020">头文件</a><code>#include&lt;netinet/in.h&gt;或#include &lt;arpa/inet.h&gt;</code>中定义</p>
<p>有时候没有包括#include &lt;netinet&#x2F;in.h&gt; ，而包括#include &lt;arpa&#x2F;inet.h&gt;，在server端和client端一般要将端口号从主机序转换成网络序，那么需要htons( )函数就需要头文件 #include &lt;arpa&#x2F;inet.h&gt;，就自然不用另一个了。可以通过编译啦。</p>
<p>查询函数所需的头文件用 <code>man htons</code>命令</p>
<p>但是有些系统是需要netinet&#x2F;in.h而不能是arpa&#x2F;inet.h</p>
</blockquote>
<h2 id="主要函数"><a href="#主要函数" class="headerlink" title="主要函数"></a>主要函数</h2><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202404071654906.png" alt="socket" style="zoom: 25%;" />

<ul>
<li><a href="#socket%E5%87%BD%E6%95%B0">socket函数</a></li>
<li><a href="#bind%E5%87%BD%E6%95%B0">bind函数</a></li>
<li><a href="#listen%E5%87%BD%E6%95%B0">listen函数</a></li>
<li><a href="#accept%E5%87%BD%E6%95%B0">accept函数</a></li>
<li><a href="#connect%E5%87%BD%E6%95%B0">connect函数</a></li>
<li><a href="#%E8%AF%BB%E5%86%99%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0">读写相关函数</a></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202208031456553.png" alt="image-20220803145641364"></p>
<h3 id="socket函数"><a href="#socket函数" class="headerlink" title="socket函数"></a>socket函数</h3><p>创建socket</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br></pre></td></tr></table></figure>

<p>参数说明:<br>        <code>domain</code>: 协议版本<br>                <code>AF_INET</code> IPV4<br>                <code>AF_INET6</code> IPV6<br>                <code>AF_UNIX</code>  <code>AF_LOCAL</code>本地套接字使用<br>        <code>type</code>:协议类型<br>                <code>SOCK_STREAM</code> 流式, 默认使用的协议是TCP协议<br>                <code>SOCK_DGRAM</code>  报式, 默认使用的是UDP协议<br>        <code>protocal</code>:<br>                一般填0, 表示使用对应类型的默认协议.<br>返回值:<br>        成功: 返回一个大于0的文件描述符<br>        失败: 返回-1, 并设置errno</p>
<p>当调用socket函数以后, <strong>返回一个文件描述符, 内核会提供与该文件描述符相对应的读和写缓冲区</strong>, <strong>同时还有两个队列, 分别是请求连接队列和已连接队列.</strong></p>
<h3 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h3><p>将socket文件描述符和IP,PORT绑定</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure>

<p>参数说明:<br>        <code>socket</code>: 调用socket函数返回的文件描述符<br>        <code>addr</code>: 本地服务器的IP地址和PORT, </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv</span>;</span></span><br><span class="line">serv.sin_family = AF_INET;</span><br><span class="line">serv.sin_port = htons(<span class="number">8888</span>);</span><br><span class="line"><span class="comment">//serv.sin_addr.s_addr = htonl(INADDR_ANY);</span></span><br><span class="line"><span class="comment">//INADDR_ANY: 表示使用本机任意有效的可用IP(服务器可以插狠多张网卡)</span></span><br><span class="line">inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;serv.sin_addr.s_addr);</span><br></pre></td></tr></table></figure>

<p>​		<code>addrlen</code>: addr变量的占用的内存大小<br>返回值:<br>​		成功: 返回0<br>​		失败: 返回-1, 并设置errno</p>
<h3 id="listen函数"><a href="#listen函数" class="headerlink" title="listen函数"></a>listen函数</h3><p>将套接字由主动态变为被动态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br></pre></td></tr></table></figure>

<p>参数说明:<br>        <code>sockfd</code>: 调用socket函数返回的文件描述符<br>        <code>backlog</code>: 同时请求连接的最大个数(还未建立连接) ,最大是128<br>返回值:<br>        成功: 返回0<br>        失败: 返回-1, 并设置errno</p>
<h3 id="accept函数"><a href="#accept函数" class="headerlink" title="accept函数"></a>accept函数</h3><p>获得一个连接, 若当前没有连接则会阻塞等待.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;	</span><br></pre></td></tr></table></figure>

<p>函数参数:<br>        <code>sockfd</code>: 调用socket函数返回的文件描述符<br>        <code>addr</code>: <strong>传出参数</strong>, <strong>保存客户端的地址信息</strong><br>        <code>addrlen</code>: 传入传出参数,  addr变量所占内存空间大小<br>返回值:<br>        成功: 返回一个新的<strong>文件描述符,用于和客户端通信</strong><br>        失败: 返回-1, 并设置errno值.</p>
<p>accept函数是一个<strong>阻塞函数</strong>, 若没有新的连接请求, 则一直阻塞.<br>从已连接队列中获取一个新的连接, 并获得一个新的文件描述符, 该文件描述符用于和客户端通信.  (<strong>内核会负责将请求队列中的连接拿到已连接队列中</strong>)</p>
<h3 id="connect函数"><a href="#connect函数" class="headerlink" title="connect函数"></a>connect函数</h3><p>连接服务器</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure>

<p>函数参数:  <em>(和bind函数参数类型一样)</em><br>        <code>sockfd</code>: 调用socket函数返回的文件描述符<br>        <code>addr</code>: 服务端的地址信息<br>        <code>addrlen</code>: addr变量的内存大小<br>返回值:<br>        成功: 返回0<br>        失败: 返回-1, 并设置errno值</p>
<p>errno:</p>
<ul>
<li><code>EACCES</code>：拒绝连接。通常出现在尝试连接受保护的端口（如1023以下的端口）时。</li>
<li><code>EADDRINUSE</code>：地址已经被使用。通常出现在本地地址或远程地址已经被其他进程占用时。</li>
<li><code>EADDRNOTAVAIL</code>：地址不可用。通常出现在尝试连接不存在的本地地址或远程地址时。</li>
<li><code>EAGAIN</code>或<code>EWOULDBLOCK</code>：非阻塞Socket正在尝试连接，但连接还没有完成。这是一个临时性错误，应该重试connect操作。</li>
<li><code>EALREADY</code> ：Socket已经处于连接状态。</li>
<li><code>EBADF</code>：无效的Socket文件描述符。</li>
<li><code>ECONNREFUSED</code>：连接被拒绝。通常出现在远程主机处于关闭状态、没有进程在监听指定端口、防火墙屏蔽了连接请求等情况下。</li>
<li><code>EFAULT</code>：指向sockaddr结构体的指针无效。</li>
<li>**<code>EINPROGRESS</code>**：非阻塞Socket正在尝试连接，但连接还没有完成。这是一个临时性错误，应该使用select函数等待Socket变为可写状态后再进行下一步操作。</li>
<li><code>EINTR</code> ：connect操作被信号中断，应该重试connect操作。</li>
<li><code>EISCONN</code> ：Socket已经处于连接状态。</li>
<li><code>ENETUNREACH</code> ：网络不可达。通常出现在远程主机处于离线状态、路由不可达等情况下。</li>
<li><code>ENOTSOCK</code> ：文件描述符不是一个Socket。</li>
<li><code>ETIMEDOUT</code> ：连接超时。通常出现在远程主机未响应连接请求、网络传输故障等情况下。</li>
</ul>
<blockquote>
<p>如果远程主机没有响应，或者网络故障等情况下，阻塞connect函数会导致程序长时间处于阻塞状态，可能会导致程序无响应或者崩溃。此外，如果在网络连接过程中出现了异常或错误，阻塞connect函数可能会直接返回错误程序需要通过错误处理机制进行处理。</p>
<p>相比之下，非阻塞connect和select的方式可以通过监控连接状态，及时处理连接异常，收到连接成功后再进行后续的操作，从而避免了阻塞和崩溃等问题的出现。超时限制也可以避免长时间等待,因此，使用非阻塞connect和select的方式可以提高程序的健壮性和稳定性。</p>
</blockquote>
<h3 id="读写相关函数"><a href="#读写相关函数" class="headerlink" title="读写相关函数"></a>读写相关函数</h3><p>读取数据和发送数据:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">send</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;	</span><br><span class="line"><span class="comment">//对应recv和send这两个函数flags直接填0就可以了.</span></span><br><span class="line"><span class="comment">//阻塞状态下,read返回0表示客户端断开连接,读取完毕</span></span><br><span class="line"><span class="comment">//flags也可以填写MSG_PEEK,MSG_PEEK标志可以用来读取套接字接收队列中可读的数据，一些情况会用到它，比如为了避免不阻塞而先检查套接字接收队列中可读的数据长度，再采取相应操作。</span></span><br></pre></td></tr></table></figure>

<p>注意: 如果写<strong>缓冲区已满, write也会阻塞</strong>, read读操作的时候, 若<strong>读缓冲区没有数据会引起阻塞</strong>.</p>
<blockquote>
<p>在进行 socket 编程中，send 函数用于向连接的另一端发送数据。当调用 send 函数后，数据并不会立即发送出去，而需要等待网络连接稳定，缓冲区可用等条件满足后才会实际发送数据。这时候，如果出现网络故障或者对方出现延迟，就可能导致 send 发送数据失败，并且可能陷入阻塞状态，导致程序无法继续执行。</p>
<p>因此，为了避免 send 函数陷入阻塞状态，我们通常使用 select 函数设置发送数据超时时间，如果在规定时间内没有发送成功，则认为发送失败并中止发送。这其实也是一种优化策略，如果继续等待缓冲区可用或者网络连接稳定，可能会导致程序长时间无响应，用户体验也会变得很差。</p>
<p>另外，通过使用 select 函数进行超时检测，可以减少 CPU 的使用率，避免空等待占用过多的系统资源，提高程序的并发性能和稳定性。</p>
<p>总之，使用 select 对 send 函数进行超时检测，是一种优化策略，可以避免 send 函数陷入阻塞状态，提高程序的响应速度和稳定性。</p>
<p>read函数同理,同样需要超时检测优化</p>
</blockquote>
<h4 id="确保write和read发送数据完全"><a href="#确保write和read发送数据完全" class="headerlink" title="确保write和read发送数据完全"></a>确保write和read发送数据完全</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* writen - 发送固定字节数数据完全</span></span><br><span class="line"><span class="comment">* @buf: 发送缓冲区</span></span><br><span class="line"><span class="comment">* @count: 要读取的字节数</span></span><br><span class="line"><span class="comment">* 成功返回count，失败返回-1</span></span><br><span class="line"><span class="comment">* 类中变量 :  m_fd</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpSocket::writen</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *buf, <span class="type">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">size_t</span> nleft = count;</span><br><span class="line">	<span class="type">ssize_t</span> nwritten;</span><br><span class="line">	<span class="type">char</span> *bufp = (<span class="type">char</span>*)buf;</span><br><span class="line">	<span class="keyword">while</span> (nleft &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> ((nwritten = <span class="built_in">write</span>(m_socket, bufp, nleft)) &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (nwritten == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		bufp += nwritten;</span><br><span class="line">		nleft -= nwritten;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* readn - 读取固定字节数完全</span></span><br><span class="line"><span class="comment">* @fd: 文件描述符</span></span><br><span class="line"><span class="comment">* @buf: 接收缓冲区</span></span><br><span class="line"><span class="comment">* @count: 要读取的字节数</span></span><br><span class="line"><span class="comment">* 成功返回count，失败返回-1，读到EOF返回&lt;count</span></span><br><span class="line"><span class="comment">* 类中变量 :  m_fd</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpSocket::readn</span><span class="params">(<span class="type">void</span> *buf, <span class="type">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">size_t</span> nleft = count;</span><br><span class="line">	<span class="type">ssize_t</span> nread;</span><br><span class="line">	<span class="type">char</span> *bufp = (<span class="type">char</span>*)buf;</span><br><span class="line">	<span class="keyword">while</span> (nleft &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> ((nread = <span class="built_in">read</span>(m_socket, bufp, nleft)) &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> count - nleft;</span><br><span class="line">		bufp += nread;</span><br><span class="line">		nleft -= nread;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试工具"><a href="#测试工具" class="headerlink" title="测试工具"></a>测试工具</h2><h3 id="nc命令"><a href="#nc命令" class="headerlink" title="nc命令"></a><code>nc</code>命令</h3><p>以客户端的方式连接小工具</p>
<p>ubuntu系统安装方式: <code>sudo apt-get -y install netcat-traditional</code><br>$$<br>nc;;ip地址;端口号<br>$$<br>例如:  <code>nc  192.168.0.2  8888</code></p>
<p>作为服务端监听端口号:<br>$$<br>nc\ \ -l\ \ -p\ \ 端口号<br>$$<br>如: <code>nc -l -p 23456</code></p>
<p>对外开放23456端口: <code>nc -l 0.0.0.0 23456</code></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhaijiahui/p/9028402.html">nc命令其他功能参考</a></p>
<h3 id="netstat命令"><a href="#netstat命令" class="headerlink" title="netstat命令"></a><code>netstat</code>命令</h3><p>测试过程中可以使用<code>netstat</code>命令查看监听状态和连接状态<br>netstat命令: </p>
<ul>
<li><code>a</code>表示显示所有,</li>
<li><code>n</code>表示显示的时候以数字的方式来显示</li>
<li><code>p</code>表示显示进程信息(进程名和进程PID)</li>
</ul>
<p>一般用 <code>netstat -anp | grep 端口号</code>来查看该端口对应的连接情况</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202208051551664.jpeg" alt="截屏2022-08-05 15.51.04"></p>
<p><code>netstat -tunlp</code>命令查看网络连接情况,仅服务器</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202208051552433.jpeg" alt="截屏2022-08-05 15.49.14"></p>
<p><code>ESTABLISHED</code>表示链接建立了</p>
<p>mac下<code>netstat</code>命令为简化版,用<code>lsof</code>命令取而代之</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202208051556513.jpeg" alt="截屏2022-08-05 15.54.43"></p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="服务器开发流程"><a href="#服务器开发流程" class="headerlink" title="服务器开发流程"></a>服务器开发流程</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202208031456553.png" alt="image-20220803145641364"></p>
<ol>
<li><p>创建socket,返回一个文件描述符lfd – <a href="#socket%E5%87%BD%E6%95%B0"><code>socket()</code></a></p>
<p>   ​	– <strong>该文件描述符用于监听客户端连接</strong></p>
</li>
<li><p>将lfd和IP PORT进行绑定 – <a href="#bind%E5%87%BD%E6%95%B0"><code>bind()</code></a></p>
</li>
<li><p>将lfd由主动变为被动监听 – <a href="#listen%E5%87%BD%E6%95%B0"><code>listen()</code></a></p>
</li>
<li><p>接受一个新的连接,得到一个文件描述符  – <a href="#accept%E5%87%BD%E6%95%B0"><code>accept()</code></a></p>
<p>   ​	– <strong>该文件描述符是用于和客户端进行通信的</strong></p>
</li>
<li><p><a href="#%E8%AF%BB%E5%86%99%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0">读写</a></p>
</li>
<li><p>关闭文件描述符 – <code>close(lfd)   close(cfd)</code></p>
</li>
</ol>
<h3 id="客户端开发流程"><a href="#客户端开发流程" class="headerlink" title="客户端开发流程"></a>客户端开发流程</h3><ol>
<li><p>创建socket,返回一个文件描述符cfd  – <a href="#socket%E5%87%BD%E6%95%B0"><code>socket()</code></a></p>
<p>​	—该文件描述符是用于和服务端通信</p>
</li>
<li><p>连接服务器 –<a href="#connect%E5%87%BD%E6%95%B0"><code>connect()</code></a></p>
</li>
<li><p><a href="#%E8%AF%BB%E5%86%99%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0">读写</a></p>
</li>
<li><p>关闭文件描述符 – <code>close(fd)</code></p>
</li>
</ol>
<p>由于客户端不需要固定的端口号，因此不必调用<code>bind()</code>，客户端的端口号由内核自动分配。注意，客户端不是不允许调用<code>bind()</code>，只是没有必要调用<code>bind()</code>固定一个端口号，服务器也不是必须调用<code>bind()</code>，但如果服务器不调用<code>bind()</code>，内核会自动给服务器分配监听端口，每次启动服务器时端口号都不一样，客户端要连接服务器就会遇到麻烦。</p>
<h3 id="linux-Mac代码"><a href="#linux-Mac代码" class="headerlink" title="linux&#x2F;Mac代码"></a>linux&#x2F;Mac代码</h3><h4 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;lfd:&quot;</span>&lt;&lt;lfd&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv</span>;</span></span><br><span class="line">    bzero(&amp;serv,<span class="keyword">sizeof</span>(serv));</span><br><span class="line">    serv.sin_family = AF_INET;</span><br><span class="line">    serv.sin_port = htons(<span class="number">23456</span>);</span><br><span class="line">    serv.sin_addr.s_addr = htonl(INADDR_ANY);<span class="comment">//表示使用本地任意可用iP</span></span><br><span class="line">    bind(lfd,(sockaddr*)&amp;serv,<span class="keyword">sizeof</span>(serv));</span><br><span class="line">    </span><br><span class="line">    listen(lfd,<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;等待客户端链接...&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="type">int</span> fd =accept(lfd,<span class="literal">NULL</span>,<span class="literal">NULL</span>);<span class="comment">//不关心连接的对方客户端信息</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;客户端已链接&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//开始读写</span></span><br><span class="line">    <span class="comment">//char str[]=&quot;你好,世界!&quot;;</span></span><br><span class="line">    <span class="comment">//send(lfd,str,strlen(str)+1,0);</span></span><br><span class="line">    <span class="comment">//读数据</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="type">int</span> readSize = read(fd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;readSize:&quot;</span>&lt;&lt;readSize&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;buf:&quot;</span>&lt;&lt;buf&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭监听文件描述符和通信文件描述符</span></span><br><span class="line">    close(lfd);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>          <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;fd:&quot;</span>&lt;&lt;fd&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv</span>;</span></span><br><span class="line">    bzero(&amp;serv,<span class="keyword">sizeof</span>(serv));</span><br><span class="line">    serv.sin_family = AF_INET;</span><br><span class="line">    serv.sin_port = htons(<span class="number">23456</span>);</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;192.168.0.115&quot;</span>, &amp;serv.sin_addr.s_addr);</span><br><span class="line">    <span class="type">int</span> iRet = connect(fd,(sockaddr*)&amp;serv,<span class="keyword">sizeof</span>(serv));</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;connect iRet:&quot;</span>&lt;&lt;iRet&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">999</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    send(fd,<span class="string">&quot;hello world!&quot;</span>,<span class="built_in">strlen</span>(<span class="string">&quot;hello world!&quot;</span>)+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="windows代码"><a href="#windows代码" class="headerlink" title="windows代码"></a><a href="#https://blog.csdn.net/li_wei_quan/article/details/79665969">windows代码</a></h3><p>代码上和linux有一定差异,但差异基本不大</p>
<h4 id="服务器-1"><a href="#服务器-1" class="headerlink" title="服务器"></a>服务器</h4><ol>
<li>加载套接字库，创建套接字（WSAStartup()&#x2F;socket()）</li>
<li>绑定套接字到一个IP地址和一个端口上（bind()）</li>
<li>将套接字设置为监听模式等待连接请求（listen()）</li>
<li>请求到来后，接受连接请求，返回一个新的对应于此次连接的套接字（accept()）；</li>
<li>用返回的套接字和客户端进行通信（send()&#x2F;recv()）</li>
<li>返回，等待另一个连接请求；</li>
<li>关闭套接字，关闭加载的套接字库（closesocket()&#x2F;WSACleanup()）</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)    </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//初始化WSA    </span></span><br><span class="line">	WORD sockVersion = MAKEWORD(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">	WSADATA wsaData;</span><br><span class="line">	<span class="keyword">if</span> (WSAStartup(sockVersion, &amp;wsaData) != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建套接字    </span></span><br><span class="line">	SOCKET slisten = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">	<span class="keyword">if</span> (slisten == INVALID_SOCKET)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;socket error !&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//绑定IP和端口    </span></span><br><span class="line">	sockaddr_in <span class="built_in">sin</span>;</span><br><span class="line">	<span class="built_in">sin</span>.sin_family = AF_INET;</span><br><span class="line">	<span class="built_in">sin</span>.sin_port = htons(<span class="number">23456</span>);</span><br><span class="line">	<span class="built_in">sin</span>.sin_addr.S_un.S_addr = INADDR_ANY;</span><br><span class="line">	<span class="keyword">if</span> (bind(slisten, (LPSOCKADDR)&amp;<span class="built_in">sin</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>)) == SOCKET_ERROR)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;bind error !&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//开始监听    </span></span><br><span class="line">	<span class="keyword">if</span> (listen(slisten, <span class="number">5</span>) == SOCKET_ERROR)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;listen error !&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//循环接收数据    </span></span><br><span class="line">	SOCKET sClient;</span><br><span class="line">	sockaddr_in remoteAddr;</span><br><span class="line">	<span class="type">int</span> nAddrlen = <span class="keyword">sizeof</span>(remoteAddr);</span><br><span class="line">	<span class="type">char</span> revData[<span class="number">255</span>];</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;等待连接...\n&quot;</span>);</span><br><span class="line">		sClient = accept(slisten, (SOCKADDR *)&amp;remoteAddr, &amp;nAddrlen);</span><br><span class="line">		<span class="keyword">if</span> (sClient == INVALID_SOCKET)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;accept error !&quot;</span>);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;接受到一个连接：%s \r\n&quot;</span>, inet_ntoa(remoteAddr.sin_addr));</span><br><span class="line"></span><br><span class="line">		<span class="comment">//接收数据    </span></span><br><span class="line">		<span class="type">int</span> ret = recv(sClient, revData, <span class="number">255</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			revData[ret] = <span class="number">0x00</span>;</span><br><span class="line">			<span class="built_in">printf</span>(revData);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//发送数据    </span></span><br><span class="line">		<span class="type">const</span> <span class="type">char</span> * sendData = <span class="string">&quot;你好，TCP客户端！\n&quot;</span>;</span><br><span class="line">		send(sClient, sendData, <span class="built_in">strlen</span>(sendData), <span class="number">0</span>);</span><br><span class="line">		closesocket(sClient);</span><br><span class="line">	&#125;</span><br><span class="line">	closesocket(slisten);</span><br><span class="line">	WSACleanup();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h4><ol>
<li>加载套接字库，创建套接字（WSAStartup()&#x2F;socket()）</li>
<li>向服务器发出连接请求（connect()）</li>
<li>和服务器进行通信（send()&#x2F;recv()）</li>
<li>关闭套接字，关闭加载的套接字库（closesocket()&#x2F;WSACleanup()）</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;WINSOCK2.H&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;STDIO.H&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ws2_32.lib&quot;</span>)  </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	WORD sockVersion = MAKEWORD(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">	WSADATA data;</span><br><span class="line">	<span class="keyword">if</span> (WSAStartup(sockVersion, &amp;data) != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		SOCKET sclient = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">		<span class="keyword">if</span> (sclient == INVALID_SOCKET)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; WSAGetLastError() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;invalid socket!&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		sockaddr_in serAddr;</span><br><span class="line">		serAddr.sin_family = AF_INET;</span><br><span class="line">		serAddr.sin_port = htons(<span class="number">23456</span>);</span><br><span class="line">		serAddr.sin_addr.S_un.S_addr = inet_addr(<span class="string">&quot;192.168.0.115&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (connect(sclient, (sockaddr *)&amp;serAddr, <span class="keyword">sizeof</span>(serAddr)) == SOCKET_ERROR)</span><br><span class="line">		&#123;  <span class="comment">//连接失败   </span></span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; WSAGetLastError() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;connect error !&quot;</span>);</span><br><span class="line">			closesocket(sclient);</span><br><span class="line">			getchar();</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">string</span> data;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; data;</span><br><span class="line">		<span class="type">const</span> <span class="type">char</span> * sendData;</span><br><span class="line">		sendData = data.c_str();   <span class="comment">//string转const char*   </span></span><br><span class="line">								   <span class="comment">//char * sendData = &quot;你好，TCP服务端，我是客户端\n&quot;;  </span></span><br><span class="line">		send(sclient, sendData, <span class="built_in">strlen</span>(sendData), <span class="number">0</span>);</span><br><span class="line">		<span class="comment">//send()用来将数据由指定的socket传给对方主机  </span></span><br><span class="line">		<span class="comment">//int send(int s, const void * msg, int len, unsigned int flags)  </span></span><br><span class="line">		<span class="comment">//s为已建立好连接的socket，msg指向数据内容，len则为数据长度，参数flags一般设0  </span></span><br><span class="line">		<span class="comment">//成功则返回实际传送出去的字符数，失败返回-1，错误原因存于error   </span></span><br><span class="line">		<span class="type">char</span> recData[<span class="number">255</span>];</span><br><span class="line">		<span class="type">int</span> ret = recv(sclient, recData, <span class="number">255</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			recData[ret] = <span class="number">0x00</span>;</span><br><span class="line">			<span class="built_in">printf</span>(recData);</span><br><span class="line">		&#125;</span><br><span class="line">		closesocket(sclient);</span><br><span class="line">	&#125;</span><br><span class="line">	WSACleanup();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="网络开发的注意点及完整案例"><a href="#网络开发的注意点及完整案例" class="headerlink" title="网络开发的注意点及完整案例"></a>网络开发的注意点及完整案例</h2><p>当read读文件描述符为非阻塞状态的时候,若对方没有发送数据,会立刻返回, <code>errno</code>设置为 <code>EAGAIN</code>,这个错误我们要忽略.</p>
<h3 id="防止阻塞被信号打断"><a href="#防止阻塞被信号打断" class="headerlink" title="防止阻塞被信号打断"></a>防止阻塞被信号打断</h3><p>像<code>accept</code>，<code>read</code>, <code>write</code> 这样的能够引起阻塞的函数，<strong>若被信号打断，由于信号的优先级较高, 会优先处理信号, 信号处理完成后，会使accept或者read解除阻塞, 然后返回, 此时返回值为 -1，设置errno&#x3D;EINTR;errno&#x3D;ECONNABORTED表示连接被打断,异常.</strong></p>
<p>阻塞函数在阻塞期间若收到信号,会被信号中断,errno设置为EINTR,这个错误不应该被视为错误.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">perr_exit</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line">	perror(s);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Accept</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> sockaddr *sa, <span class="type">socklen_t</span> *salenptr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line">	<span class="keyword">if</span> ((n = accept(fd, sa, salenptr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((errno == ECONNABORTED) || (errno == EINTR))</span><br><span class="line">			<span class="keyword">goto</span> again;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			perr_exit(<span class="string">&quot;accept error&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Bind</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *sa, <span class="type">socklen_t</span> salen)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((n = bind(fd, sa, salen)) &lt; <span class="number">0</span>)</span><br><span class="line">		perr_exit(<span class="string">&quot;bind error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Connect</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *sa, <span class="type">socklen_t</span> salen)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((n = connect(fd, sa, salen)) &lt; <span class="number">0</span>)</span><br><span class="line">		perr_exit(<span class="string">&quot;connect error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Listen</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> backlog)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((n = listen(fd, backlog)) &lt; <span class="number">0</span>)</span><br><span class="line">		perr_exit(<span class="string">&quot;listen error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Socket</span><span class="params">(<span class="type">int</span> family, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((n = socket(family, type, protocol)) &lt; <span class="number">0</span>)</span><br><span class="line">		perr_exit(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *ptr, <span class="type">size_t</span> nbytes)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">ssize_t</span> n;</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line">	<span class="keyword">if</span> ( (n = read(fd, ptr, nbytes)) == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">			<span class="keyword">goto</span> again;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//管道写满了,也会阻塞</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> nbytes)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">ssize_t</span> n;</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line">	<span class="keyword">if</span> ( (n = write(fd, ptr, nbytes)) == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">			<span class="keyword">goto</span> again;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Close</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">	<span class="keyword">if</span> ((n = close(fd)) == <span class="number">-1</span>)</span><br><span class="line">		perr_exit(<span class="string">&quot;close error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*参三: 应该读取的字节数*/</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Readn</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *vptr, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">size_t</span>  nleft;              <span class="comment">//usigned int 剩余未读取的字节数</span></span><br><span class="line">	<span class="type">ssize_t</span> nread;              <span class="comment">//int 实际读到的字节数</span></span><br><span class="line">	<span class="type">char</span>   *ptr;</span><br><span class="line"></span><br><span class="line">	ptr = (<span class="type">char</span>*)vptr;</span><br><span class="line">	nleft = n;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (nleft &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((nread = read(fd, ptr, nleft)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">				nread = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		nleft -= nread;</span><br><span class="line">		ptr += nread;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n - nleft;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Writen</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *vptr, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">size_t</span> nleft;</span><br><span class="line">	<span class="type">ssize_t</span> nwritten;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *ptr;</span><br><span class="line"></span><br><span class="line">	ptr = (<span class="type">const</span> <span class="type">char</span>*)vptr;</span><br><span class="line">	nleft = n;</span><br><span class="line">	<span class="keyword">while</span> (nleft &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> ( (nwritten = write(fd, ptr, nleft)) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nwritten &lt; <span class="number">0</span> &amp;&amp; errno == EINTR)</span><br><span class="line">				nwritten = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		nleft -= nwritten;</span><br><span class="line">		ptr += nwritten;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">my_read</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> read_cnt;</span><br><span class="line">	<span class="type">static</span> <span class="type">char</span> *read_ptr;</span><br><span class="line">	<span class="type">static</span> <span class="type">char</span> read_buf[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (read_cnt &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">again:</span><br><span class="line">		<span class="keyword">if</span> ( (read_cnt = read(fd, read_buf, <span class="keyword">sizeof</span>(read_buf))) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">				<span class="keyword">goto</span> again;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (read_cnt == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		read_ptr = read_buf;</span><br><span class="line">	&#125;</span><br><span class="line">	read_cnt--;</span><br><span class="line">	*ptr = *read_ptr++;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个个字符读,效率不行</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Readline</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *vptr, <span class="type">size_t</span> maxlen)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">ssize_t</span> n, rc;</span><br><span class="line">	<span class="type">char</span>    c, *ptr;</span><br><span class="line"></span><br><span class="line">	ptr = (<span class="type">char</span>*)vptr;</span><br><span class="line">	<span class="keyword">for</span> (n = <span class="number">1</span>; n &lt; maxlen; n++) &#123;</span><br><span class="line">		<span class="keyword">if</span> ( (rc = my_read(fd, &amp;c)) == <span class="number">1</span>) &#123;</span><br><span class="line">			*ptr++ = c;</span><br><span class="line">			<span class="keyword">if</span> (c  == <span class="string">&#x27;\n&#x27;</span>)<span class="comment">//结束标识为\n</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">			*ptr = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	*ptr  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">tcp4bind</span><span class="params">(<span class="type">short</span> port,<span class="type">const</span> <span class="type">char</span> *IP)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="type">int</span> lfd = Socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    bzero(&amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    <span class="keyword">if</span>(IP == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">//如果这样使用 0.0.0.0,任意ip将可以连接</span></span><br><span class="line">        serv_addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inet_pton(AF_INET,IP,&amp;serv_addr.sin_addr.s_addr) &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            perror(IP);<span class="comment">//转换失败</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port   = htons(port);</span><br><span class="line">    Bind(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    <span class="keyword">return</span> lfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>头文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __WRAP_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __WRAP_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">perr_exit</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Accept</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> sockaddr *sa, <span class="type">socklen_t</span> *salenptr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Bind</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *sa, <span class="type">socklen_t</span> salen)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Connect</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *sa, <span class="type">socklen_t</span> salen)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Listen</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> backlog)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Socket</span><span class="params">(<span class="type">int</span> family, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *ptr, <span class="type">size_t</span> nbytes)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> nbytes)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Readn</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *vptr, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Writen</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *vptr, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">my_read</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *ptr)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Readline</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *vptr, <span class="type">size_t</span> maxlen)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">tcp4bind</span><span class="params">(<span class="type">short</span> port,<span class="type">const</span> <span class="type">char</span> *IP)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="粘包"><a href="#粘包" class="headerlink" title="粘包"></a>粘包</h3><p>接收缓冲区中,对方发送数据连续发了两次,然后读数据的时候第一次没有读完,剩余的数据在第二次读走了,这种情况就属于粘包.</p>
<p><strong>粘包: 多次数据发送, 收尾相连, 接收端接收的时候不能正确区分第一次发送多少, 第二次发送多少.</strong></p>
<p>本质上是同一个ip端口两种业务的数据的区分问题.</p>
<p>解决方法:</p>
<ul>
<li><p>方案1: 包头+数据(最推荐)</p>
<p>如4位的数据长度+数据  ———–&gt; 00101234567890<br>其中0010表示数据长度, 1234567890表示10个字节长度的数据.<br>另外, 发送端和接收端可以协商更为复杂的报文结构, 这个报文结	构就相当于双方约定的一个协议.</p>
</li>
<li><p>方案2:添加结尾标记</p>
<p>如结尾最后一个字符为\n $等.</p>
</li>
<li><p>方案3:数据包定长</p>
<p>如发送方和接收方约定, 每次只发送128个字节的内容, 接收方接收定		长128个字节就可以了.</p>
</li>
</ul>
<p>学习目标</p>
<ul>
<li>熟练掌握TCP状态转换图</li>
<li>熟练掌握端口复用的方法</li>
<li>了解半关闭的概念和实现方式</li>
<li>了解多路IO转接模型</li>
<li>熟练掌握select函数的使用</li>
<li>熟练使用 <code>fd_set</code>相关函数的使用</li>
<li>能够编写select多路IO转接模型的代码</li>
</ul>
<h2 id="多并发服务器"><a href="#多并发服务器" class="headerlink" title="多并发服务器"></a>多并发服务器</h2><p>如何支持多个客户端   —  支持多并发的服务器</p>
<p>由于accept和read函数都会阻塞, 如当read的时候, 不能调用accept接受新的连接, 当accept阻塞等待的时候不能read读数据.</p>
<p>两种思路</p>
<ul>
<li><p><a href="#%E8%AE%BE%E7%BD%AE%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%AE%9E%E7%8E%B0">设置非阻塞</a></p>
<p>可以将accept和read函数设置为非阻塞, 调用fcntl函数可以将文件描述符设置为非阻塞, 让后再while循环中忙轮询.</p>
</li>
<li><p><a href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%AE%9E%E7%8E%B0">多进程</a></p>
<p>让父进程accept接受新连接, 然后fork子进程, 让子进程处理通信, 子进程处理完成后退出, 父进程使用SIGCHLD信号回收子进程.</p>
</li>
<li><p><a href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0">多线程</a></p>
<p>让主线程接受新连接, 让子线程处理与客户端通信; 使用多线程要将线程设置为分离属性, 让线程在退出之后自己回收资源.</p>
</li>
</ul>
<blockquote>
<p>在一次发送大量数据（超过发送缓冲区大小）的情况下，如果使用阻塞方式，程序一直阻塞，直到所有的数据都写入到缓冲区中。例如，要发送M字节数据，套接字发送缓冲区大小为B字节，只有当对端向本机返回ack表明其接收到大于等于M-B字节时，才意味着所有的数据都写入到缓冲区中。很明显，如果一次发送的数据量非常大，比如M&#x3D;10GB、B&#x3D;64KB，则：1）一次发送过程中本机线程会在一个fd上阻塞相当长一段时间，其他fd得不到及时处理；2）如果出现发送失败，无从得知到底有多少数据发送成功，应用程序只能选择重新发送这10G数据，结合考虑网络的稳定性，只能呵呵；</p>
<p>总之，上述两点都是无法接受的。因此，<strong>对性能有要求的服务器一般不采用阻塞而采用非阻塞</strong>。</p>
</blockquote>
<h3 id="设置非阻塞实现"><a href="#设置非阻塞实现" class="headerlink" title="设置非阻塞实现"></a>设置非阻塞实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置文件描述符为非阻塞函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">setfdUnblock</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> flag = fcntl(fd, F_GETFL, <span class="number">0</span>);</span><br><span class="line">    flag|=O_NONBLOCK;</span><br><span class="line">    fcntl(fd, F_SETFL, flag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务器端</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; fds;</span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    setfdUnblock(lfd);</span><br><span class="line">    <span class="comment">//设置描述符属性为非阻塞</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;lfd:&quot;</span>&lt;&lt;lfd&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv</span>;</span></span><br><span class="line">    bzero(&amp;serv,<span class="keyword">sizeof</span>(serv));</span><br><span class="line">    serv.sin_family = AF_INET;</span><br><span class="line">    serv.sin_port = htons(<span class="number">23456</span>);</span><br><span class="line">    serv.sin_addr.s_addr = htonl(INADDR_ANY);<span class="comment">//表示使用本地任意可用iP</span></span><br><span class="line">    bind(lfd,(sockaddr*)&amp;serv,<span class="keyword">sizeof</span>(serv));</span><br><span class="line">    </span><br><span class="line">    listen(lfd,<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;等待客户端链接...&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    again:</span><br><span class="line">    <span class="type">int</span> fd =accept(lfd,<span class="literal">NULL</span>,<span class="literal">NULL</span>);<span class="comment">//不关心连接的对方客户端信息</span></span><br><span class="line">    <span class="keyword">if</span>(fd==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">//std::cout&lt;&lt;&quot;获取链接失败&quot;&lt;&lt;fd&lt;&lt;std::endl;</span></span><br><span class="line">        <span class="keyword">goto</span> again;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;客户端已链接:&quot;</span>&lt;&lt;fd&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//查询是否为已连接客户端,若未连接则记录文件描述符</span></span><br><span class="line">    <span class="keyword">if</span>(find(fds.begin(),fds.end(),fd)==fds.end())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;准备添加的fd:&quot;</span>&lt;&lt;fd&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        setfdUnblock(fd);</span><br><span class="line">        fds.push_back(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此处限制只能连接两个</span></span><br><span class="line">    <span class="keyword">if</span> (fds.size()&lt;<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> again;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开始读写</span></span><br><span class="line">    <span class="comment">//char str[]=&quot;你好,世界!&quot;;</span></span><br><span class="line">    <span class="comment">//send(lfd,str,strlen(str)+1,0);</span></span><br><span class="line">    <span class="comment">//读数据</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;fds.size()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; fds.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;fds[i]&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="type">int</span> readSize =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; fds.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            readSize = read(fds[i],buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">if</span>(readSize&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;readSize:&quot;</span>&lt;&lt;readSize&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;buf:&quot;</span>&lt;&lt;buf&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭监听文件描述符和通信文件描述符</span></span><br><span class="line">    close(lfd);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此代码实现了接受多个客服端连接并接受客户端发过来的数据的功能.但建立连接的过程必须和读取数据的问题完全分离,即先<strong>建立指定连接数目的连接</strong>,然后再开始通信过程(此后无法继续建立新连接),建立连接和通信是割裂的.开始通信后没有一个好的时机供建立新的连接.如果是客户端通信内容决定建立连接的时机的话就可以用这种方式.(而且也没有好的时机做清理工作)</p>
<p>这种实现方法不是一个好的实现方法</p>
<p>但是其实还有<a href="#%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E5%9E%8Bselect">select方法</a>,可以解决上述问题</p>
<h3 id="多进程实现"><a href="#多进程实现" class="headerlink" title="多进程实现"></a>多进程实现</h3><p>不设置非阻塞状态的话都要考虑<a href="#%E9%98%B2%E6%AD%A2%E9%98%BB%E5%A1%9E%E8%A2%AB%E4%BF%A1%E5%8F%B7%E6%89%93%E6%96%AD">防止阻塞被信号打断</a></p>
<ol>
<li>注册子进程回收</li>
<li>创建socket,得到一个监听的文件描述符lfd   —   <a href="#socket%E5%87%BD%E6%95%B0">socket()</a></li>
<li>将lfd和IP和端口port进行绑定   —   <a href="#bind%E5%87%BD%E6%95%B0">bind()</a></li>
<li>设置监听   —   <a href="#listen%E5%87%BD%E6%95%B0">listen()</a></li>
<li>进入while循环<ol>
<li>接受新客户端到来 —   <a href="#accept%E5%87%BD%E6%95%B0">accept()</a></li>
<li><code>fork</code>子进程收发数据<ol>
<li>子进程关闭监听文件描述符后收发数据,最后要设置关闭描述符退出子进程<code>exit(0);</code>   —<a href="#%E8%AF%BB%E5%86%99%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0">read()&#x2F;write()</a></li>
<li>父进程关闭通信文件描述符</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>下面代码结合了<a href="#%E9%98%B2%E6%AD%A2%E9%98%BB%E5%A1%9E%E8%A2%AB%E4%BF%A1%E5%8F%B7%E6%89%93%E6%96%AD">防止阻塞被信号打断</a>的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mysocket.h&quot;</span><span class="comment">//防止堵塞被打断的代码</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigFunc</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//对子进程进行回收</span></span><br><span class="line">    <span class="type">int</span> iRet=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">       iRet = waitpid(<span class="number">-1</span>,<span class="literal">NULL</span>,WNOHANG);</span><br><span class="line">       <span class="keyword">if</span>(iRet&gt;<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;[&quot;</span>&lt;&lt;getpid()&lt;&lt;<span class="string">&quot;]主进程回收子进程[&quot;</span>&lt;&lt;iRet&lt;&lt;<span class="string">&quot;]&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((iRet!=<span class="number">0</span>)&amp;&amp;(iRet!=<span class="number">-1</span>));<span class="comment">//只要不是子进程正在运行和无子进程状态即继续循环,防止因为执行期间信号屏蔽产生僵尸进程</span></span><br><span class="line">    <span class="keyword">if</span> (iRet==<span class="number">-1</span>)<span class="comment">//全部子进程回收完毕</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//std::cout&lt;&lt;&quot;全部子进程回收完毕&quot;&lt;&lt;std::endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">99</span>];</span><br><span class="line">        gets(buf);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;buf&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;kmpSearch(buf,<span class="string">&quot;kill&quot;</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析sockaddr_in结构提取[ip:端口]字符串</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">acceptClient2Str</span><span class="params">(<span class="keyword">struct</span> sockaddr_in* client,<span class="type">char</span>* str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> sip[<span class="number">16</span>];</span><br><span class="line">    <span class="built_in">memset</span>(sip,<span class="number">0</span>,<span class="keyword">sizeof</span>(sip));</span><br><span class="line">    <span class="built_in">sprintf</span>(str,<span class="string">&quot;%s:%hu&quot;</span>,inet_ntop(AF_INET,&amp;client-&gt;sin_addr.s_addr,sip,<span class="keyword">sizeof</span>(sip)),ntohs(client-&gt;sin_port));</span><br><span class="line">    <span class="comment">//std::cout&lt;&lt;str&lt;&lt;std::endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务器端</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//注册子进程回收====================</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sg</span>;</span></span><br><span class="line">    sigemptyset(&amp;sg.sa_mask);</span><br><span class="line">    sg.__sigaction_u.__sa_handler=sigFunc;</span><br><span class="line">    sg.sa_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> iRet= sigaction(SIGCHLD,&amp;sg,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(!iRet)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;[&quot;</span>&lt;&lt;getpid()&lt;&lt;<span class="string">&quot;]主进程回收子进程回调注册成功&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//======================================</span></span><br><span class="line">    <span class="type">int</span> lfd = Socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;lfd:&quot;</span>&lt;&lt;lfd&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv</span>;</span></span><br><span class="line">    bzero(&amp;serv,<span class="keyword">sizeof</span>(serv));</span><br><span class="line">    serv.sin_family = AF_INET;</span><br><span class="line">    serv.sin_port = htons(<span class="number">23456</span>);</span><br><span class="line">    serv.sin_addr.s_addr = htonl(INADDR_ANY);<span class="comment">//表示使用本地任意可用iP</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;Bind(lfd,(sockaddr*)&amp;serv,<span class="keyword">sizeof</span>(serv))&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    Listen(lfd,<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;等待客户端链接...&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> len;</span><br><span class="line">    <span class="type">char</span> clientIp[<span class="number">20</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        len = <span class="keyword">sizeof</span>(client);</span><br><span class="line">        <span class="type">int</span> fd =Accept(lfd,(<span class="keyword">struct</span> sockaddr*)&amp;client,&amp;len);<span class="comment">//不关心连接的对方客户端信息</span></span><br><span class="line">        <span class="type">int</span> pid = fork();<span class="comment">//创建子进程收发数据</span></span><br><span class="line">        <span class="keyword">if</span>(pid&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)<span class="comment">//父进程</span></span><br><span class="line">        &#123;</span><br><span class="line">            close(fd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)<span class="comment">//子进程</span></span><br><span class="line">        &#123;</span><br><span class="line">            acceptClient2Str(&amp;client,clientIp);</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;创建子进程[&quot;</span>&lt;&lt;getpid()&lt;&lt;<span class="string">&quot;]与[&quot;</span>&lt;&lt;clientIp&lt;&lt;<span class="string">&quot;]建立连接&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            close(lfd);</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">                <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="type">int</span> readSize =<span class="number">0</span>;</span><br><span class="line">                readSize = Read(fd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span>(readSize&gt;<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;============[&quot;</span>&lt;&lt;getpid()&lt;&lt;<span class="string">&quot;]子进程读[&quot;</span>&lt;&lt;clientIp&lt;&lt;<span class="string">&quot;]数据如下:========&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;readSize:&quot;</span>&lt;&lt;readSize&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;buf:&quot;</span>&lt;&lt;buf&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;===============================================&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (readSize==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;[&quot;</span>&lt;&lt;clientIp&lt;&lt;<span class="string">&quot;]断开连接&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                    close(fd);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            close(fd);</span><br><span class="line">             <span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">//退出子进程防止其新建子进程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202208211649152.jpeg" alt="截屏2022-08-21 16.49.03" style="zoom: 33%;" />

<h3 id="多线程实现"><a href="#多线程实现" class="headerlink" title="多线程实现"></a>多线程实现</h3><p>不设置非阻塞状态的话都要考虑<a href="#%E9%98%B2%E6%AD%A2%E9%98%BB%E5%A1%9E%E8%A2%AB%E4%BF%A1%E5%8F%B7%E6%89%93%E6%96%AD">防止阻塞被信号打断</a></p>
<ol>
<li><p>注册子进程回收</p>
</li>
<li><p>创建socket,得到一个监听的文件描述符lfd   —   <a href="#socket%E5%87%BD%E6%95%B0">socket()</a></p>
</li>
<li><p>将lfd和IP和端口port进行绑定   —   <a href="#bind%E5%87%BD%E6%95%B0">bind()</a></p>
</li>
<li><p>设置监听   —   <a href="#listen%E5%87%BD%E6%95%B0">listen()</a></p>
</li>
<li><p>进入while循环</p>
<ol>
<li><p>接受新客户端到来 —   <a href="#accept%E5%87%BD%E6%95%B0">accept()</a></p>
</li>
<li><p><code>pthread_create</code>创建子线程收发数据</p>
<ol>
<li>收发数据   —<a href="#%E8%AF%BB%E5%86%99%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0">read()&#x2F;write()</a></li>
<li>关闭传入的描述符</li>
</ol>
</li>
<li><p><code>pthread_detach</code>设置线程为分离属性(退出时自动释放)</p>
</li>
</ol>
</li>
</ol>
<p><strong>[注意]</strong>  <strong>主线程和子线程共享文件描述符</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mysocket.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解析sockaddr_in结构提取[ip:端口]字符串</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">acceptClient2Str</span><span class="params">(<span class="keyword">struct</span> sockaddr_in* client,<span class="type">char</span>* str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> sip[<span class="number">16</span>];</span><br><span class="line">    <span class="built_in">memset</span>(sip,<span class="number">0</span>,<span class="keyword">sizeof</span>(sip));</span><br><span class="line">    <span class="built_in">sprintf</span>(str,<span class="string">&quot;%s:%hu&quot;</span>,inet_ntop(AF_INET,&amp;client-&gt;sin_addr.s_addr,sip,<span class="keyword">sizeof</span>(sip)),ntohs(client-&gt;sin_port));</span><br><span class="line">    <span class="comment">//std::cout&lt;&lt;str&lt;&lt;std::endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a=<span class="number">30</span>;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">threadFunc</span><span class="params">(<span class="type">void</span>* fdAddr)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span> buf[<span class="number">99</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">   <span class="type">int</span> fd = (<span class="type">int64_t</span>)fdAddr;<span class="comment">//取得通信用的描述符</span></span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="type">int</span> nRet = read(fd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(nRet==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;线程id[&quot;</span>&lt;&lt;pthread_self()&lt;&lt;<span class="string">&quot;]退出连接&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            close(fd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//pthread_exit()该函数也可以</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nRet&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;读到的数据为:&quot;</span>&lt;&lt;buf&lt;&lt;<span class="string">&quot;   长度:&quot;</span>&lt;&lt;nRet&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> cfd = Socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv</span>;</span></span><br><span class="line">    serv.sin_family=AF_INET;</span><br><span class="line">    serv.sin_port=htons(<span class="number">23456</span>);</span><br><span class="line">    inet_pton(AF_INET,<span class="string">&quot;127.0.0.1&quot;</span>,&amp;serv.sin_addr.s_addr);</span><br><span class="line">    Bind(cfd,(<span class="type">const</span> sockaddr*)&amp;serv,<span class="keyword">sizeof</span>(serv));</span><br><span class="line">    Listen(cfd,<span class="number">2</span>);</span><br><span class="line">    <span class="type">pthread_t</span> threadID;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;等待接受连接...&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="type">char</span> clientIp[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sockaddr_in client;</span><br><span class="line">        <span class="type">socklen_t</span> len=<span class="keyword">sizeof</span>(client);</span><br><span class="line">        <span class="type">int</span> fd = Accept(cfd,(sockaddr*)&amp;client,&amp;len);</span><br><span class="line">        acceptClient2Str(&amp;client,clientIp);</span><br><span class="line">        pthread_create(&amp;threadID,<span class="literal">NULL</span>,threadFunc,(<span class="type">void</span>*)fd);</span><br><span class="line">        pthread_detach(threadID);<span class="comment">//设置线程为分 离属性</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;接收到[&quot;</span>&lt;&lt;clientIp&lt;&lt;<span class="string">&quot;]连接,创建线程[0x&quot;</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; setbase(<span class="number">16</span>) &lt;&lt; (<span class="type">int64_t</span>)threadID&lt;&lt;<span class="string">&quot;]处理&quot;</span>&lt;&lt;<span class="built_in">endl</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="半关闭状态"><a href="#半关闭状态" class="headerlink" title="半关闭状态"></a>半关闭状态</h2><p>如果一方close,另一方没有close,则认为是半关闭状态,处于半关闭状态的时候,可以接受数据,但是不能发送数据.相当于把文件描述符的写缓存区操作关闭了.</p>
<p>注意:半关闭一定是出现在主动关闭的一方</p>
<h3 id="shutdown函数"><a href="#shutdown函数" class="headerlink" title="shutdown函数"></a>shutdown函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">shutdown</span><span class="params">(<span class="type">int</span> socketfd, <span class="type">int</span> how)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个参数为socket返回的文件描述符</li>
<li>第二个参数可以设置为<code>SHUT_RD/SHUT_WR/SHUT_RDWR</code>分别表示<code>关闭接受缓存区/关闭发送缓冲区/都关闭</code></li>
</ul>
<p>返回值:成功返回0;失败返回-1,并设置errno</p>
<blockquote>
<p><strong>shutdown和close的区别:</strong></p>
<p>shutdown能够把文件描述符上的读或者写操作关闭,而close关闭文件描述符只是将连接的引用计数的值减1,当减到0就真正关闭文件描述符了.</p>
<p>如: 调用dup函数或者dup2函数可以复制一个文件描述符, close其中一个并不影响另一个文件描述符,而shutdown就不同了,一旦shutdown了其中一个文件描述符,对所有的文件描述符都有影响(只是关闭了用户层,用户层没法再发了,内核层还是可以发的,tcp四次挥手最后一个ack就是这样理解)</p>
</blockquote>
<h2 id="端口复用"><a href="#端口复用" class="headerlink" title="端口复用"></a>端口复用</h2><p>解决端口复用的问题: <code>bind error: Address already in use</code>, 发生这种情况是在服务端主动关闭连接以后, 接着立刻启动就会报这种错误.</p>
<p>测试: 启动服务端和客户端, 然后先关闭服务端, 再次启动服务端, 此时服务端报错: <code>bind error: Address already in use;</code> 若是先关闭的客户端, 再关闭的服务端, 此时启动服务端就不会报这个错误.</p>
<h3 id="setsockopt函数"><a href="#setsockopt函数" class="headerlink" title="setsockopt函数"></a>setsockopt函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span> optlen)</span>;</span><br></pre></td></tr></table></figure>

<p>返回值 : 成功返回0 ; 失败返回-1,并设置errno</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用案例</span></span><br><span class="line">setsockopt(lfd,<span class="comment">//socket返回的套接字</span></span><br><span class="line">           SOL_SOCKET,<span class="comment">//通用的套接字选项</span></span><br><span class="line">           SO_REUSEADDR,<span class="comment">//如果*optval为0,重用bind中的地址;SO_REUSEPORT这个重用端口的也可以,但用得比较少</span></span><br><span class="line">           &amp;opt,<span class="comment">//根据optname的不同指向一个数据结构或一个整数,比如说一些选项是[int的非0/0]对应[选项启用/禁用]开关.</span></span><br><span class="line">           <span class="keyword">sizeof</span>(<span class="type">int</span>));<span class="comment">//optval指向的对象的大小</span></span><br><span class="line"><span class="comment">//比如说设置端口复用如下:</span></span><br><span class="line"><span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure>

<p>函数说明可参看&lt;&lt;UNIX环境高级编程&gt;&gt;</p>
<p><strong>由于错误是bind函数报出来的, 该函数调用要放在bind之前, socket之后调用.</strong></p>
<h2 id="getsockopt函数"><a href="#getsockopt函数" class="headerlink" title="getsockopt函数"></a>getsockopt函数</h2><p>函数用于获取任意类型、任意状态<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%A5%97%E6%8E%A5%E5%8F%A3/10058888?fromModule=lemma_inlink">套接口</a>的选项当前值，并把结果存入<code>option_value</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getsockopt</span><span class="params">(<span class="type">int</span> socket, </span></span><br><span class="line"><span class="params">               <span class="type">int</span> level, </span></span><br><span class="line"><span class="params">               <span class="type">int</span> option_name,</span></span><br><span class="line"><span class="params">               <span class="type">void</span> *<span class="keyword">restrict</span> option_value, </span></span><br><span class="line"><span class="params">               <span class="type">socklen_t</span> *<span class="keyword">restrict</span> optio</span></span><br><span class="line"><span class="params">               n_len)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>成功，它将返回0，表示获取选项值成功。</li>
<li>失败，它将返回-1，并设置errno变量来指示错误原因</li>
</ul>
<p>在使用非阻塞Socket时，我们通常会使用getsockopt函数和<code>SO_ERROR</code>选项来检查Socket的状态，以便在Socket出错时及时处理错误。例如，当使用select或poll等多路复用函数时，我们可以先调用getsockopt函数来获取Socket的错误状态，然后根据错误状态来判断Socket是否可以进行读写操作。</p>
<p>获取socket错误状态 例子如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> err;</span><br><span class="line"><span class="type">socklen_t</span> socklen = <span class="keyword">sizeof</span>(err);</span><br><span class="line"><span class="type">int</span> sockoptret = getsockopt(m_socket, SOL_SOCKET, SO_ERROR, &amp;err, &amp;socklen);</span><br></pre></td></tr></table></figure>

<h2 id="心跳包"><a href="#心跳包" class="headerlink" title="心跳包"></a>心跳包</h2><p>用于检测长连接是否正常的手段</p>
<p>长连接和短连接的概念:</p>
<p>连接建立之后一直不关闭为<strong>长连接</strong><br>连接收发数据完毕之后就关闭为<strong>短连接</strong></p>
<p>长连接 通常用于通信双方数据交换频繁的情况下</p>
<p>如何检查与对方的网络连接是否正常?<br>一般心跳包用于长连接.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">keepAlive = <span class="number">1</span>;</span><br><span class="line">setsockopt(listenfd, SOL_SOCKET, SO_KEEPALIVE, (<span class="type">void</span>*)&amp;keepAlive, <span class="keyword">sizeof</span>(keepAlive));</span><br></pre></td></tr></table></figure>

<p>上面为官方提供的方式,由于不能实时的检测网络情况, 一般不用这种方法</p>
<p><strong>在应用程序中自己定义心跳包,使用灵活,能实时把控</strong></p>
<p>通信双方需要协商规则(协议)</p>
<h2 id="高并发服务器模型select"><a href="#高并发服务器模型select" class="headerlink" title="高并发服务器模型select"></a>高并发服务器模型select</h2><p>一种多路io复用技术:同时监听多个文件描述符,将监控的操作交给内核去处理</p>
<p>优点:跨平台使用,windows,linux,macos都支持select</p>
<p>缺点:受最大描述符数量1024的限制</p>
<h3 id="select函数"><a href="#select函数" class="headerlink" title="select函数"></a>select函数</h3><p>函数介绍: 委托内核监控该文件描述符对应的读,写或者错误事件或者连接请求的发生.(内核收到了告诉程序,避免了accept阻塞)</p>
<p>只要是文件描述符,select函数都可以派上用场.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds, fd_set * readfds, fd_set *writefds, fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span>;</span><br></pre></td></tr></table></figure>

<p>参数说明: </p>
<ul>
<li><p>nfds: 最大的文件描述符+1</p>
</li>
<li><p>readfds: 读文件描述符集合, 是一个传入传出参数</p>
<ul>
<li>传入: 指的是告诉内核哪些文件描述符需要监控</li>
<li>传出: 指的是内核告诉应用程序哪些文件描述符发生了变化</li>
</ul>
</li>
<li><p>writefds: 写文件描述符集合(传入传出参数)</p>
<p>同上</p>
</li>
<li><p>execptfds: 异常文件描述符集合(传入传出参数)</p>
<p>同上</p>
</li>
<li><p>timeout: </p>
<ul>
<li><code>NULL</code>–表示永久阻塞, 直到有事件发生</li>
<li><code>&gt;0</code>–表示阻塞的时长,遇到事件发生或者超时就返回</li>
</ul>
<p>返回值: </p>
<p>​		成功,<strong>返回发生变化的文件描述符的个数</strong>,表示至少有一个套接字已经准备好了可读,可写或异常事件.</p>
<p>​		超时:限时内没有任何发生变化的文件描述符个数,返回0</p>
<p>​		失败,返回-1, 并设置errno值.</p>
</li>
</ul>
<blockquote>
<p>如果select()函数返回1，并且FD_ISSET()函数返回true，则表示该套接字已经准备好了可读、可写或异常事件。此时需要进一步调用<a href="#getsockopt%E5%87%BD%E6%95%B0">getsockopt()函数</a>，并检查SO_ERROR选项是否为0来判断该套接字是否处于异常状态。如果SO_ERROR的值为0，则表示该套接字没有发生错误；否则，SO_ERROR的值将是相应的错误码，表示该套接字已经发生了错误。</p>
</blockquote>
<p>操作文件描述符集的宏如下:</p>
<ul>
<li><p><code>void FD_CLR(int fd, fd_set *set);</code></p>
<p>将fd从set集合中清除.</p>
</li>
<li><p><code>int FD_ISSET(int fd, fd_set *set);</code></p>
<p>功能描述: 判断fd是否在集合中</p>
<p>返回值: 如果fd在set集合中, 返回1, 否则返回0.</p>
</li>
<li><p><code>void FD_SET(int fd, fd_set *set);</code></p>
<p>将fd设置到set集合中.</p>
</li>
<li><p><code>void FD_ZERO(fd_set *set);</code></p>
<p>初始化set集合(清空).</p>
</li>
</ul>
<p>在linux中的定义位置:<code>/usr/include/x86_64-linux-gnu/sys/select.h</code>和<code>/usr/include/x86_64-linux-gnu/bits/select.h</code>(最简单的方法就是使用预处理将头文件和宏全部替换掉<code>gcc -E select.c -o select.i</code>, 直接就可以看到最终的定义了)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">long</span> <span class="type">int</span> __fds_bits[<span class="number">1024</span>/(<span class="number">8</span>*<span class="number">8</span>))];<span class="comment">//1024对应1024个文件描述符</span></span><br><span class="line"><span class="comment">//long int __fds_bits[16];</span></span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<p>从上面的文件中可以看出, 这几个宏本质上还是位操作.(与信号集操作类似)</p>
<h3 id="select开发服务端代码"><a href="#select开发服务端代码" class="headerlink" title="select开发服务端代码"></a>select开发服务端代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mysocket.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> lfd = Socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv</span>;</span></span><br><span class="line">    serv.sin_family = AF_INET;</span><br><span class="line">    serv.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv.sin_port = htons(<span class="number">23456</span>);</span><br><span class="line">    <span class="comment">//设置端口复用</span></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    Bind(lfd,(<span class="keyword">struct</span> sockaddr*)&amp;serv,<span class="keyword">sizeof</span>(serv));</span><br><span class="line">    Listen(lfd,<span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> maxfd = lfd;<span class="comment">//设置给委托内核监控的描述符的范围</span></span><br><span class="line">    fd_set setReal;</span><br><span class="line">    FD_ZERO(&amp;setReal);</span><br><span class="line">    FD_SET(lfd,&amp;setReal);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;服务器开启,等待连接&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fd_set setR = setReal;</span><br><span class="line">        <span class="type">int</span> fdChangeNum = select(maxfd+<span class="number">1</span>,&amp;setR,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);<span class="comment">//阻塞监控变化,不需要考虑返回0的情况,因为返回&gt;0和&lt;0才会解除堵塞(如果select最后一个参数填写了超时时间设置的话,需要考虑=0的情况)</span></span><br><span class="line">        <span class="keyword">if</span>(fdChangeNum&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno==EINTR)<span class="comment">//信号被中断</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//出问题返回(并未做什么完善的处理)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//有客户端连接请求到来</span></span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(lfd,&amp;setR))<span class="comment">//如果lfd有响应</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;客户端连接存在,返回:&quot;</span>&lt;&lt;fdChangeNum&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="type">int</span> cfd = accept(lfd,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;接受到新的连接,文件描述符为&quot;</span>&lt;&lt;cfd&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="comment">//将cfd加入到委托内核监控中</span></span><br><span class="line">            FD_SET(cfd,&amp;setReal);</span><br><span class="line">            <span class="comment">//调整监控文件描述符范围,将新加入的accept接受到的描述符添加入委托内核监控的范围</span></span><br><span class="line">            <span class="keyword">if</span>(maxfd&lt;cfd)</span><br><span class="line">            &#123;</span><br><span class="line">                maxfd = cfd ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果只有一个描述符变化了,而且是在有客户端连接请求到来的上下文执行中</span></span><br><span class="line">            <span class="comment">//则此处说明只有这一个连接请求导致的描述符变化,因此这样情况下后面代码可以略过</span></span><br><span class="line">            <span class="keyword">if</span>(--fdChangeNum==<span class="number">0</span>)<span class="comment">//如果只剩最后一个就无需在执行后面了</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span> str[<span class="number">99</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">//有客户端发数据过来</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = lfd+<span class="number">1</span>; i &lt;= maxfd; i++)<span class="comment">//i表示accept接受的fd</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(i,&amp;setR))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;数据通信存在,返回值为:&quot;</span>&lt;&lt;fdChangeNum&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                <span class="type">int</span> iRet = Read(i,str,<span class="keyword">sizeof</span>(str));<span class="comment">//有才读,所以不需要考虑堵塞吗</span></span><br><span class="line">                <span class="keyword">if</span>(iRet&lt;=<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;断开连接&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                    close(i);</span><br><span class="line">                    FD_CLR(i,&amp;setReal);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;[返回&quot;</span>&lt;&lt;iRet&lt;&lt;<span class="string">&quot;]读到的数据为:&quot;</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于select的思考:</p>
<p>​	问题: 如果有效的文件描述符比较少, 会使循环的次数太多.(大多数都是初始连接一次就)</p>
<p>​	解决办法: 可以将<strong>有效的</strong>(排除了被取消掉的文件描述符)文件描述符放到一个数组当中, 这样遍历效率就高了.(连接不频繁,而通信频繁,也可以针对通信开数组)</p>
<p><strong>select优点</strong></p>
<ul>
<li>一个进程可以支持多个客户端</li>
<li>select支持跨平台</li>
</ul>
<p><strong>select缺点</strong></p>
<ul>
<li><p>代码编写困难</p>
</li>
<li><p>会涉及到用户区到内核区的来回拷贝</p>
</li>
<li><p>当客户端多个连接, 但少数活跃的情况, select效率较低</p>
<p>例如: 作为极端的一种情况, 3-1023文件描述符全部打开, 但是只有1023有发送数据, select就显得效率低下</p>
</li>
<li><p>最大支持1024个客户端连接</p>
<p>select最大支持1024个客户端连接不是有文件描述符表最多可以支持1024个文件描述符限制的, 而是由<code>FD_SETSIZE=1024</code>限制的.</p>
</li>
</ul>
<p>	</p>
<p><code>FD_SETSIZE=1024</code> fd_set(fd_set这个文件描述符表中一共有1024个bit位)使用了该宏, 当然可以修改内核, 然后再重新编译内核, 一般不建议这么做.</p>
<p><a target="_blank" rel="noopener" href="http://t.zoukankan.com/curo0119-p-8459962.html">windows下的select模型相关知识外链跳转</a></p>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>编写代码, 让select监控标准输入, 监控网络, 如果标准输入有数据就写入网络, 如果网络有数据就读出网络数据, 然后打印到标准输出. </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> lfd = Socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv</span>;</span></span><br><span class="line">    serv.sin_family = AF_INET;</span><br><span class="line">    serv.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv.sin_port = htons(<span class="number">23456</span>);</span><br><span class="line">    <span class="comment">//设置端口复用</span></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    Bind(lfd,(<span class="keyword">struct</span> sockaddr*)&amp;serv,<span class="keyword">sizeof</span>(serv));</span><br><span class="line">    Listen(lfd,<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;服务器开启,等待连接&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="type">int</span> cfd = Accept(lfd,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;接受到新的连接,文件描述符为&quot;</span>&lt;&lt;cfd&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    fd_set setRReal;</span><br><span class="line">    FD_ZERO(&amp;setRReal);</span><br><span class="line">    FD_SET(cfd,&amp;setRReal);</span><br><span class="line">    FD_SET(STDIN_FILENO,&amp;setRReal);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fd_set setR = setRReal;</span><br><span class="line">        <span class="type">int</span> iRet = select(cfd+<span class="number">1</span>,&amp;setR,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="type">char</span> str[<span class="number">99</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(cfd,&amp;setR))<span class="comment">//如果网络连接描述符有变化</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> iRet = read(cfd,str,<span class="keyword">sizeof</span>(str));</span><br><span class="line">            <span class="keyword">if</span>(iRet&lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(STDIN_FILENO,&amp;setR))<span class="comment">//如果标准输入有变化</span></span><br><span class="line">        &#123;</span><br><span class="line">            gets(str);</span><br><span class="line">            <span class="built_in">strcat</span>(str,<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            write(cfd,str,<span class="built_in">strlen</span>(str)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(cfd);</span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="poll与epoll"><a href="#poll与epoll" class="headerlink" title="poll与epoll"></a>poll与epoll</h2><p>poll与epoll可以突破最大描述符数量1024个的限制</p>
<ol>
<li>poll函数</li>
<li>epoll多路IO模型</li>
<li>了解poll ET&#x2F;LT触发模式并实现</li>
<li>理解epoll边缘非阻塞模式并实现</li>
<li>了解epoll反应堆模型设计思想</li>
<li>能看懂epoll反应堆模型的实现代码</li>
</ol>
<p>linux下常用<code>epoll</code>     unix下常用<code>select</code></p>
<p>效率来看: epoll&gt;poll&gt;select</p>
<h3 id="多路IO-poll"><a href="#多路IO-poll" class="headerlink" title="多路IO-poll"></a>多路IO-poll</h3><p>跟select类似, 监控内核监控事件,实现多路IO, 但poll不能跨平台</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure>

<p>参数说明</p>
<ul>
<li><p><code>fds</code>: 传入传出参数, 实际上是一个<strong>结构体数组</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span>  fd;    <span class="comment">/* file descriptor */</span>  <span class="comment">//监控的文件描述符</span></span><br><span class="line">  <span class="type">short</span> events;   <span class="comment">/* requested events */</span> <span class="comment">//要监控的事件---不会被修改</span></span><br><span class="line">  <span class="type">short</span> revents;  <span class="comment">/* returned events */</span>  <span class="comment">//返回发生变化的事件 ---由内核返回</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>fds.fd</code>: 要监控的文件描述符</p>
</li>
<li><p><code>fds.events</code>:(多个之间用或相连)</p>
<p><code>POLLIN</code>—-&gt;读事件</p>
<p><code>POLLOUT</code>—-&gt;写事件 </p>
<p><code>POLLERR</code>—-&gt;异常事件</p>
<p><code>POLLIN|POLLHUP</code> —-&gt;管道断开连接</p>
<p>其他更多宏参考 <code>man 2 poll</code></p>
</li>
<li><p><code>fds.revents</code>: 返回的事件</p>
</li>
</ul>
</li>
<li><p><code>nfds</code>: 数组实际有效内容的个数,就是fds数组下标的最大值+1</p>
</li>
<li><p><code>timeout</code>: 超时时间, 单位是毫秒.</p>
<ul>
<li><code>-1</code>:永久阻塞, 直到监控的事件发生</li>
<li><code>0</code>: 不管是否有事件发生, 立刻返回</li>
<li><code>&gt;0</code>: 直到监控的事件发生或者超时</li>
</ul>
</li>
</ul>
<p><strong>返回值</strong>          </p>
<ul>
<li>成功:<strong>返回就绪事件的个数</strong></li>
<li>失败: 返回-1</li>
</ul>
<p>若<code>timeout=0</code>, poll函数不阻塞,且没有事件发生, 此时返回-1, 并且<code>errno=EAGAIN</code>, <strong>这种情况不应视为错误</strong>.</p>
<p>说明</p>
<ol>
<li>当poll函数返回的时候, 结构体当中的<code>fd</code>和<code>events</code>没有发生变化, 究竟有没有事件发生由<code>revents</code>来判断, 所以<strong>poll是请求和返回分离</strong>.</li>
<li><code>struct pollfd</code>结构体中的<strong>fd成员若赋值为-1, 则poll不会监控.</strong></li>
<li>相对于select, poll没有本质上的改变; 但是<strong>poll可以突破1024的限制.</strong></li>
</ol>
<p><strong>如何突破1024的限制</strong>(开发流程一般是没有权限改的)</p>
<p>在<code>/proc/sys/fs/file-max</code>查看一个进程可以打开的socket描述符上限.</p>
<p>如果需要可以修改配置文件: <code>/etc/security/limits.conf</code></p>
<p>加入如下配置信息, 然后重启终端即可生效.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* soft nofile <span class="number">1024</span></span><br><span class="line">* hard nofile <span class="number">100000</span></span><br><span class="line"><span class="comment">//修改的话,直接修改1024处的数字.</span></span><br><span class="line"><span class="comment">//hard表示可以修改的最大限制</span></span><br></pre></td></tr></table></figure>

<p><strong>代码</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> lfd = Socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv</span>;</span></span><br><span class="line">    serv.sin_family = AF_INET;</span><br><span class="line">    serv.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv.sin_port = htons(<span class="number">23456</span>);</span><br><span class="line">    <span class="comment">//设置端口复用</span></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    Bind(lfd,(<span class="keyword">struct</span> sockaddr*)&amp;serv,<span class="keyword">sizeof</span>(serv));</span><br><span class="line">    Listen(lfd,<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;服务器开启,等待连接&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">client</span>[1024];</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++)<span class="comment">//初始化</span></span><br><span class="line">    &#123;</span><br><span class="line">        client[i].fd = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">    client[<span class="number">0</span>].fd = lfd;</span><br><span class="line">    client[<span class="number">0</span>].events = POLLIN;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> iRet = poll(client,max+<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(iRet &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//有客户端连接请求到来</span></span><br><span class="line">        <span class="keyword">if</span>(client[<span class="number">0</span>].revents == POLLIN)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> cfd = Accept(lfd,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;接受连接成功,fd:&quot;</span>&lt;&lt;cfd&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="comment">//将新文件描述符加入poll监控</span></span><br><span class="line">            <span class="comment">//寻找数组中空出来的位置</span></span><br><span class="line">            <span class="type">size_t</span> i;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (client[i].fd == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    client[i].fd = cfd;</span><br><span class="line">                    client[i].events = POLLIN;</span><br><span class="line">                    <span class="comment">//修改client数组下标最大值</span></span><br><span class="line">                    <span class="keyword">if</span>(i&gt;max)</span><br><span class="line">                    &#123;</span><br><span class="line">                        max = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">1024</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                close(cfd);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(--iRet==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//下面是收到客户端发送数据的情况</span></span><br><span class="line">        <span class="type">char</span> str[<span class="number">99</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">1</span>; j &lt;= max; j++)</span><br><span class="line">        &#123;</span><br><span class="line">             <span class="keyword">if</span>(client[j].revents == (POLLHUP|POLLIN))<span class="comment">//检测到连接断开的方式之一</span></span><br><span class="line">            &#123;</span><br><span class="line">               <span class="comment">//std::cout&lt;&lt;&quot;断开了解&quot;&lt;&lt;std::endl;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (client[j].revents &amp; POLLIN)<span class="comment">//这里必须是&amp;,如果是==无法检测到其中的连接断开的情况</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> iReadRet = Read(client[j].fd, str, <span class="keyword">sizeof</span>(str));</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;iReadRet&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">if</span> (iReadRet &lt;= <span class="number">0</span>)<span class="comment">//检测到连接断开的方式之二</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//std::cout&lt;&lt;client[j].revents&lt;&lt;std::endl;</span></span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;断开连接&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                    close(client[j].fd);</span><br><span class="line">                    client[j].fd = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (j == max)</span><br><span class="line">                        max--;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;读到的数据:&quot;</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">              	<span class="keyword">if</span>(--iRet == <span class="number">0</span>)<span class="comment">//优化,如果只有一个就无需再遍历了</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多路IO-epoll"><a href="#多路IO-epoll" class="headerlink" title="多路IO-epoll"></a>多路IO-epoll</h3><p>将检测文件描述符的变化委托给内核去处理, 然后内核将发生变化的文件描述符对应的事件返回给应用程序.</p>
<p>底层实现是<strong>红黑二叉树</strong></p>
<p>优点:epoll的并发量大于poll和select</p>
<p>缺点:只支持linux系统</p>
<h4 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h4><h5 id="epoll-create函数"><a href="#epoll-create函数" class="headerlink" title="epoll_create函数"></a>epoll_create函数</h5><p>创建一棵epoll数,返回一个树根节点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong>    <code>size</code>: 最大节点数, 此参数在linux 2.6.8已被忽略, 但必须传递一个大于0的数.</p>
<p><strong>返回值</strong></p>
<ul>
<li>成功: 返回一个大于0的文件描述符, 代表整个树的树根.</li>
<li>失败: 返回-1, 并设置errno值.</li>
</ul>
<h5 id="epoll-ctl函数"><a href="#epoll-ctl函数" class="headerlink" title="epoll_ctl函数"></a>epoll_ctl函数</h5><p>将要监听的节点在epoll树上添加, 删除和修改</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong></p>
<ul>
<li><code>epfd</code>: epoll树根</li>
<li><code>op</code>:<ul>
<li><code>EPOLL_CTL_ADD</code>: 添加事件节点到树上</li>
<li><code>EPOLL_CTL_DEL</code>: 从树上删除事件节点</li>
<li><code>EPOLL_CTL_MOD</code>: 修改树上对应的事件节点</li>
</ul>
</li>
<li><code>fd</code>: 事件节点对应的文件描述符</li>
<li><code>event</code>: 要操作的事件节点  (epoll_event结构体),如果是要下树的话,这里只需要填NULL</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">     <span class="type">void</span>    *ptr;</span><br><span class="line">     <span class="type">int</span>     fd;<span class="comment">//委托内核监控的文件描述符</span></span><br><span class="line">     <span class="type">uint32_t</span>   u32;</span><br><span class="line">     <span class="type">uint64_t</span>   u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">     <span class="type">uint32_t</span>   events;   <span class="comment">/* Epoll events */</span></span><br><span class="line">    <span class="comment">//常用如下:(多选项通过|(按位或)结合)</span></span><br><span class="line">  	<span class="comment">//EPOLLIN:监听可读事件</span></span><br><span class="line">    <span class="comment">//EPOLLOUT:监听可写事件</span></span><br><span class="line">    <span class="comment">//EPOLLERR:监听异常事件</span></span><br><span class="line">    <span class="comment">//EPOLLET: 边缘触发 </span></span><br><span class="line">     <span class="type">epoll_data_t</span> data;    <span class="comment">/* User data variable  就是上面那个epoll_data结构体*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>p.s.  客户端关闭既会触发服务器的<code>EPOLLIN</code>事件,也会触发<code>EPOLLOUT</code>事件</p>
<blockquote>
<p><strong><code>EPOLLOUT</code>的理解</strong>:传输大量数据的时候，没有办法一次将数据全部发送出去就需要将剩下的数据缓存起来，等内核通知缓冲区可写的时候再继续发送(<code>EPOLLOUT</code>事件表示fd的发送缓冲区可写，在一次发送大量数据（超过发送缓冲区大小）的情况下很有用)</p>
<p>你需要将一个10G大小的文件返回给用户，那么你简单send这个文件是不会成功的。</p>
<p>这个场景下，你send 10G的数据，send返回值不会是10G，而是大约256k，表示你只成功写入了256k的数据。接着调用send，send就会返回EAGAIN，告诉你socket的缓冲区已经满了，此时无法继续send。</p>
<p>此时异步程序的正确处理流程是调用epoll_wait，当socket缓冲区中的数据被对方接收之后，缓冲区就会有空闲空间可以继续接收数据，此时epoll_wait就会返回这个socket的EPOLLOUT事件，获得这个事件时，你就可以继续往socket中写出数据。</p>
</blockquote>
<h5 id="epoll-wait函数"><a href="#epoll-wait函数" class="headerlink" title="epoll_wait函数"></a>epoll_wait函数</h5><p>等待内核返回事件发生</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure>

<p>参数说明:</p>
<ul>
<li><code>epfd</code>: epoll树根</li>
<li><code>events</code>: 传出参数, 其实是一个事件结构体数组(epoll_event数组结构体)</li>
<li><code>maxevents</code>: epoll_event数组的项最大数量</li>
<li><code>timeout</code><ul>
<li><code>-1</code>: 表示永久阻塞</li>
<li><code>0</code>: 立即返回</li>
<li><code>&gt;0</code>: 表示超时等待事件</li>
</ul>
</li>
</ul>
<p>返回值:</p>
<ul>
<li>成功: 返回发生<strong>事件的个数</strong></li>
<li>失败: 若timeout&#x3D;0, 没有事件发生则返回; 返回-1, 设置errno值</li>
</ul>
<p>**[注意] **<code>epoll_wait</code>的<code>events</code>是一个传出参数, 调用<code>epoll_ctl</code>传递给内核什么值, 当<code>epoll_wait</code>返回的时候, 内核就传回什么值,不会对<code>struct event</code>的结构体变量的值做任何修改.</p>
<h4 id="实现案例"><a href="#实现案例" class="headerlink" title="实现案例"></a>实现案例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">        setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        sockaddr_in serv;</span><br><span class="line">        serv.sin_family = AF_INET;</span><br><span class="line">        serv.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">        serv.sin_port = htons(<span class="number">23456</span>);</span><br><span class="line">        bind(lfd, (sockaddr *)&amp;serv, <span class="keyword">sizeof</span>(serv));</span><br><span class="line">        listen(lfd, <span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> epfd = epoll_create(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//将监听文件描述符上树</span></span><br><span class="line">        epoll_event ev;</span><br><span class="line">        ev.events = EPOLLIN;</span><br><span class="line">        ev.data.fd = lfd;</span><br><span class="line">        <span class="comment">//监听文件描述符上树</span></span><br><span class="line">        epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;ev);</span><br><span class="line">        epoll_event events[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> nready = epoll_wait(epfd, events, <span class="number">1024</span>, <span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nready &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (errno == EINTR) <span class="comment">//信号中断</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nready; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//有客户端链接请求到来</span></span><br><span class="line">                <span class="type">int</span> sockfd = events[i].data.fd;</span><br><span class="line">                <span class="keyword">if</span> (sockfd == lfd)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> cfd = accept(lfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                    ev.data.fd = cfd;</span><br><span class="line">                    ev.events = EPOLLIN;</span><br><span class="line">                    epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;ev);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">char</span> buf[<span class="number">999</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="comment">//有客户端发送数据过来</span></span><br><span class="line">                <span class="type">int</span> n = read(sockfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    close(sockfd);</span><br><span class="line">                    <span class="comment">//下监控树</span></span><br><span class="line">                    epoll_ctl(epfd, EPOLL_CTL_DEL, sockfd, <span class="literal">NULL</span>);</span><br><span class="line">                    perror(<span class="string">&quot;read error of client close&quot;</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; buf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        close(lfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可能存在的问题:若每一个连接上处理的时间比较长,会导致后面的连接上发来的数据得不到及时的处理</p>
<p>解决方法:可以让主线程处理<code>epoll_wait</code>,让子线程收发数据</p>
<h4 id="ET工作模式"><a href="#ET工作模式" class="headerlink" title="ET工作模式"></a>ET工作模式</h4><p>epoll有两种工作模式:ET和LT模式</p>
<ul>
<li>水平触发(<code>LT</code>): 高电平代表1     (epoll默认是LT模式)<br>    <strong>只要缓冲区(内核的读缓冲区)中有数据, 就一直通知</strong></li>
<li>边缘触发(<code>ET</code>): 电平有变化就代表1<br>    <strong>缓冲区中有数据只会通知一次, 之后再有数据才会通知</strong>.(若是读数据的时候没有读完, 则剩余的数据不会再通知, 直到有新的数据到来)</li>
</ul>
<p>epoll_event结构体中的events按位或<code>EPOLLET</code>来<a href="#epoll_ctl%E5%87%BD%E6%95%B0">设置边缘触发</a>.</p>
<p>边缘非阻塞模式优势: 提高效率</p>
<h5 id="et模式案例"><a href="#et模式案例" class="headerlink" title="et模式案例"></a>et模式案例</h5><p>ET模式由于只通知一次, 所以在读的时候要循环读, 直到读完, 但是当读完之后read就会阻塞, 所以应该将该文件描述符设置为非阻塞模式(<a href="#%E8%AE%BE%E7%BD%AE%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%AE%9E%E7%8E%B0">fcntl函数</a>).</p>
<blockquote>
<p>read函数在非阻塞模式下读的时候, 若返回-1, 且<code>errno</code>为<code>EAGAIN</code>, 则表示当前资源不可用, 也就是说缓冲区无数据(缓冲区的数据已经读完了); 或者当read返回的读到的数据长度小于请求的数据长度时，就可以确定此时缓冲区中已没有数据可读了，也就可以认为此时读事件已处理完成。</p>
</blockquote>
<p>epoll的边缘触发模式的非阻塞模式案例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> lfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">	setsockopt(lfd,SOL_SOCKET,SO_REUSEADDR,&amp;opt,<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	sockaddr_in serv;</span><br><span class="line">	serv.sin_family = AF_INET;</span><br><span class="line">	serv.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">	serv.sin_port = htons(<span class="number">23456</span>);</span><br><span class="line">	bind(lfd,(sockaddr*)&amp;serv,<span class="keyword">sizeof</span>(serv));</span><br><span class="line">	listen(lfd,<span class="number">2</span>);</span><br><span class="line">	<span class="type">int</span> epfd = epoll_create(<span class="number">1</span>);</span><br><span class="line">	<span class="comment">//将监听文件描述符上树</span></span><br><span class="line">	epoll_event ev;</span><br><span class="line">	ev.events = EPOLLIN;</span><br><span class="line">	ev.data.fd = lfd;</span><br><span class="line">	<span class="comment">//监听文件描述符上树</span></span><br><span class="line">	epoll_ctl(epfd,EPOLL_CTL_ADD,lfd,&amp;ev);</span><br><span class="line">	epoll_event events[<span class="number">1024</span>];</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> nready = epoll_wait(epfd,events,<span class="number">1024</span>,<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">if</span>(nready&lt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(errno == EINTR)<span class="comment">//信号中断</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nready;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//有客户端链接请求到来</span></span><br><span class="line">			<span class="type">int</span> sockfd = events[i].data.fd;</span><br><span class="line">			<span class="keyword">if</span>(sockfd == lfd)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//新连接的客户端通信描述符上监控树</span></span><br><span class="line">				<span class="type">int</span> cfd = accept(lfd,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">				ev.data.fd = cfd;</span><br><span class="line">				ev.events = EPOLLIN | EPOLLET;<span class="comment">//设置为ET模式</span></span><br><span class="line">				epoll_ctl(epfd,EPOLL_CTL_ADD,cfd,&amp;ev);</span><br><span class="line">				<span class="comment">//将cfd设置为非阻塞</span></span><br><span class="line">				<span class="type">int</span> flag = fcntl(cfd,F_GETFL);</span><br><span class="line">				flag |= O_NONBLOCK;</span><br><span class="line">				fcntl(cfd,F_SETFL,flag);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">char</span> buf[<span class="number">999</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">			<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//有客户端发送数据过来</span></span><br><span class="line">				<span class="type">int</span> n = read(sockfd,buf,<span class="number">2</span>);<span class="comment">//测试按照两个两个读,用于测试ET模式</span></span><br><span class="line">				<span class="keyword">if</span>(n == <span class="number">-1</span>)<span class="comment">//读完数据了,跳出读循环</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)<span class="comment">//对方关闭连接或读异常</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;断开&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">					close(sockfd);</span><br><span class="line">					<span class="comment">//下监控树</span></span><br><span class="line">					epoll_ctl(epfd,EPOLL_CTL_DEL,sockfd,<span class="literal">NULL</span>);</span><br><span class="line">					perror(<span class="string">&quot;read error of client close&quot;</span>);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span><span class="comment">//成功读到数据</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">cout</span>&lt;&lt;buf&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	close(lfd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="epoll反应堆"><a href="#epoll反应堆" class="headerlink" title="epoll反应堆"></a>epoll反应堆</h4><p>epoll反应堆的核心思想是: 在调用<code>epoll_ctl</code>函数的时候, 将events上树的时候,利用<code>epoll_data_t</code>的ptr成员, 将一个文件描述符,事件和回调函数封装成一个结构体, 然后让ptr指向这个结构体, 然后调用<code>epoll_wait</code>函数返回的时候, 可以得到具体的events, 然后获得events结构体中的events.data.ptr指针, ptr指针指向的结构体中有回调函数, 最终可以调用这个回调函数.</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202209161418081.png" alt="image-20220916141825428"></p>
<p>其实就是自己定义结构记录回调等信息放入ptr指向中(原本用于存放fd的联合体),在main中根据epoll通知,取ptr信息来自己调用回调以此实现了一个架构体系</p>
<p>核心代码如下:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202209171611664.png" alt="image-20220917161147604"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// epoll基于非阻塞I/O事件驱动</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;wrap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EVENTS  1024                                    <span class="comment">//监听上限数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFLEN      4096</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">recvdata</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> events, <span class="type">void</span> *arg)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">senddata</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> events, <span class="type">void</span> *arg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 描述就绪文件描述符相关信息 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myevent_s</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> fd;                                                 <span class="comment">//要监听的文件描述符</span></span><br><span class="line">    <span class="type">int</span> events;                                             <span class="comment">//对应的监听事件</span></span><br><span class="line">    <span class="type">void</span> *arg;                                              <span class="comment">//泛型参数</span></span><br><span class="line">    <span class="type">void</span> (*call_back)(<span class="type">int</span> fd, <span class="type">int</span> events, <span class="type">void</span> *arg);       <span class="comment">//回调函数</span></span><br><span class="line">    <span class="type">int</span> status;                                             <span class="comment">//是否在监听:1-&gt;在红黑树上(监听), 0-&gt;不在(不监听)</span></span><br><span class="line">    <span class="type">char</span> buf[BUFLEN];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">long</span> last_active;                                       <span class="comment">//记录每次加入红黑树 g_efd 的时间值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g_efd;                                                  <span class="comment">//全局变量, 保存epoll_create返回的文件描述符</span></span><br><span class="line"><span class="type">int</span> g_lfd;									<span class="comment">//全局变量, 保存监听的文件描述符</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myevent_s</span> <span class="title">g_events</span>[<span class="title">MAX_EVENTS</span>+1];</span>                    <span class="comment">//自定义结构体类型数组. +1--&gt;listen fd</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*将结构体 myevent_s 成员变量 初始化*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">eventset</span><span class="params">(<span class="keyword">struct</span> myevent_s *ev, <span class="type">int</span> fd, <span class="type">void</span> (*call_back)(<span class="type">int</span>, <span class="type">int</span>, <span class="type">void</span> *), <span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    ev-&gt;fd = fd;</span><br><span class="line">    ev-&gt;call_back = call_back;</span><br><span class="line">    ev-&gt;events = <span class="number">0</span>;</span><br><span class="line">    ev-&gt;arg = arg;</span><br><span class="line">    ev-&gt;status = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//memset(ev-&gt;buf, 0, sizeof(ev-&gt;buf));</span></span><br><span class="line">    <span class="comment">//ev-&gt;len = 0;</span></span><br><span class="line">    ev-&gt;last_active = time(<span class="literal">NULL</span>);    <span class="comment">//调用eventset函数的时间 unix时间戳</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向 epoll监听的红黑树 添加一个 文件描述符 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">eventadd</span><span class="params">(<span class="type">int</span> efd, <span class="type">int</span> events, <span class="keyword">struct</span> myevent_s *ev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epv</span> =</span> &#123;<span class="number">0</span>, &#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> op;</span><br><span class="line">    epv.data.ptr = ev;</span><br><span class="line">    epv.events = ev-&gt;events = events;       <span class="comment">//EPOLLIN 或 EPOLLOUT</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ev-&gt;status == <span class="number">1</span>)</span><br><span class="line">	&#123;                                          <span class="comment">//已经在红黑树 g_efd 里</span></span><br><span class="line">        op = EPOLL_CTL_MOD;                    <span class="comment">//修改其属性</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;                                <span class="comment">//不在红黑树里</span></span><br><span class="line">        op = EPOLL_CTL_ADD;          <span class="comment">//将其加入红黑树 g_efd, 并将status置1</span></span><br><span class="line">        ev-&gt;status = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (epoll_ctl(efd, op, ev-&gt;fd, &amp;epv) &lt; <span class="number">0</span>)                       <span class="comment">//实际添加/修改</span></span><br><span class="line">	&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;event add failed [fd=%d], events[%d]\n&quot;</span>, ev-&gt;fd, events);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;event add OK [fd=%d], op=%d, events[%0X]\n&quot;</span>, ev-&gt;fd, op, events);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从epoll 监听的 红黑树中删除一个 文件描述符*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">eventdel</span><span class="params">(<span class="type">int</span> efd, <span class="keyword">struct</span> myevent_s *ev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epv</span> =</span> &#123;<span class="number">0</span>, &#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ev-&gt;status != <span class="number">1</span>)                                        <span class="comment">//不在红黑树上</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    epv.data.ptr = ev;</span><br><span class="line">    ev-&gt;status = <span class="number">0</span>;                                             <span class="comment">//修改状态</span></span><br><span class="line">    epoll_ctl(efd, EPOLL_CTL_DEL, ev-&gt;fd, &amp;epv);                <span class="comment">//从红黑树 efd 上将 ev-&gt;fd 摘除</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  当有文件描述符就绪, epoll返回, 调用该函数 与客户端建立链接 */</span></span><br><span class="line"><span class="comment">// 回调函数 - 监听的文件描述符发送读事件时被调用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">acceptconn</span><span class="params">(<span class="type">int</span> lfd, <span class="type">int</span> events, <span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cin</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(<span class="built_in">cin</span>);</span><br><span class="line">    <span class="type">int</span> cfd, i;</span><br><span class="line"></span><br><span class="line">    cfd = Accept(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;<span class="built_in">cin</span>, &amp;len);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//使用do while(0)的目的是为了避免使用goto语句</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_EVENTS; i++)                                <span class="comment">//从全局数组g_events中找一个空闲元素</span></span><br><span class="line">		&#123;</span><br><span class="line">            <span class="keyword">if</span> (g_events[i].status == <span class="number">0</span>)                                <span class="comment">//类似于select中找值为-1的元素</span></span><br><span class="line">			&#123;</span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">//找到第一个能用的                                                //跳出 for</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i == MAX_EVENTS)</span><br><span class="line">		&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: max connect limit[%d]\n&quot;</span>, __func__, MAX_EVENTS);</span><br><span class="line">            <span class="keyword">break</span>;   <span class="comment">//避免goto, 跳出do while(0) 不执行后续代码</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将cfd设置为非阻塞</span></span><br><span class="line">        <span class="type">int</span> flags = <span class="number">0</span>;</span><br><span class="line">		flags = fcntl(cfd, F_GETFL, <span class="number">0</span>);</span><br><span class="line">		flags |= O_NONBLOCK;</span><br><span class="line">        <span class="keyword">if</span> ((flags = fcntl(cfd, F_SETFL, flags)) &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: fcntl nonblocking failed, %s\n&quot;</span>, __func__, strerror(errno));</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//避免goto</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 给cfd设置一个 myevent_s 结构体, 回调函数 设置为 recvdata */</span></span><br><span class="line">        eventset(&amp;g_events[i], cfd, recvdata, &amp;g_events[i]);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将cfd添加到红黑树g_efd中,监听读事件</span></span><br><span class="line">        eventadd(g_efd, EPOLLIN, &amp;g_events[i]);</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;new connect [%s:%d][time:%ld], pos[%d]\n&quot;</span>,</span><br><span class="line">            inet_ntoa(<span class="built_in">cin</span>.sin_addr), ntohs(<span class="built_in">cin</span>.sin_port), g_events[i].last_active, i);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数 - 通信的文件描述符发生读事件时候被调用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">recvdata</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> events, <span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">myevent_s</span> *<span class="title">ev</span> =</span> (<span class="keyword">struct</span> myevent_s *)arg;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//读取客户端发来的数据</span></span><br><span class="line">	<span class="built_in">memset</span>(ev-&gt;buf, <span class="number">0x00</span>, <span class="keyword">sizeof</span>(ev-&gt;buf));</span><br><span class="line">    len = Read(fd, ev-&gt;buf, <span class="keyword">sizeof</span>(ev-&gt;buf));<span class="comment">//读文件描述符, 数据存入myevent_s成员buf中</span></span><br><span class="line"></span><br><span class="line">    eventdel(g_efd, ev); <span class="comment">//将该节点从红黑树上摘除</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">        ev-&gt;len = len;</span><br><span class="line">        ev-&gt;buf[len] = <span class="string">&#x27;\0&#x27;</span>;                                <span class="comment">//手动添加字符串结束标记</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;C[%d]:%s\n&quot;</span>, fd, ev-&gt;buf);</span><br><span class="line"></span><br><span class="line">        eventset(ev, fd, senddata, ev);                     <span class="comment">//设置该 fd 对应的回调函数为 senddata</span></span><br><span class="line">        eventadd(g_efd, EPOLLOUT, ev);                      <span class="comment">//将fd加入红黑树g_efd中,监听其写事件</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">        Close(ev-&gt;fd);</span><br><span class="line">        <span class="comment">/* ev-g_events 地址相减得到偏移元素位置 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[fd=%d] pos[%ld], closed\n&quot;</span>, fd, ev-g_events);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">        Close(ev-&gt;fd);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read [fd=%d] error[%d]:%s\n&quot;</span>, fd, errno, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数 - 通信的文件描述符发生写事件时候被调用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">senddata</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> events, <span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">myevent_s</span> *<span class="title">ev</span> =</span> (<span class="keyword">struct</span> myevent_s *)arg;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将小写转换为大写发送给客户端</span></span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;ev-&gt;len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ev-&gt;buf[i] = <span class="built_in">toupper</span>(ev-&gt;buf[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//发送数据给客户端</span></span><br><span class="line">    len = Write(fd, ev-&gt;buf, ev-&gt;len);</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;send[fd=%d]--&gt;[%d]:[%s]\n&quot;</span>, fd, len, ev-&gt;buf);</span><br><span class="line">        eventdel(g_efd, ev);                                <span class="comment">//从红黑树g_efd中移除</span></span><br><span class="line">        eventset(ev, fd, recvdata, ev);                     <span class="comment">//将该fd的 回调函数改为 recvdata</span></span><br><span class="line">        eventadd(g_efd, EPOLLIN, ev);                       <span class="comment">//从新添加到红黑树上， 设为监听读事件</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">        Close(ev-&gt;fd);                                      <span class="comment">//关闭链接</span></span><br><span class="line">        eventdel(g_efd, ev);                                <span class="comment">//从红黑树g_efd中移除</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;send[fd=%d] error %s\n&quot;</span>, fd, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建 socket, 初始化lfd */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">initlistensocket</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//创建socket</span></span><br><span class="line">    g_lfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//对事件结构体赋值</span></span><br><span class="line">    <span class="comment">/* void eventset(struct myevent_s *ev, int fd, void (*call_back)(int, int, void *), void *arg);  */</span></span><br><span class="line">    eventset(&amp;g_events[MAX_EVENTS], g_lfd, acceptconn, &amp;g_events[MAX_EVENTS]);<span class="comment">//仅仅是对g_events[MAX_EVENTS]进行设置</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//将监听文件描述符上树</span></span><br><span class="line">    eventadd(g_efd, EPOLLIN, &amp;g_events[MAX_EVENTS]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">	servaddr.sin_port = htons(<span class="number">23456</span>);</span><br><span class="line">	Bind(g_lfd, (<span class="keyword">struct</span> sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">	Listen(g_lfd, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    g_efd = epoll_create(MAX_EVENTS+<span class="number">1</span>);                 <span class="comment">//创建红黑树,返回给全局 g_efd</span></span><br><span class="line">	<span class="keyword">if</span>(g_efd&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">&quot;create epoll error&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//socket-bind-listen-初始化socket并将监听文件描述符上树</span></span><br><span class="line">    initlistensocket();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">MAX_EVENTS</span>+1];</span>            <span class="comment">//保存已经满足就绪事件的文件描述符数组</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> checkpos = <span class="number">0</span>, i;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">/* 超时验证，每次测试100个链接，不测试listenfd 当客户端60秒内没有和服务器通信，则关闭此客户端链接 */</span></span><br><span class="line">        <span class="type">long</span> now = time(<span class="literal">NULL</span>);                          <span class="comment">//当前时间</span></span><br><span class="line">		<span class="comment">//一次循环检测100个。 使用checkpos控制检测对象</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++, checkpos++)</span><br><span class="line">		&#123;</span><br><span class="line">            <span class="keyword">if</span> (checkpos == MAX_EVENTS)</span><br><span class="line">			&#123;</span><br><span class="line">                checkpos = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g_events[checkpos].status != <span class="number">1</span>)         <span class="comment">//不在红黑树 g_efd 上</span></span><br><span class="line">			&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">long</span> duration = now - g_events[checkpos].last_active;       <span class="comment">//客户端不活跃的世间</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (duration &gt;= <span class="number">60</span>)</span><br><span class="line">			&#123;</span><br><span class="line">                Close(g_events[checkpos].fd);                           <span class="comment">//关闭与该客户端链接</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[fd=%d] timeout\n&quot;</span>, g_events[checkpos].fd);</span><br><span class="line">                eventdel(g_efd, &amp;g_events[checkpos]);                   <span class="comment">//将该客户端 从红黑树 g_efd移除</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*监听红黑树g_efd, 将满足的事件的文件描述符加至events数组中, 1秒没有事件满足, 返回 0*/</span></span><br><span class="line">        <span class="type">int</span> nfd = epoll_wait(g_efd, events, MAX_EVENTS+<span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">if</span> (nfd &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;epoll_wait error, exit\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nfd; i++)</span><br><span class="line">		&#123;</span><br><span class="line">            <span class="comment">/*使用自定义结构体myevent_s类型指针,接收联合体data的void *ptr成员*/</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">myevent_s</span> *<span class="title">ev</span> =</span> (<span class="keyword">struct</span> myevent_s *)events[i].data.ptr;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//读就绪事件</span></span><br><span class="line">            <span class="keyword">if</span> ((events[i].events &amp; EPOLLIN) &amp;&amp; (ev-&gt;events &amp; EPOLLIN))</span><br><span class="line">			&#123;</span><br><span class="line">                <span class="comment">//ev-&gt;call_back(ev-&gt;fd, events[i].events, ev-&gt;arg);</span></span><br><span class="line">                ev-&gt;call_back(ev-&gt;fd, events[i].events, ev);<span class="comment">//调用回调函数</span></span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//写就绪事件</span></span><br><span class="line">            <span class="keyword">if</span> ((events[i].events &amp; EPOLLOUT) &amp;&amp; (ev-&gt;events &amp; EPOLLOUT))</span><br><span class="line">			&#123;</span><br><span class="line">                <span class="comment">//ev-&gt;call_back(ev-&gt;fd, events[i].events, ev-&gt;arg);</span></span><br><span class="line">                ev-&gt;call_back(ev-&gt;fd, events[i].events, ev);<span class="comment">//调用回调函数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">/*关闭文件描述符 */</span></span><br><span class="line">	Close(g_efd);</span><br><span class="line">	Close(g_lfd);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>一个抽象的概念, 若干个线程组合到一起, 形成线程池.</p>
<blockquote>
<p>为什么需要线程池?<br>    多线程版服务器一个客户端就需要创建一个线程! 若客户端太多, 显然不太合适.<br>    什么时候需要创建线程池呢？简单的说，如果一个应用需要频繁的创建和销毁线程，而任务执行的时间又非常短，这样线程创建和销毁的带来的开销就不容忽视，这时也是线程池该出场的机会了。<strong>如果线程创建和销毁时间相比任务执行时间可以忽略不计，则没有必要使用线程池了,此时可以考虑协程(C++20)。</strong><br>    实现的时候类似于生产者和消费者.</p>
</blockquote>
<p><strong>wrap.c</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">perr_exit</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line">	perror(s);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Accept</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> sockaddr *sa, <span class="type">socklen_t</span> *salenptr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line">	<span class="keyword">if</span> ((n = accept(fd, sa, salenptr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((errno == ECONNABORTED) || (errno == EINTR))</span><br><span class="line">			<span class="keyword">goto</span> again;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			perr_exit(<span class="string">&quot;accept error&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Bind</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *sa, <span class="type">socklen_t</span> salen)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((n = bind(fd, sa, salen)) &lt; <span class="number">0</span>)</span><br><span class="line">		perr_exit(<span class="string">&quot;bind error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Connect</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *sa, <span class="type">socklen_t</span> salen)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((n = connect(fd, sa, salen)) &lt; <span class="number">0</span>)</span><br><span class="line">		perr_exit(<span class="string">&quot;connect error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Listen</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> backlog)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((n = listen(fd, backlog)) &lt; <span class="number">0</span>)</span><br><span class="line">		perr_exit(<span class="string">&quot;listen error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Socket</span><span class="params">(<span class="type">int</span> family, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((n = socket(family, type, protocol)) &lt; <span class="number">0</span>)</span><br><span class="line">		perr_exit(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *ptr, <span class="type">size_t</span> nbytes)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">ssize_t</span> n;</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line">	<span class="keyword">if</span> ( (n = read(fd, ptr, nbytes)) == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">			<span class="keyword">goto</span> again;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> nbytes)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">ssize_t</span> n;</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line">	<span class="keyword">if</span> ( (n = write(fd, ptr, nbytes)) == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">			<span class="keyword">goto</span> again;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Close</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">	<span class="keyword">if</span> ((n = close(fd)) == <span class="number">-1</span>)</span><br><span class="line">		perr_exit(<span class="string">&quot;close error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*参三: 应该读取的字节数*/</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Readn</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *vptr, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">size_t</span>  nleft;              <span class="comment">//usigned int 剩余未读取的字节数</span></span><br><span class="line">	<span class="type">ssize_t</span> nread;              <span class="comment">//int 实际读到的字节数</span></span><br><span class="line">	<span class="type">char</span>   *ptr;</span><br><span class="line"></span><br><span class="line">	ptr = vptr;</span><br><span class="line">	nleft = n;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (nleft &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((nread = read(fd, ptr, nleft)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">				nread = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		nleft -= nread;</span><br><span class="line">		ptr += nread;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n - nleft;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Writen</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *vptr, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">size_t</span> nleft;</span><br><span class="line">	<span class="type">ssize_t</span> nwritten;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *ptr;</span><br><span class="line"></span><br><span class="line">	ptr = vptr;</span><br><span class="line">	nleft = n;</span><br><span class="line">	<span class="keyword">while</span> (nleft &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> ( (nwritten = write(fd, ptr, nleft)) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nwritten &lt; <span class="number">0</span> &amp;&amp; errno == EINTR)</span><br><span class="line">				nwritten = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		nleft -= nwritten;</span><br><span class="line">		ptr += nwritten;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">my_read</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> read_cnt;</span><br><span class="line">	<span class="type">static</span> <span class="type">char</span> *read_ptr;</span><br><span class="line">	<span class="type">static</span> <span class="type">char</span> read_buf[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (read_cnt &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">again:</span><br><span class="line">		<span class="keyword">if</span> ( (read_cnt = read(fd, read_buf, <span class="keyword">sizeof</span>(read_buf))) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">				<span class="keyword">goto</span> again;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (read_cnt == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		read_ptr = read_buf;</span><br><span class="line">	&#125;</span><br><span class="line">	read_cnt--;</span><br><span class="line">	*ptr = *read_ptr++;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Readline</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *vptr, <span class="type">size_t</span> maxlen)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">ssize_t</span> n, rc;</span><br><span class="line">	<span class="type">char</span>    c, *ptr;</span><br><span class="line"></span><br><span class="line">	ptr = vptr;</span><br><span class="line">	<span class="keyword">for</span> (n = <span class="number">1</span>; n &lt; maxlen; n++) &#123;</span><br><span class="line">		<span class="keyword">if</span> ( (rc = my_read(fd, &amp;c)) == <span class="number">1</span>) &#123;</span><br><span class="line">			*ptr++ = c;</span><br><span class="line">			<span class="keyword">if</span> (c  == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">			*ptr = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	*ptr  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">tcp4bind</span><span class="params">(<span class="type">short</span> port,<span class="type">const</span> <span class="type">char</span> *IP)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="type">int</span> lfd = Socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    bzero(&amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    <span class="keyword">if</span>(IP == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">//如果这样使用 0.0.0.0,任意ip将可以连接</span></span><br><span class="line">        serv_addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inet_pton(AF_INET,IP,&amp;serv_addr.sin_addr.s_addr) &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            perror(IP);<span class="comment">//转换失败</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port   = htons(port);</span><br><span class="line">    Bind(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    <span class="keyword">return</span> lfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>wrap.h</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __WRAP_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __WRAP_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">perr_exit</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Accept</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> sockaddr *sa, <span class="type">socklen_t</span> *salenptr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Bind</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *sa, <span class="type">socklen_t</span> salen)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Connect</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *sa, <span class="type">socklen_t</span> salen)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Listen</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> backlog)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Socket</span><span class="params">(<span class="type">int</span> family, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *ptr, <span class="type">size_t</span> nbytes)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> nbytes)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Readn</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *vptr, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Writen</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *vptr, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">my_read</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *ptr)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Readline</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *vptr, <span class="type">size_t</span> maxlen)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">tcp4bind</span><span class="params">(<span class="type">short</span> port,<span class="type">const</span> <span class="type">char</span> *IP)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p> <strong>线程池和任务池:</strong><br>任务池相当于共享资源, 所以需要使用互斥锁, 当任务池中没有任务的时候需要让线程阻塞, 所以需要使用条件变量.</p>
<p><strong>如何让线程执行不同的任务?</strong><br>使用回调函数, 在任务中设置任务执行函数, 这样可以起到不同的任务执行不同的函数.</p>
<p><strong>线程相关函数</strong></p>
<ul>
<li>创建子线程    <code>pthread_create</code></li>
<li>线程退出   <code>pthread_exit</code></li>
<li>设置子线程为分离属性    <code>pthread_detach</code></li>
</ul>
<p>涉及到任务池共享资源的互斥访问,<strong>因此需要互斥锁相关的函数</strong></p>
<ul>
<li>初始化互斥锁    <code>pthread_mutex_init</code>  </li>
<li>互斥锁加&#x2F;解锁   <code>pthread_mutex_lock/unlock</code></li>
<li>销毁互斥锁    <code>pthread_mutex_destroy</code></li>
</ul>
<p>若任务池已满,主线程应该阻塞等待子线程处理任务<br>若任务池空了,子线程应该阻塞等待主线程往任务池中添加任务<br><strong>因此需要涉及条件变量相关函数</strong></p>
<ul>
<li>堵塞   <code>pthread_cond_wait</code></li>
<li>唤醒至少一个阻塞在该条件变量上的线程   <code>pthread_cond_signal</code></li>
<li>初始化条件变量   <code>pthread_cond_init</code></li>
<li>销毁条件变量   <code>pthread_cond_destroy</code></li>
<li>唤醒所有条件变量   <code>pthread_cond_broadcast</code></li>
</ul>
<h4 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h4><p>[[linux基础以及系统编程#线程相关函数|pthread是linux支持的线程操作api]]</p>
<h5 id="简单版本代码"><a href="#简单版本代码" class="headerlink" title="简单版本代码:"></a><strong>简单版本代码</strong>:</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> beginNum=<span class="number">0</span>;<span class="comment">//任务编号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//任务池中的任务项结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PoolTask</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> tasknum;<span class="comment">//任务编号</span></span><br><span class="line">    <span class="type">void</span>* arg;<span class="comment">//回调函数参数</span></span><br><span class="line">    <span class="type">void</span> (*task_func)(<span class="type">void</span>* arg);<span class="comment">//回调函数</span></span><br><span class="line">&#125;PoolTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程池</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ThreadPool</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> maxJobNum;<span class="comment">//最大任务数</span></span><br><span class="line">    <span class="type">int</span> jobNum;<span class="comment">//实际任务数</span></span><br><span class="line">    PoolTask* tasks;<span class="comment">//任务队列数组</span></span><br><span class="line">    <span class="type">int</span> jobPush;<span class="comment">//入任务队列位置</span></span><br><span class="line">    <span class="type">int</span> jobPop;<span class="comment">//出任务队列位置</span></span><br><span class="line">    <span class="type">int</span> threadNum;<span class="comment">//线程数</span></span><br><span class="line">    <span class="type">pthread_t</span>* threads;<span class="comment">//线程池内线程数组</span></span><br><span class="line">    <span class="type">int</span> shutDown;<span class="comment">//是否关闭线程池的标识   0表示不摧毁线程池,1表示摧毁线程池</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> poolLock;<span class="comment">//线程池的锁</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> emptyTask;<span class="comment">//任务队列有位置的条件变量,主线程插入时等待有位置插入</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> notEmptyTask;<span class="comment">//任务队列不是空的条件变量,子线程执行时的等待他不是空</span></span><br><span class="line">&#125;ThreadPool;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">threadRun</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    ThreadPool *thePool = arg;</span><br><span class="line">    PoolTask *theTask = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(PoolTask)); </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;thePool-&gt;poolLock);</span><br><span class="line">        <span class="keyword">while</span> (thePool-&gt;jobNum == <span class="number">0</span> &amp;&amp; !thePool-&gt;shutDown)</span><br><span class="line">            pthread_cond_wait(&amp;thePool-&gt;notEmptyTask, &amp;thePool-&gt;poolLock);</span><br><span class="line">        <span class="keyword">if</span>(thePool-&gt;jobNum)<span class="comment">//此处还要再判断任务数量的原因是:会有多个线程堵塞在上面pthread_cond_wait处,直接会有多个线程同时过了上一个任务数量检测,因此此处才是真正的确保有任务才执行</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//为什么要拷贝?避免任务被修改,生产者会添加任务</span></span><br><span class="line">            <span class="built_in">memcpy</span>(theTask,&amp;thePool-&gt;tasks[thePool-&gt;jobPop % thePool-&gt;maxJobNum],<span class="keyword">sizeof</span>(PoolTask));<span class="comment">//模拟循环队列取值</span></span><br><span class="line">            thePool-&gt;jobPop++;</span><br><span class="line">            thePool-&gt;jobNum--; <span class="comment">//执行完一个任务,任务数减一</span></span><br><span class="line">            pthread_cond_signal(&amp;thePool-&gt;emptyTask); <span class="comment">//通知主线程可以插入新任务了</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (thePool-&gt;shutDown)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;thePool-&gt;poolLock);</span><br><span class="line">            <span class="built_in">free</span>(theTask);</span><br><span class="line">            pthread_exit(<span class="literal">NULL</span>);<span class="comment">//退出线程</span></span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;thePool-&gt;poolLock);</span><br><span class="line">        <span class="comment">//printf(&quot;arg:%d&quot;,(int)theTask-&gt;arg);</span></span><br><span class="line">        theTask-&gt;task_func(theTask-&gt;arg);<span class="comment">//释放完锁再自己执行自己的任务(回调函数)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建线程池</span></span><br><span class="line">ThreadPool* <span class="title function_">createThreadPool</span><span class="params">(<span class="type">int</span> threadNum,<span class="type">int</span> maxTaskNum)</span></span><br><span class="line">&#123;</span><br><span class="line">    ThreadPool* pool = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ThreadPool));</span><br><span class="line">    <span class="built_in">memset</span>(pool,<span class="number">0</span>,<span class="keyword">sizeof</span>(ThreadPool));</span><br><span class="line">    pool-&gt;maxJobNum = maxTaskNum;</span><br><span class="line">    pool-&gt;threadNum = threadNum;</span><br><span class="line">    <span class="comment">//printf(&quot;%s  %d,%d\n&quot;,__FUNCTION__,pool-&gt;maxJobNum,pool-&gt;jobNum);</span></span><br><span class="line">    pool-&gt;tasks = <span class="built_in">malloc</span>(maxTaskNum*<span class="keyword">sizeof</span>(PoolTask));</span><br><span class="line">    pool-&gt;threads = <span class="built_in">malloc</span>(threadNum*<span class="keyword">sizeof</span>(<span class="type">pthread_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pthread_mutex_init(&amp;pool-&gt;poolLock,<span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(pool-&gt;tasks);</span><br><span class="line">        <span class="built_in">free</span>(pool-&gt;threads);</span><br><span class="line">        perror(<span class="string">&quot;[error]&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_cond_init(&amp;pool-&gt;emptyTask,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;pool-&gt;notEmptyTask,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">pthread_attr_t</span> attr;</span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr,PTHREAD_CREATE_DETACHED);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; threadNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        <span class="type">int</span> iRet = pthread_create(&amp;pool-&gt;threads[i],&amp;attr,threadRun,(<span class="type">void</span>*)pool);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pool;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//摧毁线程池</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">destroyThreadPool</span><span class="params">(ThreadPool *pool)</span></span><br><span class="line">&#123;</span><br><span class="line">    pool-&gt;shutDown = <span class="number">1</span>;<span class="comment">//让子线程准备自己结束自己</span></span><br><span class="line">    pthread_cond_broadcast(&amp;pool-&gt;notEmptyTask);<span class="comment">//通知所有子线程解除阻塞诱杀</span></span><br><span class="line">    <span class="comment">//由于已经设置了线程分离,因此下面代码不需要了</span></span><br><span class="line">    <span class="comment">// for (int i = 0; i &lt; pool-&gt;threadNum; i++)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     pthread_join(pool-&gt;threads[i],NULL);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    pthread_cond_destroy(&amp;pool-&gt;notEmptyTask);</span><br><span class="line">    pthread_cond_destroy(&amp;pool-&gt;emptyTask);</span><br><span class="line">    pthread_mutex_destroy(&amp;pool-&gt;poolLock);</span><br><span class="line">    <span class="built_in">free</span>(pool-&gt;tasks);</span><br><span class="line">    <span class="built_in">free</span>(pool-&gt;threads);</span><br><span class="line">    <span class="built_in">free</span>(pool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加任务到线程池,由主线程调用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">addTask</span><span class="params">(ThreadPool *pool,<span class="type">void</span> taskRun (<span class="type">void</span>*),<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;pool-&gt;poolLock);<span class="comment">//先加锁</span></span><br><span class="line">    <span class="comment">//printf(&quot;%s  任务编号为:%d\n&quot;,__FUNCTION__,(int)arg);</span></span><br><span class="line">    <span class="comment">//printf(&quot;%s  %d&lt;=%d\n&quot;,__FUNCTION__,pool-&gt;maxJobNum,pool-&gt;jobNum);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(pool-&gt;maxJobNum&lt;=pool-&gt;jobNum)</span><br><span class="line">        pthread_cond_wait(&amp;pool-&gt;emptyTask,&amp;pool-&gt;poolLock);</span><br><span class="line">    <span class="type">int</span> taskPos = pool-&gt;jobPush%pool-&gt;maxJobNum;<span class="comment">//模拟循环队列</span></span><br><span class="line">    pool-&gt;jobPush++;<span class="comment">//插入位置往后移动</span></span><br><span class="line">    pool-&gt;tasks[taskPos].tasknum = beginNum++;</span><br><span class="line">    pool-&gt;tasks[taskPos].arg = arg;<span class="comment">//参数指向任务结构体本身</span></span><br><span class="line">    pool-&gt;tasks[taskPos].task_func = taskRun;<span class="comment">//设置回调函数</span></span><br><span class="line">    pool-&gt;jobNum++;</span><br><span class="line">    pthread_mutex_unlock(&amp;pool-&gt;poolLock);</span><br><span class="line">    pthread_cond_signal(&amp;pool-&gt;notEmptyTask);<span class="comment">//通知子线程解除阻塞,去执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">taskRun</span><span class="params">(<span class="type">void</span>* taskNum)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前执行任务编号为:%d\n&quot;</span>,(<span class="type">int</span>)taskNum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ThreadPool* pool = createThreadPool(<span class="number">3</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        addTask(pool,taskRun,i);</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;主线程结束!\n&quot;</span>);</span><br><span class="line">    destroyThreadPool(pool);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="复杂版本"><a href="#复杂版本" class="headerlink" title="复杂版本"></a><strong>复杂版本</strong></h5><p>比起简单版本,添加了<strong>动态线程管理</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_TIME 10                 <span class="comment">/*10s检测一次线程空闲情况*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_WAIT_TASK_NUM 10            <span class="comment">/*如果queue_size &gt; MIN_WAIT_TASK_NUM 添加新的线程到线程池*/</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_THREAD_VARY 10          <span class="comment">/*每次创建和销毁线程的个数*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> true 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> false 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//任务池中的任务项结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">threadpool_task</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">void</span>* arg;<span class="comment">//回调函数参数</span></span><br><span class="line">    <span class="type">void</span>* (*function)(<span class="type">void</span>* arg);<span class="comment">//回调函数</span></span><br><span class="line">&#125;threadpool_task;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程池</span></span><br><span class="line"><span class="comment">/* 描述线程池相关信息 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">threadpool_t</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> lock;               <span class="comment">/* 用于锁住本结构体 */</span>    </span><br><span class="line">    <span class="type">pthread_mutex_t</span> threadCounter;     <span class="comment">/* 记录忙状态线程个数的锁 锁的目标为 - busyThrNum */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_cond_t</span> queueNotFull;      <span class="comment">/* 当任务队列满时，添加任务的线程阻塞，等待此条件变量 */</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> queueNotEmpty;     <span class="comment">/* 任务队列里不为空时，通知等待任务的线程 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> *threads;                 <span class="comment">/* 存放线程池中每个线程的tid。数组 */</span></span><br><span class="line">    <span class="type">pthread_t</span> adjustTid;               <span class="comment">/* 存管理线程tid   管理者线程工作:根据任务数多少动态调节子线程数量 */</span></span><br><span class="line">    threadpool_task *taskQueue;      <span class="comment">/* 任务队列(数组首地址) */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> minThrNum;                    <span class="comment">/* 线程池最小线程数 */</span></span><br><span class="line">    <span class="type">int</span> maxThrNum;                    <span class="comment">/* 线程池最大线程数 */</span></span><br><span class="line">    <span class="type">int</span> liveThrNum;                   <span class="comment">/* 当前存活线程个数 */</span></span><br><span class="line">    <span class="type">int</span> busyThrNum;                   <span class="comment">/* 忙状态线程个数 */</span></span><br><span class="line">    <span class="type">int</span> waitExitThrNum;              <span class="comment">/* 要销毁的线程个数 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> queueFront;                    <span class="comment">/* taskQueue队头下标(执行任务的下标) */</span></span><br><span class="line">    <span class="type">int</span> queueRear;                     <span class="comment">/* taskQueue队尾下标(插入任务的下标) */</span></span><br><span class="line">    <span class="type">int</span> queueSize;                     <span class="comment">/* taskQueue队中实际任务数 */</span></span><br><span class="line">    <span class="type">int</span> queueMaxSize;                 <span class="comment">/* taskQueue队列可容纳任务数上限 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> shutdown;                       <span class="comment">/* 标志位，线程池使用状态，true或false */</span></span><br><span class="line">&#125;<span class="type">threadpool_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程执行函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">threadPoolThread</span><span class="params">(<span class="type">void</span>* threadPool)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">threadpool_t</span>* pool = (<span class="type">threadpool_t</span>*)threadPool;</span><br><span class="line">    threadpool_task task;<span class="comment">//用于先存储要执行的任务</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;pool-&gt;lock);</span><br><span class="line">        <span class="keyword">while</span> (pool-&gt;queueSize == <span class="number">0</span> &amp;&amp; !pool-&gt;shutdown)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_cond_wait(&amp;pool-&gt;queueNotEmpty,&amp;pool-&gt;lock);</span><br><span class="line">            <span class="comment">//被管理者线程标记为要删除的线程自己退出  </span></span><br><span class="line">            <span class="comment">//如果有需要退出的线程数</span></span><br><span class="line">            <span class="keyword">if</span>(pool-&gt;waitExitThrNum &gt; <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                pool-&gt;waitExitThrNum -- ;</span><br><span class="line">                <span class="comment">//如果线程池里线程个数大于最小值时可以结束当前线程</span></span><br><span class="line">                <span class="keyword">if</span>(pool-&gt;liveThrNum&gt;pool-&gt;minThrNum)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;[%s():%d] thread 0x%x is exiting for adjust\n&quot;</span>,__FUNCTION__,__LINE__,(<span class="type">unsigned</span> <span class="type">int</span>)pthread_self());</span><br><span class="line">                    pool-&gt;liveThrNum--;</span><br><span class="line">                    pthread_mutex_unlock(&amp;pool-&gt;lock);</span><br><span class="line">                    pthread_exit(<span class="literal">NULL</span>);<span class="comment">//退出线程</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pool-&gt;shutdown)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;pool-&gt;lock);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%s():%d] thread 0x%x is exiting for shutdown\n&quot;</span>,__FUNCTION__,__LINE__,(<span class="type">unsigned</span> <span class="type">int</span>)pthread_self());</span><br><span class="line">            pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pool-&gt;queueSize&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(&amp;task,&amp;pool-&gt;taskQueue[pool-&gt;queueFront],<span class="keyword">sizeof</span>(threadpool_task));</span><br><span class="line">            pool-&gt;queueFront = (pool-&gt;queueFront+<span class="number">1</span>)%pool-&gt;queueMaxSize;</span><br><span class="line">            pool-&gt;queueSize--;</span><br><span class="line">            pthread_cond_signal(&amp;pool-&gt;queueNotFull);</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;pool-&gt;lock);</span><br><span class="line">        <span class="comment">//准备执行任务,忙碌数+1</span></span><br><span class="line">        pthread_mutex_lock(&amp;pool-&gt;busyThrNum);</span><br><span class="line">        pool-&gt;busyThrNum++;</span><br><span class="line">        pthread_mutex_unlock(&amp;pool-&gt;busyThrNum);</span><br><span class="line">        (*task.function)(task.arg);</span><br><span class="line">        <span class="comment">//执行完任务,忙碌数-1</span></span><br><span class="line">         pthread_mutex_lock(&amp;pool-&gt;busyThrNum);</span><br><span class="line">        pool-&gt;busyThrNum--;</span><br><span class="line">        pthread_mutex_unlock(&amp;pool-&gt;busyThrNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断线程是否还存活</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isThreadAlive</span><span class="params">(<span class="type">pthread_t</span> tid)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> kill_rc = pthread_kill(tid,<span class="number">0</span>);<span class="comment">//发0号信号,测试线程是否存活</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(kill_rc!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(kill_rc == ESRCH)<span class="comment">//线程id不存在,表示线程未存活</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调整线程(管理线程的执行函数)</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">adjustThread</span><span class="params">(<span class="type">void</span>* threadPool)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%s():%d] start manager thread 0x%x...\n&quot;</span>,__FUNCTION__,__LINE__,(<span class="type">unsigned</span> <span class="type">int</span>)pthread_self());</span><br><span class="line">    <span class="type">threadpool_t</span>* pool = (<span class="type">threadpool_t</span> *)threadPool;</span><br><span class="line">    <span class="keyword">while</span>(!pool-&gt;shutdown)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(DEFAULT_TIME);<span class="comment">//定时执行</span></span><br><span class="line">        pthread_mutex_lock(&amp;pool-&gt;lock);<span class="comment">//只是读操作为什么要加锁?</span></span><br><span class="line">        <span class="type">int</span> queueSize = pool-&gt;queueSize;<span class="comment">//获取任务数</span></span><br><span class="line">        <span class="type">int</span> liveThrNum = pool-&gt;liveThrNum;<span class="comment">//获取存活线程数</span></span><br><span class="line">        pthread_mutex_unlock(&amp;pool-&gt;lock);</span><br><span class="line">        pthread_mutex_lock(&amp;pool-&gt;threadCounter);</span><br><span class="line">        <span class="type">int</span> busyThrNum = pool-&gt;busyThrNum;<span class="comment">//获取忙碌线程数</span></span><br><span class="line">        pthread_mutex_unlock(&amp;pool-&gt;threadCounter);</span><br><span class="line">        <span class="comment">//printf(&quot;[%s():%d] manager get info...\n&quot;,__FUNCTION__,__LINE__);</span></span><br><span class="line">        <span class="comment">//创建新线程算法   (任务数大于设置的最小等待任务个数,且存活的线程数少于最大线程数)</span></span><br><span class="line">        <span class="keyword">if</span>(queueSize&gt;=MIN_WAIT_TASK_NUM &amp;&amp; liveThrNum&lt;pool-&gt;maxThrNum)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_lock(&amp;pool-&gt;lock);</span><br><span class="line">            <span class="type">int</span> add = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//在线程数组中找空位或者已经死亡的线程位置插入DEFAULT_THREAD_VARY个新线程</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pool-&gt;maxThrNum&amp;&amp;add&lt;DEFAULT_THREAD_VARY&amp;&amp;pool-&gt;liveThrNum&lt;pool-&gt;maxThrNum; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(pool-&gt;threads[i]==<span class="number">0</span> || !isThreadAlive(pool-&gt;threads[i]))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;[%s():%d] create new Thread\n&quot;</span>,__FUNCTION__,__LINE__);</span><br><span class="line">                    pthread_create(&amp;pool-&gt;threads[i],<span class="literal">NULL</span>,threadPoolThread,(<span class="type">void</span>*)pool);</span><br><span class="line">                    add++;</span><br><span class="line">                    pool-&gt;liveThrNum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            pthread_mutex_unlock(&amp;pool-&gt;lock);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//销毁多余线程算法   忙碌线程小于存活线程的一半并且存活线程大于最小线程,就清理一部分线程(EFAULT_THREAD_VARY&lt;liveThrNum为自行添加,感觉需要)</span></span><br><span class="line">        <span class="keyword">if</span> ((busyThrNum * <span class="number">2</span>) &lt; liveThrNum  &amp;&amp;  liveThrNum &gt; pool-&gt;minThrNum&amp;&amp;DEFAULT_THREAD_VARY&lt;liveThrNum) </span><br><span class="line">		&#123;</span><br><span class="line">            <span class="comment">/* 一次销毁DEFAULT_THREAD个线程, 隨機10個即可 */</span></span><br><span class="line">            pthread_mutex_lock(&amp;(pool-&gt;lock));</span><br><span class="line">            pool-&gt;waitExitThrNum = DEFAULT_THREAD_VARY;      <span class="comment">/* 要销毁的线程数 设置为10 */</span></span><br><span class="line">            pthread_mutex_unlock(&amp;(pool-&gt;lock));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; DEFAULT_THREAD_VARY; i++) </span><br><span class="line">			&#123;</span><br><span class="line">                <span class="comment">/* 通知处在空闲状态的线程, 他们会自行终止*/</span></span><br><span class="line">                pthread_cond_signal(&amp;(pool-&gt;queueNotEmpty));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%s():%d] manager thread 0x%x  exit for shutdown\n&quot;</span>,__FUNCTION__,__LINE__,(<span class="type">unsigned</span> <span class="type">int</span>)pthread_self());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放线程池</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">threadpool_free</span><span class="params">(<span class="type">threadpool_t</span> *pool)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pool == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pool-&gt;taskQueue)</span><br><span class="line">        <span class="built_in">free</span>(pool-&gt;taskQueue);</span><br><span class="line">    <span class="keyword">if</span> (pool-&gt;threads)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(pool-&gt;threads);</span><br><span class="line">        pthread_mutex_lock(&amp;pool-&gt;lock);<span class="comment">//占下了才释放!</span></span><br><span class="line">        pthread_mutex_destroy(&amp;pool-&gt;lock);</span><br><span class="line">         pthread_mutex_lock(&amp;pool-&gt;threadCounter);</span><br><span class="line">        pthread_mutex_destroy(&amp;pool-&gt;threadCounter);</span><br><span class="line">        pthread_cond_destroy(&amp;pool-&gt;queueNotEmpty);</span><br><span class="line">        pthread_cond_destroy(&amp;pool-&gt;queueNotFull);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(pool);</span><br><span class="line">    pool=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建线程池   queueMaxSize-任务最大个数</span></span><br><span class="line"><span class="type">threadpool_t</span>* <span class="title function_">threadpool_creat</span><span class="params">(<span class="type">int</span> minThrNum,<span class="type">int</span> maxThrNum,<span class="type">int</span> queueMaxSize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">threadpool_t</span>* pool = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pool = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">threadpool_t</span>))) == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%s():%d] malloc threadpool fail\n&quot;</span>,__FUNCTION__,__LINE__);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(pool, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">threadpool_t</span>));</span><br><span class="line">        pool-&gt;minThrNum = minThrNum;</span><br><span class="line">        pool-&gt;maxThrNum = maxThrNum;</span><br><span class="line">        pool-&gt;queueMaxSize = queueMaxSize;</span><br><span class="line">        pool-&gt;liveThrNum = minThrNum;</span><br><span class="line">        <span class="comment">//为线程id数组开辟空间</span></span><br><span class="line">        pool-&gt;threads = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">pthread_t</span>) * maxThrNum);</span><br><span class="line">        <span class="keyword">if</span> (pool-&gt;threads == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%s:%d]malloc threads fail\n&quot;</span>, __LINE__, __FUNCTION__);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(pool-&gt;threads,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="type">pthread_t</span>)*maxThrNum);</span><br><span class="line">        <span class="comment">//为任务队列开辟空间</span></span><br><span class="line">        pool-&gt;taskQueue = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(threadpool_task)*queueMaxSize);</span><br><span class="line">         <span class="keyword">if</span> (pool-&gt;taskQueue == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%s:%d]malloc taskQueue fail\n&quot;</span>, __LINE__, __FUNCTION__);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化互斥锁,条件变量</span></span><br><span class="line">        <span class="keyword">if</span> (pthread_mutex_init(&amp;pool-&gt;lock,<span class="literal">NULL</span>)!=<span class="number">0</span></span><br><span class="line">        || pthread_mutex_init(&amp;pool-&gt;threadCounter,<span class="literal">NULL</span>)!=<span class="number">0</span></span><br><span class="line">        || pthread_cond_init(&amp;pool-&gt;queueNotEmpty,<span class="literal">NULL</span>)!= <span class="number">0</span></span><br><span class="line">        || pthread_cond_init(&amp;pool-&gt;queueNotFull,<span class="literal">NULL</span>)!= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%s():%d] init the lock or cond fail\n&quot;</span>,__FUNCTION__,__LINE__);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//启动工作线程</span></span><br><span class="line">        <span class="type">pthread_attr_t</span> attr;</span><br><span class="line">        pthread_attr_init(&amp;attr);</span><br><span class="line">        pthread_attr_setdetachstate(&amp;attr,PTHREAD_CREATE_DETACHED);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; minThrNum; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_create(&amp;pool-&gt;threads[i],&amp;attr,threadPoolThread,pool);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%s():%d] start thread 0x%x...\n&quot;</span>,__FUNCTION__,__LINE__,(<span class="type">unsigned</span> <span class="type">int</span>)pool-&gt;threads[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建管理者线程</span></span><br><span class="line">        pthread_create(&amp;pool-&gt;adjustTid,&amp;attr,adjustThread,pool);</span><br><span class="line">        <span class="keyword">return</span> pool;        </span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>);<span class="comment">//此处的do while结构仅仅是避免使用goto(无需循环作用),使break代替goto的作用</span></span><br><span class="line">    threadpool_free(pool);<span class="comment">//前面代码调用失败,释放pool存储空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加任务</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">threadpool_add</span><span class="params">(<span class="type">threadpool_t</span>* pool,<span class="type">void</span>*(*function)(<span class="type">void</span>* arg),<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;pool-&gt;lock);</span><br><span class="line">    <span class="keyword">while</span> (pool-&gt;queueSize == pool-&gt;queueMaxSize &amp;&amp; !pool-&gt;shutdown)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_cond_wait(&amp;pool-&gt;queueNotFull,&amp;pool-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pool-&gt;shutdown)<span class="comment">//诱杀工作线程</span></span><br><span class="line">    &#123;</span><br><span class="line">        pthread_cond_broadcast(&amp;pool-&gt;queueNotEmpty);</span><br><span class="line">        pthread_mutex_unlock(&amp;pool-&gt;lock);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加任务</span></span><br><span class="line">    pool-&gt;taskQueue[pool-&gt;queueRear].function = function;</span><br><span class="line">    pool-&gt;taskQueue[pool-&gt;queueRear].arg = arg;</span><br><span class="line">    pool-&gt;queueRear = (pool-&gt;queueRear + <span class="number">1</span>)%pool-&gt;queueMaxSize;</span><br><span class="line">    pool-&gt;queueSize++;</span><br><span class="line">    <span class="comment">//添加任务后,队列不为空,唤醒线程池中等待处理任务的线程</span></span><br><span class="line">    pthread_cond_signal(&amp;pool-&gt;queueNotEmpty);</span><br><span class="line">    pthread_mutex_unlock(&amp;pool-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">threadpool_destroy</span><span class="params">(<span class="type">threadpool_t</span>* pool)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(pool == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    pool-&gt;shutdown = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通知所有空闲线程,但是此时可能有线程还未</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pool-&gt;liveThrNum; i++) </span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">/*通知所有的空闲线程*/</span></span><br><span class="line">        pthread_cond_broadcast(&amp;(pool-&gt;queueNotEmpty));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//确定管理者线程已死</span></span><br><span class="line">    <span class="keyword">while</span> (isThreadAlive(pool-&gt;adjustTid));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//要确定所有线程均已经退出才能释放内存空间</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pool-&gt;maxThrNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pool-&gt;threads[i]!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(isThreadAlive(pool-&gt;threads[i]));<span class="comment">//确保每个线程都死了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放线程池</span></span><br><span class="line">    threadpool_free(pool);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">taskRun</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&gt;&gt;&gt;执行任务&lt;&lt;&lt;    任务编号为:%d\n&quot;</span>,i);</span><br><span class="line">    sleep(<span class="number">1</span>);<span class="comment">//模拟耗时任务</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&gt;&gt;&gt;执行完成&lt;&lt;&lt;    任务编号为:%d\n&quot;</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">threadpool_t</span>* pool = threadpool_creat(<span class="number">20</span>,<span class="number">50</span>,<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        threadpool_add(pool,taskRun,i);</span><br><span class="line">    &#125;</span><br><span class="line">    threadpool_destroy(pool);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>截取一点点的效果图(效果过长)</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202209201554794.jpeg" alt="截屏2022-09-20 15.54.01" style="zoom:33%;" />

<h2 id="UDP通信"><a href="#UDP通信" class="headerlink" title="UDP通信"></a>UDP通信</h2><p>UDP：<strong>用户数据报协议</strong><br>面向无连接的，不稳定，不可靠，不安全的数据报传递—更像是收发短信<br>UDP传输不需要建立连接，传输效率更高，在稳定的局域网内环境相对可靠</p>
<p>因为UDP不需要维护连接,因此<strong>udp天然支持多客户端</strong></p>
<h3 id="相关函数-1"><a href="#相关函数-1" class="headerlink" title="相关函数"></a>相关函数</h3><h4 id="recvfrom函数"><a href="#recvfrom函数" class="headerlink" title="recvfrom函数"></a>recvfrom函数</h4><p>接收消息 (调用该函数相当于TCP通信的recv+accept函数)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags,<span class="keyword">struct</span> sockaddr *src_addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>sockfd</code> 套接字</li>
<li><code>buf</code>  要接受的缓冲区</li>
<li><code>len</code>  缓冲区的长度</li>
<li><code>flags</code> 标志位一般填0</li>
<li><code>src_addr</code> 传入传出参数   原地址传出参数   (存储发送数据过来的主机的信息)</li>
<li><code>addrlen</code>  传入传出参数   发送方地址长度</li>
</ul>
<p><strong>返回值</strong><br><code>成功</code>: 返回读到的字节数<br><code>失败</code>: 返回 -1 设置errno </p>
<h4 id="sendto函数"><a href="#sendto函数" class="headerlink" title="sendto函数"></a>sendto函数</h4><p>发送数据</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags,<span class="type">const</span> <span class="keyword">struct</span> sockaddr *dest_addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>sockfd</code> 套接字</li>
<li><code>dest_addr</code> 目的地址(决定了发给谁)</li>
<li><code>addrlen</code> 目的地址长度</li>
</ul>
<p><strong>返回值</strong><br><code>成功</code>: 返回写入的字节数<br><code>失败</code>: 返回-1，设置errno</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202209201729840.png" alt="image-20220920172923105"></p>
<p><strong>UDP服务器编码流程:</strong></p>
<ol>
<li>创建套接字  <code>type=SOCK_DGRAM</code> (datagrams数据报)  – <a href="#socket%E5%87%BD%E6%95%B0">socket</a></li>
<li>绑定ip和端口  –  <a href="#bind%E5%87%BD%E6%95%B0">bind</a></li>
<li>收消息–<a href="#recvfrom%E5%87%BD%E6%95%B0">recvfrom</a>      发消息–<a href="#sendto%E5%87%BD%E6%95%B0">sendto</a></li>
<li>关闭套接字–close</li>
</ol>
<p><strong>UDP客户端编码流程:</strong></p>
<ol>
<li>创建套接字  <code>type=SOCK_DGRAM</code> (datagrams数据报)  – <a href="#socket%E5%87%BD%E6%95%B0">socket</a></li>
<li>收消息–<a href="#recvfrom%E5%87%BD%E6%95%B0">recvfrom</a>      发消息–<a href="#sendto%E5%87%BD%E6%95%B0">sendto</a></li>
<li>关闭套接字–close</li>
</ol>
<p><strong>测试命令</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -u ip号 端口号</span><br></pre></td></tr></table></figure>

<h3 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h3><p>下面是服务端收,客户端发简单案例</p>
<h4 id="udp服务端简单代码"><a href="#udp服务端简单代码" class="headerlink" title="udp服务端简单代码"></a>udp服务端简单代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">//解析sockaddr_in结构提取[ip:端口]字符串</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">acceptClient2Str</span><span class="params">(<span class="keyword">struct</span> sockaddr_in* client,<span class="type">char</span>* str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> sip[<span class="number">16</span>];</span><br><span class="line">    <span class="built_in">memset</span>(sip,<span class="number">0</span>,<span class="keyword">sizeof</span>(sip));</span><br><span class="line">    <span class="built_in">sprintf</span>(str,<span class="string">&quot;%s:%hu&quot;</span>,inet_ntop(AF_INET,&amp;client-&gt;sin_addr.s_addr,sip,<span class="keyword">sizeof</span>(sip)),ntohs(client-&gt;sin_port));</span><br><span class="line">    <span class="comment">//std::cout&lt;&lt;str&lt;&lt;std::endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建socket</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv</span>;</span></span><br><span class="line">    serv.sin_family = AF_INET;</span><br><span class="line">    serv.sin_port = htons (<span class="number">23456</span>);</span><br><span class="line">    serv.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    bind(lfd,&amp;serv,<span class="keyword">sizeof</span>(serv));</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">99</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;等待接受信息\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">socklen_t</span> len=<span class="keyword">sizeof</span>(serv);</span><br><span class="line">        <span class="type">int</span> iReaded = recvfrom(lfd,buf,<span class="number">99</span>,<span class="number">0</span>,&amp;serv,&amp;len);</span><br><span class="line">        <span class="type">char</span> ipStr[<span class="number">20</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        acceptClient2Str(&amp;serv,ipStr);</span><br><span class="line">        <span class="keyword">if</span>(iReaded&gt;<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%s():%d] 数据来源:%s  长度:%d  内容:%s\n&quot;</span>,__FUNCTION__,__LINE__,ipStr,iReaded,buf);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    close(lfd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="udp客户端简单代码"><a href="#udp客户端简单代码" class="headerlink" title="udp客户端简单代码"></a>udp客户端简单代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> lfd = socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">99</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,buf);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv</span>;</span></span><br><span class="line">        serv.sin_family = AF_INET;</span><br><span class="line">        serv.sin_port = htons(<span class="number">23456</span>);</span><br><span class="line">        inet_pton(AF_INET,<span class="string">&quot;127.0.0.1&quot;</span>,&amp;serv.sin_addr.s_addr);</span><br><span class="line">        serv.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">        <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(serv);</span><br><span class="line">        sendto(lfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>, &amp;serv, len);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="本地socket通信"><a href="#本地socket通信" class="headerlink" title="本地socket通信"></a>本地socket通信</h2><p>也是一种IPC机制(进程间通信机制)</p>
<p>通过查询: <code>man 7 unix</code> 可以查到unix本地域socket通信相关信息</p>
<p>需要头文件 <code>#include &lt;sys/un.h&gt;</code> 和 <code>#include &lt;sys/socket.h&gt;</code></p>
<p><strong>本地套接字服务器的流程：</strong></p>
<ul>
<li>可以使用TCP的方式, 必须按照tcp的流程</li>
<li>也可以使用UDP的方式, 必须按照udp的流程</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202209221142632.png" alt="image-20220922114207752"></p>
<ul>
<li><code>AF_INET</code> ： ipv4地址域类型  <code>struct sockaddr_in</code></li>
<li><code>AF_INET6</code>: ipv6地址域类型  <code>struct  sockaddr_in6</code></li>
<li><code>AF_UNIX</code>: 本地 地址域类型    <code>struct  sockaddr_un</code></li>
</ul>
<p>	</p>
<p><strong>唯一的区别只是bind函数传参数不同</strong>:本地socket通信使用的是<code>sockaddr_un</code>结构体,如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">serv</span>;</span></span><br><span class="line">serv.sun_family = AF_UNIX;</span><br><span class="line"><span class="built_in">strcpy</span>(serv.sun_path ,<span class="string">&quot;./serv.sock&quot;</span>); <span class="comment">//设置文件路径</span></span><br><span class="line">bind(lfd,&amp;serv,<span class="keyword">sizeof</span>(serv));<span class="comment">//lfd为socket函数返回</span></span><br></pre></td></tr></table></figure>

<p><strong>tcp的本地套接字服务器流程：</strong></p>
<ul>
<li>创建套接字  <a href="#socket%E5%87%BD%E6%95%B0"><code>socket(AF_UNIX,SOCK_STREAM,0)</code></a></li>
<li>绑定 <a href="#bind%E5%87%BD%E6%95%B0"><code>bind</code></a> 用的结构体是 <code>struct sockaddr_un</code> </li>
<li>侦听 <a href="#listen%E5%87%BD%E6%95%B0"><code>listen</code> </a></li>
<li>获得新连接 <a href="#accept%E5%87%BD%E6%95%B0"><code>accept</code></a> </li>
<li>循环通信 <a href="#%E8%AF%BB%E5%86%99%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><code>read</code>-<code>write</code> </a></li>
<li>关闭文件描述符 <code>close</code></li>
</ul>
<p><strong>tcp本地套接字客户端流程：</strong></p>
<ul>
<li><p>调用<a href="#socket%E5%87%BD%E6%95%B0"><code>socket</code></a>创建套接字</p>
</li>
<li><p>调用<a href="#bind%E5%87%BD%E6%95%B0"><code>bind</code></a>函数将<code>socket</code>文件描述和<code>socket</code>文件进行绑定.</p>
<p>不是必须的, 若无显示绑定会进行隐式绑定，但服务器不知道谁连接了,就无法给客户端发送消息,原因是网络编程的时候客户端信息操作系统会自动分配，而本地通信并不会</p>
</li>
<li><p>调用<a href="#connect%E5%87%BD%E6%95%B0"><code>connect</code></a>函数连接服务端</p>
</li>
<li><p>循环通信<a href="#%E8%AF%BB%E5%86%99%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><code>read</code>-<code>write</code></a></p>
</li>
<li><p>关闭文件描述符<code>close</code></p>
</li>
</ul>
<p>需要注意的是: <strong>bind函数会自动创建socket文件</strong>(大小为0), 若在调用bind函数之前<strong>socket文件已经存在, 则调用bind会报错</strong>, <strong>可以使用<code>unlink</code>函数在bind之前先删除文件.</strong></p>
<p>测试本地socket通信:<code>nc -U socket文件名.s</code></p>
<h3 id="代码案例"><a href="#代码案例" class="headerlink" title="代码案例"></a>代码案例</h3><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p><strong>服务端</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> filename <span class="string">&quot;./serv.sock&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建socket</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_UNIX,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">serv</span>;</span></span><br><span class="line">    bzero(&amp;serv,<span class="keyword">sizeof</span>(serv));</span><br><span class="line">    serv.sun_family = AF_UNIX;</span><br><span class="line">    <span class="built_in">strcpy</span>(serv.sun_path ,filename); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,serv.sun_path);</span><br><span class="line">    unlink(filename);<span class="comment">//删除可能存在的原文件</span></span><br><span class="line">    <span class="type">int</span> ret = bind(lfd,&amp;serv,<span class="keyword">sizeof</span>(serv));</span><br><span class="line">       <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;bind error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    listen(lfd,<span class="number">2</span>);</span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(serv);</span><br><span class="line">    <span class="type">int</span> cfd = accept(lfd,&amp;serv,&amp;len);</span><br><span class="line">    <span class="keyword">if</span> (cfd==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;accept wrong:&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> buf[<span class="number">99</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;等待接受连接  cfd为:%d\n&quot;</span>,cfd);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">socklen_t</span> len=<span class="keyword">sizeof</span>(serv);</span><br><span class="line">        <span class="type">int</span> iReaded = recv(cfd,buf,<span class="keyword">sizeof</span>(buf),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(iReaded&gt;<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%s():%d] 长度:%d  内容:%s\n&quot;</span>,__FUNCTION__,__LINE__,iReaded,buf);</span><br><span class="line">    &#125;</span><br><span class="line">    close(cfd);</span><br><span class="line">    close(lfd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> filename <span class="string">&quot;../test2/serv.sock&quot;</span><span class="comment">//要指向服务端创建的sock文件</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> cfd = socket(AF_UNIX,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">99</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">serv</span>;</span></span><br><span class="line">    bzero(&amp;serv, <span class="keyword">sizeof</span>(serv));</span><br><span class="line">    serv.sun_family = AF_UNIX;</span><br><span class="line">    <span class="built_in">strcpy</span>(serv.sun_path, filename);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, serv.sun_path);</span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(serv);</span><br><span class="line">    connect(cfd, &amp;serv, len);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,buf);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line">        send(cfd, buf, <span class="built_in">strlen</span>(buf)+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><p><strong>服务端</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> filename <span class="string">&quot;./serv.sock&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建socket</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_UNIX,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">serv</span>;</span></span><br><span class="line">    bzero(&amp;serv,<span class="keyword">sizeof</span>(serv));</span><br><span class="line">    serv.sun_family = AF_UNIX;</span><br><span class="line">    <span class="built_in">strcpy</span>(serv.sun_path ,filename); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,serv.sun_path);</span><br><span class="line">    unlink(filename);</span><br><span class="line">    bind(lfd,&amp;serv,<span class="keyword">sizeof</span>(serv));</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">99</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;等待接受连接\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">socklen_t</span> len=<span class="keyword">sizeof</span>(serv);</span><br><span class="line">        <span class="type">int</span> iReaded = recvfrom(lfd,buf,<span class="keyword">sizeof</span>(buf),<span class="number">0</span>,&amp;serv,&amp;len);</span><br><span class="line">        <span class="type">char</span> ipStr[<span class="number">20</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(iReaded&gt;<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%s():%d] 长度:%d  内容:%s\n&quot;</span>,__FUNCTION__,__LINE__,iReaded,buf);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    close(lfd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> filename <span class="string">&quot;../test2/serv.sock&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> cfd = socket(AF_UNIX,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">99</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,buf);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">serv</span>;</span></span><br><span class="line">        bzero(&amp;serv,<span class="keyword">sizeof</span>(serv));</span><br><span class="line">        serv.sun_family = AF_UNIX;</span><br><span class="line">        <span class="built_in">strcpy</span>(serv.sun_path,filename);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,serv.sun_path);</span><br><span class="line">        <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(serv);</span><br><span class="line">        sendto(cfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>, &amp;serv, len);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处代码只需要服务端收,客户端发,如果服务端也需要发送数据给指定客户端,那么客户端也要bind创建自己的sock文件.(供服务端标识发给谁)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202209231122390.jpeg" alt="截屏2022-09-23 11.21.57"></p>
<p>长度固定为99,是因为客户端<code>sendto</code>函数传参为固定99,而应该传 <code>strlen(buf)+1</code>,这样才会显示内容长度</p>
<h2 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h2><p><a href="#libevent%E5%AE%89%E8%A3%85">第三方库的安装方式参考libevent库的安装方式</a></p>
<h3 id="libevent库"><a href="#libevent库" class="headerlink" title="libevent库"></a>libevent库</h3><ul>
<li>事件驱动, 高性能, 轻量级, 专注于网络</li>
<li>源代码精炼, 易读 </li>
<li>跨平台(提供了不同的版本,支持linux,unix,windows,mac等)</li>
<li>支持多种I&#x2F;O多路复用技术, 如epoll select poll等</li>
<li>支持I&#x2F;O和信号等事件</li>
</ul>
<blockquote>
<p><strong>libevent的核心实现:</strong><br>在linux上, 其实质就是epoll反应堆.<br>libevent是事件驱动, epoll反应堆也是事件驱动, 当要监测的事件发生的时候, 就会调用事件对应的回调函数, 执行相应操作. 特别提醒: 事件回调函数是由用户开发的, 但不是由用户显示去调用的, 而是由libevent去调用的</p>
</blockquote>
<h4 id="libevent安装"><a href="#libevent安装" class="headerlink" title="libevent安装"></a>libevent安装</h4><p><a target="_blank" rel="noopener" href="https://libevent.org/">官方网址跳转</a></p>
<p>libevent源码下载主要分2个大版本：</p>
<ol>
<li><code>1.4.x</code> 系列, 较为早期版本, 适合源码学习</li>
<li><code>2.x</code>系列, 较新的版本, 代码量比1.4版本多很多, 功能也更完善。</li>
</ol>
<p>从官网<a target="_blank" rel="noopener" href="http://libevent.org上下载安装文件之后/">http://libevent.org上下载安装文件之后</a>, 将安装文件上传到linux系统上;源码包的安装,以2.1.12版本为例,在官网可以下载到源码包libevent-2.1.12-stable.tar.gz, 安装步骤与第三方库源码包安装方式基本一致。</p>
<p><strong>解压</strong>libevent-2.1.12-stable.tar.gz:</p>
<ol>
<li>解压: tar -zxvf libevent-2.1.12-stable.tar.gz</li>
<li>cd到libevent-2.1.12-stable目录下, 查看README文件, 该文件里描述了安装的详细步骤, 可参照这个文件进行安装.</li>
</ol>
<p><strong>进入源码目录</strong>:</p>
<ol>
<li><p>执行配置<code>./configure</code>, 检测安装环境, 生成makefile.</p>
<p>执行<code>./configure</code>的时候也可以指定路径, <code>./configure --prefix=/usr/xxxxx</code>, 这样就可以安装到指定的目录下, 但是这样在进行源代码编译的时候需要指定用-I头文件的路径和用-L库文件的路径. 若默认安装不指定–<code>prefix</code>, 则会安装到<strong>系统默认的路径下</strong>, 编译的时候可以不指定头文件和库文件所在的路径.</p>
</li>
<li><p>执行make命令编译整个项目文件.</p>
<p>通过执行make命令, 会生成一些库文件(动态库和静态库)和可执行文件.</p>
</li>
<li><p>执行<code>sudo make install</code>进行安装</p>
<p>安装需要root用户权限, 这一步需要输入当前用户的密码</p>
<p>执行这一步, 可以将刚刚编译成的库文件和可执行文件以及一些头文件拷贝到&#x2F;usr&#x2F;local目录下:</p>
<p>​			—-头文件拷贝到了&#x2F;usr&#x2F;local&#x2F;include目录下;</p>
<p>​			—-库文件拷贝到了&#x2F;usr&#x2F;local&#x2F;lib目录下.</p>
</li>
</ol>
<h4 id="libevent库的使用"><a href="#libevent库的使用" class="headerlink" title="libevent库的使用"></a>libevent库的使用</h4><p>进入到<code>libevent-2.1.12-stable/sample</code>下, 可以查看一些示例源代码文件.</p>
<p>使用libevent库编写代码在编译程序的时候需要指定库名:<code>-levent</code>;<br>安装文件的libevent库文件所在路径:<code>libevent-2.1.12-stable/.libs</code>;</p>
<p>编写代码的时候用到<code>event.h</code>头文件, 或者直接参考sample目录下的源代码文件也可以.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/event.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>编译源代码文件(以hello-world.c文件为例)<br><code>gcc hello-world.c -levent</code>    <strong>!!!!!需要指定库<code>-levent</code>!!!!</strong></p>
<p>由于安装的时候已经将头文件和库文件拷贝到了系统头文件所在路径<code>/usr/local/include</code>和系统库文件所在路径<code>/usr/local/lib</code>, 所以这里编译的时候可以不用指定<code>-I</code>和<code>-L</code>.</p>
<h4 id="event-base相关结构与函数"><a href="#event-base相关结构与函数" class="headerlink" title="event_base相关结构与函数"></a>event_base相关结构与函数</h4><p><strong>event_base结构</strong></p>
<p>使用libevent 函数之前需要分配一个或者多个 <code>event_base</code> 结构体, 每个<code>event_base</code>结构体持有一个事件集合,可以检测以确定哪个事件是激活的, <code>event_base</code>结构相当于epoll红黑树的树根节点, 每个<code>event_base</code>都有一种用于检测某种事件已经就绪的 “方法”(回调函数)</p>
<p>通常情况下可以通过<code>event_base_new</code>函数获得<code>event_base</code>结构。</p>
<p><strong>相关函数</strong></p>
<ul>
<li><a href="#event_base_new%E5%87%BD%E6%95%B0"><code>event_base_new</code></a>    获得event_base结构</li>
<li><a href="#event_base_free%E5%87%BD%E6%95%B0"><code>event_base_free</code>  </a>     释放event_base指针</li>
<li><a href="#event_reinit%E5%87%BD%E6%95%B0"><code>event_reinit</code>  </a>    重新初始化</li>
<li><a href="#event_get_supported_methods%E5%87%BD%E6%95%B0"><code>event_get_supported_methods</code> </a>      获得当前系统(或者称为平台)支持的方法有哪些</li>
<li><a href="#event_base_get_method%E5%87%BD%E6%95%B0"> <code>event_base_get_method</code>  </a>    获得当前base节点使用的多路io方法</li>
<li><a href="#event_base_loop%E5%87%BD%E6%95%B0"><code>event_base_loop</code>   </a>   进入循环等待事件(万能)</li>
<li><a href="#event_base_dispatch%E5%87%BD%E6%95%B0"><code>event_base_dispatch</code>   </a>       进入循环等待事件(常用)</li>
<li><a href="#event_base_loopexit%E5%87%BD%E6%95%B0"><code>event_base_loopexit</code>   </a>     退出循环等待(回调执行结束后终止循环)</li>
<li><a href="#event_base_loopbreak"><code>event_base_loopbreak</code></a>    退出循环等待(立即终止循环)</li>
</ul>
<h5 id="event-base函数"><a href="#event-base函数" class="headerlink" title="event_base函数"></a>event_base函数</h5><p>获得event_base结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> event_base *<span class="title function_">event_base_new</span><span class="params">(<span class="type">void</span>)</span>;   <span class="comment">//event.h的L:337 可以找到</span></span><br><span class="line">返回值: </span><br><span class="line">  成功返回event_base结构体指针;</span><br><span class="line">  失败返回<span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<h5 id="event-base-free函数"><a href="#event-base-free函数" class="headerlink" title="event_base_free函数"></a>event_base_free函数</h5><p>释放event_base指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">event_base_free</span><span class="params">(<span class="keyword">struct</span> event_base *)</span>;   <span class="comment">//event.h的L:561</span></span><br></pre></td></tr></table></figure>

<h5 id="event-reinit函数"><a href="#event-reinit函数" class="headerlink" title="event_reinit函数"></a>event_reinit函数</h5><p>如果有子进程, 且子进程也要使用base, 则子进程需要对event_base重新初始化, 此时需要调用event_reinit函数.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">event_reinit</span><span class="params">(<span class="keyword">struct</span> event_base *base)</span>; <span class="comment">//event.h的L:349</span></span><br><span class="line">函数参数: </span><br><span class="line">	由event_base_new返回的执行event_base结构的指针</span><br><span class="line">返回值: </span><br><span class="line">	成功返回<span class="number">0</span>,</span><br><span class="line">	失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h5 id="event-get-supported-methods函数"><a href="#event-get-supported-methods函数" class="headerlink" title="event_get_supported_methods函数"></a>event_get_supported_methods函数</h5><p>得当前系统(或者称为平台)支持的方法有哪些</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> **<span class="title function_">event_get_supported_methods</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">返回值: </span><br><span class="line">	返回二维数组, 类似与main函数的第二个参数**argv.</span><br></pre></td></tr></table></figure>

<p>对于不同系统而言, event_base就是调用不同的多路IO接口去判断事件是否已经被激活, 对于linux系统而言, 核心调用的就是epoll, 同时支持poll和select.</p>
<p>编写代码<strong>获得当前系统支持的多路IO方法和当前所使用的方法</strong>:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202209231540325.png" alt="image-20220923154028865"></p>
<p>linux下打印如下: <code>epoll	poll	select</code></p>
<h5 id="event-base-get-method函数"><a href="#event-base-get-method函数" class="headerlink" title="event_base_get_method函数"></a>event_base_get_method函数</h5><p>获得当前base节点使用的多路io方法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> * <span class="title function_">event_base_get_method</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> event_base *base)</span>;</span><br><span class="line">函数参数: </span><br><span class="line">	event_base结构的base指针.</span><br><span class="line">返回值: </span><br><span class="line">	获得当前base节点使用的多路io方法的指针</span><br></pre></td></tr></table></figure>

<h5 id="event-base-loop函数"><a href="#event-base-loop函数" class="headerlink" title="event_base_loop函数"></a>event_base_loop函数</h5><p>进入循环等待事件(该函数一般不用,用<a href="#event_base_dispatch%E5%87%BD%E6%95%B0"><code>event_base_dispatch</code></a>代替)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">event_base_loop</span><span class="params">(<span class="keyword">struct</span> event_base *base, <span class="type">int</span> flags)</span>;   <span class="comment">//event.h的L:660</span></span><br></pre></td></tr></table></figure>

<p>参数说明:</p>
<ul>
<li><p><code>base</code>: 由event_base_new函数返回的指向event_base结构的指针</p>
</li>
<li><p><code>flags</code>的取值：</p>
<ul>
<li><p>默认不设置时等同于<a href="#event_base_dispatch%E5%87%BD%E6%95%B0"><code>event_base_dispatch</code></a></p>
</li>
<li><p><code>#define EVLOOP_ONCE	0x01</code></p>
<p>只触发一次, 如果事件没有被触发, 阻塞等待</p>
</li>
<li><p><code>#define EVLOOP_NONBLOCK	0x02</code></p>
<p>非阻塞方式检测事件是否被触发, 不管事件触发与否, 都会立即返回.</p>
</li>
</ul>
</li>
</ul>
<h5 id="event-base-dispatch函数"><a href="#event-base-dispatch函数" class="headerlink" title="event_base_dispatch函数"></a>event_base_dispatch函数</h5><p>进入循环等待事件(阻塞)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">event_base_dispatch</span><span class="params">(<span class="keyword">struct</span> event_base *base)</span>;   <span class="comment">//event.h的L:364</span></span><br><span class="line">函数参数: </span><br><span class="line">	event_base结构的base指针.</span><br></pre></td></tr></table></figure>

<p>调用该函数, 相当于没有设置标志位的<code>event_base_loop</code>。程序将会一直运行, 直到没有需要检测的事件了, 或者被结束循环的API终止。</p>
<h5 id="event-base-loopexit函数"><a href="#event-base-loopexit函数" class="headerlink" title="event_base_loopexit函数"></a>event_base_loopexit函数</h5><p>退出循环等待(<strong>回调执行结束后</strong>终止循环,也就是等待处理完再终止)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">event_base_loopexit</span><span class="params">(<span class="keyword">struct</span> event_base *base, <span class="type">const</span> <span class="keyword">struct</span> timeval *tv)</span>;</span><br><span class="line">函数参数: </span><br><span class="line">	event_base结构的base指针.</span><br><span class="line">  tv为timeval结构体指针(如下)</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">	<span class="type">long</span>    tv_sec;                    </span><br><span class="line">	<span class="type">long</span>    tv_usec;            </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果正在执行激活事件的回调函数, 那么<code>event_base_loopexit</code>将在事件回调执行结束后终止循环（如果tv时间非NULL, 那么将等待tv设置的时间后立即结束循环）, 而<code>event_base_loopbreak</code>会立即终止循环。</p>
<h5 id="event-base-loopbreak函数"><a href="#event-base-loopbreak函数" class="headerlink" title="event_base_loopbreak函数"></a>event_base_loopbreak函数</h5><p>退出循环等待(立即终止循环)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">event_base_loopbreak</span><span class="params">(<span class="keyword">struct</span> event_base *base)</span>;</span><br><span class="line">函数参数: </span><br><span class="line">	event_base结构的base指针.</span><br></pre></td></tr></table></figure>

<h4 id="使用libevent库的流程"><a href="#使用libevent库的流程" class="headerlink" title="使用libevent库的流程"></a>使用libevent库的流程</h4><ol>
<li><p>创建根节点–<a href="#event_base_new%E5%87%BD%E6%95%B0"><code>event_base_new</code></a></p>
</li>
<li><p>设置监听事件和数据可读可写的事件的回调函数</p>
<p>设置了事件对应的回调函数以后, 当事件产生的时候会自动调用回调函数</p>
</li>
<li><p>事件循环–<a href="#event_base_dispatch%E5%87%BD%E6%95%B0"><code>event_base_dispatch</code></a></p>
<p>相当于while(1), 在循环内部等待事件的发生,  若有事件发生则会触发事件对应的回调函数。</p>
</li>
<li><p>释放根节点–<a href="#event_base_free%E5%87%BD%E6%95%B0"><code>event_base_free</code></a></p>
<p>释放由event_base_new和event_new创建的资源, 分别调用event_base_free和event_free函数.</p>
</li>
</ol>
<p><strong>事件驱动event</strong></p>
<p>事件驱动实际上是libevent的核心思想</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202209231811993.png" alt="image-20220923181138553"></p>
<p>主要几个状态：</p>
<ul>
<li><strong><code>无效的指针</code></strong>: 此时仅仅是定义了 <code>struct event *ptr</code>；</li>
<li>**<code>非未决</code>**：相当于创建了事件, 但是事件还没有处于被监听状态, 类似于我们使用epoll的时候定义了<code>struct epoll_event ev</code>并且对ev的两个字段进行了赋值, 但是此时尚未调用<code>epoll_ctl</code>对事件上树.</li>
<li>**<code>未决</code>**：就是对事件开始监听, 暂时未有事件产生。相当于调用<code>epoll_ctl</code>对要监听的事件上树, 但是没有事件产生.</li>
<li>**<code>激活</code>**：代表监听的事件已经产生, 这时需要处理, 相当于调用<code>epoll_wait</code>函数有返回, 当事件被激活以后, libevent会调用该事件对应的回调函数.</li>
</ul>
<h4 id="event相关函数和结构"><a href="#event相关函数和结构" class="headerlink" title="event相关函数和结构"></a>event相关函数和结构</h4><p>libevent的事件驱动对应的结构体为<code>struct event</code>, 对应的函数在图上也比较清晰, 下面介绍一下主要的函数:</p>
<p>自定义回调函数格式:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*event_callback_fn)</span><span class="params">(<span class="type">evutil_socket_t</span> fd, <span class="type">short</span> events, <span class="type">void</span> *arg)</span>;</span><br></pre></td></tr></table></figure>

<h5 id="event-new函数"><a href="#event-new函数" class="headerlink" title="event_new函数"></a>event_new函数</h5><p>创建event结构指针, 同时指定对应的地基base, 对应的文件描述符, 要<strong>监听的是什么事件</strong>, 以及回调函数和回调函数的参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> event *<span class="title function_">event_new</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="keyword">struct</span> event_base *base, </span></span><br><span class="line"><span class="params">  <span class="type">evutil_socket_t</span> fd, </span></span><br><span class="line"><span class="params">  <span class="type">short</span> events,</span></span><br><span class="line"><span class="params">  event_callback_fn cb, </span></span><br><span class="line"><span class="params">  <span class="type">void</span> *arg)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>base</code>: 对应的根节点–地基</p>
</li>
<li><p><code>fd</code>: 要监听的文件描述符,(或信号)</p>
</li>
<li><p><code>events</code>:要监听的事件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  EV_TIMEOUT    0x01   <span class="comment">//超时事件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  EV_READ       0x02    <span class="comment">//读事件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  EV_WRITE      0x04    <span class="comment">//写事件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  EV_SIGNAL     0x08    <span class="comment">//信号事件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  EV_PERSIST     0x10    <span class="comment">//周期性触发</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  EV_ET         0x20    <span class="comment">//边缘触发, 如果底层模型支持设置则有效, 若不支持则无效.</span></span></span><br><span class="line"><span class="comment">//若要想设置持续的读事件则： EV_READ | EV_PERSIST</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>cb</code> 回调函数, 原型如下：</p>
<p><code>typedef void (*event_callback_fn)(evutil_socket_t fd, short events, void *arg);</code></p>
<p>p.s.回调函数的参数就对应于event_new函数的fd, event和arg</p>
</li>
<li><p><code>arg</code> 传入上面回调函数的参数arg</p>
</li>
</ul>
<h5 id="event-add函数"><a href="#event-add函数" class="headerlink" title="event_add函数"></a>event_add函数</h5><p>将非未决态事件转为未决态, 相当于调用epoll_ctl函数(EPOLL_CTL_ADD), 开始监听事件是否产生, 相当于epoll的上树操作.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">event_add</span><span class="params">(<span class="keyword">struct</span> event *ev, <span class="type">const</span> <span class="keyword">struct</span> timeval *timeout)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ev</code>: 调用event_new创建的事件</li>
<li><code>timeout</code>: 限时等待事件的产生, 也可以设置为NULL, 没有限时。</li>
</ul>
<h5 id="event-del函数"><a href="#event-del函数" class="headerlink" title="event_del函数"></a>event_del函数</h5><p>将事件从未决态变为非未决态, 相当于epoll的下树（epoll_ctl调用EPOLL_CTL_DEL操作）操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">event_del</span><span class="params">(<span class="keyword">struct</span> event *ev)</span>;</span><br></pre></td></tr></table></figure>

<p>参数:  <code>ev</code>指的是由event_new创建的事件.</p>
<h5 id="event-free函数"><a href="#event-free函数" class="headerlink" title="event_free函数"></a>event_free函数</h5><p>释放由event_new申请的event节点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">event_free</span><span class="params">(<span class="keyword">struct</span> event *ev)</span>;</span><br></pre></td></tr></table></figure>

<p>参数同上</p>
<h4 id="libevent开发流程"><a href="#libevent开发流程" class="headerlink" title="libevent开发流程"></a>libevent开发流程</h4><p>编写一个基于event实现的tcp服务器</p>
<ol>
<li><p>创建socket     —    <a href="#socket%E5%87%BD%E6%95%B0"><code>socket</code></a></p>
</li>
<li><p>设置端口复用   —   <a href="#setsockopt%E5%87%BD%E6%95%B0"><code>setsockopt</code></a></p>
</li>
<li><p>绑定   —   <a href="#bind%E5%87%BD%E6%95%B0"><code>bind</code></a></p>
</li>
<li><p>设置监听   —   <a href="#listen%E5%87%BD%E6%95%B0"><code>listen</code></a></p>
</li>
<li><p>创建地基   —   <a href="#event_base_new%E5%87%BD%E6%95%B0"><code>event_base_new</code></a></p>
</li>
<li><p>创建lfd对应的事件   —   <a href="#event_new%E5%87%BD%E6%95%B0"><code>event_new</code></a></p>
<p>该事件编写回调函数为accept接受新描述符,构造新事件(处理读写的回调函数)并上树</p>
</li>
<li><p>第六步事件上树(就是上地基)   —   <a href="#event_add%E5%87%BD%E6%95%B0"><code>event_add</code></a></p>
</li>
<li><p>进入事件循环   —   <a href="#event_base_dispatch%E5%87%BD%E6%95%B0"><code>event_base_dispatch</code></a></p>
</li>
<li><p>退出循环(可以写到回调里面)   —   <a href="#event_base_free%E5%87%BD%E6%95%B0"><code>event_base_free</code></a></p>
</li>
<li><p>释放资源   —   <a href="#event_free%E5%87%BD%E6%95%B0"><code>event_free</code></a></p>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202209261620803.png" alt="image-20220926162016068"></p>
<h4 id="libevent代码案例"><a href="#libevent代码案例" class="headerlink" title="libevent代码案例"></a>libevent代码案例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写libevent服务端</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/event.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event</span>* <span class="title">connevs</span>[100] =</span> &#123; <span class="literal">NULL</span> &#125;;<span class="comment">//用于记录要下树的对应event</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//typedef void (*event_callback_fn)(evutil_socket_t fd, short events, void *arg);</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">readcb</span><span class="params">(<span class="type">evutil_socket_t</span> fd, <span class="type">short</span> events, <span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">	<span class="built_in">memset</span>(buf, <span class="number">0x00</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">	n = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">	<span class="keyword">if</span>(n&lt;=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;客户端断开连接\n&quot;</span>);</span><br><span class="line">		close(fd);</span><br><span class="line">		<span class="comment">//将通信文件描述符对应的事件从base地基上删除</span></span><br><span class="line">		event_del(connevs[fd]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;读到[%d]%s\n&quot;</span>,n,buf);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">conncb</span><span class="params">(<span class="type">evutil_socket_t</span> fd, <span class="type">short</span> events, <span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> =</span> (<span class="keyword">struct</span> event_base *)arg;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//接受新的客户端连接</span></span><br><span class="line">	<span class="type">int</span> cfd = accept(fd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span>(cfd&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;客户端连接成功\n&quot;</span>);</span><br><span class="line">		<span class="comment">//创建通信文件描述符对应的事件并设置回调函数为readcb</span></span><br><span class="line">		connevs[cfd] = event_new(base, cfd, EV_READ|EV_PERSIST, readcb, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span>(connevs[cfd]==<span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//退出循环</span></span><br><span class="line">			event_base_loopexit(base, <span class="literal">NULL</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//将通信文件描述符对应的事件上event_base地基</span></span><br><span class="line">		event_add(connevs[cfd], <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//创建socket</span></span><br><span class="line">	<span class="type">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置端口复用</span></span><br><span class="line">	<span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">	setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//绑定</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv</span>;</span></span><br><span class="line">	bzero(&amp;serv, <span class="keyword">sizeof</span>(serv));</span><br><span class="line">	serv.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">	serv.sin_port = htons(<span class="number">8888</span>);</span><br><span class="line">	serv.sin_family = AF_INET;</span><br><span class="line">	bind(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;serv, <span class="keyword">sizeof</span>(serv));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//监听</span></span><br><span class="line">	listen(lfd, <span class="number">120</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建地基</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> =</span> event_base_new();</span><br><span class="line">	<span class="keyword">if</span>(base==<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;event_base_new error\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[支持的方式：&quot;</span>);</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> **p = event_get_supported_methods();</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(p[i]!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[%s]  &quot;</span>, p[i++]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[使用的方式：%s]\n&quot;</span>, event_base_get_method(base));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建监听文件描述符对应的事件</span></span><br><span class="line">	<span class="comment">//struct event *event_new(struct event_base *base, evutil_socket_t fd, short events, event_callback_fn cb, void *arg);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">ev</span> =</span> event_new(base, lfd, EV_READ|EV_PERSIST, conncb, base);</span><br><span class="line">	<span class="keyword">if</span>(ev==<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;event_new error\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将新的事件节点上base地基</span></span><br><span class="line">	event_add(ev, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;等待连接中...\n&quot;</span>);</span><br><span class="line">	<span class="comment">//进入事件循环等待</span></span><br><span class="line">	event_base_dispatch(base);</span><br><span class="line">	<span class="comment">//释放资源</span></span><br><span class="line">	event_base_free(base);</span><br><span class="line">	event_free(ev);</span><br><span class="line">	close(lfd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="bufferevent"><a href="#bufferevent" class="headerlink" title="bufferevent"></a>bufferevent</h4><p><strong>bufferevent</strong>实际上也是一个event, 只不过比普通的event高级一些, 它的内部有两个缓冲区, 以及一个文件描述符（网络套接字）。一个网络套接字有读和写两个缓冲区, bufferevent同样也带有两个缓冲区, 还有就是libevent事件驱动的核心回调函数, 那么四个缓冲区以及触发回调的关系如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202209251642466.png" alt="image-20220925164248163"></p>
<p>从图中可以得知, 一个bufferevent对应两个缓冲区, 三个回调函数, 分别是写回调, 读回调和事件回调.</p>
<p>bufferevent有三个回调函数：</p>
<ul>
<li><strong>读回调</strong> – 当bufferevent将底层读缓冲区的数据读到自身的读缓冲区时触发读事件回调.</li>
<li><strong>写回调</strong> – 当bufferevent将自身写缓冲的数据写到底层写缓冲区的时候触发写事件回调, 由于数据最终是写入了内核的写缓冲区中, 应用程序已经无法控制, 这个事件对于应用程序来说基本没什么用, 只是通知功能.</li>
<li><strong>事件回调</strong> – 当bufferevent绑定的socket连接, 断开或者异常的时候触发事件回调.</li>
</ul>
<p>主要使用的函数如下：</p>
<h5 id="bufferevent相关函数"><a href="#bufferevent相关函数" class="headerlink" title="bufferevent相关函数"></a>bufferevent相关函数</h5><ul>
<li>bufferevent_socket_new</li>
<li>bufferevent_free</li>
<li>bufferevent_setcb</li>
<li>bufferevent_write</li>
<li>bufferevent_write_buffer</li>
<li>bufferevent_read</li>
<li>bufferevent_read_buffer</li>
<li>bufferevent_enable</li>
<li>bufferevent_disable</li>
<li>bufferevent_get_output</li>
</ul>
<p>注意,<code>bufferevent</code>的读写函数本身就是非堵塞的</p>
<h6 id="bufferevent-socket-new函数"><a href="#bufferevent-socket-new函数" class="headerlink" title="bufferevent_socket_new函数"></a>bufferevent_socket_new函数</h6><p>bufferevent_socket_new 对已经存在socket创建bufferevent事件, 可用于后面讲到的连接监听器的回调函数中.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> bufferevent *<span class="title function_">bufferevent_socket_new</span><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="keyword">struct</span> event_base *base, </span></span><br><span class="line"><span class="params">	<span class="type">evutil_socket_t</span> fd,</span></span><br><span class="line"><span class="params">	<span class="type">int</span> options)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>​	<code>base</code> :对应根节点</li>
<li>​	<code>fd</code>   :文件描述符</li>
<li>​	<code>options</code> : bufferevent的选项<ul>
<li><code>BEV_OPT_CLOSE_ON_FREE</code>– 释放bufferevent自动关闭底层接口(当bufferevent被释放以后, <strong>文件描述符也随之被close</strong>) </li>
<li><code>BEV_OPT_THREADSAFE</code>  – 使bufferevent能够在多线程下是安全的</li>
</ul>
</li>
</ul>
<h6 id="bufferevent-socket-connect函数"><a href="#bufferevent-socket-connect函数" class="headerlink" title="bufferevent_socket_connect函数"></a>bufferevent_socket_connect函数</h6><p>该函数<strong>客户端使用</strong>,封装了底层的<code>socket</code>与<code>connect</code>接口, 通过调用此函数, 可以将bufferevent事件与通信的socket进行绑定</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bufferevent_socket_connect</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="keyword">struct</span> bufferevent *bev,</span></span><br><span class="line"><span class="params">  <span class="keyword">struct</span> sockaddr *serv,</span></span><br><span class="line"><span class="params">  <span class="type">int</span> socklen)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>bev</code> – 需要提前初始化的bufferevent事件</li>
<li><code>serv</code> – 对端(一般指服务端)的ip地址, 端口, 协议的结构指针</li>
<li><code>socklen</code> – 描述serv的长度</li>
</ul>
<p>说明: 调用此函数以后, 通信的socket与bufferevent缓冲区做了绑定, 后面调用了<code>bufferevent_setcb</code>函数以后, 会对bufferevent缓冲区的读写操作的事件设置回调函数, 当往缓冲区中写数据的时候会触发写回调函数, 当数据从socket的内核缓冲区读到bufferevent读缓冲区中的时候会触发读回调函数.</p>
<h6 id="bufferevent-free函数"><a href="#bufferevent-free函数" class="headerlink" title="bufferevent_free函数"></a>bufferevent_free函数</h6><p>释放bufferevent</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bufferevent_free</span><span class="params">(<span class="keyword">struct</span> bufferevent *bufev)</span>;</span><br></pre></td></tr></table></figure>

<h6 id="bufferevent-setcb函数"><a href="#bufferevent-setcb函数" class="headerlink" title="bufferevent_setcb函数"></a>bufferevent_setcb函数</h6><p>bufferevent_setcb用于设置bufferevent的回调函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bufferevent_setcb</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="keyword">struct</span> bufferevent *bufev,</span></span><br><span class="line"><span class="params">  bufferevent_data_cb readcb, </span></span><br><span class="line"><span class="params">  bufferevent_data_cb writecb,</span></span><br><span class="line"><span class="params">	bufferevent_event_cb eventcb, </span></span><br><span class="line"><span class="params">  <span class="type">void</span> *cbarg)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>readcb</code>, <code>writecb</code>, <code>eventcb</code>分别对应了读回调, 写回调, 事件回调</li>
<li><code>cbarg</code>代表回调函数的参数。</li>
</ul>
<p>两种回调函数的函数原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读写回调</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span><span class="params">(*bufferevent_data_cb)</span><span class="params">(<span class="keyword">struct</span> bufferevent *bev, <span class="type">void</span> *ctx)</span>;</span><br><span class="line"><span class="comment">//bev    bufferevent指针</span></span><br><span class="line"><span class="comment">//ctx		 上下文指针(context)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//事件回调</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span><span class="params">(*bufferevent_event_cb)</span><span class="params">(<span class="keyword">struct</span> bufferevent *bev, <span class="type">short</span> what, <span class="type">void</span>*ctx)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">What 代表 对应的事件</span></span><br><span class="line"><span class="comment">BEV_EVENT_EOF--遇到文件结束指示</span></span><br><span class="line"><span class="comment">BEV_EVENT_ERROR--发生错误,比如说客户端连接一个未开启的socket</span></span><br><span class="line"><span class="comment">BEV_EVENT_TIMEOUT--发生超时</span></span><br><span class="line"><span class="comment">BEV_EVENT_CONNECTED--请求的过程中连接已经完成,比如说客户端连接服务器成功</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//客户端断开连接时what为 BEV_EVENT_READING | BEV_EVENT_EOF</span></span><br></pre></td></tr></table></figure>

<h6 id="bufferevent-write函数"><a href="#bufferevent-write函数" class="headerlink" title="bufferevent_write函数"></a>bufferevent_write函数</h6><p>将data的数据写到bufferevent的写缓冲区</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bufferevent_write</span><span class="params">(<span class="keyword">struct</span> bufferevent *bufev, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p><code>size</code> 为写多长</p>
<h6 id="bufferevent-write-buffer函数"><a href="#bufferevent-write-buffer函数" class="headerlink" title="bufferevent_write_buffer函数"></a>bufferevent_write_buffer函数</h6><p>将data的数据写到bufferevent的写缓冲区的另外一个写法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bufferevent_write_buffer</span><span class="params">(<span class="keyword">struct</span> bufferevent *bufev, <span class="keyword">struct</span> evbuffer *buf)</span>;</span><br></pre></td></tr></table></figure>

<p>实际上 ,bufferevent的内部的两个缓冲区结构就是<code>struct evbuffer</code>。</p>
<h6 id="bufferevent-read函数"><a href="#bufferevent-read函数" class="headerlink" title="bufferevent_read函数"></a>bufferevent_read函数</h6><p>将bufferevent的读缓冲区数据读到data中, 同时将读到的数据从bufferevent的读缓冲清除。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">bufferevent_read</span><span class="params">(<span class="keyword">struct</span> bufferevent *bufev, <span class="type">void</span> *data, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p>size为要读的最大长度</p>
<p>返回实际读到的字节数</p>
<h6 id="bufferevent-read-buffer函数"><a href="#bufferevent-read-buffer函数" class="headerlink" title="bufferevent_read_buffer函数"></a>bufferevent_read_buffer函数</h6><p>将bufferevent读缓冲数据读到buf中, 接口的另外一种。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bufferevent_read_buffer</span><span class="params">(<span class="keyword">struct</span> bufferevent *bufev, <span class="keyword">struct</span> evbuffer *buf)</span>;</span><br></pre></td></tr></table></figure>

<p>size为要读的最大长度</p>
<p>返回实际读到的字节数</p>
<h6 id="bufferevent-enable函数"><a href="#bufferevent-enable函数" class="headerlink" title="bufferevent_enable函数"></a>bufferevent_enable函数</h6><p>设置事件生效,使回调会被触发</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bufferevent_enable</span><span class="params">(<span class="keyword">struct</span> bufferevent *bufev, <span class="type">short</span> event)</span>;</span><br></pre></td></tr></table></figure>

<p>​	event参数参考<a href="#event_new%E5%87%BD%E6%95%B0">event_new函数</a>的events参数</p>
<h6 id="bufferevent-disable函数"><a href="#bufferevent-disable函数" class="headerlink" title="bufferevent_disable函数"></a>bufferevent_disable函数</h6><p>设置事件不生效,使回调不会被触发</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bufferevent_disable</span><span class="params">(<span class="keyword">struct</span> bufferevent *bufev, <span class="type">short</span> event)</span>;</span><br></pre></td></tr></table></figure>

<p>同上</p>
<h6 id="bufferevent-get-output函数"><a href="#bufferevent-get-output函数" class="headerlink" title="bufferevent_get_output函数"></a>bufferevent_get_output函数</h6><p>获取bufferevent里的写缓冲区指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> evbuffer* <span class="title function_">bufferevent_get_output</span><span class="params">(<span class="keyword">struct</span> bufferevent* bufev)</span>;</span><br></pre></td></tr></table></figure>

<h6 id="bufferevent-get-input函数"><a href="#bufferevent-get-input函数" class="headerlink" title="bufferevent_get_input函数"></a>bufferevent_get_input函数</h6><p>获取bufferevent里的读缓冲区指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> evbuffer* <span class="title function_">bufferevent_get_input</span><span class="params">(<span class="keyword">struct</span> bufferevent* bufev)</span>;</span><br></pre></td></tr></table></figure>

<h6 id="evbuffer-get-length函数"><a href="#evbuffer-get-length函数" class="headerlink" title="evbuffer_get_length函数"></a>evbuffer_get_length函数</h6><p>获取bufferevent里的缓冲区数据长度</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">evbuffer_get_length</span><span class="params">(<span class="keyword">struct</span> evbuffer* buf)</span></span><br></pre></td></tr></table></figure>

<h5 id="链接监听器"><a href="#链接监听器" class="headerlink" title="链接监听器"></a>链接监听器</h5><p>链接监听器封装了底层的socket通信相关函数, 比如socket, bind, listen, accept这几个函数。链接监听器创建后实际上相当于调用了socket, bind, listen, 此时等待新的客户端连接到来, 如果有新的客户端连接, 那么内部先进行调用accept处理, 然后调用用户指定的回调函数。可以先看看函数原型, 了解一下它是怎么运作的：</p>
<p>所在头文件: <code>event2/listener.h</code></p>
<h5 id="链接监听器相关函数"><a href="#链接监听器相关函数" class="headerlink" title="链接监听器相关函数"></a>链接监听器相关函数</h5><h6 id="evconnlistener-new-bind函数"><a href="#evconnlistener-new-bind函数" class="headerlink" title="evconnlistener_new_bind函数"></a>evconnlistener_new_bind函数</h6><p>在<strong>当前没有套接字的情况下</strong>对链接监听器进行初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> evconnlistener* <span class="title function_">evconnlistener_new_bind</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="keyword">struct</span> event_base *base,</span></span><br><span class="line"><span class="params">  evconnlistener_cb cb, </span></span><br><span class="line"><span class="params">  <span class="type">void</span> *ptr, </span></span><br><span class="line"><span class="params">  <span class="type">unsigned</span> flags, </span></span><br><span class="line"><span class="params">  <span class="type">int</span> backlog,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="keyword">struct</span> sockaddr *sa, </span></span><br><span class="line"><span class="params">  <span class="type">int</span> socklen)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>最后2个参数 <code>sa</code>,<code>socklen</code> 实际上就是bind使用的关键参数, </p>
</li>
<li><p><code>backlog</code>是listen函数的关键参数（</p>
<p>略有不同的是, 如果backlog是<code>-1</code>, 那么监听器会自动选择一个合适的值, 如果填0, 那么监听器会认为listen函数已经被调用过了）</p>
</li>
<li><p><code>ptr</code>是回调函数的参数</p>
</li>
<li><p><code>cb</code>是有新连接之后的回调函数</p>
<p>但是注意这个回调函数触发的时候, 链接器已经处理好新连接了, 并将与新连接通信的描述符交给回调函数</p>
<p><strong>回调函数格式</strong>:</p>
<p><code>typedef void (*evconnlistener_cb)(struct evconnlistener *evl, evutil_socket_t fd, struct sockaddr *cliaddr, int socklen, void *ptr);</code></p>
</li>
<li><p><code>flags</code> 需要参考几个值：<br><code>LEV_OPT_LEAVE_SOCKETS_BLOCKING</code>   文件描述符为阻塞的<br><code>LEV_OPT_CLOSE_ON_FREE</code>            关闭时自动释放监听描述符<br><code>LEV_OPT_REUSEABLE</code>                端口复用<br><code>LEV_OPT_THREADSAFE</code>               分配锁, 线程安全</p>
</li>
</ul>
<p>上面的flags参数注意区分与<a href="#bufferevent_socket_new%E5%87%BD%E6%95%B0"><code>bufferevent_socket_new</code></a>的<code>options</code>参数(BEV开头)不同</p>
<h6 id="evconnlistener-new函数"><a href="#evconnlistener-new函数" class="headerlink" title="evconnlistener_new函数"></a>evconnlistener_new函数</h6><p>在<strong>当前有套接字的情况</strong>下对链接监听器进行初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> evconnlistener *<span class="title function_">evconnlistener_new</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="keyword">struct</span> event_base *base,</span></span><br><span class="line"><span class="params">    evconnlistener_cb cb, </span></span><br><span class="line"><span class="params">  <span class="type">void</span> *ptr, </span></span><br><span class="line"><span class="params">  <span class="type">unsigned</span> flags,</span></span><br><span class="line"><span class="params">  <span class="type">int</span> backlog,</span></span><br><span class="line"><span class="params"><span class="type">evutil_socket_t</span> fd)</span>;</span><br></pre></td></tr></table></figure>

<p><code>evconnlistener_new</code>函数与前一个函数不同的地方在与后2个参数, 使用本函数时, 认为socket已经初始化好, 并且bind完成, 甚至也可以做完listen, 所以大多数时候, 我们都可以使用第一个函数。</p>
<p>参数说明参考<a href="#evconnlistener_new_bind%E5%87%BD%E6%95%B0">evconnlistener_new_bind</a></p>
<p>上面两个函数的回调函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*evconnlistener_cb)</span><span class="params">(<span class="keyword">struct</span> evconnlistener *evl, <span class="type">evutil_socket_t</span> fd, <span class="keyword">struct</span> sockaddr *cliaddr, <span class="type">int</span> socklen, <span class="type">void</span> *ptr)</span>;</span><br></pre></td></tr></table></figure>

<p>回调函数fd参数是<strong>与客户端通信的描述符</strong>, 并非是等待连接的监听的那个描述符, 所以cliaddr对应的也是新连接的对端地址信息, 已经是accept处理好的。</p>
<h6 id="evconnlistener-free函数"><a href="#evconnlistener-free函数" class="headerlink" title="evconnlistener_free函数"></a>evconnlistener_free函数</h6><p>释放链接监听器</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">evconnlistener_free</span><span class="params">(<span class="keyword">struct</span> evconnlistener *lev)</span>;</span><br></pre></td></tr></table></figure>

<h6 id="evconnlistener-enable函数"><a href="#evconnlistener-enable函数" class="headerlink" title="evconnlistener_enable函数"></a>evconnlistener_enable函数</h6><p>使链接监听器生效</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">evconnlistener_enable</span><span class="params">(<span class="keyword">struct</span> evconnlistener *lev)</span>;</span><br></pre></td></tr></table></figure>

<h6 id="evconnlistener-disable函数"><a href="#evconnlistener-disable函数" class="headerlink" title="evconnlistener_disable函数"></a>evconnlistener_disable函数</h6><p>使链接监听器失效</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">evconnlistener_disable</span><span class="params">(<span class="keyword">struct</span> evconnlistener *lev)</span>;</span><br></pre></td></tr></table></figure>

<h5 id="bufferevent和链接器服务器流程"><a href="#bufferevent和链接器服务器流程" class="headerlink" title="bufferevent和链接器服务器流程"></a>bufferevent和链接器服务器流程</h5><h6 id="主流程"><a href="#主流程" class="headerlink" title="主流程"></a>主流程</h6><ol>
<li>创建地基   —   <a href="#event_base_new%E5%87%BD%E6%95%B0"><code>event_base_new</code></a></li>
<li>创建socket,设置复用,listen,监听描述符上树实现监听调用accept(有客户端链接会调用<a href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5%E5%9B%9E%E8%B0%83%E6%B5%81%E7%A8%8B">回调函数&lt;客户端连接回调流程&gt;</a>)   —   <a href="#evconnlistener_new_bind%E5%87%BD%E6%95%B0"><code>evconnlistener_new_bind</code></a></li>
<li>进入事件循环,等待事件发生   —   <a href="#event_base_dispatch%E5%87%BD%E6%95%B0"><code>event_base_dispatch</code></a></li>
<li>跳出循环,释放资源   —   <a href="#evconnlistener_free%E5%87%BD%E6%95%B0"><code>evconnlistener_free</code></a>;<a href="#event_base_free%E5%87%BD%E6%95%B0"><code>event_base_free</code></a></li>
</ol>
<h6 id="客户端连接回调流程"><a href="#客户端连接回调流程" class="headerlink" title="客户端连接回调流程"></a>客户端连接回调流程</h6><ol>
<li>创建bufferevent(将通信文件描述符和bufferevent绑定)   —   <a href="#bufferevent_socket_new%E5%87%BD%E6%95%B0"><code>bufferevent_socket_new</code></a></li>
<li>设置回调函数:可以是<a href="#%E8%AF%BB%E5%9B%9E%E8%B0%83%E6%B5%81%E7%A8%8B">读回调</a>;写回调;信号事件回调   —   <a href="#bufferevent_setcb%E5%87%BD%E6%95%B0"><code>bufferevent_setcb</code></a></li>
<li>使回调函数生效(不写也行,默认生效)   —   <a href="#bufferevent_enable%E5%87%BD%E6%95%B0"><code>bufferevent_enable</code></a></li>
</ol>
<h6 id="读回调流程"><a href="#读回调流程" class="headerlink" title="读回调流程"></a>读回调流程</h6><ol>
<li>读bufferevent的读缓冲区数据   —   <a href="#bufferevent_read%E5%87%BD%E6%95%B0"><code>bufferevent_read</code></a></li>
<li>其他业务流程</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202209261621400.png" alt="image-20220926162128957"></p>
<h5 id="最终代码案例"><a href="#最终代码案例" class="headerlink" title="最终代码案例"></a>最终代码案例</h5><h6 id="服务器代码"><a href="#服务器代码" class="headerlink" title="服务器代码"></a>服务器代码</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写libevent服务端</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/bufferevent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/buffer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/listener.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/util.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/event.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解析sockaddr_in结构提取[ip:端口]字符串</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">acceptClient2Str</span><span class="params">(<span class="keyword">struct</span> sockaddr_in* client,<span class="type">char</span>* str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> sip[<span class="number">16</span>];</span><br><span class="line">    <span class="built_in">memset</span>(sip,<span class="number">0</span>,<span class="keyword">sizeof</span>(sip));</span><br><span class="line">    <span class="built_in">sprintf</span>(str,<span class="string">&quot;%s:%hu&quot;</span>,inet_ntop(AF_INET,&amp;client-&gt;sin_addr.s_addr,sip,<span class="keyword">sizeof</span>(sip)),ntohs(client-&gt;sin_port));</span><br><span class="line">    <span class="comment">//std::cout&lt;&lt;str&lt;&lt;std::endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//typedef void (*event_callback_fn)(evutil_socket_t fd, short events, void *arg);</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_cb</span><span class="params">(<span class="keyword">struct</span> bufferevent *bev, <span class="type">void</span> *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> str[<span class="number">99</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="type">int</span> n =bufferevent_read(bev,str,<span class="number">99</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;读到:&lt;%d&gt;%s\n&quot;</span>,n,str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">event_cb</span><span class="params">(<span class="keyword">struct</span> bufferevent *bev, <span class="type">short</span> what, <span class="type">void</span>*ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(what &amp; BEV_EVENT_EOF)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;有客户端断开连接\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过ptr指针将struct event_base指针传入进来</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">listener_cb</span><span class="params">(<span class="keyword">struct</span> evconnlistener *evl, <span class="type">evutil_socket_t</span> fd, </span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> sockaddr *cliaddr, <span class="type">int</span> socklen, <span class="type">void</span> *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> str[<span class="number">16</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	acceptClient2Str(cliaddr,str);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;客户端[%s]连接成功，占用%d描述符\n&quot;</span>,str,fd);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> =</span> ptr;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bufferevent</span> *<span class="title">bev</span> =</span> bufferevent_socket_new(base,fd,BEV_OPT_CLOSE_ON_FREE);</span><br><span class="line">	<span class="keyword">if</span>(!bev)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Error constructing bufferevent!\n&quot;</span>);</span><br><span class="line">		event_base_loopbreak(base);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	bufferevent_setcb(bev,read_cb,<span class="literal">NULL</span>,event_cb,<span class="literal">NULL</span>);<span class="comment">//此处的参数位无法将cliaddr传过去read_cb解析ip地址（应该已经被释放了）</span></span><br><span class="line">	bufferevent_enable(bev,EV_READ);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv</span>;</span></span><br><span class="line">	bzero(&amp;serv, <span class="keyword">sizeof</span>(serv));</span><br><span class="line">	serv.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">	serv.sin_port = htons(<span class="number">23456</span>);</span><br><span class="line">	serv.sin_family = AF_INET;</span><br><span class="line">	<span class="comment">//创建地基</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> =</span> event_base_new();</span><br><span class="line">	<span class="keyword">if</span>(base==<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;event_base_new error\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//创建事件连接监听器，如果有客户端连接会调用listener_cb回调函数</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">evconnlistener</span>* <span class="title">listener</span> =</span> evconnlistener_new_bind(base,listener_cb,base,</span><br><span class="line">	LEV_OPT_CLOSE_ON_FREE|LEV_OPT_REUSEABLE,<span class="number">-1</span>,&amp;serv,<span class="keyword">sizeof</span>(serv));</span><br><span class="line">	<span class="comment">//进入事件循环</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;等待连接中...\n&quot;</span>);</span><br><span class="line">	event_base_dispatch(base);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;跳出循环\n&quot;</span>);</span><br><span class="line">	evconnlistener_free(listener);</span><br><span class="line">	event_base_free(base);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写libevent客户端</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/bufferevent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/buffer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/listener.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/util.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/event.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解析sockaddr_in结构提取[ip:端口]字符串</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">acceptClient2Str</span><span class="params">(<span class="keyword">struct</span> sockaddr_in* client,<span class="type">char</span>* str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> sip[<span class="number">16</span>];</span><br><span class="line">    <span class="built_in">memset</span>(sip,<span class="number">0</span>,<span class="keyword">sizeof</span>(sip));</span><br><span class="line">    <span class="built_in">sprintf</span>(str,<span class="string">&quot;%s:%hu&quot;</span>,inet_ntop(AF_INET,&amp;client-&gt;sin_addr.s_addr,sip,<span class="keyword">sizeof</span>(sip)),ntohs(client-&gt;sin_port));</span><br><span class="line">    <span class="comment">//std::cout&lt;&lt;str&lt;&lt;std::endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//监控cmd输入回调</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cmd_msg_cb</span><span class="params">(<span class="type">evutil_socket_t</span> fd, <span class="type">short</span> events, <span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> msg[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> ret = read(fd,msg,<span class="keyword">sizeof</span>(msg));<span class="comment">//读标准输入</span></span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;read fail&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bufferevent</span>* <span class="title">bev</span> =</span> arg;<span class="comment">//传入buffereventt指针,目的是为了写到bufferevent的写缓冲区</span></span><br><span class="line">    <span class="comment">//发给服务端</span></span><br><span class="line">    bufferevent_write(bev,msg,ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读回调</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">server_msg_cb</span><span class="params">(<span class="keyword">struct</span> bufferevent *bev, <span class="type">void</span> *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> msg[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> n =bufferevent_read(bev,msg,<span class="keyword">sizeof</span>(msg));</span><br><span class="line">    msg[n] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d]%s\n&quot;</span>,n,msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//事件回调</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">event_cb</span><span class="params">(<span class="keyword">struct</span> bufferevent *bev, <span class="type">short</span> what, <span class="type">void</span>*ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//printf(&quot;事件回调:%hu\n&quot;,what);//连接成功为128,服务器断开为17</span></span><br><span class="line">    <span class="keyword">if</span>(what &amp; BEV_EVENT_EOF)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;连接断开\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(what &amp; BEV_EVENT_ERROR)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;发生错误\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (what &amp; BEV_EVENT_CONNECTED)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;连接成功\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//试图做清理,其实此处应该是将base传进来跳出循环才对</span></span><br><span class="line">    bufferevent_free(bev);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">ev</span> =</span> (<span class="keyword">struct</span> event*)ctx;</span><br><span class="line">    event_free(ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(argc&lt;<span class="number">3</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;please input 2 parameter\n&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span>* <span class="title">base</span> =</span> event_base_new();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">bufferevent</span>* <span class="title">bev</span> =</span> bufferevent_socket_new(base,<span class="number">-1</span>,BEV_OPT_CLOSE_ON_FREE);</span><br><span class="line">    <span class="comment">//新建监控标准输入事件  (往回调中传入bufferevent的指针,目的是为了写缓冲区)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span>* <span class="title">ev_cmd</span> =</span> event_new(base,STDIN_FILENO,EV_READ | EV_PERSIST,cmd_msg_cb,bev);</span><br><span class="line">    <span class="comment">//上树</span></span><br><span class="line">    event_add(ev_cmd,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv</span>;</span></span><br><span class="line">    serv.sin_family = AF_INET;</span><br><span class="line">    serv.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line">    inet_aton(argv[<span class="number">1</span>],&amp;serv.sin_addr.s_addr);</span><br><span class="line">    bufferevent_socket_connect(bev,&amp;serv,<span class="keyword">sizeof</span>(serv));</span><br><span class="line">    bufferevent_setcb(bev,server_msg_cb,<span class="literal">NULL</span>,event_cb,(<span class="type">void</span>*)ev_cmd);</span><br><span class="line">    bufferevent_enable(bev,EV_READ | EV_PERSIST);</span><br><span class="line">    event_base_dispatch(base);<span class="comment">//循环等待</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;跳出循环\n&quot;</span>);</span><br><span class="line">    event_base_free(base);</span><br><span class="line">    event_free(ev_cmd);</span><br><span class="line">    bufferevent_free(bev);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="通信效率优化"><a href="#通信效率优化" class="headerlink" title="通信效率优化"></a>通信效率优化</h2><p>通信效率:单位时间内客户端或者服务端接收或者发送数据的量.</p>
<p><strong>多线程处理效率优于多进程</strong>(多线程更节省资源)</p>
<p><strong>多路IO复用技术</strong>:既不使用多线程,也不使用多进程,在一个进程或一个线程中让多个客户端同时请求服务(都是委托内核进行监控,若有事件发生则通知应用程序)</p>
<h3 id="客户端优化"><a href="#客户端优化" class="headerlink" title="客户端优化"></a>客户端优化</h3><p><strong>客户端的效率优化</strong></p>
<ol>
<li><p>单进程只处理一个连接</p>
</li>
<li><p>多线程使用同一个连接</p>
</li>
<li><p>多线程使用多个连接   (使用到连接池)</p>
<p>缺点:如果频繁创建连接和销毁连接会有时间消耗</p>
</li>
<li><p>连接池+线程池(避免上述缺点)</p>
</li>
</ol>
<p><strong>连接池只用于客户端</strong></p>
<p>连接池不用于服务端,因为连接是只有客户端发起连接请求之后才会有的.</p>
<p><strong>连接池思想</strong></p>
<ol>
<li>一个数据结构保存连接信息</li>
<li>创建连接池操作—poolInit()</li>
<li>获取连接池操作   (如队头取)</li>
<li>使用完将连接存放的操作   (如存到队尾)</li>
<li>可以根据实际需要动态调整连接的数量</li>
<li>销毁连接池</li>
</ol>
<blockquote>
<p>在网络编程中，connect()函数用于建立与远程主机的连接。当connect()函数返回-1时，并且errno被设置为<code>EINPROGRESS</code>，表示连接操作正在进行中，但是仍未完成。</p>
<p>这种情况通常发生在非阻塞模式下调用connect()函数时。在非阻塞模式下，connect()函数立即返回，不会阻塞程序，同时设置errno为EINPROGRESS。此时需要通过select()或poll()等函数检查套接字的可写性，以确定连接是否已经建立。如果连接成功建立，套接字将变成可写状态；如果连接建立失败，则套接字将变成可读状态，并且errno被设置为相应的错误码。</p>
<p>需要注意的是，在阻塞模式下调用connect()函数，如果连接建立失败，connect()函数将会阻塞程序并返回相应的错误码，不会设置errno为<code>EINPROGRESS</code>。</p>
</blockquote>
<h4 id="客户端案例"><a href="#客户端案例" class="headerlink" title="客户端案例"></a>客户端案例</h4><h5 id="TcpClient-h"><a href="#TcpClient-h" class="headerlink" title="TcpClient.h"></a>TcpClient.h</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用于通信的套接字类 */</span></span><br><span class="line"><span class="comment">// 超时的时间</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> TIMEOUT = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TcpClient</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">enum</span> <span class="title class_">ErrorType</span></span><br><span class="line">	&#123;</span><br><span class="line">		ParamError = <span class="number">3001</span>,</span><br><span class="line">		TimeoutError,</span><br><span class="line">		PeerCloseError,</span><br><span class="line">		MallocError</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">TcpClient</span>();</span><br><span class="line">	<span class="comment">// 使用一个可以用于通信的套接字实例化套接字对象</span></span><br><span class="line">	<span class="built_in">TcpClient</span>(<span class="type">int</span> connfd);</span><br><span class="line">	~<span class="built_in">TcpClient</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 连接服务器</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">connectToHost</span><span class="params">(<span class="type">char</span> *ip, <span class="type">unsigned</span> <span class="type">short</span> port, <span class="type">int</span> timeout = TIMEOUT)</span></span>;</span><br><span class="line">	<span class="comment">// 发送数据</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">sendMsg</span><span class="params">(<span class="type">char</span> *sendData, <span class="type">int</span> dataLen, <span class="type">int</span> timeout = TIMEOUT)</span></span>;</span><br><span class="line">	<span class="comment">// 接收数据</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">recvMsg</span><span class="params">(<span class="type">char</span> **recvData, <span class="type">int</span> &amp;recvLen, <span class="type">int</span> timeout = TIMEOUT)</span></span>;</span><br><span class="line">	<span class="comment">// 断开连接</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">disConnect</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// 释放内存(用于手动释放传出读到的数据所在的空间)</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">freeMemory</span><span class="params">(<span class="type">char</span> **buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 设置I/O为非阻塞模式</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">blockIO</span><span class="params">(<span class="type">int</span> fd)</span></span>;</span><br><span class="line">	<span class="comment">// 设置I/O为阻塞模式</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">noBlockIO</span><span class="params">(<span class="type">int</span> fd)</span></span>;</span><br><span class="line">	<span class="comment">// 读超时检测函数，不含读操作</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">readTimeout</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> wait_seconds)</span></span>;</span><br><span class="line">	<span class="comment">// 写超时检测函数, 不包含写操作</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">writeTimeout</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> wait_seconds)</span></span>;</span><br><span class="line">	<span class="comment">// 带连接超时的connect函数</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">connectTimeout</span><span class="params">(<span class="keyword">struct</span> sockaddr_in *addr, <span class="type">unsigned</span> <span class="type">int</span> wait_seconds)</span></span>;</span><br><span class="line">	<span class="comment">// 每次从缓冲区中读取n个字符</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">readn</span><span class="params">(<span class="type">void</span> *buf, <span class="type">int</span> count)</span></span>;</span><br><span class="line">	<span class="comment">// 每次往缓冲区写入n个字符</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">writen</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *buf, <span class="type">int</span> count)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_fd; <span class="comment">// 用于通信的套接字</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="TcpClient-cpp"><a href="#TcpClient-cpp" class="headerlink" title="TcpClient.cpp"></a>TcpClient.cpp</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TcpClient.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">TcpClient::<span class="built_in">TcpClient</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">TcpClient::<span class="built_in">TcpClient</span>(<span class="type">int</span> connfd) : <span class="built_in">m_fd</span>(connfd)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">TcpClient::~<span class="built_in">TcpClient</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpClient::connectToHost</span><span class="params">(<span class="type">char</span> *ip, <span class="type">unsigned</span> <span class="type">short</span> port, <span class="type">int</span> timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ip == <span class="literal">NULL</span> || port &lt;= <span class="number">0</span> || port &gt; <span class="number">65535</span> || timeout &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = ParamError;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    m_fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="keyword">if</span> (m_fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = errno;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;func socket() err:  %d\n&quot;</span>, ret);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    sockaddr_in serAddr;</span><br><span class="line">    serAddr.sin_family = AF_INET;</span><br><span class="line">    serAddr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">    serAddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(ip);</span><br><span class="line">    ret = <span class="built_in">connectTimeout</span>(&amp;serAddr, timeout);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span> &amp;&amp; errno == ETIMEDOUT)</span><br><span class="line">        &#123;</span><br><span class="line">            ret = TimeoutError;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;func connect_timeout() err:&quot;</span> &lt;&lt; errno &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpClient::sendMsg</span><span class="params">(<span class="type">char</span> *sendData, <span class="type">int</span> dataLen, <span class="type">int</span> timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sendData == <span class="literal">NULL</span> || dataLen &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = ParamError;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = <span class="built_in">writeTimeout</span>(timeout);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">0</span>) <span class="comment">// 表示可以正常写了</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 开辟空间容纳待发送的数据(头4个字节用来存发送的数据长度)</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> *netdata = (<span class="type">unsigned</span> <span class="type">char</span> *)<span class="built_in">malloc</span>(dataLen + <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span> (netdata == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ret = MallocError;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;func Client_sendMsg() err:&quot;</span> &lt;&lt; ret &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> netlen = <span class="built_in">htonl</span>(dataLen);</span><br><span class="line">        <span class="built_in">memcpy</span>(netdata, &amp;netlen, <span class="number">4</span>); <span class="comment">// 头4个空间放传送数据的长度</span></span><br><span class="line">        <span class="built_in">memcpy</span>(netdata + <span class="number">4</span>, sendData, dataLen);</span><br><span class="line">        <span class="built_in">writen</span>(netdata, dataLen + <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span> (netdata != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">free</span>(netdata);</span><br><span class="line">            netdata = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 失败返回-1，超时返回-1并且errno = ETIMEDOUT</span></span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span> &amp;&amp; errno == ETIMEDOUT)</span><br><span class="line">        &#123;</span><br><span class="line">            ret = TimeoutError;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;func sckClient_send() mlloc Err:%d\n &quot;</span>, ret);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpClient::recvMsg</span><span class="params">(<span class="type">char</span> **recvData, <span class="type">int</span> &amp;recvLen, <span class="type">int</span> timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (recvData == <span class="literal">NULL</span> || recvLen == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = ParamError;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;func sckClient_rev() timeout , err:%d \n&quot;</span>, TimeoutError);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = <span class="built_in">readTimeout</span>(timeout); <span class="comment">// 先检测一下是否可读</span></span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span> || errno == ETIMEDOUT)</span><br><span class="line">        &#123;</span><br><span class="line">            ret = TimeoutError;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> netdatalen = <span class="number">0</span>;</span><br><span class="line">    ret = <span class="built_in">readn</span>(&amp;netdatalen, <span class="number">4</span>); <span class="comment">// 读包头 4个字节</span></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// printf(&quot;func readn() err:%d \n&quot;, ret);</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = PeerCloseError;</span><br><span class="line">        <span class="comment">// printf(&quot;func readn() err peer closed:%d \n&quot;, ret);</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">ntohl</span>(netdatalen);</span><br><span class="line">    <span class="type">char</span> *tmpBuf = (<span class="type">char</span> *)<span class="built_in">malloc</span>(n + <span class="number">1</span>); <span class="comment">// 多分配一个字节内容，兼容可见字符串 字符串的真实长度仍然为n</span></span><br><span class="line">    <span class="keyword">if</span> (tmpBuf == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = MallocError;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = <span class="built_in">readn</span>(tmpBuf, n); <span class="comment">// 根据长度读数据</span></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// printf(&quot;func readn() err:%d \n&quot;, ret);</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = PeerCloseError;</span><br><span class="line">        <span class="comment">// printf(&quot;func readn() err peer closed:%d \n&quot;, ret);</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *recvData = tmpBuf;</span><br><span class="line">    recvLen = n;</span><br><span class="line">    tmpBuf[n] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 多分配一个字节内容，兼容可见字符串 字符串的真实长度仍然为n</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpClient::disConnect</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_fd &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(m_fd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpClient::freeMemory</span><span class="params">(<span class="type">char</span> **buf)</span> <span class="comment">// 释放内存,并将指针置空</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (*buf != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(*buf);</span><br><span class="line">        *buf = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * writeTimeout - 写超时检测函数，不含写操作</span></span><br><span class="line"><span class="comment"> * @wait_seconds: 等待超时秒数，如果为0表示不检测超时</span></span><br><span class="line"><span class="comment"> * 成功（未超时）返回0，失败返回-1，超时返回-1并且errno = ETIMEDOUT</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpClient::writeTimeout</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> wait_seconds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (wait_seconds &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fd_set write_fdset;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">timeval</span> timeout;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">FD_ZERO</span>(&amp;write_fdset);</span><br><span class="line">        <span class="built_in">FD_SET</span>(m_fd, &amp;write_fdset);</span><br><span class="line"></span><br><span class="line">        timeout.tv_sec = wait_seconds;</span><br><span class="line">        timeout.tv_usec = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            ret = <span class="built_in">select</span>(m_fd + <span class="number">1</span>, <span class="literal">NULL</span>, &amp;write_fdset, <span class="literal">NULL</span>, &amp;timeout);</span><br><span class="line">        &#125; <span class="keyword">while</span> (ret &lt; <span class="number">0</span> &amp;&amp; errno == EINTR); <span class="comment">// 防止信号导致的中断</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ret = <span class="number">-1</span>;</span><br><span class="line">            errno = ETIMEDOUT;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">1</span>)</span><br><span class="line">            ret = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * connectTimeout - connect</span></span><br><span class="line"><span class="comment"> * @addr: 要连接的对方地址</span></span><br><span class="line"><span class="comment"> * @wait_seconds: 等待超时秒数，如果为0表示正常模式</span></span><br><span class="line"><span class="comment"> * 成功（未超时）返回0，失败返回-1，超时返回-1并且errno = ETIMEDOUT</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpClient::connectTimeout</span><span class="params">(sockaddr_in *addr, <span class="type">unsigned</span> <span class="type">int</span> wait_seconds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="keyword">if</span> (wait_seconds &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">blockIO</span>(m_fd);                                                        <span class="comment">// 设置非阻塞</span></span><br><span class="line">    ret = <span class="built_in">connect</span>(m_fd, (<span class="keyword">struct</span> sockaddr *)addr, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr_in)); <span class="comment">// 真正的连接connect函数</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span> &amp;&amp; errno == EINPROGRESS)</span><br><span class="line">    &#123;</span><br><span class="line">        fd_set connect_fdset;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">timeval</span> timeout; <span class="comment">// select函数需要用的控制阻塞时间的结构体</span></span><br><span class="line">        <span class="built_in">FD_ZERO</span>(&amp;connect_fdset);</span><br><span class="line">        <span class="built_in">FD_SET</span>(m_fd, &amp;connect_fdset);</span><br><span class="line">        timeout.tv_sec = wait_seconds;</span><br><span class="line">        timeout.tv_usec = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 建立连接,属于要监视写事件</span></span><br><span class="line">            ret = <span class="built_in">select</span>(m_fd + <span class="number">1</span>, <span class="literal">NULL</span>, &amp;connect_fdset, <span class="literal">NULL</span>, &amp;timeout);</span><br><span class="line">        &#125; <span class="keyword">while</span> (ret &lt; <span class="number">0</span> &amp;&amp; errno == EINTR); <span class="comment">// 防止阻塞状态被信号打断</span></span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ret = <span class="number">-1</span>;</span><br><span class="line">            errno = ETIMEDOUT;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;select err&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* ret返回为1（表示套接字可写），可能有两种情况，</span></span><br><span class="line"><span class="comment">            一种是连接建立成功，一种是套接字产生错误，*/</span></span><br><span class="line">            <span class="comment">/* 此时错误信息不会保存至errno变量中，</span></span><br><span class="line"><span class="comment">            因此，需要调用getsockopt来获取。 */</span></span><br><span class="line">            <span class="type">int</span> err;</span><br><span class="line">            <span class="type">socklen_t</span> socklen = <span class="built_in">sizeof</span>(err);</span><br><span class="line">            <span class="type">int</span> sockoptret = <span class="built_in">getsockopt</span>(m_fd, SOL_SOCKET, SO_ERROR, &amp;err, &amp;socklen);</span><br><span class="line">            <span class="keyword">if</span> (sockoptret == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;getsockopt err&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (err == <span class="number">0</span>) <span class="comment">// 正常连接</span></span><br><span class="line">                ret = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                errno = err;</span><br><span class="line">                ret = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wait_seconds &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">noBlockIO</span>(m_fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * readn - 读取固定字节数</span></span><br><span class="line"><span class="comment"> * @fd: 文件描述符</span></span><br><span class="line"><span class="comment"> * @buf: 接收缓冲区</span></span><br><span class="line"><span class="comment"> * @count: 要读取的字节数</span></span><br><span class="line"><span class="comment"> * 成功返回count，失败返回-1，读到EOF返回&lt;count</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpClient::readn</span><span class="params">(<span class="type">void</span> *buf, <span class="type">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">size_t</span> nleft = count;</span><br><span class="line">    <span class="type">ssize_t</span> nread;</span><br><span class="line">    <span class="type">char</span> *bufp = (<span class="type">char</span> *)buf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((nread = <span class="built_in">read</span>(m_fd, bufp, nleft)) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> count - nleft;</span><br><span class="line"></span><br><span class="line">        bufp += nread;</span><br><span class="line">        nleft -= nread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * writen - 确保数据发送完全</span></span><br><span class="line"><span class="comment"> * @buf: 发送缓冲区</span></span><br><span class="line"><span class="comment"> * @count: 要读取的字节数</span></span><br><span class="line"><span class="comment"> * 成功返回count，失败返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpClient::writen</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *buf, <span class="type">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">size_t</span> nleft = count;</span><br><span class="line">    <span class="type">ssize_t</span> nwritten;</span><br><span class="line">    <span class="type">char</span> *bufp = (<span class="type">char</span> *)buf;</span><br><span class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((nwritten = <span class="built_in">write</span>(m_fd, bufp, nleft)) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nwritten == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        bufp += nwritten;</span><br><span class="line">        nleft -= nwritten;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpClient::blockIO</span><span class="params">(<span class="type">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> flags = <span class="built_in">fcntl</span>(fd, F_GETFL);</span><br><span class="line">    <span class="keyword">if</span> (flags == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    flags |= O_NONBLOCK;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fcntl</span>(fd, F_SETFL, flags) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpClient::noBlockIO</span><span class="params">(<span class="type">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> flags = <span class="built_in">fcntl</span>(fd, F_GETFL);</span><br><span class="line">    <span class="keyword">if</span> (flags == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    flags &amp;= ~O_NONBLOCK;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fcntl</span>(fd, F_SETFL, flags) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpClient::readTimeout</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> wait_seconds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (wait_seconds &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fd_set read_fdset;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">timeval</span> timeout;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">FD_ZERO</span>(&amp;read_fdset);</span><br><span class="line">        <span class="built_in">FD_SET</span>(m_fd, &amp;read_fdset);</span><br><span class="line"></span><br><span class="line">        timeout.tv_sec = wait_seconds;</span><br><span class="line">        timeout.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// select返回值三态</span></span><br><span class="line">        <span class="comment">// 1 若timeout时间到（超时），没有检测到读事件 ret返回=0</span></span><br><span class="line">        <span class="comment">// 2 若ret返回&lt;0 &amp;&amp;  errno == EINTR 说明select的过程中被别的信号中断（可中断睡眠原理）</span></span><br><span class="line">        <span class="comment">// 2-1 若返回-1，select出错</span></span><br><span class="line">        <span class="comment">// 3 若ret返回值&gt;0 表示有read事件发生，返回事件发生的个数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            ret = <span class="built_in">select</span>(m_fd + <span class="number">1</span>, &amp;read_fdset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;timeout);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">while</span> (ret &lt; <span class="number">0</span> &amp;&amp; errno == EINTR);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ret = <span class="number">-1</span>;</span><br><span class="line">            errno = ETIMEDOUT;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">1</span>)</span><br><span class="line">            ret = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="服务端优化"><a href="#服务端优化" class="headerlink" title="服务端优化"></a>服务端优化</h3><h4 id="服务端案例"><a href="#服务端案例" class="headerlink" title="服务端案例"></a>服务端案例</h4><p>需配合<a href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A1%88%E4%BE%8B">客户端案例</a>使用</p>
<h5 id="TcpServer-h"><a href="#TcpServer-h" class="headerlink" title="TcpServer.h"></a>TcpServer.h</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TcpClient.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 超时的时间</span></span><br><span class="line"><span class="comment">// static const int TIMEOUT = 10000;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TcpServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">TcpServer</span>();</span><br><span class="line">	~<span class="built_in">TcpServer</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 服务器设置监听</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">setListen</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> port)</span></span>;</span><br><span class="line">	<span class="comment">// 等待并接受客户端连接请求, 默认连接超时时间为10000s</span></span><br><span class="line">	<span class="function">TcpClient* <span class="title">acceptConn</span><span class="params">(<span class="type">int</span> timeout = <span class="number">10000</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">closefd</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">acceptTimeout</span><span class="params">(<span class="type">int</span> wait_seconds)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_lfd;	<span class="comment">// 用于监听的文件描述符</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> m_addrCli;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="TcpServer-cpp"><a href="#TcpServer-cpp" class="headerlink" title="TcpServer.cpp"></a>TcpServer.cpp</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TcpServer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">TcpServer::<span class="built_in">TcpServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TcpServer::~<span class="built_in">TcpServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpServer::setListen</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr_in));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">    servaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    m_lfd = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (m_lfd &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> errno;</span><br><span class="line">    <span class="comment">// 设置端口复用选项为1,即打开</span></span><br><span class="line">    <span class="type">int</span> on = <span class="number">1</span>;</span><br><span class="line">    ret = <span class="built_in">setsockopt</span>(m_lfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, <span class="built_in">sizeof</span>(on));</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> errno;</span><br><span class="line">    ret = <span class="built_in">bind</span>(m_lfd, (<span class="type">const</span> sockaddr *)&amp;servaddr, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr_in));</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> errno;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">listen</span>(m_lfd, SOMAXCONN);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> errno;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TcpClient *<span class="title">TcpServer::acceptConn</span><span class="params">(<span class="type">int</span> timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> connfd = <span class="built_in">acceptTimeout</span>(timeout);</span><br><span class="line">    <span class="keyword">if</span> (connfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (connfd == <span class="number">-1</span> &amp;&amp; errno == ETIMEDOUT)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;func accept_timeout() timeout err \n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;acceptConn err&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TcpClient</span>(connfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::closefd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">close</span>(m_lfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpServer::acceptTimeout</span><span class="params">(<span class="type">int</span> wait_seconds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">socklen_t</span> addrlen = <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr_in);</span><br><span class="line">    <span class="keyword">if</span> (wait_seconds &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fd_set accept_fdset;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">timeval</span> timeout;</span><br><span class="line">        <span class="built_in">FD_ZERO</span>(&amp;accept_fdset);</span><br><span class="line">        <span class="built_in">FD_SET</span>(m_lfd, &amp;accept_fdset);</span><br><span class="line">        timeout.tv_sec = wait_seconds;</span><br><span class="line">        timeout.tv_usec = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; wait_seconds &lt;&lt; std::endl;</span><br><span class="line">            ret = <span class="built_in">select</span>(m_lfd + <span class="number">1</span>, &amp;accept_fdset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;timeout);</span><br><span class="line">        &#125; <span class="keyword">while</span> (ret &lt; <span class="number">0</span> &amp;&amp; errno == EINTR);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errno = ETIMEDOUT;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一但检测出 有select事件发生，表示对方完成了三次握手，客户端有新连接建立</span></span><br><span class="line">    <span class="comment">// 此时再调用accept将不会堵塞</span></span><br><span class="line">    ret = <span class="built_in">accept</span>(m_lfd, (<span class="keyword">struct</span> sockaddr *)&amp;m_addrCli, &amp;addrlen); <span class="comment">// 返回已连接套接字</span></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = errno;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="web服务器"><a href="#web服务器" class="headerlink" title="web服务器"></a>web服务器</h1><p>能够解析http协议的软件的电脑</p>
<h2 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h2><ul>
<li>请求协议</li>
<li>应答协议(响应)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求</span></span><br><span class="line">请求行 -&gt; 请求方式(get/post) 请求url地址 协议</span><br><span class="line">请求头 -&gt; 放一写服务器要使用的附加信息</span><br><span class="line"></span><br><span class="line">请求体 -&gt; 一般放一写请求参数</span><br><span class="line"></span><br><span class="line"><span class="comment">//响应</span></span><br><span class="line">状态行 -&gt; 协议 状态码</span><br><span class="line">响应头 -&gt; 放一些客户端要使用的附加信息</span><br><span class="line"></span><br><span class="line">响应体 -&gt;服务器返回的真正客户端要用的内容(HTML,json)等</span><br></pre></td></tr></table></figure>

<h3 id="http请求消息"><a href="#http请求消息" class="headerlink" title="http请求消息"></a>http请求消息</h3><p>我们要开发的服务器与浏览器通信采用的就是http协议,在浏览器想访问一个资源的时候,在浏览器输入访问地址(例如<a href="http://127.0.0.1:8000),地址输入完成后当敲击回车键的时候,浏览器就将请求消息发送给服务器">http://127.0.0.1:8000),地址输入完成后当敲击回车键的时候,浏览器就将请求消息发送给服务器</a></p>
<p>服务器socket收到的数据如下:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202209291727406.png" alt="image-20220929172726558"></p>
<p>这个消息看起来很乱很复杂,对应的就是我们说的请求消息.<br>    请求消息分为四部分内容:</p>
<ol>
<li><strong>请求行</strong> 说明<strong>请求类型</strong>,要<strong>访问的资源</strong>(请求指令或请求文件等资源,如果是get类型,问号后还会带数据),以及<strong>使用的http版本</strong></li>
<li><strong>请求头</strong>  说明服务器使用的附加信息,都是<strong>键值对</strong>,比如表明浏览器类型 </li>
<li><strong>空行</strong>  不能省略-而且是<code>\r\n</code>,包括请求行和请求头中每一行都是以<code>\r\n</code>结尾(<code>\r</code>是移动到末尾,<code>\n</code>是换行)</li>
<li><strong>请求体(请求数据)</strong>  表明请求的特定数据内容,可以省略-如登陆时,会将用户名和密码内容作为请求数据</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202209301345678.png" alt="image-20220930134506074"></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>xxx.xxx.xxx.xxx:23456</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>max-age=0</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span><span class="punctuation">: </span>1</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.9,en;q=0.8,ja;q=0.7</span><br></pre></td></tr></table></figure>

<h4 id="请求类型"><a href="#请求类型" class="headerlink" title="请求类型"></a>请求类型</h4><p>http协议有很多种请求类型,对我们来说常见的用的最多的是get和post请求。常见的请求类型如下：</p>
<ol>
<li><p><strong><code>Get</code></strong> 请求指定的页面信息,<strong>请求数据被包含到url中</strong>,并返回实体主体.在http协议中数据被包含在<code>请求行的要访问资源中</code></p>
<p>由于get请求不存在请求体,所以他的请求头中没有<code>Content-Length</code>和<code>Content-Type</code>键值对.</p>
</li>
<li><p><strong><code>Post</code></strong>  向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。<strong>数据被包含在请求体(请求数据)中</strong>。POST请求可能会导致新的资源的建立和&#x2F;或已有资源的修改。</p>
</li>
<li><p><strong><code>Head</code></strong> 类似于get请求，但是响应消息没有内容，只是获得报头</p>
</li>
<li><p><strong><code>Put</code></strong> 从客户端向浏览器传送的数据取代指定的文档内容</p>
</li>
<li><p><strong><code>Delete</code></strong> 请求服务器删除指定的页面</p>
</li>
<li><p><strong><code>Connect</code></strong>  HTTP&#x2F;1.1协议中预留给能够将连接改为管道方式的代理服务器</p>
</li>
<li><p><strong><code>Options</code></strong> 允许客户端查看浏览器的性能</p>
</li>
<li><p><strong><code>Trace</code></strong> 回显服务器收到的请求，主要用于测试和诊断</p>
</li>
</ol>
<p>get 和 post 请求都是<strong>请求资源</strong>,而且都会提交数据,如果提交密码信息用get请求,就会在url中<strong>明文显示</strong>,而post则不会显示出涉密信息.</p>
<h4 id="请求头中重要内容"><a href="#请求头中重要内容" class="headerlink" title="请求头中重要内容"></a>请求头中重要内容</h4><ul>
<li><p><strong><code>User-Agent</code></strong>:请求载体的身份标识(用啥发送的请求)</p>
</li>
<li><p><strong><code>Referer</code></strong>:防盗链(这次请求是从哪个页面来的?往往用于反爬)</p>
</li>
<li><p><strong><code>cookie</code></strong>:本地字符串数据信息(用户登录信息,反爬的token)</p>
<blockquote>
<p>session是服务器为了保存用户状态而创建的一个拥有唯一id特殊对象,并将它以cookie的方式发送给浏览器,当浏览器再次访问此网站时,网站的服务器就会依据session的id找到对应的session对象</p>
<p>其中session是存在服务器上的,cookie是存放在用户端的</p>
<p>session可以类比成酒店前台电脑里的信息,cookie相当于房卡</p>
</blockquote>
</li>
<li><p><strong><code>Content-Type</code></strong>:<strong>如果有请求体则必须有该项</strong>  表示返回的数据是什么类型的(均以<code>\r\n</code>结尾),如:</p>
<ul>
<li><code>text/plain</code> 纯文本  </li>
<li><code>text/html</code>  网页</li>
<li><code>text/json</code>  json数据</li>
<li>…</li>
</ul>
</li>
<li><p><strong><code>Content-Length</code></strong>:表示请求体(请求数据)的长度</p>
</li>
</ul>
<h5 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h5><blockquote>
<ul>
<li>Http协议规定POST提交的数据必须放在消息主题(entity-body)中,但协议并没有规定数据必须使用什么编码方式</li>
<li>开发者可以自己决定消息主题的格式</li>
<li>数据发送出去,还要服务端解析成功才有意义,服务端通常是根据请求头中的<code>Content-Type</code>字段来获知请求中的消息主体是用何种方式编码,再对主体进行解析</li>
</ul>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://tool.oschina.net/commons">Content-Type类型盘点跳转</a></p>
<p><code>Content-Type</code><strong>四种常用方式</strong></p>
<ul>
<li><p><strong><code>application/x-www-form-urlencoded</code></strong></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#请求行</span><br><span class="line"><span class="keyword">POST</span> <span class="string">http://www.example.com</span> <span class="meta">HTTP/1.1</span></span><br><span class="line">#请求头</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/x-www-form-urlencoded;charset=utf-8</span><br><span class="line">#空行</span><br><span class="line">#请求数据(向服务器提交的数据)</span><br><span class="line">title=test&amp;user=kevin&amp;passwd=32222</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>application/json</code></strong></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/<span class="number">1.1</span></span><br><span class="line">Content-Type<span class="punctuation">:</span> application/json;charset=utf<span class="number">-8</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;title&quot;</span><span class="punctuation">:</span><span class="string">&quot;test&quot;</span><span class="punctuation">,</span><span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">]</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>text/xml</code></strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Content_Type: text/xml</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">methodcall</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">methodname</span> <span class="attr">color</span>=<span class="string">&quot;red&quot;</span>&gt;</span>examples.getStateName<span class="tag">&lt;/<span class="name">methodname</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">params</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span><span class="tag">&lt;<span class="name">i4</span>&gt;</span>41<span class="tag">&lt;/<span class="name">i4</span>&gt;</span><span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">params</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">methodcall</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>multipart/form-data</code></strong></p>
<p>传输大文件(大数据块)常用的格式</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>multipart/form-data</span><br><span class="line"></span><br><span class="line"><span class="language-jboss-cli"><span class="comment">#发送的数据(两张图片)</span></span></span><br><span class="line"><span class="language-jboss-cli"><span class="params">------WebKitFormBoundaryPpL3BfPQ4cHShsBz</span> \r\n</span></span><br><span class="line"><span class="language-jboss-cli">Content-Disposition: from-data; name=<span class="string">&quot;file&quot;</span>;filename=<span class="string">&quot;qw.png&quot;</span></span></span><br><span class="line"><span class="language-jboss-cli">Content-Type: image/png\r\n; md5=<span class="string">&quot;xxxxxxxxx&quot;</span>\r\n</span></span><br><span class="line"><span class="language-jboss-cli"><span class="string">..........</span>具体的文件内容<span class="string">..........</span></span></span><br><span class="line"><span class="language-jboss-cli"><span class="string">..........</span>具体的文件内容<span class="string">..........</span></span></span><br><span class="line"><span class="language-jboss-cli"><span class="params">------WebKitFormBoundaryPpL3BfPQ4cHShsBz--</span></span></span><br><span class="line"><span class="language-jboss-cli">Content-Disposition: from-data; name=<span class="string">&quot;file&quot;</span>;filename=<span class="string">&quot;qw2.png&quot;</span></span></span><br><span class="line"><span class="language-jboss-cli">Content-Type: image/png\r\n; md5=<span class="string">&quot;xxxxxxxxx&quot;</span>\r\n</span></span><br><span class="line"><span class="language-jboss-cli"><span class="string">..........</span>具体的文件内容<span class="string">..........</span></span></span><br><span class="line"><span class="language-jboss-cli"><span class="string">..........</span>具体的文件内容<span class="string">..........</span></span></span><br><span class="line"><span class="language-jboss-cli"><span class="params">------WebKitFormBoundaryPpL3BfPQ4cHShsBz--</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>上面的 <code>..........具体的文件内容..........</code>指代具体要传的文件内容</p>
<h3 id="http响应消息"><a href="#http响应消息" class="headerlink" title="http响应消息"></a>http响应消息</h3><p>响应消息是代表服务器收到请求消息后,给浏览器做的反馈,所以响应消息是服务器发送给浏览器的,响应消息也分为四部分:</p>
<ol>
<li><strong>状态行</strong> 包括<strong>http版本号</strong>,<strong>状态码</strong>,<strong>状态信息</strong></li>
<li><strong>消息报头</strong> 说明客户端要使用的一些附加信息,也是<strong>键值对</strong>(Content-Type是必填的)</li>
<li><strong>空行</strong> \r\n 同样不能省略</li>
<li><strong>响应正文</strong> 服务器返回给客户端的文本信息</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202209301406297.png" alt="image-20220930140603665"></p>
<h4 id="http常见状态码"><a href="#http常见状态码" class="headerlink" title="http常见状态码"></a>http常见状态码</h4><p>http状态码由三位数字组成,第一个数字代表响应的类别,有五种分类:</p>
<table>
<thead>
<tr>
<th align="left">分类</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1**</td>
<td align="left">信息，服务器收到请求，需要请求者继续执行操作</td>
</tr>
<tr>
<td align="left">2**</td>
<td align="left">成功，操作被成功接收并处理</td>
</tr>
<tr>
<td align="left">3**</td>
<td align="left">重定向，需要进一步的操作以完成请求</td>
</tr>
<tr>
<td align="left">4**</td>
<td align="left">客户端错误，请求包含语法错误或无法完成请求</td>
</tr>
<tr>
<td align="left">5**</td>
<td align="left">服务器错误，服务器在处理请求的过程中发生了错误</td>
</tr>
</tbody></table>
<blockquote>
<p>注意:看到2开头表示成功;看到4开头表示是前端的问题;看到5开头表示后端接口的问题</p>
</blockquote>
<p>常见的状态码如下:</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>含义</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>200</td>
<td>OK</td>
<td>客户端请求成功</td>
</tr>
<tr>
<td>301</td>
<td>Moved Permanently</td>
<td>重定向</td>
</tr>
<tr>
<td>400</td>
<td>Bad Request</td>
<td>客户端请求有语法错误，不能被服务器所理解</td>
</tr>
<tr>
<td>401</td>
<td>Unauthorized</td>
<td>请求未经授权，这个状态代码必须和<code>WWW-Authenticate</code>报头域一起使用</td>
</tr>
<tr>
<td>403</td>
<td>Forbidden</td>
<td>服务器收到请求，但是拒绝提供服务</td>
</tr>
<tr>
<td>404</td>
<td>Not Found</td>
<td>请求资源不存在，eg：输入了错误的URL</td>
</tr>
<tr>
<td>500</td>
<td>Internal Server Error</td>
<td>服务器发生不可预期的错误</td>
</tr>
<tr>
<td>503</td>
<td>Server Unavailable</td>
<td>服务器当前不能处理客户端的请求，一段时间后可能恢复正常</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">状态码</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">100</td>
<td align="left">继续。客户端应继续其请求</td>
</tr>
<tr>
<td align="left">101</td>
<td align="left">切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td>
</tr>
<tr>
<td align="left">—</td>
<td align="left">—————————————–</td>
</tr>
<tr>
<td align="left">200</td>
<td align="left">请求成功。一般用于GET与POST请求</td>
</tr>
<tr>
<td align="left">201</td>
<td align="left">已创建。成功请求并创建了新的资源</td>
</tr>
<tr>
<td align="left">202</td>
<td align="left">已接受。已经接受请求，但未处理完成</td>
</tr>
<tr>
<td align="left">203</td>
<td align="left">非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td>
</tr>
<tr>
<td align="left">204</td>
<td align="left">无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td>
</tr>
<tr>
<td align="left">205</td>
<td align="left">重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td>
</tr>
<tr>
<td align="left">206</td>
<td align="left">部分内容。服务器成功处理了部分GET请求</td>
</tr>
<tr>
<td align="left">—</td>
<td align="left">—————————————–</td>
</tr>
<tr>
<td align="left">300</td>
<td align="left">多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td>
</tr>
<tr>
<td align="left">301</td>
<td align="left">永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td>
</tr>
<tr>
<td align="left">302</td>
<td align="left">临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td>
</tr>
<tr>
<td align="left">303</td>
<td align="left">查看其它地址。与301类似。使用GET和POST请求查看</td>
</tr>
<tr>
<td align="left">304</td>
<td align="left">未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td>
</tr>
<tr>
<td align="left">305</td>
<td align="left">使用代理。所请求的资源必须通过代理访问</td>
</tr>
<tr>
<td align="left">306</td>
<td align="left">已经被废弃的HTTP状态码</td>
</tr>
<tr>
<td align="left">307</td>
<td align="left">临时重定向。与302类似。使用GET请求重定向</td>
</tr>
<tr>
<td align="left">—</td>
<td align="left">—————————————–</td>
</tr>
<tr>
<td align="left">400</td>
<td align="left">客户端请求的语法错误，服务器无法理解</td>
</tr>
<tr>
<td align="left">401</td>
<td align="left">请求要求用户的身份认证</td>
</tr>
<tr>
<td align="left">402</td>
<td align="left">保留，将来使用</td>
</tr>
<tr>
<td align="left">403</td>
<td align="left">服务器理解请求客户端的请求，但是拒绝执行此请求</td>
</tr>
<tr>
<td align="left">404</td>
<td align="left">服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td>
</tr>
<tr>
<td align="left">405</td>
<td align="left">客户端请求中的方法被禁止</td>
</tr>
<tr>
<td align="left">406</td>
<td align="left">服务器无法根据客户端请求的内容特性完成请求</td>
</tr>
<tr>
<td align="left">407</td>
<td align="left">请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td>
</tr>
<tr>
<td align="left">408</td>
<td align="left">服务器等待客户端发送的请求时间过长，超时</td>
</tr>
<tr>
<td align="left">409</td>
<td align="left">服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</td>
</tr>
<tr>
<td align="left">410</td>
<td align="left">客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td>
</tr>
<tr>
<td align="left">411</td>
<td align="left">服务器无法处理客户端发送的不带Content-Length的请求信息</td>
</tr>
<tr>
<td align="left">412</td>
<td align="left">客户端请求信息的先决条件错误</td>
</tr>
<tr>
<td align="left">413</td>
<td align="left">由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td>
</tr>
<tr>
<td align="left">414</td>
<td align="left">请求的URI过长（URI通常为网址），服务器无法处理</td>
</tr>
<tr>
<td align="left">415</td>
<td align="left">服务器无法处理请求附带的媒体格式</td>
</tr>
<tr>
<td align="left">416</td>
<td align="left">客户端请求的范围无效</td>
</tr>
<tr>
<td align="left">417</td>
<td align="left">服务器无法满足Expect的请求头信息</td>
</tr>
<tr>
<td align="left">—</td>
<td align="left">—————————————–</td>
</tr>
<tr>
<td align="left">500</td>
<td align="left">服务器内部错误，无法完成请求</td>
</tr>
<tr>
<td align="left">501</td>
<td align="left">服务器不支持请求的功能，无法完成请求</td>
</tr>
<tr>
<td align="left">502</td>
<td align="left">作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td>
</tr>
<tr>
<td align="left">503</td>
<td align="left">由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td>
</tr>
<tr>
<td align="left">504</td>
<td align="left">充当网关或代理的服务器，未及时从远端服务器获取请求</td>
</tr>
<tr>
<td align="left">505</td>
<td align="left">服务器不支持请求的HTTP协议的版本，无法完成处理</td>
</tr>
</tbody></table>
<h4 id="http常见文件类型分类"><a href="#http常见文件类型分类" class="headerlink" title="http常见文件类型分类"></a>http常见文件类型分类</h4><p>http与浏览器交互时,为使浏览器能够识别文件信息,所以需要传递文件类型,这也是响应消息必填项 <code>Content-Type</code> ,常见的类型如下:</p>
<ul>
<li><code>普通文件</code>:  text&#x2F;plain; charset&#x3D;utf-8</li>
<li><code>*.html</code>:    text&#x2F;html; charset&#x3D;utf-8</li>
<li><code>*.jpg</code>:     image&#x2F;jpeg</li>
<li><code>*.gif</code>:     image&#x2F;gif</li>
<li><code>*.png</code>:     image&#x2F;png</li>
<li><code>*.wav</code>:     audio&#x2F;wav</li>
<li><code>*.avi</code>:     video&#x2F;x-msvideo</li>
<li><code>*.mov</code>:     video&#x2F;quicktime</li>
<li><code>*.mp3</code>:     audio&#x2F;mpeg</li>
</ul>
<p><strong>特别说明</strong> (编码集)</p>
<ul>
<li><code>charset=iso-8859-1</code>    西欧的编码，说明网站采用的编码是英文；</li>
<li><code>charset=gb2312</code>         说明网站采用的编码是简体中文；</li>
<li><code>charset=utf-8</code>              代表世界通用的语言编码；可以用到中文、韩文、日文等世界上所有语言编码上</li>
<li><code>charset=euc-kr</code>          说明网站采用的编码是韩文；</li>
<li><code>charset=big5</code>             说明网站采用的编码是繁体中文；</li>
</ul>
<h4 id="响应头中重要内容"><a href="#响应头中重要内容" class="headerlink" title="响应头中重要内容"></a>响应头中重要内容</h4><ul>
<li><strong><code>cookie</code></strong>:本地字符串数据信息(用户登录信息,反爬的token)</li>
<li>各种莫名其妙的字符串(一般都是token字样,防止各种攻击和反爬)</li>
<li><code>Location</code> :重定向的url,浏览器收到的响应中如果包含Location字段,则会重定向到Location指定的url地址(浏览器自动进行,用户不可见)</li>
</ul>
<h3 id="cookie详解"><a href="#cookie详解" class="headerlink" title="cookie详解"></a>cookie详解</h3><h4 id="设置Cookie"><a href="#设置Cookie" class="headerlink" title="设置Cookie"></a>设置Cookie</h4><p>Set-Cookie是HTTP响应头中的一个字段，用于在客户端（通常是浏览器）上设置一个cookie。</p>
<p>Cookie是一种在客户端存储数据的机制，用于跟踪和识别用户会话。</p>
<p>Set-Cookie字段的格式如下：</p>
<p>Set-Cookie: <code>key=value; Expires=expirationTime; Max-Age=maxAge; Domain=domainName; Path=path; Secure; HttpOnly</code> </p>
<ul>
<li><code>key=value</code>: 设置cookie的键值对，用于存储数据。 </li>
<li><code>Expires=expirationTime</code>: 指定cookie的过期时间，格式为日期时间字符串。一旦过期，浏览器将删除该cookie。</li>
<li><code>Max-Age=maxAge</code>: 指定cookie的最大存活时间，以秒为单位。在指定的时间过后，浏览器将删除该cookie。 </li>
<li><code>Domain=domainName</code>: 指定cookie的作用域，即可以访问该cookie的域名。</li>
<li><code>Path=path</code>: 指定cookie的路径，即可以访问该cookie的路径。 </li>
<li><code>Secure</code>: 表示该cookie只能通过HTTPS连接传输。 </li>
<li><code>HttpOnly</code>: 表示该cookie只能通过HTTP协议传输，JavaScript无法访问。</li>
</ul>
<p>通过Set-Cookie字段，服务器可以向客户端发送cookie，以便在后续的请求中识别和跟踪用户</p>
<h4 id="使用Cookie"><a href="#使用Cookie" class="headerlink" title="使用Cookie"></a>使用Cookie</h4><p>当向服务器发送HTTP请求时，可以在请求头中使用Cookie字段来发送cookie信息。下面是一个示例HTTP请求头，其中包含了使用cookie的部分：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /example HTTP/1.1</span><br><span class="line"><span class="section">Host: http://www.example.com </span></span><br><span class="line"><span class="section">User-Agent: Mozilla/5.0</span></span><br><span class="line"><span class="section">Accept: text/html</span></span><br><span class="line"><span class="section">Cookie: key1=value1; key2=value2</span></span><br></pre></td></tr></table></figure>

<p>在上面的示例中，Cookie字段包含了两个cookie键值对：key1&#x3D;value1和key2&#x3D;value2。这些cookie将会被发送到服务器，以便服务器可以识别和跟踪用户的会话。</p>
<p>以python为例:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用requests库发送第一次HTTP请求，并获取返回的cookie信息。然后在第二次HTTP请求中，通过设置cookies参数为第一次请求获取到的cookie信息，即可在下一次请求中带上cookie信息</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="comment"># 发起第一次HTTP请求获取cookie</span></span><br><span class="line">response = requests.get(<span class="string">&#x27;http://www.example.com&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取返回的cookie信息</span></span><br><span class="line">cookies = response.cookies.get_dict()</span><br><span class="line"><span class="comment"># 发起第二次HTTP请求时带上cookie信息</span></span><br><span class="line">response2 = requests.get(<span class="string">&#x27;http://www.example.com&#x27;</span>, cookies=cookies)</span><br><span class="line"><span class="comment"># 输出第二次请求的响应内容</span></span><br><span class="line"><span class="built_in">print</span>(response2.text)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>get_dict() </code>是requests库中Response对象的一个方法，用于获取响应中的cookie信息并以字典形式返回。具体来说， <code>get_dict()</code> 方法会将响应中的所有cookie信息转换为一个字典，其中键为cookie的名称，值为cookie的值。这样可以方便地获取和处理响应中的cookie信息，并在需要时将其用于下一次请求中。</p>
</blockquote>
<ol>
<li><p><code>cookies = response.cookies.get_dict()</code>: 这句代码将<code>response</code>对象中的所有Cookie信息转换为字典格式，并将其赋值给变量<code>cookies</code>。字典格式的Cookie信息以键值对的形式存储，其中键是Cookie的名称，值是Cookie的值。这种方式可以方便地对Cookie进行访问和操作。</p>
</li>
<li><p><code>cookies = response.cookies</code>: 这句代码直接将<code>response</code>对象中的所有Cookie信息赋值给变量<code>cookies</code>，但是此时<code>cookies</code>并不是字典格式，而是一个<code>RequestsCookieJar</code>对象，它是<code>requests</code>库中用于存储Cookie信息的数据结构。虽然<code>RequestsCookieJar</code>对象提供了一些方法来操作Cookie，但直接访问和操作Cookie可能相对繁琐。</p>
</li>
</ol>
<h2 id="https协议"><a href="#https协议" class="headerlink" title="https协议"></a>https协议</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1P5k3YHEGo/">参考HTTPS加密进化的动画解说</a></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202412212005977.png" alt="image-20241221200512263"></p>
<p>https &#x3D; http + SSL&#x2F;TLS</p>
<p>SSL是TlS的前身 </p>
<p>现在绝大部分浏览器都不支持SSL,而是支持TLS,但SSL名声很大,所以很多人把名字混用)</p>
<p><strong>SSL证书</strong>: 保存在服务器上的数据文件,表明域名属于谁,日期,还包含了特定的公钥和私钥,要让他生效需要向CA(Certificate Authority)申请.</p>
<p>CA 签发证书的过程：</p>
<ol>
<li>⾸先 CA 会把持有者的公钥、⽤途、颁发者、有效时间等信息打成⼀个包，然后对这些信息进行 Hash 计算，得到⼀个 Hash 值；</li>
<li>然后 CA 会使⽤自己的私钥将该 Hash 值加密，⽣成 Certificate Signature，也就是 CA 对证书做了签名；</li>
<li>最后将 Certificate Signature 添加在⽂件证书上，形成数字证书；</li>
</ol>
<p>客户端校验服务端的数字证书的过程：</p>
<ol>
<li><p>⾸先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1(数字摘要)；</p>
</li>
<li><p>通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使⽤ CA 的公钥解密 Certificate</p>
<p>Signature 内容，得到⼀个 Hash 值 H2(数字摘要)。</p>
</li>
<li><p>最后⽐较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。</p>
</li>
</ol>
<h3 id="TLS握手过程"><a href="#TLS握手过程" class="headerlink" title="TLS握手过程"></a>TLS握手过程</h3><p>具体tls握手过程随版本变化,这里以tls1.2为例</p>
<p>tls握手在<a href="#%E5%BB%BA%E7%AB%8B%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E8%BF%87%E7%A8%8B">tcp三次握手</a>之后</p>
<h2 id="web测试工具"><a href="#web测试工具" class="headerlink" title="web测试工具"></a>web测试工具</h2><h3 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h3><blockquote>
<p>一个非常实用的、用来与服务器之间传输数据的工具；支持的协议包括 (DICT, FILE, FTP, FTPS, GOPHER, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMTP, SMTPS, TELNET and TFTP)，curl设计为无用户交互下完成工作；curl提供了一大堆非常有用的功能，包括代理访问、用户认证、ftp上传下载、HTTP POST、SSL连接、cookie支持、断点续传…。</p>
</blockquote>
<p>格式: <code>curl [options] [URL...]</code></p>
<ul>
<li><code>curl url</code>  或 <code>curl URL?a=1&amp;b=nihao</code> 发送GET请求</li>
<li><code>curl -X POST -d &#39;a=1&amp;b=nihao&#39; URL</code> 发送post请求</li>
<li><code>curl -H &quot;Content-Type: application/json&quot; -X POST -d &#39;&#123;&quot;abc&quot;:123,&quot;bcd&quot;:&quot;nihao&quot;&#125;&#39; URL</code> 发送json格式请求</li>
</ul>
<p>其中，**-H<strong>代表header头，</strong>-X<strong>是指定什么类型请求(POST&#x2F;GET&#x2F;HEAD&#x2F;DELETE&#x2F;PUT&#x2F;PATCH)，</strong>-d**代表传输什么数据。这几个是最常用的。<code>-v</code> 显示连接的详细信息</p>
<p>查看所有curl命令： <code>man curl</code>或者<code>curl -h</code>  </p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/angle_chen123/article/details/120675472">更多信息参考</a></p>
<blockquote>
<p>可以使用<code>-k</code>或<code>--insecure</code>选项来忽略证书验证。如：<code>curl -k https://localhost</code></p>
</blockquote>
<h2 id="web服务器开发"><a href="#web服务器开发" class="headerlink" title="web服务器开发"></a>web服务器开发</h2><p><strong>实现目标</strong></p>
<p>简单功能: 首先解析浏览器发来的请求数据,得到请求的文件名</p>
<ul>
<li><p>若文件存在</p>
<p>判断文件类型:</p>
<p>若是普通文件,则发送文件内容给浏览器</p>
<p>若是目录文件,则发送文件列表构成的文件给浏览器</p>
</li>
<li><p>若文件不存在,则发送一个错误页给浏览器</p>
</li>
</ul>
<p>我们要开发web服务器已经明确要使用http协议传送html文件,那么我们如何搭建我们的服务器呢?注意http只是应用层协议,我们仍然需要选择一个传输层的协议来完成我们的传输数据工作,所以开发协议选择是TCP+HTTP,也就是说服务器搭建浏览依照TCP,对数据进行解析和响应工作遵循HTTP的原则.<br>这样我们的思路很清晰,编写一个TCP并发服务器,只不过收发消息的格式采用的是HTTP协议,如下图:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202209301437124.png" alt="image-20220930143719918"></p>
<p>为了支持并发服务器,我们可以有多个选择,比如多进程服务器,多线程服务器,select,poll,epoll等多路IO工具都可以,甚至如果读者觉得libevent非常熟练的话,也可以使用libevent进行开发.</p>
<h3 id="读取到内容后的流程"><a href="#读取到内容后的流程" class="headerlink" title="读取到内容后的流程"></a>读取到内容后的流程</h3><p>socket读取到内容后的流程如下</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202209301515589.png" alt="image-20220930151516803"></p>
<p><strong>[注意点]</strong></p>
<ul>
<li><p>浏览器中的每一次访问都是一个独立的访问,遇上一次的访问没有关系,即浏览器的任何链接跳转,都是关闭连接后建立新连接</p>
</li>
<li><p>在浏览器中访问的资源是一个中文的名称的话,需要进行<a href="#%E4%B8%AD%E6%96%87%E6%B1%89%E5%AD%97%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98">编码的转换</a></p>
</li>
<li><p>web服务端资源目录取决于web服务器程序的工作目录,可以通过 <code>chdir</code>函数切换工作目录</p>
</li>
<li><p>若浏览器关闭读端,会导致服务器进程退出,原因是当浏览器关闭读端后,而服务端还继续往一个关闭读端的链接写数据会收到到 <code>SIGPIPE</code>信号,这个信号的默认处理动作是使进程终止</p>
<p>解决方案: 忽略该信号<code>signal(SIGPIPE,SIG_IGN);</code></p>
</li>
</ul>
<h3 id="基于epoll的web服务器"><a href="#基于epoll的web服务器" class="headerlink" title="基于epoll的web服务器"></a>基于epoll的web服务器</h3><p>由于我们知道epoll在大量并发少量活跃的情况下效率很高,所以本文以epoll为例,介绍epoll开发的主体流程:</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202209301440008.png" alt="image-20220930143938195" style="zoom: 67%;" />

<p><a href="#%E5%A4%9A%E8%B7%AFIO-epoll">参考epoll模型跳转</a></p>
<h3 id="基于select的web服务器"><a href="#基于select的web服务器" class="headerlink" title="基于select的web服务器"></a>基于select的web服务器</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;wrap.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//16进制单字符转化为10进制单字符, return 0不会出现</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">hexit</span><span class="params">(<span class="type">char</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;f&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">&#x27;a&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;F&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">&#x27;A&#x27;</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="comment">//to和from可以指向同一个内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">strdecode</span><span class="params">(<span class="type">char</span>* to,<span class="type">char</span>* from)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>(;*from != <span class="string">&#x27;\0&#x27;</span>;++to,++from)&#123;</span><br><span class="line">		<span class="keyword">if</span>(from[<span class="number">0</span>]==<span class="string">&#x27;%&#x27;</span> &amp;&amp; <span class="built_in">isxdigit</span>(from[<span class="number">1</span>]) &amp;&amp; <span class="built_in">isxdigit</span>(from[<span class="number">2</span>]))<span class="comment">//isxdigit用于判断是否是16进制数字</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//一个%E8%8ba6的中文字符的字符串占6个字节,转换成16进制的中文字符后占3个字节</span></span><br><span class="line">            *to = hexit(from[<span class="number">1</span>])*<span class="number">16</span>+hexit(from[<span class="number">2</span>]);<span class="comment">//字符串%E8变成16进制的E8数值</span></span><br><span class="line">            from+=<span class="number">2</span>;<span class="comment">//结合上for中的++,总共是+3</span></span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            *to = *from;</span><br><span class="line">  &#125;</span><br><span class="line">  *to = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过文件名字获得文件类型</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">get_mime_type</span><span class="params">(<span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* dot;</span><br><span class="line"></span><br><span class="line">    dot = <span class="built_in">strrchr</span>(name, <span class="string">&#x27;.&#x27;</span>);	<span class="comment">//自右向左查找‘.’字符;如不存在返回NULL</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *charset=iso-8859-1	西欧的编码，说明网站采用的编码是英文；</span></span><br><span class="line"><span class="comment">     *charset=gb2312		说明网站采用的编码是简体中文；</span></span><br><span class="line"><span class="comment">     *charset=utf-8			代表世界通用的语言编码；</span></span><br><span class="line"><span class="comment">     *						可以用到中文、韩文、日文等世界上所有语言编码上</span></span><br><span class="line"><span class="comment">     *charset=euc-kr		说明网站采用的编码是韩文；</span></span><br><span class="line"><span class="comment">     *charset=big5			说明网站采用的编码是繁体中文；</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *以下是依据传递进来的文件名，使用后缀判断是何种文件类型</span></span><br><span class="line"><span class="comment">     *将对应的文件类型按照http定义的关键字发送回去</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (dot == (<span class="type">char</span>*)<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;text/plain; charset=utf-8&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.html&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(dot, <span class="string">&quot;.htm&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;text/html; charset=utf-8&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.jpg&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(dot, <span class="string">&quot;.jpeg&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;image/jpeg&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.gif&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;image/gif&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.png&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;image/png&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.css&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;text/css&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.au&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;audio/basic&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>( dot, <span class="string">&quot;.wav&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;audio/wav&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.avi&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;video/x-msvideo&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.mov&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(dot, <span class="string">&quot;.qt&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;video/quicktime&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.mpeg&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(dot, <span class="string">&quot;.mpe&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;video/mpeg&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.vrml&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(dot, <span class="string">&quot;.wrl&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;model/vrml&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.midi&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(dot, <span class="string">&quot;.mid&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;audio/midi&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.mp3&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;audio/mpeg&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.ogg&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;application/ogg&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.pac&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;application/x-ns-proxy-autoconfig&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;text/plain; charset=utf-8&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送响应头  code=200   msg=OK  fileType=Content-Type  len=Content-Length</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sendHeader</span><span class="params">(<span class="type">int</span> cfd,<span class="type">char</span>* code,<span class="type">char</span> *msg,<span class="type">char</span>* fileType,<span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(buf,<span class="string">&quot;HTTP/1.1 %s %s\r\n&quot;</span>,code,msg);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf+<span class="built_in">strlen</span>(buf),<span class="string">&quot;Content-Type:%s\r\n&quot;</span>,fileType);</span><br><span class="line">    <span class="keyword">if</span>(len&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(buf+<span class="built_in">strlen</span>(buf),<span class="string">&quot;Content-Length:%d\r\n&quot;</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcat</span>(buf,<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    <span class="comment">//printf(&quot;发送出去的内容为:====下面====\n&quot;);</span></span><br><span class="line">    <span class="comment">//printf(&quot;%s&quot;,buf);</span></span><br><span class="line">    Write(cfd,buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送响应正文</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sendFile</span><span class="params">(<span class="type">int</span> cfd,<span class="type">char</span>* fileName)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(fileName,O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//循环读文件,然后发送</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n = read(fd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span> (n&lt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//printf(&quot;%s\n&quot;,buf);</span></span><br><span class="line">            Write(cfd,buf,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">httpRequest</span><span class="params">(<span class="type">int</span> cfd,fd_set* setReal)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">//读取请求行数据,分析出要请求的资源文件名</span></span><br><span class="line">    <span class="type">int</span> n = Readline(cfd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)<span class="comment">//=0为客户端断开链接,&lt;0为异常</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;客户端已断开连接\n&quot;</span>);</span><br><span class="line">        close(cfd);</span><br><span class="line">        FD_CLR(cfd,setReal);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf(&quot;!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n&quot;);</span></span><br><span class="line">    <span class="comment">//printf(&quot;读到的第一行为%s\n&quot;,buf);</span></span><br><span class="line">    <span class="type">char</span> requestType[<span class="number">16</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">char</span> fileName[<span class="number">255</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">char</span> protocal[<span class="number">16</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sscanf</span>(buf,<span class="string">&quot;%[^ ] %[^ ] %[^ \r\n]&quot;</span>,requestType,fileName+<span class="number">1</span>,protocal);</span><br><span class="line">      <span class="comment">//处理文件名</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(fileName+<span class="number">1</span>)&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">strcpy</span>(fileName,<span class="string">&quot;./&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fileName[<span class="number">0</span>] = <span class="string">&#x27;.&#x27;</span>;<span class="comment">//添加点</span></span><br><span class="line">    strdecode(fileName,fileName);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;requestType==[%s]\n&quot;</span>,requestType);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fileName==[%s]\n&quot;</span>,fileName);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;protocal==[%s]\n&quot;</span>,protocal);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//循环读取完剩余的数据</span></span><br><span class="line">    <span class="keyword">while</span>((n=Readline(cfd,buf,<span class="keyword">sizeof</span>(buf))&gt;<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断文件是否存在</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="comment">//若文件不存在...</span></span><br><span class="line">    <span class="keyword">if</span>(stat(fileName,&amp;st)&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;文件不存在\n&quot;</span>);</span><br><span class="line">        <span class="comment">//发送错误信息</span></span><br><span class="line">        sendHeader(cfd,<span class="string">&quot;404&quot;</span>,<span class="string">&quot;NOT FOUND&quot;</span>,get_mime_type(<span class="string">&quot;.html&quot;</span>),<span class="number">0</span>);</span><br><span class="line">        sendFile(cfd,<span class="string">&quot;error.html&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;发送错误页成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//判断文件类型</span></span><br><span class="line">        <span class="comment">//普通文件</span></span><br><span class="line">        <span class="keyword">if</span> (S_ISREG(st.st_mode))</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;文件存在\n&quot;</span>);</span><br><span class="line">            <span class="comment">//发送头部信息</span></span><br><span class="line">            sendHeader(cfd, <span class="string">&quot;200&quot;</span>, <span class="string">&quot;OK&quot;</span>, get_mime_type(fileName), st.st_size);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//发送文件内容</span></span><br><span class="line">            sendFile(cfd, fileName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//目录文件</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (S_ISDIR(st.st_mode))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;这是目录文件\n&quot;</span>);</span><br><span class="line">            sendHeader(cfd, <span class="string">&quot;200&quot;</span>, <span class="string">&quot;OK&quot;</span>, get_mime_type(<span class="string">&quot;.html&quot;</span>), <span class="number">0</span>);</span><br><span class="line">            <span class="comment">//自己拼接html文件</span></span><br><span class="line">            sendFile(cfd, <span class="string">&quot;head.html&quot;</span>);</span><br><span class="line">            <span class="comment">//拼接文件列表信息</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> **<span class="title">namelist</span>;</span></span><br><span class="line">            <span class="type">int</span> num = scandir(fileName, &amp;namelist, <span class="literal">NULL</span>, alphasort);</span><br><span class="line">            <span class="keyword">if</span> (num &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                perror(<span class="string">&quot;scandir&quot;</span>);</span><br><span class="line">                close(cfd);</span><br><span class="line">                <span class="comment">//下监控</span></span><br><span class="line">                FD_CLR(cfd,setReal);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">char</span> buffer[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="keyword">while</span> (num--)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (namelist[num]-&gt;d_type==DT_DIR)<span class="comment">//如果是目录</span></span><br><span class="line">                        <span class="built_in">sprintf</span>(buffer+<span class="built_in">strlen</span>(buffer),<span class="string">&quot;&lt;li&gt;&lt;a href=%s/&gt; %s &lt;/a&gt;&lt;/li&gt;&quot;</span>,namelist[num]-&gt;d_name,namelist[num]-&gt;d_name);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="built_in">sprintf</span>(buffer+<span class="built_in">strlen</span>(buffer),<span class="string">&quot;&lt;li&gt;&lt;a href=%s&gt; %s &lt;/a&gt;&lt;/li&gt;&quot;</span>,namelist[num]-&gt;d_name,namelist[num]-&gt;d_name);</span><br><span class="line">                    <span class="comment">//printf(&quot;%s\n&quot;, namelist[num]-&gt;d_name);</span></span><br><span class="line">                    <span class="built_in">free</span>(namelist[num]); <span class="comment">//由于scandir内部是malloc申请的空间,因此记得要释放</span></span><br><span class="line">                &#125;</span><br><span class="line">                Write(cfd,buffer,<span class="built_in">strlen</span>(buffer));</span><br><span class="line">                <span class="built_in">free</span>(namelist);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            sendFile(cfd, <span class="string">&quot;tail.html&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//若文件存在</span></span><br><span class="line">        <span class="comment">//判断文件类型</span></span><br><span class="line">            <span class="comment">//普通文件</span></span><br><span class="line">            <span class="comment">//目录文件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//忽略SIGPIPE信号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_handler = SIG_IGN;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sigaction(SIGPIPE,&amp;act,<span class="literal">NULL</span>);</span><br><span class="line">    fd_set setReal;</span><br><span class="line">    <span class="comment">//改变当前进程的工作目录</span></span><br><span class="line">    <span class="comment">//char path[255]=&#123;0&#125;;</span></span><br><span class="line">    <span class="comment">//sprintf(&quot;&quot;,getenv(&quot;HOME&quot;),&quot;&quot;)</span></span><br><span class="line">    <span class="comment">//chdir()</span></span><br><span class="line">    <span class="type">int</span> lfd = Socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv</span>;</span></span><br><span class="line">    serv.sin_family = AF_INET;</span><br><span class="line">    serv.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv.sin_port = htons(<span class="number">23456</span>);</span><br><span class="line">    <span class="comment">//设置端口复用</span></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    Bind(lfd,(<span class="keyword">struct</span> sockaddr*)&amp;serv,<span class="keyword">sizeof</span>(serv));</span><br><span class="line">    Listen(lfd,<span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> maxfd = lfd;<span class="comment">//设置给委托内核监控的描述符的范围</span></span><br><span class="line">    FD_ZERO(&amp;setReal);</span><br><span class="line">    FD_SET(lfd,&amp;setReal);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;服务器开启,等待连接\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fd_set setR = setReal;</span><br><span class="line">        <span class="type">int</span> fdChangeNum = select(maxfd+<span class="number">1</span>,&amp;setR,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);<span class="comment">//阻塞监控变化,不需要考虑返回0的情况,因为返回&gt;0和&lt;0才会解除堵塞</span></span><br><span class="line">        <span class="keyword">if</span>(fdChangeNum&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno==EINTR)<span class="comment">//信号被中断</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//出问题返回(并未做什么完善的处理)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//有客户端连接请求到来</span></span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(lfd,&amp;setR))<span class="comment">//如果lfd有响应</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//printf(&quot;客户端连接存在,返回:%d\n&quot;,fdChangeNum);</span></span><br><span class="line">            <span class="type">int</span> cfd = accept(lfd,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;接受到新的连接,文件描述符为%d\n&quot;</span>,cfd);</span><br><span class="line">            <span class="comment">//设置cfd为非阻塞</span></span><br><span class="line">            <span class="type">int</span> flag = fcntl(cfd,F_GETFL);</span><br><span class="line">            flag |= O_NONBLOCK;</span><br><span class="line">            fcntl(cfd,F_SETFL,flag);</span><br><span class="line">            <span class="comment">//将cfd加入到委托内核监控中</span></span><br><span class="line">            FD_SET(cfd,&amp;setReal);</span><br><span class="line">            <span class="comment">//调整监控文件描述符范围,将新加入的accept接受到的描述符添加入委托内核监控的范围</span></span><br><span class="line">            <span class="keyword">if</span>(maxfd&lt;cfd)</span><br><span class="line">            &#123;</span><br><span class="line">                maxfd = cfd ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果只有一个描述符变化了,而且是在有客户端连接请求到来的上下文执行中</span></span><br><span class="line">            <span class="comment">//则此处说明只有这一个连接请求导致的描述符变化,因此这样情况下后面代码可以略过</span></span><br><span class="line">            <span class="keyword">if</span>(--fdChangeNum==<span class="number">0</span>)<span class="comment">//如果只剩最后一个就无需在执行后面了</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span> str[<span class="number">99</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">//有客户端发数据过来</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = lfd+<span class="number">1</span>; i &lt;= maxfd; i++)<span class="comment">//i表示accept接受的fd</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(i,&amp;setR))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;数据通信存在,返回值为:%d\n&quot;</span>,fdChangeNum);</span><br><span class="line">                httpRequest(i,&amp;setReal);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;请求完毕\n\n\n&quot;</span>);</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="中文汉字编码问题"><a href="#中文汉字编码问题" class="headerlink" title="中文汉字编码问题"></a>中文汉字编码问题</h3><p>举例:浏览器请求的是<code>localhost:8080/苦瓜.txt</code> ,web服务器收到之后会显示: <code>%E8%8B%A6%E7%93%9C.txt</code>,需要进行转换,utf-8格式的一个中文汉字占3个字节,首先需要去掉文件名中的%,然后逐个将字符串形式的(例如E8)转换成数值,然后保存到数组当中.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//16进制单字符转化为10进制单字符, return 0不会出现</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">hexit</span><span class="params">(<span class="type">char</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;f&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">&#x27;a&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;F&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">&#x27;A&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="comment">//to和from可以指向同一个内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">strdecode</span><span class="params">(<span class="type">char</span>* to,<span class="type">char</span>* from)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>(;*from != <span class="string">&#x27;\0&#x27;</span>;++to,++from)&#123;</span><br><span class="line">		<span class="keyword">if</span>(from[<span class="number">0</span>]==<span class="string">&#x27;%&#x27;</span> &amp;&amp; <span class="built_in">isxdigit</span>(from[<span class="number">1</span>]) &amp;&amp; <span class="built_in">isxdigit</span>(from[<span class="number">2</span>]))<span class="comment">//isxdigit用于判断是否是16进制数字</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//一个%E8%8b%a6的中文字符的字符串占9个字节,转换成16进制的中文字符后占3个字节</span></span><br><span class="line">            *to = hexit(from[<span class="number">1</span>])*<span class="number">16</span>+hexit(from[<span class="number">2</span>]);<span class="comment">//字符串%E8(3字节)变成16进制的E8数值(1字节)</span></span><br><span class="line">            from+=<span class="number">2</span>;<span class="comment">//结合上for中的++,总共是+3</span></span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            *to = *from;</span><br><span class="line">  &#125;</span><br><span class="line">  *to = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 <code>strdecode</code> 把代表unicode的字符串变成真正的unicode编码(其实就是16进制存储)</p>
<h3 id="一些特殊符号"><a href="#一些特殊符号" class="headerlink" title="一些特殊符号"></a>一些特殊符号</h3><p>相关知识</p>
<p>html中的 <code>空格</code> (space)是<code>&amp;nbsp</code></p>
<ul>
<li><code>%20</code> URL编码中的 <code>空格</code>(space)</li>
<li><code>%21</code> — <code>!</code>   </li>
<li><code>%22</code> — <code>&quot;</code></li>
<li><code>%23</code> — <code>#</code></li>
<li><code>%24</code> — <code>$</code></li>
<li><code>%25</code> — <code>%</code> </li>
<li><code>%26</code> — <code>&amp;</code> </li>
<li><code>%27</code> — <code>&#39;</code></li>
<li><code>%28</code> — <code>(</code></li>
</ul>
<h3 id="基于libevent的web服务器"><a href="#基于libevent的web服务器" class="headerlink" title="基于libevent的web服务器"></a>基于libevent的web服务器</h3><p>参考<a href="#libevent%E5%BA%93">libevent库讲解</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写libevent服务端</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/bufferevent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/buffer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/listener.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/util.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/event.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//16进制单字符转化为10进制单字符, return 0不会出现</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">hexit</span><span class="params">(<span class="type">char</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;f&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">&#x27;a&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;F&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">&#x27;A&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="comment">//to和from可以指向同一个内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">strdecode</span><span class="params">(<span class="type">char</span>* to,<span class="type">char</span>* from)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>(;*from != <span class="string">&#x27;\0&#x27;</span>;++to,++from)&#123;</span><br><span class="line">		<span class="keyword">if</span>(from[<span class="number">0</span>]==<span class="string">&#x27;%&#x27;</span> &amp;&amp; <span class="built_in">isxdigit</span>(from[<span class="number">1</span>]) &amp;&amp; <span class="built_in">isxdigit</span>(from[<span class="number">2</span>]))<span class="comment">//isxdigit用于判断是否是16进制数字</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//一个%E8%8ba6的中文字符的字符串占6个字节,转换成16进制的中文字符后占3个字节</span></span><br><span class="line">            *to = hexit(from[<span class="number">1</span>])*<span class="number">16</span>+hexit(from[<span class="number">2</span>]);<span class="comment">//字符串%E8变成16进制的E8数值</span></span><br><span class="line">            from+=<span class="number">2</span>;<span class="comment">//结合上for中的++,总共是+3</span></span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            *to = *from;</span><br><span class="line">  &#125;</span><br><span class="line">  *to = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过文件名字获得文件类型</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">get_mime_type</span><span class="params">(<span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* dot;</span><br><span class="line">    dot = <span class="built_in">strrchr</span>(name, <span class="string">&#x27;.&#x27;</span>);	<span class="comment">//自右向左查找‘.’字符;如不存在返回NULL</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *charset=iso-8859-1	西欧的编码，说明网站采用的编码是英文；</span></span><br><span class="line"><span class="comment">     *charset=gb2312		说明网站采用的编码是简体中文；</span></span><br><span class="line"><span class="comment">     *charset=utf-8			代表世界通用的语言编码；</span></span><br><span class="line"><span class="comment">     *						可以用到中文、韩文、日文等世界上所有语言编码上</span></span><br><span class="line"><span class="comment">     *charset=euc-kr		说明网站采用的编码是韩文；</span></span><br><span class="line"><span class="comment">     *charset=big5			说明网站采用的编码是繁体中文；</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *以下是依据传递进来的文件名，使用后缀判断是何种文件类型</span></span><br><span class="line"><span class="comment">     *将对应的文件类型按照http定义的关键字发送回去</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (dot == (<span class="type">char</span>*)<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;text/plain; charset=utf-8&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.html&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(dot, <span class="string">&quot;.htm&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;text/html; charset=utf-8&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.jpg&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(dot, <span class="string">&quot;.jpeg&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;image/jpeg&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.gif&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;image/gif&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.png&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;image/png&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.css&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;text/css&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.au&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;audio/basic&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>( dot, <span class="string">&quot;.wav&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;audio/wav&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.avi&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;video/x-msvideo&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.mov&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(dot, <span class="string">&quot;.qt&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;video/quicktime&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.mpeg&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(dot, <span class="string">&quot;.mpe&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;video/mpeg&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.vrml&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(dot, <span class="string">&quot;.wrl&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;model/vrml&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.midi&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(dot, <span class="string">&quot;.mid&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;audio/midi&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.mp3&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;audio/mpeg&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.ogg&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;application/ogg&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.pac&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;application/x-ns-proxy-autoconfig&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;text/plain; charset=utf-8&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送响应头  code=200   msg=OK  fileType=Content-Type  len=Content-Length</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sendHeader</span><span class="params">(<span class="keyword">struct</span> bufferevent * bev,<span class="type">char</span>* code,<span class="type">char</span> *msg,<span class="type">char</span>* fileType,<span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(buf,<span class="string">&quot;HTTP/1.1 %s %s\r\n&quot;</span>,code,msg);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf+<span class="built_in">strlen</span>(buf),<span class="string">&quot;Content-Type:%s\r\n&quot;</span>,fileType);</span><br><span class="line">    <span class="keyword">if</span>(len&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(buf+<span class="built_in">strlen</span>(buf),<span class="string">&quot;Content-Length:%d\r\n&quot;</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcat</span>(buf,<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    <span class="comment">//printf(&quot;发送出去的内容为:====下面====\n&quot;);</span></span><br><span class="line">    <span class="comment">//printf(&quot;%s&quot;,buf);</span></span><br><span class="line">    bufferevent_write(bev,buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送响应正文</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sendFile</span><span class="params">(<span class="keyword">struct</span> bufferevent * bev,<span class="type">char</span>* fileName)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(fileName,O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//循环读文件,然后发送</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n = read(fd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span> (n&lt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//printf(&quot;%s\n&quot;,buf);</span></span><br><span class="line">            bufferevent_write(bev,buf,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">httpRequest</span><span class="params">(<span class="keyword">struct</span> bufferevent * bev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">//读取请求行数据,分析出要请求的资源文件名</span></span><br><span class="line">    <span class="type">int</span> n =bufferevent_read(bev,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="comment">//printf(&quot;!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n&quot;);</span></span><br><span class="line">    <span class="comment">//printf(&quot;读到的第一行为%s\n&quot;,buf);</span></span><br><span class="line">    <span class="type">char</span> requestType[<span class="number">16</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">char</span> fileName[<span class="number">255</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">char</span> protocal[<span class="number">16</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sscanf</span>(buf,<span class="string">&quot;%[^ ] %[^ ] %[^ \r\n]&quot;</span>,requestType,fileName+<span class="number">1</span>,protocal);</span><br><span class="line">      <span class="comment">//处理文件名</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(fileName+<span class="number">1</span>)&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">strcpy</span>(fileName,<span class="string">&quot;./&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fileName[<span class="number">0</span>] = <span class="string">&#x27;.&#x27;</span>;<span class="comment">//添加点</span></span><br><span class="line">    strdecode(fileName,fileName);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;requestType==[%s]\n&quot;</span>,requestType);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fileName==[%s]\n&quot;</span>,fileName);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;protocal==[%s]\n&quot;</span>,protocal);</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环读取完剩余的数据</span></span><br><span class="line">    <span class="keyword">while</span>((n =bufferevent_read(bev,buf,<span class="keyword">sizeof</span>(buf))));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断文件是否存在</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="comment">//若文件不存在...</span></span><br><span class="line">    <span class="keyword">if</span>(stat(fileName,&amp;st)&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;文件不存在\n&quot;</span>);</span><br><span class="line">        <span class="comment">//发送错误信息</span></span><br><span class="line">        sendHeader(bev,<span class="string">&quot;404&quot;</span>,<span class="string">&quot;NOT FOUND&quot;</span>,get_mime_type(<span class="string">&quot;.html&quot;</span>),<span class="number">0</span>);</span><br><span class="line">        sendFile(bev,<span class="string">&quot;error.html&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;发送错误页成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//判断文件类型</span></span><br><span class="line">        <span class="comment">//普通文件</span></span><br><span class="line">        <span class="keyword">if</span> (S_ISREG(st.st_mode))</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;文件存在\n&quot;</span>);</span><br><span class="line">            <span class="comment">//发送头部信息</span></span><br><span class="line">            sendHeader(bev, <span class="string">&quot;200&quot;</span>, <span class="string">&quot;OK&quot;</span>, get_mime_type(fileName), st.st_size);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//发送文件内容</span></span><br><span class="line">            sendFile(bev, fileName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//目录文件</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (S_ISDIR(st.st_mode))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;这是目录文件\n&quot;</span>);</span><br><span class="line">            sendHeader(bev, <span class="string">&quot;200&quot;</span>, <span class="string">&quot;OK&quot;</span>, get_mime_type(<span class="string">&quot;.html&quot;</span>), <span class="number">0</span>);</span><br><span class="line">            <span class="comment">//自己拼接html文件</span></span><br><span class="line">            sendFile(bev, <span class="string">&quot;head.html&quot;</span>);</span><br><span class="line">            <span class="comment">//拼接文件列表信息</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> **<span class="title">namelist</span>;</span></span><br><span class="line">            <span class="type">int</span> num = scandir(fileName, &amp;namelist, <span class="literal">NULL</span>, alphasort);</span><br><span class="line">            <span class="keyword">if</span> (num &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                perror(<span class="string">&quot;scandir&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">char</span> buffer[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="keyword">while</span> (num--)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (namelist[num]-&gt;d_type==DT_DIR)<span class="comment">//如果是目录</span></span><br><span class="line">                        <span class="built_in">sprintf</span>(buffer+<span class="built_in">strlen</span>(buffer),<span class="string">&quot;&lt;li&gt;&lt;a href=%s/&gt; %s &lt;/a&gt;&lt;/li&gt;&quot;</span>,namelist[num]-&gt;d_name,namelist[num]-&gt;d_name);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="built_in">sprintf</span>(buffer+<span class="built_in">strlen</span>(buffer),<span class="string">&quot;&lt;li&gt;&lt;a href=%s&gt; %s &lt;/a&gt;&lt;/li&gt;&quot;</span>,namelist[num]-&gt;d_name,namelist[num]-&gt;d_name);</span><br><span class="line">                    <span class="comment">//printf(&quot;%s\n&quot;, namelist[num]-&gt;d_name);</span></span><br><span class="line">                    <span class="built_in">free</span>(namelist[num]); <span class="comment">//由于scandir内部是malloc申请的空间,因此记得要释放</span></span><br><span class="line">                &#125;</span><br><span class="line">                bufferevent_write(bev,buffer,<span class="built_in">strlen</span>(buffer));</span><br><span class="line">                <span class="built_in">free</span>(namelist);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            sendFile(bev, <span class="string">&quot;tail.html&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//若文件存在</span></span><br><span class="line">        <span class="comment">//判断文件类型</span></span><br><span class="line">            <span class="comment">//普通文件</span></span><br><span class="line">            <span class="comment">//目录文件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//解析sockaddr_in结构提取[ip:端口]字符串</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">acceptClient2Str</span><span class="params">(<span class="keyword">struct</span> sockaddr_in* client,<span class="type">char</span>* str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> sip[<span class="number">16</span>];</span><br><span class="line">    <span class="built_in">memset</span>(sip,<span class="number">0</span>,<span class="keyword">sizeof</span>(sip));</span><br><span class="line">    <span class="built_in">sprintf</span>(str,<span class="string">&quot;%s:%hu&quot;</span>,inet_ntop(AF_INET,&amp;client-&gt;sin_addr.s_addr,sip,<span class="keyword">sizeof</span>(sip)),ntohs(client-&gt;sin_port));</span><br><span class="line">    <span class="comment">//std::cout&lt;&lt;str&lt;&lt;std::endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//typedef void (*event_callback_fn)(evutil_socket_t fd, short events, void *arg);</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_cb</span><span class="params">(<span class="keyword">struct</span> bufferevent *bev, <span class="type">void</span> *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">	httpRequest(bev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">event_cb</span><span class="params">(<span class="keyword">struct</span> bufferevent *bev, <span class="type">short</span> what, <span class="type">void</span>*ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(what &amp; BEV_EVENT_EOF)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;有客户端断开连接\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过ptr指针将struct event_base指针传入进来</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">listener_cb</span><span class="params">(<span class="keyword">struct</span> evconnlistener *evl, <span class="type">evutil_socket_t</span> fd, </span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> sockaddr *cliaddr, <span class="type">int</span> socklen, <span class="type">void</span> *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> str[<span class="number">16</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	acceptClient2Str(cliaddr,str);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;客户端[%s]连接成功，占用%d描述符\n&quot;</span>,str,fd);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> =</span> ptr;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bufferevent</span> *<span class="title">bev</span> =</span> bufferevent_socket_new(base,fd,BEV_OPT_CLOSE_ON_FREE);</span><br><span class="line">	<span class="keyword">if</span>(!bev)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Error constructing bufferevent!\n&quot;</span>);</span><br><span class="line">		event_base_loopbreak(base);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	bufferevent_setcb(bev,read_cb,<span class="literal">NULL</span>,event_cb,<span class="literal">NULL</span>);<span class="comment">//此处的参数位无法将cliaddr传过去read_cb解析ip地址（应该已经被释放了）</span></span><br><span class="line">	bufferevent_enable(bev,EV_READ);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv</span>;</span></span><br><span class="line">	bzero(&amp;serv, <span class="keyword">sizeof</span>(serv));</span><br><span class="line">	serv.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">	serv.sin_port = htons(<span class="number">23456</span>);</span><br><span class="line">	serv.sin_family = AF_INET;</span><br><span class="line">	<span class="comment">//创建地基</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> =</span> event_base_new();</span><br><span class="line">	<span class="keyword">if</span>(base==<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;event_base_new error\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//创建事件连接监听器，如果有客户端连接会调用listener_cb回调函数</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">evconnlistener</span>* <span class="title">listener</span> =</span> evconnlistener_new_bind(base,listener_cb,base,</span><br><span class="line">	LEV_OPT_CLOSE_ON_FREE|LEV_OPT_REUSEABLE,<span class="number">-1</span>,&amp;serv,<span class="keyword">sizeof</span>(serv));</span><br><span class="line">	<span class="comment">//进入事件循环</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;等待连接中...\n&quot;</span>);</span><br><span class="line">	event_base_dispatch(base);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;跳出循环\n&quot;</span>);</span><br><span class="line">	evconnlistener_free(listener);</span><br><span class="line">	event_base_free(base);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与select,epoll的大同小异,对比select其实只是将<code>read/write</code>函数相对应换成<code>bufferevent_read/bufferevent_write</code>,并将<code>httprequest</code>的参数的文件描述符换成<code>struct bufferevent *</code></p>
<h2 id="web服务器框架"><a href="#web服务器框架" class="headerlink" title="web服务器框架"></a>web服务器框架</h2><ul>
<li>tomcat服务器<ul>
<li>apache组织产品,开源的免费服务器</li>
</ul>
</li>
<li>weblogic服务器<ul>
<li>bea公司,收费的服务器</li>
<li>不交费的话访问量受到限制</li>
</ul>
</li>
<li>IIS服务器<ul>
<li>Internet Information Server</li>
<li>微软公司主推的服务器</li>
</ul>
</li>
<li>nginx<ul>
<li>小巧且高效的HTTP服务器</li>
<li>也可以做一个高效的负载均衡<strong>反向</strong>代理</li>
<li>邮件服务器</li>
</ul>
</li>
</ul>
<p>其他的还有:(下面的都可以实现路由到函数的功能)</p>
<ul>
<li><strong>cppcms</strong>：一个轻量级、高性能的 C++ Web 框架，具有类似 Flask 的路由和模板引擎功能。</li>
<li><strong>Pistache</strong>：一个高性能、非阻塞的 C++ Web 框架，具有类似 Flask 的路由和中间件功能。</li>
<li><strong>oatpp</strong>：一个现代、高性能的 C++ Web 框架，具有类似 Flask 的路由和依赖注入功能。</li>
<li><strong>Casablanca</strong>：一个跨平台、高性能的 C++ Web 框架，具有类似 Flask 的路由和异步 I&#x2F;O 功能。</li>
</ul>
<p>Flask是python用的web框架</p>
<h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><p>[[nginx#基本介绍|nginx详解跳转]]</p>
<h2 id="REST-API"><a href="#REST-API" class="headerlink" title="REST API"></a>REST API</h2><p>Boost.Asio 是一个用于建立异步 I&#x2F;O 应用程序的 C++ 库，它提供了网络编程、串口编程、进程间通信等功能。在这个示例中，我们使用了 Boost.Asio 库提供的异步 I&#x2F;O 操作来处理请求和响应，从而构建一个简单的 REST API。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boost/asio.hpp </span><br></pre></td></tr></table></figure>

<p>包含了许多常用的 Boost.Asio 头文件。 -</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boost/asio/ssl.hpp </span><br></pre></td></tr></table></figure>

<p>包含了使用 Boost.Asio 进行 SSL 通信的头文件。 </p>
<h2 id="CGI"><a href="#CGI" class="headerlink" title="CGI"></a>CGI</h2><blockquote>
<p><strong>通用网关接口(Common Gateway Interface)描述了客户端和服务器程序之间传输数据的一种标准</strong>,可以让一个客户端,从网页浏览器向执行在网络服务器上的程序请求数据.CGI独立于任何语言,CGI程序可以用任何脚本语言或者是完全独立编程语言实现,只要这个语言可以在这个系统上运行</p>
</blockquote>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202306131027741.png" alt="image-20230613102754891" style="zoom: 67%;" />

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202306131030925.png" alt="image-20230613103012085" style="zoom:67%;" />

<ol>
<li>用户通过浏览器访问服务器,发送了一个请求</li>
<li>服务器接受数据并解析</li>
<li>nginx对于一些登录数据不知道如何处理,nginx将这些数据转发给了cgi程序<ul>
<li>服务器端会创建一个cgi进程(每一个客户端请求,都会创建一个cgi进程)</li>
</ul>
</li>
<li>CGI进程执行后返回结果,返还nginx,自身销毁,nginx回复客户端.</li>
</ol>
<p>因此CGI会频繁创建与销毁,效率低,由此fastCGI诞生.</p>
<h4 id="fastCGI"><a href="#fastCGI" class="headerlink" title="fastCGI"></a>fastCGI</h4><blockquote>
<p><strong>快速通用网关接口(Fast Common Gateway Interface)<strong>是通用网关接口(CGI)的改进,描述了客户端和服务器程序之间传输数据的一种标准.FastCGI致力于减少Web服务器与CGI程序之间互动的开销,从而使服务器可以同时处理更多的Web请求.与为每个请求创建一个新的进程不同,FastCGI使用</strong>持续的进程</strong>来处理一连串的请求.这些进程由FastCGI进程管理器管理,而不是web服务器</p>
</blockquote>
<p>与CGI的区别:</p>
<ul>
<li>CGI是<strong>短生存期</strong>应用程序</li>
<li>FastCGI是<strong>长生存期</strong>应用程序,像一个常驻(long-live)型的CGI,可以一直执行,不需要每次都创建与销毁</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202306131056925.png" alt="image-20230613105633722" style="zoom:67%;" />

<ol>
<li>用户通过浏览器访问服务器,发送了一个请求</li>
<li>服务器接受数据并解析</li>
<li>nginx对于一些登录数据不知道如何处理,nginx将这些数据通过套接字转发给了fastCGI进程管理器</li>
<li>fastCGI程序启动(不是由web服务器直接启动,而是通过fastCGI进程管理器启动)</li>
<li>fastCGI程序执行完毕后,通过套接字将处理结果返回给web服务器,服务器回复客户端</li>
</ol>
<h5 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h5><p>需要安装两个</p>
<ul>
<li><p>fastCGI框架</p>
<p><code>根目录/libfcgi/.libs/libfcgi++.so</code><br><code>根目录/libfcgi/.libs/libfcgi.so</code></p>
</li>
<li><p>spawn-fcgi   (fastCGI进程管理器)</p>
</li>
</ul>
<blockquote>
<p>nginx不能像apache那样直接执行外部可执行程序,但nginx可以作为代理服务器,将请求转发给后端服务器,这也是nginx的主要作用之一.其中nginx就支持fastCGI代理,接受客户端的请求,然后将请求转发给后端fastcgi进程.下面介绍如何使用C&#x2F;C++编写cgi&#x2F;fastcgi,并部署到nginx中.</p>
<p>**<code>fastCGI</code>**进程由fastCGI进程管理器管理,而不是nginx.这样就需要一个FastCGI管理器,管理我们编写的fastcgi程序.我们使用spawn-fcgi作为FastCGI进程管理器</p>
<p>**<code>spawn-fcgi</code>**是一个通用的FastCGI进程管理器,简单小巧,原先是属于lighttpd的一部分,后来由于使用比较广泛,所以就迁移出来作为独立新项目了.spawn-fcgi使用pre-fork模型,功能主要是打开监听端口,绑定地址,然后fork-and-exec创建我们编写的fastcgi应用程序进程,退出完成工作.fastcgi应用程序初始化,然后进入死循环侦听socket的连接请求</p>
</blockquote>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202306141212992.png" alt="image-20230614121207887" style="zoom: 50%;" />

<ol>
<li>客户端访问,发送请求</li>
<li>nginx web服务器,无法处理用户提交的数据,转发数据</li>
<li>spawn-fcgi  通信过程中的服务器角色<ul>
<li>被动接受数据</li>
<li>在spawn-fcgi启动的时候给其绑定ip和端口</li>
</ul>
</li>
<li>fastCGI程序 <ul>
<li>程序员写的login.c  -&gt;  可执行程序login</li>
<li>使用spawn-fcgi进程管理器启动login程序得到一个进程</li>
</ul>
</li>
</ol>
<p><strong>nginx的数据转发配置</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> /login</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">#转发这个数据,fastCGI进程</span></span><br><span class="line">  <span class="attribute">fastcgi_pass</span> 地址信息:端口;<span class="comment">#数据转发到spawn-fcgi,地址信息可以为ip或域名</span></span><br><span class="line">  <span class="attribute">include</span> fastcgi.conf;<span class="comment">#导入[与nginx.conf同级目录下的fastcgi.conf文件],其中定义了一些http通信的时候用到的环境变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>spawn-fcgi启动</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">前提条件,程序员已经写好fastCGI可执行程序</span></span><br><span class="line">spawn-fcgi -a IP地址 -p 端口 -f fastcgi可执行程序</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">上面的IP地址和端口需要与前面nginx转发配置中的地址信息和端口对应</span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">nginx:localhost  -&gt;此处IP地址:127.0.0.1</span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">nginx:127.0.0.1  -&gt;此处IP地址:127.0.0.1</span></span><br></pre></td></tr></table></figure>

<p>如果返回<code>spawn-fcgi: child spawned successfully: PID: 464863</code>表示成功;如果显示退出,bing返回错误码127,即fastCGI程序有问题.</p>
<h6 id="fastCGI环境变量"><a href="#fastCGI环境变量" class="headerlink" title="fastCGI环境变量"></a>fastCGI环境变量</h6><table>
<thead>
<tr>
<th>环境变量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>SCRIPT_FILENAME</td>
<td>脚本文件请求的路径</td>
</tr>
<tr>
<td>QUERY_STRING</td>
<td>请求的参数;如?app&#x3D;123</td>
</tr>
<tr>
<td>REQUEST_METHOD</td>
<td>请求的动作(GET&#x2F;POST)</td>
</tr>
<tr>
<td>CONTENT_TYPE</td>
<td>请求头中的Content-Type字段</td>
</tr>
<tr>
<td>CONTENT_LENGTH</td>
<td>请求头中的Content-length字段</td>
</tr>
<tr>
<td>SCRIPT_NAME</td>
<td>脚本名称</td>
</tr>
<tr>
<td>REQUEST_URI</td>
<td>请求的地址不带参数</td>
</tr>
<tr>
<td>DOCUMENT_URI</td>
<td>与$uri相同</td>
</tr>
<tr>
<td>DOCUMENT_ROOT</td>
<td>网站的根目录.在server配置中root指令中指定的值</td>
</tr>
<tr>
<td>SERVER_PROTOCOL</td>
<td>请求使用的协议,通常是HTTP&#x2F;1.0或HTTP&#x2F;1.1</td>
</tr>
<tr>
<td>GATEWAY_INTERFACE</td>
<td>cgi版本号</td>
</tr>
<tr>
<td>SERVER_SOFTWARE</td>
<td>nginx版本号,可修改,隐藏</td>
</tr>
<tr>
<td>REMOTE_ADDR</td>
<td>客户端IP</td>
</tr>
<tr>
<td>REMOTE_PORT</td>
<td>客户端端口</td>
</tr>
<tr>
<td>SERVER_ADDR</td>
<td>服务器IP地址</td>
</tr>
<tr>
<td>SERVER_PORT</td>
<td>服务器端口</td>
</tr>
<tr>
<td>SERVER_NAME</td>
<td>服务器名,域名在server配置中指定的server_name</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<h5 id="fastCGI程序开发"><a href="#fastCGI程序开发" class="headerlink" title="fastCGI程序开发"></a>fastCGI程序开发</h5><p>参考<code>fastCGI安装的根目录/sample/echo.c</code></p>
<p>要包含的头文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fcgi_config.h&quot;</span>   <span class="comment">//可选</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fcgi_stdio.h&quot;</span>		 <span class="comment">//必须</span></span></span><br></pre></td></tr></table></figure>

<p>开发fastCGI需要使用到的库文件(二选一)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">库文件</span></span><br><span class="line">./libfcgi/.libs/libfcgi++.so</span><br><span class="line">./libfcgi/.libs/libfcgi.so</span><br></pre></td></tr></table></figure>

<p><strong>fastCGI如何处理数据</strong></p>
<p>在FastCGI程序开发中，<strong>标准输入和标准输出被重定向到了socket连接</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(FCGI_Accept()&gt;=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//接收到数据后如何处理</span></span><br><span class="line">  <span class="comment">//根据REQUEST_METHOD</span></span><br><span class="line">  	<span class="comment">//get读请求行的第二部分,QUERY_STRING</span></span><br><span class="line">  	<span class="comment">//post读CONTENT-LENGTH</span></span><br><span class="line">  		<span class="comment">//根据CONTENT-TYPE知道长度</span></span><br><span class="line">  		<span class="comment">//从标准输入进来的就是请求体(请求数据)的内容</span></span><br><span class="line">  	<span class="comment">//打印到标准输出的就是要返回给请求方的内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>简单案例</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fcgi_config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fcgi_stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">PrintEnv</span><span class="params">(<span class="type">char</span> *label, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s:&lt;br&gt;\n&lt;pre&gt;\n&quot;</span>, label);</span><br><span class="line">    <span class="keyword">for</span> (; *envp != <span class="literal">NULL</span>; envp++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *envp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&lt;/pre&gt;&lt;p&gt;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 只有在有数据处理的时候才解除阻塞</span></span><br><span class="line">    <span class="keyword">while</span> (FCGI_Accept() &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取请求体长度</span></span><br><span class="line">        <span class="type">char</span> *contentLength = getenv(<span class="string">&quot;CONTENT_LENGTH&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取请求头的数据</span></span><br><span class="line">        <span class="type">char</span> *text = getenv(<span class="string">&quot;QUERY_STRING&quot;</span>);</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Content-type: text/html\r\n&quot;</span></span><br><span class="line">               <span class="string">&quot;\r\n&quot;</span></span><br><span class="line">               <span class="string">&quot;&lt;title&gt;FastCGI 处理结果&lt;/title&gt;&quot;</span></span><br><span class="line">               <span class="string">&quot;&lt;h1&gt;FastCGI 结果&lt;/h1&gt;\n&quot;</span></span><br><span class="line">               <span class="string">&quot;Request number %d,  Process ID: %d&lt;p&gt;\n&quot;</span>,</span><br><span class="line">               ++count, getpid());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (contentLength != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            len = strtol(contentLength, <span class="literal">NULL</span>, <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            len = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123; <span class="comment">// 可能是get方式</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;No data from standard input.&lt;p&gt;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123; <span class="comment">// post方式提交的数据</span></span><br><span class="line">            <span class="type">int</span> i, ch;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Standard input:&lt;br&gt;\n&lt;pre&gt;\n&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ((ch = getchar()) &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Error: Not enough bytes received on standard input&lt;p&gt;\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">putchar</span>(ch);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&lt;/pre&gt;&lt;p&gt;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="comment">/* while */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="分布式服务器"><a href="#分布式服务器" class="headerlink" title="分布式服务器"></a>分布式服务器</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202305111450044.png" alt="image-20230511145005482"></p>
<ul>
<li>nginx<ul>
<li>能处理静态请求 -&gt; html,jpg</li>
<li>动态请求无法处理</li>
<li>服务器集群之后,每台服务器上部署的内容必须相同</li>
</ul>
</li>
<li>FastCGI<ul>
<li>帮助服务器处理动态请求</li>
</ul>
</li>
<li>反向代理服务器<ul>
<li>客户端并不能直接访问到web服务器,直接访问到的是反向代理服务器</li>
<li>客户端将请求发送给反向代理服务器,反向代理服务器将客户端请求转发给服务器</li>
</ul>
</li>
<li>关系型[[数据库]]<ul>
<li>存储文件属性信息</li>
<li>用户属性信息</li>
</ul>
</li>
<li>redis - 非关系型<a href="%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93">[数据库]</a><ul>
<li>提高程序效率</li>
<li>存储的是服务器经常要从关系型数据库中读取的数据</li>
</ul>
</li>
<li>FASTDFS - 分布式文件系统<ul>
<li>存储文件内容</li>
<li>供用户下载</li>
</ul>
</li>
</ul>
<h3 id="分布式文件系统"><a href="#分布式文件系统" class="headerlink" title="分布式文件系统"></a>分布式文件系统</h3><blockquote>
<p>文件系统的全部, 不在同一台主机上，而是在很多台主机上，多个分散的文件系统组合在一起，形成了一个完整的文件系统。</p>
</blockquote>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202306101457914.png" alt="image-20230511152805626" style="zoom:50%;" />

<p>分布式文件系统:</p>
<ol>
<li>需要有网络</li>
<li>多台主机<br>不需要在同一地点</li>
<li>需要管理者</li>
<li>编写应用层的管理程序<br>不需要编写</li>
</ol>
<p>常用分布式文件系统</p>
<table>
<thead>
<tr>
<th align="left">分布式文件系统</th>
<th align="left">github star</th>
<th align="left">os支持</th>
</tr>
</thead>
<tbody><tr>
<td align="left">minio</td>
<td align="left">25.1k</td>
<td align="left">win&#x2F;linux</td>
</tr>
<tr>
<td align="left">fastdfs</td>
<td align="left">7k</td>
<td align="left">win</td>
</tr>
<tr>
<td align="left">ceph</td>
<td align="left">8.6k</td>
<td align="left">win&#x2F;linux</td>
</tr>
<tr>
<td align="left">GlusterFS</td>
<td align="left">2.9k</td>
<td align="left">win&#x2F;linux</td>
</tr>
</tbody></table>
<h4 id="FastDFS"><a href="#FastDFS" class="headerlink" title="FastDFS"></a>FastDFS</h4><blockquote>
<ul>
<li><p>是用c语言编写的一款开源的分布式文件系统。</p>
<p>开发者:余庆 - 淘宝的架构师</p>
</li>
<li><p>为互联网量身定制，充分考虑了冗余备份、负载均衡、线性扩容等机制，注重高可用、高性能等指标</p>
<ul>
<li>冗余备份: 纵向扩容</li>
<li>线性扩容: 横向扩容</li>
</ul>
</li>
<li><p>可以很容易搭建一套高性能的文件服务器集群提供文件 上传、下载 等服务。E.g.图床,网盘</p>
</li>
</ul>
</blockquote>
<p><strong>fastDFS框架中的三个角色</strong>(进程)</p>
<ul>
<li>追踪器(Tracker) - 管理存储节点的管理者 - 守护进程</li>
<li>存储节点(storage) -守护进程</li>
<li>客户端 - 通过连接追踪器找到目标存储节点,通过连接存储节点进行上传与下载操作<ul>
<li>文件上传</li>
<li>文件下载</li>
</ul>
</li>
</ul>
<p><strong>三者的关系</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202305111547440.png" alt="image-20230511154527564" style="zoom:67%;" />

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202305111547958.png" alt="image-202305111547958" style="zoom:67%;" />

<p><strong><code>追踪器</code></strong></p>
<p>最先启动追踪器</p>
<p><strong><code>存储节点</code></strong></p>
<p>第二个启动的角色</p>
<p>存储节点启动之后, 会单独开一个线程向追踪器汇报信息</p>
<ul>
<li>汇报当前存储节点的容量, 和剩余容量</li>
<li>汇报数据的同步情况</li>
<li>汇报数据被下载的次数</li>
</ul>
<p><strong><code>客户端</code></strong></p>
<p>最后启动</p>
<p>上传</p>
<ul>
<li>连接追踪器, 询问存储节点的信息</li>
<li>我要上传1G的文件, 询问那个存储节点有足够的容量</li>
<li>追踪器查询, 得到结果</li>
<li>追踪器将查到的存储节点的IP+端口发送给客户端</li>
<li>通过得到IP和端口连接存储节点</li>
<li>将文件内容发送给存储节点</li>
</ul>
<p>下载</p>
<ul>
<li>连接追踪器, 询问存储节点的信息</li>
<li>问一下, 要下载的文件在哪一个存储节点</li>
<li>追踪器查询, 得到结果</li>
<li>追踪器将查到的存储节点的IP+端口发送给客户端</li>
<li>通过得到IP和端口连接存储节点</li>
<li>下载文件</li>
</ul>
<h5 id="FastDFS集群"><a href="#FastDFS集群" class="headerlink" title="FastDFS集群"></a>FastDFS集群</h5><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202305171136533.png" alt="image-20230517113645120" style="zoom: 67%;" />

<blockquote>
<ul>
<li>集群的优点:<strong>避免单点故障</strong>(主要是针对tracker)</li>
<li>多个tracker靠被<strong>轮询</strong>工作</li>
<li>实现集群的方式:<strong>修改配置文件</strong></li>
</ul>
<p>fastDFS管理存储节点的方式:通过<strong>分组</strong>的方式完成</p>
</blockquote>
<p>集群方式扩容方式</p>
<ul>
<li><p><strong>横向扩容</strong>:增加容量</p>
<p>添加一台新的主机 -&gt; 容量增加</p>
<p>新主机作为一个新的组</p>
<p>不同的组间的主机之间不需要互相通信</p>
</li>
<li><p><strong>纵向扩容</strong>:数据备份</p>
<p>将新的主机放到现有的组中</p>
<p>一个组中的多台主机之间的关系是相互备份的关系</p>
<p>因此同一个组间的主机之间需要互相通信</p>
</li>
</ul>
<p>$$<br>每一个组的大小 &#x3D; 组中最小的主机的大小<br>$$</p>
<p>$$<br>fastDFS集群存储容量 &#x3D; 每一个组的大小之和<br>$$</p>
<p>因此上图中fastDFS集群的最大存储容量为2T(500G+1.5T)</p>
<h5 id="fastDFS安装"><a href="#fastDFS安装" class="headerlink" title="fastDFS安装"></a>fastDFS安装</h5><p><a target="_blank" rel="noopener" href="https://github.com/happyfish100/fastdfs">源码位置</a></p>
<p>下载源码后,按照INSTALL文件的描述进行安装与配置</p>
<p>fastDFS安装的所有可执行程序位置: <code>/usr/bin/fdfs_*</code></p>
<p><strong>主要配置项</strong></p>
<ul>
<li><p>追踪器配置文件 <code>/etc/fdfs/tracker.conf</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将追踪器和部署主机的IP地址进行绑定,也可以不写</span></span><br><span class="line"><span class="comment">#如果不写会自动绑定当前主机IP,如果为云服务器建议不写</span></span><br><span class="line">bing_addr=</span><br><span class="line"><span class="comment">#追踪器监听的端口(默认22122)</span></span><br><span class="line">port=22122</span><br><span class="line"><span class="comment">#追踪器存储日志信息的目录,xxx.pid文件,必须是一个存在的目录,并且用户需要对该路径中的文件有读写权限</span></span><br><span class="line">base_path=/home/yuqing/fastdfs</span><br></pre></td></tr></table></figure>
</li>
<li><p>存储节点配置文件  <code>/etc/fdfs/storage.conf</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#当前存储节点对应的主机属于哪一个组</span></span><br><span class="line">group_name=group1</span><br><span class="line"><span class="comment">#当前存储节点和部署主机的IP进行绑定,如果为云服务器建议不写</span></span><br><span class="line">bing_addr=</span><br><span class="line"><span class="comment">#存储节点监听的端口(默认23000),监听客户端的连接</span></span><br><span class="line">port=23000</span><br><span class="line"><span class="comment">#存储节点存储日志信息的目录,xxx.pid文件,必须是一个存在的目录,并且用户需要对该路径中的文件有读写权限</span></span><br><span class="line">base_path=/home/yuqing/fastdfs</span><br><span class="line"><span class="comment">#存储节点提供的存储文件的路径个数</span></span><br><span class="line">store_path_count = 1</span><br><span class="line"><span class="comment">#具体的存储路径,上面项为2的话,存储路径还需要填写store_path1</span></span><br><span class="line">store_path0 = /home/yuqing/fastdfs</span><br><span class="line"><span class="comment">#设置追踪器的ip地址与端口  (该项可以多次,即轮询多个追踪器，用于多个追踪服务器。追踪服务器的值格式为“HOST:PORT”，HOST可以是主机名或IP地址，并且HOST可以是用逗号分隔的双IP或主机名，双IP必须是内部（内网）IP和外部（外网）IP，或两种不同类型的内部（内网）IP。例如：192.168.2.100,122.244.141.46:22122 另一个例子：192.168.1.10,172.17.4.21:22122)</span></span><br><span class="line">tracker_server = 192.168.209.121:22122</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端配置文件  <code>/etc/fdfs/client.conf</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#客户端存储日志信息的目录,xxx.pid文件,必须是一个存在的目录,并且用户需要对该路径中的文件有读写权限</span></span><br><span class="line">base_path = /home/yuqing/fastdfs</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置追踪器的ip地址与端口 (填写规则同上存储节点配置文件)</span></span><br><span class="line">tracker_server = 192.168.0.196:22122</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="FastDFS启动"><a href="#FastDFS启动" class="headerlink" title="FastDFS启动"></a>FastDFS启动</h5><ol>
<li>启动追踪器</li>
<li>启动存储节点</li>
<li>启动客户端</li>
</ol>
<p>格式为:<code>程序 配置文件路径 [stop/restart]</code>([stop&#x2F;restart]省略表示第一次启动)  如:<code>fdfs_storaged /etc/fdfs/storage.conf</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">step 6. run the server programs</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">start the tracker server:启动追踪器</span></span><br><span class="line">/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">关闭追踪器</span></span><br><span class="line">/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf stop</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重启追踪器</span></span><br><span class="line">/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf restart</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">start the storage server:启动存储节点</span></span><br><span class="line">/usr/bin/fdfs_storaged /etc/fdfs/storage.conf</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重启和停止同追踪器格式</span></span><br><span class="line"></span><br><span class="line">/sbin/service fdfs_trackerd restart</span><br><span class="line">/sbin/service fdfs_storaged restart</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">step 7. (optional) run monitor program#运行监控程序</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">such as:</span></span><br><span class="line">/usr/bin/fdfs_monitor /etc/fdfs/client.conf</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">用于检测fastDFS的状态</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">step 8. (optional) run the <span class="built_in">test</span> program</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">such as:</span></span><br><span class="line">/usr/bin/fdfs_test &lt;client_conf_filename&gt; &lt;operation&gt;</span><br><span class="line">/usr/bin/fdfs_test1 &lt;client_conf_filename&gt; &lt;operation&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">客户端上传文件</span></span><br><span class="line">/usr/bin/fdfs_upload_file /etc/fdfs/client.conf 要上传的文件路径</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">会返回一个字符串,表示文件<span class="built_in">id</span>,如:</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">group1/M00/00/00/CtM3A2SleRCAZ1YnAACK4SS3qzw622.jpg</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">客户端下载文件</span></span><br><span class="line">/usr/bin/fdfs_download_file /etc/fdfs/client.conf 要下载的文件的文件id</span><br></pre></td></tr></table></figure>

<h4 id="上传下载代码实现"><a href="#上传下载代码实现" class="headerlink" title="上传下载代码实现"></a>上传下载代码实现</h4><h5 id="使用多进程方式实现"><a href="#使用多进程方式实现" class="headerlink" title="使用多进程方式实现"></a>使用多进程方式实现</h5><p>exec函数组函数</p>
<ul>
<li>execl</li>
<li>execlp</li>
</ul>
<p>父进程-&gt;创建子进程:执行<code>execlp(&quot;fdfs_upload_file&quot;,&quot;xx&quot;,arg,NULL)</code>,有结果输出,用dup2管道重定向标准输出到管道的写端.父进程读管道读端</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202305251636916.png" alt="image-20230525163610657" style="zoom: 67%;" />

<h5 id="使用fastDFS-API实现"><a href="#使用fastDFS-API实现" class="headerlink" title="使用fastDFS API实现"></a>使用fastDFS API实现</h5><p>余庆未提供api文档,只能通过看调用案例找API</p>
<p>安装文件夹中有test文件夹,该文件夹中的是调用案例</p>
<p>参考项目中自带的案例来实现</p>
<h4 id="fastDFS配合fastCGI项目"><a href="#fastDFS配合fastCGI项目" class="headerlink" title="fastDFS配合fastCGI项目"></a>fastDFS配合fastCGI项目</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202306251137772.png" alt="image-20230625113716573"></p>
<p><a target="_blank" rel="noopener" href="https://github.com/happyfish100/fastdfs-nginx-module">nginx的fastdfs插件下载链接</a></p>
<ol>
<li><p>在fastDFS存储节点上安装Nginx,需要交叉编译nginx和nginx的fastDFS插件.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">交叉编译nginx和nginx的fastDFS插件,在nginx目录中执行下面命令:</span></span><br><span class="line">./configure --add-module=/root/Desktop/fastdfs-nginx-module/src --with-openssl=../nginxNeed/openssl-1.1.1u  --with-pcre=../nginxNeed/pcre2-10.42 --with-zlib=../nginxNeed/zlib-1.2.13</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
</li>
<li><p>从fastDFS插件的源码目录的src目录中找<code>mod_fastdfs.conf</code>执行<code>sudo cp mod_fastdfs.conf /etc/fdfs</code>,修改<code>mod_fastdfs.conf</code>(参考<code>storage.conf</code>来修改)</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#日志位置</span></span><br><span class="line">base_path=/home/xxx/fastdfs/<span class="attribute">storage</span></span><br><span class="line"><span class="comment">#配置追踪器的ip和端口</span></span><br><span class="line">tracker_server=xxx.xxx.xxx.xxx:<span class="number">22122</span></span><br><span class="line"><span class="comment">#存储节点绑定的端口</span></span><br><span class="line">storage_server_port=<span class="number">23000</span></span><br><span class="line"><span class="comment">#当前存储节点所属组</span></span><br><span class="line">group_name=group1</span><br><span class="line"><span class="comment">#客户端下载文件时候,这个下载的url中是否包含组的名字(仅在只有同一个组的时候,这个选项可以设为false)</span></span><br><span class="line">url_have_group_name=<span class="literal">true</span></span><br><span class="line"><span class="comment">#存储节点绑定的IP地址</span></span><br><span class="line">bind_addr=</span><br><span class="line"><span class="comment">#存储节点上存储路径的个数</span></span><br><span class="line">store_path_count=<span class="number">1</span></span><br><span class="line"><span class="comment">#存储路径的详细位置(可以多个)	</span></span><br><span class="line">store_path0=/home/xxx/fastdfs/storage</span><br><span class="line"><span class="comment">#store_path1=...</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>重新启动nginx后,执行<code>ps aux | grep nginx</code>发现没有worker进程,查看<code>/usr/local/nginx/logs/error.log</code>日志,报错如下:</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ERROR</span> - file: ini_file_reader.c, line: <span class="number">1051</span>, include file <span class="string">&quot;http.conf&quot;</span> not exists, line: <span class="string">&quot;#include http.conf&quot;</span></span><br><span class="line"><span class="comment">#解决方式如下:从fastDFS源码安装目录找./conf,执行下面命令:</span></span><br><span class="line">sudo cp http.conf /etc/fdfs</span><br><span class="line"></span><br><span class="line">ERROR - file: shared_func.c, line: <span class="number">1301</span>, file /etc/fdfs/mime.types not exist</span><br><span class="line"><span class="comment">#解决方式如下:从fastDFS源码安装目录找./conf,执行下面命令:</span></span><br><span class="line">sudo cp mime.types /etc/fdfs</span><br></pre></td></tr></table></figure>
</li>
<li><p>资源在存储节点的存储目录中,store_path0等中,需要告诉nginx服务器资源在哪,<code>nginx.conf</code>添加location</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#location /group1/M00/00/00/</span></span><br><span class="line"><span class="comment">#由于/00/00经常变化并不是固定目录,因此:</span></span><br><span class="line"><span class="section">location</span> /group1/M00/&#123;</span><br><span class="line">  <span class="comment">#告诉服务器资源的位置</span></span><br><span class="line">  <span class="attribute">root</span> /opt/fastdfs/data;</span><br><span class="line">  ngx_fastdfs_module;<span class="comment">#标记需要通过fastdfs插件处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加了之后重启效果如下:<code>ngx_http_fastdfs_set pid=699791</code></p>
</li>
<li></li>
</ol>
<h1 id="日志实现案例"><a href="#日志实现案例" class="headerlink" title="日志实现案例"></a>日志实现案例</h1><h2 id="源文件"><a href="#源文件" class="headerlink" title="源文件"></a>源文件</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span>  msgopt, wanopt;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> msgdatefmt[<span class="number">100</span>], wandatefmt[<span class="number">100</span>], ident_name[<span class="number">100</span>];</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">be_stime</span>;</span></span><br><span class="line"><span class="type">static</span> FILE *msgfile = <span class="literal">NULL</span>, *wanfile = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">/* ************************************************************************************ */</span></span><br><span class="line"><span class="comment">/* ************************************************************************************ */</span></span><br><span class="line"><span class="comment">/* ************************************************************************************ */</span></span><br><span class="line"><span class="comment">//日志文件初始化,也可以通过msgLogOpen进行初始化</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgInit</span><span class="params">(<span class="type">char</span> *pName)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (msgLogOpen(pName, LOG_MESSAGE_FILE, LOG_POSTFIX_MESS,LOG_WARNING_FILE, LOG_POSTFIX_WARN) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        msgLogFormat(LOG_PROCNAME|LOG_PID, LOG_MESSAGE_DFMT, LOG_PROCNAME|LOG_PID, LOG_WARNING_DFMT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>                             </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;can not create log!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* ************************************************************************************ */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgLogOpen</span><span class="params">(<span class="type">char</span> *ident, <span class="type">char</span> *mpre, <span class="type">char</span> *mdate, <span class="type">char</span> *wpre, <span class="type">char</span> *wdate)</span> <span class="comment">/* 打开日志 */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">time_t</span> now_time;</span><br><span class="line">    <span class="type">char</span> openfilename[<span class="number">200</span>], timestring[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    now_time = time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> ((!msgfile) &amp;&amp; (*mpre))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(openfilename, mpre);</span><br><span class="line">        <span class="keyword">if</span> (*mdate)</span><br><span class="line">        &#123;</span><br><span class="line">            strftime(timestring, <span class="keyword">sizeof</span>(timestring), mdate, localtime(&amp;now_time));</span><br><span class="line">            <span class="built_in">strcat</span>(openfilename, <span class="string">&quot;.&quot;</span>);</span><br><span class="line">            <span class="built_in">strcat</span>(openfilename, timestring);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((msgfile = fopen(openfilename, <span class="string">&quot;a+b&quot;</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">        &#123; <span class="comment">/* 如果没有应该把目录建上 */</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;openfilename=%s\n&quot;</span>, openfilename);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        setlinebuf(msgfile);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((!wanfile) &amp;&amp; (*wpre))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(openfilename, wpre);</span><br><span class="line">        <span class="keyword">if</span> (*wdate)</span><br><span class="line">        &#123;</span><br><span class="line">            strftime(timestring, <span class="keyword">sizeof</span>(timestring), wdate, localtime(&amp;now_time));</span><br><span class="line">            <span class="built_in">strcat</span>(openfilename, <span class="string">&quot;.&quot;</span>);</span><br><span class="line">            <span class="built_in">strcat</span>(openfilename, timestring);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((wanfile = fopen(openfilename, <span class="string">&quot;a+b&quot;</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        setlinebuf(wanfile);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((msgfile) &amp;&amp; (wanfile))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*ident)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(ident_name, ident);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ident_name[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        msgopt = LOG_PROCNAME|LOG_PID;          <span class="comment">/* 设置默认信息输出信息选项              */</span></span><br><span class="line">        wanopt = LOG_PROCNAME|LOG_PID;          <span class="comment">/* 设置默认告警输出信息选项              */</span></span><br><span class="line">        <span class="built_in">strcpy</span>(msgdatefmt, <span class="string">&quot;%m-%d %H:%M:%S&quot;</span>);   <span class="comment">/* 默认信息输出时间格式 MM-DD HH24:MI:SS */</span></span><br><span class="line">        <span class="built_in">strcpy</span>(wandatefmt, <span class="string">&quot;%m-%d %H:%M:%S&quot;</span>);   <span class="comment">/* 默认告警输出时间格式 MM-DD HH24:MI:SS */</span></span><br><span class="line"></span><br><span class="line">        msglog(MSG_INFO,<span class="string">&quot;File is msgfile=[%d],wanfile=[%d].&quot;</span>,fileno(msgfile),fileno(wanfile));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* ************************************************************************************ */</span></span><br><span class="line"><span class="comment">/* 自定义日志输出函数系列,可以按普通信息及告警信息分类输出程序日志                      */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">msglog</span><span class="params">(<span class="type">int</span> mtype, <span class="type">char</span> *outfmt, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">time_t</span> now_time;</span><br><span class="line">    va_list ap;<span class="comment">//变参的列表</span></span><br><span class="line">    <span class="type">char</span> logprefix[<span class="number">1024</span>], tmpstring[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    time(&amp;now_time);</span><br><span class="line">    <span class="keyword">if</span> (mtype &amp; MSG_INFO)</span><br><span class="line">    &#123; <span class="comment">/*strftime会将localtime(&amp;now_time)按照msgdatefmt格式,输出到logprefix.*/</span></span><br><span class="line">        strftime(logprefix, <span class="keyword">sizeof</span>(logprefix), msgdatefmt, localtime(&amp;now_time));</span><br><span class="line">        <span class="built_in">strcat</span>(logprefix, <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="comment">/*static int  msgopt,wanopt;*/</span></span><br><span class="line">        <span class="keyword">if</span> (msgopt&amp;LOG_PROCNAME)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strcat</span>(logprefix, ident_name);</span><br><span class="line">            <span class="built_in">strcat</span>(logprefix, <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (msgopt&amp;LOG_PID)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">sprintf</span>(tmpstring, <span class="string">&quot;[%6d]&quot;</span>, getpid());</span><br><span class="line">            <span class="built_in">strcat</span>(logprefix, tmpstring);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">fprintf</span>(msgfile, <span class="string">&quot;%s: &quot;</span>, logprefix);</span><br><span class="line">        va_start(ap, outfmt);</span><br><span class="line">        <span class="built_in">vfprintf</span>(msgfile, outfmt, ap);</span><br><span class="line">        va_end(ap);</span><br><span class="line">        <span class="built_in">fprintf</span>(msgfile, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mtype &amp; MSG_WARN)</span><br><span class="line">    &#123;</span><br><span class="line">        strftime(logprefix, <span class="keyword">sizeof</span>(logprefix), wandatefmt, localtime(&amp;now_time));</span><br><span class="line">        <span class="built_in">strcat</span>(logprefix, <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="comment">/*#define LOG_PROCNAME      0x00000001*/</span>              <span class="comment">/* msglog 输出日志时打印程序名        */</span></span><br><span class="line">        <span class="keyword">if</span> (wanopt &amp; LOG_PROCNAME)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strcat</span>(logprefix, ident_name);</span><br><span class="line">            <span class="built_in">strcat</span>(logprefix, <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (wanopt &amp; LOG_PID)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">sprintf</span>(tmpstring, <span class="string">&quot;[%6d]&quot;</span>, getpid());</span><br><span class="line">            <span class="built_in">strcat</span>(logprefix, tmpstring);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">fprintf</span>(wanfile, <span class="string">&quot;%s: &quot;</span>, logprefix);</span><br><span class="line">        va_start(ap, outfmt);</span><br><span class="line">        <span class="built_in">vfprintf</span>(wanfile, outfmt, ap);</span><br><span class="line">        va_end(ap);</span><br><span class="line">        <span class="built_in">fprintf</span>(wanfile, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (wanopt &amp; LOG_PERROR)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s: &quot;</span>, logprefix);</span><br><span class="line">            va_start(ap, outfmt);</span><br><span class="line">            <span class="built_in">vfprintf</span>(<span class="built_in">stderr</span>, outfmt, ap);</span><br><span class="line">            va_end(ap);</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* ************************************************************************************ */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgLogFormat</span><span class="params">(<span class="type">int</span> mopt, <span class="type">char</span> *mdfmt, <span class="type">int</span> wopt, <span class="type">char</span> *wdfmt)</span>   <span class="comment">/* 设置日志格式及选项  */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mopt &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        msgopt = mopt;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        msgopt = msgopt &amp; mopt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wopt &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        wanopt = wopt;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        wanopt = wanopt &amp; wopt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*mdfmt) <span class="built_in">strcpy</span>(msgdatefmt, mdfmt);</span><br><span class="line">    <span class="keyword">if</span> (*wdfmt) <span class="built_in">strcpy</span>(wandatefmt, wdfmt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* ************************************************************************************ */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgLogClose</span><span class="params">(<span class="type">void</span>)</span>                                           <span class="comment">/* 关闭日志文件         */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (msgfile) fclose(msgfile);</span><br><span class="line">    <span class="keyword">if</span> (wanfile) fclose(wanfile);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* ************************************************************************************ */</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">begusec_process</span><span class="params">(<span class="type">void</span>)</span>                      <span class="comment">/* 设置开始时间 0=ok                    */</span></span><br><span class="line">&#123;</span><br><span class="line">    gettimeofday(&amp;be_stime,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* ************************************************************************************ */</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">getusec_process</span><span class="params">(<span class="type">void</span>)</span>                      <span class="comment">/* 返回usecond 从 begusec_process历时   */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">ed_stime</span>;</span></span><br><span class="line"></span><br><span class="line">    gettimeofday(&amp;ed_stime,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ((ed_stime.tv_sec-be_stime.tv_sec)*<span class="number">1000000</span>+ed_stime.tv_usec-be_stime.tv_usec);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* ************************************************************************************ */</span></span><br><span class="line"><span class="comment">/* ************************************************************************************ */</span></span><br><span class="line"><span class="comment">/* ************************************************************************************ */</span></span><br><span class="line"><span class="comment">/* ************************************************************************************ */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="头文件log-h"><a href="#头文件log-h" class="headerlink" title="头文件log.h"></a>头文件log.h</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LOG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_H</span></span><br><span class="line"><span class="comment">/* ************************************************************************************ */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/statfs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_PROCNAME      0x00000001              <span class="comment">/* msglog 输出日志时打印程序名        */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_PID           0x00000010              <span class="comment">/* msglog 输出日志时打印进程 PID      */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_PERROR        0x00000100              <span class="comment">/* msglog 是否把告警内容输出到stderr  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NLO_PROCNAME      0x11111110              <span class="comment">/* msglog 不输出程序名                */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NLO_PID           0x11111101              <span class="comment">/* msglog 不输出进程 PID              */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NLO_PERROR        0x11111011              <span class="comment">/* msglog 不输出告警到stderr          */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_INFO          0x00000001              <span class="comment">/* msglog 输出到告警日志文件中        */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_WARN          0x00000010              <span class="comment">/* msglog 输出到普通日志文件中        */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_BOTH          MSG_INFO|MSG_WARN       <span class="comment">/* msglog 输出到普通和告警日志文件中  */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_MESSAGE_FILE  <span class="string">&quot;/home/itheima/log/tcpsvr&quot;</span>           <span class="comment">/* 系统程序运行日志信息文件           */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_MESSAGE_DFMT  <span class="string">&quot;%m-%d %H:%M:%S&quot;</span>        <span class="comment">/* 日志信息时间格式字串               */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_POSTFIX_MESS  <span class="string">&quot;%y%m&quot;</span>                  <span class="comment">/* 程序运行日志信息文件后缀           */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_WARNING_FILE  <span class="string">&quot;/home/itheima/log/log.sys_warn&quot;</span>   <span class="comment">/* 系统程序运行告警日志文件           */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_WARNING_DFMT  <span class="string">&quot;%m-%d %H:%M:%S&quot;</span>        <span class="comment">/* 告警信息时间格式字串               */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_POSTFIX_WARN  <span class="string">&quot;&quot;</span>                      <span class="comment">/* 程序运行告警日志文件后缀           */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ************************************************************************************ */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">msglog</span><span class="params">(<span class="type">int</span> mtype, <span class="type">char</span> *outfmt, ...)</span>;<span class="comment">//写日志函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgLogFormat</span><span class="params">(<span class="type">int</span> mopt, <span class="type">char</span> *mdfmt, <span class="type">int</span> wopt, <span class="type">char</span> *wdfmt)</span>;<span class="comment">//对日志格式化 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgLogOpen</span><span class="params">(<span class="type">char</span> *ident, <span class="type">char</span> *mpre, <span class="type">char</span> *mdate, <span class="type">char</span> *wpre, <span class="type">char</span> *wdate)</span>;<span class="comment">//打开日志文件</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgLogClose</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//关闭日志文件</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">begusec_process</span><span class="params">(<span class="type">void</span>)</span>;                      <span class="comment">/* 设置开始时间 0=ok                   */</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">getusec_process</span><span class="params">(<span class="type">void</span>)</span>;                      <span class="comment">/* 返回usecond 从 begusec_process历时  */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgInit</span><span class="params">(<span class="type">char</span> *pName)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/* ************************************************************************************ */</span></span><br><span class="line"><span class="comment">/* ************************************************************************************ */</span></span><br><span class="line"><span class="comment">/* ************************************************************************************ */</span></span><br><span class="line"><span class="comment">/* ************************************************************************************ */</span></span><br></pre></td></tr></table></figure>

<h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><ol>
<li><code>msgInit(&quot;日志文件名&quot;)</code>  初始化日志文件</li>
<li><code>msglog([MSG_INFO或MSG_BOTH],&quot;&quot;,...)</code> 输出内容到日志文件</li>
<li><code>msgLogClose()</code> 关闭日志文件</li>
</ol>
<h1 id="报文编解码"><a href="#报文编解码" class="headerlink" title="报文编解码"></a>报文编解码</h1><ul>
<li>报文:  网络通信过程中接受发送的数据</li>
<li>编码:   将传输的数据转换为字节流的过程</li>
<li><code>ASN.1</code>:  通用的一种编码格式</li>
</ul>
<p>两台机器通信有如下要考虑</p>
<ol>
<li>网络传输的时候需要用大端模式</li>
<li>字节序对齐不同,比如结构体</li>
<li>等等….</li>
</ol>
<h2 id="常用序列化方式"><a href="#常用序列化方式" class="headerlink" title="常用序列化方式"></a>常用序列化方式</h2><h3 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h3><p>XML(Extensible Markup Language),类似于html</p>
<p>XML是一种常用的序列化和反序列化协议,具有跨机器,跨语言等优点.XML历史悠久,其1.0版本早在1998年就形成标准,并被广泛使用至今</p>
<p>XML最初产生的目标是对互联网文档进行标记,所以它的设计理念中就包含了对于人和机器都具备可读性.但是,当这种标记文档的设计被用来序列化对象的时候,就显得冗长而复杂</p>
<p>XML基本格式:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">part</span> <span class="attr">id</span> = <span class="string">&quot;01&quot;</span> <span class="attr">name</span>=<span class="string">&quot;选项一&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>我是徐茅山<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>今年20岁<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sex</span>&gt;</span>男<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">part</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">part</span> <span class="attr">id</span>=<span class="string">&quot;02&quot;</span> <span class="attr">name</span>=<span class="string">&quot;选项二&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>我是李逍遥<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>今年22岁<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sex</span>&gt;</span>男<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">part</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Json"><a href="#Json" class="headerlink" title="Json"></a>Json</h3><p>Json(JavaScript Object Notation)</p>
<p>JSON起源于弱类型语言Javascript,它的产生来自于一种称之为”关联数组(Associative array)”的概念,其本质是采用**”键值对”**的方式来描述对象</p>
<p>JSON格式保持了XML的人眼可读的优点,非常符合工程师对对象的理解</p>
<p>相对于XML而言,序列化后的数据更加简洁(XML所产生序列化之后文件的大小接近JSON的两倍),而且其协议比较简单,解析速度比较快</p>
<p>JSON格式具备Javascript的先天性支持,所以被广泛应用于Web browser的应用场景中,是Ajax的事实标准协议.</p>
<p><a target="_blank" rel="noopener" href="https://www.json.org/json-zh.html">官网介绍跳转</a></p>
<p>说明</p>
<ul>
<li>json对象格式的字符串都是以键值对的形式存在的—&gt;<code>key:value</code>,其中key都是以字符串的形式存在的,而value部分可以包含:<code>int bool char double</code>等多种类型,value还可以是子对象或者数组</li>
<li>在json文件中,只能是json对象和json数组,不能既有json对象也有json数组</li>
<li>在json对象内部,可以包含子json对象,也可以有子json数组</li>
<li>在json数组内部,可以有子json对象,也可以有子json数组</li>
</ul>
<h3 id="Protocol-Buffer"><a href="#Protocol-Buffer" class="headerlink" title="Protocol Buffer"></a>Protocol Buffer</h3><p><a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers">官方文档</a></p>
<p>Protocol Buffer(简称Protobuf)是Google公司内部的混合语言数据标准,它是一种轻便高效的结构化数据存储格式,可以用于结构化数据串行化,很适合做数据存储或RPC数据交换格式</p>
<blockquote>
<ol>
<li>高效的序列化：protobuf使用<strong>二进制编码</strong>，相比于文本格式如JSON和XML，它的序列化后的<strong>数据体积更小，传输效率更高</strong>。</li>
<li>跨平台和语言无关：protobuf定义了一种独立于语言和平台的数据描述语言，可以在不同的编程语言之间进行数据的序列化和反序列化，使得不同系统之间的数据交换更加方便。</li>
<li>可扩展性：protobuf支持向后兼容和向前兼容的数据格式演化，可以在不破坏现有数据结构的情况下进行数据模型的更新和扩展。<ul>
<li><strong>向后兼容性</strong>（Backward compatibility）：新版本的数据模型可以解析旧版本的数据，即新模型可以正确地处理旧数据，不会导致解析错误或数据丢失。这意味着旧版本的数据可以与新版本的代码一起使用。</li>
</ul>
<ol start="2">
<li><strong>向前兼容性</strong>（Forward compatibility）：旧版本的数据可以被新版本的数据模型解析，即旧模型可以正确地处理新数据，不会导致解析错误或数据丢失。这意味着新版本的数据可以与旧版本的代码一起使用。</li>
</ol>
</li>
<li>代码生成：protobuf提供了代码生成工具(protoc命令行工具)，可以根据定义的数据结构自动生成对应的类代码，简化了数据的编码和解码过程，提高了开发效率。</li>
<li>可读性：protobuf的定义文件采用了类似于IDL（接口定义语言）的结构，可以清晰地描述数据的结构和字段含义，便于理解和维护。</li>
</ol>
</blockquote>
<p>ASN.1和Protocol的主要应用场景区别</p>
<ul>
<li>ASN.1：ASN.1广泛应用于电信领域、安全协议、网络管理等场景，例如在SNMP（Simple Network Management Protocol）和TLS（Transport Layer Security）中使用。</li>
<li>Protocol Buffers：Protocol Buffers被广泛用于分布式系统通信、数据存储、配置文件、RPC等领域。</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>ASN.1抽象语法标记(Abstract Syntax Notation One)</li>
<li>boost序列化的类</li>
<li>自定义的格式</li>
</ul>
<h2 id="ASN-1"><a href="#ASN-1" class="headerlink" title="ASN.1"></a>ASN.1</h2><p>ASN.1抽象语法标记,是一种ISO&#x2F;ITU-T标准,是描述在网络上传输信息格式的标准方法.描述了一种对数据进行表示,编码,传输和解码的数据格式.它提供了一整套正规的格式用于描述对象的结构,而不管语言上如何执行及这些数据的具体指代,也不用去管到底是什么样的应用程序</p>
<p><strong>本质解决的是在网络上传输数据结构的数据</strong> </p>
<p>ASN.1有两部分</p>
<ol>
<li>一部分描述信息内数据,数据类型及序列格式(相当于属性)</li>
<li>一部分描述如何将各部分组成消息(相当于方法)</li>
</ol>
<p>标准的ASN.1编码规则有:</p>
<ul>
<li>基本编码规则(BER,Basic Encoding Rules)</li>
<li>规范编码规则(CER,Canonical Encoding Rules)</li>
<li>唯一编码规则(DER,Distinguished Encoding Rules)</li>
<li>压缩编码规则(PER,Packed Encoding Rules)</li>
<li>XML编码规则(XER,XML Encoding Rules)</li>
</ul>
<p>编码格式(TLV格式,即Tag,Length,Value组成的格式)</p>
<table>
<thead>
<tr>
<th>tag(type)</th>
<th>Length</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>数据类型</td>
<td>数据长度</td>
<td>数据的值</td>
</tr>
</tbody></table>
<p> 下面结构体编码图示:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Persion</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">long</span> age;</span><br><span class="line">	<span class="type">char</span> name[<span class="number">64</span>];</span><br><span class="line">&#125;Person;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202302071414997.png" alt="image-20230207141410914"></p>
<p>TLV节点对应的结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">tupedef <span class="class"><span class="keyword">struct</span> <span class="title">ITCAST_ANYBUF_</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *pData; <span class="comment">//数据的值V   真正的数据在这里</span></span><br><span class="line">	ITCAST_UINT32 dataLen; <span class="comment">//数据长度L</span></span><br><span class="line">	ITCAST_UINT32 unusedBits;</span><br><span class="line">	iTCAST_UINT32 memoryType;</span><br><span class="line">	iTCAST_UINT32 dataType; <span class="comment">//数据类型T</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ITCAST_ANYBUF_</span> *<span class="title">next</span>;</span><span class="comment">//指向下一个成员属性编码形成的结点</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ITCAST_ANYBUF_</span> *<span class="title">prev</span>;</span><span class="comment">//指向上一个成员属性编码形成的结点</span></span><br><span class="line">&#125;ITCAST_ANYBUF;</span><br></pre></td></tr></table></figure>

<p>原理：</p>
<ul>
<li>定义一个结点以TLV形式存储编码后的数据</li>
<li>被编码对象的每一个成员属性都会成为一个结点。从对象的一个成员开始到最后一个成员，所有新建的结点会连成一条双向链表，<strong>便于后续对象成员依次解码</strong></li>
<li>整个对象也会被编码，即将链表的首结点封装成一个新的节点，作为传出参数传出，<strong>便于解码时以对象为单位进行解码</strong></li>
</ul>
<p>TLV原理图:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202302101436746.png" alt="image-20230210143611378"></p>
<h3 id="相关函数-2"><a href="#相关函数-2" class="headerlink" title="相关函数"></a>相关函数</h3><blockquote>
<p>编解码函数中包括对各种基本数据类型的编解码函数，用于对对象的成员属性进行分别编码；同时还包括对对象进行编解码的函数，即对成员属性编码后形成的链表首结点进行编码</p>
</blockquote>
<ul>
<li><a href="#DER_ItAsn1_WriteInteger">DER_ItAsn1_WriteInteger</a>  整形-&gt;ITCAST_ANYBUF</li>
<li><a href="#DER_ItAsn1_ReadInteger">DER_ItAsn1_ReadInteger</a>   ITCAST_ANYBUF-&gt;整形</li>
<li><a href="#DER_ItAsn1_WritePrintableString">DER_ItAsn1_WritePrintableString</a></li>
<li><a href="#DER_ItAsn1_ReadPrintableString">DER_ItAsn1_ReadPrintableString</a></li>
<li><a href="#DER_ITCAST_String_To_AnyBuf">DER_ITCAST_String_To_AnyBuf</a>   char* -&gt;ITCAST_ANYBUF</li>
<li><a href="#EncodeChar/DecodeChar">EncodeChar&#x2F;DecodeChar</a>  char* &lt;-&gt;ITCAST_ANYBUF</li>
<li><a href="#DER_ItAsn1_WriteSequence">DER_ItAsn1_WriteSequence</a>  ITCAST_ANYBUF链表 -&gt; 发送的字节流</li>
<li><a href="#DER_ItAsn1_ReadSequence">DER_ItAsn1_ReadSequence</a>  接受的字节流 -&gt; ITCAST_ANYBUF链表</li>
<li><a href="#DER_ITCAST_FreeQueue">DER_ITCAST_FreeQueue</a>   释放内存</li>
</ul>
<h4 id="DER-ItAsn1-WriteInteger"><a href="#DER-ItAsn1-WriteInteger" class="headerlink" title="DER_ItAsn1_WriteInteger"></a>DER_ItAsn1_WriteInteger</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ITCAST_INT <span class="title function_">DER_ItAsn1_WriteInteger</span><span class="params">(ITCAST_UINT32 integer,ITASN1_INTEGER **ppDerInteger)</span>;</span><br></pre></td></tr></table></figure>

<p>功能:对整形数进行编码操作    int-&gt; ITCAST_ANYBUF</p>
<p>函数参数:<br>    <code>integer</code>: 输入参数, 表示待编码的整形数据<br>    <code>ppDerInteger</code>: 传出参数, ITCAST_ANYBUF指针的指针, 编码之后的数据,用于构造链表<br>返回值:<br>    成功或者失败</p>
<h4 id="DER-ItAsn1-ReadInteger"><a href="#DER-ItAsn1-ReadInteger" class="headerlink" title="DER_ItAsn1_ReadInteger"></a>DER_ItAsn1_ReadInteger</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ITCAST_INT <span class="title function_">DER_ItAsn1_ReadInteger</span><span class="params">(ITASN1_INTEGER *pDerInteger, ITCAST_UINT32 *pInteger)</span>;</span><br></pre></td></tr></table></figure>

<p>函数说明: 对整形数据解码    int-&gt; ITCAST_ANYBUF</p>
<p>参数说明:<br>    <code>pDerInteger</code>: 传入参数, ITCAST_ANYBUF指针, 表示待解码的数据<br>    <code>pInteger</code>: 传出参数, 表示解码之后的数据<br>返回值:<br>    成功或者失败</p>
<p>调用例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ITCAST_ANYBUF p;</span><br><span class="line">ITCAST_UINT32 aa; </span><br><span class="line">DER_ItAsn1_ReadInteger(&amp;p, &amp;aa);</span><br></pre></td></tr></table></figure>

<h4 id="DER-ItAsn1-WritePrintableString"><a href="#DER-ItAsn1-WritePrintableString" class="headerlink" title="DER_ItAsn1_WritePrintableString"></a>DER_ItAsn1_WritePrintableString</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ITCAST_INT <span class="title function_">DER_ItAsn1_WritePrintableString</span><span class="params">(ITASN1_PRINTABLESTRING *pPrintString, ITASN1_PRINTABLESTRING **ppDerPrintString)</span>;</span><br></pre></td></tr></table></figure>

<p>函数说明: 编码字符串数据</p>
<p>函数参数:<br>    <code>pPrintString</code>: 输入参数, ITCAST_ANYBUF指针,表示要编码的数据<br>    <code>ppDerPrintString</code>: 输出参数, ITCAST_ANYBUF指针的指针, 表示编码成链表格式之后的数据,用于<strong>构造链表</strong><br>返回值:<br>    成功或者失败	</p>
<h4 id="DER-ItAsn1-ReadPrintableString"><a href="#DER-ItAsn1-ReadPrintableString" class="headerlink" title="DER_ItAsn1_ReadPrintableString"></a>DER_ItAsn1_ReadPrintableString</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ITCAST_INT <span class="title function_">DER_ItAsn1_ReadPrintableString</span><span class="params">(ITASN1_PRINTABLESTRING *pDerPrintString, ITASN1_PRINTABLESTRING **ppPrintString)</span>;</span><br></pre></td></tr></table></figure>

<p>函数说明: 解码函数, 将<code>ANYCAST_ANYBUF</code>类型解码到第二个参数<br>参数说明:<br>        <code>pDerPrintString</code>: 输入参数,ITCAST_ANYBUF指针, 表示待解码的链表数据<br>        <code>ppPrintString</code>: 输出参数, ITCAST_ANYBUF指针的指针, 存放解码之后的数据<br>返回值:<br>    成功或者失败</p>
<h4 id="DER-ITCAST-String-To-AnyBuf"><a href="#DER-ITCAST-String-To-AnyBuf" class="headerlink" title="DER_ITCAST_String_To_AnyBuf"></a>DER_ITCAST_String_To_AnyBuf</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ITCAST_INT <span class="title function_">DER_ITCAST_String_To_AnyBuf</span><span class="params">(ITCAST_ANYBUF **pOriginBuf, <span class="type">unsigned</span> <span class="type">char</span> * strOrigin, <span class="type">int</span> strOriginLen)</span>;</span><br></pre></td></tr></table></figure>

<p>函数说明: 原始字节流转换为ITCAST_ANYBUF类型字节流,将char *—-&gt;ITCAST_ANYBUF类型</p>
<p>函数参数:<br>    <code>pOriginBuf</code>: 传出参数, ITCAST_ANYBUF指针的指针<br>    <code>strOrigin</code>: 传入参数, 待转换的字符串<br>    <code>strOriginLen</code>: 传入参数, strOrigin的字符串长度<br>返回值:<br>    成功或者失败</p>
<h4 id="EncodeChar-DecodeChar"><a href="#EncodeChar-DecodeChar" class="headerlink" title="EncodeChar&#x2F;DecodeChar"></a>EncodeChar&#x2F;DecodeChar</h4><h5 id="EncodeChar"><a href="#EncodeChar" class="headerlink" title="EncodeChar"></a>EncodeChar</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">EncodeChar</span><span class="params">(<span class="type">char</span> *pData, <span class="type">int</span> dataLen, ITCAST_ANYBUF **outBuf)</span>;</span><br></pre></td></tr></table></figure>

<p>函数说明: 将char *类型数据进行编码,相当于集成了<a href="#DER_ITCAST_String_To_AnyBuf">DER_ITCAST_String_To_AnyBuf</a>和<a href="#DER_ItAsn1_WritePrintableString">(DER_ItAsn1_WritePrintableString</a></p>
<p>函数参数:<br>    <code>pData</code>: 输入参数, 指的是待编码的字符串<br>    <code>dataLen</code>: 输入参数, 指的是pData的长度<br>    <code>outBuf</code>: 输出参数, ITCAST_ANYBUF指针的指针, TLV格式</p>
<h5 id="DecodeChar"><a href="#DecodeChar" class="headerlink" title="DecodeChar"></a>DecodeChar</h5><p><strong>DecodeChar</strong>基本同理,<strong>某些情况下</strong>相当于集成了<a href="#DER_ITCAST_String_To_AnyBuf">DER_ITCAST_String_To_AnyBuf</a>和<a href="#DER_ItAsn1_ReadPrintableString">DER_ItAsn1_ReadPrintableString</a>,又有所<a href="#%E8%A7%A3%E7%A0%81%E4%B8%8A%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BD%93%E7%8E%B0">区别</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">DecodeChar</span><span class="params">(ITCAST_ANYBUF *inBuf, <span class="type">char</span> **Data, <span class="type">int</span> *pDataLen)</span>;</span><br></pre></td></tr></table></figure>

<h6 id="解码上两种方式的区别体现"><a href="#解码上两种方式的区别体现" class="headerlink" title="解码上两种方式的区别体现"></a>解码上两种方式的区别体现</h6><p>如下结构体中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Temp</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="type">char</span> name[<span class="number">64</span>];</span><br><span class="line">		<span class="type">char</span> *p;</span><br><span class="line">	&#125;Temp;</span><br></pre></td></tr></table></figure>

<p>解码name时不可以使用<code>DecodeChar</code>来解码,p可以.原因如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">DecodeChar</span><span class="params">(<span class="type">char</span>** p)</span></span><br><span class="line">&#123;</span><br><span class="line">	*p = <span class="built_in">malloc</span>();<span class="comment">//DecodeChar中包含对二级指针的malloc操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">	DecodeChar(...,&amp;name,...);<span class="comment">//会报错,由于数组名是指针常量,因此不可以修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DER-ItAsn1-WriteSequence"><a href="#DER-ItAsn1-WriteSequence" class="headerlink" title="DER_ItAsn1_WriteSequence"></a>DER_ItAsn1_WriteSequence</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ITCAST_INT <span class="title function_">DER_ItAsn1_WriteSequence</span><span class="params">(ITASN1_SEQUENCE *pSequence, ITCAST_ANYBUF **ppDerSequence)</span>;</span><br></pre></td></tr></table></figure>

<p>函数说明: 序列化链表, <strong>将ITCAST_ANYBUF链表序列化成ITCAST_ANYBUF类型的字节流数据</strong><br>函数参数:<br>    <code>pSequence</code>: 输入参数, ITCAST_ANYBUF指针类型,待序列化的数据<br>    <code>ppDerSequence</code>: 输出参数, ITCAST_ANYBUF指针的指针类型, 序列化之后的数据</p>
<h4 id="DER-ItAsn1-ReadSequence"><a href="#DER-ItAsn1-ReadSequence" class="headerlink" title="DER_ItAsn1_ReadSequence"></a>DER_ItAsn1_ReadSequence</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ITCAST_INT <span class="title function_">DER_ItAsn1_ReadSequence</span><span class="params">(ITCAST_ANYBUF *pDerSequence, ITASN1_SEQUENCE **ppSequence)</span>;</span><br></pre></td></tr></table></figure>

<p>函数说明: 反序列化,<strong>将ITCAST_ANYBUF类型的字节流数据反序列化成ITCAST_ANYBUF链表</strong><br>参数说明:<br>    <code>pDerSequence</code>:输入参数, 开始需要将char *—&gt;ITCAST_ANYBUF类型<br>    <code>ppSequence</code>: 输出参数, 获得链表头节点</p>
<h4 id="DER-ITCAST-FreeQueue"><a href="#DER-ITCAST-FreeQueue" class="headerlink" title="DER_ITCAST_FreeQueue"></a>DER_ITCAST_FreeQueue</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ITCAST_INT <span class="title function_">DER_ITCAST_FreeQueue</span><span class="params">(ITCAST_ANYBUF *pAnyBuf)</span>;</span><br></pre></td></tr></table></figure>

<p>函数说明:释放内存</p>
<h3 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h3><h4 id="简单使用案例"><a href="#简单使用案例" class="headerlink" title="简单使用案例"></a>简单使用案例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;teacher.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;itcast_asn1_der.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">typedef struct _Teacher</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	char name[64];</span></span><br><span class="line"><span class="comment">	int age;</span></span><br><span class="line"><span class="comment">	char *p;</span></span><br><span class="line"><span class="comment">	long plen;</span></span><br><span class="line"><span class="comment">&#125;Teacher;</span></span><br><span class="line"><span class="comment">//在teacher.h中定义*/</span></span><br><span class="line"><span class="comment">//编码Teacher结构体</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">encodeTeacher</span><span class="params">(Teacher * p, <span class="type">char</span> ** outData, <span class="type">int</span> * outlen)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//编码name</span></span><br><span class="line">	ITCAST_ANYBUF *head = <span class="literal">NULL</span>;<span class="comment">//头结点</span></span><br><span class="line">	ITCAST_ANYBUF* temp = <span class="literal">NULL</span>;</span><br><span class="line">	ITCAST_ANYBUF* next = <span class="literal">NULL</span>;</span><br><span class="line">	DER_ITCAST_String_To_AnyBuf(&amp;temp,p-&gt;name,<span class="built_in">strlen</span>(p-&gt;name)+<span class="number">1</span>);<span class="comment">//只要传temp指针就可以,内部会malloc</span></span><br><span class="line">	DER_ItAsn1_WritePrintableString(temp,&amp;head);</span><br><span class="line">	DER_ITCAST_FreeQueue(temp);</span><br><span class="line">	next = head;</span><br><span class="line">	<span class="comment">//编码age</span></span><br><span class="line">	DER_ItAsn1_WriteInteger(p-&gt;age,&amp;next-&gt;next);</span><br><span class="line">	next=next-&gt;next;</span><br><span class="line">	<span class="comment">//编码p</span></span><br><span class="line">	EncodeChar(p-&gt;p,<span class="built_in">strlen</span>(p-&gt;p)+<span class="number">1</span>,&amp;next-&gt;next);</span><br><span class="line">	next=next-&gt;next;</span><br><span class="line">	<span class="comment">//编码plen</span></span><br><span class="line">	DER_ItAsn1_WriteInteger(p-&gt;plen,&amp;next-&gt;next);</span><br><span class="line">	<span class="comment">//序列化</span></span><br><span class="line">	DER_ItAsn1_WriteSequence(head,&amp;temp);</span><br><span class="line">	<span class="comment">//输出参数赋值</span></span><br><span class="line">	*outData = temp-&gt;pData;</span><br><span class="line">	*outlen = temp-&gt;dataLen;</span><br><span class="line">	<span class="comment">//释放内存</span></span><br><span class="line">	DER_ITCAST_FreeQueue(head);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解码Teacher结构体</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">decodeTeacher</span><span class="params">(<span class="type">char</span> * inData, <span class="type">int</span> inLen, Teacher ** p)</span></span><br><span class="line">&#123;</span><br><span class="line">	ITCAST_ANYBUF *head = <span class="literal">NULL</span>;<span class="comment">//头结点</span></span><br><span class="line">	ITCAST_ANYBUF* temp = <span class="literal">NULL</span>;</span><br><span class="line">	ITCAST_ANYBUF* next = <span class="literal">NULL</span>;</span><br><span class="line">	Teacher* pt = (Teacher *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Teacher));</span><br><span class="line">	<span class="comment">//将inData反序列化成链表</span></span><br><span class="line">		<span class="comment">//将char* --&gt; ITCAST_ANYBUF</span></span><br><span class="line">		DER_ITCAST_String_To_AnyBuf(&amp;temp,inData,inLen);</span><br><span class="line">	DER_ItAsn1_ReadSequence(temp,&amp;head);<span class="comment">//有疑问!!!!!!!!!!!!  此时得到head指向的链表</span></span><br><span class="line">	DER_ITCAST_FreeQueue(temp);</span><br><span class="line">	next = head;</span><br><span class="line">	<span class="comment">//解码name</span></span><br><span class="line">	DER_ItAsn1_ReadPrintableString(head,&amp;temp);</span><br><span class="line">	<span class="built_in">memcpy</span>(pt-&gt;name,temp-&gt;pData,temp-&gt;dataLen);</span><br><span class="line">	DER_ITCAST_FreeQueue(temp);</span><br><span class="line">	next = next-&gt;next;</span><br><span class="line">	<span class="comment">//解码age</span></span><br><span class="line">	DER_ItAsn1_ReadInteger(next,&amp;pt-&gt;age);</span><br><span class="line">	next = next-&gt;next;</span><br><span class="line">	<span class="comment">//解码p</span></span><br><span class="line">	<span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">	DecodeChar(next,&amp;pt-&gt;p,&amp;len);<span class="comment">//此处的pt中的p也要记得在freeTeacher中释放内存!</span></span><br><span class="line">	next=next-&gt;next;</span><br><span class="line">	<span class="comment">//解码plen</span></span><br><span class="line">	DER_ItAsn1_ReadInteger(next,&amp;pt-&gt;plen);</span><br><span class="line">	<span class="comment">//输出参数赋值</span></span><br><span class="line">	*p = pt;</span><br><span class="line">	<span class="comment">//释放内存</span></span><br><span class="line">	DER_ITCAST_FreeQueue(head);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeTeacher</span><span class="params">(Teacher ** p)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(*p!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>((*p)-&gt;p!= <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">free</span>((*p)-&gt;p);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">free</span>(*p);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;teacher.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world!\n&quot;</span>);</span><br><span class="line">    <span class="comment">/* code */</span></span><br><span class="line">    Teacher t;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;t,<span class="number">0</span>,<span class="keyword">sizeof</span>(t));</span><br><span class="line">    <span class="built_in">strcpy</span>(t.name,<span class="string">&quot;路飞&quot;</span>);</span><br><span class="line">    t.age = <span class="number">20</span>;</span><br><span class="line">    t.p = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(t.p,<span class="string">&quot;我是要成为海贼王的男人&quot;</span>);</span><br><span class="line">    t.plen = <span class="built_in">strlen</span>(t.p);</span><br><span class="line">    <span class="comment">//编码</span></span><br><span class="line">    <span class="type">char</span> *outData;</span><br><span class="line">    <span class="type">int</span> outLen;</span><br><span class="line">    encodeTeacher(&amp;t,&amp;outData,&amp;outLen);</span><br><span class="line">    <span class="comment">//==========================省去了发送流程</span></span><br><span class="line">    <span class="comment">//直接解码</span></span><br><span class="line">    Teacher* pt;</span><br><span class="line">    decodeTeacher(outData,outLen,&amp;pt);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name:  %s\n&quot;</span>,pt-&gt;name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;age:  %d\n&quot;</span>,pt-&gt;age);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p:  %s\n&quot;</span>,pt-&gt;p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;plen:  %d\n&quot;</span>,pt-&gt;plen);</span><br><span class="line">    freeTeacher(&amp;pt);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202306101457657.png" alt="image-20230210173019307" style="zoom: 50%;" />

<h4 id="进一步封装"><a href="#进一步封装" class="headerlink" title="进一步封装"></a>进一步封装</h4><p>封装uml图如下:</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202302201320179.jpeg" alt="ASN.1 编解码- 类图jpg_Page1"  />

<p>其中的SequenceASN1部分:</p>
<h6 id="SequenceASN1-h"><a href="#SequenceASN1-h" class="headerlink" title="SequenceASN1.h"></a>SequenceASN1.h</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ASN1DER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ASN1DER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;BaseASN1.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SequenceASN1</span>  :</span> public BaseASN1</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    SequenceASN1();</span><br><span class="line">    <span class="comment">// 添加头结点</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">writeHeadNode</span><span class="params">(<span class="type">int</span> iValue)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">writeHeadNode</span><span class="params">(<span class="type">char</span>* sValue, <span class="type">int</span> len)</span>;</span><br><span class="line">    <span class="comment">// 添加后继结点</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">writeNextNode</span><span class="params">(<span class="type">int</span> iValue)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">writeNextNode</span><span class="params">(<span class="type">char</span>* sValue, <span class="type">int</span> len)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读头结点数据</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">readHeadNode</span><span class="params">(<span class="type">int</span> &amp;iValue)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">readHeadNode</span><span class="params">(<span class="type">char</span>* sValue)</span>;</span><br><span class="line">    <span class="comment">// 读后继结点数据</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">readNextNode</span><span class="params">(<span class="type">int</span> &amp;iValue)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">readNextNode</span><span class="params">(<span class="type">char</span>* sValue)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打包链表</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">packSequence</span><span class="params">(<span class="type">char</span>** outData, <span class="type">int</span> &amp;outLen)</span>;</span><br><span class="line">    <span class="comment">// 解包链表</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">unpackSequence</span><span class="params">(<span class="type">char</span>* inData, <span class="type">int</span> inLen)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放链表</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">freeSequence</span><span class="params">(ITCAST_ANYBUF* node = <span class="literal">NULL</span>)</span>;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    ITCAST_ANYBUF* m_header = <span class="literal">NULL</span>;</span><br><span class="line">	ITCAST_ANYBUF* m_next   = <span class="literal">NULL</span>;</span><br><span class="line">	ITCAST_ANYBUF* m_temp   = <span class="literal">NULL</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// ASN1DER_H</span></span></span><br></pre></td></tr></table></figure>

<h6 id="SequenceASN1-cpp"><a href="#SequenceASN1-cpp" class="headerlink" title="SequenceASN1.cpp"></a>SequenceASN1.cpp</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SequenceASN1.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">SequenceASN1::<span class="built_in">SequenceASN1</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SequenceASN1::writeHeadNode</span><span class="params">(<span class="type">int</span> iValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">DER_ItAsn1_WriteInteger</span>(iValue,&amp;m_header);</span><br><span class="line">    m_next=m_header;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SequenceASN1::writeHeadNode</span><span class="params">(<span class="type">char</span> *sValue, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">EncodeChar</span>(sValue,len,&amp;m_header);</span><br><span class="line">    m_next=m_header;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SequenceASN1::writeNextNode</span><span class="params">(<span class="type">int</span> iValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="built_in">DER_ItAsn1_WriteInteger</span>(iValue,&amp;m_next-&gt;next);</span><br><span class="line">    m_next=m_next-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SequenceASN1::writeNextNode</span><span class="params">(<span class="type">char</span> *sValue, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">EncodeChar</span>(sValue,len,&amp;m_next-&gt;next);</span><br><span class="line">    m_next=m_next-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SequenceASN1::readHeadNode</span><span class="params">(<span class="type">int</span> &amp;iValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">DER_ItAsn1_ReadInteger</span>(m_header,(ITCAST_UINT32*)&amp;iValue);</span><br><span class="line">    m_next = m_header-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SequenceASN1::readHeadNode</span><span class="params">(<span class="type">char</span>* sValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// DER_ITCAST_String_To_AnyBuf(&amp;m_temp,(unsigned char*)sValue,strlen(sValue)+1);</span></span><br><span class="line">    <span class="comment">// DER_ItAsn1_ReadPrintableString(m_temp,&amp;m_header);</span></span><br><span class="line">    <span class="comment">// DER_ITCAST_FreeQueue(m_temp);</span></span><br><span class="line">    <span class="comment">// m_next = m_header;</span></span><br><span class="line">    <span class="built_in">DER_ItAsn1_ReadPrintableString</span>(m_header,&amp;m_temp);</span><br><span class="line">    <span class="built_in">memcpy</span>(sValue,m_temp-&gt;pData,m_temp-&gt;dataLen);</span><br><span class="line">    <span class="built_in">DER_ITCAST_FreeQueue</span>(m_temp);</span><br><span class="line">    m_next = m_header-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SequenceASN1::readNextNode</span><span class="params">(<span class="type">int</span> &amp;iValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret =<span class="built_in">DER_ItAsn1_ReadInteger</span>(m_next,(ITCAST_UINT32*)&amp;iValue);</span><br><span class="line">    <span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    m_next = m_next-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SequenceASN1::readNextNode</span><span class="params">(<span class="type">char</span> *sValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// DER_ITCAST_String_To_AnyBuf(&amp;m_temp,(unsigned char*)sValue,strlen(sValue)+1);</span></span><br><span class="line">    <span class="comment">// DER_ItAsn1_ReadPrintableString(m_temp,&amp;m_next);</span></span><br><span class="line">    <span class="comment">//  DER_ITCAST_FreeQueue(m_temp);</span></span><br><span class="line">    <span class="comment">// m_next = m_next-&gt;next;</span></span><br><span class="line">    <span class="type">int</span> ret =<span class="built_in">DER_ItAsn1_ReadPrintableString</span>(m_next,&amp;m_temp);<span class="comment">//这句有问题,未能解决!!!!!!!</span></span><br><span class="line">    <span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    <span class="built_in">memcpy</span>(sValue,m_temp-&gt;pData,m_temp-&gt;dataLen);</span><br><span class="line">    <span class="built_in">DER_ITCAST_FreeQueue</span>(m_temp);</span><br><span class="line">    m_next = m_next-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SequenceASN1::packSequence</span><span class="params">(<span class="type">char</span> **outData, <span class="type">int</span> &amp;outLen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">DER_ItAsn1_WriteSequence</span>(m_header,&amp;m_temp);</span><br><span class="line">    outLen = m_temp-&gt;dataLen;</span><br><span class="line">    *outData = (<span class="type">char</span>*)m_temp-&gt;pData;</span><br><span class="line">    <span class="built_in">DER_ITCAST_FreeQueue</span>(m_header);<span class="comment">//释放m_header</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SequenceASN1::unpackSequence</span><span class="params">(<span class="type">char</span> *inData, <span class="type">int</span> inLen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">DER_ITCAST_String_To_AnyBuf</span>(&amp;m_temp,(<span class="type">unsigned</span> <span class="type">char</span>*)inData,inLen);</span><br><span class="line">    <span class="built_in">DER_ItAsn1_ReadSequence</span>(m_temp,&amp;m_header);</span><br><span class="line">    <span class="built_in">DER_ITCAST_FreeQueue</span>(m_temp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SequenceASN1::freeSequence</span><span class="params">(ITCAST_ANYBUF *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="CSharp网络通信"><a href="#CSharp网络通信" class="headerlink" title="CSharp网络通信"></a>CSharp网络通信</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wenchm/article/details/134785346">学习参考链接</a></p>
<p>主要是下面几种方式,它们都位于System.Net.Sockets命名空间中</p>
<ul>
<li><a href="#Socket">Socket</a></li>
<li><a href="#TcpClient/TcpListener">TcpClient 和 TcpListener</a></li>
<li>UdpClient 和 UdpListene</li>
</ul>
<p><code>IPAddress</code> 是 .NET 中的一个类，属于 <code>System.Net</code> 命名空间。</p>
<ul>
<li><p><strong>类型</strong>：<code>IPAddress</code> 是一个结构（struct），用于表示 IPv4 或 IPv6 地址。</p>
</li>
<li><p><strong>用途</strong>：它提供了处理 IP 地址的功能，例如解析字符串形式的 IP 地址、比较 IP 地址、获取地址的字节表示等。</p>
<p><strong>IPEndPoint</strong>: 表示一个网络端点，它结合了一个 IP 地址和一个端口号。</p>
</li>
</ul>
<h2 id="TcpClient-TcpListener"><a href="#TcpClient-TcpListener" class="headerlink" title="TcpClient&#x2F;TcpListener"></a>TcpClient&#x2F;TcpListener</h2><p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/fundamentals/networking/sockets/tcp-classes">官方文档参考</a></p>
<h3 id="TcpClient"><a href="#TcpClient" class="headerlink" title="TcpClient"></a>TcpClient</h3><table>
<thead>
<tr>
<th>属性及方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Available属性</td>
<td>获取已经从网络接收且可供读取的数据量</td>
</tr>
<tr>
<td>Client属性</td>
<td>获取或设置基础Socket</td>
</tr>
<tr>
<td>Connected属性</td>
<td>获取一个值，该值指示TepClient的基础Socket是否已连接到远程主机</td>
</tr>
<tr>
<td>RecieveBufferSize属性</td>
<td>获取或设置接收缓冲区的大小</td>
</tr>
<tr>
<td>RecieveTimeout属性</td>
<td>获取或设置在初始化一个读取操作后TcpClient等待接收数据的时间量</td>
</tr>
<tr>
<td>SendBufferSize属性</td>
<td>获取或设置发送缓冲区的大小</td>
</tr>
<tr>
<td>SendTimeout属性</td>
<td>获取或设置TcpClient等待发送操作成功完成的时间量</td>
</tr>
<tr>
<td>BeginConnect方法</td>
<td>开始一个对远程主机连接的异步请求</td>
</tr>
<tr>
<td>Close方法</td>
<td>释放此TcpClient实例，而不关闭基础连接</td>
</tr>
<tr>
<td>Connec方法</td>
<td>使用指定的主机名和端口号将客户端连接到TCP主机</td>
</tr>
<tr>
<td>EndConnect方法</td>
<td>异步接受传入的连接尝试</td>
</tr>
<tr>
<td>GetStream方法</td>
<td>返回用于发送和接收数据的NetworkStream</td>
</tr>
</tbody></table>
<h3 id="TcpListener"><a href="#TcpListener" class="headerlink" title="TcpListener"></a>TcpListener</h3><table>
<thead>
<tr>
<th><strong>属性及方法</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>LocalEndpoint属性</td>
<td>获取当前TcpListener的基础EndPoint</td>
</tr>
<tr>
<td>Server属性</td>
<td>获取基础网络Socket</td>
</tr>
<tr>
<td>AcceptSocket&#x2F;AcceptTcpClient方法</td>
<td>接受挂起的连接请求</td>
</tr>
<tr>
<td>BeginAcceptSocket&#x2F;BeginAcceptTcpClient方法</td>
<td>开始一个异步操作来接受一个传入的连接尝试</td>
</tr>
<tr>
<td>EndAcceptSocket方法</td>
<td>异步接受传入的连接尝试，并创建新的Socket来处理远程主机通信</td>
</tr>
<tr>
<td>EndAcceptTcpClient方法</td>
<td>异步接受传入的连接尝试，并创建新的TcpClient来处理远程主机通信</td>
</tr>
<tr>
<td>Start方法</td>
<td>开始侦听传入的连接请求</td>
</tr>
<tr>
<td>Stop方法</td>
<td>关闭侦听器</td>
</tr>
</tbody></table>
<h3 id="案例-3"><a href="#案例-3" class="headerlink" title="案例"></a>案例</h3><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Server</span></span><br><span class="line"><span class="comment">// .NET 8.0控制台应用</span></span><br><span class="line"><span class="keyword">using</span> System.Net;</span><br><span class="line"><span class="keyword">using</span> System.Net.Sockets;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> _<span class="title">Server</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> port = <span class="number">888</span>;</span><br><span class="line">            TcpClient tcpClient;</span><br><span class="line">            IPAddress[] serverIP = Dns.GetHostAddresses(<span class="string">&quot;127.0.0.1&quot;</span>);   <span class="comment">//定义IP地址</span></span><br><span class="line">            IPAddress localAddress = serverIP[<span class="number">0</span>];                       <span class="comment">//IP地址  </span></span><br><span class="line">            TcpListener tcpListener = <span class="keyword">new</span>(localAddress, port);          <span class="comment">//监听套接字</span></span><br><span class="line">            tcpListener.Start();                                                                                </span><br><span class="line">                                                                        <span class="comment">//开始监听  </span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;服务器启动成功，等待用户接入…&quot;</span>);            <span class="comment">//输出消息  </span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    tcpClient = tcpListener.AcceptTcpClient();          <span class="comment">//每接收一个客户端则生成一个TcpClient  </span></span><br><span class="line">                    NetworkStream networkStream = tcpClient.GetStream();<span class="comment">//获取网络数据流</span></span><br><span class="line">                    BinaryReader reader = <span class="keyword">new</span>(networkStream);           <span class="comment">//定义流数据读取对象</span></span><br><span class="line">                    BinaryWriter writer = <span class="keyword">new</span>(networkStream);           <span class="comment">//定义流数据写入对象</span></span><br><span class="line">                    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">try</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="built_in">string</span> strReader = reader.ReadString();      <span class="comment">//接收消息</span></span><br><span class="line">                            <span class="built_in">string</span>[] strReaders = strReader.Split([<span class="string">&#x27; &#x27;</span>]);<span class="comment">//截取客户端消息</span></span><br><span class="line">                            Console.WriteLine(<span class="string">&quot;有客户端接入，客户IP：&quot;</span> + strReaders[<span class="number">0</span>]);  <span class="comment">//输出接收的客户端IP地址  </span></span><br><span class="line">                            Console.WriteLine(<span class="string">&quot;来自客户端的消息：&quot;</span> + strReaders[<span class="number">1</span>]);        <span class="comment">//输出接收的消息  </span></span><br><span class="line">                            <span class="built_in">string</span> strWriter = <span class="string">&quot;我是服务器，欢迎光临&quot;</span>;    <span class="comment">//定义服务端要写入的消息</span></span><br><span class="line">                            writer.Write(strWriter);                    <span class="comment">//向对方发送消息  </span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">catch</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="客户端-2"><a href="#客户端-2" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Client</span></span><br><span class="line"><span class="comment">// .NET 8.0控制台应用</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Net;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> System.Net.Sockets;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> _<span class="title">Client</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            TcpClient tcpClient = <span class="keyword">new</span>();          <span class="comment">//创建一个TcpClient对象，自动分配主机IP地址和端口号  </span></span><br><span class="line">            tcpClient.Connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">888</span>);  <span class="comment">//连接服务器，其IP和端口号为127.0.0.1和888  </span></span><br><span class="line">            <span class="keyword">if</span> (tcpClient != <span class="literal">null</span>)                <span class="comment">//判断是否连接成功</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;连接服务器成功&quot;</span>);</span><br><span class="line">                NetworkStream networkStream = tcpClient.GetStream();  <span class="comment">//获取数据流</span></span><br><span class="line">                BinaryReader reader = <span class="keyword">new</span>(networkStream);             <span class="comment">//定义流数据读取对象</span></span><br><span class="line">                BinaryWriter writer = <span class="keyword">new</span>(networkStream);             <span class="comment">//定义流数据写入对象</span></span><br><span class="line">                <span class="built_in">string</span> localip = <span class="string">&quot;127.0.0.1&quot;</span>;                                               <span class="comment">//存储本机IP，默认值为127.0.0.1</span></span><br><span class="line">                IPAddress[] ips = Dns.GetHostAddresses(Dns.GetHostName());<span class="comment">//获取所有IP地址</span></span><br><span class="line">                <span class="keyword">foreach</span> (IPAddress ip <span class="keyword">in</span> ips)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!ip.IsIPv6SiteLocal)         <span class="comment">//如果不是IPV6地址</span></span><br><span class="line">                        localip = ip.ToString();     <span class="comment">//获取本机IP地址</span></span><br><span class="line">                &#125;</span><br><span class="line">                writer.Write(localip + <span class="string">&quot; 你好服务器，我是客户端&quot;</span>);    <span class="comment">//向服务器发送消息  </span></span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">try</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">string</span> strReader = reader.ReadString();     <span class="comment">//接收服务器发送的数据  </span></span><br><span class="line">                        <span class="keyword">if</span> (strReader != <span class="literal">null</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            Console.WriteLine(<span class="string">&quot;来自服务器的消息：&quot;</span> + strReader);<span class="comment">//输出接收的服务器消息</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">break</span>;                          <span class="comment">//接收过程中如果出现异常，退出循环  </span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;连接服务器失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h4 id="二进制读写"><a href="#二进制读写" class="headerlink" title="二进制读写"></a>二进制读写</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//reader和writer与上面定义一致</span></span><br><span class="line"><span class="comment">// 读取二进制数据</span></span><br><span class="line"><span class="built_in">byte</span>[] buffer = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">4</span>]; <span class="comment">// 假设我们期望接收4个字节（例如一个整数）</span></span><br><span class="line"><span class="built_in">int</span> bytesRead = reader.Read(buffer, <span class="number">0</span>, buffer.Length); <span class="comment">// 读取二进制数据</span></span><br><span class="line"><span class="keyword">if</span> (bytesRead &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> receivedNumber = BitConverter.ToInt32(buffer, <span class="number">0</span>); <span class="comment">// 将字节数组转换为整数</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;来自服务器的消息：接收到的整数是 &quot;</span> + receivedNumber);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 发送二进制数据</span></span><br><span class="line"><span class="built_in">byte</span>[] dataToSend = BitConverter.GetBytes(<span class="number">12345</span>); <span class="comment">// 示例：发送一个整数的二进制表示</span></span><br><span class="line">writer.Write(dataToSend); <span class="comment">// 发送二进制数据</span></span><br></pre></td></tr></table></figure>

<h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/fundamentals/networking/sockets/socket-services">官方文档参考</a></p>
<p>Socket的优势:</p>
<ul>
<li>协议不仅支持 TCP，还可以处理其他协议，如 UDP、ICMP 等</li>
<li>更精细度的资源管理,如可以直接处理底层的协议、套接字选项（如缓冲区大小、超时设置等）</li>
<li>支持更完整的异步操作,可以使用 BeginConnect、EndConnect、BeginReceive、EndReceive 等方法实现非阻塞的网络通信</li>
<li>更强的自定义能力,如可以直接控制连接的建立、数据传输等过程，支持更多高级特性，比如多播、广播、TCP 队列控制等</li>
</ul>
<h3 id="常用属性及说明"><a href="#常用属性及说明" class="headerlink" title="常用属性及说明"></a>常用属性及说明</h3><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>AddressFamily</td>
<td>获取Socket的地址族</td>
</tr>
<tr>
<td>Availabe</td>
<td>获取已经从网络接收且可供读取的数据量</td>
</tr>
<tr>
<td>Connected</td>
<td>获取一个值，该值指示Socket是在上次Send还是Receive操作时连接到远程主机</td>
</tr>
<tr>
<td>Handle</td>
<td>获取Socket的操作系统句柄</td>
</tr>
<tr>
<td>LocalEndPoint</td>
<td>获取本地终结点</td>
</tr>
<tr>
<td>ProtocolType</td>
<td>获取Socket的协议类型</td>
</tr>
<tr>
<td>RemoteEndPoint</td>
<td>获取远程终结点</td>
</tr>
<tr>
<td>SendTimeout</td>
<td>获取或设置一个值，该值指定之后同步Send调用将超时的时间长度</td>
</tr>
</tbody></table>
<h3 id="常用方法及说明"><a href="#常用方法及说明" class="headerlink" title="常用方法及说明"></a>常用方法及说明</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Accept</td>
<td>为新建连接创建新的Socket</td>
</tr>
<tr>
<td>BeginAccept</td>
<td>开始一个异步操作来接受一个传入的连接尝试</td>
</tr>
<tr>
<td>BeginConnect</td>
<td>开始一个对远程主机连接的异步请求</td>
</tr>
<tr>
<td>BeginDisconnect</td>
<td>开始异步请求从远程终结点断开连接</td>
</tr>
<tr>
<td>BeginReceive</td>
<td>开始从连接的Socket中异步接收数据</td>
</tr>
<tr>
<td>BeginSend</td>
<td>将数据异步发送到连接的Socket</td>
</tr>
<tr>
<td>BeginSendFile</td>
<td>将文件异步发送到连接的Socket</td>
</tr>
<tr>
<td>BeginSendTo</td>
<td>向特定远程主机异步发送数据</td>
</tr>
<tr>
<td>Close</td>
<td>关闭Socket连接并释放所有关联的资源</td>
</tr>
<tr>
<td>Connect</td>
<td>建立与远程主机的连接</td>
</tr>
<tr>
<td>Disconnect</td>
<td>关闭套接字连接并允许重用套接字</td>
</tr>
<tr>
<td>EndAccept</td>
<td>异步接受传入的连接尝试</td>
</tr>
<tr>
<td>EndConnect</td>
<td>结束挂起的异步连接请求</td>
</tr>
<tr>
<td>EndDisconnect</td>
<td>结束挂起的异步断开连接请求</td>
</tr>
<tr>
<td>EndReceive</td>
<td>结束挂起的异步读取</td>
</tr>
<tr>
<td>EndSend</td>
<td>结束挂起的异步发送</td>
</tr>
<tr>
<td>EndSendFile</td>
<td>结束文件的挂起异步发送</td>
</tr>
<tr>
<td>EndSendTo</td>
<td>结束挂起的、向指定位置进行的异步发送</td>
</tr>
<tr>
<td>Listen</td>
<td>将Socket置于侦听状态</td>
</tr>
<tr>
<td>Receive</td>
<td>接收来自绑定的Socket的数据</td>
</tr>
<tr>
<td>Send</td>
<td>将数据发送到连接的Socket</td>
</tr>
<tr>
<td>SendFile</td>
<td>将文件和可选数据异步发送到连接的Socket</td>
</tr>
<tr>
<td>SendTo</td>
<td>将数据发送到特定终结点</td>
</tr>
<tr>
<td>Shutdown</td>
<td>禁用某Socket上的发送和接收</td>
</tr>
</tbody></table>
<h3 id="案例-4"><a href="#案例-4" class="headerlink" title="案例"></a>案例</h3><h4 id="客户端-3"><a href="#客户端-3" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Socket client = <span class="keyword">new</span>(</span><br><span class="line">    ipEndPoint.AddressFamily, </span><br><span class="line">    SocketType.Stream, </span><br><span class="line">    ProtocolType.Tcp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> client.ConnectAsync(ipEndPoint);</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Send message.</span></span><br><span class="line">    <span class="keyword">var</span> message = <span class="string">&quot;Hi friends 👋!&lt;|EOM|&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> messageBytes = Encoding.UTF8.GetBytes(message);</span><br><span class="line">    _ = <span class="keyword">await</span> client.SendAsync(messageBytes, SocketFlags.None);</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;Socket client sent message: \&quot;<span class="subst">&#123;message&#125;</span>\&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Receive ack.</span></span><br><span class="line">    <span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">1</span>_024];</span><br><span class="line">    <span class="keyword">var</span> received = <span class="keyword">await</span> client.ReceiveAsync(buffer, SocketFlags.None);</span><br><span class="line">    <span class="keyword">var</span> response = Encoding.UTF8.GetString(buffer, <span class="number">0</span>, received);</span><br><span class="line">    <span class="keyword">if</span> (response == <span class="string">&quot;&lt;|ACK|&gt;&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(</span><br><span class="line">            <span class="string">$&quot;Socket client received acknowledgment: \&quot;<span class="subst">&#123;response&#125;</span>\&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Sample output:</span></span><br><span class="line">    <span class="comment">//     Socket client sent message: &quot;Hi friends 👋!&lt;|EOM|&gt;&quot;</span></span><br><span class="line">    <span class="comment">//     Socket client received acknowledgment: &quot;&lt;|ACK|&gt;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">client.Shutdown(SocketShutdown.Both);</span><br></pre></td></tr></table></figure>

<h4 id="服务器-2"><a href="#服务器-2" class="headerlink" title="服务器"></a>服务器</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Socket listener = <span class="keyword">new</span>(</span><br><span class="line">    ipEndPoint.AddressFamily,</span><br><span class="line">    SocketType.Stream,</span><br><span class="line">    ProtocolType.Tcp);</span><br><span class="line"></span><br><span class="line">listener.Bind(ipEndPoint);</span><br><span class="line">listener.Listen(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> handler = <span class="keyword">await</span> listener.AcceptAsync();</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Receive message.</span></span><br><span class="line">    <span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">1</span>_024];</span><br><span class="line">    <span class="keyword">var</span> received = <span class="keyword">await</span> handler.ReceiveAsync(buffer, SocketFlags.None);</span><br><span class="line">    <span class="keyword">var</span> response = Encoding.UTF8.GetString(buffer, <span class="number">0</span>, received);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> eom = <span class="string">&quot;&lt;|EOM|&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (response.IndexOf(eom) &gt; <span class="number">-1</span> <span class="comment">/* is end of message */</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(</span><br><span class="line">            <span class="string">$&quot;Socket server received message: \&quot;<span class="subst">&#123;response.Replace(eom, <span class="string">&quot;&quot;</span>)&#125;</span>\&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> ackMessage = <span class="string">&quot;&lt;|ACK|&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">var</span> echoBytes = Encoding.UTF8.GetBytes(ackMessage);</span><br><span class="line">        <span class="keyword">await</span> handler.SendAsync(echoBytes, <span class="number">0</span>);</span><br><span class="line">        Console.WriteLine(</span><br><span class="line">            <span class="string">$&quot;Socket server sent acknowledgment: \&quot;<span class="subst">&#123;ackMessage&#125;</span>\&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Sample output:</span></span><br><span class="line">    <span class="comment">//    Socket server received message: &quot;Hi friends 👋!&quot;</span></span><br><span class="line">    <span class="comment">//    Socket server sent acknowledgment: &quot;&lt;|ACK|&gt;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="常用网络相关命令"><a href="#常用网络相关命令" class="headerlink" title="常用网络相关命令"></a>常用网络相关命令</h1><p><code>sudo lsof -i:端口号</code> 查询端口占用</p>
<p>windows排查端口占用:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">通过端口号查找占用的进程的pid</span></span><br><span class="line">netstat -ano | findstr :需要查的端口号</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">通过pid查进程名称,也可以直接打开任务管理器详细信息窗口查看</span></span><br><span class="line">tasklist | findstr &lt;PID&gt;</span><br></pre></td></tr></table></figure>

<p>windows用于ping测试ip地址的脚本</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">for /L %%i in (2,1,255) do (</span><br><span class="line">    ping -n 1 192.168.1.%%i | find &quot;TTL=&quot; &gt;nul &amp;&amp; echo 192.168.1.%%i 连通 || echo 192.168.1.%%i 不通</span><br><span class="line">)</span><br><span class="line">pause</span><br></pre></td></tr></table></figure>

<h1 id="UDP打洞"><a href="#UDP打洞" class="headerlink" title="UDP打洞"></a>UDP打洞</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/fjh1997/article/details/87969274">点击跳转</a></p>
<h1 id="域名相关"><a href="#域名相关" class="headerlink" title="域名相关"></a>域名相关</h1><h2 id="托管域名"><a href="#托管域名" class="headerlink" title="托管域名"></a>托管域名</h2><p><strong>托管域名（Domain Hosting）</strong>是指将已注册域名的管理权委托给专业的第三方服务商，由其负责域名的解析、维护和技术支持，使用户无需自行处理复杂的DNS配置 ,其核心功能包括:</p>
<ul>
<li><strong>域名解析管理</strong>：将域名转换为对应的IP地址，确保用户通过域名访问网站时能正确指向服务器</li>
<li><strong>DNS记录维护</strong>：管理A记录（指向IP地址）、MX记录（邮件服务器）、CNAME记录（别名）等，支持灵活配置</li>
<li><strong>安全与稳定性保障</strong>：通过DNSSEC（DNS安全扩展）、DDoS防护等措施防止域名劫持或攻击，确保服务高可用</li>
<li><strong>自动化服务</strong>：提供域名续费提醒、备份恢复等，减少人工操作成本</li>
</ul>
<blockquote>
<p><strong>NS记录的定义与作用</strong></p>
<p>NS（Name Server）记录是DNS系统中的一种资源记录，用于指定负责解析域名的权威DNS服务器 ,其核心功能包括：</p>
<ol>
<li><strong>授权解析权</strong>：明确域名由哪些DNS服务器管理（如<code>ns1.cloudflare.com</code>），指导用户请求的查询路径</li>
<li><strong>冗余与负载均衡</strong>：支持配置多个NS记录，当主服务器故障时，备用服务器可接管，保障解析不中断</li>
<li><strong>子域名管理</strong>：若子域名需独立解析（如<code>blog.example.com</code>），可通过NS记录指向其他DNS服务商</li>
</ol>
<p><strong>示例</strong>：若域名使用Cloudflare的DNS服务，则需在注册商处设置NS记录为 <code>ns1.cloudflare.com</code> 和 <code>ns2.cloudflare.com</code>，此后所有DNS查询由Cloudflare处理</p>
</blockquote>
<h2 id="DNSChecker"><a href="#DNSChecker" class="headerlink" title="DNSChecker"></a>DNSChecker</h2><p><strong>全球DNS解析检测与诊断工具</strong>,主要用于验证域名解析记录的全球传播状态、检查DNS配置准确性，并提供多种网络诊断功能。以下是其核心功能与使用场景的详细解析</p>
<p>免费且跨平台</p>
<p><a target="_blank" rel="noopener" href="https://dnschecker.org/">基于该工具的DNS记录查询网站</a></p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4" title="头像" alt="头像"></a><div class="post-copyright__author_name">ZEROKO14</div><div class="post-copyright__author_desc">zeroko14's blog</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://che77a38.github.io/posts/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://che77a38.github.io/posts/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/')">网络编程</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://che77a38.github.io/posts/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=网络编程&amp;url=https://che77a38.github.io/posts/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://che77a38.github.io" target="_blank">ZEROKO14的个人博客</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E7%BD%91%E7%BB%9C/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>网络<span class="tagsPageCount">3</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">数据库</div></div></a></div><div class="next-post pull-right"><a href="/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">设计模式</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/posts/nginx/" title="nginx"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-11-24</div><div class="title">nginx</div></div></a></div><div><a href="/posts/%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/" title="网络架构"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-11-18</div><div class="title">网络架构</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description">欢迎来到ZEROKO14的个人博客</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">ZEROKO14</h1><div class="author-info__desc">zeroko14's blog</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/che77a38" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">网络基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">分层模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82OSI-7%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">网络分层OSI 7层模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-IP-4%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">TCP&#x2F;IP  4层模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-IP%E5%8D%8F%E8%AE%AE%E5%88%86%E5%B1%82%E9%80%9A%E8%AE%AF%E5%85%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">1.1.3.</span> <span class="toc-text">TCP&#x2F;IP协议分层通讯全过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.2.</span> <span class="toc-text">协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E5%90%8D%E8%AF%8D"><span class="toc-number">1.3.</span> <span class="toc-text">网络相关名词</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E7%9B%B8%E5%85%B3"><span class="toc-number">1.3.0.1.</span> <span class="toc-text">设备相关</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.0.1.1.</span> <span class="toc-text">以太网交换机工作原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E8%A1%A8-Routing-Table"><span class="toc-number">1.3.0.1.2.</span> <span class="toc-text">路由表(Routing Table)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E6%9D%A1%E7%9B%AE"><span class="toc-number">1.3.0.1.3.</span> <span class="toc-text">路由条目</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%9C%81%E8%B7%AF%E7%94%B1%E6%9D%A1%E7%9B%AE"><span class="toc-number">1.3.0.1.4.</span> <span class="toc-text">缺省路由条目</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.0.1.5.</span> <span class="toc-text">路由器工作原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%90%8D%E8%AF%8D"><span class="toc-number">1.3.1.</span> <span class="toc-text">其他名词</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8A%E5%8F%8C%E5%B7%A5-%E5%85%A8%E5%8F%8C%E5%B7%A5"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">半双工&#x2F;全双工</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DNS%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">DNS服务器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#windows%E4%B8%8B%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9hosts%E6%96%87%E4%BB%B6"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">windows下如何修改hosts文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E5%9F%9F%E7%BD%91-LAN"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">局域网(LAN)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%BF%E5%9F%9F%E7%BD%91-WAN"><span class="toc-number">1.3.1.5.</span> <span class="toc-text">广域网(WAN)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MTU"><span class="toc-number">1.3.1.6.</span> <span class="toc-text">MTU</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="toc-number">1.4.</span> <span class="toc-text">网络相关命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.5.</span> <span class="toc-text">网络程序的设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C-S%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.5.1.</span> <span class="toc-text">C&#x2F;S设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-S%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.5.2.</span> <span class="toc-text">B&#x2F;S设计模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcp%E5%8E%9F%E7%90%86"><span class="toc-number">1.6.</span> <span class="toc-text">tcp原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">1.6.1.</span> <span class="toc-text">三次握手四次挥手</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">建立三次握手的过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">数据传输的过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5%EF%BC%88%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%89%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">1.6.1.3.</span> <span class="toc-text">关闭连接（四次挥手）的过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcp%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.6.2.</span> <span class="toc-text">tcp状态转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">1.6.3.</span> <span class="toc-text">滑动窗口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mss%E5%92%8CMTU%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.6.4.</span> <span class="toc-text">mss和MTU的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.7.</span> <span class="toc-text">以太网帧格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ARP%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.7.1.</span> <span class="toc-text">ARP数据报格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%93%E5%8C%85%E5%91%BD%E4%BB%A4"><span class="toc-number">1.7.2.</span> <span class="toc-text">抓包命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IP%E6%AE%B5%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.7.3.</span> <span class="toc-text">IP段格式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ip%E5%88%86%E7%89%87"><span class="toc-number">1.7.3.1.</span> <span class="toc-text">ip分片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E6%9C%BA%E5%88%B6"><span class="toc-number">1.7.3.2.</span> <span class="toc-text">路由机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IPv6"><span class="toc-number">1.7.3.3.</span> <span class="toc-text">IPv6</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.7.4.</span> <span class="toc-text">UDP数据报格式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#UDP%E5%A4%B4%E9%83%A8%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.7.4.1.</span> <span class="toc-text">UDP头部格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#udp%E8%BF%9E%E6%8E%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">1.7.4.2.</span> <span class="toc-text">udp连接机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E6%95%B0%E6%8D%AE%E6%B5%81%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.7.5.</span> <span class="toc-text">TCP数据流格式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#tcp%E5%A4%B4%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.7.5.1.</span> <span class="toc-text">tcp头部结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E9%80%89%E9%A1%B9%E7%BB%93%E6%9E%84"><span class="toc-number">1.7.5.1.1.</span> <span class="toc-text">典型选项结构</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E8%BF%9E%E6%8E%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">1.7.5.2.</span> <span class="toc-text">TCP连接机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ip%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.8.</span> <span class="toc-text">ip地址转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#inet-pton%E5%87%BD%E6%95%B0"><span class="toc-number">1.8.1.</span> <span class="toc-text">inet_pton函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#inet-ntop%E5%87%BD%E6%95%B0"><span class="toc-number">1.8.2.</span> <span class="toc-text">inet_ntop函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="toc-number">1.9.</span> <span class="toc-text">网络字节序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E5%B0%8F%E7%AB%AF%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.9.1.</span> <span class="toc-text">大小端转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5"><span class="toc-number">1.10.</span> <span class="toc-text">同步与异步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="toc-number">1.11.</span> <span class="toc-text">阻塞与非阻塞</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DNS%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="toc-number">1.12.</span> <span class="toc-text">DNS解析过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#URL%E5%92%8CURN"><span class="toc-number">1.13.</span> <span class="toc-text">URL和URN</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E5%90%91-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86"><span class="toc-number">1.14.</span> <span class="toc-text">正向&#x2F;反向代理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86"><span class="toc-number">1.14.1.</span> <span class="toc-text">正向代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86"><span class="toc-number">1.14.2.</span> <span class="toc-text">反向代理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E7%9B%97%E9%93%BE"><span class="toc-number">1.15.</span> <span class="toc-text">防盗链</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#socket%E7%BC%96%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">socket编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">2.1.</span> <span class="toc-text">相关结构体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.</span> <span class="toc-text">主要函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#socket%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.1.</span> <span class="toc-text">socket函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bind%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.2.</span> <span class="toc-text">bind函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#listen%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.3.</span> <span class="toc-text">listen函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#accept%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.4.</span> <span class="toc-text">accept函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#connect%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.5.</span> <span class="toc-text">connect函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.6.</span> <span class="toc-text">读写相关函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AE%E4%BF%9Dwrite%E5%92%8Cread%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E5%AE%8C%E5%85%A8"><span class="toc-number">2.2.6.1.</span> <span class="toc-text">确保write和read发送数据完全</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7"><span class="toc-number">2.3.</span> <span class="toc-text">测试工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#nc%E5%91%BD%E4%BB%A4"><span class="toc-number">2.3.1.</span> <span class="toc-text">nc命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#netstat%E5%91%BD%E4%BB%A4"><span class="toc-number">2.3.2.</span> <span class="toc-text">netstat命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-number">2.4.</span> <span class="toc-text">案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B"><span class="toc-number">2.4.1.</span> <span class="toc-text">服务器开发流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B"><span class="toc-number">2.4.2.</span> <span class="toc-text">客户端开发流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#linux-Mac%E4%BB%A3%E7%A0%81"><span class="toc-number">2.4.3.</span> <span class="toc-text">linux&#x2F;Mac代码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">2.4.3.1.</span> <span class="toc-text">服务器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">2.4.3.2.</span> <span class="toc-text">客户端</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#windows%E4%BB%A3%E7%A0%81"><span class="toc-number">2.4.4.</span> <span class="toc-text">windows代码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8-1"><span class="toc-number">2.4.4.1.</span> <span class="toc-text">服务器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF-1"><span class="toc-number">2.4.4.2.</span> <span class="toc-text">客户端</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%BC%80%E5%8F%91%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9%E5%8F%8A%E5%AE%8C%E6%95%B4%E6%A1%88%E4%BE%8B"><span class="toc-number">2.5.</span> <span class="toc-text">网络开发的注意点及完整案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B2%E6%AD%A2%E9%98%BB%E5%A1%9E%E8%A2%AB%E4%BF%A1%E5%8F%B7%E6%89%93%E6%96%AD"><span class="toc-number">2.5.1.</span> <span class="toc-text">防止阻塞被信号打断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B2%98%E5%8C%85"><span class="toc-number">2.5.2.</span> <span class="toc-text">粘包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">2.6.</span> <span class="toc-text">多并发服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.6.1.</span> <span class="toc-text">设置非阻塞实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.6.2.</span> <span class="toc-text">多进程实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.6.3.</span> <span class="toc-text">多线程实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8A%E5%85%B3%E9%97%AD%E7%8A%B6%E6%80%81"><span class="toc-number">2.7.</span> <span class="toc-text">半关闭状态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#shutdown%E5%87%BD%E6%95%B0"><span class="toc-number">2.7.1.</span> <span class="toc-text">shutdown函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8"><span class="toc-number">2.8.</span> <span class="toc-text">端口复用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#setsockopt%E5%87%BD%E6%95%B0"><span class="toc-number">2.8.1.</span> <span class="toc-text">setsockopt函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getsockopt%E5%87%BD%E6%95%B0"><span class="toc-number">2.9.</span> <span class="toc-text">getsockopt函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%83%E8%B7%B3%E5%8C%85"><span class="toc-number">2.10.</span> <span class="toc-text">心跳包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E5%9E%8Bselect"><span class="toc-number">2.11.</span> <span class="toc-text">高并发服务器模型select</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#select%E5%87%BD%E6%95%B0"><span class="toc-number">2.11.1.</span> <span class="toc-text">select函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#select%E5%BC%80%E5%8F%91%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BB%A3%E7%A0%81"><span class="toc-number">2.11.2.</span> <span class="toc-text">select开发服务端代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0"><span class="toc-number">2.11.3.</span> <span class="toc-text">练习</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#poll%E4%B8%8Eepoll"><span class="toc-number">2.12.</span> <span class="toc-text">poll与epoll</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AFIO-poll"><span class="toc-number">2.12.1.</span> <span class="toc-text">多路IO-poll</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AFIO-epoll"><span class="toc-number">2.12.2.</span> <span class="toc-text">多路IO-epoll</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-number">2.12.2.1.</span> <span class="toc-text">相关函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#epoll-create%E5%87%BD%E6%95%B0"><span class="toc-number">2.12.2.1.1.</span> <span class="toc-text">epoll_create函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#epoll-ctl%E5%87%BD%E6%95%B0"><span class="toc-number">2.12.2.1.2.</span> <span class="toc-text">epoll_ctl函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#epoll-wait%E5%87%BD%E6%95%B0"><span class="toc-number">2.12.2.1.3.</span> <span class="toc-text">epoll_wait函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%A1%88%E4%BE%8B"><span class="toc-number">2.12.2.2.</span> <span class="toc-text">实现案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ET%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.12.2.3.</span> <span class="toc-text">ET工作模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#et%E6%A8%A1%E5%BC%8F%E6%A1%88%E4%BE%8B"><span class="toc-number">2.12.2.3.1.</span> <span class="toc-text">et模式案例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#epoll%E5%8F%8D%E5%BA%94%E5%A0%86"><span class="toc-number">2.12.2.4.</span> <span class="toc-text">epoll反应堆</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">2.13.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">2.13.1.</span> <span class="toc-text">实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-1"><span class="toc-number">2.13.1.1.</span> <span class="toc-text">案例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%89%88%E6%9C%AC%E4%BB%A3%E7%A0%81"><span class="toc-number">2.13.1.1.1.</span> <span class="toc-text">简单版本代码:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E7%89%88%E6%9C%AC"><span class="toc-number">2.13.1.1.2.</span> <span class="toc-text">复杂版本</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UDP%E9%80%9A%E4%BF%A1"><span class="toc-number">2.14.</span> <span class="toc-text">UDP通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0-1"><span class="toc-number">2.14.1.</span> <span class="toc-text">相关函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#recvfrom%E5%87%BD%E6%95%B0"><span class="toc-number">2.14.1.1.</span> <span class="toc-text">recvfrom函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sendto%E5%87%BD%E6%95%B0"><span class="toc-number">2.14.1.2.</span> <span class="toc-text">sendto函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-2"><span class="toc-number">2.14.2.</span> <span class="toc-text">案例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#udp%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%AE%80%E5%8D%95%E4%BB%A3%E7%A0%81"><span class="toc-number">2.14.2.1.</span> <span class="toc-text">udp服务端简单代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#udp%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%AE%80%E5%8D%95%E4%BB%A3%E7%A0%81"><span class="toc-number">2.14.2.2.</span> <span class="toc-text">udp客户端简单代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0socket%E9%80%9A%E4%BF%A1"><span class="toc-number">2.15.</span> <span class="toc-text">本地socket通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B"><span class="toc-number">2.15.1.</span> <span class="toc-text">代码案例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP"><span class="toc-number">2.15.1.1.</span> <span class="toc-text">TCP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UDP"><span class="toc-number">2.15.1.2.</span> <span class="toc-text">UDP</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93"><span class="toc-number">2.16.</span> <span class="toc-text">第三方库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#libevent%E5%BA%93"><span class="toc-number">2.16.1.</span> <span class="toc-text">libevent库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#libevent%E5%AE%89%E8%A3%85"><span class="toc-number">2.16.1.1.</span> <span class="toc-text">libevent安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#libevent%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.16.1.2.</span> <span class="toc-text">libevent库的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#event-base%E7%9B%B8%E5%85%B3%E7%BB%93%E6%9E%84%E4%B8%8E%E5%87%BD%E6%95%B0"><span class="toc-number">2.16.1.3.</span> <span class="toc-text">event_base相关结构与函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#event-base%E5%87%BD%E6%95%B0"><span class="toc-number">2.16.1.3.1.</span> <span class="toc-text">event_base函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#event-base-free%E5%87%BD%E6%95%B0"><span class="toc-number">2.16.1.3.2.</span> <span class="toc-text">event_base_free函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#event-reinit%E5%87%BD%E6%95%B0"><span class="toc-number">2.16.1.3.3.</span> <span class="toc-text">event_reinit函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#event-get-supported-methods%E5%87%BD%E6%95%B0"><span class="toc-number">2.16.1.3.4.</span> <span class="toc-text">event_get_supported_methods函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#event-base-get-method%E5%87%BD%E6%95%B0"><span class="toc-number">2.16.1.3.5.</span> <span class="toc-text">event_base_get_method函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#event-base-loop%E5%87%BD%E6%95%B0"><span class="toc-number">2.16.1.3.6.</span> <span class="toc-text">event_base_loop函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#event-base-dispatch%E5%87%BD%E6%95%B0"><span class="toc-number">2.16.1.3.7.</span> <span class="toc-text">event_base_dispatch函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#event-base-loopexit%E5%87%BD%E6%95%B0"><span class="toc-number">2.16.1.3.8.</span> <span class="toc-text">event_base_loopexit函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#event-base-loopbreak%E5%87%BD%E6%95%B0"><span class="toc-number">2.16.1.3.9.</span> <span class="toc-text">event_base_loopbreak函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8libevent%E5%BA%93%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">2.16.1.4.</span> <span class="toc-text">使用libevent库的流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#event%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E5%92%8C%E7%BB%93%E6%9E%84"><span class="toc-number">2.16.1.5.</span> <span class="toc-text">event相关函数和结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#event-new%E5%87%BD%E6%95%B0"><span class="toc-number">2.16.1.5.1.</span> <span class="toc-text">event_new函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#event-add%E5%87%BD%E6%95%B0"><span class="toc-number">2.16.1.5.2.</span> <span class="toc-text">event_add函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#event-del%E5%87%BD%E6%95%B0"><span class="toc-number">2.16.1.5.3.</span> <span class="toc-text">event_del函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#event-free%E5%87%BD%E6%95%B0"><span class="toc-number">2.16.1.5.4.</span> <span class="toc-text">event_free函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#libevent%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B"><span class="toc-number">2.16.1.6.</span> <span class="toc-text">libevent开发流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#libevent%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B"><span class="toc-number">2.16.1.7.</span> <span class="toc-text">libevent代码案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bufferevent"><span class="toc-number">2.16.1.8.</span> <span class="toc-text">bufferevent</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#bufferevent%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-number">2.16.1.8.1.</span> <span class="toc-text">bufferevent相关函数</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#bufferevent-socket-new%E5%87%BD%E6%95%B0"><span class="toc-number">2.16.1.8.1.1.</span> <span class="toc-text">bufferevent_socket_new函数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#bufferevent-socket-connect%E5%87%BD%E6%95%B0"><span class="toc-number">2.16.1.8.1.2.</span> <span class="toc-text">bufferevent_socket_connect函数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#bufferevent-free%E5%87%BD%E6%95%B0"><span class="toc-number">2.16.1.8.1.3.</span> <span class="toc-text">bufferevent_free函数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#bufferevent-setcb%E5%87%BD%E6%95%B0"><span class="toc-number">2.16.1.8.1.4.</span> <span class="toc-text">bufferevent_setcb函数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#bufferevent-write%E5%87%BD%E6%95%B0"><span class="toc-number">2.16.1.8.1.5.</span> <span class="toc-text">bufferevent_write函数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#bufferevent-write-buffer%E5%87%BD%E6%95%B0"><span class="toc-number">2.16.1.8.1.6.</span> <span class="toc-text">bufferevent_write_buffer函数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#bufferevent-read%E5%87%BD%E6%95%B0"><span class="toc-number">2.16.1.8.1.7.</span> <span class="toc-text">bufferevent_read函数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#bufferevent-read-buffer%E5%87%BD%E6%95%B0"><span class="toc-number">2.16.1.8.1.8.</span> <span class="toc-text">bufferevent_read_buffer函数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#bufferevent-enable%E5%87%BD%E6%95%B0"><span class="toc-number">2.16.1.8.1.9.</span> <span class="toc-text">bufferevent_enable函数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#bufferevent-disable%E5%87%BD%E6%95%B0"><span class="toc-number">2.16.1.8.1.10.</span> <span class="toc-text">bufferevent_disable函数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#bufferevent-get-output%E5%87%BD%E6%95%B0"><span class="toc-number">2.16.1.8.1.11.</span> <span class="toc-text">bufferevent_get_output函数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#bufferevent-get-input%E5%87%BD%E6%95%B0"><span class="toc-number">2.16.1.8.1.12.</span> <span class="toc-text">bufferevent_get_input函数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#evbuffer-get-length%E5%87%BD%E6%95%B0"><span class="toc-number">2.16.1.8.1.13.</span> <span class="toc-text">evbuffer_get_length函数</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-number">2.16.1.8.2.</span> <span class="toc-text">链接监听器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E7%9B%91%E5%90%AC%E5%99%A8%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-number">2.16.1.8.3.</span> <span class="toc-text">链接监听器相关函数</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#evconnlistener-new-bind%E5%87%BD%E6%95%B0"><span class="toc-number">2.16.1.8.3.1.</span> <span class="toc-text">evconnlistener_new_bind函数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#evconnlistener-new%E5%87%BD%E6%95%B0"><span class="toc-number">2.16.1.8.3.2.</span> <span class="toc-text">evconnlistener_new函数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#evconnlistener-free%E5%87%BD%E6%95%B0"><span class="toc-number">2.16.1.8.3.3.</span> <span class="toc-text">evconnlistener_free函数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#evconnlistener-enable%E5%87%BD%E6%95%B0"><span class="toc-number">2.16.1.8.3.4.</span> <span class="toc-text">evconnlistener_enable函数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#evconnlistener-disable%E5%87%BD%E6%95%B0"><span class="toc-number">2.16.1.8.3.5.</span> <span class="toc-text">evconnlistener_disable函数</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#bufferevent%E5%92%8C%E9%93%BE%E6%8E%A5%E5%99%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">2.16.1.8.4.</span> <span class="toc-text">bufferevent和链接器服务器流程</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%BB%E6%B5%81%E7%A8%8B"><span class="toc-number">2.16.1.8.4.1.</span> <span class="toc-text">主流程</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5%E5%9B%9E%E8%B0%83%E6%B5%81%E7%A8%8B"><span class="toc-number">2.16.1.8.4.2.</span> <span class="toc-text">客户端连接回调流程</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AF%BB%E5%9B%9E%E8%B0%83%E6%B5%81%E7%A8%8B"><span class="toc-number">2.16.1.8.4.3.</span> <span class="toc-text">读回调流程</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E7%BB%88%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B"><span class="toc-number">2.16.1.8.5.</span> <span class="toc-text">最终代码案例</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%A3%E7%A0%81"><span class="toc-number">2.16.1.8.5.1.</span> <span class="toc-text">服务器代码</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%A3%E7%A0%81"><span class="toc-number">2.16.1.8.5.2.</span> <span class="toc-text">客户端代码</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1%E6%95%88%E7%8E%87%E4%BC%98%E5%8C%96"><span class="toc-number">2.17.</span> <span class="toc-text">通信效率优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BC%98%E5%8C%96"><span class="toc-number">2.17.1.</span> <span class="toc-text">客户端优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A1%88%E4%BE%8B"><span class="toc-number">2.17.1.1.</span> <span class="toc-text">客户端案例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#TcpClient-h"><span class="toc-number">2.17.1.1.1.</span> <span class="toc-text">TcpClient.h</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TcpClient-cpp"><span class="toc-number">2.17.1.1.2.</span> <span class="toc-text">TcpClient.cpp</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BC%98%E5%8C%96"><span class="toc-number">2.17.2.</span> <span class="toc-text">服务端优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%A1%88%E4%BE%8B"><span class="toc-number">2.17.2.1.</span> <span class="toc-text">服务端案例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#TcpServer-h"><span class="toc-number">2.17.2.1.1.</span> <span class="toc-text">TcpServer.h</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TcpServer-cpp"><span class="toc-number">2.17.2.1.2.</span> <span class="toc-text">TcpServer.cpp</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#web%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">3.</span> <span class="toc-text">web服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#http%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.1.</span> <span class="toc-text">http协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#http%E8%AF%B7%E6%B1%82%E6%B6%88%E6%81%AF"><span class="toc-number">3.1.1.</span> <span class="toc-text">http请求消息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">请求类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%A4%B4%E4%B8%AD%E9%87%8D%E8%A6%81%E5%86%85%E5%AE%B9"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">请求头中重要内容</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Content-Type"><span class="toc-number">3.1.1.2.1.</span> <span class="toc-text">Content-Type</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http%E5%93%8D%E5%BA%94%E6%B6%88%E6%81%AF"><span class="toc-number">3.1.2.</span> <span class="toc-text">http响应消息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#http%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">http常见状态码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#http%E5%B8%B8%E8%A7%81%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E5%88%86%E7%B1%BB"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">http常见文件类型分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E5%A4%B4%E4%B8%AD%E9%87%8D%E8%A6%81%E5%86%85%E5%AE%B9"><span class="toc-number">3.1.2.3.</span> <span class="toc-text">响应头中重要内容</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cookie%E8%AF%A6%E8%A7%A3"><span class="toc-number">3.1.3.</span> <span class="toc-text">cookie详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AECookie"><span class="toc-number">3.1.3.1.</span> <span class="toc-text">设置Cookie</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Cookie"><span class="toc-number">3.1.3.2.</span> <span class="toc-text">使用Cookie</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#https%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.2.</span> <span class="toc-text">https协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TLS%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B"><span class="toc-number">3.2.1.</span> <span class="toc-text">TLS握手过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#web%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7"><span class="toc-number">3.3.</span> <span class="toc-text">web测试工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#curl"><span class="toc-number">3.3.1.</span> <span class="toc-text">curl</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#web%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91"><span class="toc-number">3.4.</span> <span class="toc-text">web服务器开发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E5%88%B0%E5%86%85%E5%AE%B9%E5%90%8E%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">3.4.1.</span> <span class="toc-text">读取到内容后的流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8Eepoll%E7%9A%84web%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">3.4.2.</span> <span class="toc-text">基于epoll的web服务器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8Eselect%E7%9A%84web%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">3.4.3.</span> <span class="toc-text">基于select的web服务器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%87%E6%B1%89%E5%AD%97%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98"><span class="toc-number">3.4.4.</span> <span class="toc-text">中文汉字编码问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7"><span class="toc-number">3.4.5.</span> <span class="toc-text">一些特殊符号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8Elibevent%E7%9A%84web%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">3.4.6.</span> <span class="toc-text">基于libevent的web服务器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#web%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6"><span class="toc-number">3.5.</span> <span class="toc-text">web服务器框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Nginx"><span class="toc-number">3.5.1.</span> <span class="toc-text">Nginx</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#REST-API"><span class="toc-number">3.6.</span> <span class="toc-text">REST API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CGI"><span class="toc-number">3.7.</span> <span class="toc-text">CGI</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#fastCGI"><span class="toc-number">3.7.0.1.</span> <span class="toc-text">fastCGI</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE"><span class="toc-number">3.7.0.1.1.</span> <span class="toc-text">安装与配置</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#fastCGI%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-number">3.7.0.1.1.1.</span> <span class="toc-text">fastCGI环境变量</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#fastCGI%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91"><span class="toc-number">3.7.0.1.2.</span> <span class="toc-text">fastCGI程序开发</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">3.8.</span> <span class="toc-text">分布式服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.8.1.</span> <span class="toc-text">分布式文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FastDFS"><span class="toc-number">3.8.1.1.</span> <span class="toc-text">FastDFS</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#FastDFS%E9%9B%86%E7%BE%A4"><span class="toc-number">3.8.1.1.1.</span> <span class="toc-text">FastDFS集群</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#fastDFS%E5%AE%89%E8%A3%85"><span class="toc-number">3.8.1.1.2.</span> <span class="toc-text">fastDFS安装</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#FastDFS%E5%90%AF%E5%8A%A8"><span class="toc-number">3.8.1.1.3.</span> <span class="toc-text">FastDFS启动</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.8.1.2.</span> <span class="toc-text">上传下载代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.8.1.2.1.</span> <span class="toc-text">使用多进程方式实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8fastDFS-API%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.8.1.2.2.</span> <span class="toc-text">使用fastDFS API实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fastDFS%E9%85%8D%E5%90%88fastCGI%E9%A1%B9%E7%9B%AE"><span class="toc-number">3.8.1.3.</span> <span class="toc-text">fastDFS配合fastCGI项目</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E5%AE%9E%E7%8E%B0%E6%A1%88%E4%BE%8B"><span class="toc-number">4.</span> <span class="toc-text">日志实现案例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E6%96%87%E4%BB%B6"><span class="toc-number">4.1.</span> <span class="toc-text">源文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6log-h"><span class="toc-number">4.2.</span> <span class="toc-text">头文件log.h</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">4.3.</span> <span class="toc-text">使用方式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8A%A5%E6%96%87%E7%BC%96%E8%A7%A3%E7%A0%81"><span class="toc-number">5.</span> <span class="toc-text">报文编解码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%B9%E5%BC%8F"><span class="toc-number">5.1.</span> <span class="toc-text">常用序列化方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#XML"><span class="toc-number">5.1.1.</span> <span class="toc-text">XML</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Json"><span class="toc-number">5.1.2.</span> <span class="toc-text">Json</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Protocol-Buffer"><span class="toc-number">5.1.3.</span> <span class="toc-text">Protocol Buffer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">5.1.4.</span> <span class="toc-text">其他</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ASN-1"><span class="toc-number">5.2.</span> <span class="toc-text">ASN.1</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0-2"><span class="toc-number">5.2.1.</span> <span class="toc-text">相关函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DER-ItAsn1-WriteInteger"><span class="toc-number">5.2.1.1.</span> <span class="toc-text">DER_ItAsn1_WriteInteger</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DER-ItAsn1-ReadInteger"><span class="toc-number">5.2.1.2.</span> <span class="toc-text">DER_ItAsn1_ReadInteger</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DER-ItAsn1-WritePrintableString"><span class="toc-number">5.2.1.3.</span> <span class="toc-text">DER_ItAsn1_WritePrintableString</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DER-ItAsn1-ReadPrintableString"><span class="toc-number">5.2.1.4.</span> <span class="toc-text">DER_ItAsn1_ReadPrintableString</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DER-ITCAST-String-To-AnyBuf"><span class="toc-number">5.2.1.5.</span> <span class="toc-text">DER_ITCAST_String_To_AnyBuf</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EncodeChar-DecodeChar"><span class="toc-number">5.2.1.6.</span> <span class="toc-text">EncodeChar&#x2F;DecodeChar</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#EncodeChar"><span class="toc-number">5.2.1.6.1.</span> <span class="toc-text">EncodeChar</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#DecodeChar"><span class="toc-number">5.2.1.6.2.</span> <span class="toc-text">DecodeChar</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A7%A3%E7%A0%81%E4%B8%8A%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BD%93%E7%8E%B0"><span class="toc-number">5.2.1.6.2.1.</span> <span class="toc-text">解码上两种方式的区别体现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DER-ItAsn1-WriteSequence"><span class="toc-number">5.2.1.7.</span> <span class="toc-text">DER_ItAsn1_WriteSequence</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DER-ItAsn1-ReadSequence"><span class="toc-number">5.2.1.8.</span> <span class="toc-text">DER_ItAsn1_ReadSequence</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DER-ITCAST-FreeQueue"><span class="toc-number">5.2.1.9.</span> <span class="toc-text">DER_ITCAST_FreeQueue</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="toc-number">5.2.2.</span> <span class="toc-text">使用案例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="toc-number">5.2.2.1.</span> <span class="toc-text">简单使用案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E4%B8%80%E6%AD%A5%E5%B0%81%E8%A3%85"><span class="toc-number">5.2.2.2.</span> <span class="toc-text">进一步封装</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#SequenceASN1-h"><span class="toc-number">5.2.2.2.0.1.</span> <span class="toc-text">SequenceASN1.h</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#SequenceASN1-cpp"><span class="toc-number">5.2.2.2.0.2.</span> <span class="toc-text">SequenceASN1.cpp</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSharp%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1"><span class="toc-number">6.</span> <span class="toc-text">CSharp网络通信</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TcpClient-TcpListener"><span class="toc-number">6.1.</span> <span class="toc-text">TcpClient&#x2F;TcpListener</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TcpClient"><span class="toc-number">6.1.1.</span> <span class="toc-text">TcpClient</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TcpListener"><span class="toc-number">6.1.2.</span> <span class="toc-text">TcpListener</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-3"><span class="toc-number">6.1.3.</span> <span class="toc-text">案例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-number">6.1.3.1.</span> <span class="toc-text">服务端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF-2"><span class="toc-number">6.1.3.2.</span> <span class="toc-text">客户端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%AF%BB%E5%86%99"><span class="toc-number">6.1.3.3.</span> <span class="toc-text">二进制读写</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Socket"><span class="toc-number">6.2.</span> <span class="toc-text">Socket</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7%E5%8F%8A%E8%AF%B4%E6%98%8E"><span class="toc-number">6.2.1.</span> <span class="toc-text">常用属性及说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E5%8F%8A%E8%AF%B4%E6%98%8E"><span class="toc-number">6.2.2.</span> <span class="toc-text">常用方法及说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-4"><span class="toc-number">6.2.3.</span> <span class="toc-text">案例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF-3"><span class="toc-number">6.2.3.1.</span> <span class="toc-text">客户端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8-2"><span class="toc-number">6.2.3.2.</span> <span class="toc-text">服务器</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="toc-number">7.</span> <span class="toc-text">常用网络相关命令</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#UDP%E6%89%93%E6%B4%9E"><span class="toc-number">8.</span> <span class="toc-text">UDP打洞</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%9F%E5%90%8D%E7%9B%B8%E5%85%B3"><span class="toc-number">9.</span> <span class="toc-text">域名相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%98%E7%AE%A1%E5%9F%9F%E5%90%8D"><span class="toc-number">9.1.</span> <span class="toc-text">托管域名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DNSChecker"><span class="toc-number">9.2.</span> <span class="toc-text">DNSChecker</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/%E7%89%A9%E7%90%86/" title="物理">物理</a><time datetime="2025-09-29T01:48:42.561Z" title="发表于 2025-09-29 09:48:42">2025-09-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/%E5%B7%A5%E4%B8%9A%E7%9B%B8%E5%85%B3/" title="工业相关">工业相关</a><time datetime="2025-02-14T03:04:40.761Z" title="发表于 2025-02-14 11:04:40">2025-02-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3/" title="嵌入式相关">嵌入式相关</a><time datetime="2025-02-14T03:04:40.761Z" title="发表于 2025-02-14 11:04:40">2025-02-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/" title="操作系统">操作系统</a><time datetime="2024-12-16T01:38:01.470Z" title="发表于 2024-12-16 09:38:01">2024-12-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/%E8%AE%A1%E7%BB%84/" title="计算机组成原理">计算机组成原理</a><time datetime="2024-12-16T01:38:01.470Z" title="发表于 2024-12-16 09:38:01">2024-12-16</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2025 By <a class="footer-bar-link" href="/" title="ZEROKO14" target="_blank">ZEROKO14</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu"></a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">74</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">57</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">6</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AI/" style="font-size: 0.88rem;">AI<sup>1</sup></a><a href="/tags/C/" style="font-size: 0.88rem;">C#<sup>3</sup></a><a href="/tags/C/" style="font-size: 0.88rem;">C++<sup>5</sup></a><a href="/tags/CSS/" style="font-size: 0.88rem;">CSS<sup>1</sup></a><a href="/tags/CSharp/" style="font-size: 0.88rem;">CSharp<sup>1</sup></a><a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 0.88rem;">C语言<sup>1</sup></a><a href="/tags/FPS/" style="font-size: 0.88rem;">FPS<sup>1</sup></a><a href="/tags/HTML/" style="font-size: 0.88rem;">HTML<sup>1</sup></a><a href="/tags/JavaScript/" style="font-size: 0.88rem;">JavaScript<sup>1</sup></a><a href="/tags/MFC/" style="font-size: 0.88rem;">MFC<sup>1</sup></a><a href="/tags/PE/" style="font-size: 0.88rem;">PE<sup>1</sup></a><a href="/tags/QT/" style="font-size: 0.88rem;">QT<sup>1</sup></a><a href="/tags/WPF/" style="font-size: 0.88rem;">WPF<sup>3</sup></a><a href="/tags/ai/" style="font-size: 0.88rem;">ai<sup>1</sup></a><a href="/tags/cmake/" style="font-size: 0.88rem;">cmake<sup>1</sup></a><a href="/tags/doxygen/" style="font-size: 0.88rem;">doxygen<sup>1</sup></a><a href="/tags/git/" style="font-size: 0.88rem;">git<sup>1</sup></a><a href="/tags/linux/" style="font-size: 0.88rem;">linux<sup>1</sup></a><a href="/tags/nas/" style="font-size: 0.88rem;">nas<sup>1</sup></a><a href="/tags/next/" style="font-size: 0.88rem;">next<sup>1</sup></a><a href="/tags/ppt/" style="font-size: 0.88rem;">ppt<sup>1</sup></a><a href="/tags/python/" style="font-size: 0.88rem;">python<sup>1</sup></a><a href="/tags/slidev/" style="font-size: 0.88rem;">slidev<sup>1</sup></a><a href="/tags/vue/" style="font-size: 0.88rem;">vue<sup>1</sup></a><a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 0.88rem;">代码规范<sup>1</sup></a><a href="/tags/%E5%86%85%E6%A0%B8/" style="font-size: 0.88rem;">内核<sup>2</sup></a><a href="/tags/%E5%86%85%E6%A0%B8%E7%9B%B8%E5%85%B3/" style="font-size: 0.88rem;">内核相关<sup>5</sup></a><a href="/tags/%E5%8A%A0%E8%A7%A3%E5%AF%86/" style="font-size: 0.88rem;">加解密<sup>1</sup></a><a href="/tags/%E5%9F%BA%E7%A1%80/" style="font-size: 0.88rem;">基础<sup>6</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 0.88rem;">多线程<sup>1</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F/" style="font-size: 0.88rem;">并发模式<sup>1</sup></a><a href="/tags/%E5%BC%80%E5%8F%91/" style="font-size: 0.88rem;">开发<sup>4</sup></a><a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 0.88rem;">数学<sup>1</sup></a><a href="/tags/%E6%9D%82%E9%A1%B9/" style="font-size: 0.88rem;">杂项<sup>1</sup></a><a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 0.88rem;">正则表达式<sup>1</sup></a><a href="/tags/%E7%89%A9%E7%90%86/" style="font-size: 0.88rem;">物理<sup>1</sup></a><a href="/tags/%E7%9B%91%E6%8E%A7/" style="font-size: 0.88rem;">监控<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 0.88rem;">网络<sup>3</sup></a><a href="/tags/%E9%80%86%E5%90%91/" style="font-size: 0.88rem;">逆向<sup>5</sup></a><a href="/tags/%E9%AD%94%E6%B3%95/" style="font-size: 0.88rem;">魔法<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.cbd.int/mathjax@3.2.2/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.cbd.int/mermaid@10.2.4/dist/mermaid.min.js').then(runMermaid)
  }

  anzhiyu.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>