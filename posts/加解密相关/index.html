<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>加密与解密 | ZEROKO14的个人博客</title><meta name="keywords" content="加解密"><meta name="author" content="ZEROKO14"><meta name="copyright" content="ZEROKO14"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#18171d"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="加密与解密"><meta name="application-name" content="加密与解密"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#18171d"><meta property="og:type" content="article"><meta property="og:title" content="加密与解密"><meta property="og:url" content="https://che77a38.github.io/posts/%E5%8A%A0%E8%A7%A3%E5%AF%86%E7%9B%B8%E5%85%B3/index.html"><meta property="og:site_name" content="ZEROKO14的个人博客"><meta property="og:description" content="加解密相关知识及其背后原理阐述   加解密相关涉及到网络数据传输的且对传输的数据有安全性需求的,就需要传输数据之前对数据进行加密操作,常用的网络通信方式有  socket通信 —- 如 socket API编程 http协议通信 —- 如B&amp;#x2F;S模式   为保证网络通信时数据的安全,就需要对"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4"><meta property="article:author" content="ZEROKO14"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4"><meta name="description" content="加解密相关知识及其背后原理阐述   加解密相关涉及到网络数据传输的且对传输的数据有安全性需求的,就需要传输数据之前对数据进行加密操作,常用的网络通信方式有  socket通信 —- 如 socket API编程 http协议通信 —- 如B&amp;#x2F;S模式   为保证网络通信时数据的安全,就需要对"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://che77a38.github.io/posts/%E5%8A%A0%E8%A7%A3%E5%AF%86%E7%9B%B8%E5%85%B3/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2024/07/27/125766904/ba62475f396df9de3316a08ed9e65d86_5680958632268053399..png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":true,"limitCount":50,"languages":{"author":"作者: ZEROKO14","link":"链接: ","source":"来源: ZEROKO14的个人博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'ZEROKO14的个人博客',
  title: '加密与解密',
  postAI: '',
  pageFillDescription: '加解密相关, 常用的加密的方式, 对称加密, 非对称加密, 最简单的非对称加密方式举例, 常用安全算法, 对称加密, DESx2F3DES, AES, 其他对称加密算法, 非对称加密, DH算法原理, RSA算法原理, Hash算法, 消息认证码, 数字签名, openssl配置, win下安装, win下使用openssl, Linux下安装, Linux下使用openssl, openssl库的api, BIO, BIO相关api, RSA算法api, RSA结构体, BIGNUM结构体, BIGNUM操作函数api, rsa公私钥生成案例, openssl生成公钥和私钥命令, openssl公私密钥使用案例, 常见的加密算法的逆向特征, 取盐算法, MD5逆向特征, SHA逆向特征, 可还原加密算法, RSA逆向特征, AES逆向特征, DES逆向特征, 其他编码算法, Base64 逆向特征, AES算法, OpenSSL中的AES算法, 生成加密x2F解密的Key, 加解密函数, 案例, ECB方式加密, CBC方式加密, 案例, 单向散列函数, 哈希函数特点, 哈希函数的应用, 检测软件是否被篡改, 消息认证码, 数字签名, 一次性口令或登录验证, 常用的哈希函数, Md4x2FMd5, SHA-1x2FSHA-256x2FSHA-384x2FSHA-512, openssl库中哈希函数用法, sha1简单案例, hmac简单案例, base64编码, 安全传输, 密钥协商, 客户端协商流程, 服务端协商流程, 密钥校验, 密钥注销, 安全传输平台结构, 根证书比对工具加解密相关知识及其背后原理阐述加解密相关涉及到网络数据传输的且对传输的数据有安全性需求的就需要传输数据之前对数据进行加密操作常用的网络通信方式有通信如编程协议通信如模式为保证网络通信时数据的安全就需要对数据进行加密常用的加密的方式对称加密加密和解密使用的是同一个秘钥秘钥分发困难加密效率高安全级别低相对与非对称加密解密方式非对称加密非对称加密可靠的前提在于对方真的是对方非对称加密害怕被冒充加密和解密所使用的秘钥不同是一个秘钥对包含公钥可以公开的秘钥私钥不能公开的秘钥传输的数据对谁更重要谁就拿私钥私钥加密公钥解密的场景可以用于确定该信息来自私钥拥有者公钥加密私钥解密的场景可以用于向私钥拥有者传递数据防止被其他人解密加密的过程使用公钥加密必须使用私钥解密使用私钥加密必须使用公钥解密秘钥分发简单加密效率低安全级别高加密需要实现秘钥生成秘钥校验秘钥生成模块应该与实际使用该模块的项目关联程度要低耦合度要低一个模块的修改不要影响其他模块最简单的非对称加密方式举例想一个数字将他乘以得到的数取后五位将取到的后五位数乘以得到的五位数就是最开始的数字原理是为因此它天然可以保留后五位数也知道刚开始想的数字最多为位数这种加密知道后可以推出破解加密算法常用安全算法对称加密已经被破解要求秘钥长度字节在对数据进行加密之前先对数据按每组个字节进行分组然后分段进行加密最后再将每一段加密的数据进行组合效率低秘钥长度字节内部会将秘钥分成份同样需要加密的数据先按每组个字节进行分组然后分别使用三份秘钥进行加密解密加密若三份秘钥都相同其实就是加密方式使用最广泛的对称加密算法详解秘钥要求字节字节字节秘钥长度越大加密效率越低但安全性越高其他对称加密算法非对称加密数字签名和密钥交换椭圆曲线加密算法密钥交换数字签名数字签名算法原理迪菲赫尔曼密钥交换算法算法的关键在于离散对数问题的难解性即在已知和的情况下计算的困难性这使得攻击者无法通过截获网络传输的公钥来推导出私钥从而保证了密钥交换的安全性和就是上面的和是公开的数字可以任意更换需要了解一个公式这个公式展示了算法的交换性质即指数运算和模运算的顺序不会影响最终的共享密钥算法原理用于生成非对称加密的公私钥数学原理参考数学原理参考阮一峰明文密文转化过程如图公钥私钥生成规则算法流程找到两个指数计算其乘积计算欧拉函数选择一个整数使得是最大公约数找到一个整数使得的余数为即为整数公钥为私钥为加密密文明文明文密文算法算法单向散列函数算法不是用于加密的只能单向转换将任意长度的数据生成一个固定长度的字符串散列值长度字节散列值长度字节散列值长度字节注意算法由于不能逆所以不能得到原始数据不能用于加密多用于数据校验消息认证码消息认证码是一种确认完整性并进行认证的技术取三个单词的首字母简称为消息认证码的输入包括任意长度的消息和一个发送者与接受者之间共享的密钥它可以输出固定长度的数据这个数据称为值根据任意长度的消息输出固定长度的数据这一点和单向散列函数很类似但是单向散列函数中计算散列值时不需要密钥而消息认证码中则需要使用发送者与接受这之间共享的密钥上面的就属于消息认证码数字签名配置是一个安全套接字层密码库由语言实现的囊括主要的密码算法常用的密钥和证书封装管理功能及协议并提供丰富的应用程序供测试或其它目的使用是安全套接层协议的缩写可以在上提供秘密性传输公司在推出第一个浏览器的同时提出了协议标准其目标是保证两个应用间通信的保密性和可靠性可在服务器端和用户端同时实现支持已经成为上保密通讯的工业标准协议就用到了协议是由协议构建的可进行加密传输身份认证的网络协议比协议安全既可以在平台下使用也可以在平台下使用是开源跨平台的一套加密库下安装版安装路径下使用设置项目属性将的头文件目录和库目录添加到当前项目中包含目录设置为安装目录下的目录库目录设置为安装目录下的目录中的附加依赖项设置项目属性链接器输入附加依赖项将安装目录目录下的两个动态库拷贝到工作目录下测试代码头文件初始化添加数据计算结果输出输出结果下安装版下载进入根目录安装可选使用管理员权限执行该命令参考基础以及系统编程源码安装中的安装流程以下文件里边有安装步骤找可执行文件执行这个可执行文件检测安装环境生成执行命令编译源代码生成了动态库静态库可执行程序安装需要管理员权限将第三步生成的动态库动态库可执行程序拷贝到对应的系统目录验证是否安装成功下使用使用的代码与此处代码一样通过编译源文件执行该命令需要加载的两个动态库查看生成的可执行程序运行时需要加载的动态库如果找不到可以使用定位或者等语句找到动态库所在目录将找到的动态库绝对路径添加到文件夹中并使用管理员权限执行命令将找到的动态库绝对路径添加到文件末尾保存退出配置文件更新配置库的算法哈希算法算法是库中提供的一个抽象层它提供了一种统一的接口用于对不同类型的数据源如文件内存网络连接等进行读写操作提供了一种灵活的方式来处理数据的输入和输出无论是从文件读取数据还是将数据写入文件甚至是通过网络发送数据都可以通过来实现它可以用于加密解密签名验证等各种加密操作可以与各种数据源进行交互包括文件内存缓冲区套接字等它提供了一组函数如用于创建对象和用于读写数据用于释放对象等的优点是可以将不同类型的数据源抽象为统一的接口使得代码更加灵活和可移植在加密和解密操作中常用于将密钥证书加密数据等读取到内存中或者将加密结果写入文件或发送到网络中需要注意的是在使用时需要进行适当的错误处理和内存管理以确保安全和可靠的数据传输相关创建一个内存对象创建一个新的文件对象并打开指定的文件创建一个新的文件描述符对象并关联指定的文件描述符创建一个新的套接字对象并关联指定的套接字将数据写入对象从对象中读取数据将字符串写入对象从对象中读取字符串刷新对象设置对象是否关闭控制对象的行为释放对象的内存空间算法库中提供了一系列相关的函数以下是其中一些常用的函数及其作用下面需要的两个头文件为和创建一个空的对象生成密钥对获取密钥的长度使用公钥加密数据使用私钥解密数据使用私钥加密数据使用公钥解密数据将公钥以格式写入文件将私钥以格式写入文件从格式的文件中读取公钥从格式的文件中读取私钥释放对象占用的内存详细含义参阅下方一一对应创建一个空的对象返回值指向新创建的对象的指针生成密钥对指向对象的指针生成密钥对的位数公钥指数进度回调函数指针可选返回值成功返回失败返回获取密钥的长度参数指向对象的指针返回值密钥的长度以字节为单位使用公钥加密数据要加密的数据长度以字节为单位指向要加密的数据的指针指向存储加密结果的缓冲区的指针指向对象的指针填充方式返回值加密后的数据长度使用私钥解密数据要解密的数据长度以字节为单位指向要解密的数据的指针指向存储解密结果的缓冲区的指针指向对象的指针填充方式返回值解密后的数据长度使用私钥加密数据要加密的数据长度以字节为单位指向要加密的数据的指针指向存储加密结果的缓冲区的指针指向对象的指针填充方式返回值加密后的数据长度使用公钥解密数据要解密的数据长度以字节为单位指向要解密的数据的指针指向存储解密结果的缓冲区的指针指向对象的指针填充方式返回值解密后的数据长度将公钥以格式写入文件文件指针指向要写入的文件指向对象的指针返回值成功返回失败返回将私钥以格式写入文件文件指针指向要写入的文件指向对象的指针加密算法可选密码字符串可选密码长度可选进度回调函数指针可选返回值成功返回失败返回从格式的文件中读取公钥文件指针指向要读取的文件指向对象的指针的指针密码回调函数指针可选密码回调函数参数可选返回值成功返回读取到的对象失败返回从格式的文件中读取私钥文件指针指向要读取的文件指向对象的指针的指针密码回调函数指针可选密码回调函数参数可选返回值成功返回读取到的对象失败返回释放对象占用的内存参数指向对象的指针返回值无结构体版本模数公钥指数私钥指数和是的两个素数因子之一方法引擎结构体结构体是库中进行等非对称加密算法所必需的数据结构之一它提供了一种方便的方式来处理大数运算如大数的加法减法乘法除法取模等操作需要注意的是在使用结构体时我们需要进行适当的内存管理和错误处理以确保安全和正确的大数运算存储大数的数据大数的有效二进制位数数组的最大长度标志位表示大数的符号正负标志位用于控制大数的行为在不同的平台上的大小可能会有所不同通常情况下被定义为类型它的大小与平台的位数相关操作函数以下是一些常用于操作和控制大数的函数包括加法减法乘法除法取模等运算以及比较赋值转换等功能加法和减法将大数和相加结果存储在中将大数减去结果存储在中乘法和除法将大数和相乘结果存储在中将大数除以商存储在中余数存储在中取模运算将大数对取模结果存储在中比较函数比较两个大数和的大小返回值为负数零或正数表示小于等于或大于赋值和拷贝将无符号长整型数赋值给大数复制大数返回一个新的对象转换函数将大数转换为二进制格式存储在指向的缓冲区中将二进制数据转换为大数返回一个新的对象公私钥生成案例初始化库并不是必需的但是建议在使用库进行加密操作时调用这两个函数以确保库的正确初始化和错误处理机制的正常工作这些函数可以提高代码的健壮性和可靠性特别是在处理复杂的加密操作时中用于存储大数的数据类型在算法中用于存储和处理密钥和加密数据一个预定义的常量通常用作公钥指数设置为对象的值生成位的密钥对导出公钥导出私钥将公钥写入清空将私钥写入释放释放资源生成公钥和私钥命令生成私钥这将生成一个算法的私钥并将其保存在名为的文件中私钥将使用加密生成公钥这将从文件中提取私钥并生成相应的公钥公钥将保存在名为的文件中公私密钥使用案例加密函数加密失败处理错误逻辑解密函数解密失败处理错误逻辑加载公钥加载私钥加密解密打印结果释放内存常见的加密算法的逆向特征参考网址跳转取盐算法取盐算法也叫摘要算法是对数据进行一系列运算后截取一部分关键值进行校验因此运算过程不可逆无法还原出加密前的初始文本取盐算法得到的结果长度一般是固定的无论输入的消息有多长计算出来的消息摘要的长度总是固定的一般地只要输入的文本不同对其进行摘要以后产生的摘要消息也必不相同但相同的文本输入必会产生相同的输出在密码学中盐是指通过在密码任意固定位置插入特定的字符串让散列后的结果和使用原始密码的散列结果不相符这种过程称之为加盐这样可以增加破解难度提高密码安全性取盐算法是指如何选择盐逆向特征字符串为进制即数字英文组合而且英文最大是字母位数为搜索关键字关键词默认的值原始的魔法值进制原始的魔法值进制计算结果值位结果值开头位小写计算结果位大写计算结果位结果值开头位小写计算结果位小写计算结果注意位的结果值是位的结果值的一部分逆向特征字符串为进制即数字英文组合而且英文最大是字母位数为等位数均是的倍数计算结果值位位位位可还原加密算法特征字符串为进制即数字英文组合而且英文最大是字母字符串为编码形式由数字小写字母大写字母以及字符组成且最后一个或最后两个字符为通常而言的识别特征为索引表当我们能找到这样索引表再经过简单的分析基本就能判定是编码逆向特征是典型的非对称加密拥有一个公钥和一个私钥其中客户端浏览器拥有公钥服务器同时拥有公钥和私钥同一个明文可以生成不同的密文必须先加密对象然后加密后的数据长度不可能是的倍数搜索关键词逆向特征是对称加密的一种一般加密出来的数据是或的整倍数搜索关键词或类似二进制模值逆向特征搜索关键词其他编码算法逆向特征字符串的长度为的整数倍字符串的符号取值只能在共计个字符中且如果出现就必须在结尾出现算法是一套对称密钥的密码术目前已广泛使用用于替代已经不够安全的算法所谓对称密钥就是说加密和解密用的是同一个密钥消息的发送方和接收方在消息传递前需要享有这个密钥和非对称密钥体系不同这里的密钥是双方保密的不会让任何第三方知道对称密钥加密法主要基于块加密选取固定长度的密钥去加密明文中固定长度的块生成的密文块与明文块长度一样显然密钥长度十分重要块的长度也很重要如果太短则很容易枚举出所有的明文密文映射如果太长性能则会急剧下降中规定块长度为而密钥长度可以选择或暴力破解密钥需要万亿年这保证了的安全性中的算法头文件生成加密解密的明文分组的大小加密的时候调用参数数据加密使用的原始秘钥字符串参数秘钥字符串占的位数参数传出参数供后续加密使用的秘钥类型解密时候使用参数数据解码密使用的原始秘钥字符串参数秘钥字符串占的位数参数传出参数供后续解密使用的秘钥类型同上成功返回失败返回参数名称描述字节字节字节传出后续加解密需要用到加解密函数下面使用的其实就是分组模式要求使用以下两个时候参数必须是的整数倍如果不是需要将最后一组补足字节解密的时候需要将最后一个分组添加的末尾字节删除加密函数参数要加密的原始数据明文参数传出加密之后对数据密文参数通过得到的值解密函数参数要被解密的密文参数解密后得到明文参数得到的值案例已经是的整数倍若不是的整数倍则需要在末尾进行补齐如何补齐呢在补齐的时候缺几个就补几如最后的一组缺个字节则最后都补如果正好是的整数倍则最后需要补上个字节如补上一个解码之后再删掉就可以了方式加密电子密码本模式参数要加密解密的数据长度在字节范围就就可以参数传出参数得到的明文密文参数参数指定进行加密或者解密函数的使用方式这个函数调用一次只能处理字节条件方式加密密码分组链接模式参数要加密解密的数据参数通过加密得到的密文通过解密得到的明文参数修饰的是参数如果长度需要加上长度是的整数倍那么就等于该长度就是尾部的的长度需要加上长度不是的整数倍需要将其变成的整数倍计算当前有多少个分组将最后不满字节的分组添加进来并将其字节数填充到字节参数通过得到的值得到的值参数随机字符串长度和明文分组长度相同参与加解密的初始化向量的值必须相同参数案例需要加密的字符串计算第三个参数的长度包含了字符串末尾的长度刚好合适加密后内容为下面是解密解密后的内容为输出为加密后内容为下面是解密解密后的内容为单向散列函数用于获取消息的指纹单向散列函数有一个输入和一个输出其中输入称为消息输出称为散列值单向散列函数可以根据消息的内容计算出散列值而散列值就可以被用来检查消息的完整性单向散列函数也称为消息摘要函数哈希函数或者杂凑函数单向散列函数输出的散列值也称为消息摘要或者指纹完整性也称为一致性哈希函数特点压缩性任意长度的数据算出的值长度都是固定的容易计算计算散列值所花费的时间必须要短尽管消息越长计算散列值的时间也会越长但如果不能在现实的时间内完成计算就没有意义了抗修改性对原数据进行任何改动哪怕只修改个字节所得到的值都有很大区别强抗碰撞性已知原数据和其哈希值想找到一个具有相同哈希值的数据即伪造数据是非常困难的单向性不可逆哈希函数的应用检测软件是否被篡改我们可以使用单向散列函数来确认自己下载的软件是否被篡改很多软件尤其是安全相关的软件都会把通过单向散列函数计算出的散列值公布在自己的官方网站上用户在下载到软件之后可以自行计算散列值然后与官方网站上公布的散列值进行对比通过散列值用户可以确认自己所下载到的文件与软件作者所提供的文件是否一致这样的方法在可以通过多种途径得到软件的情况下非常有用为了减轻服务器的压力很多软件作者都会借助多个网站镜像站点来发布软件在这种情况下单向散列函数就会在检测软件是否被篡改方面发挥重要作用消息认证码使用单向散列函数可以构造消息认证码消息认证码是将发送者和接收者之间的共享密钥和消息进行混合后计算出的散列值使用消息认证码可以检测并防止通信过程中的错误篡改以及伪装对于发送端将要发送的数据进行哈希运算参与运算的数据是原始数据秘钥可以得到一个散列值将散列值与原始数据进行拼接一起发送给对方对于接收端接收对方发来的数据并将原始数据和散列值拆分开得到散列值和原始数据对原始数据进行哈希运算参与运算的数据也是原始数据秘钥可以得到一个散列值将计算得到的散列值与接受到的散列值进行比较相同则认为没有被篡改否则认为被篡改了注意发送方和接受方使用的秘钥是同一个秘钥对称秘钥秘钥分发困难这个秘钥只有发送方和接受方知道若这个秘钥被第三方知道了就没有办法保证数据的是安全的了数字签名在进行数字签名时也会使用单向散列函数数字签名是现实社会中的签名和盖章这样的行为在数字世界中的实现数字签名的处理过程非常耗时因此一般不会对整个消息内容直接施加数字签名而是先通过单向散列函数计算出消息的散列值然后再对这个散列值施加数字签名使用的是非对称加密有公钥和私钥数字签名流程将明文进行哈希运算得到一个散列值并且用私钥对哈希值进行加密然后将明文和加了密的哈希值一起发送给收到之后使用公钥对哈希值进行解密得到原始的哈希值并且对明文进行哈希运算也得到一个哈希值最后对自己生成的哈希值和发送过来的哈希值进行比较如果一样则认为没有被篡改使用数字签名的目的是为了不可抵赖性表明拿私钥的一方发送的数据是不可抵赖的一次性口令或登录验证一次性口令使用单向散列函数可以构造一次性口令一次性口令经常被用于服务器对客户端的合法性认证在这种方式中通过使用单向散列函数可以保证口令只在通信链路上传送一次因此即使窃听者窃取了口令也无法使用登录验证当用户登录的时候需要输入密码这个密码会经过加密运算经过运算之后的值再与服务器中保存的密码进行比较若相同则输入密码正确允许登录若用户忘记密码则只能重置密码服务端并不知道用户原来的明文只能是重新设置常用的哈希函数是由于年设计的单向散列函数能够产生比特的散列值修订版不过随着提出寻找散列碰撞的方法因此现在它已经不安全了是由于年设计的单项散列函数能够产生比特的散列值的强抗碰撞性已经被攻破也就是说现在已经能够产生具备相同散列值的两条不同的消息因此它也已经不安全了和中的是消息摘要的缩写是由美国国家标准技术研究所设计的一种能够产生比特的散列值的单向散列函数年被作为美国联邦信息处理标准规格发布的是年发布的修订版称为的消息长度存在上限但这个值接近于比特是个非常巨大的数值因此在实际应用中没有问题和都是由设计的单向散列函数它们的散列值长度分别为比特比特和比特这些单向散列函数合起来统称它们的消息长度也存在上限的上限接近于比特和的上限接近于比特这些单向散列函数是于年和一起作为发布的的强抗碰撞性已于年被攻破也就是说现在已经能够产生具备相同散列值的两条不同的消息不过还尚未被攻破哈希函数散列值长度散列值长度最终需要对得到的散列值做转换以进制格式的字符串表库中哈希函数用法头文件位置根目录库文件位置根目录下添加附加依赖项和无法解析的外部符号报错下添加附加依赖项第一种方式第二种方式为第一种方式的封装初始化一个类型的变量传出给哈希函数添加要运算的数据传入传入要进行哈希运算的数据参数的长度文件计算结果传出参数需要将计算出的散列值保存到中出入第二种方式要进行哈希运算的字符串第一个参数的长度计算出的散列值返回值得到的散列值上述几个函数的用法同的几个函数相关的函数说明可以在安装目录中去查看如和能够用到的库名使用到的库所在的路径使用到的头文件所在的路径注意在使用进行项目开发的时候需要指定头文件所在路径和库文件所在路径可以用诸如文件路径命令直接计算得出值简单案例下面案例为下需指定头文件所在路径和库文件所在路径以及添加依赖项你好世界若有不可见或者是二进制数据使用会出现将散列值转换为进制格式的字符串将每个字符格式化简单案例下面例子其实也是使用的单向散列方式密钥要单向散列的数据单向散列输出的结果一个字节用两个字符来表示因此乘该变量用于打印这个也可以代替下面那行设置单向散列函数哈希结果输出到中下面是第二种方式一行代码生成结果编码是一种基于个可打印字符来表示二进制数据的表示方法在中的可打印字符包括字母数字这样共有个字符此外两个可打印符号在不同的系统中而不同只是一种编码格式并不用于加密因为特征明显且易于还原为什么要使用在计算机中任何数据都是按码存储的而码的之间的值是不可见字符而在网络上交换数据时比如说从地传到地往往要经过多个路由设备由于不同的设备对字符的处理方式有一些不同这样那些不可见字符就有可能被处理错误这是不利于传输的所以就先把数据先做一个编码统统变成可见字符这样出错的可能性就大大降低了的主要应用场景作为电子邮件的传输编码邮件传输协议只支持字符传递因此如果要传输二进制文件如图片视频需要通过编码协议协议要求请求行和请求头都必须是编码数据库数据读写存储二进制的大数据块将中文传入不支持中文的数据库具体算法把个位字节转换为个位字节个字节把位的前面补两个形成位一个字节的形式如果剩下的字符不足个字节则用填充输出字符使用因此编码后输出的文本末尾可能会出现个或个表示补了多少字节解码的时候会自动去掉的编码的编码安全传输非对称加密好是好但一般由于加解密太废时间了导致卡顿因此实际上都只使用非对称加密参与流程获得对称密钥在使用对称密钥来进行双方的通信对称加密有硬件加速现代都内置指令集参考加密进化的动画解说密钥协商图示注意实际的情况中与的发送流程应该是使用非对称加密算法的公钥来加密后发送的只有服务器的私钥才能解开此案例中直接明文发送了这样也无法高枕无忧因为无法确定公钥一定是服务器的害怕被冒充所以同样需要效仿实现证书机制至于证书的签发机构是不是受信任因为受信任机构的根证书被安装到了系统中即使有证书机制还是要防范假的根证书被安装到了系统客户端协商流程客户端生成一个随机数同时使用中哈希函数对进行哈希运算得到一个哈希值将要发送的数据进行编码发送数据给服务端包含和对应的哈希值客户端等待接受服务端的应答服务端协商流程操作对接收到的数据进行解码判断的值若为表示生成密钥失败如果成功获得服务端发来的随机字符串将和进行拼接进行哈希运算得到一个新的客户端将密钥信息写入共享内存服务端协商流程收到请求数据之后首先解码根据客户端服务端查询数据库校验客户端是否合法如不合法直接拒绝服务服务端校验消息认证码使用和客户端相同的算法生成哈希值然后将这个哈希值与接收到的哈希值做比较如果不一样则拒绝服务如果一样则继续后续操作服务端也生成随机数服务端将和进行拼接然后使用与客户端相同的哈希算法进行哈希运算得到一个哈希值这个哈希值就当做新的密钥将新的密钥信息写入共享内存和数据库服务端发送应答信息给客户端密钥校验客户端客户端将密钥进行哈希运算得到一个哈希值将哈希值发送给服务端服务端收到哈希值自己也生成一个哈希值将两个哈希值进行比较相同则密钥协商成功否则秘钥协商失败密钥注销客户端将和密钥发送给服务端服务端服务端收到请求之后将共享内存和数据库中的密钥的状态修改为不可用状态安全传输平台结构通信操作的封装完全可以封装到一个类中内部处理了超时问题实现最基本的共享内存操作对共享内存操作的进一步封装服务器的操作封装客户端的操作封装实现最基本的编码逻辑编码的进一步封装对为了实现对不同结构体的编码而对做的进一步封装的一个用于实现多态的基类和用于具体实现多态的对请求数据进行编码的类型以及对回应数据进行编码的类型生产各种工厂的抽象类其生产工厂的函数返回的类型为多态对多态和具体的生产请求数据的工厂的类和生产回应数据的工厂的类对操作的封装实现日志功能根证书比对工具开源工具下载根证书相关知识',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-12-21 20:38:48',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://th.bing.com/th/id/OIP.wtmjepfWPBvn26uz7s18dgHaHa?rs=1&amp;pid=ImgDetMain"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">ZEROKO14的个人博客</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size: 1.05rem;">C#<sup>2</sup></a><a href="/tags/C/" style="font-size: 1.05rem;">C++<sup>5</sup></a><a href="/tags/CSS/" style="font-size: 1.05rem;">CSS<sup>1</sup></a><a href="/tags/CSharp/" style="font-size: 1.05rem;">CSharp<sup>1</sup></a><a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 1.05rem;">C语言<sup>1</sup></a><a href="/tags/FPS/" style="font-size: 1.05rem;">FPS<sup>1</sup></a><a href="/tags/HTML/" style="font-size: 1.05rem;">HTML<sup>1</sup></a><a href="/tags/JavaScript/" style="font-size: 1.05rem;">JavaScript<sup>1</sup></a><a href="/tags/MFC/" style="font-size: 1.05rem;">MFC<sup>1</sup></a><a href="/tags/PE/" style="font-size: 1.05rem;">PE<sup>1</sup></a><a href="/tags/QT/" style="font-size: 1.05rem;">QT<sup>1</sup></a><a href="/tags/WPF/" style="font-size: 1.05rem;">WPF<sup>2</sup></a><a href="/tags/ai/" style="font-size: 1.05rem;">ai<sup>1</sup></a><a href="/tags/cmake/" style="font-size: 1.05rem;">cmake<sup>1</sup></a><a href="/tags/doxygen/" style="font-size: 1.05rem;">doxygen<sup>1</sup></a><a href="/tags/git/" style="font-size: 1.05rem;">git<sup>1</sup></a><a href="/tags/json/" style="font-size: 1.05rem;">json<sup>1</sup></a><a href="/tags/linux/" style="font-size: 1.05rem;">linux<sup>1</sup></a><a href="/tags/nas/" style="font-size: 1.05rem;">nas<sup>1</sup></a><a href="/tags/next/" style="font-size: 1.05rem;">next<sup>1</sup></a><a href="/tags/ppt/" style="font-size: 1.05rem;">ppt<sup>1</sup></a><a href="/tags/slidev/" style="font-size: 1.05rem;">slidev<sup>1</sup></a><a href="/tags/vue/" style="font-size: 1.05rem;">vue<sup>1</sup></a><a href="/tags/xml/" style="font-size: 1.05rem;">xml<sup>1</sup></a><a href="/tags/yaml/" style="font-size: 1.05rem;">yaml<sup>1</sup></a><a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 1.05rem;">代码规范<sup>1</sup></a><a href="/tags/%E5%86%85%E6%A0%B8/" style="font-size: 1.05rem;">内核<sup>2</sup></a><a href="/tags/%E5%86%85%E6%A0%B8%E7%9B%B8%E5%85%B3/" style="font-size: 1.05rem;">内核相关<sup>5</sup></a><a href="/tags/%E5%8A%A0%E8%A7%A3%E5%AF%86/" style="font-size: 1.05rem;">加解密<sup>1</sup></a><a href="/tags/%E5%9F%BA%E7%A1%80/" style="font-size: 1.05rem;">基础<sup>2</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 1.05rem;">多线程<sup>1</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F/" style="font-size: 1.05rem;">并发模式<sup>1</sup></a><a href="/tags/%E5%BC%80%E5%8F%91/" style="font-size: 1.05rem;">开发<sup>4</sup></a><a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 1.05rem;">数学<sup>1</sup></a><a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 1.05rem;">正则表达式<sup>1</sup></a><a href="/tags/%E7%9B%91%E6%8E%A7/" style="font-size: 1.05rem;">监控<sup>1</sup></a><a href="/tags/%E7%A1%AC%E7%BC%96%E7%A0%81/" style="font-size: 1.05rem;">硬编码<sup>1</sup></a><a href="/tags/%E7%AE%A1%E7%90%86/" style="font-size: 1.05rem;">管理<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 1.05rem;">网络<sup>3</sup></a><a href="/tags/%E9%80%86%E5%90%91/" style="font-size: 1.05rem;">逆向<sup>2</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/02/"><span class="card-archive-list-date">二月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/12/"><span class="card-archive-list-date">十二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/11/"><span class="card-archive-list-date">十一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/09/"><span class="card-archive-list-date">九月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">七月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">14</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/06/"><span class="card-archive-list-date">六月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/04/"><span class="card-archive-list-date">四月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">十一月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">27</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url">技术</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E5%8A%A0%E8%A7%A3%E5%AF%86/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>加解密</span></a></span></div></div><h1 class="post-title" itemprop="name headline">加密与解密</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-11-24T09:33:30.024Z" title="发表于 2023-11-24 17:33:30">2023-11-24</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-12-21T12:38:48.008Z" title="更新于 2024-12-21 20:38:48">2024-12-21</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="加密与解密"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为新加坡"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>新加坡</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://che77a38.github.io/posts/%E5%8A%A0%E8%A7%A3%E5%AF%86%E7%9B%B8%E5%85%B3/"><header><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url">技术</a><a href="/tags/%E5%8A%A0%E8%A7%A3%E5%AF%86/" tabindex="-1" itemprop="url">加解密</a><h1 id="CrawlerTitle" itemprop="name headline">加密与解密</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">ZEROKO14</span><time itemprop="dateCreated datePublished" datetime="2023-11-24T09:33:30.024Z" title="发表于 2023-11-24 17:33:30">2023-11-24</time><time itemprop="dateCreated datePublished" datetime="2024-12-21T12:38:48.008Z" title="更新于 2024-12-21 20:38:48">2024-12-21</time></header><p>加解密相关知识及其背后原理阐述</p>
<span id="more"></span>

<h1 id="加解密相关"><a href="#加解密相关" class="headerlink" title="加解密相关"></a>加解密相关</h1><p>涉及到网络数据传输的且对传输的数据有安全性需求的,就需要传输数据之前对数据进行加密操作,常用的网络通信方式有</p>
<ul>
<li>socket通信 —- 如 socket API编程</li>
<li>http协议通信 —- 如B&#x2F;S模式</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202212241530981.png" alt="image-20221224153050288"></p>
<p>为保证网络通信时数据的安全,就需要对数据进行加密</p>
<h2 id="常用的加密的方式"><a href="#常用的加密的方式" class="headerlink" title="常用的加密的方式"></a>常用的加密的方式</h2><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>加密和解密使用的是同一个秘钥</p>
<ul>
<li>秘钥分发困难</li>
<li>加密效率高</li>
<li>安全级别低(相对与非对称加密)</li>
</ul>
<p>AEAD解密方式</p>
<h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><blockquote>
<p>非对称加密可靠的前提在于: 对方真的是对方,非对称加密害怕被冒充</p>
</blockquote>
<p>加密和解密所使用的秘钥不同,是一个秘钥对,包含:</p>
<ul>
<li>公钥 — 可以公开的秘钥</li>
<li>私钥 — 不能公开的秘钥</li>
</ul>
<p>传输的数据对谁更重要,谁就拿私钥</p>
<ul>
<li>私钥加密,公钥解密的场景:可以用于确定该信息来自私钥拥有者</li>
<li>公钥加密,私钥解密的场景:可以用于向私钥拥有者传递数据防止被其他人解密</li>
</ul>
<p>加密的过程:使用公钥加密,必须使用私钥解密;使用私钥加密,必须使用公钥解密</p>
<ul>
<li>秘钥分发简单</li>
<li>加密效率低</li>
<li>安全级别高</li>
</ul>
<p>加密需要实现:</p>
<ul>
<li>秘钥生成,秘钥校验</li>
<li>秘钥生成模块应该与实际使用该模块的项目关联程度要低,耦合度要低,一个模块的修改不要影响其他模块</li>
</ul>
<h4 id="最简单的非对称加密方式举例"><a href="#最简单的非对称加密方式举例" class="headerlink" title="最简单的非对称加密方式举例"></a>最简单的非对称加密方式举例</h4><p>想一个数字,将他乘以2359得到的数取后五位</p>
<p>将取到的后五位数乘以12039,得到的五位数就是最开始的数字</p>
<p>原理是2359*12039为28400001,因此它天然可以保留后五位数,也知道刚开始想的数字最多为5位数</p>
<p>这种加密,知道2359后,可以推出12039,破解加密算法</p>
<h2 id="常用安全算法"><a href="#常用安全算法" class="headerlink" title="常用安全算法"></a>常用安全算法</h2><h3 id="对称加密-1"><a href="#对称加密-1" class="headerlink" title="对称加密"></a>对称加密</h3><h4 id="DES-3DES"><a href="#DES-3DES" class="headerlink" title="DES&#x2F;3DES"></a>DES&#x2F;3DES</h4><p>DES-已经被破解</p>
<ul>
<li>要求秘钥长度8字节</li>
<li>在对数据进行加密之前先对数据按每组8个字节进行分组,然后分段进行加密,最后再将每一段加密的数据进行组合</li>
</ul>
<p>3DES-效率低</p>
<ul>
<li>秘钥长度24字节,内部会将秘钥分成3份</li>
<li>同样,需要加密的数据先按每组8个字节进行分组,然后分别使用三份秘钥进行加密—&gt;解密—&gt;加密;</li>
<li>若三份秘钥都相同,其实就是DES加密方式</li>
</ul>
<h4 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h4><p><strong>使用最广泛</strong>的对称加密算法,<a href="#AES%E7%AE%97%E6%B3%95">详解</a></p>
<p>秘钥要求:</p>
<ul>
<li>16字节,24字节,32字节</li>
<li>秘钥长度越大,加密效率越低,但安全性越高</li>
</ul>
<h4 id="其他对称加密算法"><a href="#其他对称加密算法" class="headerlink" title="其他对称加密算法"></a>其他对称加密算法</h4><ul>
<li>TDEA</li>
<li>Blowfish</li>
<li>RC2&#x2F;RC4&#x2F;RC5</li>
<li>IDEA</li>
<li>SKIPJACK</li>
</ul>
<h3 id="非对称加密-1"><a href="#非对称加密-1" class="headerlink" title="非对称加密"></a>非对称加密</h3><ul>
<li><a href="#RSA%E7%AE%97%E6%B3%95">RSA</a>(数字签名和密钥交换)</li>
<li>ECC(椭圆曲线加密算法)</li>
<li>Diffie-Hellman(DH,密钥交换)</li>
<li>El Gamal(数字签名)</li>
<li>DSA (数字签名)</li>
</ul>
<h4 id="DH算法原理"><a href="#DH算法原理" class="headerlink" title="DH算法原理"></a>DH算法原理</h4><p>迪菲-赫尔曼 Diffie–Hellman 密钥交换算法<br>DH 算法的关键在于离散对数问题的难解性，即在已知 A、B 和 $A^x \bmod B$ 的情况下，计算 x 的困难性。这使得攻击者无法通过截获网络传输的公钥来推导出私钥，从而保证了密钥交换的安全性。<br>5 和 23 就是上面的 A 和 B 是公开的数字可以任意更换:<br>需要了解一个公式: $(5^x  \bmod  23 )^y  \bmod  23&#x3D; (5^x  \bmod  23 )^y  \bmod  23&#x3D;5^{xy} \bmod 23$<br>$$<br>(A^x  \bmod  B )^y  \bmod  B&#x3D; (A^x  \bmod  B )^y  \bmod  B&#x3D;A^{xy} \bmod B<br>$$<br>这个公式展示了 Diffie-Hellman 算法的交换性质，即指数运算和模运算的顺序不会影响最终的共享密钥。</p>
<h4 id="RSA算法原理"><a href="#RSA算法原理" class="headerlink" title="RSA算法原理"></a>RSA算法原理</h4><blockquote>
<p>用于生成非对称加密的公私钥</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41619796/article/details/118604950">数学原理参考1</a></p>
<p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html">数学原理参考阮一峰</a></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://www.bilibili.com/video/BV154411L7VT" alt="RSA算法数学原理视频|720x360"></p>
<p>明文,密文转化过程如图:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202302021804138.jpeg" alt="161675332249_.pic"></p>
<p>公钥,私钥生成规则:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202302021804660.jpeg" alt="171675332251_.pic"></p>
<p>RSA算法流程</p>
<ol>
<li><p>找到两个指数p,q，计算其乘积n</p>
</li>
<li><p>计算t &#x3D; （p-1）*（q-1）  (欧拉函数)</p>
</li>
<li><p>选择一个<strong>整数E</strong>使得gcd(E,t)&#x3D;1</p>
<p>gcd是最大公约数greatest common divisor</p>
</li>
<li><p>找到一个<strong>整数D</strong>使得E*D&#x2F;t的余数为1,即Ex-yf-1&#x3D;0(x,y为整数)</p>
</li>
<li><p>公钥为n,E   私钥为n,D</p>
</li>
</ol>
<p>加密:<br>$$<br>密文 &#x3D;  明文^{E} \bmod  n<br>$$</p>
<p>$$<br>明文 &#x3D;  密文^{D} \bmod  n<br>$$</p>
<h3 id="Hash算法"><a href="#Hash算法" class="headerlink" title="Hash算法"></a>Hash算法</h3><p><a href="#%E5%8D%95%E5%90%91%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0"><strong>Hash算法</strong></a>  –&gt;  单向散列函数 —- Hash算法不是用于加密的,只能<strong>单向转换</strong></p>
<ul>
<li>将任意长度的数据生成一个固定长度的字符串</li>
<li>MD4&#x2F;MD5 <ul>
<li>散列值长度16字节</li>
</ul>
</li>
<li>SHA-1<ul>
<li>散列值长度20字节</li>
</ul>
</li>
<li>SHA-2<ul>
<li>SHA224&#x2F;SHA256&#x2F;SHA384&#x2F;SHA512</li>
<li>sha224<ul>
<li>散列值长度:224&#x2F;8&#x3D;28字节</li>
</ul>
</li>
</ul>
</li>
<li>SHA3-224&#x2F;SHA3-256&#x2F;SHA3-384&#x2F;SHA3-512</li>
<li>HMAC</li>
</ul>
<p>注意:Hash算法由于不能逆,所以不能得到原始数据,不能用于加密,多用于数据校验</p>
<h3 id="消息认证码"><a href="#消息认证码" class="headerlink" title="消息认证码"></a>消息认证码</h3><p>消息认证码(message authentication code)是一种确认完整性并进行认证的技术,取三个单词的首字母,简称为MAC.</p>
<p>消息认证码的输入包括任意长度的消息和一个发送者与接受者之间共享的密钥,它可以输出固定长度的数据,这个数据称为MAC值.</p>
<p>根据任意长度的消息输出固定长度的数据,这一点和单向散列函数很类似.但是单向散列函数中计算散列值时不需要密钥,而消息认证码中则需要使用发送者与接受这之间共享的密钥.</p>
<p>上面的hmac就属于消息认证码</p>
<h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>​	</p>
<h2 id="openssl配置"><a href="#openssl配置" class="headerlink" title="openssl配置"></a>openssl配置</h2><p>OpenSSL 是一个安全套接字层密码库(由C语言实现的)，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，并提供丰富的应用程序供测试或其它目的使用。</p>
<p>SSL是Secure Sockets Layer（安全套接层协议）的缩写，可以在Internet上提供秘密性传输。Netscape公司在推出第一个Web浏览器的同时，提出了SSL协议标准。其目标是保证两个应用间通信的保密性和可靠性,可在服务器端和用户端同时实现支持。已经成为Internet上保密通讯的工业标准.https协议就用到了SSL,HTTPS协议是由SSL+HTTP协议构建的可进行加密传输,身份认证的网络协议,比http协议安全</p>
<p>OpenSSL既可以在windows平台下使用,也可以在linux平台下使用,是<strong>开源跨平台</strong>的一套加密库</p>
<h3 id="win下安装"><a href="#win下安装" class="headerlink" title="win下安装"></a>win下安装</h3><p><a target="_blank" rel="noopener" href="http://slproweb.com/products/Win32OpenSSL.html">OpenSSL win版安装路径</a></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202212311521546.png" alt="image-20221231152119110"></p>
<h3 id="win下使用openssl"><a href="#win下使用openssl" class="headerlink" title="win下使用openssl"></a>win下使用openssl</h3><p>设置项目属性,将openssl的头文件目录和库目录添加到当前项目中</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202212311525657.png" alt="image-20221231152435770"></p>
<ul>
<li><strong>包含目录</strong>设置为openssl安装目录下的include目录</li>
<li><strong>库目录</strong>设置为openssl安装目录下的lib目录</li>
</ul>
<p>VS中的附加依赖项设置:</p>
<p><strong>项目属性 -&gt; 链接器 -&gt; 输入 -&gt; 附加依赖项</strong></p>
<ul>
<li><strong>libssl.lib</strong></li>
<li><strong>libcrypto.lib</strong></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202212311543694.png" alt="image-20221231154325461"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202212311543177.png" alt="image-20221231154349203"></p>
<p>将openssl安装目录<code>/bin</code>目录下的两个动态库拷贝到工作目录下: </p>
<ul>
<li><strong><code>libcrypto-1_1-x64.dll</code></strong></li>
<li><strong><code>libssl-1_1-x64.dll</code></strong></li>
</ul>
<p><strong>测试代码:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include &lt;openssl/md5.h&gt;    // md5 头文件</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void getMD5(const char* str, char* result)</span><br><span class="line">&#123;</span><br><span class="line">  MD5_CTX ctx;</span><br><span class="line">  // 初始化</span><br><span class="line">  MD5_Init(&amp;ctx);</span><br><span class="line">  // 添加数据</span><br><span class="line">  MD5_Update(&amp;ctx, str, strlen(str));</span><br><span class="line">  // 计算结果</span><br><span class="line">  unsigned char md[16] = &#123; 0 &#125;;</span><br><span class="line">  MD5_Final(md, &amp;ctx);</span><br><span class="line">  for (int i = 0; i &lt; 16; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    sprintf(&amp;result[i * 2], &quot;%02x&quot;, md[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  char result[33] = &#123; 0 &#125;;</span><br><span class="line">  getMD5(&quot;hello, md5&quot;, result);</span><br><span class="line">  printf(&quot;md5 value: %s\n&quot;, result);</span><br><span class="line">  system(&quot;pause&quot;);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输出结果: </span><br><span class="line">  md5 value: 33b3bc8e05b4fcc16bd531dd9adac166</span><br></pre></td></tr></table></figure>

<h3 id="Linux下安装"><a href="#Linux下安装" class="headerlink" title="Linux下安装"></a>Linux下安装</h3><p><strong><a target="_blank" rel="noopener" href="https://github.com/openssl/openssl/tree/OpenSSL_1_1_1-stable">OpenSSL linux版下载</a></strong></p>
<p> <strong><code>git clone https://github.com/openssl/openssl.git</code></strong></p>
<p><strong>进入根目录,安装:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./config</span><br><span class="line">make</span><br><span class="line">make test    (可选)</span><br><span class="line">make install   (使用管理员权限执行该命令)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>参考[[linux基础以及系统编程#linux源码安装]]中的安装流程:</strong> </p>
<ol>
<li><strong>以下文件, 里边有安装步骤</strong><ol>
<li><strong>readme</strong></li>
<li><strong>readme.md</strong></li>
<li><strong>INSTALL</strong></li>
</ol>
</li>
<li><strong>找 可执行文件 <code>configure</code></strong><ol>
<li><strong>执行这个可执行文件</strong><ol>
<li><strong>检测安装环境</strong></li>
<li><strong>生成 makefile</strong></li>
</ol>
</li>
</ol>
</li>
<li><strong>执行<code>make</code>命令</strong><ol>
<li><strong>编译源代码</strong><ol>
<li><strong>生成了动态库</strong></li>
<li><strong>静态库</strong></li>
<li><strong>可执行程序</strong></li>
</ol>
</li>
</ol>
</li>
<li><strong>安装 <code>make install</code> (需要管理员权限)</strong><ol>
<li><strong>将第三步生成的动态库&#x2F;动态库&#x2F;可执行程序拷贝到对应的系统目录</strong></li>
</ol>
</li>
</ol>
</blockquote>
<p><strong>验证是否安装成功</strong></p>
<p><strong><code>openssl version -a</code></strong></p>
<h3 id="Linux下使用openssl"><a href="#Linux下使用openssl" class="headerlink" title="Linux下使用openssl"></a>Linux下使用openssl</h3><p><strong>使用的代码与<a href="#win%E4%B8%8B%E4%BD%BF%E7%94%A8openssl">此处代码</a>一样</strong></p>
<p><strong>通过gcc编译源文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc md5_test.c -o md5 -lssl -lcrypto</span><br><span class="line">执行该命令, 需要加载openssl的两个动态库    </span><br><span class="line">- libssl.so    </span><br><span class="line">- libcrypto.so</span><br></pre></td></tr></table></figure>

<p><strong>查看生成的可执行程序 md5 运行时需要加载的动态库:</strong></p>
<p><strong><code>ldd md5</code></strong></p>
<p><strong>如果找不到,可以使用定位libcrypto.so   <code>locate libcrypto.so</code>  或者 <code>find / -name &quot;libcrypto.so&quot;</code>等语句找到动态库所在目录</strong></p>
<p><strong>将找到的动态库绝对路径添加到  <code>/etc/ls.so.conf</code>  文件夹中,并使用管理员权限执行命令  <code>ldconfig</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/ld.so.conf</span><br><span class="line">将 找到的动态库绝对路径 添加到文件末尾, 保存退出配置文件</span><br><span class="line">更新配置:</span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure>

<h3 id="openssl库的api"><a href="#openssl库的api" class="headerlink" title="openssl库的api"></a>openssl库的api</h3><ul>
<li><a href="#OpenSSL%E4%B8%AD%E7%9A%84AES%E7%AE%97%E6%B3%95">AES算法api</a></li>
<li><a href="#openssl%E5%BA%93%E4%B8%AD%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95">哈希算法api</a></li>
<li><a href="#RSA%E7%AE%97%E6%B3%95api">RSA算法api</a></li>
</ul>
<h4 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h4><blockquote>
<p><strong>BIO</strong>（BIO - I&#x2F;O abstraction）是OpenSSL库中提供的一个I&#x2F;O抽象层。它提供了一种统一的接口，用于对不同类型的数据源（如文件、内存、网络连接等）进行读写操作。</p>
</blockquote>
<p>BIO提供了一种灵活的方式来处理数据的输入和输出，无论是从文件读取数据，还是将数据写入文件，甚至是通过网络发送数据，都可以通过BIO来实现。它可以用于加密、解密、签名、验证等各种加密操作。</p>
<p>BIO可以与各种数据源进行交互，包括文件（FILE*）、内存缓冲区（buffer）、套接字（socket）等。它提供了一组函数，如<code>BIO_new()</code>用于创建BIO对象，<code>BIO_read()</code>和<code>BIO_write()</code>用于读写数据，<code>BIO_free()</code>用于释放BIO对象等。</p>
<p>BIO的优点是可以将不同类型的数据源抽象为统一的接口，使得代码更加灵活和可移植。在加密和解密操作中，BIO常用于将密钥、证书、加密数据等读取到内存中，或者将加密结果写入文件或发送到网络中。</p>
<p>需要注意的是，BIO在使用时需要进行适当的错误处理和内存管理，以确保安全和可靠的数据传输。</p>
<h5 id="BIO相关api"><a href="#BIO相关api" class="headerlink" title="BIO相关api"></a>BIO相关api</h5><ul>
<li><code>BIO *BIO_new(BIO_METHOD *method)</code>    创建一个内存BIO对象</li>
<li><code>BIO *BIO_new_file(const char *filename, const char *mode)</code>：创建一个新的文件BIO对象，并打开指定的文件。</li>
<li><code>BIO_new_fd(int fd, int close_flag)</code>：创建一个新的文件描述符BIO对象，并关联指定的文件描述符。</li>
<li><code>BIO_new_socket(int sock, int close_flag)</code>：创建一个新的套接字BIO对象，并关联指定的套接字。</li>
<li><code>int BIO_write(BIO *bio, const void *data, int dlen)</code>：将数据写入 BIO 对象。</li>
<li><code>int BIO_read(BIO *bio, void *data, int dlen)</code>：从 BIO 对象中读取数据。</li>
<li><code>int BIO_puts(BIO *bio, const char *str)</code>：将字符串写入 BIO 对象。</li>
<li><code>int BIO_gets(BIO *bio, char *buf, int size)</code>：从 BIO 对象中读取字符串。</li>
<li><code>int BIO_flush(BIO *bio)</code>：刷新 BIO 对象。</li>
<li><code>int BIO_set_close(BIO *bio, long c)</code>：设置 BIO 对象是否关闭。</li>
<li><code>long BIO_ctrl(BIO *bio, int cmd, long larg, void *parg)</code>：控制 BIO 对象的行为。</li>
<li><code>void BIO_free_all(BIO *bio)</code>：释放 BIO 对象的内存空间。</li>
</ul>
<h4 id="RSA算法api"><a href="#RSA算法api" class="headerlink" title="RSA算法api"></a>RSA算法api</h4><p>OpenSSL库中提供了一系列RSA相关的函数，以下是其中一些常用的函数及其作用</p>
<p>下面需要的两个头文件为 <code>&lt;openssl/rsa.h&gt;</code> 和 <code>&lt;openssl/pem.h&gt;</code></p>
<ol>
<li><code>RSA_new()</code>：创建一个空的RSA对象。</li>
<li><code>RSA_generate_key_ex()</code>：生成RSA密钥对。</li>
<li><code>RSA_size()</code>：获取RSA密钥的长度。</li>
<li><code>RSA_public_encrypt()</code>：使用RSA公钥加密数据。</li>
<li><code>RSA_private_decrypt()</code>：使用RSA私钥解密数据。</li>
<li><code>RSA_private_encrypt()</code>：使用RSA私钥加密数据。</li>
<li><code>RSA_public_decrypt()</code>：使用RSA公钥解密数据。</li>
<li><code>PEM_write_RSA_PUBKEY()</code>：将RSA公钥以PEM格式写入文件。</li>
<li><code>PEM_write_RSAPrivateKey()</code>：将RSA私钥以PEM格式写入文件。</li>
<li><code>PEM_read_RSA_PUBKEY()</code>：从PEM格式的文件中读取RSA公钥。</li>
<li><code>PEM_read_RSAPrivateKey()</code>：从PEM格式的文件中读取RSA私钥。</li>
<li><code>RSA_free()</code>：释放RSA对象占用的内存。</li>
</ol>
<p><strong>详细含义参阅下方:</strong>(一一对应)</p>
<ol>
<li><p><code>RSA* RSA_new()</code>：创建一个空的RSA对象。</p>
<ul>
<li>返回值：指向新创建的RSA对象的指针</li>
</ul>
</li>
<li><p><code>int RSA_generate_key_ex(RSA* rsa,int bits,BIGNUM* e,BN_GENCB* c)</code>：生成RSA密钥对。</p>
<ul>
<li>rsa：指向RSA对象的指针</li>
<li>bits：生成密钥对的位数</li>
<li>e：公钥指数</li>
<li>cb：进度回调函数指针（可选）</li>
<li>返回值：成功返回1，失败返回0</li>
</ul>
</li>
<li><p><code>int RSA_size(const RSA* rsa)</code>：获取RSA密钥的长度。</p>
<ul>
<li>参数：rsa：指向RSA对象的指针</li>
<li>返回值：RSA密钥的长度（以字节为单位）</li>
</ul>
</li>
<li><p><code>int RSA_public_encrypt(int flen, const unsigned char* from, unsigned char* to, RSA* rsa, int padding)</code>：使用RSA公钥加密数据。</p>
<ul>
<li>flen：要加密的数据长度（以字节为单位）</li>
<li>from：指向要加密的数据的指针</li>
<li>to：指向存储加密结果的缓冲区的指针</li>
<li>rsa：指向RSA对象的指针</li>
<li>padding：填充方式</li>
<li>返回值：加密后的数据长度</li>
</ul>
</li>
<li><p><code>int RSA_private_decrypt(int flen, const unsigned char* from, unsigned char* to, RSA* rsa, int padding)</code>：使用RSA私钥解密数据。</p>
<ul>
<li>flen：要解密的数据长度（以字节为单位）</li>
<li>from：指向要解密的数据的指针</li>
<li>to：指向存储解密结果的缓冲区的指针</li>
<li>rsa：指向RSA对象的指针</li>
<li>padding：填充方式</li>
<li>返回值：解密后的数据长度</li>
</ul>
</li>
<li><p><code>int RSA_private_encrypt(int flen, const unsigned char* from, unsigned char* to, RSA* rsa, int padding)</code>：使用RSA私钥加密数据。</p>
<ul>
<li>flen：要加密的数据长度（以字节为单位）</li>
<li>from：指向要加密的数据的指针</li>
<li>to：指向存储加密结果的缓冲区的指针</li>
<li>rsa：指向RSA对象的指针</li>
<li>padding：填充方式</li>
<li>返回值：加密后的数据长度</li>
</ul>
</li>
<li><p><code>int RSA_public_decrypt(int flen, const unsigned char* from, unsigned char* to, RSA* rsa, int padding)</code>：使用RSA公钥解密数据。</p>
<ul>
<li>flen：要解密的数据长度（以字节为单位）</li>
<li>from：指向要解密的数据的指针</li>
<li>to：指向存储解密结果的缓冲区的指针</li>
<li>rsa：指向RSA对象的指针</li>
<li>padding：填充方式</li>
<li>返回值：解密后的数据长度</li>
</ul>
</li>
<li><p><code>int PEM_write_RSA_PUBKEY(FILE* fp, RSA* rsa)</code>：将RSA公钥以PEM格式写入文件。</p>
<ul>
<li>fp：文件指针，指向要写入的文件</li>
<li>rsa：指向RSA对象的指针</li>
<li>返回值：成功返回1，失败返回0</li>
</ul>
</li>
<li><p><code>int PEM_write_RSAPrivateKey(FILE* fp, RSA* rsa, const EVP_CIPHER* enc, unsigned char* kstr, int klen, pem_password_cb* cb)</code>：将RSA私钥以PEM格式写入文件。</p>
<ul>
<li>fp：文件指针，指向要写入的文件</li>
<li>rsa：指向RSA对象的指针</li>
<li>enc：加密算法（可选）</li>
<li>kstr：密码字符串（可选）</li>
<li>klen：密码长度（可选）</li>
<li>cb：进度回调函数指针（可选）</li>
<li>返回值：成功返回1，失败返回0</li>
</ul>
</li>
<li><p><code>RSA* PEM_read_RSA_PUBKEY(FILE* fp, RSA** rsa, pem_password_cb* cb, void* u)</code>：从PEM格式的文件中读取RSA公钥。</p>
<ul>
<li><p>fp：文件指针，指向要读取的文件</p>
</li>
<li><p>rsa：指向RSA对象的指针的指针</p>
</li>
<li><p>cb：密码回调函数指针（可选）</p>
</li>
<li><p>u：密码回调函数参数（可选）</p>
<ul>
<li>返回值：成功返回读取到的RSA对象，失败返回NULL</li>
</ul>
</li>
</ul>
</li>
<li><p><code>RSA* PEM_read_RSAPrivateKey(FILE* fp, RSA** rsa, pem_password_cb* cb, void* u)</code>：从PEM格式的文件中读取RSA私钥。</p>
<ul>
<li>fp：文件指针，指向要读取的文件</li>
<li>rsa：指向RSA对象的指针的指针</li>
<li>cb：密码回调函数指针（可选）</li>
<li>u：密码回调函数参数（可选）</li>
<li>返回值：成功返回读取到的RSA对象，失败返回NULL</li>
</ul>
</li>
<li><p><code>void RSA_free(RSA* rsa)</code>：释放RSA对象占用的内存。</p>
<ul>
<li>参数：rsa：指向RSA对象的指针</li>
<li>返回值：无</li>
</ul>
</li>
</ol>
<h5 id="RSA结构体"><a href="#RSA结构体" class="headerlink" title="RSA结构体"></a>RSA结构体</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">rsa_st</span> RSA;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rsa_st</span> &#123;</span><br><span class="line">    <span class="comment">// RSA版本</span></span><br><span class="line">    <span class="type">int</span> version;</span><br><span class="line">    <span class="comment">// RSA模数</span></span><br><span class="line">    BIGNUM* n;</span><br><span class="line">    <span class="comment">// 公钥指数</span></span><br><span class="line">    BIGNUM* e;</span><br><span class="line">    <span class="comment">// 私钥指数</span></span><br><span class="line">    BIGNUM* d;</span><br><span class="line">    <span class="comment">// p和q是RSA的两个素数因子之一</span></span><br><span class="line">    BIGNUM* p;</span><br><span class="line">    BIGNUM* q;</span><br><span class="line">    <span class="comment">// d mod (p-1)</span></span><br><span class="line">    BIGNUM* dmp1;</span><br><span class="line">    <span class="comment">// d mod (q-1)</span></span><br><span class="line">    BIGNUM* dmq1;</span><br><span class="line">    <span class="comment">// q^-1 mod p</span></span><br><span class="line">    BIGNUM* iqmp;</span><br><span class="line">    <span class="comment">// RSA方法</span></span><br><span class="line">    <span class="type">const</span> RSA_METHOD* meth;</span><br><span class="line">    <span class="comment">// RSA引擎</span></span><br><span class="line">    ENGINE* engine;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h6 id="BIGNUM结构体"><a href="#BIGNUM结构体" class="headerlink" title="BIGNUM结构体"></a>BIGNUM结构体</h6><blockquote>
<p>BIGNUM结构体是OpenSSL库中进行RSA、DSA、ECC等非对称加密算法所必需的数据结构之一。它提供了一种方便的方式来处理大数运算，如大数的加法、减法、乘法、除法、取模等操作。</p>
<p>需要注意的是，在使用BIGNUM结构体时，我们需要进行适当的内存管理和错误处理，以确保安全和正确的大数运算。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">bignum_st</span> BIGNUM;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bignum_st</span> &#123;</span><br><span class="line">    BN_ULONG* d;    <span class="comment">// 存储大数的数据</span></span><br><span class="line">    <span class="type">int</span> top;        <span class="comment">// 大数的有效二进制位数</span></span><br><span class="line">    <span class="type">int</span> dmax;       <span class="comment">// 数组d的最大长度</span></span><br><span class="line">    <span class="type">int</span> neg;        <span class="comment">// 标志位，表示大数的符号（正/负）</span></span><br><span class="line">    <span class="type">int</span> flags;      <span class="comment">// 标志位，用于控制大数的行为</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//在不同的平台上，BN_ULONG的大小可能会有所不同。通常情况下，BN_ULONG被定义为unsigned long类型，它的大小与平台的位数相关</span></span><br></pre></td></tr></table></figure>

<h6 id="BIGNUM操作函数api"><a href="#BIGNUM操作函数api" class="headerlink" title="BIGNUM操作函数api"></a>BIGNUM操作函数api</h6><p>以下是一些常用于操作和控制大数的函数，包括加法、减法、乘法、除法、取模等运算，以及比较、赋值、转换等功能：</p>
<ol>
<li>加法和减法：<ul>
<li><code>int BN_add(BIGNUM* r, const BIGNUM* a, const BIGNUM* b)</code>: 将大数a和b相加，结果存储在r中。</li>
<li><code>int BN_sub(BIGNUM* r, const BIGNUM* a, const BIGNUM* b)</code>: 将大数a减去b，结果存储在r中。</li>
</ul>
</li>
<li>乘法和除法：<ul>
<li><code>int BN_mul(BIGNUM* r, const BIGNUM* a, const BIGNUM* b, BN_CTX* ctx)</code>: 将大数a和b相乘，结果存储在r中。</li>
<li><code>int BN_div(BIGNUM* dv, BIGNUM* rem, const BIGNUM* num, const BIGNUM* divisor, BN_CTX* ctx)</code>: 将大数num除以divisor，商存储在dv中，余数存储在rem中。</li>
</ul>
</li>
<li>取模运算：<ul>
<li><code>int BN_mod(BIGNUM* rem, const BIGNUM* num, const BIGNUM* divisor, BN_CTX* ctx)</code>: 将大数num对divisor取模，结果存储在rem中。</li>
</ul>
</li>
<li>比较函数：<ul>
<li><code>int BN_cmp(const BIGNUM* a, const BIGNUM* b)</code>: 比较两个大数a和b的大小，返回值为负数、零或正数，表示a小于、等于或大于b。</li>
</ul>
</li>
<li>赋值和拷贝：<ul>
<li><code>int BN_set_word(BIGNUM* a, BN_ULONG w)</code>: 将无符号长整型数w赋值给大数a。</li>
<li><code>BIGNUM* BN_dup(const BIGNUM* a)</code>: 复制大数a，返回一个新的BIGNUM对象。</li>
</ul>
</li>
<li>转换函数：<ul>
<li><code>int BN_bn2bin(const BIGNUM* a, unsigned char* to)</code>: 将大数a转换为二进制格式，存储在to指向的缓冲区中。</li>
<li><code>BIGNUM* BN_bin2bn(const unsigned char* s, int len, BIGNUM* ret)</code>: 将二进制数据s转换为大数，返回一个新的BIGNUM对象。</li>
</ul>
</li>
</ol>
<h5 id="rsa公私钥生成案例"><a href="#rsa公私钥生成案例" class="headerlink" title="rsa公私钥生成案例"></a>rsa公私钥生成案例</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化openssl库</span></span><br><span class="line">    <span class="comment">//并不是必需的，但是建议在使用OpenSSL库进行加密操作时调用这两个函数，以确保库的正确初始化和错误处理机制的正常工作。这些函数可以提高代码的健壮性和可靠性，特别是在处理复杂的加密操作时。</span></span><br><span class="line">    <span class="comment">//OpenSSL_add_all_algorithms();</span></span><br><span class="line">    <span class="comment">//ERR_load_crypto_strings();</span></span><br><span class="line"></span><br><span class="line">    RSA *rsa = <span class="built_in">RSA_new</span>();</span><br><span class="line">    <span class="comment">//openssl中用于存储大数的数据类型BIGNUM</span></span><br><span class="line">    <span class="comment">//BIGNUM在RSA算法中用于存储和处理密钥和加密数据</span></span><br><span class="line">    BIGNUM *e = <span class="built_in">BN_new</span>();</span><br><span class="line">    <span class="comment">//RSA_F4（一个预定义的常量，通常用作RSA公钥指数）设置为BIGNUM对象e的值</span></span><br><span class="line">    <span class="built_in">BN_set_word</span>(e, RSA_F4);                  </span><br><span class="line">    <span class="built_in">RSA_generate_key_ex</span>(rsa, <span class="number">2048</span>, e, <span class="literal">NULL</span>); <span class="comment">// 生成2048位的RSA密钥对</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 导出公钥</span></span><br><span class="line">    FILE *publicKeyFile = <span class="built_in">fopen</span>(<span class="string">&quot;public_key.pem&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="built_in">PEM_write_RSA_PUBKEY</span>(publicKeyFile, rsa);</span><br><span class="line">    <span class="built_in">fclose</span>(publicKeyFile);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 导出私钥</span></span><br><span class="line">    FILE *privateKeyFile = <span class="built_in">fopen</span>(<span class="string">&quot;private_key.pem&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="built_in">PEM_write_RSAPrivateKey</span>(privateKeyFile, rsa, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">fclose</span>(privateKeyFile);</span><br><span class="line"></span><br><span class="line">    BIO* bio = <span class="built_in">BIO_new</span>(<span class="built_in">BIO_s_mem</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将公钥写入BIO</span></span><br><span class="line">    <span class="built_in">PEM_write_bio_RSA_PUBKEY</span>(bio, rsa);</span><br><span class="line">    <span class="type">char</span>* publicKeyData;</span><br><span class="line">    <span class="type">long</span> publicKeyLength = <span class="built_in">BIO_get_mem_data</span>(bio, &amp;publicKeyData);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Public Key:\n%s\n&quot;</span>, publicKeyData);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清空BIO</span></span><br><span class="line">    <span class="built_in">BIO_reset</span>(bio);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将私钥写入BIO</span></span><br><span class="line">    <span class="built_in">PEM_write_bio_RSAPrivateKey</span>(bio, rsa, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">char</span>* privateKeyData;</span><br><span class="line">    <span class="type">long</span> privateKeyLength = <span class="built_in">BIO_get_mem_data</span>(bio, &amp;privateKeyData);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Private Key:\n%s\n&quot;</span>, privateKeyData);</span><br><span class="line">    <span class="comment">//释放BIO</span></span><br><span class="line">    <span class="built_in">BIO_free</span>(bio);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//释放资源</span></span><br><span class="line">    <span class="built_in">RSA_free</span>(rsa);</span><br><span class="line">    <span class="built_in">BN_free</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="openssl生成公钥和私钥命令"><a href="#openssl生成公钥和私钥命令" class="headerlink" title="openssl生成公钥和私钥命令"></a>openssl生成公钥和私钥命令</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成私钥：这将生成一个RSA算法的私钥，并将其保存在名为private_key.pem的文件中。私钥将使用AES-256加密。</span></span><br><span class="line">openssl genpkey -algorithm RSA -out private_key.pem -aes256</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">生成公钥：这将从private_key.pem文件中提取私钥，并生成相应的公钥。公钥将保存在名为public_key.pem的文件中。</span></span><br><span class="line">openssl rsa -pubout -in private_key.pem -out public_key.pem</span><br></pre></td></tr></table></figure>

<h5 id="openssl公私密钥使用案例"><a href="#openssl公私密钥使用案例" class="headerlink" title="openssl公私密钥使用案例"></a>openssl公私密钥使用案例</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/rsa.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/pem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加密函数</span></span><br><span class="line"><span class="function">std::string <span class="title">encrypt</span><span class="params">(<span class="type">const</span> std::string&amp; plaintext, RSA* publicKey)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> keySize = <span class="built_in">RSA_size</span>(publicKey);</span><br><span class="line">    <span class="function">std::string <span class="title">ciphertext</span><span class="params">(keySize, <span class="string">&#x27;\0&#x27;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> encryptedSize = <span class="built_in">RSA_public_encrypt</span>(plaintext.<span class="built_in">size</span>(), <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>*&gt;(plaintext.<span class="built_in">data</span>()),</span><br><span class="line">                                           <span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">char</span>*&gt;(ciphertext.<span class="built_in">data</span>()), publicKey, RSA_PKCS1_OAEP_PADDING);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (encryptedSize == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 加密失败</span></span><br><span class="line">        <span class="comment">// 处理错误逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ciphertext.<span class="built_in">resize</span>(encryptedSize);</span><br><span class="line">    <span class="keyword">return</span> ciphertext;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解密函数</span></span><br><span class="line"><span class="function">std::string <span class="title">decrypt</span><span class="params">(<span class="type">const</span> std::string&amp; ciphertext, RSA* privateKey)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> keySize = <span class="built_in">RSA_size</span>(privateKey);</span><br><span class="line">    <span class="function">std::string <span class="title">plaintext</span><span class="params">(keySize, <span class="string">&#x27;\0&#x27;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> decryptedSize = <span class="built_in">RSA_private_decrypt</span>(ciphertext.<span class="built_in">size</span>(), <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>*&gt;(ciphertext.<span class="built_in">data</span>()),</span><br><span class="line">                                            <span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">char</span>*&gt;(plaintext.<span class="built_in">data</span>()), privateKey, RSA_PKCS1_OAEP_PADDING);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (decryptedSize == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 解密失败</span></span><br><span class="line">        <span class="comment">// 处理错误逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    plaintext.<span class="built_in">resize</span>(decryptedSize);</span><br><span class="line">    <span class="keyword">return</span> plaintext;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 加载公钥</span></span><br><span class="line">    FILE* publicKeyFile = <span class="built_in">fopen</span>(<span class="string">&quot;public_key.pem&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    RSA* publicKey = <span class="built_in">PEM_read_RSA_PUBKEY</span>(publicKeyFile, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">fclose</span>(publicKeyFile);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载私钥</span></span><br><span class="line">    FILE* privateKeyFile = <span class="built_in">fopen</span>(<span class="string">&quot;private_key.pem&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    RSA* privateKey = <span class="built_in">PEM_read_RSAPrivateKey</span>(privateKeyFile, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">fclose</span>(privateKeyFile);</span><br><span class="line"></span><br><span class="line">    std::string plaintext = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加密</span></span><br><span class="line">    std::string ciphertext = <span class="built_in">encrypt</span>(plaintext, publicKey);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解密</span></span><br><span class="line">    std::string decryptedText = <span class="built_in">decrypt</span>(ciphertext, privateKey);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Plaintext: &quot;</span> &lt;&lt; plaintext &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Ciphertext: &quot;</span> &lt;&lt; ciphertext &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Decrypted Text: &quot;</span> &lt;&lt; decryptedText &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="built_in">RSA_free</span>(publicKey);</span><br><span class="line">    <span class="built_in">RSA_free</span>(privateKey);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="常见的加密算法的逆向特征"><a href="#常见的加密算法的逆向特征" class="headerlink" title="常见的加密算法的逆向特征"></a>常见的加密算法的逆向特征</h1><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/320ff95dff2d">参考网址跳转</a></p>
<h2 id="取盐算法"><a href="#取盐算法" class="headerlink" title="取盐算法"></a>取盐算法</h2><blockquote>
<p>取盐 算法，也叫 摘要算法，是对数据进行一系列运算后，截取一部分关键值进行校验。因此运算过程 不可逆，无法还原出加密前的 初始文本。取盐算法得到的结果长度一般是固定的，无论输入的消息有多长，计算出来的消息摘要的长度总是固定的。一般地，只要输入的文本不同，对其进行摘要以后产生的摘要消息也必不相同，但相同的文本输入必会产生相同的输出。</p>
</blockquote>
<p>在密码学中，<code>盐（Salt）</code>是指通过在密码任意固定位置插入特定的字符串，让散列后的结果和使用原始密码的散列结果不相符，这种过程称之为“加盐”。这样可以增加破解难度，提高密码安全性。</p>
<p><strong>取盐算法</strong>是指如何选择盐</p>
<h3 id="MD5逆向特征"><a href="#MD5逆向特征" class="headerlink" title="MD5逆向特征"></a>MD5逆向特征</h3><ul>
<li><p>字符串为 16 进制，即数字英文组合，而且 英文最大是字母 <code>f</code> 。</p>
</li>
<li><p>位数为 16、32。</p>
</li>
<li><p>搜索关键字：</p>
<p>– 关键词：md5、MD5</p>
<p>– 默认的 key 值：0123456789abcdef、0123456789ABCDEF</p>
<p>– 原始MD5的魔法值（16进制）：0x67452301、0xefcdab89、0x98badcfe、0x10325476</p>
<p>– 原始MD5的魔法值（10进制）：1732584193、271733879、1732584194、271733878</p>
</li>
<li><p>123456 计算结果值：</p>
</li>
<li><p>16 位，结果值 49 开头。</p>
<p>– 16位小写计算结果：49ba59abbe56e057</p>
<p>– 16位大写计算结果：49BA59ABBE56E057</p>
</li>
<li><p>32 位，结果值 e10、E10 开头。</p>
<p>– 32位小写计算结果：e10adc3949ba59abbe56e057f20f883e</p>
<p>– 32位小写计算结果：E10ADC3949BA59ABBE56E057F20F883E</p>
</li>
</ul>
<p>注意：16位 的结果值是 32位 的结果值的一部分。</p>
<h3 id="SHA逆向特征"><a href="#SHA逆向特征" class="headerlink" title="SHA逆向特征"></a>SHA逆向特征</h3><ul>
<li>字符串为 16 进制，即数字英文组合，而且 英文最大是字母 f </li>
<li>位数为 40、64、96、128 等，位数均是 8 的倍数。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//123456 计算结果值：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//SHA1：40 位：</span></span><br><span class="line"><span class="number">7</span>c4a8d09ca3762af<span class="number">61e59520943</span>dc26494f8941b</span><br><span class="line"></span><br><span class="line"><span class="comment">//SHA256：64 位：</span></span><br><span class="line"><span class="number">8</span>d969eef6ecad3c29a3a<span class="number">629280e686</span>cf0c3f5d5a86aff3ca12020c923adc6c92</span><br><span class="line"></span><br><span class="line"><span class="comment">//SHA384：96 位：</span></span><br><span class="line"><span class="number">0</span>a989ebc4a77b56a<span class="number">6e2</span>bb7b19d995d185ce44090c<span class="number">13e2984</span>b7ecc6d446d4b61ea9991b76a4c2f04b1b4d244841449454</span><br><span class="line"></span><br><span class="line"><span class="comment">//SHA512：128 位：</span></span><br><span class="line">ba3253876aed6bc22d4a6ff53d8406c6ad864195ed144ab5c87621b6c233b548baeae6956df346ec8c17f5ea10f35ee3cbc514797ed7ddd<span class="number">3145464e2</span>a0bab413</span><br></pre></td></tr></table></figure>

<h2 id="可还原加密算法"><a href="#可还原加密算法" class="headerlink" title="可还原加密算法"></a>可还原加密算法</h2><p>特征：</p>
<ol>
<li>字符串为 16 进制，即数字英文组合，而且 英文最大是字母 f 。</li>
<li>字符串为 base64 编码形式，由数字 <code>0-9</code>、小写字母 <code>a-z</code>、大写字母 <code>A-Z</code> 以及字符 +、_、&#x3D; 组成，且最后一个或最后两个字符为 <code>=</code>。通常而言 Base64 的识别特征为索引表，当我们能找到 <code>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/</code> 这样索引表，再经过简单的分析基本就能判定是 Base64 编码。</li>
</ol>
<h3 id="RSA逆向特征"><a href="#RSA逆向特征" class="headerlink" title="RSA逆向特征"></a>RSA逆向特征</h3><blockquote>
<p>RSA 是典型的 非对称加密，拥有一个公钥和一个私钥。</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">其中：</span><br><span class="line">-- 客户端（浏览器）拥有公钥，服务器同时拥有公钥和私钥。</span><br><span class="line">-- 同一个明文可以生成不同的密文。</span><br><span class="line">-- 必须先 <span class="keyword">new</span> JSEncrypt 加密对象，然后 setPublicKey。</span><br></pre></td></tr></table></figure>

<ul>
<li>加密后的数据长度不可能是 8 的倍数。</li>
<li>搜索关键词：<code>new JSEncrypt</code>、<code>setpublickey</code>、<code>ABCDEFG</code>、<code>abcdefg</code>。</li>
</ul>
<h3 id="AES逆向特征"><a href="#AES逆向特征" class="headerlink" title="AES逆向特征"></a>AES逆向特征</h3><p>AES 是 对称加密 的一种。</p>
<ul>
<li>一般AES加密出来的数据是128 或 256 的整倍数。</li>
<li>搜索关键词：cryptojs.aes、encryptedString、010001（或类似二进制模值）。</li>
</ul>
<h3 id="DES逆向特征"><a href="#DES逆向特征" class="headerlink" title="DES逆向特征"></a>DES逆向特征</h3><p>搜索关键词：<code>cryptojs.des.encrypt</code>。</p>
<h2 id="其他编码算法"><a href="#其他编码算法" class="headerlink" title="其他编码算法"></a>其他编码算法</h2><h3 id="Base64-逆向特征"><a href="#Base64-逆向特征" class="headerlink" title="Base64 逆向特征"></a>Base64 逆向特征</h3><ul>
<li>字符串的长度为4的整数倍。</li>
<li>字符串的符号取值只能在 <code>A-Z</code>, <code>a-z</code>, <code>0-9</code>, <code>+</code>, <code>/</code>, <code>=</code> 共计 65 个字符中，且 <code>=</code> 如果出现就必须在结尾出现。</li>
</ul>
<h1 id="AES算法"><a href="#AES算法" class="headerlink" title="AES算法"></a>AES算法</h1><blockquote>
<p>AES是一套对称密钥的密码术，目前已广泛使用，用于替代已经不够安全的DES算法。所谓对称密钥，就是说加密和解密用的是同一个密钥，消息的发送方和接收方在消息传递前需要享有这个密钥。和非对称密钥体系不同，这里的密钥是双方保密的，不会让任何第三方知道。</p>
</blockquote>
<p>对称密钥加密法主要<strong>基于块加密</strong>，选取固定长度的密钥，去加密明文中固定长度的块，生成的密文块,与明文块长度一样。显然密钥长度十分重要，块的长度也很重要。如果太短，则很容易枚举出所有的明文-<br>密文映射；如果太长，性能则会急剧下降。AES中规定块长度为128 bit，而密钥长度可以选择128,192或256 bit 。暴力破解密钥需要万亿年，这保证了AES的安全性。</p>
<h2 id="OpenSSL中的AES算法"><a href="#OpenSSL中的AES算法" class="headerlink" title="OpenSSL中的AES算法"></a>OpenSSL中的AES算法</h2><p>头文件: <strong><code>&lt;openssl/aes.h&gt;</code></strong></p>
<h3 id="生成加密-解密的Key"><a href="#生成加密-解密的Key" class="headerlink" title="生成加密&#x2F;解密的Key"></a>生成加密&#x2F;解密的Key</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> AES_BLOCK_SIZE 16 <span class="comment">// 明文分组的大小</span></span></span><br><span class="line"><span class="comment">// 加密的时候调用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">AES_set_encrypt_key</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *userKey, <span class="type">const</span> <span class="type">int</span> bits, AES_KEY *key)</span></span>;</span><br><span class="line"><span class="comment">//- 参数userKey: 数据加密使用的原始秘钥(字符串)</span></span><br><span class="line"><span class="comment">//- 参数bits: 秘钥字符串占的位数</span></span><br><span class="line"><span class="comment">//- 参数key: 传出参数, 供后续AES api加密使用的秘钥类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解密时候使用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">AES_set_decrypt_key</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *userKey, <span class="type">const</span> <span class="type">int</span> bits, AES_KEY *key)</span></span>;</span><br><span class="line"><span class="comment">//- 参数userKey: 数据解码密使用的原始秘钥(字符串)</span></span><br><span class="line"><span class="comment">//- 参数bits: 秘钥字符串占的位数</span></span><br><span class="line"><span class="comment">//- 参数key: 传出参数, 供后续AES api解密使用的秘钥类型</span></span><br><span class="line"><span class="comment">//同上,成功返回0,失败返回1</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>userKey</td>
<td>16字节&#x2F;24字节&#x2F;32字节</td>
</tr>
<tr>
<td>bits</td>
<td>128bit&#x2F;192bit&#x2F;256bit</td>
</tr>
<tr>
<td>key</td>
<td>传出, 后续加解密API需要用到</td>
</tr>
</tbody></table>
<h3 id="加解密函数"><a href="#加解密函数" class="headerlink" title="加解密函数"></a>加解密函数</h3><p>下面使用的其实就是<strong>ECB分组模式</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要求使用以下两个api时候参数in必须是16的整数倍, 如果不是需要将最后一组补足16字节</span></span><br><span class="line"><span class="comment">// 解密的时候需要将最后一个分组添加的末尾字节删除</span></span><br><span class="line"><span class="comment">// 加密函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AES_encrypt</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *in, <span class="type">unsigned</span> <span class="type">char</span> *out, <span class="type">const</span> AES_KEY *key)</span></span>;</span><br><span class="line"><span class="comment">//- 参数in: 要加密的原始数据 - 明文</span></span><br><span class="line"><span class="comment">//- 参数out: 传出, 加密之后 对数据 - 密文</span></span><br><span class="line"><span class="comment">//- 参数key: 通过AES_set_encrypt_key得到的key值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解密函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AES_decrypt</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *in, <span class="type">unsigned</span> <span class="type">char</span> *out, <span class="type">const</span> AES_KEY *key)</span></span>;</span><br><span class="line"><span class="comment">//- 参数in: 要被解密的密文</span></span><br><span class="line"><span class="comment">//- 参数out: 解密后得到明文</span></span><br><span class="line"><span class="comment">//- 参数key: AES_set_decrypt_key得到的key值</span></span><br></pre></td></tr></table></figure>

<h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a><strong>案例</strong></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> len = <span class="built_in">strlen</span>(data); <span class="comment">// 已经是16的整数倍</span></span><br><span class="line"><span class="type">int</span> tmpLen = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span>* intbuf = data;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> outbuf[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">while</span>(tmpLen &lt; len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">AES_encrypt</span>(inbuf, &amp;outbuf, key);</span><br><span class="line">inbuf += <span class="number">16</span>;</span><br><span class="line">outbuf += <span class="number">16</span>;</span><br><span class="line">tmpLen += <span class="number">16</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//若不是16的整数倍, 则需要在末尾进行补齐, 如何补齐呢? 在补齐的时候, 缺几个就补几, 如:</span></span><br><span class="line"><span class="comment">//最后的一组, 缺7个字节, 则最后都补7, xxxxxxx7777777</span></span><br><span class="line"><span class="comment">//如果正好是16的整数倍, 则最后需要补上16个字节(如补上一个P), 解码之后再删掉就可以了.</span></span><br></pre></td></tr></table></figure>

<h4 id="ECB方式加密"><a href="#ECB方式加密" class="headerlink" title="ECB方式加密"></a>ECB方式加密</h4><p><strong>电子密码本模式</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AES_ecb_encrypt</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *in, <span class="type">unsigned</span> <span class="type">char</span> *out,<span class="type">const</span> AES_KEY *key, <span class="type">const</span> <span class="type">int</span> enc)</span></span>;</span><br><span class="line"><span class="comment">//- 参数in: 要加密/解密的数据, 长度在8字节范围就就可以</span></span><br><span class="line"><span class="comment">//- 参数out: 传出参数, 得到的明文/密文</span></span><br><span class="line"><span class="comment">//- 参数key:</span></span><br><span class="line"><span class="comment">//- 参数enc: 指定进行加密或者解密</span></span><br><span class="line">	<span class="comment">//- # define AES_ENCRYPT 1</span></span><br><span class="line">	<span class="comment">//- # define AES_DECRYPT 0</span></span><br></pre></td></tr></table></figure>

<p>函数的使用方式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个函数调用一次只能处理8字节</span></span><br><span class="line"><span class="keyword">while</span>(条件)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">AES_ecb_encrypt</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CBC方式加密"><a href="#CBC方式加密" class="headerlink" title="CBC方式加密"></a>CBC方式加密</h4><p><strong>密码分组链接模式</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AES_cbc_encrypt</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *in, <span class="type">unsigned</span> <span class="type">char</span> *out,<span class="type">size_t</span> length, <span class="type">const</span> AES_KEY *key,<span class="type">unsigned</span> <span class="type">char</span> *ivec, <span class="type">const</span> <span class="type">int</span> enc)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>参数**<code>in</code>**: 要加密&#x2F;解密的数据</p>
</li>
<li><p>参数**<code>out</code>**: 通过加密得到的密文&#x2F;通过解密得到的明文</p>
</li>
<li><p>参数**<code>Length</code>**: 修饰的是in参数</p>
<ul>
<li><p>如果in长度(需要加上<code>&#39;\0&#39;</code>长度)是16的整数倍, 那么length就等于该长度</p>
<p><code>length = strlen(in)+1;</code>   (1就是尾部的’\0’)</p>
</li>
<li><p>in的长度(需要加上<code>&#39;\0&#39;</code>长度)不是16的整数倍, 需要将其变成16的整数倍</p>
<p>计算当前有多少个分组 <code>gourp = (strlen(in)+1) / 16;</code></p>
<p>将最后不满16字节的分组添加进来并将其字节数填充到16字节</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">group=group+1</span><br><span class="line">length = group * 16</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>参数**<code>key</code>**: 通过AES_set_encrypt_key得到的key值&#x2F; AES_set_decrypt_key得到的key值</p>
</li>
<li><p>参数**<code>ivec</code>**:</p>
<ul>
<li>随机字符串, 长度和明文分组长度相同.</li>
<li>参与加解密的初始化向量的值必须相同</li>
</ul>
</li>
<li><p>参数**<code>enc</code>**:</p>
<ul>
<li><code># define AES_ENCRYPT 1</code></li>
<li><code># define AES_DECRYPT 0</code></li>
</ul>
</li>
</ul>
<h5 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* mykey = <span class="string">&quot;0123456789abcdef&quot;</span>;</span><br><span class="line">AES_KEY key;</span><br><span class="line"><span class="built_in">AES_set_encrypt_key</span>((<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>*)mykey,<span class="number">128</span>,&amp;key);</span><br><span class="line"><span class="comment">//需要加密的字符串</span></span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line"><span class="type">char</span> *mystr = <span class="string">&quot;hello world,hao are you, i am fine, thank you&quot;</span>;</span><br><span class="line"><span class="comment">//计算第三个参数length的长度,包含了字符串末尾的\0</span></span><br><span class="line"><span class="keyword">if</span>((<span class="built_in">strlen</span>(mystr) + <span class="number">1</span>)%<span class="number">16</span> == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//长度刚好合适</span></span><br><span class="line">    length = <span class="built_in">strlen</span>(mystr)<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    length = ((<span class="built_in">strlen</span>(mystr) + <span class="number">1</span>)/<span class="number">16</span> <span class="number">+1</span>)*<span class="number">16</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* encrypt = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">calloc</span>(length,<span class="number">1</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> iv[<span class="number">16</span>];</span><br><span class="line"><span class="built_in">memset</span>(iv,<span class="string">&#x27;a&#x27;</span>,<span class="built_in">sizeof</span>(iv));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;iv[&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;]==[&quot;</span>&lt;&lt;iv[i]&lt;&lt;<span class="string">&quot;]&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">AES_cbc_encrypt</span>((<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>*)mystr,encrypt,length,&amp;key,iv,AES_ENCRYPT);</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;====================&quot;</span>&lt;&lt;std::endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;iv[&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;]==[&quot;</span>&lt;&lt;iv[i]&lt;&lt;<span class="string">&quot;]&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;加密后内容为:&quot;</span>&lt;&lt;encrypt&lt;&lt;endl;</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;====================&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;下面是解密&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;====================&quot;</span>&lt;&lt;std::endl;</span><br><span class="line"><span class="built_in">AES_set_decrypt_key</span>((<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>*)mykey,<span class="number">128</span>,&amp;key);</span><br><span class="line"><span class="built_in">memset</span>(iv,<span class="string">&#x27;a&#x27;</span>,<span class="built_in">sizeof</span>(iv));</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *decrypt = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">calloc</span>(length,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">AES_cbc_encrypt</span>(encrypt,decrypt,length,&amp;key,iv,AES_DECRYPT);</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;iv[&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;]==[&quot;</span>&lt;&lt;iv[i]&lt;&lt;<span class="string">&quot;]&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;解密后的内容为:&quot;</span>&lt;&lt;decrypt&lt;&lt;std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">iv[0]==[a]</span><br><span class="line">iv[1]==[a]</span><br><span class="line">iv[2]==[a]</span><br><span class="line">iv[3]==[a]</span><br><span class="line">iv[4]==[a]</span><br><span class="line">iv[5]==[a]</span><br><span class="line">iv[6]==[a]</span><br><span class="line">iv[7]==[a]</span><br><span class="line">iv[8]==[a]</span><br><span class="line">iv[9]==[a]</span><br><span class="line">iv[10]==[a]</span><br><span class="line">iv[11]==[a]</span><br><span class="line">iv[12]==[a]</span><br><span class="line">iv[13]==[a]</span><br><span class="line">iv[14]==[a]</span><br><span class="line">iv[15]==[a]</span><br><span class="line">====================</span><br><span class="line">iv[0]==[r]</span><br><span class="line">iv[1]==[8]</span><br><span class="line">iv[2]==[V]</span><br><span class="line">iv[3]==[]</span><br><span class="line">iv[4]==[]</span><br><span class="line">iv[5]==[�]</span><br><span class="line">iv[6]==[�]</span><br><span class="line">iv[7]==[a]</span><br><span class="line">iv[8]==[_]</span><br><span class="line">iv[9]==[~]</span><br><span class="line">iv[10]==[�]</span><br><span class="line">iv[11]==[�]</span><br><span class="line">iv[12]==[]</span><br><span class="line">iv[13]==[�]</span><br><span class="line">iv[14]==[]]</span><br><span class="line">iv[15]==[�]</span><br><span class="line">加密后内容为:T��h�u�f�&#123;&amp;y�]&amp;�7�h���(���</span><br><span class="line">                                       n�pr8V��a_~���]�</span><br><span class="line">====================</span><br><span class="line">下面是解密</span><br><span class="line">====================</span><br><span class="line">iv[0]==[r]</span><br><span class="line">iv[1]==[8]</span><br><span class="line">iv[2]==[V]</span><br><span class="line">iv[3]==[]</span><br><span class="line">iv[4]==[]</span><br><span class="line">iv[5]==[�]</span><br><span class="line">iv[6]==[�]</span><br><span class="line">iv[7]==[a]</span><br><span class="line">iv[8]==[_]</span><br><span class="line">iv[9]==[~]</span><br><span class="line">iv[10]==[�]</span><br><span class="line">iv[11]==[�]</span><br><span class="line">iv[12]==[]</span><br><span class="line">iv[13]==[�]</span><br><span class="line">iv[14]==[]]</span><br><span class="line">iv[15]==[�]</span><br><span class="line">解密后的内容为:hello world,hao are you, i am fine, thank you</span><br></pre></td></tr></table></figure>

<h1 id="单向散列函数"><a href="#单向散列函数" class="headerlink" title="单向散列函数"></a>单向散列函数</h1><p>用于获取消息的**”指纹”**</p>
<blockquote>
<p>单向散列函数（one-wayftnction）有一个输入和一个输出，其中输入称为<strong>消息</strong>（message），输出称为<strong>散列值</strong>（hashvalue）。单向散列函数可以根据消息的内容计算出散列值，而散列值就可以被用来检查消息的完整性。</p>
</blockquote>
<ul>
<li>单向散列函数也称为<strong>消息摘要函数</strong>（message digest function）、<strong>哈希函数</strong>或者<strong>杂凑函数</strong>。</li>
<li>单向散列函数输出的散列值也称为<strong>消息摘要</strong>（message digest）或者<strong>指纹</strong>（fifingerprint）。</li>
<li>完整性也称为一致性。</li>
</ul>
<h2 id="哈希函数特点"><a href="#哈希函数特点" class="headerlink" title="哈希函数特点"></a>哈希函数特点</h2><ul>
<li><p><strong>压缩性</strong> :  任意长度的数据，算出的值长度都是固定的</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202302221517723.png" alt="image-20230222151732365" style="zoom: 33%;" />
</li>
<li><p><strong>容易计算</strong> : 计算散列值所花费的时间必须要短。尽管消息越长，计算散列值的时间也会越长，但如果不能在现实的<br>时间内完成计算就没有意义了。</p>
</li>
<li><p><strong>抗修改性</strong> : 对原数据进行任何改动，哪怕只修改1个字节，所得到的值都有很大区别</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202302221520297.png" alt="image-20230222152018854" style="zoom: 50%;" />
</li>
<li><p>强抗碰撞性 : 已知原数据和其哈希值，想找到一个具有相同哈希值的数据（即伪造数据）是非常困难的</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202302231408999.png" alt="image-20230223140813788" style="zoom: 50%;" />
</li>
<li><p>单向性（不可逆）</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202302231409550.png" alt="image-20230223140857182" style="zoom:50%;" /></li>
</ul>
<h2 id="哈希函数的应用"><a href="#哈希函数的应用" class="headerlink" title="哈希函数的应用"></a>哈希函数的应用</h2><h3 id="检测软件是否被篡改"><a href="#检测软件是否被篡改" class="headerlink" title="检测软件是否被篡改"></a>检测软件是否被篡改</h3><blockquote>
<p>我们可以使用单向散列函数来确认自己下载的软件是否被篡改。很多软件，尤其是安全相关的软件都会把通过单向散列函数计算出的散列值公布在自己的官方网站上。用户在下载到软件之后，可以自行计算散列值，然后与官方网站上公布的散列值进行对比。通过散列<br>值，用户可以确认自己所下载到的文件与软件作者所提供的文件是否一致。这样的方法，在可以通过多种途径得到软件的情况下非常有用。为了减轻服务器的压力，很多软件作者都会借助多个网站（镜像站点）来发布软件，在这种情况下，单向散列函数就会在检测软件是否被篡改方面发挥重要作用。</p>
</blockquote>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202302231420018.png" alt="image-20230223141955553" style="zoom: 50%;" />

<h3 id="消息认证码-1"><a href="#消息认证码-1" class="headerlink" title="消息认证码"></a>消息认证码</h3><blockquote>
<p>使用单向散列函数可以构造消息认证码。<br>消息认证码是将“发送者和接收者之间的共享密钥”和“消息，进行混合后计算出的散列值。使用消息认证码可以检测并防止通信过程中的错误、篡改以及伪装</p>
</blockquote>
<p>对于发送端:</p>
<ul>
<li>将要发送的数据进行哈希运算, 参与运算的数据是: 原始数据+秘钥, 可以得到一个散列值</li>
<li>将散列值与原始数据进行拼接, 一起发送给对方;</li>
</ul>
<p>对于接收端:</p>
<ul>
<li>接收对方发来的数据, 并将原始数据和散列值拆分开, 得到散列值和原始数据</li>
<li>对原始数据进行哈希运算: 参与运算的数据也是:原始数据+秘钥, 可以得到一个散列值</li>
<li>将计算得到的散列值与接受到的散列值进行比较, 相同则认为没有被篡改, 否则认为被篡改了.</li>
</ul>
<p>注意: 发送方和接受方使用的秘钥是<strong>同一个秘钥</strong>(<strong>对称秘钥</strong>,秘钥分发困难), 这个秘钥只有发送方和接受方知道,<br>若这个秘钥被第三方知道了, 就没有办法保证数据的是安全的了</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202302231557592.png" alt="image-20230223155717235" style="zoom:50%;" />

<h3 id="数字签名-1"><a href="#数字签名-1" class="headerlink" title="数字签名"></a>数字签名</h3><blockquote>
<p>在进行数字签名时也会使用单向散列函数。<br>数字签名是现实社会中的签名（sign）和盖章这样的行为在数字世界中的实现。数字签名的处理过程非常耗时，因此一般不会对整个消息内容直接施加数字签名，而是先通过单向散列函数计算出消息的散列值，然后再对这个散列值施加数字签名。</p>
</blockquote>
<p>使用的是非对称加密, 有公钥和私钥</p>
<p>数字签名流程: </p>
<ol>
<li>A将明文进行哈希运算得到一个散列值, 并且用私钥对哈希值进行加密, 然后将明文和加了密的哈希值一起发送给B;</li>
<li>B收到之后, 使用公钥对哈希值进行解密, 得到原始的哈希值, 并且对明文进行哈希运算也得到一个哈希值, 最后对自己生成的哈希值和A发送过来的哈希值进行比较, 如果一样, 则认为没有被篡改.</li>
</ol>
<p>使用数字签名的目的是为了<strong>不可抵赖性</strong>.(表明拿私钥的一方发送的数据, 是不可抵赖的)</p>
<h3 id="一次性口令或登录验证"><a href="#一次性口令或登录验证" class="headerlink" title="一次性口令或登录验证"></a>一次性口令或登录验证</h3><p><strong>一次性口令</strong></p>
<p>使用单向散列函数可以构造一次性口令（one-time password）。<br>一次性口令经常被用于服务器对客户端的合法性认证。在这种方式中，通过使用单向散列函数可以<strong>保证口令只在通信链路上传送一次（one-time）</strong>，因此即使窃听者窃取了口令，也无法使用。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202302231855096.jpeg" alt="v2-905cef8c0aca6a43e1529f4a14901d56_r" style="zoom:50%;" />

<p><strong>登录验证</strong></p>
<p>当用户登录的时候, 需要输入密码, 这个密码会经过加密运算, 经过运算之后的值再与服务器中保存的密码进行比较, 若相同则输入密码正确, 允许登录.<br>若用户忘记密码, 则只能重置密码, 服务端并不知道用户原来的明文, 只能是重新设置</p>
<h2 id="常用的哈希函数"><a href="#常用的哈希函数" class="headerlink" title="常用的哈希函数"></a>常用的哈希函数</h2><h3 id="Md4-Md5"><a href="#Md4-Md5" class="headerlink" title="Md4&#x2F;Md5"></a>Md4&#x2F;Md5</h3><blockquote>
<p>MD4是由Rivest于1990年设计的单向散列函数，能够产生&#x3D;&#x3D;128比特&#x3D;&#x3D;的散列值（RFC1186，修订版RFC1320）。不过，随着Dobbertin提出寻找MD4散列碰撞的方法，因此现在它已经不安全了。<br>MD5是由Rwest于1991年设计的单项散列函数，能够产生&#x3D;&#x3D;128比特&#x3D;&#x3D;的散列值（RFC1321）。<br>MD5的强抗碰撞性已经被攻破，也就是说，现在已经能够产生具备相同散列值的两条不同的消息，因此它也已经不安全了。<br>MD4和MD5中的MD是消息摘要（Message Digest）的缩写。</p>
</blockquote>
<h3 id="SHA-1-SHA-256-SHA-384-SHA-512"><a href="#SHA-1-SHA-256-SHA-384-SHA-512" class="headerlink" title="SHA-1&#x2F;SHA-256&#x2F;SHA-384&#x2F;SHA-512"></a>SHA-1&#x2F;SHA-256&#x2F;SHA-384&#x2F;SHA-512</h3><blockquote>
<p>SHA-1是由NIST（National Institute Of Standardsand Technology，美国国家标准技术研究所）设计的一种能够产生&#x3D;&#x3D;160比特&#x3D;&#x3D;的散列值的单向散列函数。1993年被作为美国联邦信息处理标准规格（FIPS PUB 180）发布的是SHA,1995年发布的修订版FIPS PUB 180-1称为SHA-1。<br>SHA-1的消息长度存在上限，但这个值接近于2^64^比特，是个非常巨大的数值，因此在实际应用中没<br>有问题。<br>SHA-256、SHA-384和SHA-512都是由NIST设计的单向散列函数，它们的散列值长度分别为&#x3D;&#x3D;256比特&#x3D;&#x3D;、&#x3D;&#x3D;384&#x3D;&#x3D;比特和&#x3D;&#x3D;512比特&#x3D;&#x3D;。这些单向散列函数合起来统称SHA-2，它们的消息长度也存在上限（SHA-256的上限接近于 2^64^ 比特，SHA-384 和 SHA-512的上限接近于 2^128^ 比特）。这些单向散列函数是于2002年和 SHA-1 一起作为 FIPS PUB 180-2发布的 SHA-1 的强抗碰撞性已于2005年被攻破, 也就是说，现在已经能够产生具备相同散列值的两条不同的消息。不过，SHA-2还尚未被攻破</p>
</blockquote>
<table>
<thead>
<tr>
<th>哈希函数</th>
<th>散列值长度(bit)</th>
<th>散列值长度(byte)</th>
</tr>
</thead>
<tbody><tr>
<td>Md4&#x2F;Md5</td>
<td>128bit</td>
<td>16byte</td>
</tr>
<tr>
<td>SHA-1</td>
<td>160bit</td>
<td>20byte</td>
</tr>
<tr>
<td>SHA-224</td>
<td>224bit</td>
<td>28byte</td>
</tr>
<tr>
<td>SHA-256</td>
<td>256bit</td>
<td>32byte</td>
</tr>
<tr>
<td>SHA-384</td>
<td>384bit</td>
<td>48byte</td>
</tr>
<tr>
<td>SHA-512</td>
<td>512bit</td>
<td>64byte</td>
</tr>
</tbody></table>
<p>  最终需要对得到的散列值做转换, 以16进制格式的字符串表</p>
<h2 id="openssl库中哈希函数用法"><a href="#openssl库中哈希函数用法" class="headerlink" title="openssl库中哈希函数用法"></a>openssl库中哈希函数用法</h2><p>头文件位置(<code>-I</code>)    <code>openssl根目录/include/openssl/</code></p>
<p>库文件位置(<code>-L</code>)   <code>openssl根目录/lib</code></p>
<p>win下添加<strong>附加依赖项</strong>:<code>libcrypto.lib</code>和<code>libssl.lib</code> (无法解析的外部符号报错)</p>
<p>linux下添加附加依赖项: <code>-lssl  -lcrypto</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种方式(第二种方式为第一种方式的封装)</span></span><br><span class="line"><span class="comment">// 初始化一个MD5_CTX类型的变量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">MD5_Init</span><span class="params">(MD5_CTX *c)</span>;</span><br><span class="line">- c: 传出</span><br><span class="line"><span class="comment">// 给哈希函数添加要运算的数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">MD5_Update</span><span class="params">(MD5_CTX *c, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> len)</span>;</span><br><span class="line">- C: 传入</span><br><span class="line">- data: 传入, 要进行哈希运算的数据</span><br><span class="line">- len: data参数的长度</span><br><span class="line">文件<span class="number">1</span>G</span><br><span class="line"><span class="title function_">while</span><span class="params">(read(fd, buf, len))</span></span><br><span class="line">&#123;</span><br><span class="line">MD5_Update(c, buf, buflen);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算结果</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">MD5_Final</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *md, MD5_CTX *c)</span>;</span><br><span class="line">- md传出参数, 需要将计算出的散列值保存到md中</span><br><span class="line">- c: 出入</span><br><span class="line"><span class="comment">//=========================================</span></span><br><span class="line"><span class="comment">// 第二种方式</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">MD5</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *d, <span class="type">size_t</span> n, <span class="type">unsigned</span> <span class="type">char</span> *md)</span>;</span><br><span class="line">- d: 要进行哈希运算的字符串</span><br><span class="line">- n: 第一个参数的长度</span><br><span class="line">- md: 计算出的散列值</span><br><span class="line">返回值:</span><br><span class="line">得到的散列值</span><br><span class="line"><span class="comment">//===========================================================================</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">SHA1_Init</span><span class="params">(SHA_CTX *c)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">SHA1_Update</span><span class="params">(SHA_CTX *c, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> len)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">SHA1_Final</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *md, SHA_CTX *c)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">SHA1</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *d, <span class="type">size_t</span> n, <span class="type">unsigned</span> <span class="type">char</span> *md)</span>;</span><br><span class="line"><span class="comment">//上述几个函数的用法同md5的几个函数.</span></span><br></pre></td></tr></table></figure>

<p>相关的函数说明可以在openssl安装目录中去查看:</p>
<ul>
<li><code>C:\OpenSSL-Win32\include\openssl</code>, 如<code>md5.h</code>和<code>sha.h</code></li>
<li>能够用到的库名: <code>libssl.lib libcrypto.lib</code></li>
<li>使用到的库所在的路径: <code>C:\OpenSSL-Win32\lib</code></li>
<li>使用到的头文件所在的路径: <code>C:\OpenSSL-Win32\include</code></li>
</ul>
<p>注意: 在使用vs进行项目开发的时候, 需要指定头文件所在路径和库文件所在路径</p>
<p>可以用诸如<code>md5sum+文件路径</code>命令(<code>xxxsum</code>)直接计算得出md5值</p>
<h3 id="sha1简单案例"><a href="#sha1简单案例" class="headerlink" title="sha1简单案例"></a>sha1简单案例</h3><p>下面案例为vs下,需指定头文件所在路径和库文件所在路径以及添加依赖项</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/sha.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">char</span> md[SHA_DIGEST_LENGTH];</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">char</span> md1[SHA_DIGEST_LENGTH*<span class="number">2</span><span class="number">+1</span>];</span><br><span class="line">		<span class="type">const</span> <span class="type">char</span>* p = <span class="string">&quot;你好, 世界&quot;</span>;</span><br><span class="line">		<span class="built_in">SHA1</span>((<span class="type">unsigned</span> <span class="type">char</span>*)p, <span class="built_in">strlen</span>(p) + <span class="number">1</span>, md);</span><br><span class="line">		<span class="comment">//cout &lt;&lt; &quot;sha1: &quot; &lt;&lt; md &lt;&lt; endl; //若有不可见或者		是二进制数据, 使用cout会出现bug</span></span><br><span class="line">		<span class="comment">// 将散列值转换为16进制格式的字符串</span></span><br><span class="line">		<span class="comment">// base64</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SHA_DIGEST_LENGTH; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">				<span class="comment">// 将每个字符格式化010203</span></span><br><span class="line">				<span class="built_in">sprintf</span>((<span class="type">char</span>*)&amp;md1[i*<span class="number">2</span>], <span class="string">&quot;%02x&quot;</span>, md[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;sha1: &quot;</span> &lt;&lt; md1 &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="hmac简单案例"><a href="#hmac简单案例" class="headerlink" title="hmac简单案例"></a>hmac简单案例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面例子其实也是使用sha1的单向散列方式</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;openssl/hmac.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;openssl/sha.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HMAC_CTX *ctx = <span class="built_in">HMAC_CTX_new</span>();</span><br><span class="line">    <span class="type">char</span> key[] = <span class="string">&quot;&quot;</span>;<span class="comment">//密钥</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data[] = <span class="string">&quot;&quot;</span>;<span class="comment">//要单向散列的数据</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> md[SHA_DIGEST_LENGTH];<span class="comment">//单向散列输出的结果</span></span><br><span class="line">    <span class="type">char</span> mdBuf[SHA_DIGEST_LENGTH * <span class="number">2</span> + <span class="number">1</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 一个字节用两个字符来表示,因此乘2,该变量用于打印</span></span><br><span class="line">    <span class="comment">//HMAC_Init(ctx, key, strlen(key), EVP_sha1());//这个也可以代替下面那行</span></span><br><span class="line">    <span class="built_in">HMAC_Init_ex</span>(ctx, key, <span class="built_in">strlen</span>(key), <span class="built_in">EVP_sha1</span>(),<span class="literal">NULL</span>);<span class="comment">//设置sha1单向散列函数</span></span><br><span class="line">    <span class="built_in">HMAC_Update</span>(ctx, data, <span class="built_in">strlen</span>((<span class="type">const</span> <span class="type">char</span> *)data));</span><br><span class="line">    <span class="type">int</span> len = SHA_DIGEST_LENGTH;</span><br><span class="line">    <span class="built_in">HMAC_Final</span>(ctx, md, (<span class="type">unsigned</span> <span class="type">int</span> *)&amp;len); <span class="comment">// 哈希结果输出到md中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SHA_DIGEST_LENGTH; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(&amp;mdBuf[i * <span class="number">2</span>], <span class="string">&quot;%02x&quot;</span>, md[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; mdBuf &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 下面是第二种方式</span></span><br><span class="line">    <span class="built_in">memset</span>(md, <span class="number">0</span>, <span class="built_in">sizeof</span>(md));</span><br><span class="line">    <span class="comment">// 一行代码生成结果</span></span><br><span class="line">    <span class="built_in">HMAC</span>(<span class="built_in">EVP_sha1</span>(), key, <span class="built_in">strlen</span>(key), data, <span class="built_in">strlen</span>((<span class="type">const</span> <span class="type">char</span> *)data), md, (<span class="type">unsigned</span> <span class="type">int</span> *)&amp;len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SHA_DIGEST_LENGTH; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(&amp;mdBuf[i * <span class="number">2</span>], <span class="string">&quot;%02x&quot;</span>, md[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; mdBuf &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="base64编码"><a href="#base64编码" class="headerlink" title="base64编码"></a>base64编码</h1><blockquote>
<p>Base64是一种基于64个可打印字符来表示二进制数据的表示方法.在Base64中的可打印字符包括字母<code>A-Z</code>,<code>a-z</code>,数字<code>0-9</code>,这样共有62个字符,此外两个可打印符号在不同的系统中而不同</p>
</blockquote>
<p>只是一种编码格式,并不用于加密,因为特征明显且易于还原</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2//202310071707600.png" alt="image-20231007170729078" style="zoom:50%;" />

<p>为什么要使用base64:</p>
<blockquote>
<p>在计算机中任何数据都是按ascii码存储的,而ascii码的128-255之间的值是不可见字符.而在网络上交换数据时,比如说从A地传到B地,往往要经过多个路由设备,由于不同的设备对字符的处理方式有一些不同,这样那些不可见字符就有可能被处理错误,这是不利于传输的.所以就先把数据先做一个Base64编码,统统变成可见字符,这样出错的可能性就大大降低了</p>
</blockquote>
<p>base64的主要应用场景</p>
<ul>
<li><p>作为<strong>电子邮件的传输编码</strong></p>
<p>邮件传输协议只支持ASCII字符传递,因此如果要传输二进制文件,如:图片,视频需要通过base64编码.</p>
</li>
<li><p><strong>Http协议</strong></p>
<p>HTTP协议要求请求行和请求头都必须是ASCII编码</p>
</li>
<li><p><strong>数据库数据读写</strong> - blob(big large object)</p>
<p>存储二进制的大数据块</p>
<p>将中文传入不支持中文的数据库</p>
</li>
</ul>
<p>具体算法:</p>
<ol>
<li>把 3 个 8 位字节 (3*8&#x3D;24) 转换为 4 个 6 位字节 (4*6 个字节)</li>
<li>把 6 位的前面补两个 0, 形成 8 位一个字节的形式</li>
<li>如果剩下的字符不足 3 个字节, 则用 0 填充, 输出字符使用 ‘&#x3D;’ ,因此编码后输出的文本末尾可能会出现 1 个或 2 个 ‘&#x3D;’, 表示补了多少字节, 解码的时候会自动去掉</li>
</ol>
<p>[[QT#QT 的 base 64 编码|QT 的 base 64 编码]]</p>
<h1 id="安全传输"><a href="#安全传输" class="headerlink" title="安全传输"></a>安全传输</h1><p>非对称加密好是好,但一般由于加解密太废时间了,导致卡顿,因此实际上都只使用非对称加密参与流程获得对称密钥,在使用对称密钥来进行双方的通信.对称加密有硬件加速,现代CPU都内置AES指令集.</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1P5k3YHEGo/">参考HTTPS加密进化的动画解说</a></p>
<h2 id="密钥协商"><a href="#密钥协商" class="headerlink" title="密钥协商"></a>密钥协商</h2><p>图示:</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2//202312071052759.png" alt="image-20231207105210476" style="zoom:50%;" />

<blockquote>
<p>注意实际的情况中,r1与r2的发送流程应该是使用非对称加密算法的公钥来加密后发送的,只有服务器的私钥才能解开,此案例中直接明文发送了</p>
<p>这样也无法高枕无忧,因为无法确定公钥一定是服务器的,害怕被冒充,所以同样需要效仿https实现证书机制,至于证书的签发机构是不是受信任?因为受信任机构的根证书被安装到了系统中.即使有证书机制,还是要防范假的根证书被安装到了系统</p>
</blockquote>
<h3 id="客户端协商流程"><a href="#客户端协商流程" class="headerlink" title="客户端协商流程"></a>客户端协商流程</h3><ol>
<li><p>客户端生成一个随机数r1,同时使用openssl中哈希函数对r1进行哈希运算,得到一个哈希值</p>
</li>
<li><p>将要发送的数据进行编码</p>
</li>
<li><p>发送数据给服务端(包含r1和对应的哈希值)</p>
</li>
<li><p>客户端等待接受服务端的应答</p>
</li>
<li><p><a href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8D%8F%E5%95%86%E6%B5%81%E7%A8%8B">{服务端协商流程操作}</a></p>
</li>
<li><p>对接收到的数据进行解码</p>
</li>
<li><p>判断rv的值,若rv为-1表示生成密钥失败</p>
</li>
<li><p>如果成功;rv &#x3D; 0;</p>
<p>获得服务端发来的随机字符串r2,将r2和r1进行拼接进行哈希运算得到一个新的**<code>seckey1</code>**</p>
</li>
<li><p>客户端将密钥信息写入共享内存</p>
</li>
</ol>
<h3 id="服务端协商流程"><a href="#服务端协商流程" class="headerlink" title="服务端协商流程"></a>服务端协商流程</h3><ol>
<li><p>收到请求数据之后,首先解码</p>
</li>
<li><p>根据客户端ID+服务端ID查询数据库,校验客户端是否合法,如不合法直接拒绝服务</p>
</li>
<li><p>服务端校验r1消息认证码</p>
<p>使用和客户端相同的算法生成哈希值,然后将这个哈希值与接收到的哈希值做比较</p>
<p>如果不一样,则拒绝服务,如果一样,则继续后续操作</p>
</li>
<li><p>服务端也生成随机数r2</p>
</li>
<li><p>服务端将r1和r2进行拼接,然后使用与客户端相同的哈希算法进行哈希运算,得到一个哈希值,这个哈希值就当做新的密钥**<code>seckey2</code>**</p>
</li>
<li><p>将新的密钥信息写入共享内存和数据库</p>
</li>
<li><p>服务端发送应答信息给客户端;</p>
</li>
</ol>
<h2 id="密钥校验"><a href="#密钥校验" class="headerlink" title="密钥校验"></a>密钥校验</h2><p>客户端</p>
<ol>
<li>客户端将密钥进行哈希运算,得到一个哈希值</li>
<li>将哈希值发送给服务端</li>
</ol>
<p>服务端</p>
<ol>
<li>收到哈希值,自己也生成一个哈希值</li>
<li>将两个哈希值进行比较,相同则密钥协商成功,否则秘钥协商失败</li>
</ol>
<h2 id="密钥注销"><a href="#密钥注销" class="headerlink" title="密钥注销"></a>密钥注销</h2><p>客户端</p>
<ol>
<li>将clientID,serverID和密钥ID发送给服务端</li>
</ol>
<p>服务端</p>
<ol>
<li>服务端收到请求之后,将共享内存和数据库中的密钥的状态修改为不可用状态</li>
</ol>
<h2 id="安全传输平台结构"><a href="#安全传输平台结构" class="headerlink" title="安全传输平台结构"></a>安全传输平台结构</h2><ul>
<li>TcpClient TcpServer   tcp通信操作的封装(完全可以封装到一个类中)  (内部处理了超时问题)</li>
</ul>
<hr>
<ul>
<li><p>ShareMemory  实现最基本的共享内存操作</p>
</li>
<li><p>SecKeyShm  对共享内存操作的进一步封装</p>
</li>
</ul>
<hr>
<ul>
<li><p>ServerOperation 服务器的操作封装</p>
</li>
<li><p>ClientOperation 客户端的操作封装</p>
</li>
</ul>
<hr>
<ul>
<li><p>BaseASN1   实现最基本的ASN1编码逻辑</p>
</li>
<li><p>SequenceASN1  ASN1编码的进一步封装</p>
</li>
<li><p>Codec  对为了实现对不同结构体的ASN1编码而对SequenceASN1做的进一步封装的一个用于实现多态的基类</p>
</li>
<li><p>RequestCodec和RespondCodec   用于具体实现Codec多态的[对请求数据进行ASN1编码的类型]以及[对回应数据进行ASN1编码的类型]</p>
</li>
<li><p>FactoryCodec   生产各种工厂的抽象类,其生产工厂的函数返回的类型为Codec(多态对多态)</p>
</li>
<li><p>RequestFactory和RespondFectory 具体的[生产请求数据的工厂的类]和[生产回应数据的工厂的类]</p>
</li>
</ul>
<hr>
<ul>
<li><p>Mysqlop   对mysql操作的封装</p>
</li>
<li><p>ItcastLog  实现日志功能</p>
</li>
</ul>
<h1 id="根证书比对工具"><a href="#根证书比对工具" class="headerlink" title="根证书比对工具"></a>根证书比对工具</h1><p><a target="_blank" rel="noopener" href="https://github.com/canstand/ctlcheck">开源工具下载</a></p>
<p><a target="_blank" rel="noopener" href="https://kompost.cn/posts/check-and-remove-untrusted-cert/#:~:text=%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%EF%BC%9F%201%20Windows%3A%20Microsft%20%E5%9C%A8%20%E8%BF%99%E9%87%8C%20%E5%85%AC%E5%B8%83%E4%BA%86%E6%9C%80%E6%96%B0%E5%88%97%E8%A1%A8%E7%9A%84%20%E5%9C%B0%E5%9D%80,JDK%EF%BC%8C%E5%8C%BA%E5%88%86%20Oracle%20%E7%89%88%E5%92%8C%20OpenJDK%EF%BC%8C%E5%88%86%E5%88%AB%E4%BB%8E%E6%9C%80%E6%96%B0%E5%AE%89%E8%A3%85%E5%8C%85%E9%87%8C%E8%A7%A3%E5%87%BA%20cacerts%20%E6%96%87%E4%BB%B6%E5%92%8C%20blocked.certs%20%E6%96%87%E4%BB%B6%E4%B9%8B%E5%90%8E%E5%86%8D%E8%A7%A3%E6%9E%90">根证书相关知识</a></p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4" title="头像" alt="头像"></a><div class="post-copyright__author_name">ZEROKO14</div><div class="post-copyright__author_desc">zeroko14's blog</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://che77a38.github.io/posts/%E5%8A%A0%E8%A7%A3%E5%AF%86%E7%9B%B8%E5%85%B3/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://che77a38.github.io/posts/%E5%8A%A0%E8%A7%A3%E5%AF%86%E7%9B%B8%E5%85%B3/')">加密与解密</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://che77a38.github.io/posts/%E5%8A%A0%E8%A7%A3%E5%AF%86%E7%9B%B8%E5%85%B3/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=加密与解密&amp;url=https://che77a38.github.io/posts/%E5%8A%A0%E8%A7%A3%E5%AF%86%E7%9B%B8%E5%85%B3/&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://che77a38.github.io" target="_blank">ZEROKO14的个人博客</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E5%8A%A0%E8%A7%A3%E5%AF%86/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>加解密<span class="tagsPageCount">1</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/windows%E5%BC%80%E5%8F%91/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">windows开发</div></div></a></div><div class="next-post pull-right"><a href="/posts/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">字符编码</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description">欢迎来到ZEROKO14的个人博客</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">ZEROKO14</h1><div class="author-info__desc">zeroko14's blog</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/che77a38" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A0%E8%A7%A3%E5%AF%86%E7%9B%B8%E5%85%B3"><span class="toc-number">1.</span> <span class="toc-text">加解密相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8A%A0%E5%AF%86%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.</span> <span class="toc-text">常用的加密的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="toc-number">1.1.1.</span> <span class="toc-text">对称加密</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="toc-number">1.1.2.</span> <span class="toc-text">非对称加密</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E6%96%B9%E5%BC%8F%E4%B8%BE%E4%BE%8B"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">最简单的非对称加密方式举例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%AE%89%E5%85%A8%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">常用安全算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86-1"><span class="toc-number">1.2.1.</span> <span class="toc-text">对称加密</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DES-3DES"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">DES&#x2F;3DES</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AES"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">AES</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">其他对称加密算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86-1"><span class="toc-number">1.2.2.</span> <span class="toc-text">非对称加密</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DH%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">DH算法原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RSA%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">RSA算法原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hash%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.3.</span> <span class="toc-text">Hash算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81%E7%A0%81"><span class="toc-number">1.2.4.</span> <span class="toc-text">消息认证码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D"><span class="toc-number">1.2.5.</span> <span class="toc-text">数字签名</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#openssl%E9%85%8D%E7%BD%AE"><span class="toc-number">1.3.</span> <span class="toc-text">openssl配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#win%E4%B8%8B%E5%AE%89%E8%A3%85"><span class="toc-number">1.3.1.</span> <span class="toc-text">win下安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#win%E4%B8%8B%E4%BD%BF%E7%94%A8openssl"><span class="toc-number">1.3.2.</span> <span class="toc-text">win下使用openssl</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E4%B8%8B%E5%AE%89%E8%A3%85"><span class="toc-number">1.3.3.</span> <span class="toc-text">Linux下安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E4%B8%8B%E4%BD%BF%E7%94%A8openssl"><span class="toc-number">1.3.4.</span> <span class="toc-text">Linux下使用openssl</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#openssl%E5%BA%93%E7%9A%84api"><span class="toc-number">1.3.5.</span> <span class="toc-text">openssl库的api</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BIO"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">BIO</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#BIO%E7%9B%B8%E5%85%B3api"><span class="toc-number">1.3.5.1.1.</span> <span class="toc-text">BIO相关api</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RSA%E7%AE%97%E6%B3%95api"><span class="toc-number">1.3.5.2.</span> <span class="toc-text">RSA算法api</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#RSA%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.3.5.2.1.</span> <span class="toc-text">RSA结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#BIGNUM%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.3.5.2.1.1.</span> <span class="toc-text">BIGNUM结构体</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#BIGNUM%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0api"><span class="toc-number">1.3.5.2.1.2.</span> <span class="toc-text">BIGNUM操作函数api</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#rsa%E5%85%AC%E7%A7%81%E9%92%A5%E7%94%9F%E6%88%90%E6%A1%88%E4%BE%8B"><span class="toc-number">1.3.5.2.2.</span> <span class="toc-text">rsa公私钥生成案例</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#openssl%E7%94%9F%E6%88%90%E5%85%AC%E9%92%A5%E5%92%8C%E7%A7%81%E9%92%A5%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.5.2.2.1.</span> <span class="toc-text">openssl生成公钥和私钥命令</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#openssl%E5%85%AC%E7%A7%81%E5%AF%86%E9%92%A5%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="toc-number">1.3.5.2.3.</span> <span class="toc-text">openssl公私密钥使用案例</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%9A%84%E9%80%86%E5%90%91%E7%89%B9%E5%BE%81"><span class="toc-number">2.</span> <span class="toc-text">常见的加密算法的逆向特征</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%96%E7%9B%90%E7%AE%97%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text">取盐算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MD5%E9%80%86%E5%90%91%E7%89%B9%E5%BE%81"><span class="toc-number">2.1.1.</span> <span class="toc-text">MD5逆向特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SHA%E9%80%86%E5%90%91%E7%89%B9%E5%BE%81"><span class="toc-number">2.1.2.</span> <span class="toc-text">SHA逆向特征</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E8%BF%98%E5%8E%9F%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">可还原加密算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RSA%E9%80%86%E5%90%91%E7%89%B9%E5%BE%81"><span class="toc-number">2.2.1.</span> <span class="toc-text">RSA逆向特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AES%E9%80%86%E5%90%91%E7%89%B9%E5%BE%81"><span class="toc-number">2.2.2.</span> <span class="toc-text">AES逆向特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DES%E9%80%86%E5%90%91%E7%89%B9%E5%BE%81"><span class="toc-number">2.2.3.</span> <span class="toc-text">DES逆向特征</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%BC%96%E7%A0%81%E7%AE%97%E6%B3%95"><span class="toc-number">2.3.</span> <span class="toc-text">其他编码算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Base64-%E9%80%86%E5%90%91%E7%89%B9%E5%BE%81"><span class="toc-number">2.3.1.</span> <span class="toc-text">Base64 逆向特征</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#AES%E7%AE%97%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">AES算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#OpenSSL%E4%B8%AD%E7%9A%84AES%E7%AE%97%E6%B3%95"><span class="toc-number">3.1.</span> <span class="toc-text">OpenSSL中的AES算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%8A%A0%E5%AF%86-%E8%A7%A3%E5%AF%86%E7%9A%84Key"><span class="toc-number">3.1.1.</span> <span class="toc-text">生成加密&#x2F;解密的Key</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%A7%A3%E5%AF%86%E5%87%BD%E6%95%B0"><span class="toc-number">3.1.2.</span> <span class="toc-text">加解密函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-number">3.1.2.0.1.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ECB%E6%96%B9%E5%BC%8F%E5%8A%A0%E5%AF%86"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">ECB方式加密</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CBC%E6%96%B9%E5%BC%8F%E5%8A%A0%E5%AF%86"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">CBC方式加密</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-1"><span class="toc-number">3.1.2.2.1.</span> <span class="toc-text">案例</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%95%E5%90%91%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0"><span class="toc-number">4.</span> <span class="toc-text">单向散列函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E7%89%B9%E7%82%B9"><span class="toc-number">4.1.</span> <span class="toc-text">哈希函数特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">4.2.</span> <span class="toc-text">哈希函数的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E8%BD%AF%E4%BB%B6%E6%98%AF%E5%90%A6%E8%A2%AB%E7%AF%A1%E6%94%B9"><span class="toc-number">4.2.1.</span> <span class="toc-text">检测软件是否被篡改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81%E7%A0%81-1"><span class="toc-number">4.2.2.</span> <span class="toc-text">消息认证码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D-1"><span class="toc-number">4.2.3.</span> <span class="toc-text">数字签名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E6%AC%A1%E6%80%A7%E5%8F%A3%E4%BB%A4%E6%88%96%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81"><span class="toc-number">4.2.4.</span> <span class="toc-text">一次性口令或登录验证</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0"><span class="toc-number">4.3.</span> <span class="toc-text">常用的哈希函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Md4-Md5"><span class="toc-number">4.3.1.</span> <span class="toc-text">Md4&#x2F;Md5</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SHA-1-SHA-256-SHA-384-SHA-512"><span class="toc-number">4.3.2.</span> <span class="toc-text">SHA-1&#x2F;SHA-256&#x2F;SHA-384&#x2F;SHA-512</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#openssl%E5%BA%93%E4%B8%AD%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95"><span class="toc-number">4.4.</span> <span class="toc-text">openssl库中哈希函数用法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sha1%E7%AE%80%E5%8D%95%E6%A1%88%E4%BE%8B"><span class="toc-number">4.4.1.</span> <span class="toc-text">sha1简单案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hmac%E7%AE%80%E5%8D%95%E6%A1%88%E4%BE%8B"><span class="toc-number">4.4.2.</span> <span class="toc-text">hmac简单案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#base64%E7%BC%96%E7%A0%81"><span class="toc-number">5.</span> <span class="toc-text">base64编码</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E4%BC%A0%E8%BE%93"><span class="toc-number">6.</span> <span class="toc-text">安全传输</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%86%E9%92%A5%E5%8D%8F%E5%95%86"><span class="toc-number">6.1.</span> <span class="toc-text">密钥协商</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8D%8F%E5%95%86%E6%B5%81%E7%A8%8B"><span class="toc-number">6.1.1.</span> <span class="toc-text">客户端协商流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8D%8F%E5%95%86%E6%B5%81%E7%A8%8B"><span class="toc-number">6.1.2.</span> <span class="toc-text">服务端协商流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%86%E9%92%A5%E6%A0%A1%E9%AA%8C"><span class="toc-number">6.2.</span> <span class="toc-text">密钥校验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%86%E9%92%A5%E6%B3%A8%E9%94%80"><span class="toc-number">6.3.</span> <span class="toc-text">密钥注销</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E4%BC%A0%E8%BE%93%E5%B9%B3%E5%8F%B0%E7%BB%93%E6%9E%84"><span class="toc-number">6.4.</span> <span class="toc-text">安全传输平台结构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%B9%E8%AF%81%E4%B9%A6%E6%AF%94%E5%AF%B9%E5%B7%A5%E5%85%B7"><span class="toc-number">7.</span> <span class="toc-text">根证书比对工具</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/%E5%B7%A5%E4%B8%9A%E7%9B%B8%E5%85%B3/" title="工业相关">工业相关</a><time datetime="2025-02-14T03:04:40.761Z" title="发表于 2025-02-14 11:04:40">2025-02-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/%E8%AE%A1%E7%BB%84/" title="计算机组成原理">计算机组成原理</a><time datetime="2024-12-16T01:38:01.470Z" title="发表于 2024-12-16 09:38:01">2024-12-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/" title="网络架构">网络架构</a><time datetime="2024-11-18T06:17:01.282Z" title="发表于 2024-11-18 14:17:01">2024-11-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/avalonia/" title="avalonia">avalonia</a><time datetime="2024-09-11T14:51:13.000Z" title="发表于 2024-09-11 22:51:13">2024-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/%E8%A7%86%E9%A2%91%E6%95%88%E6%9E%9C/" title="PR">PR</a><time datetime="2024-07-18T07:06:08.330Z" title="发表于 2024-07-18 15:06:08">2024-07-18</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2025 By <a class="footer-bar-link" href="/" title="ZEROKO14" target="_blank">ZEROKO14</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu"></a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">60</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">50</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">6</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size: 0.88rem;">C#<sup>2</sup></a><a href="/tags/C/" style="font-size: 0.88rem;">C++<sup>5</sup></a><a href="/tags/CSS/" style="font-size: 0.88rem;">CSS<sup>1</sup></a><a href="/tags/CSharp/" style="font-size: 0.88rem;">CSharp<sup>1</sup></a><a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 0.88rem;">C语言<sup>1</sup></a><a href="/tags/FPS/" style="font-size: 0.88rem;">FPS<sup>1</sup></a><a href="/tags/HTML/" style="font-size: 0.88rem;">HTML<sup>1</sup></a><a href="/tags/JavaScript/" style="font-size: 0.88rem;">JavaScript<sup>1</sup></a><a href="/tags/MFC/" style="font-size: 0.88rem;">MFC<sup>1</sup></a><a href="/tags/PE/" style="font-size: 0.88rem;">PE<sup>1</sup></a><a href="/tags/QT/" style="font-size: 0.88rem;">QT<sup>1</sup></a><a href="/tags/WPF/" style="font-size: 0.88rem;">WPF<sup>2</sup></a><a href="/tags/ai/" style="font-size: 0.88rem;">ai<sup>1</sup></a><a href="/tags/cmake/" style="font-size: 0.88rem;">cmake<sup>1</sup></a><a href="/tags/doxygen/" style="font-size: 0.88rem;">doxygen<sup>1</sup></a><a href="/tags/git/" style="font-size: 0.88rem;">git<sup>1</sup></a><a href="/tags/json/" style="font-size: 0.88rem;">json<sup>1</sup></a><a href="/tags/linux/" style="font-size: 0.88rem;">linux<sup>1</sup></a><a href="/tags/nas/" style="font-size: 0.88rem;">nas<sup>1</sup></a><a href="/tags/next/" style="font-size: 0.88rem;">next<sup>1</sup></a><a href="/tags/ppt/" style="font-size: 0.88rem;">ppt<sup>1</sup></a><a href="/tags/slidev/" style="font-size: 0.88rem;">slidev<sup>1</sup></a><a href="/tags/vue/" style="font-size: 0.88rem;">vue<sup>1</sup></a><a href="/tags/xml/" style="font-size: 0.88rem;">xml<sup>1</sup></a><a href="/tags/yaml/" style="font-size: 0.88rem;">yaml<sup>1</sup></a><a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 0.88rem;">代码规范<sup>1</sup></a><a href="/tags/%E5%86%85%E6%A0%B8/" style="font-size: 0.88rem;">内核<sup>2</sup></a><a href="/tags/%E5%86%85%E6%A0%B8%E7%9B%B8%E5%85%B3/" style="font-size: 0.88rem;">内核相关<sup>5</sup></a><a href="/tags/%E5%8A%A0%E8%A7%A3%E5%AF%86/" style="font-size: 0.88rem;">加解密<sup>1</sup></a><a href="/tags/%E5%9F%BA%E7%A1%80/" style="font-size: 0.88rem;">基础<sup>2</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 0.88rem;">多线程<sup>1</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F/" style="font-size: 0.88rem;">并发模式<sup>1</sup></a><a href="/tags/%E5%BC%80%E5%8F%91/" style="font-size: 0.88rem;">开发<sup>4</sup></a><a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 0.88rem;">数学<sup>1</sup></a><a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 0.88rem;">正则表达式<sup>1</sup></a><a href="/tags/%E7%9B%91%E6%8E%A7/" style="font-size: 0.88rem;">监控<sup>1</sup></a><a href="/tags/%E7%A1%AC%E7%BC%96%E7%A0%81/" style="font-size: 0.88rem;">硬编码<sup>1</sup></a><a href="/tags/%E7%AE%A1%E7%90%86/" style="font-size: 0.88rem;">管理<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 0.88rem;">网络<sup>3</sup></a><a href="/tags/%E9%80%86%E5%90%91/" style="font-size: 0.88rem;">逆向<sup>2</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.cbd.int/mathjax@3.2.2/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.cbd.int/mermaid@10.2.4/dist/mermaid.min.js').then(runMermaid)
  }

  anzhiyu.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>