<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>CSharp入门 | ZEROKO14的个人博客</title><meta name="keywords" content="CSharp"><meta name="author" content="ZEROKO14"><meta name="copyright" content="ZEROKO14"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#18171d"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="CSharp入门"><meta name="application-name" content="CSharp入门"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#18171d"><meta property="og:type" content="article"><meta property="og:title" content="CSharp入门"><meta property="og:url" content="https://che77a38.github.io/posts/CSharp%E5%85%A5%E9%97%A8/index.html"><meta property="og:site_name" content="ZEROKO14的个人博客"><meta property="og:description" content="C# 又称“C Sharp”，是微软发布的一种简单、安全、稳定、通用的面向对象编程语言。   C# 是从 C&amp;#x2F;C++ 衍生出来的，它在继承 C&amp;#x2F;C++强大功能的同时，抛弃了 C&amp;#x2F;C++ 的一些复杂特性。C# 还和 Java 非常类似，仅仅在一些细节上有差别。 C# 运行"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4"><meta property="article:author" content="ZEROKO14"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4"><meta name="description" content="C# 又称“C Sharp”，是微软发布的一种简单、安全、稳定、通用的面向对象编程语言。   C# 是从 C&amp;#x2F;C++ 衍生出来的，它在继承 C&amp;#x2F;C++强大功能的同时，抛弃了 C&amp;#x2F;C++ 的一些复杂特性。C# 还和 Java 非常类似，仅仅在一些细节上有差别。 C# 运行"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://che77a38.github.io/posts/CSharp%E5%85%A5%E9%97%A8/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2024/07/27/125766904/ba62475f396df9de3316a08ed9e65d86_5680958632268053399..png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":true,"limitCount":50,"languages":{"author":"作者: ZEROKO14","link":"链接: ","source":"来源: ZEROKO14的个人博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'ZEROKO14的个人博客',
  title: 'CSharp入门',
  postAI: '',
  pageFillDescription: '.NET Framework, CLR：公共语言运行库, FCL：框架类库, WinForms, ASP.NET, ADO.NET, WPF, WCF, WF, LINQ, Parallel LINQ, 开发环境搭建, mac版, vscode Nuget Package Manager扩展插件, nuget包相关, nuget包的打包与发布, 更新, CSharp概述, 数据类型, 值类型, 引用类型, 对象类型（Object）, 动态类型（Dynamic）, 字符串类型（String）, 指针类型, 变量, CSharp可空类型, Null 合并运算符（??）, 类型转换, 隐式类型转换, 显示类型转换, 运算符优先级, CSharp foreach循环, CSharp函数x2F方法, 静态函数, CSharp封装, CSharp值传递引用传递输出传递, 引用传递, 输出传递, CSharp Array数组, 二维数组, 交错数组, 交错数组和多维数组, 参数数组, CSharp Array类, 属性, 方法, CSharp String字符串, 属性, 方法, CSharp struct结构体, CSharp enum枚举类型, CSharp class类, 对象, 构造函数, 实例构造函数, 静态构造函数, 私有构造函数, 析构函数, CSharp this关键字, CSharp 静态成员, 静态属性, 静态函数, CSharp 静态类, CSharp 继承, CSharp 接口, 接口实现的多重继承, 接口实现的泛型数据结构实例, CSharp 多态, 编译时多态, 函数重载, 运算符重载, 可重载与不可重载的运算符, 运行时多态, abstract, virtual, virtual与abstract的区别, virtual在接口和抽象类中, CSharp与C++多态对比, 对接口和抽象类的理解, 什么情况下应该使用接口而不用抽象类, CSharp namespace：命名空间, using关键字, CSharp 预处理器指令, CSharp 中的预处理器指令, define 预处理器, 条件指令, CSharp 正则表达式, Regex类, CSharp 异常, CSharp中的异常类, 自定义异常类, 抛出异常, 异常调用堆栈理解, CSharp 文件读写, CSharp 中的 Ix2FO 类, FileStream 类, FileStream 类中的常用方法, 二进制文件读写, BinaryReader, BinaryWriter, 文本文件的读写, StreamReader, StreamWriter, CSharp 目录操作, DirectoryInfo, CSharp 文件操作, FileInfo, CSharp 特性, 预定义特性, AttributeUsage, Conditional, Obsolete, 自定义特性, 声明自定义属性, 构建自定义特性, 应用自定义特性, CSharp 属性, 访问器, 抽象属性, CSharp 索引器, 索引器重载, CSharp 委托, 声明委托, 实例化委托, 常用的委托类型, 多播委托（合并委托）, CSharp 事件, 注意点, CSharp 集合, ArrayList动态数组, Hashtable哈希表, SortedList排序列表, Stack堆栈, Queue队列, BitArray点阵列, ConcurrentQueue并发队列, 属性盘点, 方法盘点, 阻塞集合BlockingCollection, 主要方法, 添加元素, 取出元素, GetConsumingEnumerable, 尝试添加元素, 尝试取出元素, 完成添加, 检查是否已完成, CSharp所有容器总结, IEnumerable接口, 遍历方式, CSharp 泛型, 泛型类, 泛型方法, 泛型委托, CSharp 匿名函数x2F方法, CSharp new Action的方式定义匿名函数, CSharp 指针变量与unsafe, 指针变量, 编译不安全代码, CSharp 多线程, 线程生命周期, 主线程, Thread 类, 创建线程, CSharp BackgroundWorker, CSharp 获取线程id, CSharp 异步编程模型, 线程切换时机, 同步上下文的理解, ConfigureAwait, 关于同步上下文导致的死锁, TaskScheduler, 直接调用async方法, 返回值相关, 原理相关, async void理解, 异步完成后执行的另一种方式, 传染性, 同步异步技巧, 如何创建异步任务, 如何同时开启多个异步任务, 如何取消任务, CancellationTokenx2FCancellationTokenSource, 任务超时如何实现, 使用Channel实现异步任务之间的通信, Chanel, 创建, 读写操作, 生产完成通知, 案例, 在异步任务中汇报进度, 如何在同步方法中调用异步方法, 如何终止一个同步任务, Task.Run和async方法的区别, TaskCompletionSource高级异步, wpf异步编程的死锁避免, 多线程环境下的进度通知, Invoke与BeginInvoke, Delegate.Invoke, Delegate.BeginInvoke, CSharp Task, Task相关方法盘点, 需要更细粒度的控制, Task.Delay, Parallel.For, CSharp 异步定时器, 线程同步, AutoResetEvent, CSharp线程同步机制, CSharp读写锁, ReaderWriterLockSlim, ReaderWriterLock, CSharp信号量, CSharp 手动垃圾回收, CSharp中的代码块, visual studio开发环境相关, 官方组件, 重构技巧盘点, 快捷键, 上下文菜单妙用, 数值进制转换, 引入常量x2F引入局部变量x2F引入参数, 提取接口x2F基类, 选择性黏贴, 显示结构, 新建解决方案资源管理器视图, 插件相关, 简易插件, CodeRush, CodeGeeX, 保存的时候格式化, 一键展开排列代码, xaml代码格式化, 翻译插件, windows下vs的NuGet包管理器, windows下的winget, win商店下载方式, GitHub下载方式, vs相关设置, vs生成注释, vs函数参数数据类型显示, vs添加方法的引用计数, 重要的快捷键, 项目结构, winForm项目结构, CSharp语法主要版本迭代, 与C++的相互调用关系, 非托管方式调用（Px2FInvoke）, 数据类型转换, 基本类型转换, 结构体与枚举, 特殊类型, 传递容器, 通过数组传递容器内容, 通过连续内存块传递内容, 使用自定义数据结构, 内存管理, 手动管理, 自动管理, COM接口与智能指针, 最佳实践, 原理, 使用自动化工具生成Px2FInvoke代码, SWIG, ClangSharp.PInvokeGenerator, 托管方式调用（CLRx2FC++x2FCLI）, CSharp winform, 容器控件Panel, 文本标签控件（Lable）, 下拉组合框控件（ComboBox）, 按钮控件（Button）, 文本框控件（TextBox）, CSharp中的窗体事件驱动, CSharp窗口ui线程防堵塞, Invokex2FBeginInvoke, Control.Invoke, 隐式控件, 串口组件（SerialPort）, 编辑串口通信逻辑, 开关串口, 发送和接收串口, 串口发送, 串口接受, CSharp 绘图, 获取Graphics对象, 如何在现有控件上进行绘图, CSharp 窗体相关的事件, CSharp DLL开发, 创建DLL, CSharp中调用该DLL, DLL中自定义窗口, NuGet程序包管理器, NuGet使用方式, NuGet CLI, VS图形界面, CSharp 合并程序集, ILRepack, CSharp 单元测试, 为什么要使用单元测试？, mock技术, 自动生成单元测试, 1. 包和命名空间, 2. 跨平台支持, 3. 与 .NET Core 的兼容性, 4. NuGet 包管理, 5. 特性 (Attributes), 6. 改进的 TestContext, 7. 配置和运行设置, 8. 集成和扩展, 总结, 异常相关, CSharp XML操作, XmlSerializer, CSharp 反射, 类反射, 函数反射, 普通函数, 构造函数, 属性反射, 反射与特性结合, 案例, 反射置空案例, 动态类型生成, CSharp 元组, 使用场景, CSharp dump, 常用的其他 MiniDump 选项, 组合盘点, 分析方式, visual studio, dotnet-dump, 死锁排查, CPU占用率排查, CSharp 拓展方法, 实现扩展方法的关键点, 案例, 工作原理, CSharp LINQ, 查询表达式, 链式编程, 提供的高阶函数盘点, CSharp 断言, CSharp 网络通信, CSharp 计时, Stopwatch, 基本用法, 最高效的Stopwatch使用方式, CSharp 转换器, Converter, BitConverter, Encoding, CSharp Json处理, System.Text.Json, 序列化（对象转 JSON）, 反序列化（JSON 转对象）, 处理复杂类型, 中文json序列化, Newtonsoft.Json, 序列化（对象转 JSON）, 反序列化（JSON 转对象）, 处理复杂类型, LINQ to JSON, 属性盘点, JsonProperty, JsonIgnore, JsonConverter, JsonObject, 其他, 复杂案例, CSharp Entity Framework, 概述, 开发模式, EF注意事项, 安装, 数据库提供程序, 命令行工具, 数据库上下文, 数据迁移, 迁移, 使用dotnet-ef, 使用vs自带的程序包管理器控制台, EntityFramework的自动迁移, 重置所有迁移, 反向工程, EF Core使用方法, 案例参考, 连接字符串配置, EF使用方法, 查询, 查询全表数据, 查询单个数据, 查询部分字段, 增加, 删除, 修改, 延迟实例化, 原理, 缺点, Lazy的线程安全模式, C++中的实现, CSharp 命名规范, 变量命名规范, 特殊情形, 方法命名规范, 异步方法, 合理选择单词, 语法与时态, 更多细节, nuget包盘点, SkiaSharp绘图, 绘制多条曲线图, Dynamic Expresso, CsvHelper, 读取方式, 写入方式, 第三方数据结构库, C5, 控制反转容器库, 状态机库, stateless, 基本概念, 如何使用, 完整案例, 自动映射库, CSharp 一些好用的控件盘点又称是微软发布的一种简单安全稳定通用的面向对象编程语言是从衍生出来的它在继承强大功能的同时抛弃了的一些复杂特性还和非常类似仅仅在一些细节上有差别运行在上借助可以开发不同类型的应用程序桌面应用程序网络应用程序分布式应用程序服务应用程序数据库应用程序等主要由四个部分构成如下所示公共语言运行库框架类库核心语言和其他模块等公共语言运行库全称为它为应用程序提供了一个托管的代码执行环境类似中的虚拟机是整个框架的核心实际上是驻留在内存里的一段代码负责程序执行期间的代码管理工作例如内存管理线程管理安全管理远程管理即时编译等基础类库一个类库为应用程序提供了一些类线程支持用来管理多线程应用程序的并行执行封送处理程序提供对象与应用程序之间的通信类型检查器检查应用程序中使用的类型并验证它们是否与提供的标准类型匹配代码管理器在程序运行时管理代码垃圾回收器释放未使用的内存并将其分配给新的应用程序异常管理器在程序运行时处理异常避免应用程序运行失败类加载器在运行时加载所有的类框架类库全称为它是一个标准库其中包含了成千上万个类主要用于构建应用程序的核心是基础类库提供了的基本功能的基本组成如下所示是的简称它是一种的智能客户端技术用来开发可以在电脑中运行的应用程序经常使用的记事本就是使用技术开发的是一个微软设计和开发的框架于年月首次发布中完美的集成了和可以使用来开发网站应用程序和服务一个是的模块由可用于连接检索插入和删除数据的类组成主要用来开发能够与等数据库进行交互的应用程序全称为是微软推出的基于的用户界面框架主要用来设计应用程序的用户界面以前也叫集成在中发布的是最早支持的全称为是由微软开发的支持数据通信的应用程序框架中文翻译为通讯开发平台与相同最早也是集成在中和被统称为新一代操作系统以及的托管代码编程模型的三个重大应用程序开发类库整合了通讯中的机制并融合了和的相关技术因此尤其适合平台上分布式应用的开发全称为是微软提供的一项技术其中提供进程内工作流引擎和可重新托管的设计器用来将长时间运行的进程实现为应用程序中的工作流技术在年跟随一同发布其全称为是微软的一项技术新增了一种自然查询的语法到的编程语言中当前支持以及语言常用的方法包括投影操作将集合的每个元素转换为另一个形式过滤操作根据条件筛选集合的元素排序操作分组操作聚合操作可以进行累积计算用于判断集合中是否有任何一个元素满足条件或者所有元素都满足条件获取集合中的第一个元素将多个集合扁平化为一个集合语法在的时候才真正执行代码属于延迟执行也叫是对技术的并行实现将语法的简洁和可靠性与并行编程的强大功能结合在一起大大提高了使用时的运行速度开发环境搭建版完整参考此处下载链接查看是否安装完成安装和拓展新项目文件夹路径到新项目去中添加设置输出到终端编译命令项目目录下编译发布版编译调试版使用实际上调用的是编译器查看已安装的包依赖项添加包删除包在上使用时您通常会使用命令行工具来执行操作命令行工具是的官方命令行工具用于构建运行和管理应用程序通过命令行工具您可以使用来添加删除和更新项目的依赖项列出本地的路径使用命令安装引用包安装引用指版本使用使用特定源安装引用包注意执行命令的目录是要安装的项目的文件位置指定项目文件位置扩展插件在的扩展插件中搜索并且安装扩展插件使用或者下将替换成输入在下拉框中选择输入需要安装的包名不需要完整的包名可以模糊搜索进行搜索配置开发环境更详细的参考包相关在和项目中包默认存储在用户的全局包缓存中而不是项目的文件夹中全局包缓存的位置如下或下使用包的相关命令要使用这样的形式使用包的打包与发布在类库项目属性中添加各种信息记得勾选在构建时生成包选项之后生成项目的时候会生成一个文件到官网上传页上传该文件就可以了详细信息可以参考此处更新在官网上新建密钥注意要在设置中确保使用一个未被占用的版本号以便顺利完成发布通过命令指定新生成的文件来更新概述之所以能称为一门被广泛应用的编程语言原因有以下几点是一种现代的通用的编程语言是面向对象的是面向组件的简单易学是一种结构化语言使用开发效率很高可以在各种计算机平台上进行编译相对于的一次编写到处运行的跨平台性可能稍显不足是的一部分以下是的一些重要功能的列表布尔条件自动垃圾回收标准库组件版本属性和事件委托和时间管理易于使用的泛型索引器条件编译简单的多线程和表达式集成借助编程语言可以开发不同类型且安全可靠的应用程序例如桌面应用程序网络应用程序分布式应用程序服务应用程序数据库应用程序等中的关键字是编译器预先定义好的一些单词也可以称为保留字或者保留标识符这些关键字对编译器有特殊的意义不能用作标识符但是如果您非要使用的话也不是没有办法只需要在关键字前面加上前缀即可例如就是一个有效的标识符而则是一个关键字在中有些关键字在代码的上下文中具有特殊的意义例如和这样的关键字被称为上下文关键字一般来说语言中新增的关键字都会作为上下文关键字这样可以避免影响到使用旧版语言编写的程序下图列出了中的保留关键字和上下文关键字数据类型语言中内置了一些基本的数据类型数据类型用来指定程序中变量可以存储的数据的类型中的数据类型可以大致分为三类值类型引用类型指针类型在中不需要像中函数传参的时候考虑应该用引用传递还是值传递因为在中传递对象时的行为取决于该对象的类型值类型和引用类型值类型当你传递一个值类型的变量时默认进行值复制也就是说函数内部得到的是原始变量的一个副本对这个副本的修改不会影响到原始变量但是你可以使用或关键字来按引用传递值类型这样函数内部对参数的修改会影响到原始变量引用类型当你传递一个引用类型的变量时默认进行引用传递也就是说函数内部得到的是原始对象的引用对这个引用的修改会影响到原始对象但是如果你修改了引用本身即让它指向一个新的对象这个修改不会影响到原始变量因为这个修改只改变了函数内部的引用而没有改变原始变量的引用值类型中的值类型是从类中派生出来的对于值类型的变量可以直接为其分配一个具体的值当声明一个值类型的变量时系统会自动分配一块儿内存区域用来存储这个变量的值需要注意的是变量所占内存的大小会根据系统的不同而有所变化中的值类型有很多如下表所示引用类型用类型的变量中并不存储实际的数据值而是存储的对数据对象的引用换句话说就是引用类型的变量中存储的是数据在内存中的位置当多个变量都引用同一个内存地址时如果其中一个变量改变了内存中数据的值那么所有引用这个内存地址的变量的值都会改变中内置的引用类型包括对象动态字符串对象类型对象类型是通用类型系统中所有数据类型的最终基类是类的别名任何类型的值都可以分配给对象类型但是在分配值之前需要对类型进行转换将值类型转换为对象类型的过程被称为装箱反之将对象类型转换为值类型的过程则被称为拆箱注意只有经过装箱的数据才能进行拆箱类型检查在编译时进行的动态类型您可以在动态类型的变量中存储任何类型的值这些变量的类型检查是在程序运行时进行的动态类型的声明语法如下所示例如类型检查在程序运行时进行的字符串类型字符串类型的变量允许您将一个字符串赋值给这个变量字符串类型需要通过类来创建类是类的别名它是从对象类型中派生的在中有两种定义字符串类型的方式分别是使用和使用引号的声明方式使用加引号的声明形式使用形式声明的字符串称为逐字字符串逐字字符串会将转义字符当作普通字符对待例如等价于另外在形式声明的字符串中可以任意使用换行换行符及缩进空格等都会计算在字符串的长度之中指针类型语言中的指针是一个变量也称为定位器或指示符其中可以存储另一种类型的内存地址中的指针与或中的指针具有相同的功能变量变量可以理解为是程序可以操作的内存区域的名称在中每个变量都有自己特定的类型这个类型确定了变量所占内存的大小布局取值范围以及可以对该变量执行的操作可以将变量当作一种通过符号变量名表示某个内存区域的方法变量的值可以更改并且可以多次重复使用中的基本变量类型可以归纳为以下几种类型示例整型整数类型浮点型十进制类型布尔型空类型可为空值的数据类型请输入第一个数字请输入第二个数字因为使用接收的数据是字符串格式的所以使用函数来将用户输入的数据转换为类型中的表达式非左值表达式右值表达式可空类型在的版本中一个值类型的变量是不可以被赋值为空值的否则会产生异常而在中新增了一个类型可以使用类型定义包含值的数据例如您可以在可为空的类型类型的变量中存储到之间的任何值或者同样您可以在可为空的类型类型的变量中存储或声明可空类型的语法如下其中为要声明的数据类型后面紧跟一个问号则为变量的名称输出这些值合并运算符在中合并运算符用于定义可空类型和引用类型的默认值如果此运算符的左操作数不为那么运算符将返回左操作数否则返回右操作数例如表达式中如果不为空那么表达式的值则为反之则为需要注意的是合并运算符左右两边操作数的类型必须相同或者右操作数的类型可以隐式的转换为左操作数的类型否则将编译错误类型转换隐式类型转换一种数据类型类型只要其取值范围完全包含在另一种数据类型类型的取值范围内那么类型就可以隐式转换为类型基于这一特性的隐式类型转换不会导致数据丢失显示类型转换显式类型转换也叫强制类型转换这种转换需要使用的形式或者预定义函数显式的完成显式转换需要用户明确的指定要转换的类型而且在转换的过程中可能会造成数据丢失中还提供了一系列内置的类型转换方法如下表所示方法描述将类型转换为布尔型将类型转换为字节类型将类型转换为单个字符类型将类型整数或字符串类型转换为日期时间的结构将浮点型或整数类型转换为十进制类型将类型转换为双精度浮点型将类型转换为位整数类型将类型转换为位整数类型将类型转换为位整数类型将类型转换为有符号字节类型将类型转换为小浮点数类型将类型转换为字符串类型将类型转换为指定类型将类型转换为位无符号整数类型将类型转换为位无符号整数类型将类型转换为位无符号整数类型例子运算符优先级循环除了前面介绍的几种循环语句外同样也支持循环使用可以遍历数组或者集合对象中的每一个元素其语法格式如下数据类型变量名数组或集合对象语句块函数方法格式如下需要注意的是访问权限修饰符是可以省略省略后默认为静态函数中的静态函数指的是在一个类中使用修饰的函数调用静态函数比调用普通函数要简单很多只需要函数名即可调用类中的静态函数定义一个函数该函数可以接收一个字符串参数并返回一个字符串欢迎访问封装中的访问权限修饰符有以下几种公共的所有对象都可以访问但是需要引用命名空间私有的类的内部才可以访问内部的同一个程序集的对象可以访问程序集就是命名空间受保护的类的内部或类的父类和子类中可以访问和的并集符合任意一条都可以访问值传递引用传递输出传递方式描述值传递值传递会复制参数的实际值并赋值给函数的形式参数实参和形参使用的是两个不同内存位置中的值当形参的值发生改变时不会影响实参的值从而保证了实参数据的安全引用传递引用传递会复制参数的内存位置并传递给形式参数当形参的值发生改变时同时也会改变实参的值输出传递输出传递可以一次返回多个值引用传递在中需要使用关键字来使用引用传递函数内部的值输出传递使用语句可以从函数中返回一个值但是使用输出传递则可以从函数中一次性返回多个值输出传递与引用传递相似不同之处在于输出传递是将数据从函数中传输出来而不是传输到函数中在中需要使用关键字来使用输出传递下面通过示例来演示一下数组初始化一个长度为的整型数组初始化一个长度为的浮点型数组不指定长度赋值指定长度赋值二维数组可以使用的形式来访问二维数组中的每个元素其中为数组的名称而和则是数组元素的索引类似于表格中的行和列初始化二维数组第一种方式第二种方式第三种方式访问二维数组中的元素交错数组中的交错数组其实就是元素为数组的数组换句话说就是交错数组中的每个元素都可以是维度和大小不同的数组所以有时交错数组也被称为数组的数组定义并初始化定义一个交错数组对数组的第一个元素初始化对数组的第二个元素初始化对数组的第三个元素初始化还可以简写为定义一个交错数组并遍历数组中的内容遍历数组交错数组和多维数组交错数组中的元素不仅可以是一维数组还可以是多维数组例如下面的代码中定义了一个包含三个二维数组元素的一维交错数组访问变量的值为变量的值为参数数组某些情况下在定义函数时可能并不能提前确定参数的数量这时可以使用提供的参数数组参数数组通常用于为函数传递未知数量的参数若要使用参数数组则需要利用关键字语法格式如下访问权限修饰符返回值类型函数名类型名称数组名称使用参数数组时既可以直接为函数传递一个数组作为参数也可以使用函数名参数参数参数的形式传递若干个具体的值作为参数调用方式调用方式类类是中所有数组的基类其中提供了一系列用来处理数组的操作例如对数组元素进行排序搜索数组中指定的元素等类中提供了一系列属性通过这些属性可以获取数组的各种信息类中的常用属性如下表所示属性属性描述检查数组是否具有固定大小检查数组是否为只读检查是否同步对数组的访问线程安全获取数组中所有维度中元素的总数获取数组中所有维数中元素的总数并返回一个位整数获取数组的秩维数例如一维数组返回二维数组返回依次类推用来获取一个对象该对象可以用于同步对数组的访问方法方法描述将数组中指定范围内的元素设置为该元素所属类型的默认值从第一个元素开始拷贝数组中指定长度的元素并将其粘贴到另一个数组中从第一个元素开始粘贴使用位整数来指定要拷贝的长度从指定的目标数组索引处开始将当前一维数组的所有元素复制到指定的一维数组中索引使用位整数指定获取数组指定维度中的元素数并返回一个位整数获取数组指定维度中的元素数并返回一个位整数获取数组中指定维度第一个元素的索引获取当前实例的类型继承自获取数组中指定维度最后一个元素的索引获取一维数组中指定位置的值在一个一维数组中搜索指定对象并返回其首个匹配项的索引反转整个一维数组中元素的顺序设置一维数组中指定元素的值对一维数组中的元素排序返回一个表示当前对象的字符串继承自如果想要了解有关类中的属性和方法的详细介绍可以查阅的官方文档创建一个数组并赋值创建一个空数组获取数组的长度数组的长度为为数组排序排序后的数组为打印排序后的查找数组元素的索引数组中值为的元素的索引为拷贝到打印数组打印数组反序排列数组遍历数组元素字符串在中或关键字是类的别名其中提供了定义字符串以及操作字符串的一系列方法下面就来详细介绍一下使用定义一个空字符串属性属性描述获取指定字符在字符串中的位置获取当前对象中的字符数字符串的长度方法方法描述返回对此实例的引用比较两个指定的对象并返回一个指示二者在排序顺序中的相对位置的整数通过比较每个字符串中的字符来比较两个字符串是否相等将一个字符串与另一个字符串进行比较连接两个指定的字符串判断一个字符串中是否包含零一个字符串将字符串的值复制一份并赋值给另一个字符串从字符串中复制指定数量的字符到一个字符数组中用来判断字符串是否以指定的字符串结尾判断两个字符串是否相等将字符串格式化为指定的字符串表示形式返回一个可以循环访问此字符串中的每个字符的对象返回该字符串的哈希代码获取当前实例的类型返回字符串的类型代码返回字符在字符串中的首次出现的索引位置索引从零开始在字符串的指定位置插入另一个字符串并返回新形成的字符串返回指定字符串的内存地址返回的是引用返回指定字符串的内存地址返回的是可能为空的引用判断此字符串是否符合标准判断指定的字符串是否为空或空字符串判断指定的字符串是否为空或仅由空白字符组成串联字符串数组中的所有元素并将每个元素使用指定的分隔符分隔开获取某个字符在字符串中最后一次出现的位置获取一个或多个字符在字符串中最后一次出现的位置返回一个新字符串新字符串与原字符串的值相等但其二进制表示形式符合标准返回一个指定长度的新字符串新字符串通过在原字符串左侧填充空格来达到指定的长度从而实现右对齐返回一个指定长度的新字符串新字符串通过在原字符串右侧填充空格来达到指定的长度从而实现左对齐返回一个指定长度的新字符串将字符串中超出长度以外的部分全部删除使用指定字符替换字符串中的某个字符并返回新形成的字符串按照某个分隔符将一个字符串拆分成一个字符串数组返回分割后的字符串数组判断字符串是否使用指定的字符串开头从指定的位置截取字符串将字符串中的字符复制到字符数组将字符串中的字母转换为小写的形式使用固定区域性的大小写规则将字符串转换为小写的形式将其它数据类型转换为字符串类型将字符串中的字母转换为大写形式删除字符串首尾的空白字符删除字符串尾部的空白字符删除字符串首部的空白字符上表中只列举了一些类中常用方法可以通过查阅的官方文档来了解类中的全部的方法介绍结构体在中结构体也被称为结构类型或它是一种可封装数据和相关功能的值类型在语法上结构体与类非常相似它们都可以用来封装数据并且都可以包含成员属性和成员方法在设计结构体时有以下几点需要注意不能为结构体声明无参数的构造函数因为每个结构体中都已经默认创建了一个隐式的无参数的构造函数不能在声明成员属性时对它们进行初始化静态属性和常量除外结构体的构造函数必须初始化该结构体中的所有成员属性结构体不能从其他类或结构体中继承也不能作为类的基础类型但是结构类型可以实现接口不能在结构体中声明析构函数中的结构体与中的结构体有很大的不同在中结构体具有以下功能结构体中可以具有方法字段索引属性运算符方法和事件结构体中可以定义构造函数但不能定义析构函数需要注意的是定义的构造函数不能没有参数因为没有参数的构造函数是默认自动定义的而且不能更改与类不同结构体不能继承其他结构体或类结构体不能用作其他结构体或类的基础结构一种结构体可以实现一个或多个接口结构体成员不能被设定为或与类不同结构体可以不用操作符来实例化当使用操作符来实例化结构体时会自动调用结构体中的构造函数如果不使用操作符来实例化结构体结构体对象中的字段将保持未分配状态并且在所有字段初始化之前无法使用该结构体实例类和结构体的主要区别类是引用类型结构体是值类型结构体不支持继承但可以实现接口结构体中不能声明默认的构造函数类是引用类型结构体是值类型在中结构体是值类型意味着当你创建一个结构体的实例时实际上在内存中存储的是该实例的实际数据当你将一个结构体赋值给另一个变量或作为参数传递时会复制整个结构体的数据相比之下类是引用类型意味着当你创建一个类的实例时内存中存储的是对该实例的引用而不是实际数据当你将一个类的实例赋值给另一个变量或作为参数传递时实际上是传递了对同一个对象的引用而不是对象的副本枚举类型枚举类型也可以称为枚举器由一组具有独立标识符名称的整数类型常量构成在中枚举类型不仅可以在类或结构体的内部声明也可以在类或结构体的外部声明默认情况下枚举类型中成员的默认值是从开始的然后逐一递增在中可以使用关键字来声明枚举类型语法格式如下所示在使用枚举类型时有以下几点需要注意枚举类型中不能定义方法枚举类型具有固定的常量集枚举类型可提高类型的安全性枚举类型可以遍历默认情况下枚举类型中的每个成员都为类型它们的值从零开始并按定义顺序依次递增但是也可以显式的为每个枚举类型的成员赋值如下所示遍历枚举使用遍历枚举类型中的所有成员使用遍历枚举类型中的所有成员类类的定义语法格式成员属性成员函数成员方法函数体函数体函数体语法说明如下为访问权限修饰符用来指定类或类中成员的访问规则可以忽略不写如果没有指定则使用默认的访问权限修饰符类的默认访问权限修饰符是类中成员的默认访问权限修饰符是为类的名称为数据类型用来指定成员属性的数据类型等为成员属性的名称类似于变量名为返回值类型用来指定成员函数的返回值类型等为成员函数的名称对象类和对象是不同的概念类决定了对象的类型但不是对象本身另外类是在开发阶段创建的而对象则是在程序运行期间创建的可以将对象看作是基于类创建的实体所以对象也可以称为类的实例想要创建一个类的实例需要使用关键字类是引用类型虽然也可以像创建普通变量那样只创建一个类型的变量而不使用关键字实例化这个类不过不建议使用这样的写法因为此时的只是一个类型的普通变量它并没有被赋值所以不能使用来访问对象中的属性和方法如果非要使用的话则可以将一个已经创建的对象赋值给它和指向同一个对象因此使用对对象的任何操作也会影响到构造函数中的构造函数有三种实例构造函数静态构造函数私有构造函数实例构造函数构造函数是类中特殊的成员函数它的名称与它所在类的名称相同并且没有返回值当使用关键字创建类的对象时可以使用实例构造函数来创建和初始化类中的任意成员属性只要创建类的对象就会调用类中的实例构造函数类中剩余的成员调用类中的实例构造函数张三如果没有为类显式的创建构造函数那么将会为这个类隐式的创建一个没有参数的构造函数无参数构造函数这个无参的构造函数会在实例化对象时为类中的成员属性设置默认值关于中类型的默认值可以查阅值类型一节在结构体中也是如此如果没有为结构体创建构造函数那么将隐式的创建一个无参数的构造函数用来将每个字段初始化为其默认值静态构造函数静态构造函数用于初始化类中的静态数据或执行仅需执行一次的特定操作静态构造函数将在创建第一个实例或引用类中的静态成员之前自动调用静态构造函数具有以下特性静态构造函数不使用访问权限修饰符修饰或不具有参数类或结构体中只能具有一个静态构造函数静态构造函数不能继承或重载静态构造函数不能直接调用仅可以由公共语言运行时调用用户无法控制程序中静态构造函数的执行时间在创建第一个实例或引用任何静态成员之前将自动调用静态构造函数以初始化类静态构造函数会在实例构造函数之前运行构造函数静态构造函数当执行上面程序时会首先执行接着执行类中的静态构造函数此时然后执行函数里面的内容此时打印的值为接着初始化类这时会执行类中的构造函数此时会重新赋值为所以上例的运行结果如下所示私有构造函数私有构造函数是一种特殊的实例构造函数通常用在只包含静态成员的类中如果一个类中具有一个或多个私有构造函数而没有公共构造函数的话那么其他类除嵌套类外则无法创建该类的实例对于一些类并不需要实例化就用这种方式防止实例化私有构造函数上例中定义了一个空的私有构造函数这么做的好处就是空构造函数可阻止自动生成无参数构造函数需要注意的是如果不对构造函数使用访问权限修饰符则默认它为私有构造函数析构函数与构造函数类似中的析构函数也被称作终结器同样是类中的一个特殊成员函数主要用于在垃圾回收器回收类实例时执行一些必要的清理操作中的析构函数具有以下特点析构函数只能在类中定义不能用于结构体一个类中只能定义一个析构函数析构函数不能继承或重载析构函数没有返回值析构函数是自动调用的不能手动调用析构函数不能使用访问权限修饰符修饰也不能包含参数析构函数的名称同样与类名相同不过需要在名称的前面加上一个波浪号作为前缀如下所示析构函数注意析构函数不能对外公开所以我们不能在析构函数上应用任何访问权限修饰符关键字中可以使用关键字来表示当前对象日常开发中我们可以使用关键字来访问类中的成员属性以及函数不仅如此关键字还有一些其它的用法使用表示当前类的对象使用关键字串联构造函数无参构造函数这里的代表无参构造函数先执行后执行此处实例构造函数使用关键字作为类的索引器可以理解为重载函数注意这个也是关键字使用关键字作为原始类型的扩展方法扩展方法是对现有类型功能的一种补充但这种补充并非改变原始类型的行为而是为它们添加新的行为使其看起来像是类型本身就具有这些方法你好世界调用拓展方法定义给类型的拓展方法上述代码中是一个拓展方法它拓展了类型使其看起来拥有将字符串转换为标题格式的功能这里的就表示这个方法是拓展类型的调用时如同直接在对象上调用该方法一样的扩展方法并不适用于原始类型而是适用于任何用户自定义类型或内建的引用类型如原始类型如等不支持扩展方法静态成员在中我们可以使用关键字声明属于类型本身而不是属于特定对象的静态成员因此不需要使用对象来访问静态成员在类接口和结构体中可以使用关键字修饰变量函数构造函数类属性运算符和事件注意索引器和析构函数不能是静态的若在定义某个成员时使用关键字则表示该类仅存在此成员的一个实例也就是说当我们将一个类的成员声明为静态成员时无论创建多少个该类的对象静态成员只会被创建一次这个静态成员会被所有对象共享静态属性使用定义的成员属性称为静态属性静态属性可以直接通过类名属性名的形式直接访问不需要事先创建类的实例静态属性不仅可以使用成员函数来初始化还可以直接在类外进行初始化静态函数除了可以定义静态属性外关键字还可以用来定义成员函数使用定义的成员函数称为静态函数静态函数只能访问静态属性静态类中的静态类是一种特殊的类它具备以下几个显著特征静态成员限定静态类只能包含静态成员字段属性方法事件和嵌套类型不能包含实例成员非静态字段非静态方法等这意味着你不能在静态类中定义构造函数因为构造函数总是与实例关联的不可实例化由于静态类仅包含静态成员所以不能使用关键字创建该类的实例也就是说静态类不能有实例生命周期因为它不是为了创建对象而设计的静态构造函数尽管静态类不能有实例构造函数但可以有一个静态构造函数它在第一次访问该类的任何静态成员之前自动调用并且在整个程序中只调用一次静态构造函数用于初始化静态类的静态数据成员或者执行必要的静态资源初始化单一实例和全局可见性静态类的所有成员都是全局共享的意味着对静态成员的任何更改都会影响到整个应用程序的所有使用者密封性静态类在概念上类似于密封的抽象类因为它既不能被继承也不能被实例化仅仅作为一个组织相关静态成员的容器编译时常量静态类常用于封装与类层次结构无关的全局常量工具方法或服务这些内容在整个应用程序域中只需要一份拷贝即可加载时机公共语言运行库会在加载包含静态类的程序集时自动加载此类及其成员总结来说静态类的主要目的是组织和管理那些不需要与类实例关联的全局可用的功能和数据继承中只支持单继承也就是说一个派生类只能继承一个基类派生类基类所有的类都隐式继承自类该类提供了这些可以被子类重写的方法接口对应中的纯虚基类接口可以看作是一个约定其中定义了类或结构体继承接口后需要实现功能接口的特点如下所示接口是一个引用类型通过接口可以实现多重继承接口中只能声明抽象成员所以不能直接对接口进行实例化接口中可以包含方法属性事件索引器等成员接口名称一般习惯使用字母作为开头不是必须的不这样声明也可以接口中成员的访问权限默认为所以我们在定义接口时不用再为接口成员指定任何访问权限修饰符否则编译器会报错在声明接口成员的时候不能为接口成员编写具体的可执行代码也就是说只要在定义成员时指明成员的名称和参数就可以了接口一旦被实现被一个类继承派生类就必须实现接口中的所有成员除非派生类本身也是抽象类在中声明接口需要使用关键字语法结构如下所示其中为接口名称为返回值类型为成员函数的名称为参数列表在中一个接口可以继承另一个接口例如可以使用接口继承接口当用某个类来实现接口时必须同时实现接口和接口中的所有成员下面通过一个示例来演示一下实现接口中的函数实现接口中的函数实现接口中的函数实现接口中的函数接口实现的多重继承与单继承相反多重继承则是指一个类可以同时继承多个基类并不支持多重继承但是可以借助接口来实现多重继承长方形的面积为长方形的周长为基类定义接口派生类接口实现的泛型数据结构实例在中接口是一种抽象类型无法直接实例化在这种情况下并不是实例化了一个接口而是实例化了一个泛型列表该列表可以存储实现了接口的类的实例因为接口可以被类实现所以你可以将实现了接口的类的实例添加到但要注意只有接口中定义的方法和属性才能被对象访问多态在中具有两种类型的多态编译时多态通过中的方法重载和运算符重载来实现编译时多态也称为静态绑定或早期绑定运行时多态通过方法重载实现的运行时多态也称为动态绑定或后期绑定编译时多态在编译期间将函数与对象链接的机制称为早期绑定也称为静态绑定提供了两种技术来实现编译时多态分别是函数重载和运算符重载函数重载在同一个作用域中可以定义多个同名的函数但是这些函数彼此之间必须有所差异比如参数个数不同或参数类型不同等等返回值类型不同除外运算符重载中支持运算符重载所谓运算符重载就是我们可以使用自定义类型来重新定义中大多数运算符的功能运算符重载需要通过关键字后跟运算符的形式来定义的我们可以将被重新定义的运算符看作是具有特殊名称的函数与其他函数一样该函数也有返回值类型和参数列表如下例所示重载运算符把两个对象相加可重载与不可重载的运算符运算符可重载性这些一元运算符可以进行重载强制类型转换运算符不能重载这些运算符无法进行重载注意比较运算符必须成对重载也就是说如果重载一对运算符中的任意一个则另一个运算符也必须重载比如和运算符和运算符和运算符演示如下长度宽度高度重载运算符来把两个对象相加声明类型为声明类型为声明类型为体积详述详述使用重载的显示两个盒子的体积的体积的体积的体积把两个对象相加的体积的体积大于不大于小于不小于大于等于不大于等于小于等于不小于等于不等于等于等于不等于的体积的体积的体积不大于小于不大于等于小于等于不等于等于等于运行时多态允许您使用关键字来创建抽象类抽象类用于实现部分接口另外抽象类包含抽象方法可以在派生类中实现下面列举了一些有关抽象类的规则不能创建一个抽象类的实例不能在一个抽象类外部声明抽象方法通过在类定义时使用关键字可以将类声明为密封类密封类不能被继承因此抽象类中不能声明密封类覆写抽象类中的抽象方法都可以长方形的面积为运行结果如下长方形的面积为的运行时多态也通过实现的几个特点声明了的方法无需去改动类的声明他只在此方法上起到影响与不同如果一个类中包含抽象成员函数那么这个类必须被声明为抽象类只有的方法可以被子类子类可以不父类的方法这种情况下他就像普通的父类方法一样与的区别抽象类不可以直接实例化他可以有个抽象方法这些抽象方法子类必须实现强制关键字就是告诉子类此方法可以被但非强制在接口和抽象类中在接口中所有成员都默认是公共的抽象成员不包含任何实现因此不能使用关键字定义虚拟方法在抽象类中抽象方法是用来强制子类实现的而虚拟方法是可以在抽象类中提供默认实现的方法因此抽象类中可以使用关键字定义虚拟方法但不需要使用关键字与多态对比支持支持支持接口支持抽象类支持所有类的多重继承首先这点就不支持中仅接口可以支持多重继承概念对照主要功能基础纯虚函数和抽象类纯虚函数抽象函数必须被重写基础多态不重写则调用父类虚函数基础纯虚函数和抽象类抽象类包含一个纯虚函数就是抽象类抽象类全是纯虚函数的抽象类接口对应关系大致符合上表但还有不同中普通方法不能被重写只有抽象或虚方法可以被重写中普通函数也能被重定义抽象或虚方法也可以被重写注意点中如果你想要重写基类中的虚方法方法或抽象方法方法关键字是必写的中只是个标志增加可读性可写可不写都能重写父类对接口和抽象类的理解接口虽然不可以被实例化但是接口引用可以指向个实现该接口的对象若实现了接口可以接口引用实现了他的实例也可以把的对象强制转换为接口的对象什么情况下应该使用接口而不用抽象类总的来说如果你需要定义一组应该被多个不相关的类实现的行为或者需要多重继承的特性接口是更好的选择如果你的目标是共享代码或定义一个明确的是一个继承结构并且需要包含状态或属性那么抽象类可能是更好的选择在实际开发中经常会同时使用接口和抽象类接口定义行为的契约而抽象类提供部分实现理解它们各自的优势和用途可以帮助你做出更合适的设计选择命名空间在中可以将命名空间看作是一个范围用来标注命名空间中成员的归属一个命名空间中类与另一个命名空间中同名的类互不冲突但在同一个命名空间中类的名称必须是唯一的在一个简单的程序中假如我们要输出某些数据就需要使用其中就是命名空间而是类的名字则是具体要使用方法也就是说如果要访问某个命名空间中的类我们需要使用的形式当然也可以使用关键字来引用需要的命名空间例如这样我们就可以直接使用来输出指定的数据了在中定义命名空间需要使用关键字语法格式如下命名空间中的代码调用指定命名空间下的成员需要使用关键字关键字用来引用指定的命名空间它可以告诉编译器后面的代码中我们需要用到某个命名空间例如我们在程序中需要使用到命名空间只需要在程序的开始使用引用该命名空间即可这时我们在使用命名空间下的类时就可以将省略例如签名相同的函数要指明哪个命名空间中的函数命名空间下类中的函数命名空间下类中的函数命名空间可以嵌套使用也就是说我们可以在一个命名空间中再定义一个或几个命名空间如下所示下的代码下的代码您可以使用点运算符来访问嵌套的命名空间成员例如预处理器指令预处理指令的作用主要是向编译器发出指令以便在程序编译开始之前对信息进行一些预处理操作在中预处理器指令均以开头并且预处理器指令之前只能出现空格不能出现任何代码另外预处理器指令不是语句因此它们不需要以分号结尾在中预处理指令用于帮助条件编译不同于和中的指令在中不能使用这些指令来创建宏而且预处理器指令必须是一行中唯一的代码不能掺杂其它中的预处理器指令预处理器指令描述用于定义一系列字符可以将这些字符称为符号用于取消一个已定义符号用于测试符号是否为真用于创建复合条件指令与一起使用用于创建复合条件指令指定一个条件指令的结束用于修改编译器的行数以及可选地输出错误和警告的文件名用于在代码的指定位置生成一个错误用于在代码的指定位置生成一级警告用于在使用的大纲特性时指定一个可展开或折叠的代码块用于标识块的结束预处理器预处理器指令用来创建符号常量这个符号可以作为传递给指令的表达式表达式将返回的语法格式如下已定义未定义已定义条件指令您可以使用来创建条件指令条件指令可以用于测试一个或多个符号的值是否为如果符号的值为那么编译器将评估指令和下一个指令之间的所有代码在语法上预处理器语句与中的条件判断语句比较相似如下所示要执行的代码要执行的代码要执行的代码是要测试的符号的名称条件指令中仅可以使用运算符相等和不相等来测试布尔值或例如表示已定义该符号另外还可以使用和运算符来同时测试多个符号以及使用括号对符号和运算符分组正则表达式正则表达式是一种匹配输入文本的模式可以用于解析和验证给定文本以及模式之间是否匹配模式可以包含运算符字符字面值或结构参考正则表达式类类用于使用一个正则表达式下表中列出了类中一些常用的方法方法描述指示构造函数中指定的正则表达式是否在指定的输入字符串中找到匹配项指示构造函数中指定的正则表达式是否在指定的输入字符串中找到匹配项从字符串中指定的位置开始查找指示指定的正则表达式是否在指定的输入字符串中找到匹配项在指定的输入字符串中搜索正则表达式的所有匹配项在指定的输入字符串中把所有匹配正则表达式模式的所有匹配的字符串替换为指定的替换字符串把输入字符串分割为子字符串数组根据在构造函数中指定的正则表达式模式定义的位置进行分割异常在中异常是在程序运行出错时引发的例如以一个数字除以零所有异常都派生自类异常处理则是处理运行时错误的过程使用异常处理可以使程序在发生错误时保持正常运行中的异常处理基于四个关键字构建分别是和语句块中通常用来存放容易出现异常的代码其后面紧跟一个或多个语句块语句块用来捕获语句块中的出现的异常语句块用于执行特定的语句不管异常是否被抛出都会执行只要跳出块一定会被执行到内中途也会被执行到在中块的主要作用是确保无论块中的代码是否抛出异常或者是否在块中执行了语句块中的代码都会被执行这使得块非常适合用于清理资源比如关闭文件释放网络连接或释放数据库连接等用来抛出一个异常引起异常的语句错误处理代码错误处理代码错误处理代码要执行的语句中的异常类中的异常类主要是从类派生的比如和两个异常类就是从类派生的类支持由程序产生的异常因此我们自定义的异常都应继承此类类是所有系统预定义异常的基类下表中列举了一些从类派生的预定义异常类异常类描述处理错误处理当方法引用超出范围的数组索引时产生的错误处理当数组类型不匹配时产生的错误处理引用一个空对象时产生的错误处理当除以零时产生的错误处理在类型转换期间产生的错误处理空闲内存不足产生的错误处理栈溢出产生的错误自定义异常类除了可以使用系统预定义的异常类外我们还可以自行定义异常类自定义的异常类都应继承类下面通过示例来演示一下自定义异常类的使用其它代码在在其它代码抛出异常如果异常是直接或间接派生自类则可以在语句块中使用语句抛出该异常所谓抛出异常这里可以理解为重新引发该异常语句的语法格式如下所示异常调用堆栈理解的作用是分隔符它表示在此行之前的调用堆栈信息是来自于一个不同的上下文或调用路径也就是说当前的异常可能是由之前的一些操作引发的但这些操作是在不同的上下文中进行的上下文切换的指示这条消息提醒开发者异常的发生与之前的调用堆栈即在这条消息之前的调用是分开的它帮助开发者理解异常并不是在当前线程的上下文中直接引发的而是可能与其他线程或异步操作有关文件读写文件是存储在磁盘中的具有特定名称和目录路径的数据集合当我们使用程序对文件进行读取或写入时程序会将文件以数据流简称流的形式读入内存中我们可以将流看作是通过通信路径传递的字节序列流主要分为输入流和输出流输入流主要用于从文件读取数据读操作输出流主要用于向文件中写入数据写操作中的类命名空间中包含了各种用于文件操作的类例如文件的创建删除读取写入等等如下表中所示类描述从二进制流中读取原始数据以二进制格式写入原始数据临时存储字节流对目录进行复制移动重命名创建和删除等操作用于对目录执行操作获取驱动器的信息对文件进行操作用于对文件执行操作用于文件中任何位置的读写用于随机访问存储在内存中的数据流对路径信息执行操作用于从字节流中读取字符用于向一个流中写入字符用于从字符串缓冲区读取数据用于向字符串缓冲区写入数据类类在命名空间下使用它可以读取写入和关闭文件创建类对象的语法格式如下所示例子参数说明如下创建的对象名称文件的路径包含文件名在内枚举类型用来设定文件的打开方式可选值如下打开一个已有的文件并将光标放置在文件的末尾如果文件不存在则创建文件创建一个新的文件如果文件已存在则将旧文件删除然后创建新文件创建一个新的文件如果文件已存在则抛出异常打开一个已有的文件如果文件不存在则抛出异常打开一个已有的文件如果文件不存在则创建一个新的文件并打开打开一个已有的文件然后将文件清空删除原有内容如果文件不存在则抛出异常枚举类型用来设置文件的存取可选值有和枚举类型用来设置文件的权限可选值如下允许子进程继承文件句柄不直接支持此功能在文件关闭前拒绝共享当前文件打开该文件的任何请求由此进程或另一进程发出的请求都将失败允许随后打开文件读取如果未指定此标志则文件关闭前任何打开该文件以进行读取的请求都将失败需要注意的是即使指定了此标志仍需要附加权限才能够访问该文件允许随后打开文件读取或写入如果未指定此标志则文件关闭前任何打开该文件以进行读取或写入的请求都将失败需要注意的是即使指定了此标志仍需要附加权限才能够访问该文件允许随后打开文件写入如果未指定此标志则文件关闭前任何打开该文件以进行写入的请求都将失败需要注意的是即使指定了此标志仍可能需要附加权限才能够访问该文件允许随后删除文件类中的常用方法方法描述关闭当前流并释放与之关联的所有资源如套接字和文件句柄从当前流中读取字节并将其写入到另一流中释放由使用的所有资源判断指定对象是否等于当前对象确保垃圾回收器回收时释放资源并执行其他清理操作清除此流的缓冲区使得所有缓冲数据都写入到文件中默认哈希函数获取当前实例的防止其他进程读取或写入从流中读取字节块并将该数据写入给定缓冲区中从文件中读取一个字节并将读取位置提升一个字节返回表示当前对象的字符串允许其他进程访问以前锁定的某个文件的全部或部分将字节块写入文件流将一个字节写入文件流中的当前位置是一个较低级别的类是直接操作文件的字节流的无论是读取还是写入都是基于字节的它适用于需要对原始二进制数据进行精确控制的场合例如读写图像音频自定义格式的数据文件等但如果需要更复杂的数据读取写入操作那么应该考虑下面的两种方式二进制文件读写用于各种数据类型的二进制读写文本文件的读写用于文本的读写二进制文件读写中的和类可以用于二进制文件的读写类用于从文件读取二进制数据类中的常用方法如下所示方法描述关闭对象和基础流从基础流中读取字符并根据所使用的编码和从流中读取的特定字符将流的当前位置前移从当前流中读取一个布尔值并将流的当前位置前移一个字节从当前流中读取下一个字节并将流的当前位置前移一个字节从当前流中读取指定数目的字节到一个字节数组中并将流的当前位置前移指定数目的字节从当前流中读取下一个字节并把流的当前位置按照所使用的编码和从流中读取的指定的字符往前移从当前流中读取指定数目的字符并以字符数组的形式返回数据并把流的当前位置按照所使用的编码和从流中读取的指定的字符往前移从当前流中读取一个字节浮点值并把流的当前位置前移八个字节从当前流中读取一个字节有符号整数并把流的当前位置前移四个字节从当前流中读取一个字符串字符串以长度作为前缀同时编码为一个七位的整数完整的方法列表查阅的官方文档类用于向文件写入二进制数据类中的常用方法如下表所示方法描述关闭对象和基础流清理当前编写器的所有缓冲区使得所有缓冲数据写入基础设备设置当前流中的位置将一个字节的布尔值写入到当前流中表示表示将一个无符号字节写入到当前流中并把流的位置前移一个字节将一个字节数组写入到基础流中将一个字符写入到当前流中并把流的当前位置按照所使用的编码和要写入到流中的指定字符往前移将一个字符数组写入到当前流中并把流的当前位置按照所使用的编码和要写入到流中的指定字符往前移将一个字节浮点值写入到当前流中并把流位置前移八个字节将一个字节有符号整数写入到当前流中并把流位置前移四个字节将一个有长度前缀的字符串按的当前编码写如到流中并把流的当前位置按照所使用的编码和要写入到流中的指定字符往前移完整的方法列表请查阅的官方文档你好世界创建文件文件创建失败写入文件文件写入失败读取文件文件打开失败文件读取失败文本文件的读写命名空间下的和类可以用于文本文件的数据读写这些类继承自抽象基类类提供了对文件流读写的功能类继承自抽象基类用来从文件中读取一系列字符下表列出了类中一些常用的方法方法描述关闭对象和基础流并释放任何与之相关的系统资源返回下一个可用的字符但不使用它从输入流中读取下一个字符并把字符位置往前移一个字符完整的方法列表可以访问的官网文档创建类的对象从文件中读取内容类同样继承自抽象类用来向文件中写入一系列字符下表列出了类中一些常用的方法方法描述关闭当前的对象和基础流清理当前所有的缓冲区使所有缓冲数据写入基础流将布尔值的文本表示形式写入文本流将一个字符写入流将一个小数值的文本表示形式写入文本流将一个字节浮点值的文本表示形式写入文本流将一个字节有符号整数的文本表示形式写入文本流将一个字符串写入文本流将行结束符写入文本流完整的方法列表查阅的官方文档要写入文件中的数据你好世界创建类的对象将数组中的数据写入文件目录操作类派生自类其中提供了各种用于创建移动浏览目录和子目录的方法需要注意的是该类不能被继承常用属性属性描述获取当前文件或目录的属性获取当前文件或目录的创建时间获取一个表示目录是否存在的布尔值获取表示文件存在的字符串获取目录或文件的完整路径获取当前文件或目录最后被访问的时间获取该实例的名称常用方法方法描述创建一个目录在指定的路径上创建子目录指定的路径可以是相对于类的实例的路径如果为空的则删除该返回当前目录的子目录从当前目录返回文件列表完整的方法以及属性介绍查阅官方文档获取当前目录文件列表创建一个对象获取目录中的文件以及它们的名称和大小文件名称大小文件操作类派生自类其中提供了用于创建复制删除移动打开文件的属性和方法与类相同类也不能被继承常用属性属性描述获取当前文件的属性获取当前文件的创建时间获取文件所属目录的一个实例获取一个表示文件是否存在的布尔值获取表示文件存在的字符串获取文件的完整路径获取当前文件最后被访问的时间获取文件最后被写入的时间获取当前文件的大小以字节为单位获取文件的名称常用方法方法描述创建一个追加文本到由的实例表示的文件中创建一个文件永久删除一个文件移动一个指定的文件到一个新的位置提供选项来指定新的文件名以指定的模式打开一个文件以指定的模式使用或访问来打开一个文件以指定的模式使用或访问以及指定的分享选项来打开一个文件创建一个只读的创建一个只写的完整的方法以及属性介绍查阅官方文档特性特性是一种用于在程序运行时传递各种元素例如类方法结构枚举等行为信息的声明性代码使用特性可以将元数据例如编译器指令注释描述方法和类等信息添加到程序中提供了两种类型的特性分别是预定义特性自定义特性在中特性具有以下属性使用特性可以向程序中添加元数据元数据是指程序中各种元素的相关信息所有程序中都包含一组指定的元数据可以将一个或多个特性应用于整个程序模块或者较小的程序元素例如类和属性中特性可以像方法和属性一样接受自变量程序可使用反射来检查自己的元数据或其他程序中的元数据预定义特性中提供了三个预定义的属性预定义特性用来描述如何使用自定义特性类其中定义了可以应用特性的项目类型的语法格式如下如参数说明如下参数用来定义特性可被放置的语言元素它是枚举器的值的组合默认值是参数可选参数用来为该特性的属性提供一个布尔值默认值为单用的如果为则该特性是多用的参数可选参数用来为该特性的属性提供一个布尔值默认为不被继承如果为则该特性可被派生类继承该特性允许使用别名来取代该特性指出是一个必要参数预定义特性用来标记一个方法它的执行依赖于指定的预处理标识符根据该特性值的不同在编译时会起到不同的效果例如当值为或时会在调试代码时显示变量的值预定义特性的语法格式如下如用于在特定的编译条件下包含或排除方法的调用具体来说当编译器定义了符号时标记了的方法会被包含在编译结果中否则这些方法的调用会被忽略案例函数函数函数这个代码中特性作用于方法它告诉编译器该方法的执行应取决于预处理器符号是否被定义在代码顶部有一个预处理器指令这意味着在编译阶段符号被定义当方法前面加上特性时意味着在调试版本即符号被定义时编译代码时方法会被正常编译并执行而在发布版本即符号未定义时编译器将会移除所有对该方法的调用就像这些调用从未存在过一样这样一来当你在发布版中运行这段代码时方法不会输出任何消息因为它在编译阶段就被优化掉了而在调试版中运行时你将看到所有的消息打印出来这种方法常用于插入调试代码以便在调试阶段辅助追踪程序流程而不影响最终发布产品的性能或体积预定义特性用来标记不应被使用的程序您可以使用它来通知编译器放弃某个目标元素例如当您需要使用一个新方法来替代类中的某个旧方法时就可以使用该特性将旧方法标记为过时的并来输出一条消息来提示我们应该使用新方法代替旧方法预定义特性的语法格式如下两种任选一种语法说明如下参数是一个字符串用来描述项目为什么过时以及应该使用什么替代参数是一个布尔值默认值是编译器会生成一个警告如果设置为那么编译器会把该项目的当作一个错误已弃用请改用已弃用的函数新定义的函数已过时已弃用请改用自定义特性允许您创建自定义特性自定义特性不仅可以用于存储声明性的信息还可以在运行时被检索创建并使用自定义特性可以分为四个步骤声明自定义特性构建自定义特性在目标程序上应用自定义特性通过反射访问特性最后一步涉及编写一个简单的程序来读取元数据以便查找各种符号元数据是有关数据或用于描述其他数据信息的数据该程序应在运行时使用反射来访问属性声明自定义属性自定义特性应该继承类如下所示一个自定义特性被赋给类及其成员声明了一个名为的自定义属性构建自定义特性让我们构建一个名为的自定义特性该特性可以存储下面列举的调试信息的代码编号该的开发人员名字上次审查代码的日期一个存储了开发人员标记的字符串消息类中带有三个用于存储前三个信息的私有属性和一个用于存储消息的公有属性所以编号开发人员名字和审查日期将是类的必需的定位参数而消息则是一个可选的命名参数每个特性都至少有一个构造函数而且定位参数需要通过构造函数传递一个自定义特性被赋给类及其成员应用自定义特性通过把特性放置在紧挨着它的目标上面来应用该特性返回值类型不匹配未使用变量成员变量返回值类型不匹配一个自定义特性被赋给类及其成员通过把特性放置在紧挨着它的目标上面来应用该特性是一个自定义特性它主要用于记录与调试和错误修复相关的信息这些信息并不是直接参与到程序的运行逻辑中而是在编译后的元数据中保存可以通过反射在运行时读取这些信息这段代码中并未提供如何在运行时读取并利用这些自定义特性所携带的信息要真正发挥其作用通常还需要额外编写代码通过反射来提取和展示这些元数据属性属性是类结构体和接口的成员类或结构体中的成员变量称为字段属性是字段的扩展使用访问器可以读写私有字段的值属性没有确切的内存位置但具有可读写或计算的访问器例如有一个名为的类其中包含和三个私有字段我们不能在类的范围以外直接访问这些字段但是可以访问这些私有字段的属性在中属性提供了一种封装类字段并公开对其访问的方式属性允许您定义对类成员的访问方法这样您可以控制对类的数据的访问方式通过属性您可以实现对类的字段的读取和写入操作并在必要时执行其他逻辑比如验证输入或触发事件属性使代码更易读更易维护并提供了一种更安全的方式来访问类的数据访问器属性访问器有两种分别是属性访问器和属性访问器其中访问器用来返回属性的值访问器用来为属性设置新值在声明访问器时可以仅声明其中一个也可以两个访问器同时声明如下例所示声明类型的属性声明类型的属性声明类型的属性学生信息编号姓名年龄学生信息编号姓名年龄抽象属性抽象类中可以拥有抽象属性这些属性会在派生类中实现下面就通过一个示例来演示一下创建一个新的对象设置的和学生信息增加年龄学生信息声明类型为的属性声明类型为的属性声明类型为的属性编号姓名年龄学生信息编号姓名年龄学生信息编号姓名年龄索引器索引器英文名是类中的一个特殊成员它能够让对象以类似数组的形式来操作使程序看起来更为直观更容易编写索引器与属性属性类似在定义索引器时同样会用到和访问器不同的是访问属性不需要提供参数而访问索引器则需要提供相应的参数中属性的定义需要提供属性名称而索引器则不需要具体名称而是使用关键字来定义语法格式如下索引器类型访问器返回指定的值访问器设置指定的值索引器的使用语言中文网教程索引器索引器定义索引器重载索引器可以被重载而且在声明索引器时也可以带有多个参数每个参数可以是不同的类型另外索引器中的索引不必是整数也可以是其他类型例如字符串类型语言中文网教程索引器使用带有参数的第一个索引器使用带有参数的第二个索引器教程的索引为教程委托中的委托类似于或中的函数指针是一种引用类型表示对具有特定参数列表和返回类型的方法的引用委托特别适用于实现事件和回调方法所有的委托都派生自类在实例化委托时可以将委托的实例与具有相同返回值类型的方法相关联这样就可以通过委托来调用方法另外使用委托还可以将方法作为参数传递给其他方法委托具有以下特点委托类似于中的函数指针但委托是完全面向对象的另外中的指针会记住函数而委托则是同时封装对象实例和方法委托允许将方法作为参数进行传递委托可用于定义回调方法委托可以链接在一起例如可以对一个事件调用多个方法方法不必与委托类型完全匹配版引入了匿名函数的概念可以将代码块作为参数而不是单独定义的方法进行传递引入了表达式利用它们可以更简练地编写内联代码块匿名方法和表达式都可编译为委托类型这些功能现在统称为匿名函数声明委托声明委托需要使用关键字语法格式如下其中为返回值类型为委托的名称为参数列表提示委托可以引用与委托具有相同签名的方法也就是说委托在声明时即确定了委托可以引用的方法实例化委托委托一旦声明想要使用就必须使用关键字来创建委托的对象同时将其与特定的方法关联如下例所示声明一个委托实例化委托对象并将其与方法关联实例化委托对象并将其与方法关联委托案例定义委托被委托的函数被委托的函数创建委托实例实例化委托实例化委托使用委托对象调用方法使用委托的值为使用委托的值为常用的委托类型表示带有一个输入参数和一个返回值的方法表示没有返回值的方法表示用于定义一组条件的方法并返回布尔值如实际上就等同于多播委托合并委托委托对象有一个非常有用的属性那就是可以通过使用运算符将多个对象分配给一个委托实例同时还可以使用运算符从委托中移除已分配的对象当委托被调用时会依次调用列表中的委托委托的这个属性被称为委托的多播也可称为组播利用委托的这个属性您可以创建一个调用委托时要调用的方法列表注意仅可合并类型相同的委托所有委托都支持单一回调换言之多重性等于然而一个委托变量可以引用一系列委托在这一系列委托中每个委托都顺序指向一个后续的委托从而形成了一个委托链或者称为多播委托使用多播委托可以通过一个方法对象来调用一个方法链创建变量来引用定义委托创建委托实例调用多播的值为的值为自我理解相当于指针但比指针多了一个组合功能可以让一个委托为好几个不同的委托的组合打印案例定义一个委托我们使用这个委托来调用两个方法第一个把字符串打印到控制台第二个把字符串打印到文件委托声明该方法打印到控制台该方法打印到文件该方法把委托作为参数并使用它调用方法语言中文网事件在中事件可以看作是用户的一系列操作例如点击键盘的某个按键单击移动鼠标等当事件发生时我们可以针对事件做出一系列的响应例如退出程序记录日志等等中线程之间的通信就是使用事件机制实现的在中事件是一种特殊的委托它允许类对象通知其他类对象发生的特定动作在中你可以使用回调函数来实现类似的功能但是事件在中提供了更强大和更易于使用的机制来实现类似的行为事件需要在类中声明和触发并通过委托与事件处理程序关联事件可以分为发布器和订阅器两个部分其中发布器是一个包含事件和委托的对象事件和委托之间的联系也定义在这个类中发布器类的对象可以触发事件并使用委托通知其他的对象订阅器则是一个接收事件并提供事件处理程序的对象发布器类中的委托调用订阅器类中的方法事件处理程序有关事件我们需要注意以下几点发布器确定何时触发事件订阅器确定对事件作出何种响应一个事件可以拥有多个订阅器同时订阅器也可以处理来自多个发布器的事件没有订阅器的事件永远也不会触发事件通常用于定义针对用户的操作例如单击某个按钮如果事件拥有多个订阅器当事件被触发时会同步调用所有的事件处理程序在类库中事件基于委托和基类若要在类中声明一个事件首先需要为该事件声明一个委托类型例如然后使用关键字来声明事件本身如下所示基于上面的委托定义事件上例中定义了一个名为和名为的事件当事件触发的时侯会调用委托实例发布器类实例订阅器类语言中文网发布器类触发事件订阅器类注意点事件添加事件事件添加事件会产生事件循环集合中的集合类是专门用于数据存储和检索的类类中提供了对栈队列列表和哈希表的支持大多数集合类都实现了相同的接口集合类的用途多种多样例如可以动态的为元素分配内存根据索引访问列表项等等这些类创建类的对象集合类是中所有数据类型的基类类描述和用法动态数组动态数组表示可被单独索引的对象的有序集合动态数组基本上与数组相似唯一不同的是动态数组可以使用索引在指定的位置添加和移除项目动态数组会自动重新调整自身的大小另外动态数组也允许在列表中进行动态内存分配增加搜索排序等等哈希表哈希表可以使用键来访问集合中的元素哈希表中的每一项都由一个键值对组成键用于访问集合中的指定项排序列表排序列表是数组和哈希表的组合可以使用键或索引来访问列表中的各项排序列表中包含一个可使用键或索引访问各项的列表如果您使用索引访问各项则它是一个动态数组如果您使用键访问各项则它就是一个哈希表另外排序列表中的各项总是按键值进行排序的自排序与一致键必须唯一堆栈堆栈代表了一个后进先出的对象集合当您需要对各项进行后进先出的访问时则可以使用堆栈为堆栈中添加一项称为推入项目从堆栈中移除一项称为弹出项目队列队列代表了一个先进先出的对象集合当您需要对各项进行先进先出的访问时则可以使用队列为队列中添加项目称为入队为队列中移除项目称为出队点阵列点阵列代表了一个使用和来表示的二进制数组当您需要存储比特位但是事先不知道具体位数时则可以使用点阵列可以使用整型索引从点阵列集合中访问各项索引从零开始动态数组在中动态数组代表了可被单独索引的对象的有序集合动态数组基本上可以代替数组唯一与数组不同的是动态数组可以使用索引在指定的位置添加和移除指定的项目动态数组会自动重新调整自身的大小另外动态数组允许在列表中进行动态内存分配增加搜索排序等操作属性描述获取或设置动态数组中可以包含的元素个数获取动态数组中实际包含的元素个数判断动态数组是否具有固定大小判断动态数组是否只读判断访问动态数组是否同步线程安全获取或设置指定索引处的元素获取一个对象用于同步访问动态数组方法名描述将对象添加到动态数组的末尾将的元素添加到动态数组的末尾从动态数组中移除所有的元素判断某个元素是否在动态数组中返回一个动态数组表示源动态数组中元素的子集搜索整个动态数组并返回对象在动态数组中第一次出现的索引索引从零开始在动态数组的指定索引处插入一个元素在动态数组的指定索引处插入某个集合的元素从动态数组中移除指定的对象移除动态数组中指定索引处的元素从动态数组中移除某个范围的元素逆转动态数组中元素的顺序复制某个集合的元素到动态数组中某个范围的元素上对动态数组中的元素进行排序将容量设置为动态数组中元素的实际个数关于类中的完整属性和方法介绍可以查阅官方文档存案例添加类型数据到遍历并输出类型数据哈希表在中哈希表类表示根据键的哈希代码进行组织的键值对的集合可以使用键来访问集合中的元素也就是说当您需要使用键来访问指定元素时可以选择使用哈希表属性描述获取哈希表中包含的键值对的个数获取一个值用来表示哈希表是否具有固定大小获取一个值用来表示哈希表是否只读获取或设置与指定键关联的值获取一个其中包含哈希表中的键获取一个其中包含哈希表中的值方法名描述向哈希表中添加一个带有指定的键和值的元素从哈希表中移除所有的元素判断哈希表是否包含指定的键判断哈希表是否包含指定的值从哈希表中移除带有指定的键的元素关于类中的完整属性和方法介绍可以查阅官方文档排序列表在中类用来表示键值对的集合这些键值对按照键值进行排序并且可以通过键或索引访问集合中的各个项我们可以将排序列表看作是数组和哈希表的组合其中包含了可以使用键或索引访问各项的列表如果您使用索引访问各项那么它就是一个动态数组如果您使用键访问各项那么它就是一个哈希表另外集合中的各项总是按键值进行排序属性描述获取或设置排序列表中可包含的元素个数获取排序列表中的元素个数判断排序列表是否具有固定大小判断排序列表是否只读获取或设置排序列表中指定键所关联的值获取一个包含排序列表中所有键的集合获取一个包含排序列表中所有值的集合方法名描述向排序列表中添加一个带有指定的键和值的元素从排序列表中移除所有的元素判断排序列表中是否包含指定的键判断排序列表中是否包含指定的值获取排序列表中指定索引处的值获取排序列表中指定索引处的键获取排序列表中的键获取排序列表中的值返回排序列表中指定键的索引索引从零开始返回排序列表中指定值第一次出现的索引索引从零开始从排序列表中移除带有指定键的元素移除排序列表中指定索引处的元素将排序列表的容量设置为排序列表中元素的实际个数关于类中的完整属性和方法介绍可以查阅官方文档堆栈在中堆栈类表示一个后进先出的对象集合当您需要对项目进行后进先出的访问时则可以使用堆栈向堆栈中添加元素称为推入元素从堆栈中移除元素称为弹出元素属性描述获取堆栈中包含的元素个数判断是否同步对堆栈的访问线程安全获取可用于同步对堆栈访问的对象方法名描述从堆栈中移除所有的元素判断某个元素是否在堆栈中返回在堆栈顶部的对象但不移除它移除并返回在堆栈顶部的对象向堆栈顶部添加一个对象复制堆栈到一个新的数组中关于类中的完整属性和方法介绍可以查阅官方文档队列在中队列类与堆栈类似它代表了一个先进先出的对象集合当您需要对项目进行先进先出访问时则可以使用队列向队列中添加元素称为入队从堆栈中移除元素称为出队属性描述获取队列中包含的元素个数判断是否同步对队列的访问线程安全获取可用于同步对队列访问的对象方法名描述从队列中移除所有的元素判断某个元素是否在队列中移除并返回在队列开头的对象向队列的末尾处添加一个对象复制队列到一个新的数组中将队列的容量设置为队列中元素的实际个数点阵列在中类用来管理一个紧凑型的位值数组数组中的值均为布尔类型其中表示此位为开启表示此位为关闭当您需要存储位英文名数据存储的最小单位也可称为比特但事先又不知道具体位数时就可以使用点阵列当需要访问点阵列中的元素时可以使用整型索引从点阵列中访问指定元素索引从零开始属性描述获取点阵列中包含的元素个数判断点阵列是否只读获取或设置点阵列中指定位置的值获取或设置点阵列中的元素个数方法名描述对当前的点阵列中的元素和指定点阵列中相对应的元素执行按位与操作获取点阵列中指定位置的位值反转当前点阵列中所有位的值即将设置为将设置为对当前点阵列中的元素和指定点阵列中的相对应的元素执行按位或操作把点阵列中指定位置的位设置为指定的值把点阵列中的所有位设置为指定的值对当前点阵列中的元素和指定点阵列中的相对应的元素执行按位异或操作关于类中的完整属性和方法介绍可以查阅官方文档并发队列是一个线程安全的队列适用于多线程环境提供了和等方法来操作队列适合于需要高并发读写的场景能够有效地避免锁竞争综合以上两种实现方式在支持多线程并发出队并发入队的情况下使用了分段存储的概念如上图所示分配内存时以段为单位一个段内部含有一个默认长度为的数组和执行下一个段的指针有个和和指针分别指向了起始段和结束段这种结构有点像操作系统的段式内存管理和页式内存管理策略这种分配内存的实现方式不但减轻的的压力而且调用者也不用显示的调用方法回收内存在某段内存为空时会由来回收该段内存内部和用数组实现的普通队列相当只不过对于入队和出队操作使用了原子操作来防止多线程竞争问题使用随机退让等技术保证活锁等问题实现机制和差别不大跟多的实现细节在源码注释中已经阐述的非常清楚这里就再做不过多的解释随机退让技术说明使用随机退让技术时线程在发现无法获取资源时不会立即重试而是会随机等待一段时间这样线程可能会在之后成功获取资源从而打破活锁状态引入命名空间并初始化属性盘点属性说明获取中包含的元素数获取一个值该值指示是否为空方法盘点从中移除所有对象从指定数组索引开始将元素复制到现有一维数组中将对象添加到的结尾处确定指定对象是否等于当前对象返回循环访问的枚举数作为默认哈希函数获取当前实例的创建当前对象的浅表副本将中存储的元素复制到新数组中返回表示当前对象的字符串尝试移除并返回并发队列开头处的对象尝试返回开头处的对象但不将其移除主要成员入队出队是否为空获取队列内元素数量阻塞集合是中提供的一个线程安全的集合类主要用于在生产者消费者模式中进行数据的安全传递它实现了接口支持多线程环境下的并发操作实际上就是一个自带信号量的在的基础上通过内置信号量机制扩展了堵塞功能主要特性线程安全是线程安全的多个线程可以同时添加和取出元素阻塞操作当集合为空时尝试取出元素的线程会被阻塞直到有元素可用当集合达到最大容量时尝试添加元素的线程会被阻塞直到有空间可用可设置的容量可以指定集合的最大容量防止内存过度使用构造设置容量设置容量大小如果不传参表示无限容量如果集合达到这个容量尝试添加新元素的线程将会被阻塞直到有空间可用主要方法添加元素将元素添加到集合中如果集合已满则阻塞直到有空间可用支持取消操作取出元素从集合中取出一个元素如果集合为空则阻塞直到有元素可用支持取消操作用途返回一个消费者可以通过这个枚举器逐个消费集合中的元素行为当集合中没有元素时会阻塞当前线程直到有新的元素被添加到集合中一旦消费者从枚举器中获取了一个元素该元素会从集合中移除当被调用并且集合中没有更多元素时枚举器会结束适用场景适用于需要持续消费元素的场景特别是在生产者消费者模式中消费者线程需要不断处理新元素消费者任务使用模拟消费延迟尝试添加元素尝试添加元素如果集合已满则返回在指定的时间内尝试添加元素尝试取出元素尝试从集合中取出一个元素如果集合为空则返回在指定的时间内尝试取出元素完成添加标记集合为完成添加之后不再允许添加新元素调用后会将设置为任何尝试调用或方法向集合中添加新元素的操作都会抛出异常调用后消费者仍然可以继续消费集合中剩余的元素直到集合为空检查是否已完成检查是否已完成添加所有容器总结盘点所有容器数组固定大小的连续内存块用于存储相同类型的数据列表动态大小的数组支持快速随机访问但插入和删除操作在中间位置可能比较慢字典使用键值对存储数据支持快速查找插入和删除操作键必须是唯一的哈希集存储不重复的元素支持快速查找插入和删除操作链表使用节点存储数据节点之间通过指针链接支持快速插入和删除操作但随机访问比较慢队列先进先出的数据结构支持快速入队和出队操作栈后进先出的数据结构支持快速入栈和出栈操作可观察集合支持通知机制当集合发生变化时会通知订阅者可枚举集合定义了遍历集合的接口允许使用循环访问集合中的元素可查询集合定义了查询集合的接口允许使用查询语言对集合进行查询排序列表存储键值对根据键进行排序支持快速查找操作排序字典存储键值对根据键进行排序支持快速查找插入和删除操作并发背包线程安全的集合支持并发添加和删除操作但不保证元素的顺序并发队列线程安全的队列支持并发入队和出队操作并发栈线程安全的栈支持并发入栈和出栈操作并发字典线程安全的字典支持并发查找插入和删除操作阻塞集合线程安全的集合支持生产者消费者模式当集合为空时消费者会阻塞等待生产者添加元素只读集合只读集合不允许修改集合中的元素只读字典只读字典不允许修改字典中的键值对不可变字典不可变性和线程安全机制中所有的容器都实现了实现接口接口通过实现接口可以使自定义的集合类能够被语句简单遍历提供了一种统一的遍历集合元素的方式摘要公开枚举器支持对指定类型的集合进行简单迭代类型参数要枚举的对象的类型摘要返回一个枚举器用于遍历集合返回结果一个可用于遍历集合的枚举器遍历方式实现了使用接口手动迭代可以通过手动调用枚举器对象的方法来遍历集合元素而不是使用语句使用接口的方法可以实现更灵活的遍历方式例如条件遍历跳过元素等操作查询提供了丰富的查询操作符可以对实现了接口的集合进行查询和筛选可以使用查询来对集合进行排序过滤投影等操作泛型在中泛型是一种规范它允许我们使用占位符来定义类和方法编译器会在编译时将这些占位符替换为指定的类型利用泛型的这一特性我们可以定义为通用类泛型类通用方法泛型方法定义通用类需要使用尖括号这里的尖括号用于将类或方法声明为泛型可以将泛型看作是一种增强程序功能的技术泛型类和泛型方法兼具可重用性类型安全性和效率这是非泛型类和非泛型方法无法实现的泛型通常与集合以及作用于集合的方法一起使用命名空间下就包含几个基于泛型的集合类下面总结了一些关于泛型的特性使用泛型类型可以最大限度地重用代码保护类型的安全性以及提高性能泛型最常见的用途是创建集合类类库在命名空间中包含几个新的泛型集合类您可以使用这些类来代替中的集合类您可以创建自己的泛型接口泛型类泛型方法泛型事件和泛型委托您也可以对泛型类进行约束以访问特定数据类型的方法在泛型数据类型中所用类型的信息可在运行时通过使用反射来获取泛型类泛型方法语言中文网泛型方法在交换之前显示值调用之前的值调用之前的字符值调用在交换之后显示值调用之后的值调用之后的字符值泛型委托创建委托实例使用委托对象调用方法的值为的值为匿名函数方法在中可以将匿名函数简单的理解为没有名称只有函数主体的函数匿名函数提供了一种将代码块作为委托参数传递的技术它是一个内联语句或表达式可在任何需要委托类型的地方使用匿名函数可以用来初始化命名委托或传递命名委托作为方法参数无需在匿名函数中指定返回类型返回值类型是从方法体内的语句推断出来的名函数是通过使用关键字创建的委托实例来声明的匿名函数传递给了委托作为对比查看命名函数实例化委托假设这个命名函数名为委托可以通过匿名函数调用也可以通过普通有名称的函数调用只需要向委托对象中传递相应的方法参数即可注意匿名函数的主体后面需要使用结尾的方式定义匿名函数在中是一种代表不返回值的委托类型它可以用来定义一个接受零个到多个参数的方法并且不返回任何值下面是一个示例演示了如何使用中的来定义一个没有参数的方法可以使用来定义一个带有多个参数的委托以下是一个示例可以直接整合到一块一步到位调用定义了一个带有两个参数一个整数和一个字符串的委托并创建了一个匿名函数来输出这两个参数的值指针变量与为了保持类型的安全性默认情况下是不支持指针的但是如果使用关键字来修饰类或类中的成员这样的类或类中成员就会被视为不安全代码允许在不安全代码中使用指针变量在公共语言运行时中不安全代码是指无法验证的代码不安全代码不一定是危险的只是无法验证该代码的安全性因此仅会执行信任程序集中包含的不安全代码指针变量在中指针同样是一个变量但是它的值是另一个变量的内存地址在使用指针之前我们同样需要先声明指针声明指针的语法格式如下所示示例说明是指向整数的指针是指向双精度数的指针是指向浮点数的指针是指向整数的指针的指针是指向整数的指针的一维数组是指向字符的指针是指向未知类型的指针数据的内容是数据在内存中的地址是提示在编译上述代码时需要在编译命令中添加例如在中我们可以使用来获取指针变量所指向的数据的值变量的值为指针指向的值为指针的值为使用指针访问数组元素在中数组和指向该数组且与数组名称相同的指针是不同的数据类型例如和就是不同的数据类型您可以增加指针变量的值因为它在内存中不是固定的但数组地址在内存中是固定的因此您不能增加数组的值如果您需要使用指针变量访问数组数据使用关键字来固定指针下面通过示例演示一下在中固定语句通常用于与非托管代码进行交互非托管代码是指直接操作内存或者由其他语言编写的代码通常不受垃圾回收器的管理当你需要将中的托管对象传递给非托管代码时必须确保这些对象在内存中不会被移动因为非托管代码可能会持有指向这些对象的指针通过使用固定语句你可以确保在固定块内的对象不会被垃圾回收器移动从而保证非托管代码能够正确地访问这些对象的内存位置中的垃圾回收器是自动管理的它负责在程序运行时检测和回收不再被程序使用的内存垃圾回收器使用一种叫做标记清除的算法来确定哪些内存块是可以回收的当垃圾回收器检测到某个对象不再被引用时它会将其标记为可回收并在适当的时机清除这些对象以释放内存这种自动内存管理机制让开发人员不必手动管理内存减少了内存泄漏和其他内存相关的问题显示指针中数组地址的内存地址为的值为编译不安全代码为了编译不安全代码在编译时必须使用命令例如编译包含不安全代码的程序的命令如下所示或如果您使用的是那么您需要在项目属性中启用不安全代码具体步骤如下通过双击资源管理器中的属性节点打开项目属性点击标签页选择选项多线程多线程就是多个线程同时工作的过程我们可以将线程看作是程序的执行路径每个线程都定义了一个独特的控制流用来完成特定的任务如果您的应用程序涉及到复杂且耗时的操作那么使用多线程来执行是非常有益的使用多线程可以节省资源同时提高应用程序的执行效率例如现代操作系统对并发编程的实现就用到了多线程到目前为止我们编写的示例程序都是单线程的应用程序这样的应用程序一次只能执行一个任务线程生命周期线程生命周期开始于我们创建类对象的时候当线程被终止或完成执行时生命周期终止下面列出了线程生命周期中的各种状态未启动状态当线程实例被创建但方法未被调用时的状况就绪状态当线程准备好运行并等待周期时的状况不可运行状态下面的几种情况下线程是不可运行的已经调用方法已经调用方法通过操作阻塞死亡状态当线程已完成执行或已中止时的状况主线程在中类用于处理线程它允许在多线程应用程序中创建和访问各个线程在多线程中执行的第一个线程称为主线程当程序开始执行时将自动创建主线程而使用类创建的线程则称为子线程您可以使用类的属性访问线程下面通过示例程序演示主线程的执行主线程这是输出这是主线程类属性描述获取线程正在执行的上下文获取或设置当前线程的区域性获取或设置线程的当前负责人对基于角色的安全性而言获取当前正在运行的线程获取或设置资源管理器使用的当前区域性以便在运行时查找区域性特定的资源获取一个对象该对象包含有关当前线程的各种上下文的信息获取当前线程的执行状态获取或设置一个值该值表示某个线程是否为后台线程获取线程是否属于托管线程池获取当前托管线程的唯一标识符获取或设置线程的名称获取或设置线程的调度优先级获取当前线程的状态方法名描述在调用此方法的线程上引发以终止此线程在所有的线程上分配未命名的数据槽为了获得更好的性能请改用以特性标记的字段在所有线程上分配已命名的数据槽为了获得更好的性能请改用以特性标记的字段通知主机执行将要进入一个代码区域在该代码区域内线程中止或未经处理的异常的影响可能会危害应用程序域中的其他任务通知主机托管代码将要执行依赖于当前物理操作系统线程的标识指令通知主机执行将要进入一个代码区域在该代码区域内线程中止或未经处理的异常仅影响当前任务通知主机托管代码已执行完依赖于当前物理操作系统线程的标识指令为进程中的所有线程消除名称与数据槽之间的关联为了获得更好的性能请改用以特性标记的字段检索当前线程中指定的值为了获得更好的性能请改用以特性标记的字段返回当前线程运行的域返回应用程序域的唯一标识符查找已命名的数据槽为了获得更好的性能请改用以特性标记的字段中断处于状态的线程在继续执行标准的和消息泵处理期间阻塞调用线程直到某个线程终止为止此方法有不同的重载形式按如下方式同步内存访问执行当前线程的处理器在对指令重新排序时不能采用先执行调用之后的内存存取再执行调用之前的内存存取的方式取消为当前线程请求的在当前正在运行的线程上的指定槽中为此线程的当前域设置数据为了获得更好的性能请改用以特性标记的字段开始一个线程让线程暂停一段时间让线程等待一段时间时间长短由参数定义读取字段值无论处理器的数目或处理器缓存状态如何该值都是由计算机处理器写入的最新值立即向字段中写入一个值并使该值对计算机中的所有处理器都可见终止当前正在调用的线程并执行另一个准备运行的线程由操作系统选择将要执行的另一个线程创建线程是通过扩展类来创建线程的然后使用扩展的类调用方法开始执行子线程执行子线程这行代码定义了一个委托该委托不支持返回值也不支持传参类型的变量它指向一个名为的方法在函数中创建子线程这行代码创建了一个新的线程对象并将之前定义的委托作为参数传递给线程对象启动了子线程中止子线程上不支持该函数以下是一个简单的示例演示如何使用在中执行异步操作模拟耗时操作报告进度在这个示例中在后台线程中执行一个简单的计数操作每次递增并报告进度主线程不会被阻塞可以继续执行其他操作与的区别是一个高级别的组件封装了在后台执行操作的细节使得在线程上执行操作和在后台线程上执行操作更加容易它提供了事件来报告进度和完成状态并且可以在线程中方便地更新元素是一个更底层的多线程类可以更灵活地控制线程的创建和管理但是使用需要手动处理线程的生命周期线程同步和异常处理等问题相对复杂一些获取线程不推荐使用这个这种方式更轻量化打印线程函数可封装成如下的效果会被传入调用者的方法名线程异步编程模型什么是异步异步是一个更广泛的行为开个线程也叫异步回调也叫异步中的和关键字是异步编程的核心通过这两个关键字可以使用或运行时中的资源轻松创建异步方法几乎与创建同步方法一样轻松将方法标记为异步方法表示该方法可能包含异步操作最终是否采用异步执行是否真使用了多线程不决定于是否用方式调用这个方法而决定于这个方法内部是否有方式的调用只有将方法标记后才可以在方法中使用关键字用于等待一个操作完成的结果然后继续执行下面的代码只能在方法内部使用在异步中表达的意思是当前线程方法中引导的方法出结果前跳出当前线程方法从调用当前线程方法的位置去执行其它可能执行的线程方法并在引导的方法出结果后把运行点拉回到当前位置继续执行直到遇到下一个或线程方法完成返回跳回去刚才外部最后执行的位置继续执行因此不会堵塞线程虽然表现上是停止往后运行了可以理解为堵塞了逻辑但不堵塞线程线程实际上去干别的了在通过函数时会等待函数执行完才回来继续执行下一句代码但如果不通过执行一个内含的函数那么程序才是真正异步执行存在子线程执行的情况注意可以作用于任务而不一定要作用于方法要真正使用异步被调用函数被标记被调用函数内部使用了调用被调用函数的时候没写才是真正使用异步如果使用了方式调用被调用函数那么实际上是堵塞了代码逻辑线程切换时机此处结合使用了获取线程获取线程中的代码案例如下打印如下线程线程线程线程可见在之前是同一个线程执行在其之后包括本身是另一个线程执行使用可以让等待后回来执行的线程与离开的线程是同一个即不会切换线程等待后继续在原来的上下文中执行后续代码但是注意该效果只在或中有效控制台程序无效理解同步上下文在和应用程序中存在一个同步上下文它负责管理线程的执行当你在线程上运行异步代码时会捕获当前的同步上下文并在等待完成后返回到同一个上下文中继续执行后续代码这意味着如果你在线程上调用那么在等待结束后代码会在线程中继续执行从而可以安全地更新控件控制台程序控制台应用程序默认没有同步上下文这意味着在控制台程序中使用时不会有任何效果因为没有上下文可供返回完成后会在线程池线程上继续执行后续代码因此在控制台应用程序中即使你使用也不会保证后续代码在原来的线程上执行中在中线程会有一个与之关联的当你在线程上调用一个方法并使用时会自动捕获当前的同步上下文即线程的上下文并在异步操作完成后返回到同一个上下文中继续执行后续代码无需使用由于的会自动处理上下文切换因此在中通常不需要使用这意味着你可以安全地在方法中更新控件而不必担心线程安全问题异步编程的重要思想是不阻塞会暂时释放当前线程使得该线程可以执行其他工作而不必阻塞线程直到异常操作完成不应该在异步方法中用任何方式阻塞当前线程更细地讲就是或中之前一定不能阻塞此时还在原线程中下面罗列常见阻塞线程情形等操作的同步方法其他繁重且耗时的任务因此要注意当这些阻塞线程的行为在方法中的第一次使用代码之前调用的时候实际上还是会被阻塞线程因为此时还没有切到别的线程同步上下文的理解同步上下文是一种管理和协调线程的机制允许开发者将代码的执行切换到特定的线程与拥有同步上下文线程而控制台程序默认没有通过来设置执行后是否回到原线程表示回到原线程一般只有线程会采用这种策略关于同步上下文导致的死锁此处记录一个关于同步上下文导致的死锁情况的经典案例完成后将回到线程按钮点击事件绑定的方法内部调用了会导致线程堵塞直到得到的返回结果的结果需要号代码能返回到线程可线程又正在被堵塞中于是陷入死锁上面的代码将导致死锁不是卡住秒而是一直卡住通俗地讲就是你托线程带个东西回来东西不带回来就线程别想回来还只能当前线程带回来于是导致死锁解决方法是改编号的代码为可以通俗理解为你要求线程带个东西回来东西不带回来线程就别想回来但可以托别的线程带回来别的线程把东西带回来了线程也就可以回来了控制的调度方式和运行线程用法可参考此处线程池线程当前线程单线程上下文长时间运行线程也可以设置优先级上下文执行状态等直接调用方法一发即忘调用一个异步方法但是不使用或阻塞的方式去等待它的结束无法观察任务的状态是否完成是否报错等返回值相关使用关键字标记的函数通常需要返回一个下面类型的结果类型表示异步操作完成后不返回任何结果类型表示异步操作完成后返回一个类型的值类型通常用于事件处理程序等异步操作中表示异步操作完成后不返回任何结果但可能通过事件或其他机制通知调用方命名规范命名异步方法时可以在方法名后面加上后缀以明确表示它是一个异步方法例如堵塞下载完成堵塞下载内容长度方法和方法都被标记为在方法内部通过等待方法的异步操作完成这样程序能够在等待异步操作的同时继续执行其他代码提高了程序的并发性和响应性执行流程调用函数的时候没有前缀又是一个被标识的函数因此函数会由子线程执行输出为原理相关与组合使用会将方法包装成设计模式状态模式状态机方法会被底层调用从而切换状态查看上面代码会被编译器编译的时候包装成一个状态机经过一定的变量名修改以及提取核心代码段后的代码如下属性表示下面的类是编译器生成的通常用于异步方法的状态机定义一个名为的密封类它继承自密封类意味着这个类不能被继承并且所有成员都是私有的除非声明为公共或受保护定义一个名为的公共整数属性用于存储状态机的当前状态这个属性没有指定的访问修饰符默认为定义一个名为的公共类型的属性用于异步方法的启动和完成并跟踪异步操作的状态定义一个名为的公共类型的属性这个属性通常用于存储异步操作的实例如果有定义一个名为的私有类型的字段这个字段用于存储异步操作的等待器允许状态机在异步操作完成时恢复执行定义一个名为的私有方法这个方法包含了状态机的逻辑根据当前状态执行相应的操作声明一个名为的整型变量并初始化为当前状态声明一个名为的类型局部变量判断当前状态是否为如果当前状态不是通过创建一个新的判断新创建的是否已完成如果没有完成则将当前状态设置为并将新创建的赋给以便之后恢复执行创建一个名为的类的实例以便在之后使用它恢复执行通过引用和启动一个异步等待操作这样当完成时状态机可以恢复执行如果当前状态是则将的值赋给并将当前状态设置为标记为完成等待完成重置为默认状态获取的结果如果有异常则抛出如果发生异常将当前状态设置为并通过引用设置异常给异步任务执行结束将当前状态设置为表示异步任务已完成通过引用设置异步任务完成定义一个名为的公共方法这个方法可能是异步操作的入口点创建一个类的实例用于管理异步操作的状态获取或创建一个实例并将其赋值给这个对象将允许启动和跟踪异步操作的进度将当前类的实例赋值给可能是为了在异步操作中访问当前类的成员或方法设置的当前状态为可能表示异步操作的初始状态或者是某种特定的起始状态启动的异步操作通过引用实例异步操作会根据的值执行相应的逻辑返回创建的对象这个对象代表了异步操作的执行可以通过它来跟踪异步操作的进度或等待其完成只是决定是否将其转换为一个状态机而被包装的方法还是个但是如果方法中没有操作他其实是个同步方法因为遇到才可能涉及到线程切换因此是给编译器看的本质上返回的仍然是只不过通过编译器提供了语法糖也因此接口中无法声明还带另一个语法糖在其中写返回值可以直接写中的类型不用包装成如下必须返回同理加了后理解几乎只用于对事件的注册因为对事件的注册没办法写与相比同样会被包装成状态机但缺少记录状态的对象由于还包含了异步任务里面的异常信息因此无法聚合异常需要谨慎处理异常下面展示一个异常案例捕获异常等待异步完成此抛出的异常不会被块捕获因此在使用事件注册的时候需要异步的情况下不得不使用的时候一定注意在事件注册方法中做异常处理只有返回的才能被等待结果异步完成后执行的另一种方式是用于任务的延续操作的方法它允许您在一个任务完成后执行另一个任务方法接受一个委托作为参数表示在原始任务完成后要执行的操作使用方法可以实现任务之间的串行执行确保一个任务完成后再执行另一个任务您还可以通过方法指定不同的任务调度选项和取消标记以满足更复杂的需求是异步编程中一个非常有用的方法可以帮助您构建复杂的任务流程和处理异步操作的结果执行一些耗时操作原始任务完成延续任务开始在原始任务完成后执行的操作堵塞等待延续任务完成传染性异步编程具有传染性一处处处几乎所有自带方法都提供了异步的版本如果真的遇到了只提供同步的方案也可以使用把他包装成一个异步的方法内置异步方法非常多随意罗列一些同步异步技巧如何创建异步任务将同步任务直接包装成异步任务如何同时开启多个异步任务如何取消任务使用取消任务任务取消推荐所有的异步方法都带上这一传参是中处理异步操作取消的重要工具通过合理使用和可以有效地管理长时间运行的任务并在需要时安全地取消它们表示请求取消操作的标志它是一个轻量级的结构通常用于传递给支持取消的异步方法用于创建的对象并提供取消操作的功能创建也可以用于同步任务不是只能用于异步任务任务超时如何实现使用实现异步任务之间的通信参考视频类似以及这种内部函数本质都是同步方法是一个高性能的线程安全库专为生产者消费者场景设计用于解耦生产者和消费者任务提升并发处理能力命名空间核心作用与优势解耦生产者与消费者通过异步读写机制允许生产者和消费者独立工作互不阻塞提高吞吐率动态扩展性支持按需增加生产者或消费者数量应对负载不均衡场景高性能相比和在单一职责存储场景下性能更高线程安全内置同步机制支持多线程并发读写特性核心职责存储存储处理流水线存储性能高线程安全优化中低适用场景纯生产者消费者模型复杂数据处理流水线简单同步队列创建无限容量通道适用于不确定数据量或瞬时高吞吐场景可配置和限制多线程操作默认为单线程操作有限容量通道设置满容策略单线程单线程满容策略阻塞写入直到有空间丢弃新写入的数据丢弃最旧数据腾出空间丢弃最新数据腾出空间读写操作方法用途非阻塞写入同步异步阻塞写入参数可以接受非阻塞读取同步异步阻塞读取参数可以接受异步等待直到允许写入异步等待直到允许读取通过异步写入通过或非阻塞循环读取异步等待数据到达避免忙等待确保并发场景下安全读取生产完成通知告诉生产完成了当消费者消费完剩余量后将会触发异常虽然使用也可以判断是否完成了但是只有读取的那瞬间能确定是否完成由于程序执行流程的不确定性建议通过来判断已完成案例多生产者多消费者模型多线程写入多线程读取返回异步流支持并行处理如果是消费者的需要使用可以直接传也可以而不必要整个传过去在异步任务中汇报进度参考此处如何在同步方法中调用异步方法使用包裹就可以很简单的将一个同步方法转换为一个异步方法也就可以使用等待结果如何终止一个同步任务下面方式似乎可行实则不行因为下面的两个方法均是只是获得了超时的执行时间点并没有真正将同步任务给终止控制被封装为异步任务的同步任务的执行超时时间可以使用封装起来之后使用使用并传超时时间参数来设置超时时间还有一种很巧妙的方式是个同步任务未完待续真正终止同步方法参考此视频和方法的区别用于将一个同步方法或代码块放到线程池中异步执行它通常用于将密集型的任务移出主线程以避免阻塞用户界面是用于定义一个异步方法这个方法可以使用操作符来异步等待其他异步任务的完成它通常用于密集型的操作例如网络请求或文件读取在中使用启动的任务可以通过关键字异步等待其结果同时保持主线程不被阻塞主线程如线程调用的示例使用将密集型任务放到线程池模拟耗时计算如复杂数学运算这里会回到主线程上下文线程安全更新错误方式会阻塞主线程正确方式非阻塞的参数可以接受同步函数密集型任务才需要密集型任务应直接使用异步如性能注意不要对已经异步的方法使用高级异步探讨的是如何让一些事务处理变成异步的虽然能让一些同步代码变成一个通过在一个单独的线程上运行能让一些已经异步的代码变成当然它最重要的功能使能够让一些基于回调的代码变成更好看的但如果他已经是异步的为啥还需要让他变成一个呢这是因为只是一个好用的异步模型已经异步的代码需要转换为才能更优雅的被使用使得异步代码执行的东西可以被等待如果本身就是实现的异步因为返回本身就是这种情况下使用就没什么意义但是如果是用其他方式实现的异步就意义非凡一个很经典的例子在于对于子线程中更新界面的控件效果需要通过来执行改动界面代码即对于子线程中的代码来说是异步的这样实际上外部的代码是无法等待中执行的代码结束才返回的结果的这时候就可以来实现等待异步结果的效果案例如下下面代码在子线程中执行供用户选择一边的数字的窗口你的选择可以等待用户选择后才返回用户选择的结果即使是在异步编程模型使用本身也可以使用将某些返回值封装成可异步获取的结果十分方便异步编程的死锁避免在默认情况下会尝试在原始线程上下文如线程或请求上下文中恢复后续代码的执行但在同步阻塞操作如或或等等中如果原始线程正被阻塞等待异步任务完成而异步任务又尝试返回到该线程继续执行就会导致死锁如在的线程中调用而异步方法内部未使用此时线程被阻塞但异步任务完成后需要返回到线程执行后续代码两者相互等待形成死锁即使使用了也不能在子线程中通过调度到线程执行这样也会导致死锁如果不使用当需要操作界面元素的时候又是不合理的因此也不行多线程环境下的进度通知对象继承自接口是框架的标准接口位于命名空间中专门用于异步操作中的进度报告实际上是可以用于多线程不仅仅是异步编程就是每次会做的事情这里传进来的是接口的意义在于隐藏除了之外的其他没有意义的成员执行完成后不会回到线程上也可以正常执行下面的的内部原理是在他本身的线程上下文中去执行他时传递的操作参数除此之外可以注册事件在每次被的时候同时也调用这个事件中存在函数可以被重写该函数是被调用的时候首先会执行的函数才可以调用函数对象如果需要调用函数需要转换为接口与可以参考窗口线程防堵塞参考特定于窗体控件的线程安全方法使用方式类似是同步的方法会卡住调用它的线程跟这样没什么区别是用于委托的通用调用而是一个特定于窗体控件的线程安全方法用于跨线程操作界面元素如果你不需要处理多线程的更新那么你可能不会使用到在中委托提供了方法来启动委托的异步执行这是中实现异步编程的早期方式之一在并发模型出现之前通过委托的方法您可以在另一个线程上异步执行委托指向的方法而不会阻塞当前线程简单案例定义委托委托指向的方法异步执行委托在这里可以执行其他工作等待异步操作完成并获取结果尽管委托的和方法仍然可用但在新的开发中通常建议使用基于的模式异步编程模型因为它提供了更简单更可靠的异步编程体验在这个示例中我们定义了一个名为的委托它接受两个参数并返回一个结果接着我们创建了这个委托的实例并将其与方法绑定然后我们使用来异步调用这个委托方法的参数与委托的签名相匹配外加两个额外的参数一个是委托用于指定一个回调方法另一个是一个类型的状态对象在这个示例中我们没有使用回调所以传递了当异步执行完成后可以通过调用委托的方法来获取结果方法接受一个接口作为参数这个参数是方法返回的是加入的跟线程池的功能类似用开启新任务时会从线程池中调用线程而每次实例化都会创建一个新的线程我们可以说是一种基于任务的编程模型它与的主要区别是它更加方便对线程进程调度和获取线程的执行结果类和类前者接收的是委托类型后者接收的是委托类型任务和线程的区别任务是架构在线程之上的也就是说任务最终还是要抛给线程去执行任务跟线程不是一对一的关系比如开个任务并不是说会开个线程这一点任务有点类似线程池但是任务相比线程池有很小的开销和精确的控制什么是异步任务包含了对异步任务的各种状态的一个引用类型正在运行完成结果报错等对于异步任务的抽象开启异步任务后当前线程不会被阻塞而是可以做其他事情异步任务默认会借助线程池在其他线程上运行获取结果后回到之前的状态最好使用异步编程模型异步编程模型子线程中执行可以使用主线程中的变量但要注意是否需要锁主线程中执行的回调函数子线程运行完后由主线程回调并且可以得到子线程执行完成传回来的返回值可以让在线程上执行将代码调度到线程上执行线程相关解释方法返回与当前同步上下文关联的任务调度程序在理解这个方法在中的作用之前让我们先介绍一下同步上下文和任务调度程序的概念同步上下文同步上下文是一个抽象概念用于跟踪和管理代码执行的上下文环境在应用程序中同步上下文通常与线程关联用于确保操作在线程上执行任务调度程序任务调度程序用于管理和调度任务的执行不同的任务调度程序可以决定任务在何时何地执行例如在线程池中执行在线程上执行等现在让我们来解释在中的作用在应用程序中通常需要确保操作在线程上执行以避免线程阻塞或出现线程安全问题当您在线程上启动一个任务例如使用默认情况下任务会在线程池中执行而不是在线程上执行通过使用方法您可以获取当前同步上下文关联的任务调度程序从而将任务调度到与线程关联的同步上下文中执行这样可以确保任务在线程上执行避免了操作的线程安全问题详解是在应用程序中用于访问线程调度程序的静态属性在中元素通常只能在创建它们的线程上进行更新和操作以确保的响应性和避免线程安全问题类提供了一种在线程上执行代码的机制而允许您访问当前应用程序的线程调度程序以下是关于的一些详解线程调度程序是一个用于调度和执行代码的类它负责将操作调度到与其关联的线程上执行在应用程序中每个线程都有一个关联的对象用于管理元素的更新和操作是一个静态属性用于获取当前正在运行的应用程序实例通过可以访问当前应用程序的各种属性和方法包括线程的调度程序和类提供了和等方法用于将操作调度到与其关联的线程上执行是同步执行操作会阻塞调用线程直到操作完成而是异步执行操作不会阻塞调用线程通过使用您可以在任何地方访问当前应用程序的线程调度程序从而确保在需要在线程上执行代码时能够正确地调度操作这对于在异步操作完成后更新或在后台线程中执行操作非常有用可以等待线程执行完再执行相关方法盘点创建任务执行的代码用于在线程池中启动一个新任务与调用方法并非马上调用线程切换不同会导致立即的线程切换因为它会在不同的线程上执行任务执行的代码也是用于创建并启动一个新任务具有更多的配置选项创建一个已完成的任务返回指定的结果组合任务接受多个任务并返回一个新的任务该任务在所有传入任务完成时完成可以用于并行执行多个异步操作接受多个任务并返回一个新的任务该任务在任意一个传入任务完成时完成任务状态执行的代码获取任务的状态返回任务的当前状态如等处理异常处理异常如果任务失败属性将包含导致失败的异常取消任务检查是否已请求取消使用允许你在任务中响应取消请求继续任务执行的代码继续的代码在任务完成后执行后续操作异步等待等待秒创建一个任务该任务在指定的时间后完成其他有用的方法阻塞当前线程直到任务完成等待任务完成阻塞当前线程直到所有任务完成等待所有任务完成需要更细粒度的控制使用提供了更多的灵活性和选项例如可以指定等参数来对任务进行更详细的控制在一些需要更细粒度控制任务行为的场景下可能会选择使用可以指定任务的调度器比如可以指定由线程调用是用于指定任务的创建选项的枚举类型通过指定可以对任务的创建和执行行为进行一些控制和定制以下是一些常用的选项默认选项表示不指定任何特殊的创建选项指示任务调度器在选择下一个要执行的任务时优先考虑公平性指示任务是一个长时间运行的任务可以让任务调度器做出一些优化指示新任务将作为父任务的子任务运行父任务完成时子任务也会被取消禁止将新任务作为父任务的子任务运行在大多数情况下使用都优于使用无论是在线程还是其他线程中这是因为和在行为上有本质的不同尤其是在资源管理和线程利用率方面资源利用和效率阻塞线程当调用时当前线程将停止执行毫秒在这段时间内线程不会做任何其他工作只是处于等待状态资源浪费阻塞线程会占用系统资源如线程栈和上下文信息尽管它在期间不消耗时间非阻塞等待返回一个未完成的任务而关键字会使方法异步等待该任务的完成这种等待不会阻塞线程允许操作系统将该线程的资源调度给其他任务资源释放因为线程不被阻塞所以可以释放资源以供其他任务使用提高资源利用率和系统的整体响应性在线程中的表现在线程中使用会冻结用户界面因为线程被阻塞无法处理其他事件或更新界面在线程中使用不会阻塞线程关键字会在任务完成时自动恢复执行上下文例如线程这确保了界面的响应性和流畅性上下文恢复没有上下文恢复的概念因为它完全阻塞线程当任务完成后会尝试在原始同步上下文中恢复执行例如在应用中这意味着任务会在线程上继续执行这对于保持操作的顺序性和一致性非常重要总结在绝大多数情况下是更好的选择因为它允许线程在等待期间执行其他操作提高了应用程序的整体效率和响应性特别是在应用中这种方法能够避免界面冻结提供更好的用户体验唯一可能的例外是在极少数需要精确控制线程行为的场景下但这种情况通常非常罕见且特定不会面临创建线程的开销这是它的一个重要优势要理解这一点我们需要深入了解的内部工作原理以及异步编程模型的工作原理返回一个对象这个任务会在毫秒后完成关键点在于它不创建新的线程来处理这个延迟相反通过以下机制来实现延迟基于定时器的延迟实际上是使用系统的定时器机制来管理延迟它会请求操作系统在毫秒后触发一个事件这个事件会使状态变为已完成因此不需要线程来等待这个时间只需一个定时器来完成这一操作非阻塞等待当你使用时当前方法的执行会被挂起但这不会阻塞线程相反会将控制权返回给调用者线程可以继续处理其他工作或进入空闲状态直到毫秒后系统会发出一个信号使得完成然后会恢复方法的执行与线程相关的开销不创建线程不涉及线程创建它利用系统的定时器机制来处理延迟而不需要额外的线程资源这与不同需要阻塞当前线程无法利用系统定时器的非阻塞机制轻量级操作的实现是轻量级的因为它只需注册一个定时器而不涉及线程调度或上下文切换开销这使得它非常适合用于异步编程模型中能够有效地管理延迟而不会增加不必要的开销异步编程模型的优势响应性通过使用和你可以保持应用程序的响应性特别是在需要处理操作或长时间运行的任务时例如在应用程序中允许线程处理其他用户输入事件而不是冻结界面资源利用异步编程模型能够更有效地利用系统资源与阻塞线程相比异步方法可以让线程在等待期间处理其他任务提高了系统的并发性能总结是一种非阻塞的延迟实现方式不涉及额外的线程创建开销它利用系统定时器机制和异步编程模型来管理延迟使得在等待期间线程可以自由地处理其他任务这是它在异步编程中相比更具优势的原因新版本中提供了协程机制这是一种更接近于异步编程模型的机制能够更优雅地处理异步操作协程可以暂停执行直到某个操作完成类似于中的也提供了和一种简单的异步编程方式能够启动异步任务并获得结果虽然它主要用于并行计算但也可以用于执行延迟任务这虽然不是完全类似于的但在许多情况下可以达到类似的效果有更强大的异步库如但是复杂性比较高是中用于并行循环的功能它允许在多个线程上并行执行循环迭代从而提高循环的执行效率以下是关于的详解工作原理会将循环的迭代分配给多个线程每个线程负责处理一部分迭代循环迭代的分配和同步由并行任务调度器负责管理并行执行的迭代不一定按照顺序执行因此需要注意并行执行可能会改变迭代的顺序循环体内的代码为当前迭代的索引循环的起始索引循环的结束索引不包含循环体内的代码会在多个线程上并行执行控制并行度可以通过类中的属性来控制并行度即同时执行的线程数量默认情况下会根据系统的处理器数量来确定并行度注意事项循环体内的代码应该是线程安全的避免出现竞争条件避免在循环体内进行对共享资源的写操作可以考虑使用或其他同步机制来保护共享资源适用场景处理大量数据或计算密集型任务时可以使用来提高处理效率在需要并行执行独立迭代的情况下可以使用来并行化循环通过合理使用可以充分利用多核处理器的优势加快循环的执行速度但需要注意线程安全和并行度控制等问题以确保并行执行的正确性和效率异步定时器创建一个取消令牌源启动异步定时器每毫秒秒执行一次按任意键停止定时器取消定时器等待定时器任务完成定时器已停止等待指定的时间间隔执行定时操作当前时间处理任务被取消的情况定时器任务被取消线程同步是中的一个同步原语用于线程间的同步和通信它允许一个线程在某个事件发生时等待而其他线程可以在事件发生时通知等待的线程继续执行有两个主要状态有信号和无信号当处于有信号状态时等待的线程可以继续执行当处于无信号状态时等待的线程将被阻塞直到其他线程将其设置为有信号状态下面是的一些主要成员方法和属性当处于无信号状态时调用此方法会阻塞当前线程直到被设置为有信号状态将设置为有信号状态唤醒一个等待的线程将设置为无信号状态在指定的超时时间内等待的信号使用可以实现线程间的同步和协作例如一个线程等待另一个线程完成某个任务后再继续执行是多线程编程中常用的同步机制之一可以帮助确保线程之间的顺序和协作除此之外还有如下用于解决不同情况的存在与类似但它在被设置为有信号状态后会一直保持该状态直到调用方法将其恢复为无信号状态适用于一次性事件通知的场景是一个倒计时事件可以设置一个初始计数值每次调用方法减少计数值直到计数值为时触发事件适用于需要等待多个任务完成后再继续执行的场景是一个用于创建和控制异步任务的类可以通过方法设置任务完成的结果适用于异步任务的协作和同步类类提供了基于锁的同步机制可以使用关键字或类的方法来实现线程同步适用于简单的线程同步场景类类是一个计数信号量可以控制同时访问共享资源的线程数量适用于限制并发访问的场景线程同步机制读写锁是中用于同步访问共享资源的机制它允许多个线程同时进行读取操作但只允许一个线程进行写入操作这种锁定机制提高了在读取操作远远多于写入操作的场景下的性能适用于读多写少写持续时间短的场景提高了并发读的效率写入时会阻塞所有读锁它解决了并发读的性能问题大大提高了数据并发访问的性能只有在写入时才会阻塞所有读锁在多线程环境下选择合适的锁机制非常重要是一种在多读少写场景下非常高效的选择缺点不支持递归锁不支持递归锁这意味着在同一个线程持有锁时不允许再次获取锁这可能在某些情况下导致不便特别是在需要递归锁的情况下性能相对较慢相对于一些其他锁的类型如可能在某些情况下速度较慢有性能测试表明比更快一倍但它也有自己的限制复杂性和潜在死锁使用可能引入额外的复杂性需要谨慎使用因为不正确的使用锁可能导致死锁和性能问题需要仔细考虑何时以及如何使用这种锁以确保安全性和性能可能导致写饥饿如果写操作频繁读操作也频繁那么写操作可能会一直等待因为每次有读锁的线程时写操作都无法获取写锁类定义支持单个写线程和多个读线程的锁类表示用于管理资源访问的锁定状态可实现多线程读取或进行独占式写入访问方法说明尝试进入读取模式锁定状态尝试进入可升级模式读锁定状态锁升级指的是从读锁升级为写锁尝试进入写入模式锁定状态可升级模式的读锁也使用这个函数升级减少读取模式的递归计数并在生成的计数为零时退出读取模式减少可升级模式的递归计数并在生成的计数为零时退出可升级模式减少写入模式的递归计数并在生成的计数为零时退出写入模式尝试进入读取模式锁定状态可以选择整数超时时间尝试进入读取模式锁定状态可以选择超时时间尝试进入可升级模式锁定状态可以选择超时时间尝试进入可升级模式锁定状态可以选择超时时间尝试进入写入模式锁定状态可以选择超时时间尝试进入写入模式锁定状态可以选择超时时间可以参考一个标准做法写入操作先以可升级读锁开始检查是否需要写入需要写入的条件升级到写锁执行写入操作可以加上超时机制大多数情况下都是推荐的而且两者的使用方法十分接近方法说明使用一个超时值获取读线程锁使用一个超时值获取读线程锁使用一个超时值获取写线程锁使用一个超时值获取写线程锁指示获取序列号之后是否已将写线程锁授予某个线程将线程的锁状态还原为调用前的状态释放锁不管线程获取锁的次数如何减少锁计数减少写线程锁上的锁计数将线程的锁状态还原为调用前的状态使用一个超时值将读线程锁升级为写线程锁使用一个超时值将读线程锁升级为写线程锁信号量不能与异步操作一起使用因为它会阻止同步上下文的释放应该使用异步锁代替例如使用初始化表示最初只有一个线程可以访问共享资源并且最大只允许一个线程访问共享资源进入临界区离开临界区加上超时的做法还未测试添加超时时间秒离开临界区确保只有在获取到锁的情况下才释放手动垃圾回收在的环境中托管的资源都将由的垃圾回收机制来释放而一些非托管的资源则需要程序员手动地将它们释放非托管资源是指在垃圾回收器管理下不能自动释放的资源这意味着当不再需要非托管资源时需要手动调用其方法来释放它所占用的内存常见的非托管资源有操作系统资源如文件句柄进程句柄线程句柄等对象使用互操作时所涉及的对象外部设备资源如串行端口网络套接字等非托管代码资源通过调用的非托管代码或第三方库数据库连接资源与数据库交互时所使用的连接对象图形设备接口资源与图形设备交互时所用到的资源其他需要手动分配和释放内存的资源但注意这里指的是原生的提供的那些封装库都是托管的比如说是托管的提供了主动和被动两种释放非托管资源的方式即接口的方法类型自己的方法任何带有非托管资源的类型都有必要实现的方法并且在使用完这些类型后需要手动地调用对象的方法来释放对象中的非托管资源如果类型正确地实现了方法那么即使不调用方法非托管资源也最终会被释放但那时资源已经被很长时间无谓地占据了语句用于管理非托管资源如文件句柄数据库连接等的释放语句的作用就是提供了一个高效的调用对象方法的方式对于任何接口的类型都可以使用语句而对于那些没有实现接口的类型使用语句会导致一个编译错误中间处理逻辑语句一开始定义了一个的对象之后在整个语句块中都可以使用在语句块结束的时候的方法将会被自动调用语句不仅免除了程序员输入调用的代码它还提供了机制保证方法被调用无论语句块顺利执行结束还是抛出了一个异常下面的代码演示了的这一保护机制使用抛出一个异常来测试抛出一个异常继承自接口仅仅用来做测试不使用任何非托管资源方法被调用在此处做回收工作做了很多工作输出做了很多工作方法被调用事实上编译器为语句自动添加了块所以方法能够保证被调用到所以如下两段代码经过编译后内容将完全一致与下面完全一致应该注意一点使用时常犯的错误那就是千万不要试图在语句块外初始化对象中的代码块代码这样就形成了可以折叠的代码块开发环境相关官方组件类设计器参考可以图形化查看类结构重构技巧盘点快捷键展开所有代码块折叠所有代码块上下文菜单妙用可以打开上下文菜单数值进制转换中可以直接进行数值进制的转换打开上下文菜单转换数字引入常量引入局部变量引入参数可以将某个变量提取到常量局部变量参数提取接口基类可以针对一个类打开上下文菜单可以选择提取接口提取基类移动到命名空间等等在一个现有类上生成接口并移动到想让他去的地方选择性黏贴编辑选择性黏贴将粘贴为类将粘贴为类显示结构右键注释显示结构快捷键为可以显示当前的代码结构的所有外部结构的层次结构在中直接查看大纲可以使用快速在成员中跳转新建解决方案资源管理器视图可以在创建一个局部的解决方案资源管理器插件相关下载插件位置菜单中拓展管理拓展简易插件括号颜色配对输出栏多颜色显示代码导航实测占用有点高插件下载地址按下空格代码模板展开按下空格转换为如下键可以在跳到选中目标的下一个引用拼写检查调试可视化可直接在复合表达式上看到他的值一键选择嵌入功能允许选中部分代码通过按如下键一键用下面框架包裹住选中代码默认未启用尖括号块块块大写键空格添加修饰符默认未启用补全聊天插件插件网页优势可用有免费版保存的时候格式化插件版本使用插件一键展开排列代码会将函数参数过长的每个参数排一行初始化过长的排成多行等等在中展开排列使用动词翻译为包装每个参数实际上是把参数排成一行一个展示这个插件只是帮我们省了点击自带的包装每个参数等功能的时间默认快捷键安装好插件后进入后会有提示安装工具才能真正使用代码格式化翻译插件下的包管理器通过可以很方便的安装第三方库在中使用包的步骤如下安装包管理器在中选择工具扩展与更新然后搜索并安装打开包管理器在解决方案管理器中右键点击项目然后选择管理程序包搜索并安装包在包管理器中选择作为包源在浏览选项卡中搜索你需要的包例如在列表中选择它然后选择安装使用包安装包后可以在代码中通过语句引用它其中是你正在使用的包的名称创建引用后就可以通过调用包在命令行中使用的步骤如下下载并安装你可以从下载将文件保存到合适的目录并确保该目录位于环境变量中打开命令行窗口你可以通过在上按并输入或在上打开终端来打开命令行窗口运行命令在命令行窗口中你可以运行并后跟你想要执行的命令和相应的选项例如你可以运行来查看命令的帮助信息以下是一些常用的命令安装指定的包还原项目的依赖项将包发布到包源从包源中删除或取消列出包显示来自给定源的包下的商店下载方式要在或上安裝包管理器請使用以下步驟打開應用程序安裝程序頁面單擊獲取按鈕單擊打開按鈕單擊更新按鈕下载方式在下载地址点击后缀文件下载安装后即可相关设置生成注释工具选项高级为生成文档注释打上勾函数参数数据类型显示函数的每一个内联参数的数据类型都在写代码的时候显示了出来这样我们在编写代码的时候就可以很方便的进行参数的填写也能避免一些参数位置填错的惨案添加方法的引用计数内置的是一个帮助开发人员在代码编辑器中获取代码引用单元测试源代码管理等信息的工具工具选项文本编辑器所有语言启用显示和参考显示测试状态和这一选项启用后会在代码编辑器中显示代码的测试状态信息包括哪些测试覆盖了当前代码测试是否通过等显示和参考这一选项启用后会在代码编辑器中显示和代码的引用信息例如该方法或类被哪些代码引用了显示引用这一选项启用后会在代码编辑器中显示和代码的引用信息帮助开发者了解代码在项目中的引用情况显示测试者和这一选项启用后会在代码编辑器中显示和代码的测试者信息即哪些测试用例涉及了当前代码显示引用这一选项启用后会在代码编辑器中显示代码中的引用信息帮助开发者了解当前文件被哪些其他文件引用了显示编译时间这一选项启用后会在代码编辑器中显示代码的编译时间信息帮助开发者优化代码编译效率显示请求这一选项启用后会在代码编辑器中显示收集的请求信息帮助开发者了解代码在实际运行中的请求情况和性能指标显示异常这一选项启用后会在代码编辑器中显示收集的异常信息帮助开发者快速定位和解决代码中的异常问题重要的快捷键获取建议项目结构项目结构应用配置源码文件窗口双击打开界面设计器右键可以选择查看源码还是设计器源码文件界面设计在定义类的时候含有一个关键字这里就不得不说语言设计一个重要的特性了能作为大多数人开发上位机的首选有一个特性就是设计的时候界面与后台分离但是类名相同资源文件入口所在的源码文件引用项目依赖的一些系统库通常包含一些项目的配置和属性信息用于管理项目的设置和行为应用程序发布时的一些属性设置版本号属性版权之类的其余两个文件是工具自动生成的一些设置文件语法主要版本迭代最初的版本包含了基本的面向对象编程特性如类接口继承多态等引入了泛型迭代器匿名方法等新特性提高了代码的灵活性和可读性引入了特性使查询数据变得更加简洁和直观统一查询语法引入了动态类型命名参数可选参数等新特性增强了语言的灵活性引入了异步编程模型使异步操作更加简单和直观引入了自动属性初始化表达式体成员字符串插值等新特性提高了开发效率引入了元组模式匹配局部函数等新特性增强了语言的表达能力和功能性引入了引用类型异步序列等新特性提高了代码的安全性和可靠性与的相互调用关系创建封装器来实现允许您在代码中调用原生函数而是一种混合语言可以让您在同一个项目中同时使用和代码其实差别就两种非托管方式适用于已有且不打算修改其源码仅需调用其兼容接口的情况简单快捷无需额外工具链支持但需要处理数据类型转换和内存管理问题托管方式适用于愿意调整代码以支持框架追求更紧密集成和更易用性的场景可以直接使用封装好的托管类但可能增加项目复杂度需要维护中间层非托管方式调用这种情况是不需要修改的的调用开发的如果是编写的如该函数这里是函数的实现处理传入的整型数组可以直接使用下面的方式对接注意只有编写的才可以在项目中被引用要使用必须使用再给一个更简单的案例假如动态库里面有下面两数相加的方法我们在里面想调用库方法如下先声明方法之后就可以像普通方法一样调用如下计算结果为在通过平台调用调用时数据类型转换和内存管理是需要特别关注的两个方面数据类型转换基本类型转换数值类型与的基本整数和浮点数类型通常有一一对应关系如等在定义函数签名时使用对应的类型即可字符与字符串的通常对应的或取决于是否区分字节和字符的宽字符通常对应的在及更高版本中默认使用编码因此宽字符可能需要转换为字符串的字符串类通常需要转换为风格的字符串以结尾的字符数组才能通过传递在端使用指定为对于字符串或对于字符串返回字符串时通常函数会返回指向缓冲区的指针需要负责释放该内存见内存管理部分结构体与枚举结构体如果中定义了结构体供使用需要在中创建对应的结构体类并使用或等特性确保布局与端一致对于嵌套结构体和数组成员同样需要正确处理枚举的枚举类型可以映射为的枚举类型注意保持枚举值的对应关系并指定适当的底层类型如等特殊类型指针与句柄的原始指针通常映射为的类型对于需要传递或返回的句柄如中的也通常使用数组数组可以通过固定大小的数组结合长度参数或者使用等方法进行传递标准库中的容器如通常包含复杂的内部结构如动态分配的内存迭代器容量信息等这些都不适合直接通过传递给然而有几种方法可以间接地在与之间交换所存储的数据传递容器通过从向传递容器数据时通常不会直接传递容器本身而是传递容器内容如通过数组连续内存块或自定义数据结构在端将接收到的数据转换为相应的集合类如后使用通过数组传递容器内容动态长度数组拿来举例指针长度进入数组长度通过连续内存块传递内容端将动态长度数组序列化为字节数组并提供一个函数返回该数组的指针和长度端接收字节数组和长度然后在中反序列化示例动态长度数组序列化到中记录所需的使用自定义数据结构定义一个包含动态长度数组数据的自定义结构体包括数据缓冲区和长度信息端提供函数填充该结构体端声明对应的结构体并解析结构体中的数据内存管理手动管理堆内存分配当函数返回指向堆上分配的内存的指针时需要负责释放该内存通常通过或函数释放务必确保释放时机正确避免内存泄漏字符串缓冲区如前所述返回的字符串缓冲区通常需要释放可以使用等方法将指针转换为托管字符串同时释放原始内存自动管理使用或参数对于简单的数据类型或结构体可以使用或参数让自动管理内存这样函数可以直接修改传入的变量而无需返回新分配的内存内联缓冲区对于小尺寸的字符串或数据可以考虑在结构体中预留内联缓冲区并使用指定为这样函数可以直接写入缓冲区避免额外分配内存接口与智能指针接口如果提供了接口可以直接通过属性等创建对象代理内存管理由机制自动处理智能指针如果使用或更高版本的智能指针如则需要设计合适的接口让能够安全地使用这些智能指针所管理的对象可能涉及原始指针与智能指针的互操作最佳实践遵循约定确保导出函数遵循特定的调用约定如或并在的属性中指定正确的错误处理定义并文档化函数返回错误代码的方式端应检查并妥善处理这些错误性能优化对于频繁调用或大数据量传输的情况考虑使用代码语句预分配的缓冲区等手段提高效率但需谨慎处理以避免内存安全问题原理平台调用依赖于元数据在运行时查找导出的函数并封送其参数下图显示了这一过程对非托管函数的平台调用调用使用自动化工具生成代码有一些工具可以帮助自动生成函数声明和相关的类型定义减少手动编写的工作量例如跨语言开发工具可以生成以及其他多种语言绑定代码封装库需要编写接口文件描述接口然后通过生成绑定代码基于的工具可以从头文件生成绑定代码支持自动处理数据类型转换和内存管理使用这些工具您只需提供头文件或接口描述工具会自动生成对应的代码然后在项目中引用生成的代码文件即可调用函数总的说和都是用于简化调用代码过程的工具它们通过自动化的方式生成封装代码大大减轻了手动编写绑定的工作量具有更广泛的语言支持和丰富的定制化选项而则依托于编译器提供了精准的类型映射和对现代特性的良好支持各自最大优势广泛语言支持对于使用现代特性的库尤其是模板及以后标准特性丰富的库可能由于其精准的类型映射和对最新标准的良好支持成为更合适的选择是一个广泛使用的跨语言接口生成器它能够自动将代码包装成其他多种高级编程语言包括可以调用的形式通过解析头文件或者用户提供的接口文件生成对应的封装代码使得原生函数类和数据结构可以被非语言如透明地调用主要特点与功能广泛的语言支持除了支持外还支持许多其他语言如等使得同一套代码可以轻松地为多个平台和编程环境提供接口自动类型映射能够识别的基本类型结构体枚举类等并自动映射到目标语言的等价类型对于复杂类型还可以生成必要的适配器代码以保证类型兼容性智能指针支持可以处理中的智能指针如在生成的接口中提供适当的生命周期管理成员函数封装对于类的成员函数会生成对应的代理方法使代码可以直接调用这些方法如同在中操作本地对象模板支持能够处理部分模板并生成特定实例化的代码对于模板类或函数可能需要在接口文件中显式实例化扩展性与定制化提供了丰富的预处理器指令和宏系统允许用户自定义类型映射规则控制代码生成细节添加额外的包装逻辑等使用流程编写接口文件文件定义需要导出的接口包括头文件包含模块定义类型映射规则等可以使用指令包含头文件运行使用命令行工具指定接口文件和目标语言如生成对应的接口代码编译生成的代码生成的代码通常包括两个部分接口库文件和包装代码文件需要分别编译这两个部分接口库编译成或包装代码与原生库一起编译链接在项目中引用将生成的接口库添加为项目的引用即可在代码中直接调用原生函数和类是基于编译器前端的一个工具用于从头文件生成绑定代码它利用的完整语法解析能力提供精确的类型映射和函数签名生成主要特点与功能基于得益于强大的解析能力能够准确处理复杂的特性包括模板宏内联函数及以上标准的新特性等精准类型映射根据类型生成对应的类型包括指针引用数组结构体枚举模板实例等并处理特有的类型修饰符等函数签名生成生成符合规范的函数声明包括名称修饰参数传递规则返回值处理等确保代码能够正确调用函数支持标准库容器对于标准库容器如等可以生成适配器代码使得能够以接近原生的方式使用这些容器代码注释保留在生成代码时尽可能保留源码中的注释有助于开发者理解封装的接口使用流程安装通常通过包管理器将工具包添加到项目中配置项目在项目中指定要解析的头文件路径以及生成的代码输出路径运行生成调用提供的或命令行工具指定头文件和输出选项生成绑定代码集成到项目将生成的代码通常是文件添加到项目中同时确保项目引用了必要的代码现在可以直接调用函数托管方式调用如果愿意修改以支持框架可以创建一个混合模式的它既包含原生代码又包含托管代码可以直接被项目引用这种方法适用于需要深度集成功能或者希望代码能更方便地使用类库的情况创建项目使用创建一个类库项目封装原生代码在项目中编写托管类使用命名空间和关键字如并在其内部封装对原生代码的调用例如文件中实现托管类的方法调用原生代码假设这里实际调用了原生代码同样这里实际应调用原生代码编译并生成编译项目生成文件由于这个现在包含托管代码它可以被项目直接引用在项目中引用在项目中添加对的引用如同引用其他托管一样然后直接实例化并使用其中的托管类串口通信测试小工具教程事件源描述人机交互中事件的来源通常是一些控件事件事件源产生的交互内容比如按下按钮事件处理这部分也在中被叫做回调函数当事件发生时用来处理事件这部分在单片机中也是如此中断源产生中断然后进入中断服务函数进行响应和非常像容器控件是容器控件是一些小控件的容器池用来给控件进行大致分组要注意容器是一个虚拟的只会在设计的时候出现不会显示在设计完成的界面上这里我们将整个界面分为个容器池如图文本标签控件用于显示一些文本但是不可被编辑改变其显示内容有两种方法一是直接在属性面板修改的值二是通过代码修改其属性见如下代码另外可以修改属性修改其显示字体及大小这里我们选择微软雅黑号字体串口设置的属性值下拉组合框控件用来显示下拉列表通常有两种模式两种模式通过设置属性选择模式既可以选择下拉项也可以选择直接编辑模式只能从下拉列表中选择单个添加添加波特率列表批量添加波特率列表设置默认值按钮控件略文本框控件控件与控件不同的是文本框控件的内容可以由用户修改这也满足我们的发送文本框需求需要多行显示设置其属性为的方法中最多的是方法它的作用是将新的文本数据从末尾处追加至中那么当一直追加文本后就会带来本身长度不够而无法显示全部文本的问题此时我们需要使能的纵向滚动条来跟踪显示最新文本所以我们将的属性的值设置为即可中的窗体事件驱动是中用于创建事件处理程序委托实例的语法在中事件处理程序委托是一种特殊的委托类型用于表示事件处理程序的方法签名是中预定义的委托类型用于处理不包含数据的事件当您使用语法时您正在实例化一个委托并指定事件处理程序的方法作为参数在这种情况下您需要指定事件处理程序方法的签名即接受两个参数一个类型的参数和一个类型的参数下面是一个示例演示如何使用语法创建事件处理程序委托实例定义事件处理程序方法事件处理程序逻辑创建事件处理程序委托实例在上面的示例中我们首先定义了一个名为的事件处理程序方法然后使用语法创建了一个委托实例将方法作为参数传递给该委托实例这样就创建了一个用于处理不包含数据的事件的事件处理程序委托实例窗口线程防堵塞在窗体程序中组件比如文本框按钮等是不安全的线程资源这意味着只能在创建组件的线程通常是主线程或线程上对这些组件进行操作当从非线程如串口接收事件处理线程尝试访问组件时就必须使用某种同步方法来确保操作的安全性是委托类型的实例方法用于调用委托所引用的方法委托是一种类型它允许我们将方法作为参数传递并存储在字段或属性中当委托实例被调用时它会调用与之关联的方法可以使用运算符将一个方法添加到委托中使用运算符将其从委托中删除在具体使用上委托被定义为一个类实例其具有与特定方法签名匹配的方法每个委托实例都与一个特定方法绑定并且可以通过委托实例调用该方法使用修饰的委托就变成了事件在类外部是不能把该委托当做方法直接调用的这就是用不用的区别方法是一个同步方法它可以将一个操作的执行权转交给线程这样做可以避免因为多线程访问同一个组件而引起的竞争条件或冲突方法接受一个委托作为参数该委托指向将要在线程上执行的方法方式这种方式专门被用于解决从不是创建控件的线程访问控件首先说下和的使用有两种情况参数方法在拥有此控件的基础窗口句柄的线程上同步执行指定的委托参数方法在创建控件的基础句柄所在线程上异步执行指定委托的含义是在拥有此控件的基础窗口句柄的现呈上同步执行指定的委托同步的含义是在创建控件的基础句柄所在线程上异步执行的委托异步调用时会阻止当前主线程的运行等到方法返回才继续执行后面的代码表现出同步的概念调用时当前线程会启用线程池中的某个线程来执行此方法不会阻止当前主线程的运行而是等当前主线程做完事情之后再执行中的代码内容表现出异步的概念在想获取执行完毕后的结果时调用方法来获取而这两个方法中执行的是一个委托使用场景当您需要立即更新并且不介意等待时使用当您不需要立即知道操作结果并且不希望阻塞当前线程时使用返回值和异常可以返回值并且如果委托中引发异常它将被传递回调用线程不能直接返回值如果委托中引发异常它将不会传递回调用线程的一般用于解决跨线程访问的问题比如你想操作一个按钮你就要用你想操作一个文本你就要用但是大家会发现很麻烦如果我既然想操作又操作能不能写在一起呢有没有更简单的方法呢其实主窗体使一个自然也是继承了的所以也有的方法如果你想省点事就可以直接调用这就是常见的为什么有的前面啥都没有其实前面是只不过省略了对于的更标准的用法是先加判断再调用是的一个属性获取一个值该值指示调用方在对控件进行方法调用时是否必须调用方法因为调用方位于创建控件所在的线程以外的线程中如果控件的是在与调用线程不同的线程上创建的说明您必须通过方法对控件进行调用则为否则为方法接受两个参数一个委托和一个对象数组委托定义了要在线程上执行的操作对象数组则提供了传递给委托的参数与之对比的在和中防止线程卡住的方法分别如下或信号和槽机制隐式控件运行于后台的用户看不见更不能直接控制所以也成为组件接下来我们添加最主要的串口组件串口组件这种隐式控件添加后位于设计器下面串口常用的属性有两个一个是端口号一个是波特率当然还有数据位停止位奇偶校验位等串口打开与关闭都有接口可以直接调用串口同时还有一个属性为表示串口已经打开为则表示串口已经关闭类是相当容易上手的在进行串口通讯时一般的流程是设置通讯端口号及波特率数据位停止位和校验位再打开端口连接发送数据接收数据最后关闭端口连接这样几个步骤添加了串口组件后我们就可以通过它来获取电脑当前端口并添加到可选列表中获取电脑当前可用串口并添加到选项列表中编辑串口通信逻辑开关串口首先我们先来控制打开关闭串口大致思路是当按下打开串口按钮后将设置值传送到串口控件的属性中然后打开串口按钮显示关闭串口再次按下时串口关闭显示打开按钮在这个过程中要注意一点当我们点击打开按钮时会发生一些我们编程时无法处理的事件比如硬件串口没有连接串口打开的过程中硬件突然断开这些被称之为异常针对这些异常也有处理机制在中放置可能产生异常的代码比如打开串口在中捕捉异常进行处理打开串口按钮将可能产生异常的代码放置在块中根据当前串口属性来判断是否打开串口已经处于打开状态关闭串口打开串口清空接收区清空发送区串口已经处于关闭状态则设置好串口属性后打开打开串口关闭串口捕获可能发生的异常并进行处理捕获到异常创建一个新的对象之前的不可以再用刷新口选项响铃并显示异常给用户打开串口发送和接收串口串口发送串口发送有两种方法一种是字符串发送一种是可以发送一个字符串或者进制发送见下篇其中字符串发送默认已经在末尾添加换行符首先判断串口是否开启串口处于开启状态将发送区文本发送捕获到异常创建一个新的对象之前的不可以再用刷新口选项响铃并显示异常给用户打开串口串口接受在类中有事件当串口的读缓存有数据到达时则触发事件其中属性决定了当串口读缓存中数据多少个时才触发事件默认为另外事件运行比较特殊其运行在辅线程不能与主线程中的显示数据控件直接进行数据传输必须用间接的方式实现使用串口接收之前要先为串口注册一个事件相当于单片机中的串口接收中断然后在中断内部对缓冲区的数据进行读取串口接收事件处理串口接收也有两种方法一种是进制方式读下篇介绍一种是字符串方式读在刚刚生成的代码中编写如下串口接收事件处理因为要访问资源所以需要使用方式同步响铃并显示异常给用户上面是整体读下面是按字节租步读串口接收事件处理获取接收缓冲区中的字节数声明一个大小为的字节数据用于存放读出的型数据接收字节计数变量增加读取接收缓冲区中个字节到数组中接第二步中的代码防止出错首先清空字符串构造器遍历数组进行字符串转化及拼接因为要访问资源所以需要使用方式同步代码省略绘图对象在中非常灵活可以在多种不同的上下文中进行绘制除了在打印文档中使用外它还可以在以下地方进行绘制控件和窗体的自定义绘制通过覆盖控件或窗体的方法可以在控件或窗体的表面上直接进行绘制这允许开发者创建自定义的控件外观或动画效果图像对象可以使用对象在对象上进行绘制从而创建或修改图像这常用于图像处理和修改例如添加文字图形或进行颜色调整内存中的绘图可以从一个创建并用于在内存中的图像上绘制而不需要直接绘制到屏幕上打印图形除了还可以用于绘制打印预览和打印输出自定义的窗口装饰通过自定义窗口的非客户区如窗口边框和标题栏可以在窗口的这些区域进行绘制图形用户界面组件在自定义组件开发中对象可以用于绘制各种视觉元素游戏开发在简单的游戏开发中可以用于绘制游戏中的图形和动画数据可视化用于绘制图表图形和其他数据可视化元素在窗口上直接进行绘制的示例代码假设是窗体或控件的实例创建与当前窗体或控件关联的对象使用对象绘制内容清除背景绘制文本释放对象在上面的示例中方法用于创建与当前控件或窗体关联的对象然后使用该对象在控件或窗体上绘制文本绘制完成后需要调用方法来释放对象所占用的资源需要注意的是在进行自定义绘制时应该在方法中正确管理对象的生命周期以避免资源泄漏和其他问题此外绘制操作可能会影响应用程序的性能特别是在复杂的绘制任务或高频绘制操作中获取对象演示如何获取一个控件的对象并使用它来绘制控件的内容假设是您想要打印的控件创建一个与控件大小相同的对象使用方法从控件获取对象使用对象绘制控件内容这里我们简单地将控件的图像绘制到上其他绘制操作释放对象现在包含了控件的图像您可以使用进行进一步的操作比如打印或保存到文件如何在现有控件上进行绘图如果您需要在已经存在的控件上进行绘图您通常会处理该控件的事件当控件需要重绘时例如当控件被覆盖或其方法被调用时事件会被触发在事件的处理程序中您可以使用传入的参数中的对象来绘制您的自定义图形以下是如何为控件添加自定义绘图的步骤订阅事件为您想要绘制的控件订阅事件创建事件处理器编写一个事件处理器来响应事件使用对象绘制在事件处理器中使用的对象绘制您的图形触发重绘如果需要可以调用控件的方法来触发重绘以下是示例代码假设是您想要在其上绘制的控件订阅事件在这里使用对象绘制您的自定义图形绘制示例在控件上绘制一个红色的矩形清除背景绘制填充矩形如果需要绘制文本使用完对象后不需要调用因为它是由系统管理的如果需要手动触发重绘这将导致事件被触发在上面的代码中方法是事件的处理器当控件需要重绘时会调用此方法并传入对象其中包含对象和绘制区域的等信息请注意您不应该手动释放对象因为它是由系统管理的资源只需确保不要在方法调用之后使用它即可使用此方法您可以在控件上绘制文本形状图像等实现完全自定义的控件外观窗体相关的事件在中应用程序中的窗体可以触发多种事件这些事件按照不同的阶段和操作进行排序以下是一些常见的窗体事件按时间顺序排列构造和初始化事件在窗体构造后窗体的控件被创建和布局完成后触发显示和隐藏事件在窗体首次显示后触发在调用方法隐藏窗体时触发激活和取消激活事件在窗体被激活时触发在窗体失去焦点时触发大小和布局事件在调整窗体大小时触发在控件布局发生更改时触发移动事件在窗体位置发生移动时触发输入和焦点事件在控件获得焦点时触发在控件失去焦点时触发和与和类似但更常用于控件点击和双击事件当鼠标进入窗体时触发当鼠标离开窗体时触发当鼠标在窗体内部按下时触发当释放鼠标按钮时触发当用户点击窗体时触发和之间当用户在窗体上双击时触发键盘事件当键盘上的键被按下时触发当键盘上的键被释放时触发当键盘上的键被按下并释放时触发关闭事件在窗体关闭前触发可以取消关闭操作在窗体关闭后触发绘图事件在需要重绘窗体或控件的任何部分时触发在绘制窗体背景时触发拖放事件在开始拖动操作时触发在拖动操作过程中触发在完成拖动操作时触发当拖动操作离开窗体时触发帮助事件当用户请求帮助时触发这些事件为开发者提供了丰富的交互性允许对用户的操作做出响应并执行相应的逻辑处理开发者可以根据需要在窗体或控件的事件处理器中编写代码以实现特定的功能开发创建在中创建项目选择类库封装成时程序集名字要跟程序里的命名一致如下图否则应用时无法引用成功中调用该把放在项目文件夹的目录的目录下点击项目里的引用添加添加完后可以在引用里看到使用包含进去并调用中的函数新建类调用的函数查看调用结果封装的是非标准的托管类不可以用调用是用来调用标准类非托管类的这类一般是用写的中自定义窗口项目上右键添加添加新建项窗体窗体弹消息框非模态弹自定义窗口模态弹自定义窗口窗口程序包管理器开发过程中几乎不可避免地要使用第三方包当然可以不用包管理器对于开源的项目可以直接引用源文件预先构建好了的库也可以直接引用但是用之类的包管理器可以更方便地进行管理比如最基本的安装更新卸载功能可以直接通过命令行或者来操作常用的包管理工具是平台上的包管理器可以帮助开发者轻松地安装更新和卸载第三方库和工具可以提高项目的开发效率和质量因为它可以让开发者复用已有的优秀的代码而不需要自己从头编写或者手动管理依赖关系使用方式图形界面推荐命令行程序包管理器控制台安装前要先查看当前包是否支持自己的项目框架如下查看安装命令复制到命令行执行大致语法下面命令可以直接在终端中运行安装指定版本卸载更新到最新版图形界面合并程序集我们有多种工具可以将程序集合并成为一个比如前者不可定制运行缓慢消耗资源不过好消息是现在开源了后者已被弃用不受支持且基于旧版本的用来替代它们的使用来合并程序集是一款开源的类库重打包工具它能够将多个文件合并成一个单一的或文件这在处理依赖性复杂的问题时非常有用并且可以提高应用程序的部署效率以帮助开发者解决以下问题将多个类库合并为一个文件减少部署所需的文件数量合并类库中的类型冲突可以自动解决这些冲突并确保程序正常运行支持和支持和操作系统此外还具有以下特点易于使用只需要在命令行中输入简单的指令即可完成操作高效使用指令进行操作因此速度非常快灵活支持自定义输出目录和输出文件名使用来合并程序集使用方式项目根目录下出现的下会出现使用类似这样的命令将和以及以为主合并为一个比如说如果还依赖将一起拉进来合成单元测试为什么要使用单元测试大大节约了测试和修改的时间有效且便于测试各种情况能快速定位每一个测试用例都是具有针对性能使开发人员重新审视需求和功能的设计难以单元测试的代码就需要重新设计强迫开发者以调用者而不是实现者的角度来设计代码利于代码之间的解耦自动化的单元测试能保证回归测试的有效执行使代码可以放心修改和重构测试用例可作为开发文档使用测试即文档测试用例永久保存支持随时测试对于我个人来说主要是防止自己犯低级错误的同时也方便修改修复而不引入新的问题可以放心大胆的重构简言之这个简单有效的技术就是为了令代码变得更加完美常用单元测试框架官方和为微软产品集成在工具中为开源测试框架采用开发广泛用于平台的单元测试和回归测试中官方网址为的改进版技术在进行单元测试时如果函数依赖于许多资源而不仅仅是参数可以考虑使用技术是一种在单元测试中模拟依赖项的技术以确保测试的独立性和可靠性通过使用框架或手动创建模拟对象您可以模拟函数所依赖的资源从而使测试更加可控和可靠这样您就可以专注于测试函数的逻辑而不必担心外部资源的影响希望这可以帮助您进行函数的单元测试本身并不提供内置的框架但您可以使用第三方的框架来进行单元测试一些流行的框架如和可以与集成并且可以很容易地在中使用这些框架来进行单元测试自动生成单元测试参考链接仅公共类或公共方法中支持创建单元测试在需要测试的函数内右键创建单元测试会打开一个窗口供你配置直接按默认的设置项就可以配置好后会新建一个测试类和一个测试函数在测试函数中编写断言测试框架可以选择和和区别和是提供的两代测试框架用于在中编写和运行单元测试是的继任者改进了许多功能并且增加了更多的灵活性和现代化特性以下是两者之间的一些主要区别包和命名空间包名命名空间包名和命名空间跨平台支持主要针对平台支持跨平台可以在和上运行与的兼容性不支持只能用于项目支持和可以在新的平台上使用包管理一般情况下它是通过自带的组件安装的不使用包管理通过包进行安装和管理非常方便特性和都使用类似的特性来标记测试方法和类例如不过增加了一些新的特性如用于数据驱动测试改进的用于提供测试信息和数据但是功能相对有限改进了增加了更多的功能和更好的灵活性配置和运行设置使用和文件进行配置更加强调使用文件同时支持更多的配置选项集成和扩展集成和扩展的能力相对有限提供了更好的扩展机制和更强的集成能力可以更容易地与其他测试工具和框架如集成总结是的现代化替代品提供了更多的功能更好的跨平台支持和更强的灵活性如果你开始一个新的项目或者需要在或上进行单元测试推荐使用而对于已经使用的现有项目可以考虑逐步迁移到以利用其改进和新特性一个例子如下包含输出打印数据驱动的的列子用于打印数据显示示例数据集添加更多数据集中有很多断言方法曲线曲线曲线曲线相似度为异常相关如果方法在测试过程中抛出异常而没有使用特性或方法来捕获异常测试将失败如果方法在测试过程中没有抛出异常即使不写任何断言测试也会通过操作此处记录一个很实用的工具在编辑选择性粘贴将粘贴为类可以将字符串数据转换为类结构参考链接操作与处理处理有很大的不同创建一个新的文档对象创建声明插入声明创建根元素根元素是必须要有的插入根元素在根元素下创建子元素并设置属性设置标签名为设置标签中的值为保存到文件文件创建成功读取示例创建一个对象并加载文件使用方法选择匹配的第一个节点获取节点的文本内容生成的文件内容如下也有函数用于读取是一个非常重要的类用于将对象序列化为格式或者将反序列化为对象的命名空间提供了多种操作类包括是这个库的一部分主要用于对象与之间的序列化和反序列化操作张三序列化反序列化张三注意如果是属性的话要使用反射一句话说清楚反射就是一种使用字符串当成代码用的方法反射是框架设计的基础反射在系统中另一个重要应用就是与特性的结合使用编程语言中最常使用的是类和类中的函数和属性正向调用的方法是创建类然后用类创建一个对象接下来就可以用这个对象调用类中的方法和属性了而反射就是相对于这种正向调用的存在即它是反向调用反射可以通过类名的字符串来创建类可以通过函数名的字符串和属性名的字符串来调用类下的函数和属性为什么需要反射在不知道一个类型是什么的情况下可以动态的去操作一个类型典型的表现就是依赖注入容器依赖注入容器是怎么做到我们要什么类型他就给什么类型的类反射两种通过类名称的字符串反射出类的对象的用法如下是一个完全限定名什么是完全限定名完全限定名就是命名空间类名在反射的时候需要我们传递完全限定名来确定到底要去哪个命名空间找哪个类如果是反射时只写了一个类名那么速度就会变慢因为它要遍历所有的命名空间去找这个类先进行了加载组件然后再由组件获取类型即可以解析中的类只能解析当前命名空间下的类如果该类存在于引用的中就解析不了函数反射普通函数函数的反射应用主要是使用类类反射获取了命名空间下这个类的类型通过这个类型来获取指定名称的方法实例化对象定义了一个参数的数组执行方法构造函数获取第一个构造函数无参的方式调用第一个构造函数上面代码要求没有别的构造函数但是如果想指定性的获取无参构造函数可以使用来筛选出无参构造函数如通过构造函数的参数列表来判断调用无参构造函数处理没有无参构造函数的情况属性反射属性反射是用类来实现反射与特性结合演示了如何在运行时根据属性的元数据动态修改对象的属性值如通过反射将拥有特性的且描述为的属性清空了包含演示反射和自定义属性处理的主类用于演示使用反射执行方法的示例创建类的实例并设置其属性带有自定义属性的属性带有自定义属性的属性没有任何自定义属性的普通属性调用方法清除带有自定义属性的属性值打印属性值以观察更改应输出因为此属性被清除应输出因为此属性未被清除应输出因为此属性没有任何自定义属性根据自定义属性清除对象的某些属性获取类的所有公共实例属性遍历每个属性获取当前属性的所有类型的自定义属性检查该属性是否具有自定义属性将第一个自定义属性强制转换为并获取其属性值如果为将该属性值设置为清除属性值表示对象的类其属性将被操作自定义属性设置为自定义属性设置为没有任何自定义属性的普通属性自定义属性类用于为属性添加元数据该属性可以应用于所有程序元素用于存储描述信息的属性构造函数用于初始化自定义属性的描述信息在用反射将转存到实体的时候遍历属性并赋值的时候就会多遍历那么几次如果只是一个实体那么多遍历几次也没影响但如果是数十万的数据那这多几次的遍历影响就大了而用反射特性就可以减少这些额外遍历次数即只需要遍历一次根据属性来做不同的操作案例字符串反射类对象中的变量设置为值哪个类的实例要设置的变量名要设置的值获取当前实例的类型使用反射获取字段并赋值反射的变量名不存在调用堆栈打印调用堆栈信息使用案例设定的值需要类型转化反射置空案例在中没有直接的方法可以将一个对象的所有属性都置为空您需要逐个设置每个属性为或默认值这是因为中的对象初始化语法通常需要为每个属性提供明确的赋值如果您想要一种更通用的方法来将对象的所有属性置为空您可能需要编写一个通用的方法或使用反射来实现这一目的以下是一个使用反射的示例代码可以将一个对象的所有属性置为空这个示例代码使用反射来获取对象的所有属性并将它们的值设置为请注意使用反射可能会影响性能因此请根据实际情况谨慎使用动态类型生成方法适用场景动态性语法友好性性能简单动态对象无需强类型约束高较高自定义动态类型复杂动态逻辑如解析高中等组合模式保留原始对象强类型特性低高反射与动态代理高级场景需生成全新类型中低若需完全动态行为优先选择或自定义动态对象若需与现有对象协作使用组合模式或包装类避免尝试修改已编译类型的元数据语言限制元组元组是版本引入的一种数据结构用于组合多个值并将它们作为一个单元一起传递元组可以包含不同类型的值并且可以在不创建新的类或结构的情况下使用以下是一些关于元组的介绍语法使用元组的语法是在圆括号中列出要组合的值用逗号分隔例如表示包含一个整数和一个字符串的元组可以为元组的组成部分指定名称例如创建元组使用方法创建元组例如使用元组字面量语法创建元组例如访问元组元素可以使用操作符访问元组中的元素例如在具有命名组件的元组中可以使用组件名称访问元素例如返回元组可以在方法中返回元组作为结果例如解构元组可以使用解构语法将元组的值分配给多个变量例如使用场景异步方法返回多数据一个方法体要返回具体的业务数据如果里面逻辑校验不通过或者出现了异常则也要返回响应的错误信息通过或者等关键字来实现多个数据回传具体的逻辑但是从普及后异步方法不支持或参数元组就有用了写法变成了具体的逻辑临时数据只是想临时性记录一下某个对象的部分属性比如一个包裹的体积长宽高或者某个点的平面坐标或者空间坐标等如果单独为其创建类写起来其实挺费力的但是如果使用元组那就简单太多了变量值互换代码如下带文件数量限制的版本获取当前目录下所有文件按创建时间排序删除最早的文件使用方式常用的其他选项基础选项仅包含最基本的崩溃信息异常信息调用堆栈线程列表模块列表包含数据段加载的模块的数据段有助于查看全局变量包含进程的完整内存转储包括所有可读写的内存页可以查看完整的堆内存文件较大包含句柄信息进程打开的所有句柄文件句柄事件句柄互斥体等过滤内存数据仅包含有用的内存页减小文件大小扫描内存查找特定的内存模式用于内存分析包含已卸载的模块信息帮助诊断模块加载问题分析模块依赖关系包含间接引用的内存包括指针引用的内存有助于追踪内存关系过滤模块路径仅包含必要的模块路径信息减小文件大小包含进程和线程数据详细的线程状态线程本地存储包含私有读写内存进程私有的可读写内存页不包含共享内存排除可选数据最小化转储大小仅保留核心信息完整的内存信息内存管理信息内存分配状态保护属性额外的线程信息线程时间线程优先级线程亲和性包含代码段所有模块的代码段用于反汇编分析排除辅助状态不包含辅助数据结构减小文件大小完整的辅助状态包含所有辅助数据结构用于深入分析私有写时复制内存包含写时复制页面用于分析内存修改忽略不可访问的内存跳过无法读取的内存页避免转储失败包含令牌信息安全令牌权限信息包含模块头信息头信息导入导出表筛选关键信息仅包含故障排除必需信息优化文件大小状态上下文寄存器状态相关信息处理器追踪处理器执行追踪信息性能分析数据扫描不可访问的部分页面尝试读取部分可访问的页面最大化信息收集组合标志常用的完整内存转储组合包含完整内存映像内存管理信息句柄数据线程信息安全令牌信息组合盘点初步分析适用于生成较小的文件用于基本调试如快速分析崩溃原因线程状态等一般调试适合大多数问题分析如内存泄漏资源泄漏和多线程问题全面诊断全面分析复杂问题包括内存和线程异常模块加载卸载等性能调优性能调优检查内存和代码段的使用情况分析方式可以直接加载文件打开后选择文件打开文件选择文件即可查看堆栈信息异常上下文和托管对象超级详细使用方案实践参考工具也可用于分析安装方式进入交互式调试模式文件路径进入交互式调试模式可以执行类似的命令比如等其他工具还有用于列出进程的用于检查托管内存使用情况的用于收集和分析转储文件的死锁排查参考链接占用率排查参考链接拓展方法扩展方法自引入以来就一直是语言及其运行环境包括所有版本的一个重要特性它允许你向现有的类型添加新方法而无需修改这些类型的定义或创建子类这对于增强不可修改的类例如在库中的类或者避免使用继承来扩展类的功能是非常有用的使用场景不修改源码的情况下扩展功能无须更改类的基础结构或继承直接扩展功能提供与实例方法类似的调用语法在实际使用中扩展方法看起来就像是实例方法实现的基础的查询操作符如等都是通过扩展方法实现的实现扩展方法的关键点静态方法所在的静态类扩展方法必须定义在一个静态类中第一个参数使用关键字扩展方法的第一个参数必须用关键字来修饰且紧跟着要扩展的类型这样可以让编译器知道该方法是扩展方法名称空间的导入如果你要使用某个扩展方法必须在适用代码的文件中使用指令来导入包含该扩展方法的命名空间案例下面是一个简单的扩展方法示例它为类型添加了一个方法来计算字符串内的单词数量用关键字在第一个参数前来定义为的扩展方法通过扩展方法像调用实例方法一样使用工作原理当你调用时编译器实际上是在字符串对象上调用把传递给扩展方法的第一个参数注意扩展方法不可以覆盖已有的实例方法过度使用扩展方法可能导致代码可读性下降因此扩展方法应该用于增强已有类的功能而非替代更具可读性明确的设计模式语言集成查询发音是微软的一项技术新增一种自然查询的语法到的编程语言中当前可支持以及语言年月日随发布了技术其中主要包括简单的理解为在中添加了一种类似的语法可以方便开发者进行数据的查询操作数组集合参考表现形式主要有以下两种查询表达式链式编程查询表达式查询表达式查询数组中大于的奇数并降序排列遍历结果集上面的查询语句实际上并没有查询到这里遍历的时候才真正执行了查询操作交集查询按照字符长度分组排序长度为的语言有长度为的语言有长度为的语言有长度为的语言有长度为的语言有长度为的语言有注意遍历结果集的时候才真正执行查询链式编程链式编程进行查询遍历结果集上面的查询语句实际上并没有查询到这里遍历的时候才真正执行了查询操作交集查询按照字符长度分组排序长度为的语言有按照字符长度分组排序长度为的语言有长度为的语言有长度为的语言有长度为的语言有长度为的语言有长度为的语言有查询结果查询结果如等也实现了接口可以通过循环对查询结果进行遍历提供的高阶函数盘点对集合中的每个元素应用一个函数生成由结果组成的集合过滤集合中的元素只保留符合条件的元素通过累积函数将集合元素规约为单一结果检查集合中是否有任何元素满足给定条件检查集合中的所有元素是否都满足给定条件查找集合中第一个满足条件的元素如果不存在则返回类型的默认值则返回则返回断言这是在调试模式下使用的断言它会在条件为假时引发异常并且默认情况下在发布模式下会被忽略这是在生产环境中使用的断言可以在调试和发布模式下都生效需要引用命名空间在使用断言时您可以指定一个条件和一个可选的消息如果条件为假断言会引发异常并显示消息断言是一种在开发过程中帮助验证代码逻辑的有用工具但应当注意在生产环境中不要过度依赖断言网络通信网络编程网络通信网络通信参考此处计时是中用于精确计时的核心工具适用于性能调优代码段耗时分析等场景使用时需注意其非线程安全特性和环境稳定性结合多次测量以提高结果可靠性基本用法命名空间计时操作盘点如下开始计时启动计时支持多次调用以累积时间需先停止计时停止计时暂停计时可通过再次继续累积重启计时方法等同于清空历史时间后重新开始重置计时器方法清空累积时间并停止计时获取时间结果操作盘点如下返回对象表示总时间如返回总时间的毫秒数如返回计时器刻度数需结合属性转换高精度场景使用状态检查操作布尔属性判断计时器是否正在运行简化初始化使用直接创建并启动实例最高效的使用方式需要计算的执行过程此时就是计算出来的执行过程的时间转换器在中类是一个提供了各种数据类型之间转换的静态方法的类类提供了一系列用于将一种数据类型转换为另一种数据类型的方法包括基本数据类型日期时间类型字符串等以下是类的一些常用方法将其他数据类型转换为布尔类型将其他数据类型转换为位有符号整数将其他数据类型转换为双精度浮点数将其他数据类型转换为字符串将其他数据类型转换为日期时间类型类提供了一种方便的方式来进行数据类型之间的转换避免了手动编写转换逻辑的繁琐通过使用类您可以快速安全地将不同数据类型之间进行转换适用于各种数据处理和转换的场景是中用于基本数据类型与字节数组之间相互转换的工具类它提供了一系列静态方法可以将各种基本数据类型如整数浮点数布尔值等转换为字节数组或将字节数组转换为对应的基本数据类型将各种基本数据类型转换为字节数组将个字节的字节数组转换为位有符号整数将个字节的字节数组转换为单精度浮点数等用于其他基本数据类型的转换类提供了方便的方法来进行基本数据类型与字节数组之间的转换适用于处理二进制数据网络通信文件操作等场景类是中用于字符编码和解码的类位于命名空间中它提供了一系列静态方法和属性用于将文本数据转换为字节数组编码或将字节数组转换为文本数据解码支持多种字符编码方式如等以下是类的一些常用方法和属性将字符串转换为字节数组使用指定的编码方式将字节数组转换为字符串使用指定的编码方式表示常用的编码方式如编码编码编码等根据编码名称获取对应的对象类提供了丰富的功能和灵活的接口可以帮助您在应用程序中处理不同编码方式的文本数据通过使用类您可以进行字符编码和解码操作确保数据在不同系统和环境中的正确传输和处理处理此处记录一个很实用的工具在编辑选择性粘贴将粘贴为类可以将字符串数据转换为类结构中处理数据通常使用或也称为库这两个库都非常流行且功能强大以下是这两个库的详细介绍和使用示例二者差异性能在性能上通常更快尤其是在处理大量数据时这是因为它是为设计的采用了更高效的内存管理策略在某些情况下可能会稍慢但它的灵活性和功能丰富性弥补了这一点功能提供了更多的功能例如支持动态对象复杂的自定义序列化和反序列化等的功能相对较少但在及更高版本中微软正在逐步添加更多功能配置选项提供了丰富的配置选项可以通过自定义序列化和反序列化的行为的配置选项相对较少但也在不断改进兼容性可以在和中使用适用范围更广是及以上版本的内置库适用于现代应用程序是和更高版本中内置的处理库性能较高且使用简单序列化对象转将对象转换为字符串张三输出张三反序列化转对象将字符串转换为对象张三输出张三处理复杂类型对于复杂类型如嵌套对象集合等也支持公司张三李四更复杂的案例定义一个自定义转换器用于处理及其子类的序列化和反序列化反序列化方法将数据转换为具体的子类对象使用解析数据确保及时释放资源获取根元素以便访问属性从中获取必须的属性用于确定具体子类类型根据字段值选择对应的子类进行反序列化当为时反序列化为对象当为时反序列化为对象在此处可以继续添加其他设备端口类型的处理逻辑示例遇到未知类型时抛出异常防止无效数据未知的设备端口类型序列化方法将及其子类对象写入将对象转换为基类类型进行序列化以支持多态序列化这会触发系统默认的多态序列化处理保留子类特有的属性序列化中文序列化序列化时默认将字符转义了要让文件中正确显示中文我们需要修改的设置如下原本中显示中文为修改后中的中文为聚焦杯默认就支持正确显示中文是一个非常流行的第三方库功能强大支持更多的功能和灵活性通过包管理器安装序列化对象转张三输出张三反序列化转对象张三输出张三处理复杂类型与类似也支持复杂类型的序列化和反序列化公司张三李四设置用于演示的属性设置为忽略张三这是一个秘密创建实例设置缩进格式设置日期格式忽略值忽略默认值序列化反序列化设置字符串的格式为缩进格式更易于阅读用于指定日期的格式在这个例子中日期格式设置为这样序列化后的日期将以这种格式输出表示在序列化时忽略值为的属性如果属性为它将不会出现在序列化后的中表示在序列化时忽略默认值的属性如整数的默认值为布尔值的默认值为特性用于标记在序列化和反序列化过程中应被忽略的属性在这个例子中属性不会出现在序列化的中示例字符串张三阅读旅行游泳北京解析字符串为查询属性查询数组查询嵌套对象修改属性更新年龄跑步添加新的爱好输出修改后的修改后的格式化输出属性盘点也称为是生态中最常用的处理库之一它提供了一系列属性来控制序列化和反序列化的行为以下是中常用的属性用于修改序列化和反序列化时的属性名称默认值等这个选项表示如果属性的值是其默认值则在序列化时会忽略该属性作用设定对应的键名如控制默认值的处理用于忽略某个属性使其不被序列化或反序列化不会出现在序列化后的中指定某个属性的自定义转换器允许枚举值序列化为字符串而不是默认的整数用于控制类的序列化方式如模式下只有标记的属性才会被序列化该字段不会被序列化其他用于控制数组或集合的序列化行为如指定数组的元素是否为必选项用于自定义字典类型的序列化行为如允许自定义字典类型的序列化方式用于接收额外的未映射数据如将中不匹配的额外数据存入字典用于强制要求某个属性在数据中存在否则弹出异常如如果在中缺失则反序列化时会抛出异常用于指定某个构造函数供反序列化时使用如指定反序列化时调用的构造函数复杂案例结构如图新增的喜爱物品属性使用基类类型物品基类衣服类物品例如例如红色深蓝数码类物品价格是否使用电池食品类物品是否需要加热重量克序列化并保存代码张三这是一个秘密白色创建实例设置缩进格式设置日期格式忽略值忽略默认值序列化保存到当前目录最终产出的张三白色下面的复杂案例可以与中的复杂案例对比看序列化反序列化和的区别是一个较早的框架主要用于提供了一种简单的方法来与数据库交互它支持多种数据库但在性能和灵活性方面有一些限制是一个跨平台的框架旨在支持和及更高版本进行了重写提供了更好的性能更灵活的和对新功能的支持如异步编程下面主要都是介绍特性平台仅支持支持等跨平台开发轻量化体积较大依赖较多轻量化模块化设计性能更高跨平台支持仅支持支持跨平台性能相对较慢特别是批量操作性能低性能显著提高批量操作性能优化支持的数据库主要支持支持等多种数据库支持支持但有一些局限性支持更广泛包含一些新操作符离线开发支持文件的可视化设计器不支持文件基于和设计迁移支持数据迁移支持数据迁移更灵活支持自定义脚本注重模块化较为笨重依赖于模块化设计独立的包如未来支持停止新功能开发仅维护持续迭代和更新主力框架概述是轻量化可扩展开源和跨平台版数据库访问技术选择的原因微软的亲儿子对接了微软的众多其他需要数据访问的框架例如全面支持查询性能提升已非常接近原生的框架了数据库迁移功能可以动态创建数据库或修改数据库优势能够使用对象处理数据库数据迁移正式环境慎用备注不建议使用数据迁移需要学习处理数据库字段长度生成值不生成默认添加或更新时生成键索引等一定量内容并且需要对数据库很熟悉既然熟悉了数据库为什么还要在中处理呢专业的任务还是专业的工具去做官方建议部署到生产数据库的建议方法是生成脚本无需编写大部分数据访问代码三种功能已经有数据表了程序中没有对应的类程序中有类了的设计了但是没有数据库和程序中的类已经有数据模型的设计了但是没有数据库和程序中的类从版本开始由发布从版本开始开源开源地址版本发行情况主要特性基本开发模式三种模式对于使用模型执行数据访问模型由实体类和表示数据库会话的上下文对象构成上下文对象允许查询并保存数据支持以下开发模式数据库优先从现有数据库生成类和属性模型优先基本不使用代码优先最常用现有类和属性从类和属性生成数据库对应的表和字段创建模型后使用迁移从模型创建数据库模型发生变化时迁移可让数据库不断演进基本框架注意事项若要在高性能生产应用中构建调试分析和迁移数据必须具备基础数据库服务器的中级知识或更高级别的知识例如有关主键和外键约束索引标准化和语句数据类型分析等方面的知识功能和集成测试请务必尽可能严密地复制生产环境以便查找仅在使用特定版本的数据库服务器时应用才出现的问题在升级和其他依赖项时捕获中断性变更例如添加或升级或等框架这些依赖项可能以多种意外方式影响通过代表性负载进行性能和压力测试某些功能的不成熟用法缩放性不佳例如多项集合包含内容大量使用延迟加载对未编制索引的列执行条件查询对存储生成的值进行大规模更新和插入缺乏并发处理大型模型缓存策略不充分安全评审例如连接字符串和其他机密处理非部署操作的数据库权限原始的输入验证敏感数据加密确保日志记录和诊断充足目可用例如适当的日志记录配置查询标记和错误恢复为常见故障场景如版本回退回退服务器横向扩展和负载平衡缓解和数据备份准备应急计划生成的迁移的详细检查和测试将迁移应用于生产数据前应对其进行全面测试若表中包含生产数据架构的形状和列类型就不能轻易更改例如在上对于映射到字符串和十进制属性的列和极少成为最佳类型但这些是使用的默认值因为不了解你的具体情况安装安装请务必安装提供的所有包的同一版本例如如果安装版本的则所有其他包也必须为版本数据库提供程序通过使用数据库提供程序支持不同的数据库系统每个系统都有自己的数据库提供程序而提供程序以包的形式提供应用程序应安装其中一个或多个提供程序包下表列出了常贝的数据库提供程序有关可用提供程序的更全面列表请参阅官方网址数据库系统配置示例程序包或内存中数据库如执行将会自动安装的本体等一切依赖如果需要支持的数据迁移还需要安装包命令行工具不安装也可以可以通过自带的程序包管理器控制台来执行数据迁移像和等没有程序包管理器控制台就只可以通过下面工具来执行数据迁移使用用于迁移的工具需要安装相应的工具包版本与运行时的版本一致最稳妥可以使用来判断是否安装成功等同于可以使用来查看帮助文档数据库上下文的生命周期从创建实例时开始并在释放实例时结束实例旨在用于单个工作单元这意味着实例的生命周期通常很短引用的话工作单元将持续跟踪在可能影响数据库的业务事务中执行的所有操作当你完成操作后它将找出更改数据库作为工作结果时需要执行的所有操作创建实例根据上下文跟踪实体实例实体将在一下情况下被跟踪正在从查询返回正在添加或附加到上下文根据需要对所跟踪的实体已进行更改以实现业务规则调用或检测所做的更改并将这些更改写入数据库释放实例重要的部分使用后释放非常重要这可确保释放所有非托管资源并注销任何事件或其他挂钩以防止在实例保持引用时出现内存泄漏不是线程安全的不要在线程之间共享上下文请确保在继续使用上下文实例之前等待所有异步调用最简单的解决方式就是使用可以避免线程安全问题代码引发的可以使上下文进入不可恢复的状态此类异常指示程序错误并且不旨在从其中恢复数据迁移提供两种主要方法来保持模型和数据库架构同步至于我们应该选用哪个方法请确定你是希望以模型为准还是以数据库为准如果希望以模型为准请使用迁移对于模型进行更改时此方法会以增量方式将相应架构更改应用到数据库以使数据库保持与模型兼容小项目用这种如果希望以数据库架构为准请使用反向工程使用此方法可通过将数据库架构反向工程到模型来生成相应的和实体类型中大型模型建议使用迁移与的差异对比项是否需要设计包内置于本身需要迁移工具包管理器控制台包管理器控制台迁移命令操作平台仅支持支持依赖项包已集成所有功能需要安装和历史记录存储表表迁移的常见操作及数据保留情况操作类型对表数据的影响详细说明新增表创建新表不会影响现有表中的数据新增列新增的列会为所有现有行赋默认值或默认值删除列删除列后列中的数据无法恢复需小心操作修改列类型可能会删除或截断数据视更改的类型而定如不丢数据但可能出错重命名列使用数据会保留新增索引索引的增加不会丢失数据删除索引删除索引不会删除表中的数据重命名表使用数据不会丢失删除表删除表会丢失所有数据无法恢复更改主键视操作而定有时需要删除并重建表数据可能丢失外键变更视操作而定如果外键约束被删除可能会导致约束不满足因此使用重命名列迁移后再删除列再迁移等方式替代直接删除列迁移导致的数据丢失使用数据迁移的名字添加数据迁移执行语句添加数据迁移数据迁移名为返回表示成功如下然后执行返回如下删除迁移可以使用但如果迁移已被应用则无法使用列出所有迁移列出更新数据库的脚本可以使用重定向到一个文件中在中执行文件打开连接到您的实例打开文件在中选择菜单中的文件打开文件然后选择您刚刚生成的文件执行脚本打开文件后您可以查看生成的脚本点击工具栏上的执行按钮或者按以执行脚本使用自带的程序包管理器控制台上面两个语句分别对应如下才需要执行这句即不需要执行此命令用于启用迁移功能并为数据库创建迁移文件该命令会在项目中生成一个文件夹以及一个文件新建迁移更新数据库删除迁移列出所有迁移数据库更新脚本默认生成整个数据库的语句生成增量修改文件源迁移名称目标迁移名称的自动迁移注意不是的自动迁移自动迁移示例创建配置自动迁移启用自动迁移不允许数据丢失自动迁移过程中会阻止删除列等危险操作该方法可以用于在迁移完成后填充数据库常用于初始化数据库的种子数据例如添加一些默认记录在代码中调用迁移运行所有未应用的迁移继续执行其他程序逻辑重置所有迁移在某些极端情况下可能需要删除所有迁移并重新开始这可以通过删除文件夹并删除数据库来轻松完成此时你可以创建一个新的初始迁移其中将包含当前整个架构你还可以重置所有迁移并创建单个迁移而不会丢失数据此操作有时称为更正涉及一些手动操作删除文件夹创建新迁移并为其生成脚本或在数据库中删除迁移历史记录表中的所有行执行后手动在迁移历史记录中插入一行以记录第一个迁移已经应用因为表已经存在注意不执行反向工程使用方法案例参考必须继承数据库上下文中的类与数据库中的表进行一个映射关系声明表连接字符串文件的完整路径配置一些连接字符串日志的输出方式等等使用配置一个数据库连接表示始终放在启动目录中而不是当前工作目录此处使用的话是不对的自增主键一个文章有多个帖子外键数据库操作测试测试添加一条数据执行提交查询删除执行提交查询更新执行提交查询释放上下文上述连接数据库是通过写死连接字符串在代码中实现的但也可以将连接字符串写成如下形式连接字符串配置连接数据库的最常见方式是通过连接字符串配置这些字符串通常存储在或用于桌面程序用于程序文件中或格式文件演示开发者需要根据实际情况手动编辑这些配置文件确保数据库连接字符串正确无误通常配置项包括服务器地址例如表示使用本地数据库服务器数据库名称例如身份验证信息例如使用身份验证或身份验证使用方法这里对的各种增删改查方法做一次系统的总结和巩固上下文对象实例化上下文对象以此表为例查询下面的变量名详解这是的一个实例是中用于与数据库交互的主要类它管理实体对象的生命周期包括对象的查询保存删除等这里指的是中的一个属性代表了数据库中的一个集合用于操作指定类型的实体在中是表示数据库中表的集合的类是中的一种泛型集合类用于表示数据库上下文中的实体集合每个对应数据库中的一个表可以用于查询插入更新和删除表中的数据查询全表数据这里为了查看结果方便都使用结束了延迟加载延迟加载是中的一个特性指的是在实体属性被访问时才加载相关联的实体数据这意味着当你查询并获取一个实体对象时并不会立即加载它的导航属性指向的关联实体只有在你访问这些导航属性时才会执行必要的查询操作从数据库中加载这些关联实体的数据三种方式语句方法语句三者种方法结果相同但是之前的返回值类型是不一样的方法一方法二使用返回值类型为方法三中返回值类型为返回值类型为查询单个数据方法根据要查找的实体的主键值查对象若通过主键查用比较方便语句上面的简写形式查询单个数据时可以使用返回第一条数据结果为空时出异常返回序列第一条数据数据为空返回返回序列第一条数据多条结果时出异常若序列为空返回默认值方法语句查询部分字段语句方法语句因为查询部分字段要返回一个匿名类对象调用语句要指明类型然后使用这样的代码执行查询并返回结果增加主要是三种方法防脱发神器瓶程序员必备此处定义的是表中一行数据的实例通知上下文将实体的变化保存到数据库中修改状态中的实体的状态值有五种可以通过修改上下文中实体的值来实现相应增删改操作防脱发神器瓶程序员必备执行语句具体语句返回受影响行数删除先查找再删除操作数据库两次若直接实例化一个实体对象不是查出来的直接使用方法则会引发异常解释操作的对象必须在上下文中直接的实体对象是不在上下文中的解决办法通过方法将实例化的添加到上下文对象即可将添加到上下文对象中修改状态直接删除操作数据库一次若不指定主键值直接修改值去删除也会引发异常解释上下文中通过主键对实体对象进行跟踪因此修改值删除时要指明主键异常正确执行语句略同增加修改修改部分字段先查再修改修改全部字段设置状态跟删除一样要指明主键全部更新注意这种更新会将实例化的新对象中的值全部更新到数据库中未赋值的字段为更新为值解决方法可以先将实例化添加到上下文中设定某一字段的属性来实现只修改部分字段将对象添加到管理容器上下文对象执行语句略同增加延迟实例化延迟实例化是一种将对象的创建延迟到第一次需要用时的技术在中相关的功能是通过类引入的是在中引入的这个类用于实现延迟加载即在需要时才创建对象的实例从而提高性能和资源利用率并且是线程安全的可以用于在访问对象的属性或方法时延迟实例化也称为懒加载当使用的时候这里的就是你要延迟的集合那如何做到按需加载呢调用即可下面的代码片段展示了如何使用即访问的时候才真正初始化实例可以使用配合实现单例类只有将的实例声明为才能确保在整个应用程序中只有一个实例从而实现单例模式如果去掉每次创建实例时都会创建一个新的实例无法实现单例的效果原理具体原理是内部使用了一个委托该委托负责创建目标对象当你第一次访问的属性时该委托会执行实例化目标对象并将其保存下来随后的访问会直接返回已经创建好的对象而不会再次执行委托类提供了内建的线程安全机制确保在多线程环境下也能正常工作通过你可以实现延迟加载而且无需担心线程安全性内部使用了一种双重检查锁的机制确保在多线程环境下只有一个线程会执行被延迟加载的对象的初始化操作这意味着会保证在多线程环境下只有一个线程会调用目标对象的构造函数避免了竞态条件的发生具体来说使用了双重检查锁机制来保证线程安全第一次检查在没有锁的情况下检查是否已经初始化了对象如果对象已经初始化直接返回它否则进入第二个步骤加锁确保只有一个线程能够进入临界区域在进入临界区域后再次检查对象是否已经初始化如果没有初始化进行初始化操作这种双重检查锁机制在类内部实现确保了延迟加载的对象在多线程环境下的线程安全性缺点性能开销在第一次访问对象时需要进行初始化操作这可能会引入一定的性能开销特别是在初始化逻辑较复杂或耗时的情况下线程安全性默认情况下是线程安全的但如果需要在多线程环境下共享实例可能需要额外的线程同步措施这会增加复杂性内存占用虽然可以延迟对象的创建但在对象创建后它将一直占用内存即使后续不再需要该对象不适用于某些场景适用于需要延迟初始化的场景但并不适用于所有情况在某些情况下可能需要即时创建对象或使用其他设计模式引入额外复杂性在某些情况下使用可能会引入额外的复杂性使代码变得难以理解和维护的线程安全模式类提供了一些线程安全的模式例如和你可以根据需求选择适当的模式确保在多线程环境下实例的安全共享描述不进行任何线程安全保护适用场景只有单线程访问时使用或者你负责在多线程环境中确保线程安全注意如果多个线程同时访问属性可能会导致多个实例的创建描述允许多个线程同时初始化实例但只会有一个线程的初始化结果被保留其他线程在访问时会返回已经初始化的实例适用场景当你希望提高性能并允许并行初始化但不关心哪个线程的初始化结果被保留时使用注意这种模式下如果多个线程同时访问可能会导致多个实例的创建但最终只会有一个实例被保留默认情况描述这是最安全的模式只有一个线程能够初始化实例其他线程在访问时会等待初始化完成并共享同一个实例适用场景当你需要确保在多线程环境中只创建一个实例并且希望其他线程在访问时能够安全地共享该实例时使用注意这种模式下性能可能会受到影响因为它需要确保线程安全中的实现中可以通过或的实现线程安全的延迟初始化构造函数接受一个创建对象的工厂函数获取实例化的对象延迟创建检查值是否已经初始化工厂函数用于创建对象存储延迟实例化的对象保证线程安全的单次初始化记录是否已经初始化示例首次访问触发初始化再次访问不会重新初始化命名规范不要给别人和将来的自己添麻烦遵守相同的习惯与风格可以提高效率避免误会变量命名规范私有字段局部变量入参使用依赖注入时更为推荐一般不推荐使用关键字作为名称命名空间类名方法名接口名泛型类型名特性依赖属性特殊情形中的名及名或均可中的命名空间名尽量简单预编译器指令控件的事件注册允许下划线方法命名规范名称遵守命名规范无论是否为公共方法均首字母大写选择合适的动词名词非公共方法可为名称添加等字眼例外方法局部方法可以小写开头用于注册事件的方法异步方法异步方法以结尾与同名的同步方法进行区分便于快速判断调用的方法是否需要等待例外情况人尽皆知的方法控制器中的方法中才有虽然是异步的但是不添加因为不会被开发者直接调用而是框架调用合理选择单词选择最合适且被广泛接受的单词描述某个意思应该用于排序而不是用于命令用于表达应用而不是申请常用于名词而非动词避免使用过于宽泛或与标准库重名的词汇布尔类型的成员一般以开头使用偏正式的单词而非偏口语化的单词语法与时态一般使用第三人称单数可以考虑使用复数形式尽量不要使用单复数不符合常见形式可适当未被词汇或语法使用会很痛苦需要加一些新的特性不符合语法但可以不符合语法但可以考虑时态习惯对于事件可以以开头正在关闭已经关闭更多细节名称写清晰且完整例外情形遵守普通习惯指语义上拓展方法尽量简洁且清晰由于调用的时候已经知道转换的主体了因此后者在保持语义清晰的同时更简洁杜绝等命名习惯包盘点绘图下载包避免除以零的情况绘制轴和轴绘制轴绘制轴在零的位置改变折线颜色以区别于轴线绘制多条曲线图圆点半径虚线绘制不全还未修正是一个用于动态解析和执行表达式的库主要用于将字符串形式的表达式解析为可执行的表达式它的主要功能包括开源开源地址动态计算可以在运行时动态地解析和计算表达式而不需要在编译时确定所有的逻辑这在某些场景下非常有用比如需要根据用户输入或配置文件动态生成逻辑的情况简化代码通过将复杂的逻辑表达式以字符串形式表示可以简化代码的编写和维护例如可以将业务规则或条件逻辑存储为字符串然后在需要时解析并执行灵活性允许开发者在运行时创建和调整表达式使得应用程序能够更灵活地响应变化例如在规则引擎或查询语言中用户可以输入自定义的查询条件系统则可以解析并执行这些条件可以评估数学表达式或者解析带有多个变量或参数的表达式并多次调用它或者为查询生成委托和表达式是一个用于在中生成和读取文件的库它通常用于将数据导出到格式或者从文件中读取数据库提供了简单易用的使得处理文件变得更加方便开源地址详细使用介绍简单记录使用方式定义一个可以和文件格式对应的类读取方式读取自定义的类该方法将返回一个记录这意味着在迭代记录时一次只返回一条记录这也意味着只有一小部分文件被读入内存但要小心如果您执行任何执行投影的操作例如调用则整个文件将被读入内存是仅向前的因此如果您想针对数据运行任何查询则必须将整个文件拉入内存只要知道这就是你在做的事情如果文件中没有标题记录或者想要改属性名的对应大小写格式都可以参考详细使用介绍写入方式将对象写入文件第三方数据结构库用于的通用集合库开源开源地址安装方式线性数据结构底层使用动态数组实现支持快速随机访问但插入和删除操作在中间位置可能比较慢底层使用双向链表实现支持快速插入和删除操作但随机访问比较慢底层使用动态数组和哈希表实现支持快速随机访问和插入但删除操作可能比较慢底层使用双向链表和哈希表实现支持快速插入和删除操作但随机访问比较慢集合底层使用哈希表实现不包含重复元素支持快速查找插入和删除操作底层使用哈希表实现允许重复元素支持快速查找插入和删除操作底层使用有序数组实现支持快速查找插入和删除操作但插入和删除操作在中间位置可能比较慢底层使用数组实现提供对数组的只读访问底层使用平衡二叉树红黑树实现有序集合不包含重复元素支持快速查找插入和删除操作并保持元素的排序底层使用平衡二叉树红黑树实现有序集合允许重复元素支持快速查找插入和删除操作并保持元素的排序栈和队列底层使用数组或链表实现后进先出的栈支持快速入栈和出栈操作底层使用双向链表实现支持从两端进行入队和出队操作底层使用数组实现支持快速入队和出队操作但容量有限底层使用间隔堆实现支持快速插入和删除操作并根据优先级排序元素字典底层使用哈希表实现支持快速查找插入和删除操作底层使用平衡二叉树红黑树实现支持快速查找插入和删除操作并保持键的排序即使是这样也没找到一个类似于中的这样的数据结构控制反转容器库可以提供自动注入构造函数参数的功能也可以提供面向切片编程的实现状态机库开源地址是一个轻量级的状态机库用于在应用程序中实现状态机模式它允许你以简单直观的方式定义状态转换和触发器安装方式基本概念状态对象在某一时刻的条件或情况触发器导致状态改变的事件或动作转换从一个状态到另一个状态的转变如何使用定义状态和触发器开始使用之前你需要定义状态机的状态和触发器状态表示对象当前所处的阶段而触发器是导致状态改变的事件创建状态机使用类创建一个状态机实例你需要指定初始状态配置状态转换定义状态和触发器之间的转换关系你可以使用方法为每个状态设置可以接受的触发器允许状态机在状态下被变化到状态允许状态机在状态下被变化到状态触发转换通过触发器改变状态机的状态调用方法来执行状态转换输出输出添加进入和退出动作你可以在状态进入或退出时执行特定的动作使用和方法使用条件限制转换可以使用条件来限制某些状态转换例如你可以在某个条件下允许转换异步支持也支持异步状态转换你可以使用异步方法来配置和触发状态机还支持子状态动态触发器参数等略其他获取可用触发器检查是否可以触发特定转换获取当前状态信息完整案例下面是一个订单处理系统的示例使用方式自动映射库等但自动映射使用起来要注意查找所有引用或查找哪里使用了这种操作无法找到自动映射的使用这样当清除某些属性的时候就不好判断是否有别处用了有可能是在自动映射中使用了这个问题也有解决方案有辅助的插件可以生成映射代码一些好用的控件盘点',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-03-05 13:55:20',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://th.bing.com/th/id/OIP.wtmjepfWPBvn26uz7s18dgHaHa?rs=1&amp;pid=ImgDetMain"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">ZEROKO14的个人博客</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size: 1.05rem;">C#<sup>2</sup></a><a href="/tags/C/" style="font-size: 1.05rem;">C++<sup>5</sup></a><a href="/tags/CSS/" style="font-size: 1.05rem;">CSS<sup>1</sup></a><a href="/tags/CSharp/" style="font-size: 1.05rem;">CSharp<sup>1</sup></a><a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 1.05rem;">C语言<sup>1</sup></a><a href="/tags/FPS/" style="font-size: 1.05rem;">FPS<sup>1</sup></a><a href="/tags/HTML/" style="font-size: 1.05rem;">HTML<sup>1</sup></a><a href="/tags/JavaScript/" style="font-size: 1.05rem;">JavaScript<sup>1</sup></a><a href="/tags/MFC/" style="font-size: 1.05rem;">MFC<sup>1</sup></a><a href="/tags/PE/" style="font-size: 1.05rem;">PE<sup>1</sup></a><a href="/tags/QT/" style="font-size: 1.05rem;">QT<sup>1</sup></a><a href="/tags/WPF/" style="font-size: 1.05rem;">WPF<sup>2</sup></a><a href="/tags/ai/" style="font-size: 1.05rem;">ai<sup>1</sup></a><a href="/tags/cmake/" style="font-size: 1.05rem;">cmake<sup>1</sup></a><a href="/tags/doxygen/" style="font-size: 1.05rem;">doxygen<sup>1</sup></a><a href="/tags/git/" style="font-size: 1.05rem;">git<sup>1</sup></a><a href="/tags/json/" style="font-size: 1.05rem;">json<sup>1</sup></a><a href="/tags/linux/" style="font-size: 1.05rem;">linux<sup>1</sup></a><a href="/tags/nas/" style="font-size: 1.05rem;">nas<sup>1</sup></a><a href="/tags/next/" style="font-size: 1.05rem;">next<sup>1</sup></a><a href="/tags/ppt/" style="font-size: 1.05rem;">ppt<sup>1</sup></a><a href="/tags/slidev/" style="font-size: 1.05rem;">slidev<sup>1</sup></a><a href="/tags/vue/" style="font-size: 1.05rem;">vue<sup>1</sup></a><a href="/tags/xml/" style="font-size: 1.05rem;">xml<sup>1</sup></a><a href="/tags/yaml/" style="font-size: 1.05rem;">yaml<sup>1</sup></a><a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 1.05rem;">代码规范<sup>1</sup></a><a href="/tags/%E5%86%85%E6%A0%B8/" style="font-size: 1.05rem;">内核<sup>2</sup></a><a href="/tags/%E5%86%85%E6%A0%B8%E7%9B%B8%E5%85%B3/" style="font-size: 1.05rem;">内核相关<sup>5</sup></a><a href="/tags/%E5%8A%A0%E8%A7%A3%E5%AF%86/" style="font-size: 1.05rem;">加解密<sup>1</sup></a><a href="/tags/%E5%9F%BA%E7%A1%80/" style="font-size: 1.05rem;">基础<sup>2</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 1.05rem;">多线程<sup>1</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F/" style="font-size: 1.05rem;">并发模式<sup>1</sup></a><a href="/tags/%E5%BC%80%E5%8F%91/" style="font-size: 1.05rem;">开发<sup>4</sup></a><a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 1.05rem;">数学<sup>1</sup></a><a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 1.05rem;">正则表达式<sup>1</sup></a><a href="/tags/%E7%9B%91%E6%8E%A7/" style="font-size: 1.05rem;">监控<sup>1</sup></a><a href="/tags/%E7%A1%AC%E7%BC%96%E7%A0%81/" style="font-size: 1.05rem;">硬编码<sup>1</sup></a><a href="/tags/%E7%AE%A1%E7%90%86/" style="font-size: 1.05rem;">管理<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 1.05rem;">网络<sup>3</sup></a><a href="/tags/%E9%80%86%E5%90%91/" style="font-size: 1.05rem;">逆向<sup>2</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/02/"><span class="card-archive-list-date">二月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/12/"><span class="card-archive-list-date">十二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/11/"><span class="card-archive-list-date">十一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/09/"><span class="card-archive-list-date">九月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">七月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">14</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/06/"><span class="card-archive-list-date">六月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/04/"><span class="card-archive-list-date">四月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">十一月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">27</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url">技术</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/CSharp/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>CSharp</span></a></span></div></div><h1 class="post-title" itemprop="name headline">CSharp入门</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-07-16T04:06:28.941Z" title="发表于 2024-07-16 12:06:28">2024-07-16</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-03-05T05:55:20.124Z" title="更新于 2025-03-05 13:55:20">2025-03-05</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="CSharp入门"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为新加坡"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>新加坡</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://che77a38.github.io/posts/CSharp%E5%85%A5%E9%97%A8/"><header><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url">技术</a><a href="/tags/CSharp/" tabindex="-1" itemprop="url">CSharp</a><h1 id="CrawlerTitle" itemprop="name headline">CSharp入门</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">ZEROKO14</span><time itemprop="dateCreated datePublished" datetime="2024-07-16T04:06:28.941Z" title="发表于 2024-07-16 12:06:28">2024-07-16</time><time itemprop="dateCreated datePublished" datetime="2025-03-05T05:55:20.124Z" title="更新于 2025-03-05 13:55:20">2025-03-05</time></header><p>C# 又称“C Sharp”，是微软发布的一种简单、安全、稳定、通用的面向对象编程语言。</p>
<span id="more"></span>

<p>C# 是从 C&#x2F;C++ 衍生出来的，它在继承 C&#x2F;C++强大功能的同时，抛弃了 C&#x2F;C++ 的一些复杂特性。C# 还和 Java 非常类似，仅仅在一些细节上有差别。</p>
<p>C# 运行在 .NET Framework 上，借助 C# 可以开发不同类型的应用程序：</p>
<ul>
<li>桌面应用程序；</li>
<li>网络应用程序；</li>
<li>分布式应用程序；</li>
<li>Web 服务应用程序；</li>
<li>数据库应用程序等。</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202404090813099.png"  />

<h1 id="NET-Framework"><a href="#NET-Framework" class="headerlink" title=".NET Framework"></a>.NET Framework</h1><p>.NET Framework 主要由四个部分构成，如下所示：</p>
<ul>
<li>公共语言运行库（CLR）；</li>
<li>框架类库（FCL）；</li>
<li>核心语言（WinForms、ASP.NET 和 ADO.NET）；</li>
<li>其他模块（WCF、WPF、WF、Card Space、LINQ、Entity Framework、Parallel LINQ、Task Parallel Library 等）。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202403192327412.png" alt="4-220I0133321X5"></p>
<h2 id="CLR：公共语言运行库"><a href="#CLR：公共语言运行库" class="headerlink" title="CLR：公共语言运行库"></a>CLR：公共语言运行库</h2><p>CLR 全称为“Common Language Runtime”，它为 .NET 应用程序提供了一个托管的代码执行环境（类似 Java 中的虚拟机），是整个 .NET 框架的核心。实际上 CLR 是驻留在内存里的一段代码，负责程序执行期间的代码管理工作，例如内存管理、线程管理、安全管理、远程管理、即时编译等。</p>
<ul>
<li>Base Class Library Support（基础类库）：一个类库，为 .NET 应用程序提供了一些类；</li>
<li>Thread Support（线程支持）：用来管理多线程应用程序的并行执行；</li>
<li>COM Marshaler（COM 封送处理程序）：提供 COM 对象与应用程序之间的通信；</li>
<li>Type Checker（类型检查器）：检查应用程序中使用的类型，并验证它们是否与 CLR 提供的标准类型匹配；</li>
<li>Code Manager（代码管理器）：在程序运行时管理代码；</li>
<li>Garbage Collector（垃圾回收器）：释放未使用的内存，并将其分配给新的应用程序；</li>
<li>Exception Handler（异常管理器）：在程序运行时处理异常，避免应用程序运行失败；</li>
<li>Class Loader（类加载器）：在运行时加载所有的类。</li>
</ul>
<h2 id="FCL：框架类库"><a href="#FCL：框架类库" class="headerlink" title="FCL：框架类库"></a>FCL：框架类库</h2><p>FCL 全称为“Framework Class Library”，它是一个标准库，其中包含了成千上万个类，主要用于<strong>构建应用程序</strong>。FCL 的核心是 BCL（Base Class Library：基础类库），BCL 提供了 FCL 的基本功能。FCL 的基本组成如下所示：</p>
<h2 id="WinForms"><a href="#WinForms" class="headerlink" title="WinForms"></a>WinForms</h2><p>WinForms 是 Windows Forms 的简称，它是一种 .NET Framework 的<strong>智能客户端技术</strong>，用来开发可以在电脑中运行的应用程序，经常使用的记事本就是使用 WinForms 技术开发的。</p>
<h2 id="ASP-NET"><a href="#ASP-NET" class="headerlink" title="ASP.NET"></a>ASP.NET</h2><p>ASP.NET 是一个微软设计和开发的 Web 框架，于 2002 年 1 月首次发布，ASP.NET 中完美的集成了 HTML、CSS 和 JavaScript。可以使用 ASP.NET 来<strong>开发网站、Web 应用程序和 Web 服务</strong>。</p>
<h2 id="ADO-NET"><a href="#ADO-NET" class="headerlink" title="ADO.NET"></a>ADO.NET</h2><p>ADO.NET 一个是 .Net Framework 的模块，由可用于连接、检索、插入和删除数据的类组成，主要用来开发能够与 SQL Server、Oracle 等<strong>数据库进行交互</strong>的应用程序。</p>
<h2 id="WPF"><a href="#WPF" class="headerlink" title="WPF"></a>WPF</h2><p>WPF 全称为“Windows Presentation Foundation”，是微软推出的<strong>基于 Windows 的用户界面框架</strong>，主要用来设计 Windows 应用程序的用户界面。WPF 以前也叫“Avalon”，集成在 .NET Framework 中，2006 发布的 .NET Framework 3.0 是最早支持 WPF 的。</p>
<h2 id="WCF"><a href="#WCF" class="headerlink" title="WCF"></a>WCF</h2><p>WCF 全称为“Windows Communication Foundation”，是由微软开发的支持数据通信的应用程序框架，中文翻译为 Windows 通讯开发平台。与 WPF 相同，WCF 最早也是集成在 .NET Framework 3.0 中，WCP、WPF 和 WF 被统称为新一代 Windows 操作系统以及 WinFX（Windows Vista 的托管代码编程模型）的三个重大应用程序开发类库。</p>
<p>WCF 整合了 Windows 通讯中的 .net Remoting、WebService、Socket 机制，并融合了 HTTP 和 FTP 的相关技术，因此尤其适合 <strong>Windows 平台上分布式应用的开发</strong>。</p>
<h2 id="WF"><a href="#WF" class="headerlink" title="WF"></a>WF</h2><p>WF 全称为“Windows Workflow Foundation”，是微软提供的一项技术，其中提供 API、进程内工作流引擎和可重新托管的设计器，用来将长时间运行的进程实现为 .NET 应用程序中的工作流。</p>
<h2 id="LINQ"><a href="#LINQ" class="headerlink" title="LINQ"></a>LINQ</h2><p>LINQ 技术在 2007 年跟随 .NET Framework 3.5 一同发布，其全称为“Language Integrated Query”，是微软的一项技术，<strong>新增了一种自然查询的 SQL 语法</strong>到 .NET Framework 的编程语言中，当前支持 C# 以及 Visual Basic .NET 语言。</p>
<p>常用的LINQ方法包括：</p>
<ul>
<li><code>Select</code>: 投影操作，将集合的每个元素转换为另一个形式。</li>
<li><code>Where</code>: 过滤操作，根据条件筛选集合的元素。</li>
<li><code>OrderBy</code>&#x2F;<code>OrderByDescending</code>: 排序操作。</li>
<li><code>GroupBy</code>: 分组操作。</li>
<li><code>Aggregate</code>: 聚合操作，可以进行累积计算。</li>
<li><code>Any</code>&#x2F;<code>All</code>: 用于判断集合中是否有任何一个元素满足条件，或者所有元素都满足条件。</li>
<li><code>First</code>&#x2F;<code>FirstOrDefault</code>: 获取集合中的第一个元素。</li>
<li><code>SelectMany</code>: 将多个集合扁平化为一个集合。</li>
</ul>
<p>linq语法在tolist的时候才真正执行代码,属于延迟执行</p>
<h2 id="Parallel-LINQ"><a href="#Parallel-LINQ" class="headerlink" title="Parallel LINQ"></a>Parallel LINQ</h2><p>Parallel LINQ 也叫 PLINQ，是对 LINQ 技术的并行实现，PLINQ 将 LINQ 语法的简洁和可靠性与并行编程的强大功能结合在一起，大大提高了使用 LINQ 时的运行速度。</p>
<h1 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h1><h2 id="mac版"><a href="#mac版" class="headerlink" title="mac版"></a>mac版</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv19486819">完整参考此处</a></p>
<ol>
<li><a target="_blank" rel="noopener" href="https://dotnet.microsoft.com/zh-cn/download">下载.net链接</a>  , <code>dotnet -info</code>查看是否安装完成</li>
<li>vscode安装C# Dev Kit 和 C#拓展</li>
<li><code>dotnet new console -o 新项目文件夹路径</code> 到新项目去</li>
</ol>
<p>p.s. <code>launch.json</code>中添加 <code>&quot;console&quot;: &quot;integratedTerminal&quot;,</code>设置输出到终端</p>
<p><strong>编译命令</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">项目目录下</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">编译发布版</span></span><br><span class="line">dotnet build -c Release </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">编译调试版</span></span><br><span class="line">dotnet build -c Debug</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用dotnet build实际上调用的是C#编译器(csc)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看已安装的nuget包依赖项</span></span><br><span class="line">dotnet list package</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">添加 NuGet 包。</span></span><br><span class="line">dotnet add package    </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除 NuGet 包。</span></span><br><span class="line">dotnet remove package    </span><br></pre></td></tr></table></figure>

<p>在Mac上使用NuGet时，您通常会使用dotnet命令行工具来执行NuGet操作。dotnet命令行工具是.NET Core的官方命令行工具，用于构建、运行和管理.NET应用程序。通过dotnet命令行工具，您可以使用NuGet来添加、删除和更新项目的依赖项。</p>
<p>1、列出Nuget本地的路径</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet nuget locals all --list</span><br></pre></td></tr></table></figure>

<p>2、使用dotnet命令安装引用Nuget包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet add package NLog</span><br></pre></td></tr></table></figure>

<p>3、安装引用指版本使用-v</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet add package NLog -v 4.6.7</span><br></pre></td></tr></table></figure>

<p>4、使用特定源安装引用Nuget包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet add package Microsoft.AspNetCore.StaticFiles -s https://dotnet.myget.org/F/dotnet-core/api/v3/index.json</span><br></pre></td></tr></table></figure>

<p>注意：执行命令的目录是要安装的项目的.csproj文件位置</p>
<p>5、指定项目.csproj文件位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet add ToDo.csproj package NLog -v 1.0.0</span><br></pre></td></tr></table></figure>

<h3 id="vscode-Nuget-Package-Manager扩展插件"><a href="#vscode-Nuget-Package-Manager扩展插件" class="headerlink" title="vscode Nuget Package Manager扩展插件"></a>vscode Nuget Package Manager扩展插件</h3><p>在VSCode的扩展插件中，搜索并且安装Nuget Package Manager扩展插件</p>
<p>使用ctrl + shift + p或者ctrl + p（mac下将ctrl替换成cmd）</p>
<p>输入&gt; nuget ，在下拉框中选择&gt;Nuget Package Manager:Add Package</p>
<p>输入需要安装的包名（不需要完整的包名，可以模糊搜索），进行搜索</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/springsnow/p/12882696.html">mac配置c#开发环境更详细的参考</a></p>
<h1 id="nuget包相关"><a href="#nuget包相关" class="headerlink" title="nuget包相关"></a>nuget包相关</h1><p>在 .NET Core 和 .NET 5+ 项目中，NuGet 包默认存储在用户的全局包缓存中，而不是项目的 <code>packages</code> 文件夹中。全局包缓存的位置如下：</p>
<ul>
<li><strong>Windows</strong>: <code>C:\Users\&lt;username&gt;\.nuget\packages</code></li>
<li><strong>macOS&#x2F;Linux</strong>: <code>/Users/&lt;username&gt;/.nuget/packages</code> 或 <code>/home/&lt;username&gt;/.nuget/packages</code></li>
</ul>
<p><code>.net core</code>下使用nuget包的相关命令要使用<code>dotnet nuget ...</code>这样的形式使用</p>
<h2 id="nuget包的打包与发布"><a href="#nuget包的打包与发布" class="headerlink" title="nuget包的打包与发布"></a>nuget包的打包与发布</h2><p>vs在类库项目属性中添加各种信息,记得勾选<strong>在构建时生成NuGet包</strong>选项,之后生成项目的时候会生成一个nupkg文件,到<a target="_blank" rel="noopener" href="https://www.nuget.org/packages/manage/upload#">nuget官网上传页</a>上传该文件就可以了</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44448313/article/details/106695032">详细信息可以参考此处</a></p>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>在nuget官网上新建API密钥</p>
<p>注意要在vs设置中确保使用一个未被占用的版本号，以便顺利完成发布</p>
<p>通过命令指定新生成的nupgk文件来更新: <code>dotnet nuget push YourPackage.nupkg --source https://api.nuget.org/v3/index.json --api-key YourApiKey</code></p>
<h1 id="CSharp概述"><a href="#CSharp概述" class="headerlink" title="CSharp概述"></a>CSharp概述</h1><p>C# 之所以能称为一门被广泛应用的编程语言，原因有以下几点：</p>
<ul>
<li>C# 是一种现代的通用的编程语言；</li>
<li>C# 是面向对象的；</li>
<li>C# 是面向组件的；</li>
<li>C# 简单易学；</li>
<li>C# 是一种结构化语言；</li>
<li>使用 C# 开发效率很高；</li>
<li>C# 可以在各种计算机平台上进行编译；(相对于 Java 的“一次编写，到处运行”，C# 的跨平台性可能稍显不足。)</li>
<li>C# 是 .Net Framework 的一部分。</li>
</ul>
<p>以下是 C# 的一些重要功能的列表：</p>
<ul>
<li>布尔条件；</li>
<li>自动垃圾回收；</li>
<li>标准库；</li>
<li>组件版本；</li>
<li>属性和事件；</li>
<li>委托和时间管理；</li>
<li>易于使用的泛型；</li>
<li>索引器；</li>
<li>条件编译；</li>
<li>简单的多线程；</li>
<li>LINQ 和 Lambda 表达式；</li>
<li>集成 Windows。</li>
</ul>
<p>借助 C# 编程语言，可以开发不同类型且安全可靠的应用程序，例如：</p>
<ul>
<li>桌面应用程序；</li>
<li>网络应用程序；</li>
<li>分布式应用程序；</li>
<li>Web 服务应用程序；</li>
<li>数据库应用程序等。</li>
</ul>
<blockquote>
<p>C# 中的关键字是编译器预先定义好的一些单词，也可以称为保留字或者保留标识符，这些关键字对编译器有特殊的意义，不能用作标识符。但是，如果您非要使用的话也不是没有办法，只需要在关键字前面加上<code>@</code>前缀即可，例如<code>@if</code>就是一个有效的标识符，而<code>if</code>则是一个关键字。</p>
<p>在 C# 中，有些关键字在代码的上下文中具有特殊的意义，例如 get 和 set，这样的关键字被称为上下文关键字（contextual keywords）。一般来说，C# 语言中新增的关键字都会作为上下文关键字，这样可以避免影响到使用旧版语言编写的 C# 程序。</p>
<p>下图列出了 C# 中的保留关键字（Reserved Keywords）和上下文关键字（Contextual Keywords）</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202403201322738.png" alt="image-20240320132236392" style="zoom:67%;" />
</blockquote>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>C# 语言中内置了一些基本的数据类型，数据类型用来指定程序中变量可以存储的数据的类型，C# 中的数据类型可以大致分为三类：</p>
<ul>
<li>值类型（Value types）；</li>
<li>引用类型（References types）；</li>
<li>指针类型（Pointer types）。</li>
</ul>
<blockquote>
<p>在C#中,不需要像C++中函数传参的时候考虑应该用引用传递还是值传递,因为:</p>
<p>在C#中，传递对象时的行为取决于该对象的类型。值类型和引用类型</p>
<ul>
<li><strong>值类型</strong>：当你传递一个值类型的变量时，C#默认进行值复制，也就是说，函数内部得到的是原始变量的一个副本，对这个副本的修改不会影响到原始变量。但是，你可以使用<code>ref</code>或<code>out</code>关键字来按引用传递值类型，这样函数内部对参数的修改会影响到原始变量。</li>
<li><strong>引用类型</strong>：当你传递一个引用类型的变量时，C#默认进行引用传递，也就是说，函数内部得到的是原始对象的引用，对这个引用的修改会影响到原始对象。但是，如果你修改了引用本身（即让它指向一个新的对象），这个修改不会影响到原始变量，因为这个修改只改变了函数内部的引用，而没有改变原始变量的引用。</li>
</ul>
</blockquote>
<h2 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h2><p>C# 中的值类型是从 <code>System.ValueType</code> 类中派生出来的，对于值类型的变量可以直接为其分配一个具体的值。当声明一个值类型的变量时，系统会自动分配一块儿内存区域用来存储这个变量的值，需要注意的是，变量所占内存的大小会根据系统的不同而有所变化。</p>
<p>C# 中的值类型有很多，如下表所示：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202403201325933.png" alt="image-20240320132506645" style="zoom: 67%;" />

<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>用类型的变量中并不存储实际的数据值，而是存储的对数据（对象）的引用，换句话说就是，引用类型的变量中存储的是数据在内存中的位置。当多个变量都引用同一个内存地址时，如果其中一个变量改变了内存中数据的值，那么所有引用这个内存地址的变量的值都会改变。</p>
<p>C# 中内置的引用类型包括 </p>
<ul>
<li>Object（对象）</li>
<li>Dynamic（动态）</li>
<li>string（字符串）</li>
</ul>
<h3 id="对象类型（Object）"><a href="#对象类型（Object）" class="headerlink" title="对象类型（Object）"></a>对象类型（Object）</h3><p>对象类型是 C# 通用类型系统（Common Type System：CTS）中所有数据类型的最终基类，Object 是 System.Object 类的别名。任何类型的值都可以分配给对象类型，但是在分配值之前，需要对类型进行转换。</p>
<blockquote>
<p>将值类型转换为对象类型的过程被称为“装箱”，反之将对象类型转换为值类型的过程则被称为“拆箱”。注意，只有经过装箱的数据才能进行拆箱。</p>
</blockquote>
<p><strong>类型检查在编译时进行的</strong></p>
<h3 id="动态类型（Dynamic）"><a href="#动态类型（Dynamic）" class="headerlink" title="动态类型（Dynamic）"></a>动态类型（Dynamic）</h3><p>您可以在动态类型的变量中存储任何类型的值，这些变量的类型检查是在程序运行时进行的。动态类型的声明语法如下所示：</p>
<p><code>dynamic &lt;variable_name&gt; = value;</code></p>
<p>例如：</p>
<p><code>dynamic d = 20;</code></p>
<p>类型检查在<strong>程序运行时进行的</strong>。</p>
<h3 id="字符串类型（String）"><a href="#字符串类型（String）" class="headerlink" title="字符串类型（String）"></a>字符串类型（String）</h3><p>字符串类型的变量允许您将一个字符串赋值给这个变量，字符串类型需要通过 String 类来创建，String 类是 System.String 类的别名，它是从对象（Object）类型中派生的。在 C# 中有两种定义字符串类型的方式，分别是使用<code>&quot; &quot;</code>和<code>@&quot; &quot;</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用引号的声明方式</span></span><br><span class="line">String str = <span class="string">&quot;http://helloworld/&quot;</span>;</span><br><span class="line"><span class="comment">//使用 @ 加引号的声明形式</span></span><br><span class="line">@<span class="string">&quot;http://helloworld/&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>使用<code>@&quot; &quot;</code>形式声明的字符串称为“逐字字符串”，逐字字符串会将转义字符<code>\</code>当作普通字符对待，例如<code>string str = @&quot;C:\Windows&quot;;</code>等价于<code>string str = &quot;C:\\Windows&quot;;</code>。</p>
<p>另外，在<code>@&quot; &quot;</code>形式声明的字符串中可以任意使用换行，换行符及缩进空格等都会计算在字符串的长度之中。</p>
<h2 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h2><p>C# 语言中的指针是一个变量，也称为定位器或指示符，其中可以存储另一种类型的内存地址。C# 中的指针与 C 或 C++ 中的指针具有相同的功能。</p>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>变量可以理解为是程序可以操作的内存区域的名称，在 C# 中每个变量都有自己特定的类型，这个类型确定了变量所占内存的大小、布局、取值范围以及可以对该变量执行的操作。</p>
<p>可以将变量当作一种通过符号（变量名）表示某个内存区域的方法，变量的值可以更改，并且可以多次重复使用。C# 中的基本变量类型可以归纳为以下几种：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>整型（整数类型）</td>
<td>sbyte、byte、short、ushort、int、uint、long、ulong、char</td>
</tr>
<tr>
<td>浮点型</td>
<td>float、double</td>
</tr>
<tr>
<td>十进制类型</td>
<td>decimal</td>
</tr>
<tr>
<td>布尔型</td>
<td>true、false</td>
</tr>
<tr>
<td>空类型</td>
<td>可为空值的数据类型</td>
</tr>
</tbody></table>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">helloworld</span>&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">int</span> a, b;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;请输入第一个数字：&quot;</span>);</span><br><span class="line">            a = Convert.ToInt32(Console.ReadLine());</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;请输入第二个数字：&quot;</span>);</span><br><span class="line">            b = Convert.ToInt32(Console.ReadLine());</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;&#123;0&#125;+&#123;1&#125;=&#123;2&#125;&quot;</span>, a, b, a+b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为使用 Console.ReadLine() 接收的数据是字符串格式的，所以使用 Convert.ToInt32() 函数来将用户输入的数据转换为 int 类型。</p>
<p>C#中的表达式非</p>
<ul>
<li>左值表达式 Lvalues</li>
<li>右值表达式 Rvalues</li>
</ul>
<h2 id="CSharp可空类型"><a href="#CSharp可空类型" class="headerlink" title="CSharp可空类型"></a>CSharp可空类型</h2><p>在 C# 1.x 的版本中，一个值类型的变量是不可以被赋值为 null（空值）的，否则会产生异常。而在 C# 2.0 中，新增了一个 nullable 类型，可以使用 nullable 类型定义包含 null 值的数据，例如，您可以在 nullable <Int32>（可为空的 int32 类型）类型的变量中存储 -2147483648 到 2147483647 之间的任何值或者 null。同样，您可以在 nullable <bool>（可为空的 bool 类型）类型的变量中存储 true、false 或 null。声明可空类型的语法如下：</p>
<p><code>data_type? variable_name = null;</code></p>
<p>其中，<code>data_type</code> 为要声明的数据类型，后面紧跟一个问号；<code>variable_name</code> 则为变量的名称。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">helloworld</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Demo</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">int</span>? num1;</span><br><span class="line">            <span class="built_in">int</span>? num2 = <span class="number">123</span>;</span><br><span class="line">            num1 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">double</span>? num3 = <span class="keyword">new</span> <span class="built_in">double</span>?();</span><br><span class="line">            <span class="built_in">double</span>? num4 = <span class="number">3.1415926</span>;</span><br><span class="line">            <span class="built_in">bool</span>? boolval = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 输出这些值</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;num1 = &#123;0&#125; \r\n num2 = &#123;1&#125; \r\n num3 = &#123;2&#125; \r\n num4 = &#123;3&#125; \r\n boolval = &#123;4&#125;&quot;</span>, num1, num2, num3, num4, boolval);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// num1 =</span></span><br><span class="line"><span class="comment">// num2 = 123</span></span><br><span class="line"><span class="comment">// num3 =</span></span><br><span class="line"><span class="comment">// num4 = 3.1415926</span></span><br><span class="line"><span class="comment">// boolval =</span></span><br></pre></td></tr></table></figure>

<h2 id="Null-合并运算符（-）"><a href="#Null-合并运算符（-）" class="headerlink" title="Null 合并运算符（??）"></a>Null 合并运算符（??）</h2><p>在 C# 中 Null 合并运算符用于定义可空类型和引用类型的默认值。如果此运算符的左操作数不为 null，那么运算符将返回左操作数，否则返回右操作数。例如表达式<code>a??b</code>中，如果 a 不为空，那么表达式的值则为 a，反之则为 b。</p>
<p>需要注意的是，Null 合并运算符左右两边操作数的<strong>类型必须相同，或者右操作数的类型可以隐式的转换为左操作数的类型</strong>，否则将编译错误。</p>
<p><code>num3 = num1 ?? 321;</code></p>
<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><p>一种数据类型（类型 A），只要其取值范围完全包含在另一种数据类型（类型 B）的取值范围内，那么类型 A 就可以隐式转换为类型 B。基于这一特性，C# 的隐式类型转换不会导致数据丢失。</p>
<h2 id="显示类型转换"><a href="#显示类型转换" class="headerlink" title="显示类型转换"></a>显示类型转换</h2><p>显式类型转换也叫强制类型转换，这种转换需要使用<code>(type)value</code>的形式或者预定义函数显式的完成，显式转换需要用户明确的指定要转换的类型，而且在转换的过程中可能会造成数据丢失</p>
<p>C# 中还提供了一系列内置的类型转换方法，如下表所示：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ToBoolean</td>
<td>将类型转换为布尔型</td>
</tr>
<tr>
<td>ToByte</td>
<td>将类型转换为字节类型</td>
</tr>
<tr>
<td>ToChar</td>
<td>将类型转换为单个 Unicode 字符类型</td>
</tr>
<tr>
<td>ToDateTime</td>
<td>将类型（整数或字符串类型）转换为日期时间的结构</td>
</tr>
<tr>
<td>ToDecimal</td>
<td>将浮点型或整数类型转换为十进制类型</td>
</tr>
<tr>
<td>ToDouble</td>
<td>将类型转换为双精度浮点型</td>
</tr>
<tr>
<td>ToInt16</td>
<td>将类型转换为 16 位整数类型</td>
</tr>
<tr>
<td>ToInt32</td>
<td>将类型转换为 32 位整数类型</td>
</tr>
<tr>
<td>ToInt64</td>
<td>将类型转换为 64 位整数类型</td>
</tr>
<tr>
<td>ToSbyte</td>
<td>将类型转换为有符号字节类型</td>
</tr>
<tr>
<td>ToSingle</td>
<td>将类型转换为小浮点数类型</td>
</tr>
<tr>
<td>ToString</td>
<td>将类型转换为字符串类型</td>
</tr>
<tr>
<td>ToType</td>
<td>将类型转换为指定类型</td>
</tr>
<tr>
<td>ToUInt16</td>
<td>将类型转换为 16 位无符号整数类型</td>
</tr>
<tr>
<td>ToUInt32</td>
<td>将类型转换为 32 位无符号整数类型</td>
</tr>
<tr>
<td>ToUInt64</td>
<td>将类型转换为 64 位无符号整数类型</td>
</tr>
</tbody></table>
<p>例子:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">helloworld</span>&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">StringConversion</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">int</span> i = <span class="number">75</span>;</span><br><span class="line">            <span class="built_in">float</span> f = <span class="number">53.005</span>;</span><br><span class="line">            <span class="built_in">double</span> d = <span class="number">2345.7652</span>;</span><br><span class="line">            <span class="built_in">bool</span> b = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(i.ToString());</span><br><span class="line">            Console.WriteLine(f.ToString());</span><br><span class="line">            Console.WriteLine(d.ToString());</span><br><span class="line">            Console.WriteLine(b.ToString());</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//75</span></span><br><span class="line"><span class="comment">//53.005</span></span><br><span class="line"><span class="comment">//2345.7652</span></span><br><span class="line"><span class="comment">//True</span></span><br></pre></td></tr></table></figure>

<h1 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h1><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202403211231239.png" alt="image-20240321123105179" style="zoom: 67%;" />

<h1 id="CSharp-foreach循环"><a href="#CSharp-foreach循环" class="headerlink" title="CSharp foreach循环"></a>CSharp foreach循环</h1><p>除了前面介绍的几种循环语句外，C# 同样也支持 foreach 循环，使用 foreach 可以遍历数组或者集合对象中的每一个元素，其语法格式如下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(数据类型 变量名 <span class="keyword">in</span> 数组或集合对象)&#123;</span><br><span class="line">    语句块;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="CSharp函数-方法"><a href="#CSharp函数-方法" class="headerlink" title="CSharp函数&#x2F;方法"></a>CSharp函数&#x2F;方法</h1><p>格式如下:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Access_Specifier Return_Type <span class="title">FunctionName</span>(<span class="params">Parameter List</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   Function_Body</span><br><span class="line">   Return_Statement</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//需要注意的是，访问权限修饰符是可以省略,省略后默认为private</span></span><br></pre></td></tr></table></figure>

<h2 id="静态函数"><a href="#静态函数" class="headerlink" title="静态函数"></a>静态函数</h2><p>C# 中的静态函数指的是，在一个类中使用 static 修饰的函数，调用静态函数比调用普通函数要简单很多，只需要函数名即可：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">helloworld</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Demo</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">string</span> msg = Output(<span class="string">&quot;http://helloworld/&quot;</span>);   <span class="comment">// 调用类中的静态函数</span></span><br><span class="line">            Console.WriteLine(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 定义一个函数，该函数可以接收一个字符串参数，</span></span><br><span class="line"><span class="comment">         * 并返回一个字符串</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="built_in">string</span> <span class="title">Output</span>(<span class="params"><span class="built_in">string</span> message</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">string</span> str = <span class="string">&quot;欢迎访问：&quot;</span> + message;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="CSharp封装"><a href="#CSharp封装" class="headerlink" title="CSharp封装"></a>CSharp封装</h1><p>C# 中的访问权限修饰符有以下几种：</p>
<ul>
<li>public：公共的，所有对象都可以访问，但是需要引用命名空间；</li>
<li>private：私有的，类的内部才可以访问；</li>
<li>internal：内部的，同一个程序集的对象可以访问，程序集就是命名空间；</li>
<li>protected：受保护的，类的内部或类的父类和子类中可以访问；</li>
<li>Protected internal：protected 和 internal 的并集，符合任意一条都可以访问。</li>
</ul>
<h1 id="CSharp值传递-引用传递-输出传递"><a href="#CSharp值传递-引用传递-输出传递" class="headerlink" title="CSharp值传递,引用传递,输出传递"></a>CSharp值传递,引用传递,输出传递</h1><table>
<thead>
<tr>
<th>方式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>值传递</td>
<td>值传递会复制参数的实际值并赋值给函数的形式参数，实参和形参使用的是两个不同内存位置中的值，当形参的值发生改变时，不会影响实参的值，从而保证了实参数据的安全</td>
</tr>
<tr>
<td>引用传递</td>
<td>引用传递会复制参数的内存位置并传递给形式参数，当形参的值发生改变时，同时也会改变实参的值</td>
</tr>
<tr>
<td>输出传递</td>
<td>输出传递可以一次返回多个值</td>
</tr>
</tbody></table>
<h2 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h2><p>在 C# 中，需要使用 <code>ref</code> 关键字来使用引用传递</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Func</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span> val</span>)</span>&#123;</span><br><span class="line">            val *= val;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;函数内部的值：&#123;0&#125;&quot;</span>, val);</span><br><span class="line">        &#125;</span><br><span class="line">Obj.Func(<span class="keyword">ref</span> val);</span><br></pre></td></tr></table></figure>

<h2 id="输出传递"><a href="#输出传递" class="headerlink" title="输出传递"></a>输出传递</h2><p>使用 return 语句可以从函数中返回一个值，但是使用输出传递则可以从函数中一次性返回多个值。输出传递与引用传递相似，不同之处在于输出传递是将数据从函数中传输出来而不是传输到函数中。</p>
<p>在 C# 中，需要使用 <code>out</code> 关键字来使用输出传递，下面通过示例来演示一下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getValue</span>(<span class="params"><span class="keyword">out</span> <span class="built_in">int</span> x</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">int</span> temp = <span class="number">11</span>;</span><br><span class="line">            x = temp;</span><br><span class="line">            x *= x;</span><br><span class="line">        &#125;</span><br><span class="line"> Obj.getValue(<span class="keyword">out</span> val);</span><br></pre></td></tr></table></figure>

<h1 id="CSharp-Array数组"><a href="#CSharp-Array数组" class="headerlink" title="CSharp Array数组"></a>CSharp Array数组</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] array1 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">10</span>]                <span class="comment">// 初始化一个长度为 10 的整型数组</span></span><br><span class="line"><span class="built_in">double</span>[] array2 = <span class="keyword">new</span> <span class="built_in">double</span>[<span class="number">5</span>]    <span class="comment">// 初始化一个长度为 5 的浮点型数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不指定长度赋值</span></span><br><span class="line"><span class="built_in">double</span>[] arr1 = &#123;<span class="number">96.5</span>, <span class="number">98.0</span>, <span class="number">99.5</span>, <span class="number">90.0</span>&#125;;</span><br><span class="line"><span class="built_in">int</span>[] arr2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="built_in">double</span>[] arr1 = <span class="keyword">new</span> <span class="built_in">double</span>[]&#123;<span class="number">96.5</span>, <span class="number">98.0</span>, <span class="number">99.5</span>, <span class="number">90.0</span>&#125;;</span><br><span class="line"><span class="built_in">int</span>[] arr2 = <span class="keyword">new</span> <span class="built_in">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">//指定长度赋值</span></span><br><span class="line"><span class="built_in">double</span>[] arr1 = <span class="keyword">new</span> <span class="built_in">double</span>[<span class="number">4</span>]&#123;<span class="number">96.5</span>, <span class="number">98.0</span>, <span class="number">99.5</span>, <span class="number">90.0</span>&#125;;</span><br><span class="line"><span class="built_in">int</span>[] arr2 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">10</span>]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p>可以使用<code>arr[i, j]</code>的形式来访问二维数组中的每个元素，其中 arr 为数组的名称，而 i 和 j 则是数组元素的索引，类似于表格中的行和列。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化二维数组</span></span><br><span class="line"><span class="comment">// 第一种方式</span></span><br><span class="line"><span class="built_in">int</span>[,] arr = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>,<span class="number">4</span>]&#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;,</span><br><span class="line">    &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 第二种方式</span></span><br><span class="line"><span class="built_in">int</span>[,] arr = <span class="keyword">new</span> <span class="built_in">int</span>[,]&#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;,</span><br><span class="line">    &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 第三种方式</span></span><br><span class="line"><span class="built_in">int</span>[,] arr = &#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;,</span><br><span class="line">    &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问二维数组中的元素</span></span><br><span class="line"><span class="built_in">int</span> a = arr[<span class="number">1</span>, <span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<h2 id="交错数组"><a href="#交错数组" class="headerlink" title="交错数组"></a>交错数组</h2><p>C# 中的交错数组其实就是<strong>元素为数组的数组</strong>，换句话说就是交错数组中的每个元素都可以是维度和大小不同的数组，所以有时交错数组也被称为“数组的数组”。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义并初始化</span></span><br><span class="line"><span class="built_in">int</span>[][] jaggedArray = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>][]; <span class="comment">// 定义一个交错数组</span></span><br><span class="line">jaggedArray[<span class="number">0</span>] = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>];        <span class="comment">// 对数组的第一个元素初始化</span></span><br><span class="line">jaggedArray[<span class="number">1</span>] = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">4</span>];        <span class="comment">// 对数组的第二个元素初始化</span></span><br><span class="line">jaggedArray[<span class="number">2</span>] = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">2</span>];        <span class="comment">// 对数组的第三个元素初始化</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span>[][] jaggedArray = <span class="keyword">new</span> <span class="built_in">int</span>[][]&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;,</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">int</span>[] &#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;,</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">int</span>[] &#123;<span class="number">10</span>, <span class="number">11</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//还可以简写为:</span></span><br><span class="line"><span class="built_in">int</span>[][] jaggedArray = &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;,</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">int</span>[] &#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;,</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">int</span>[] &#123;<span class="number">10</span>, <span class="number">11</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>定义一个交错数组,并遍历数组中的内容</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">helloworld</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Demo</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">int</span>[][] arr = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>][]&#123;  </span><br><span class="line">                <span class="keyword">new</span> <span class="built_in">int</span>[]&#123;<span class="number">31</span>, <span class="number">22</span>, <span class="number">16</span>, <span class="number">88</span>&#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="built_in">int</span>[]&#123;<span class="number">21</span>, <span class="number">54</span>, <span class="number">6</span>, <span class="number">77</span>, <span class="number">98</span>, <span class="number">52</span>&#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="built_in">int</span>[]&#123;<span class="number">112</span>, <span class="number">25</span>&#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">// 遍历数组</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; arr[i].Length; j++)&#123;</span><br><span class="line">                    Console.Write(arr[i][j]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                Console.WriteLine();</span><br><span class="line">            &#125;</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="交错数组和多维数组"><a href="#交错数组和多维数组" class="headerlink" title="交错数组和多维数组"></a>交错数组和多维数组</h2><p>交错数组中的元素不仅可以是一维数组，还可以是多维数组，例如下面的代码中定义了一个包含三个二维数组元素的一维交错数组：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[][,] jaggedArray = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>][,]</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">int</span>[,] &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">int</span>[,] &#123;</span><br><span class="line">        &#123;<span class="number">5</span>, <span class="number">8</span>&#125;,</span><br><span class="line">        &#123;<span class="number">13</span>, <span class="number">21</span>&#125;,</span><br><span class="line">        &#123;<span class="number">34</span>, <span class="number">55</span>&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">int</span>[,] &#123;</span><br><span class="line">        &#123;<span class="number">89</span>, <span class="number">144</span>&#125;,</span><br><span class="line">        &#123;<span class="number">233</span>, <span class="number">377</span>&#125;,</span><br><span class="line">        &#123;<span class="number">610</span>, <span class="number">987</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//访问</span></span><br><span class="line"><span class="built_in">int</span> a = jaggedArray[<span class="number">1</span>][<span class="number">1</span>,<span class="number">1</span>]     <span class="comment">// 变量 a 的值为 21</span></span><br><span class="line"><span class="built_in">int</span> b = jaggedArray[<span class="number">2</span>][<span class="number">0</span>,<span class="number">0</span>]     <span class="comment">// 变量 b 的值为 89</span></span><br></pre></td></tr></table></figure>

<h2 id="参数数组"><a href="#参数数组" class="headerlink" title="参数数组"></a>参数数组</h2><p>某些情况下，在定义函数时可能并不能提前确定参数的数量，这时可以使用 C# 提供的参数数组，参数数组通常用于为函数传递未知数量的参数。</p>
<p>若要使用参数数组，则需要利用 <code>params</code> 关键字，语法格式如下：</p>
<p><code>访问权限修饰符 返回值类型 函数名(params 类型名称[] 数组名称)</code></p>
<blockquote>
<p>使用参数数组时，既可以直接为函数传递一个数组作为参数，也可以使用<code>函数名(参数1, 参数2, ..., 参数n)</code>的形式传递若干个具体的值作为参数。</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">getSum</span>(<span class="params"><span class="keyword">params</span> <span class="built_in">int</span>[] arr</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">string</span> str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">foreach</span>(<span class="built_in">int</span> i <span class="keyword">in</span> arr)&#123;</span><br><span class="line">                sum += i;</span><br><span class="line">                str += <span class="string">&quot;+ &quot;</span> + i + <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            str = str.Trim(<span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">            str += <span class="string">&quot;= &quot;</span>+sum;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//调用方式1</span></span><br><span class="line"><span class="built_in">string</span> str = Obj.getSum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line"><span class="comment">//调用方式2</span></span><br><span class="line"><span class="built_in">int</span>[] arr = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>&#125;;</span><br><span class="line"><span class="built_in">string</span> str2 = Obj.getSum(arr);</span><br></pre></td></tr></table></figure>

<h2 id="CSharp-Array类"><a href="#CSharp-Array类" class="headerlink" title="CSharp Array类"></a>CSharp Array类</h2><p>Array 类是 C# 中所有数组的基类，其中提供了一系列用来处理数组的操作，例如对数组元素进行排序、搜索数组中指定的元素等。</p>
<p>Array 类中提供了一系列属性，通过这些属性可以获取数组的各种信息。Array 类中的常用属性如下表所示：</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>IsFixedSize</td>
<td>检查数组是否具有固定大小</td>
</tr>
<tr>
<td>IsReadOnly</td>
<td>检查数组是否为只读</td>
</tr>
<tr>
<td>IsSynchronized</td>
<td>检查是否同步对数组的访问（线程安全）</td>
</tr>
<tr>
<td>Length</td>
<td>获取数组中<strong>所有维度中元素的总数</strong></td>
</tr>
<tr>
<td>LongLength</td>
<td>获取数组中所有维数中元素的总数，并返回一个 64 位整数</td>
</tr>
<tr>
<td>Rank</td>
<td>获取数组的秩（维数），例如一维数组返回 1，二维数组返回 2，依次类推</td>
</tr>
<tr>
<td>SyncRoot</td>
<td>用来<strong>获取一个对象，该对象可以用于同步对数组的访问</strong></td>
</tr>
</tbody></table>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Clear(Array, Int32, Int32)</td>
<td>将数组中指定范围内的元素设置为该元素所属类型的默认值</td>
</tr>
<tr>
<td>Copy(Array, Array, Int32)</td>
<td>从第一个元素开始拷贝数组中指定长度的元素，并将其粘贴到另一个数组中（从第一个元素开始粘贴），使用 32 位整数来指定要拷贝的长度</td>
</tr>
<tr>
<td>CopyTo(Array, Int32)</td>
<td>从指定的目标数组索引处开始，将当前一维数组的所有元素复制到指定的一维数组中，索引使用 32 位整数指定</td>
</tr>
<tr>
<td>GetLength</td>
<td>获取数组指定维度中的元素数，并返回一个 32 位整数</td>
</tr>
<tr>
<td>GetLongLength</td>
<td>获取数组指定维度中的元素数，并返回一个 64 位整数</td>
</tr>
<tr>
<td>GetLowerBound</td>
<td>获取数组中指定维度第一个元素的索引</td>
</tr>
<tr>
<td>GetType</td>
<td>获取当前实例的类型（继承自 Object ）</td>
</tr>
<tr>
<td>GetUpperBound</td>
<td>获取数组中指定维度最后一个元素的索引</td>
</tr>
<tr>
<td>GetValue(Int32)</td>
<td>获取一维数组中指定位置的值</td>
</tr>
<tr>
<td>IndexOf(Array, Object)</td>
<td>在一个一维数组中搜索指定对象，并返回其首个匹配项的索引</td>
</tr>
<tr>
<td>Reverse(Array)</td>
<td>反转整个一维数组中元素的顺序</td>
</tr>
<tr>
<td>SetValue(Object, Int32)</td>
<td>设置一维数组中指定元素的值</td>
</tr>
<tr>
<td>Sort(Array)</td>
<td>对一维数组中的元素排序</td>
</tr>
<tr>
<td>ToString()</td>
<td>返回一个表示当前对象的字符串（继承自 Object）</td>
</tr>
</tbody></table>
<p>如果想要了解有关 Array 类中的属性和方法的详细介绍，可以查阅 C# 的<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/api/system.array?view=netcore-3.1#properties">官方文档</a>。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">helloworld</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Demo</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// 创建一个数组并赋值 </span></span><br><span class="line">            <span class="built_in">int</span>[] arr = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">6</span>] &#123;<span class="number">15</span>, <span class="number">33</span>, <span class="number">29</span>, <span class="number">55</span>, <span class="number">10</span>, <span class="number">11</span> &#125;; </span><br><span class="line">            <span class="comment">// 创建一个空数组</span></span><br><span class="line">            <span class="built_in">int</span>[] arr2 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">6</span>]; </span><br><span class="line">            <span class="comment">// 获取数组的长度</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;数组 arr 的长度为：&quot;</span>+arr.Length); </span><br><span class="line">            <span class="comment">// 为数组排序</span></span><br><span class="line">            Array.Sort(arr); </span><br><span class="line">            Console.Write(<span class="string">&quot;排序后的数组 arr 为：&quot;</span>); </span><br><span class="line">            <span class="comment">// 打印排序后的 arr</span></span><br><span class="line">            PrintArray(arr); </span><br><span class="line">            <span class="comment">// 查找数组元素的索引</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;\n数组 arr 中值为 29 的元素的索引为：&quot;</span>+Array.IndexOf(arr,<span class="number">29</span>)); </span><br><span class="line">            <span class="comment">// 拷贝 arr 到 arr2 </span></span><br><span class="line">            Array.Copy(arr, arr2, arr.Length); </span><br><span class="line">            Console.Write(<span class="string">&quot;打印数组 arr2：&quot;</span>); </span><br><span class="line">            <span class="comment">// 打印数组 arr2 </span></span><br><span class="line">            PrintArray(arr2); </span><br><span class="line">            Array.Reverse(arr); </span><br><span class="line">            Console.Write(<span class="string">&quot;\n反序排列数组 arr： &quot;</span>); </span><br><span class="line">            PrintArray(arr); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 遍历数组元素</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintArray</span>(<span class="params"><span class="built_in">int</span>[] arr</span>)</span> </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">foreach</span> (Object elem <span class="keyword">in</span> arr) </span><br><span class="line">            &#123; </span><br><span class="line">                Console.Write(elem+<span class="string">&quot; &quot;</span>); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="CSharp-String字符串"><a href="#CSharp-String字符串" class="headerlink" title="CSharp String字符串"></a>CSharp String字符串</h1><p>在 C# 中，string（或 String）关键字是 System.String 类的别名，其中提供了定义字符串以及操作字符串的一系列方法，下面就来详细介绍一下。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 System.String.Empty 定义一个空字符串</span></span><br><span class="line"><span class="built_in">string</span> str2 = System.String.Empty;</span><br></pre></td></tr></table></figure>

<h2 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h2><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Chars[Int32]</td>
<td>获取指定字符在字符串中的位置</td>
</tr>
<tr>
<td>Length</td>
<td>获取当前 String 对象中的字符数（字符串的长度）</td>
</tr>
</tbody></table>
<h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Clone()</td>
<td>返回对此 String 实例的引用</td>
</tr>
<tr>
<td>Compare(String, String)</td>
<td>比较两个指定的 String 对象，并返回一个指示二者在排序顺序中的相对位置的整数</td>
</tr>
<tr>
<td>CompareOrdinal(String, String)</td>
<td>通过比较每个字符串中的字符，来比较两个字符串是否相等</td>
</tr>
<tr>
<td>CompareTo(String)</td>
<td>将一个字符串与另一个字符串进行比较</td>
</tr>
<tr>
<td>Concat(String, String)</td>
<td>连接两个指定的字符串</td>
</tr>
<tr>
<td>Contains(String)</td>
<td>判断一个字符串中是否包含零一个字符串</td>
</tr>
<tr>
<td>Copy(String)</td>
<td>将字符串的值复制一份，并赋值给另一个字符串</td>
</tr>
<tr>
<td>CopyTo(Int32, Char[], Int32, Int32)</td>
<td>从字符串中复制指定数量的字符到一个字符数组中</td>
</tr>
<tr>
<td>EndsWith(String)</td>
<td>用来判断字符串是否以指定的字符串结尾</td>
</tr>
<tr>
<td>Equals(String, String)</td>
<td>判断两个字符串是否相等</td>
</tr>
<tr>
<td>Format(String, Object)</td>
<td>将字符串格式化为指定的字符串表示形式</td>
</tr>
<tr>
<td>GetEnumerator()</td>
<td>返回一个可以循环访问此字符串中的每个字符的对象</td>
</tr>
<tr>
<td>GetHashCode()</td>
<td>返回该字符串的哈希代码</td>
</tr>
<tr>
<td>GetType()</td>
<td>获取当前实例的类型</td>
</tr>
<tr>
<td>GetTypeCode()</td>
<td>返回字符串的类型代码</td>
</tr>
<tr>
<td>IndexOf(String)</td>
<td>返回字符在字符串中的首次出现的索引位置，索引从零开始</td>
</tr>
<tr>
<td>Insert(Int32, String)</td>
<td>在字符串的指定位置插入另一个字符串，并返回新形成的字符串</td>
</tr>
<tr>
<td>Intern(String)</td>
<td>返回指定字符串的内存地址(返回的是引用)</td>
</tr>
<tr>
<td>IsInterned(String)</td>
<td>返回指定字符串的内存地址(返回的是<a href="#CSharp%E5%8F%AF%E7%A9%BA%E7%B1%BB%E5%9E%8B">可能为空</a>的引用)</td>
</tr>
<tr>
<td>IsNormalized()</td>
<td>判断此字符串是否符合 Unicode 标准</td>
</tr>
<tr>
<td>IsNullOrEmpty(String)</td>
<td>判断指定的字符串是否为空（null）或空字符串（””）</td>
</tr>
<tr>
<td>IsNullOrWhiteSpace(String)</td>
<td>判断指定的字符串是否为 null、空或仅由空白字符组成</td>
</tr>
<tr>
<td>Join(String, String[])</td>
<td>串联字符串数组中的所有元素，并将每个元素使用指定的分隔符分隔开</td>
</tr>
<tr>
<td>LastIndexOf(Char)</td>
<td>获取某个字符在字符串中最后一次出现的位置</td>
</tr>
<tr>
<td>LastIndexOfAny(Char[])</td>
<td>获取一个或多个字符在字符串中最后一次出现的位置</td>
</tr>
<tr>
<td>Normalize()</td>
<td>返回一个新字符串，新字符串与原字符串的值相等，但其二进制表示形式符合 Unicode 标准</td>
</tr>
<tr>
<td>PadLeft(Int32)</td>
<td>返回一个指定长度的新字符串，新字符串通过在原字符串左侧填充空格来达到指定的长度，从而实现右对齐</td>
</tr>
<tr>
<td>PadRight(Int32)</td>
<td>返回一个指定长度的新字符串，新字符串通过在原字符串右侧填充空格来达到指定的长度，从而实现左对齐</td>
</tr>
<tr>
<td>Remove(Int32)</td>
<td>返回一个指定长度的新字符串，将字符串中超出长度以外的部分全部删除</td>
</tr>
<tr>
<td>Replace(String, String)</td>
<td>使用指定字符替换字符串中的某个字符，并返回新形成的字符串</td>
</tr>
<tr>
<td>Split(Char[])</td>
<td>按照某个分隔符将一个字符串拆分成一个<a href="#ArrayList%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84">字符串数组</a>,返回分割后的字符串数组</td>
</tr>
<tr>
<td>StartsWith(String)</td>
<td>判断字符串是否使用指定的字符串开头</td>
</tr>
<tr>
<td>Substring(Int32)</td>
<td>从指定的位置截取字符串</td>
</tr>
<tr>
<td>ToCharArray()</td>
<td>将字符串中的字符复制到 Unicode 字符数组</td>
</tr>
<tr>
<td>ToLower()</td>
<td>将字符串中的字母转换为小写的形式</td>
</tr>
<tr>
<td>ToLowerInvariant()</td>
<td>使用固定区域性的大小写规则将字符串转换为小写的形式</td>
</tr>
<tr>
<td>ToString()</td>
<td>将其它数据类型转换为字符串类型</td>
</tr>
<tr>
<td>ToUpper()</td>
<td>将字符串中的字母转换为大写形式</td>
</tr>
<tr>
<td>Trim()</td>
<td>删除字符串首尾的空白字符</td>
</tr>
<tr>
<td>TrimEnd(Char[])</td>
<td>删除字符串尾部的空白字符</td>
</tr>
<tr>
<td>TrimStart(Char[])</td>
<td>删除字符串首部的空白字符</td>
</tr>
</tbody></table>
<p>上表中只列举了一些 String 类中常用方法，可以通过查阅 C# 的<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/api/system.string?view=netcore-3.1#methods">官方文档</a>来了解 String 类中的全部的方法介绍。</p>
<h1 id="CSharp-struct结构体"><a href="#CSharp-struct结构体" class="headerlink" title="CSharp struct结构体"></a>CSharp struct结构体</h1><p>在 C# 中，结构体也被称为结构类型（“structure type”或“struct type”），它是一种可封装数据和相关功能的值类型，在语法上结构体与类（class）非常相似，它们都可以用来封装数据，并且都可以包含成员属性和成员方法。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Books &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> title;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> author;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> subject;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> book_id;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在设计结构体时有以下几点需要注意：</p>
<ul>
<li>不能为结构体声明无参数的构造函数，因为每个结构体中都已经默认创建了一个隐式的、无参数的构造函数；</li>
<li>不能在声明成员属性时对它们进行初始化，静态属性和常量除外；</li>
<li>结构体的构造函数必须初始化该结构体中的所有成员属性；</li>
<li>结构体不能从其他类或结构体中继承，也不能作为类的基础类型，但是结构类型可以实现接口；</li>
<li>不能在结构体中声明析构函数。</li>
</ul>
<p><strong>C# 中的结构体与 C&#x2F;C++ 中的结构体有很大的不同</strong>，在 C# 中结构体具有以下功能：</p>
<ul>
<li>结构体中可以具有方法、字段、索引、属性、运算符方法和事件；</li>
<li>结构体中可以定义构造函数，但不能定义析构函数，需要注意的是，定义的构造函数不能没有参数，因为<strong>没有参数的构造函数是 C# 默认自动定义的，而且不能更改</strong>；</li>
<li>与类不同，结构体不能继承其他结构体或类；</li>
<li>结构体不能用作其他结构体或类的基础结构；</li>
<li>一种结构体可以实现一个或多个接口；</li>
<li><strong>结构体成员不能被设定为 abstract、virtual 或 protected；</strong></li>
<li>与类不同，结构体可以不用 New 操作符来实例化，当使用 New 操作符来实例化结构体时会自动调用结构体中的构造函数；</li>
<li>如果不使用 New 操作符来实例化结构体，结构体对象中的字段将保持未分配状态，并且在所有字段初始化之前无法使用该结构体实例。</li>
</ul>
<p><strong>类和结构体的主要区别</strong>：</p>
<ul>
<li>类是引用类型，结构体是值类型；</li>
<li>结构体不支持继承，但可以实现接口；</li>
<li>结构体中不能声明默认的构造函数。</li>
</ul>
<blockquote>
<p><strong>类是引用类型，结构体是值类型；</strong></p>
<p>在C#中，结构体是值类型，意味着当你创建一个结构体的实例时，实际上在内存中存储的是该实例的实际数据。当你将一个结构体赋值给另一个变量或作为参数传递时，会复制整个结构体的数据。相比之下，类是引用类型，意味着当你创建一个类的实例时，内存中存储的是对该实例的引用，而不是实际数据。当你将一个类的实例赋值给另一个变量或作为参数传递时，实际上是传递了对同一个对象的引用，而不是对象的副本。</p>
</blockquote>
<h1 id="CSharp-enum枚举类型"><a href="#CSharp-enum枚举类型" class="headerlink" title="CSharp enum枚举类型"></a>CSharp enum枚举类型</h1><p>枚举类型（也可以称为“枚举器”）由一组具有独立标识符（名称）的整数类型常量构成，在 C# 中枚举类型不仅可以在类或结构体的内部声明，也可以在类或结构体的外部声明，默认情况下枚举类型中成员的默认值是从 0 开始的，然后逐一递增。</p>
<p>在 C# 中可以使用 enum 关键字来声明枚举类型，语法格式如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> enum_name&#123;</span><br><span class="line">  enumeration list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用枚举类型时有以下几点需要注意：</p>
<ul>
<li>枚举类型中不能定义方法；</li>
<li>枚举类型具有固定的常量集；</li>
<li>枚举类型可提高类型的安全性；</li>
<li>枚举类型可以遍历。</li>
</ul>
<p>默认情况下，枚举类型中的每个成员都为 int 类型，它们的值从零开始，并按定义顺序依次递增。但是也可以显式的为每个枚举类型的成员赋值，如下所示</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> ErrorCode</span><br><span class="line">&#123;</span><br><span class="line">    None,</span><br><span class="line">    Unknown,</span><br><span class="line">    ConnectionLost = <span class="number">100</span>,</span><br><span class="line">    OutlierReading = <span class="number">200</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>遍历枚举</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用 GetValues()  遍历枚举类型中的所有成员：</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">helloworld</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Demo</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">enum</span> Season &#123;</span><br><span class="line">            winter = <span class="number">10</span>,</span><br><span class="line">            spring,</span><br><span class="line">            summer = <span class="number">15</span>,</span><br><span class="line">            autumn</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span>(Season i <span class="keyword">in</span> Enum.GetValues(<span class="keyword">typeof</span>(Season)))&#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;&#123;0&#125; = &#123;1&#125;&quot;</span>, i, (<span class="built_in">int</span>)i);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//winter = 10</span></span><br><span class="line"><span class="comment">//spring = 11</span></span><br><span class="line"><span class="comment">//summer = 15</span></span><br><span class="line"><span class="comment">//autumn = 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 GetNames() 遍历枚举类型中的所有成员：</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">helloworld</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Demo</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">enum</span> Season &#123;</span><br><span class="line">            winter = <span class="number">10</span>,</span><br><span class="line">            spring,</span><br><span class="line">            summer = <span class="number">15</span>,</span><br><span class="line">            autumn</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span>(String s <span class="keyword">in</span> Enum.GetNames(<span class="keyword">typeof</span>(Season)))&#123;</span><br><span class="line">                Console.WriteLine(s);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//winter</span></span><br><span class="line"><span class="comment">//spring</span></span><br><span class="line"><span class="comment">//summer</span></span><br><span class="line"><span class="comment">//autumn</span></span><br></pre></td></tr></table></figure>

<h1 id="CSharp-class类"><a href="#CSharp-class类" class="headerlink" title="CSharp class类"></a>CSharp class类</h1><p>类的定义语法格式:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;access specifier&gt; <span class="keyword">class</span> <span class="title">class_name</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 成员属性</span></span><br><span class="line">    &lt;access specifier&gt; &lt;data type&gt; variable1;</span><br><span class="line">    &lt;access specifier&gt; &lt;data type&gt; variable2;</span><br><span class="line">    ...</span><br><span class="line">    &lt;access specifier&gt; &lt;data type&gt; variableN;</span><br><span class="line">    <span class="comment">// 成员函数/成员方法</span></span><br><span class="line">    &lt;access specifier&gt; &lt;<span class="keyword">return</span> type&gt; method1(parameter_list)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 函数体</span></span><br><span class="line">    &#125;</span><br><span class="line">    &lt;access specifier&gt; &lt;<span class="keyword">return</span> type&gt; method2(parameter_list)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 函数体</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    &lt;access specifier&gt; &lt;<span class="keyword">return</span> type&gt; methodN(parameter_list)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 函数体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>语法说明如下：</p>
<ul>
<li><code>&lt;access specifier&gt;</code> 为访问权限修饰符，用来指定类或类中成员的访问规则，可以忽略不写，如果没有指定，则使用默认的访问权限修饰符，类的默认访问权限修饰符是 internal，类中成员的默认访问权限修饰符是 private；</li>
<li><code>class_name</code> 为类的名称；</li>
<li><code>&lt;data type&gt;</code> 为数据类型，用来指定成员属性的数据类型；</li>
<li><code>variable1、variable2</code> 等为成员属性的名称，类似于变量名；</li>
<li><code>&lt;return type&gt;</code> 为返回值类型，用来指定成员函数的返回值类型；</li>
<li><code>method1、method2</code> 等为成员函数的名称。</li>
</ul>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>类和对象是不同的概念，类决定了对象的类型，但不是对象本身。另外，类是在开发阶段创建的，而对象则是在程序运行期间创建的。可以将对象看作是基于类创建的实体，所以对象也可以称为类的实例。</p>
<p>想要创建一个类的实例需要使用 new 关键字: </p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Student Object = <span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line"><span class="comment">//类是引用类型</span></span><br><span class="line"><span class="comment">//虽然也可以像创建普通变量那样只创建一个 Student 类型的变量，而不使用 new 关键字实例化 Student 这个类</span></span><br><span class="line">Student Object2;</span><br><span class="line"><span class="comment">//不过不建议使用这样的写法，因为此时的 Object2 只是一个 Student 类型的普通变量，它并没有被赋值，所以不能使用 Object2 来访问对象中的属性和方法。如果非要使用 Object2 的话，则可以将一个已经创建的对象赋值给它</span></span><br><span class="line">Student Object3 = <span class="keyword">new</span> Student();</span><br><span class="line">Student Object2 = Object3;</span><br><span class="line"><span class="comment">//Object2 和 Object3 指向同一个 Student 对象，因此使用 Object3 对 Student 对象的任何操作也会影响到 Object2</span></span><br></pre></td></tr></table></figure>

<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>C# 中的构造函数有三种：</p>
<ul>
<li>实例构造函数；</li>
<li>静态构造函数；</li>
<li>私有构造函数。</li>
</ul>
<h3 id="实例构造函数"><a href="#实例构造函数" class="headerlink" title="实例构造函数"></a>实例构造函数</h3><p>构造函数是类中特殊的成员函数，它的名称与它所在类的名称相同，并且没有返回值。当使用 new 关键字创建类的对象时，可以使用实例构造函数来创建和初始化类中的任意成员属性</p>
<p>只要创建 Person 类的对象，就会调用类中的实例构造函数</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> n, <span class="built_in">int</span> a</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        name = n;</span><br><span class="line">        age = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 类中剩余的成员</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用类中的实例构造函数</span></span><br><span class="line">Person P = <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>);</span><br></pre></td></tr></table></figure>

<p>如果没有为类显式的创建构造函数，那么 C# 将会为这个类隐式的创建一个没有参数的构造函数（无参数构造函数），这个无参的构造函数会在实例化对象时为类中的成员属性设置默认值（关于 C# 中类型的默认值可以查阅《<a href="#%E5%80%BC%E7%B1%BB%E5%9E%8B">值类型</a>》一节）。在结构体中也是如此，如果没有为结构体创建构造函数，那么 C# 将隐式的创建一个无参数的构造函数，用来将每个字段初始化为其默认值。</p>
<h3 id="静态构造函数"><a href="#静态构造函数" class="headerlink" title="静态构造函数"></a>静态构造函数</h3><p>静态构造函数用于初始化类中的静态数据或执行仅需执行一次的特定操作。静态构造函数将在<strong>创建第一个实例或引用类中的静态成员之前自动调用</strong></p>
<p>静态构造函数具有以下特性：</p>
<ul>
<li>静态构造函数不使用访问权限修饰符修饰或不具有参数；</li>
<li>类或结构体中只能具有一个静态构造函数；</li>
<li>静态构造函数不能继承或重载；</li>
<li>静态构造函数不能直接调用，仅可以由公共语言运行时 (CLR) 调用；</li>
<li>用户无法控制程序中静态构造函数的执行时间；</li>
<li>在创建第一个实例或引用任何静态成员之前，将自动调用静态构造函数以初始化类；</li>
<li>静态构造函数会在实例构造函数之前运行。</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">helloworld</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Demo</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">        Demo()&#123;</span><br><span class="line">            num = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 静态构造函数</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="title">Demo</span>()</span>&#123;</span><br><span class="line">            num = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> </span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;num = &#123;0&#125;&quot;</span>, num);</span><br><span class="line">            Demo Obj = <span class="keyword">new</span> Demo();</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;num = &#123;0&#125;&quot;</span>, num);</span><br><span class="line">            Console.Read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当执行上面程序时，会首先执行public static int num = 0，接着执行类中的静态构造函数，此时 num = 2，然后执行 Main 函数里面的内容，此时打印 num 的值为 2，接着初始化 Demo 类，这时会执行类中的构造函数，此时 num 会重新赋值为 1，所以上例的运行结果如下所示：</span></span><br><span class="line"><span class="comment">//num = 2</span></span><br><span class="line"><span class="comment">//num = 1</span></span><br></pre></td></tr></table></figure>

<h3 id="私有构造函数"><a href="#私有构造函数" class="headerlink" title="私有构造函数"></a>私有构造函数</h3><p>私有构造函数是一种特殊的实例构造函数，<strong>通常用在只包含静态成员的类中</strong>。如果一个类中具有一个或多个私有构造函数而没有公共构造函数的话，那么其他类（除嵌套类外）则无法创建该类的实例。</p>
<blockquote>
<p>对于一些类并不需要实例化就用这种方式防止实例化</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">NLog</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">NLog</span>()</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">double</span> e = Math.E;  <span class="comment">//2.71828...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上例中定义了一个空的私有构造函数，这么做的好处就是空构造函数可阻止自动生成无参数构造函数。需要注意的是，如果不对构造函数使用访问权限修饰符，则默认它为私有构造函数。</p>
<h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>与《<a href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">构造函数</a>》类似，C# 中的析构函数（也被称作“终结器”）同样是类中的一个特殊成员函数，主要用于在垃圾回收器回收类实例时执行一些必要的清理操作。</p>
<p>C# 中的析构函数具有以下特点：</p>
<ul>
<li>析构函数只能在类中定义，不能用于结构体；</li>
<li>一个类中只能定义一个析构函数；</li>
<li>析构函数不能继承或重载；</li>
<li>析构函数没有返回值；</li>
<li>析构函数是自动调用的，不能手动调用；</li>
<li>析构函数不能使用访问权限修饰符修饰，也不能包含参数。</li>
</ul>
<p>析构函数的名称同样与类名相同，不过需要在名称的前面加上一个波浪号<code>~</code>作为前缀，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Car</span></span><br><span class="line">&#123;</span><br><span class="line">  ~Car() <span class="comment">// 析构函数</span></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：<strong>析构函数不能对外公开</strong>，所以我们不能在析构函数上应用任何访问权限修饰符。</p>
<h2 id="CSharp-this关键字"><a href="#CSharp-this关键字" class="headerlink" title="CSharp this关键字"></a>CSharp this关键字</h2><p> C# 中，可以使用 this 关键字来表示当前对象，日常开发中我们可以使用 this 关键字来访问类中的成员属性以及函数。不仅如此 this 关键字还有一些其它的用法</p>
<ol>
<li><p>使用 this 表示当前类的对象</p>
</li>
<li><p>使用 this 关键字串联构造函数</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Test</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;无参构造函数&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里的 this()代表无参构造函数 Test()</span></span><br><span class="line">　　      <span class="comment">// 先执行 Test()，后执行 Test(string text)</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Test</span>(<span class="params"><span class="built_in">string</span> text</span>) : <span class="title">this</span>() <span class="comment">//此处</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(text);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;实例构造函数&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 this 关键字作为类的索引器</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以理解为c++重载operator[]函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> Temp0;</span><br><span class="line">        <span class="built_in">int</span> Temp1;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> <span class="keyword">this</span>[<span class="built_in">int</span> index]</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> (<span class="number">0</span> == index) ? Temp0 : Temp1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">set</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span>==index)</span><br><span class="line">                    Temp0 = <span class="keyword">value</span>;<span class="comment">//注意这个value也是关键字</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    Temp1 = <span class="keyword">value</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 this 关键字作为原始类型的扩展方法</p>
<blockquote>
<p>扩展方法是对现有类型功能的一种补充，但这种补充并非改变原始类型的行为，而是为它们添加新的行为，使其看起来像是类型本身就具有这些方法</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Demo</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> str = <span class="string">&quot;你好世界&quot;</span>;</span><br><span class="line">            <span class="built_in">string</span> newstr = str.ExpandString();<span class="comment">//调用拓展方法</span></span><br><span class="line">            Console.WriteLine(newstr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">ExpandString</span>(<span class="params"><span class="keyword">this</span> <span class="built_in">string</span> name</span>)<span class="comment">//定义给string类型的拓展方法</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> name+<span class="string">&quot; hello world&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//上述代码中,ExpandString是一个拓展方法,它拓展了string类型,使其看起来拥有将字符串转换为标题格式的功能.这里的`this string name`就表示这个方法是拓展string类型的,调用时如同直接在`string`对象上调用该方法一样</span></span><br></pre></td></tr></table></figure>

<p>C#的扩展方法并<strong>不适用于原始类型</strong>，而是适用于任何用户自定义类型或.NET Framework内建的引用类型（如<code>string</code>）。原始类型如<code>int</code>、<code>double</code>等不支持扩展方法。</p>
</li>
</ol>
<h2 id="CSharp-静态成员"><a href="#CSharp-静态成员" class="headerlink" title="CSharp 静态成员"></a>CSharp 静态成员</h2><p>在 C# 中，我们可以使用 static 关键字声明属于类型本身而不是属于特定对象的静态成员，因此不需要使用对象来访问静态成员。在类、接口和结构体中可以使用 static 关键字修饰变量、函数、构造函数、类、属性、运算符和事件。</p>
<blockquote>
<p>注意：<strong>索引器和析构函数不能是静态的</strong>。</p>
</blockquote>
<p>若在定义某个成员时使用 static 关键字，则表示该类仅存在此成员的一个实例，也就是说当我们将一个类的成员声明为静态成员时，无论创建多少个该类的对象，静态成员只会被创建一次，这个静态成员会被所有对象共享。</p>
<h3 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h3><p>使用 static 定义的成员属性称为“静态属性”，静态属性可以直接通过<code>类名.属性名</code>的形式直接访问，不需要事先创建类的实例。静态属性不仅可以使用成员函数来初始化，还可以直接在类外进行初始化。</p>
<h3 id="静态函数-1"><a href="#静态函数-1" class="headerlink" title="静态函数"></a>静态函数</h3><p>除了可以定义静态属性外，static 关键字还可以用来定义成员函数，使用 static 定义的成员函数称为“静态函数”，静态函数只能访问静态属性</p>
<h3 id="CSharp-静态类"><a href="#CSharp-静态类" class="headerlink" title="CSharp 静态类"></a>CSharp 静态类</h3><p>C#中的静态类是一种特殊的类，它具备以下几个显著特征：</p>
<ol>
<li><strong>静态成员限定</strong>：静态类只能包含静态成员（字段、属性、方法、事件和嵌套类型），不能包含实例成员（非静态字段、非静态方法等）。这意味着你不能在静态类中定义构造函数，因为构造函数总是与实例关联的。</li>
<li><strong>不可实例化</strong>：由于静态类仅包含静态成员，所以不能使用<code>new</code>关键字创建该类的实例。也就是说，静态类不能有实例生命周期，因为它不是为了创建对象而设计的。</li>
<li><strong>静态构造函数</strong>：尽管静态类不能有实例构造函数，但可以有一个静态构造函数，它在第一次访问该类的任何静态成员之前自动调用，并且在整个程序中只调用一次。静态构造函数用于初始化静态类的静态数据成员或者执行必要的静态资源初始化。</li>
<li><strong>单一实例和全局可见性</strong>：静态类的所有成员都是全局共享的，意味着对静态成员的任何更改都会影响到整个应用程序的所有使用者。</li>
<li><strong>密封性</strong>：静态类在概念上类似于密封的抽象类，因为它既不能被继承也不能被实例化，仅仅作为一个组织相关静态成员的容器。</li>
<li><strong>编译时常量</strong>：静态类常用于封装与类层次结构无关的全局常量、工具方法或服务，这些内容在整个应用程序域中只需要一份拷贝即可。</li>
<li><strong>加载时机</strong>：.NET Framework公共语言运行库（CLR）会在加载包含静态类的程序集时自动加载此类及其成员。</li>
</ol>
<p>总结来说，C#静态类的主要目的是组织和管理那些不需要与类实例关联的、全局可用的功能和数据。</p>
<h2 id="CSharp-继承"><a href="#CSharp-继承" class="headerlink" title="CSharp 继承"></a>CSharp 继承</h2><p>C# 中只支持单继承，也就是说一个派生类只能继承一个基类</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 派生类 : 基类&#123;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>所有的C#类都隐式继承自<code>System.Object</code>类，该类提供了这些可以被子类重写的方法。</strong></p>
</blockquote>
<h3 id="CSharp-接口"><a href="#CSharp-接口" class="headerlink" title="CSharp 接口"></a>CSharp 接口</h3><blockquote>
<p>对应C++中的纯虚基类</p>
</blockquote>
<p>接口可以看作是一个约定，其中定义了类或结构体继承接口后需要实现功能，接口的特点如下所示：</p>
<ul>
<li>接口是一个引用类型，通过接口可以实现多重继承；</li>
<li>接口中只能声明”抽象”成员，所以不能直接对接口进行实例化；</li>
<li>接口中可以包含方法、属性、事件、索引器等成员；</li>
<li>接口名称一般习惯使用字母“I”作为开头（不是必须的，不这样声明也可以）；</li>
<li>接口中成员的访问权限默认为 public，所以我们在定义接口时不用再为接口成员指定任何访问权限修饰符，否则编译器会报错；</li>
<li>在声明接口成员的时候，不能为接口成员编写具体的可执行代码，也就是说，只要在定义成员时指明成员的名称和参数就可以了；</li>
<li>接口一旦被实现（被一个类继承），派生类就必须实现接口中的所有成员，除非派生类本身也是抽象类。</li>
</ul>
<p>在 C# 中声明接口需要使用 interface 关键字，语法结构如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">InterfaceName</span>&#123;</span><br><span class="line">  <span class="function">returnType <span class="title">funcName1</span>(<span class="params">type parameterList</span>)</span>;</span><br><span class="line">  <span class="function">returnType <span class="title">funcName2</span>(<span class="params">type parameterList</span>)</span>;</span><br><span class="line">  ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，InterfaceName 为接口名称，returnType 为返回值类型，funcName 为成员函数的名称，parameterList 为参数列表。</p>
<p>在 C# 中，一个接口可以继承另一个接口，例如可以使用接口 1 继承接口 2，当用某个类来实现接口 1 时，必须同时实现接口 1 和接口 2 中的所有成员，下面通过一个示例来演示一下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">helloworld</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IParentInterface</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">ParentInterfaceMethod</span>()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IMyInterface</span> : <span class="title">IParentInterface</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">MethodToImplement</span>()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Demo</span> : <span class="title">IMyInterface</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> </span><br><span class="line">        &#123;</span><br><span class="line">            Demo demo = <span class="keyword">new</span> Demo();</span><br><span class="line">            demo.MethodToImplement();</span><br><span class="line">            demo.ParentInterfaceMethod();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MethodToImplement</span>()</span>&#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;实现 IMyInterface 接口中的 MethodToImplement 函数&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ParentInterfaceMethod</span>()</span>&#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;实现 IParentInterface 接口中的 ParentInterfaceMethod 函数&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现 IMyInterface 接口中的 MethodToImplement 函数</span></span><br><span class="line"><span class="comment">//实现 IParentInterface 接口中的 ParentInterfaceMethod 函数</span></span><br></pre></td></tr></table></figure>

<h3 id="接口实现的多重继承"><a href="#接口实现的多重继承" class="headerlink" title="接口实现的多重继承"></a>接口实现的多重继承</h3><p>与单继承相反，多重继承则是指一个类可以同时继承多个基类，C# 并不支持多重继承，但是可以借助接口来实现多重继承</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">helloworld</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Demo</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> </span><br><span class="line">        &#123;</span><br><span class="line">            Rectangle oblong = <span class="keyword">new</span> Rectangle();</span><br><span class="line">            oblong.setWidth(<span class="number">3</span>);</span><br><span class="line">            oblong.setHeight(<span class="number">4</span>);</span><br><span class="line">            <span class="built_in">int</span> area = oblong.getArea();</span><br><span class="line">            <span class="built_in">int</span> girth = oblong.getGirth();</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;长方形的面积为：&#123;0&#125;&quot;</span>, area);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;长方形的周长为：&#123;0&#125;&quot;</span>, girth);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 基类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Shape</span>&#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="built_in">int</span> width, height;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWidth</span>(<span class="params"><span class="built_in">int</span> w</span>)</span>&#123;</span><br><span class="line">            width = w;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHeight</span>(<span class="params"><span class="built_in">int</span> h</span>)</span>&#123;</span><br><span class="line">            height = h;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Perimeter</span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">int</span> <span class="title">getGirth</span>()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 派生类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Rectangle</span> : <span class="title">Shape</span>, <span class="title">Perimeter</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">getArea</span>()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> width*height;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">getGirth</span>()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (width+height)*<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口实现的泛型数据结构实例"><a href="#接口实现的泛型数据结构实例" class="headerlink" title="接口实现的泛型数据结构实例"></a>接口实现的泛型数据结构实例</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;IEquipment&gt; equipmentList = <span class="keyword">new</span> List&lt;IEquipment&gt;();</span><br></pre></td></tr></table></figure>

<p>在C#中，接口是一种抽象类型，无法直接实例化。在这种情况下， <code>List&lt;IEquipment&gt; </code>并不是实例化了一个接口，而是实例化了一个<strong>泛型列表</strong>，该列表可以存储实现了 <code>IEquipment </code>接口的类的实例。因为接口可以被类实现，所以你可以将实现了 <code>IEquipment </code>接口的类的实例添加到 <code>equipmentList </code>。</p>
<p>但要注意:<strong>只有接口中定义的方法和属性才能被List对象访问</strong></p>
<h2 id="CSharp-多态"><a href="#CSharp-多态" class="headerlink" title="CSharp 多态"></a>CSharp 多态</h2><p>在 C# 中具有两种类型的多态：</p>
<ul>
<li>编译时多态：通过 C# 中的方法重载和运算符重载来实现编译时多态，也称为静态绑定或早期绑定；</li>
<li>运行时多态：通过方法重载实现的运行时多态，也称为动态绑定或后期绑定。</li>
</ul>
<h3 id="编译时多态"><a href="#编译时多态" class="headerlink" title="编译时多态"></a>编译时多态</h3><p>在编译期间将函数与对象链接的机制称为早期绑定，也称为静态绑定。C# 提供了两种技术来实现编译时多态，分别是函数重载和运算符重载</p>
<h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p>在同一个作用域中，可以定义多个同名的函数，但是这些函数彼此之间必须有所差异，比如参数个数不同或参数类型不同等等，<strong>返回值类型不同除外</strong>。</p>
<h4 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h4><p>C# 中支持运算符重载，所谓运算符重载就是我们可以使用自定义类型来重新定义 C# 中大多数运算符的功能。运算符重载需要通过 operator 关键字后跟运算符的形式来定义的，我们可以将被重新定义的运算符看作是具有特殊名称的函数，与其他函数一样，该函数也有返回值类型和参数列表，如下例所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重载 + 运算符，把两个 Box 对象相加</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Box <span class="keyword">operator</span>+ (Box b, Box c)</span><br><span class="line">&#123;</span><br><span class="line">        Box box = <span class="keyword">new</span> Box();</span><br><span class="line">     box.length = b.length + c.length;</span><br><span class="line">     box.breadth = b.breadth + c.breadth;</span><br><span class="line">     box.height = b.height + c.height;</span><br><span class="line">     <span class="keyword">return</span> box;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h5 id="可重载与不可重载的运算符"><a href="#可重载与不可重载的运算符" class="headerlink" title="可重载与不可重载的运算符"></a>可重载与不可重载的运算符</h5><table>
<thead>
<tr>
<th>运算符</th>
<th>可重载性</th>
</tr>
</thead>
<tbody><tr>
<td><code>+、-、!、~、++、--</code></td>
<td>这些一元运算符可以进行重载</td>
</tr>
<tr>
<td>&#96;+、-、*、&#x2F;、%、&amp;、</td>
<td>、^、&lt;&lt;、&gt;&gt;、&#x3D;、!&#x3D;、&lt;、&gt;、&lt;&#x3D;、&gt;&#x3D;&#96;</td>
</tr>
<tr>
<td><code>&amp;&amp;、</code></td>
<td></td>
</tr>
<tr>
<td><code>(type)var_name</code></td>
<td>强制类型转换运算符不能重载</td>
</tr>
<tr>
<td>&#96;+&#x3D;、-&#x3D;、*&#x3D;、&#x2F;&#x3D;、%&#x3D;、&amp;&#x3D;、</td>
<td>&#x3D;、^&#x3D;、&lt;&lt;&#x3D;、&gt;&gt;&#x3D;&#96;</td>
</tr>
<tr>
<td><code>^、=、.、?.、?  : 、??、??=、..、-&gt;、=&gt;、as、await、checked、unchecked、default、delegate、is、nameof、new、sizeof、stackalloc、switch、typeof</code></td>
<td>这些运算符无法进行重载</td>
</tr>
</tbody></table>
<blockquote>
<p>注意：比较运算符必须成对重载，也就是说，如果重载一对运算符中的任意一个，则另一个运算符也必须重载。比如<code>==</code>和<code>!=</code>运算符、<code>&lt;</code>和<code>&gt;</code>运算符、<code>&lt;=</code>和<code>&gt;=</code>运算符。</p>
</blockquote>
<p>演示如下:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">helloworld</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Box</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">double</span> length;      <span class="comment">// 长度</span></span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">double</span> breadth;     <span class="comment">// 宽度</span></span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">double</span> height;      <span class="comment">// 高度</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">getVolume</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> length * breadth * height;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLength</span>(<span class="params"> <span class="built_in">double</span> len </span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            length = len;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBreadth</span>(<span class="params"> <span class="built_in">double</span> bre </span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            breadth = bre;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHeight</span>(<span class="params"> <span class="built_in">double</span> hei </span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            height = hei;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重载 + 运算符来把两个 Box 对象相加</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Box <span class="keyword">operator</span>+ (Box b, Box c)</span><br><span class="line">        &#123;</span><br><span class="line">            Box box = <span class="keyword">new</span> Box();</span><br><span class="line">            box.length = b.length + c.length;</span><br><span class="line">            box.breadth = b.breadth + c.breadth;</span><br><span class="line">            box.height = b.height + c.height;</span><br><span class="line">            <span class="keyword">return</span> box;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="keyword">operator</span>== (Box lhs, Box rhs)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">bool</span> status = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (lhs.length == rhs.length &amp;&amp; lhs.height == rhs.height &amp;&amp; lhs.breadth == rhs.breadth)</span><br><span class="line">            &#123;</span><br><span class="line">                status = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> status;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="keyword">operator</span>!= (Box lhs, Box rhs)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">bool</span> status = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (lhs.length != rhs.length || lhs.height != rhs.height || lhs.breadth != rhs.breadth)</span><br><span class="line">            &#123;</span><br><span class="line">                status = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> status;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> <span class="title">Equals</span>(<span class="params"><span class="built_in">object</span> o</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(o==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(GetType() != o.GetType()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">int</span> <span class="title">GetHashCode</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">base</span>.GetHashCode();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="keyword">operator</span> &lt;(Box lhs, Box rhs)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">bool</span> status = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (lhs.length &lt; rhs.length &amp;&amp; lhs.height &lt; rhs.height &amp;&amp; lhs.breadth &lt; rhs.breadth)</span><br><span class="line">            &#123;</span><br><span class="line">                status = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> status;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="keyword">operator</span> &gt;(Box lhs, Box rhs)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">bool</span> status = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (lhs.length &gt; rhs.length &amp;&amp; lhs.height &gt; rhs.height &amp;&amp; lhs.breadth &gt; rhs.breadth)</span><br><span class="line">            &#123;</span><br><span class="line">                status = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> status;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="keyword">operator</span> &lt;=(Box lhs, Box rhs)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">bool</span> status = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (lhs.length &lt;= rhs.length &amp;&amp; lhs.height &lt;= rhs.height &amp;&amp; lhs.breadth &lt;= rhs.breadth)</span><br><span class="line">            &#123;</span><br><span class="line">                status = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> status;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="keyword">operator</span> &gt;=(Box lhs, Box rhs)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">bool</span> status = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (lhs.length &gt;= rhs.length &amp;&amp; lhs.height &gt;= rhs.height &amp;&amp; lhs.breadth &gt;= rhs.breadth)</span><br><span class="line">            &#123;</span><br><span class="line">                status = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> status;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> String.Format(<span class="string">&quot;(&#123;0&#125;, &#123;1&#125;, &#123;2&#125;)&quot;</span>, length, breadth, height);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Demo</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> </span><br><span class="line">        &#123;</span><br><span class="line">            Box Box1 = <span class="keyword">new</span> Box();          <span class="comment">// 声明 Box1，类型为 Box</span></span><br><span class="line">            Box Box2 = <span class="keyword">new</span> Box();          <span class="comment">// 声明 Box2，类型为 Box</span></span><br><span class="line">            Box Box3 = <span class="keyword">new</span> Box();          <span class="comment">// 声明 Box3，类型为 Box</span></span><br><span class="line">            Box Box4 = <span class="keyword">new</span> Box();</span><br><span class="line">            <span class="built_in">double</span> volume = <span class="number">0.0</span>;   <span class="comment">// 体积</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Box1 详述</span></span><br><span class="line">            Box1.setLength(<span class="number">6.0</span>);</span><br><span class="line">            Box1.setBreadth(<span class="number">7.0</span>);</span><br><span class="line">            Box1.setHeight(<span class="number">5.0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Box2 详述</span></span><br><span class="line">            Box2.setLength(<span class="number">12.0</span>);</span><br><span class="line">            Box2.setBreadth(<span class="number">13.0</span>);</span><br><span class="line">            Box2.setHeight(<span class="number">10.0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用重载的 ToString() 显示两个盒子</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Box1： &#123;0&#125;&quot;</span>, Box1.ToString());</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Box2： &#123;0&#125;&quot;</span>, Box2.ToString());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Box1 的体积</span></span><br><span class="line">            volume = Box1.getVolume();</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Box1 的体积： &#123;0&#125;&quot;</span>, volume);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Box2 的体积</span></span><br><span class="line">            volume = Box2.getVolume();</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Box2 的体积： &#123;0&#125;&quot;</span>, volume);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 把两个对象相加</span></span><br><span class="line">            Box3 = Box1 + Box2;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Box3： &#123;0&#125;&quot;</span>, Box3.ToString());</span><br><span class="line">            <span class="comment">// Box3 的体积</span></span><br><span class="line">            volume = Box3.getVolume();</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Box3 的体积： &#123;0&#125;&quot;</span>, volume);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//comparing the boxes</span></span><br><span class="line">            <span class="keyword">if</span> (Box1 &gt; Box2)</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Box1 大于 Box2&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Box1 不大于 Box2&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (Box1 &lt; Box2)</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Box1 小于 Box2&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Box1 不小于 Box2&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (Box1 &gt;= Box2)</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Box1 大于等于 Box2&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Box1 不大于等于 Box2&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (Box1 &lt;= Box2)</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Box1 小于等于 Box2&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Box1 不小于等于 Box2&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (Box1 != Box2)</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Box1 不等于 Box2&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Box1 等于 Box2&quot;</span>);</span><br><span class="line">            Box4 = Box3;</span><br><span class="line">            <span class="keyword">if</span> (Box3 == Box4)</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Box3 等于 Box4&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Box3 不等于 Box4&quot;</span>);</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Box1： (6, 7, 5)</span></span><br><span class="line"><span class="comment">//Box2： (12, 13, 10)</span></span><br><span class="line"><span class="comment">//Box1 的体积： 210</span></span><br><span class="line"><span class="comment">//Box2 的体积： 1560</span></span><br><span class="line"><span class="comment">//Box3： (18, 20, 15)</span></span><br><span class="line"><span class="comment">//Box3 的体积： 5400</span></span><br><span class="line"><span class="comment">//Box1 不大于 Box2</span></span><br><span class="line"><span class="comment">//Box1 小于 Box2</span></span><br><span class="line"><span class="comment">//Box1 不大于等于 Box2</span></span><br><span class="line"><span class="comment">//Box1 小于等于 Box2</span></span><br><span class="line"><span class="comment">//Box1 不等于 Box2</span></span><br><span class="line"><span class="comment">//Box3 等于 Box4 等于 Box4</span></span><br></pre></td></tr></table></figure>

<h3 id="运行时多态"><a href="#运行时多态" class="headerlink" title="运行时多态"></a>运行时多态</h3><h4 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h4><p>C# 允许您使用 abstract 关键字来创建抽象类，抽象类用于实现部分接口。另外，抽象类包含抽象方法，可以在派生类中实现。</p>
<p>下面列举了一些有关抽象类的规则：</p>
<ul>
<li>不能创建一个抽象类的实例；</li>
<li>不能在一个抽象类外部声明抽象方法；</li>
<li>通过在类定义时使用 sealed 关键字，可以将类声明为密封类，密封类不能被继承，因此抽象类中不能声明密封类。</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">helloworld</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Shape</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">int</span> <span class="title">area</span>()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Rectangle</span> : <span class="title">Shape</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">int</span> width, height;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span>(<span class="params"><span class="built_in">int</span> w, <span class="built_in">int</span> h</span>)</span>&#123;</span><br><span class="line">            width = w;</span><br><span class="line">            height = h;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">int</span> <span class="title">area</span>()</span>&#123;<span class="comment">//覆写抽象类中的抽象方法</span></span><br><span class="line">            <span class="keyword">return</span> (width * height);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Demo</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> </span><br><span class="line">        &#123;          </span><br><span class="line">              Shape r = <span class="keyword">new</span> Rectangle(<span class="number">12</span>,<span class="number">15</span>);</span><br><span class="line">            <span class="comment">//Rectangle r = new Rectangle(12,15); //都可以</span></span><br><span class="line">            <span class="built_in">double</span> a = r.area();</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;长方形的面积为： &#123;0&#125;&quot;</span>,a);</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果如下:</span></span><br><span class="line"><span class="comment">//长方形的面积为： 180</span></span><br></pre></td></tr></table></figure>

<h4 id="virtual"><a href="#virtual" class="headerlink" title="virtual"></a>virtual</h4><p>C#的运行时多态也通过virtual实现</p>
<p>virtual的几个特点</p>
<p>1、声明了virtual的方法无需去改动类的声明，他只在此方法上起到影响。(与abstract不同,如果一个类中包含抽象成员函数，那么这个类必须被声明为抽象类)</p>
<p>2、只有virtual的方法可以被子类override。</p>
<p>3、子类可以不override父类的virtual方法，这种情况下他就像普通的父类方法一样。</p>
<h4 id="virtual与abstract的区别"><a href="#virtual与abstract的区别" class="headerlink" title="virtual与abstract的区别"></a>virtual与abstract的区别</h4><ul>
<li><strong>抽象类不可以直接实例化，他可以有n个（n&gt;&#x3D;0）抽象方法，这些抽象方法子类必须实现(强制)</strong></li>
<li><strong>virtual关键字就是告诉子类，此方法可以被override，但非强制</strong></li>
</ul>
<h4 id="virtual在接口和抽象类中"><a href="#virtual在接口和抽象类中" class="headerlink" title="virtual在接口和抽象类中"></a>virtual在接口和抽象类中</h4><ul>
<li>在接口中，所有成员都默认是公共的抽象成员，不包含任何实现，因此不能使用virtual关键字定义虚拟方法。</li>
<li>在抽象类中，抽象方法（abstract method）是用来强制子类实现的，而虚拟方法（virtual method）是可以在抽象类中提供默认实现的方法。因此，抽象类中可以使用virtual关键字定义虚拟方法，但不需要使用abstract关键字。</li>
</ul>
<h3 id="CSharp与C-多态对比"><a href="#CSharp与C-多态对比" class="headerlink" title="CSharp与C++多态对比"></a>CSharp与C++多态对比</h3><p>Charp支持<a href="#abstract">abstract</a>,支持<a href="#virtual">virtual</a>,支持[interface](#CSharp 接口),支持抽象类</p>
<p>C++支持所有类的多重继承,首先这点CSharp就不支持,CSharp中仅接口可以支持多重继承</p>
<p>概念对照</p>
<table>
<thead>
<tr>
<th>C++</th>
<th>CSharp</th>
<th>主要功能</th>
</tr>
</thead>
<tbody><tr>
<td>[[C++基础#纯虚函数和抽象类|纯虚函数]]</td>
<td>抽象函数</td>
<td>必须被重写</td>
</tr>
<tr>
<td>[[C++基础#多态|virtual]]</td>
<td>virtual</td>
<td>不重写则调用父类虚函数</td>
</tr>
<tr>
<td>[[C++基础#纯虚函数和抽象类|抽象类(包含一个纯虚函数就是抽象类)]]</td>
<td>抽象类</td>
<td></td>
</tr>
<tr>
<td>全是纯虚函数的抽象类</td>
<td>接口</td>
<td></td>
</tr>
</tbody></table>
<p>对应关系大致符合上表,但还有不同: </p>
<ul>
<li><strong>C#中普通方法不能被重写,只有抽象或虚方法可以被重写.</strong></li>
<li><strong>C++中普通函数也能被重定义,抽象或虚方法也可以被重写.</strong></li>
</ul>
<p><strong>override注意点</strong></p>
<ul>
<li>C# 中，如果你想要重写基类中的虚方法（<code>virtual</code> 方法）或抽象方法（<code>abstract</code> 方法），<code>override</code> 关键字是必写的</li>
<li>C++中,override只是个标志,增加可读性,可写可不写都能重写父类</li>
</ul>
<h3 id="对接口和抽象类的理解"><a href="#对接口和抽象类的理解" class="headerlink" title="对接口和抽象类的理解"></a>对接口和抽象类的理解</h3><p>接口虽然不可以被实例化,但是接口引用可以指向1个实现该接口的对象.</p>
<p>若A实现了接口B,可以:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口引用实现了他的实例</span></span><br><span class="line">B b = <span class="keyword">new</span> A();</span><br><span class="line"><span class="comment">//也可以把A的对象强制转换为 接口B的对象</span></span><br><span class="line">A a = <span class="keyword">new</span> A();</span><br><span class="line">B b = (B)a;</span><br></pre></td></tr></table></figure>

<h4 id="什么情况下应该使用接口而不用抽象类"><a href="#什么情况下应该使用接口而不用抽象类" class="headerlink" title="什么情况下应该使用接口而不用抽象类"></a>什么情况下应该使用接口而不用抽象类</h4><p>总的来说，如果你需要定义一组应该被多个不相关的类实现的行为，或者需要多重继承的特性，接口是更好的选择。如果你的目标是共享代码或定义一个明确的“是一个”（is-a）继承结构，并且需要包含状态或属性，那么抽象类可能是更好的选择。</p>
<p>在实际开发中，经常会同时使用接口和抽象类。接口定义行为的契约，而抽象类提供部分实现。理解它们各自的优势和用途，可以帮助你做出更合适的设计选择。</p>
<h1 id="CSharp-namespace：命名空间"><a href="#CSharp-namespace：命名空间" class="headerlink" title="CSharp namespace：命名空间"></a>CSharp namespace：命名空间</h1><p>在 C# 中，可以将命名空间看作是一个范围，用来标注命名空间中成员的归属，一个命名空间中类与另一个命名空间中同名的类互不冲突，但在同一个命名空间中类的名称必须是唯一的。</p>
<blockquote>
<p>在一个简单的 C# 程序中，假如我们要输出某些数据，就需要使用<code>System.Console.WriteLine()</code>，其中 System 就是命名空间，而 Console 是类的名字，WriteLine 则是具体要使用方法。也就是说，如果要访问某个命名空间中的类，我们需要使用<code>namespacename.classname.funcname()</code>的形式。当然也可以使用 using 关键字来引用需要的命名空间，例如<code>using System</code>，这样我们就可以直接使用<code>Console.WriteLine()</code>来输出指定的数据了。</p>
</blockquote>
<p>在 C# 中定义命名空间需要使用 namespace 关键字，语法格式如下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">namespaceName</span>&#123;</span><br><span class="line">    <span class="comment">// 命名空间中的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用指定命名空间下的成员,需要使用</span></span><br><span class="line">namespaceName.className.funcName()</span><br></pre></td></tr></table></figure>

<h3 id="using关键字"><a href="#using关键字" class="headerlink" title="using关键字"></a>using关键字</h3><p>using 关键字用来引用指定的命名空间，它可以告诉编译器后面的代码中我们需要用到某个命名空间。例如我们在程序中需要使用到 System 命名空间，只需要在程序的开始使用<code>using System</code>引用该命名空间即可，这时我们在使用 System 命名空间下的类时就可以将<code>System.</code>省略，例如<code>Console.WriteLine();</code>。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> First;</span><br><span class="line"><span class="keyword">using</span> Second;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">helloworld</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Demo</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> </span><br><span class="line">        &#123;</span><br><span class="line">            firstClass first = <span class="keyword">new</span> firstClass();</span><br><span class="line">            secondClass second = <span class="keyword">new</span> secondClass();</span><br><span class="line">            first.sayHello();<span class="comment">//签名相同的函数,要指明哪个命名空间中的函数</span></span><br><span class="line">            second.sayHello();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">First</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">firstClass</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span>()</span>&#123;</span><br><span class="line">            System.Console.WriteLine(<span class="string">&quot;First 命名空间下 demoClass 类中的 sayHello 函数&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Second</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">secondClass</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span>()</span>&#123;</span><br><span class="line">            System.Console.WriteLine(<span class="string">&quot;Second 命名空间下 demoClass 类中的 sayHello 函数&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>命名空间可以嵌套使用，也就是说我们可以在一个命名空间中再定义一个或几个命名空间，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">namespaceName1</span>&#123;</span><br><span class="line">  <span class="comment">// namespaceName1 下的代码</span></span><br><span class="line">  <span class="keyword">namespace</span> <span class="title">namespaceName2</span>&#123;</span><br><span class="line">    <span class="comment">// namespaceName2 下的代码</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您可以使用点<code>.</code>运算符来访问嵌套的命名空间成员，例如<code>namespaceName1.namespaceName2</code></p>
<h1 id="CSharp-预处理器指令"><a href="#CSharp-预处理器指令" class="headerlink" title="CSharp 预处理器指令"></a>CSharp 预处理器指令</h1><p>预处理指令的作用主要是向编译器发出指令，以便在程序编译开始之前对信息进行一些预处理操作。在 C# 中，预处理器指令均以<code>#</code>开头，并且预处理器指令之前只能出现空格不能出现任何代码。另外，预处理器指令不是语句，因此它们不需要以分号<code>;</code>结尾。</p>
<p>在 C# 中，预处理指令用于帮助条件编译。<strong>不同于 C 和 C++ 中的指令，在 C# 中不能使用这些指令来创建宏</strong>，而且预处理器指令必须是一行中唯一的代码，不能掺杂其它。</p>
<h2 id="CSharp-中的预处理器指令"><a href="#CSharp-中的预处理器指令" class="headerlink" title="CSharp 中的预处理器指令"></a>CSharp 中的预处理器指令</h2><table>
<thead>
<tr>
<th>预处理器指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>#define</td>
<td>用于定义一系列字符，可以将这些字符称为符号</td>
</tr>
<tr>
<td>#undef</td>
<td>用于取消一个已定义符号</td>
</tr>
<tr>
<td>#if</td>
<td>用于测试符号是否为真</td>
</tr>
<tr>
<td>#else</td>
<td>用于创建复合条件指令，与 #if 一起使用</td>
</tr>
<tr>
<td>#elif</td>
<td>用于创建复合条件指令</td>
</tr>
<tr>
<td>#endif</td>
<td>指定一个条件指令的结束</td>
</tr>
<tr>
<td>#line</td>
<td>用于修改编译器的行数以及（可选地）输出错误和警告的文件名</td>
</tr>
<tr>
<td>#error</td>
<td>用于在代码的指定位置生成一个错误</td>
</tr>
<tr>
<td>#warning</td>
<td>用于在代码的指定位置生成一级警告</td>
</tr>
<tr>
<td>#region</td>
<td>用于在使用 Visual Studio Code Editor 的大纲特性时，指定一个可展开或折叠的代码块</td>
</tr>
<tr>
<td>#endregion</td>
<td>用于标识 #region 块的结束</td>
</tr>
</tbody></table>
<h2 id="define-预处理器"><a href="#define-预处理器" class="headerlink" title="#define 预处理器"></a>#define 预处理器</h2><p>#define 预处理器指令用来创建符号常量，这个符号可以作为传递给 #if 指令的表达式，表达式将返回 true。#define 的语法格式如下：</p>
<p><code>#define symbol</code></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">helloworld</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Demo</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">#<span class="keyword">if</span> (PI)</span></span><br><span class="line">                Console.WriteLine(<span class="string">&quot;PI 已定义&quot;</span>);</span><br><span class="line">            <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">                Console.WriteLine(<span class="string">&quot;PI 未定义&quot;</span>);</span><br><span class="line">            <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//PI 已定义</span></span><br></pre></td></tr></table></figure>

<h2 id="条件指令"><a href="#条件指令" class="headerlink" title="条件指令"></a>条件指令</h2><p>您可以使用 #if 来创建条件指令，条件指令可以用于测试一个或多个符号的值是否为 true 。如果符号的值为 true，那么编译器将评估 #if 指令和下一个指令之间的所有代码。在语法上 #if 预处理器语句与 C# 中的 if 条件判断语句比较相似，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> symbol_1</span></span><br><span class="line">    <span class="comment">// 要执行的代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> symbol_2</span></span><br><span class="line">    <span class="comment">// 要执行的代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">// 要执行的代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">//symbol 是要测试的符号的名称</span></span><br></pre></td></tr></table></figure>

<p>条件指令中仅可以使用运算符<code>==</code>（相等）和<code>!=</code>（不相等）来测试布尔值 true 或 false，例如 true 表示已定义该符号。另外，还可以使用<code>&amp;&amp; (and)</code>、<code>|| (or)</code>和<code>! (not)</code>运算符来同时测试多个符号，以及使用括号对符号和运算符分组。</p>
<h1 id="CSharp-正则表达式"><a href="#CSharp-正则表达式" class="headerlink" title="CSharp 正则表达式"></a>CSharp 正则表达式</h1><blockquote>
<p>正则表达式是一种匹配输入文本的模式，可以用于解析和验证给定文本以及模式之间是否匹配，模式可以包含运算符、字符字面值或结构。</p>
</blockquote>
<p>参考[[正则表达式]]</p>
<h2 id="Regex类"><a href="#Regex类" class="headerlink" title="Regex类"></a>Regex类</h2><p>Regex 类用于使用一个正则表达式，下表中列出了 Regex 类中一些常用的方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>public bool IsMatch( string input )</code></td>
<td>指示 Regex 构造函数中指定的正则表达式是否在指定的输入字符串中找到匹配项</td>
</tr>
<tr>
<td><code>public bool IsMatch( string input, int startat )</code></td>
<td>指示 Regex 构造函数中指定的正则表达式是否在指定的输入字符串中找到匹配项，从字符串中指定的位置开始查找</td>
</tr>
<tr>
<td><code>public static bool IsMatch( string input, string pattern )</code></td>
<td>指示指定的正则表达式是否在指定的输入字符串中找到匹配项</td>
</tr>
<tr>
<td><code>public MatchCollection Matches( string input )</code></td>
<td>在指定的输入字符串中搜索正则表达式的所有匹配项</td>
</tr>
<tr>
<td><code>public string Replace( string input, string replacement )</code></td>
<td>在指定的输入字符串中，把所有匹配正则表达式模式的所有匹配的字符串替换为指定的替换字符串</td>
</tr>
<tr>
<td><code>public string[] Split( string input )</code></td>
<td>把输入字符串分割为子字符串数组，根据在 Regex 构造函数中指定的正则表达式模式定义的位置进行分割</td>
</tr>
</tbody></table>
<h1 id="CSharp-异常"><a href="#CSharp-异常" class="headerlink" title="CSharp 异常"></a>CSharp 异常</h1><p>在 C# 中，异常是在程序运行出错时引发的，例如以一个数字除以零，所有异常都派生自 System.Exception 类。异常处理则是处理运行时错误的过程，使用异常处理可以使程序在发生错误时保持正常运行。</p>
<p>C# 中的异常处理基于四个关键字构建，分别是 try、catch、finally 和 throw。</p>
<ul>
<li><p>try：try 语句块中通常用来存放容易出现异常的代码，其后面紧跟一个或多个 catch 语句块；</p>
</li>
<li><p>catch：catch 语句块用来捕获 try 语句块中的出现的异常；</p>
</li>
<li><p>finally：finally 语句块用于执行特定的语句，不管异常是否被抛出都会执行；**只要跳出try块一定会被执行到!**try内中途return也会被执行到</p>
<blockquote>
<p>在 C# 中，<code>finally</code> 块的主要作用是确保无论 <code>try</code> 块中的代码是否抛出异常，或者是否在 <code>try</code> 块中执行了 <code>return</code> 语句，<code>finally</code> 块中的代码都会被执行。这使得 <code>finally</code> 块非常适合用于清理资源，比如关闭文件、释放网络连接或释放数据库连接等。</p>
</blockquote>
</li>
<li><p>throw：throw 用来抛出一个异常。</p>
</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">   <span class="comment">// 引起异常的语句</span></span><br><span class="line">&#125;<span class="keyword">catch</span>( ExceptionName e1 )&#123;</span><br><span class="line">   <span class="comment">// 错误处理代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>( ExceptionName e2 )&#123;</span><br><span class="line">   <span class="comment">// 错误处理代码</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">catch</span>( ExceptionName eN )&#123;</span><br><span class="line">   <span class="comment">// 错误处理代码</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">   <span class="comment">// 要执行的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CSharp中的异常类"><a href="#CSharp中的异常类" class="headerlink" title="CSharp中的异常类"></a>CSharp中的异常类</h2><p>C# 中的异常类主要是从 System.Exception 类派生的，比如 System.ApplicationException 和 System.SystemException 两个异常类就是从 System.Exception 类派生的。</p>
<ul>
<li>System.ApplicationException 类支持由程序产生的异常，因此我们自定义的异常都应继承此类；</li>
<li>System.SystemException 类是所有系统预定义异常的基类。</li>
</ul>
<p>下表中列举了一些从 Sytem.SystemException 类派生的预定义异常类：</p>
<table>
<thead>
<tr>
<th>异常类</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>System.IO.IOException</td>
<td>处理 I&#x2F;O 错误</td>
</tr>
<tr>
<td>System.IndexOutOfRangeException</td>
<td>处理当方法引用超出范围的数组索引时产生的错误</td>
</tr>
<tr>
<td>System.ArrayTypeMismatchException</td>
<td>处理当数组类型不匹配时产生的错误</td>
</tr>
<tr>
<td>System.NullReferenceException</td>
<td>处理引用一个空对象时产生的错误</td>
</tr>
<tr>
<td>System.DivideByZeroException</td>
<td>处理当除以零时产生的错误</td>
</tr>
<tr>
<td>System.InvalidCastException</td>
<td>处理在类型转换期间产生的错误</td>
</tr>
<tr>
<td>System.OutOfMemoryException</td>
<td>处理空闲内存不足产生的错误</td>
</tr>
<tr>
<td>System.StackOverflowException</td>
<td>处理栈溢出产生的错误</td>
</tr>
</tbody></table>
<h2 id="自定义异常类"><a href="#自定义异常类" class="headerlink" title="自定义异常类"></a>自定义异常类</h2><p>除了可以使用系统预定义的异常类外，我们还可以自行定义异常类，自定义的异常类都应继承 System.ApplicationException 类。下面通过示例来演示一下自定义异常类的使用：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">helloworld</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Demo</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> </span><br><span class="line">        &#123;</span><br><span class="line">            TestUserDefinedException test = <span class="keyword">new</span> TestUserDefinedException();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                test.validate(<span class="number">12</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(InvalidAgeException e)&#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;InvalidAgeException: &#123;0&#125;&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;其它代码&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">InvalidAgeException</span> : <span class="title">ApplicationException</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">InvalidAgeException</span> (<span class="params"><span class="built_in">string</span> message</span>): <span class="title">base</span>(<span class="params">message</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestUserDefinedException</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validate</span>(<span class="params"><span class="built_in">int</span> age</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">if</span>(age &lt; <span class="number">18</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">throw</span> (<span class="keyword">new</span> InvalidAgeException(<span class="string">&quot;Sorry, Age must be greater than 18&quot;</span>));</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//InvalidAgeException: InvalidAgeException: Sorry, Age must be greater than 18</span></span><br><span class="line"><span class="comment">//   在 TestUserDefinedException.validate(Int32 age)</span></span><br><span class="line"><span class="comment">//   在 helloworld.Demo.Main(String[] args)</span></span><br><span class="line"><span class="comment">//其它代码</span></span><br></pre></td></tr></table></figure>

<h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><p>如果异常是直接或间接派生自 System.Exception 类，则可以在 catch 语句块中使用 throw 语句抛出该异常，所谓抛出异常这里可以理解为重新引发该异常。throw 语句的语法格式如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">catch</span>(Exception e) &#123;</span><br><span class="line">  ...</span><br><span class="line">  Throw e</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异常调用堆栈理解"><a href="#异常调用堆栈理解" class="headerlink" title="异常调用堆栈理解"></a>异常调用堆栈理解</h2><p><code>--- End of stack trace from previous location ---</code> 的作用是：</p>
<ul>
<li><p><strong>分隔符</strong>：它表示在此行之前的调用堆栈信息是来自于一个不同的上下文或调用路径。也就是说，当前的异常可能是由之前的一些操作引发的，但这些操作是在不同的上下文中进行的。</p>
</li>
<li><p><strong>上下文切换的指示</strong>：这条消息提醒开发者，异常的发生与之前的调用堆栈（即在这条消息之前的调用）是分开的。它帮助开发者理解，异常并不是在当前线程的上下文中直接引发的，而是可能与其他线程或异步操作有关。</p>
</li>
</ul>
<h1 id="CSharp-文件读写"><a href="#CSharp-文件读写" class="headerlink" title="CSharp 文件读写"></a>CSharp 文件读写</h1><blockquote>
<p>文件是存储在磁盘中的具有特定名称和目录路径的数据集合，当我们使用程序对文件进行读取或写入时，程序会将文件以数据流（简称流）的形式读入内存中。我们可以将流看作是通过通信路径传递的字节序列，流主要分为输入流和输出流，输入流主要用于从文件读取数据（读操作），输出流主要用于向文件中写入数据（写操作）。</p>
</blockquote>
<h2 id="CSharp-中的-I-O-类"><a href="#CSharp-中的-I-O-类" class="headerlink" title="CSharp 中的 I&#x2F;O 类"></a>CSharp 中的 I&#x2F;O 类</h2><p>System.IO 命名空间中包含了各种用于文件操作的类，例如文件的创建、删除、读取、写入等等。如下表中所示：</p>
<table>
<thead>
<tr>
<th>I&#x2F;O 类</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>BinaryReader</td>
<td>从二进制流中读取原始数据</td>
</tr>
<tr>
<td>BinaryWriter</td>
<td>以二进制格式写入原始数据</td>
</tr>
<tr>
<td>BufferedStream</td>
<td>临时存储字节流</td>
</tr>
<tr>
<td>Directory</td>
<td>对目录进行复制、移动、重命名、创建和删除等操作</td>
</tr>
<tr>
<td>DirectoryInfo</td>
<td>用于对目录执行操作</td>
</tr>
<tr>
<td>DriveInfo</td>
<td>获取驱动器的信息</td>
</tr>
<tr>
<td>File</td>
<td>对文件进行操作</td>
</tr>
<tr>
<td>FileInfo</td>
<td>用于对文件执行操作</td>
</tr>
<tr>
<td>FileStream</td>
<td>用于文件中任何位置的读写</td>
</tr>
<tr>
<td>MemoryStream</td>
<td>用于随机访问存储在内存中的数据流</td>
</tr>
<tr>
<td>Path</td>
<td>对路径信息执行操作</td>
</tr>
<tr>
<td>StreamReader</td>
<td>用于从字节流中读取字符</td>
</tr>
<tr>
<td>StreamWriter</td>
<td>用于向一个流中写入字符</td>
</tr>
<tr>
<td>StringReader</td>
<td>用于从字符串缓冲区读取数据</td>
</tr>
<tr>
<td>StringWriter</td>
<td>用于向字符串缓冲区写入数据</td>
</tr>
</tbody></table>
<h2 id="FileStream-类"><a href="#FileStream-类" class="headerlink" title="FileStream 类"></a>FileStream 类</h2><p>FileStream 类在 System.IO 命名空间下，使用它可以读取、写入和关闭文件。创建 FileStream 类对象的语法格式如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FileStream &lt;object_name&gt; = <span class="keyword">new</span> FileStream(&lt;file_name&gt;, &lt;FileMode Enumerator&gt;, &lt;FileAccess Enumerator&gt;, &lt;FileShare Enumerator&gt;);</span><br><span class="line"><span class="comment">//例子:</span></span><br><span class="line">FileStream F = <span class="keyword">new</span> FileStream(<span class="string">&quot;sample.txt&quot;</span>, FileMode.Open, FileAccess.Read, FileShare.Read);</span><br></pre></td></tr></table></figure>

<p>参数说明如下：</p>
<ul>
<li>object_name：创建的对象名称；</li>
<li>file_name：文件的路径（包含文件名在内）；</li>
<li>FileMode：枚举类型，用来设定文件的打开方式，可选值如下：<ul>
<li>Append：打开一个已有的文件，并将光标放置在文件的末尾。如果文件不存在，则创建文件；</li>
<li>Create：创建一个新的文件，如果文件已存在，则将旧文件删除，然后创建新文件；</li>
<li>CreateNew：创建一个新的文件，如果文件已存在，则抛出异常；</li>
<li>Open：打开一个已有的文件，如果文件不存在，则抛出异常；</li>
<li>OpenOrCreate：打开一个已有的文件，如果文件不存在，则创建一个新的文件并打开；</li>
<li>Truncate：打开一个已有的文件，然后将文件清空（删除原有内容），如果文件不存在，则抛出异常。</li>
</ul>
</li>
<li>FileAccess：枚举类型，用来<strong>设置文件的存取</strong>，可选值有 Read、ReadWrite 和 Write；</li>
<li>FileShare：枚举类型，用来<strong>设置文件的权限</strong>，可选值如下：<ul>
<li>Inheritable：允许子进程继承文件句柄，Win32 不直接支持此功能；</li>
<li>None：在文件关闭前拒绝共享当前文件，打开该文件的任何请求（由此进程或另一进程发出的请求）都将失败；</li>
<li>Read：允许随后打开文件读取，如果未指定此标志，则文件关闭前，任何打开该文件以进行读取的请求都将失败，需要注意的是，即使指定了此标志，仍需要附加权限才能够访问该文件；</li>
<li>ReadWrite：允许随后打开文件读取或写入，如果未指定此标志，则文件关闭前，任何打开该文件以进行读取或写入的请求都将失败，需要注意的是，即使指定了此标志，仍需要附加权限才能够访问该文件；</li>
<li>Write：允许随后打开文件写入，如果未指定此标志，则文件关闭前，任何打开该文件以进行写入的请求都将失败，需要注意的是，即使指定了此标志，仍可能需要附加权限才能够访问该文件；</li>
<li>Delete：允许随后删除文件。</li>
</ul>
</li>
</ul>
<h3 id="FileStream-类中的常用方法"><a href="#FileStream-类中的常用方法" class="headerlink" title="FileStream 类中的常用方法"></a>FileStream 类中的常用方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Close()</td>
<td>关闭当前流并释放与之关联的所有资源（如套接字和文件句柄）</td>
</tr>
<tr>
<td>CopyTo(Stream)</td>
<td>从当前流中读取字节并将其写入到另一流中</td>
</tr>
<tr>
<td>Dispose()</td>
<td>释放由 Stream 使用的所有资源</td>
</tr>
<tr>
<td>Equals(Object)</td>
<td>判断指定对象是否等于当前对象</td>
</tr>
<tr>
<td>Finalize()</td>
<td>确保垃圾回收器回收 FileStream 时释放资源并执行其他清理操作</td>
</tr>
<tr>
<td>Flush()</td>
<td>清除此流的缓冲区，使得所有缓冲数据都写入到文件中</td>
</tr>
<tr>
<td>GetHashCode()</td>
<td>默认哈希函数</td>
</tr>
<tr>
<td>GetType()</td>
<td>获取当前实例的 Type</td>
</tr>
<tr>
<td>Lock(Int64, Int64)</td>
<td>防止其他进程读取或写入 FileStream</td>
</tr>
<tr>
<td>Read(Byte[], Int32, Int32)</td>
<td>从流中读取字节块并将该数据写入给定缓冲区中</td>
</tr>
<tr>
<td>ReadByte()</td>
<td>从文件中读取一个字节，并将读取位置提升一个字节</td>
</tr>
<tr>
<td>ToString()</td>
<td>返回表示当前对象的字符串</td>
</tr>
<tr>
<td>Unlock(Int64, Int64)</td>
<td>允许其他进程访问以前锁定的某个文件的全部或部分</td>
</tr>
<tr>
<td>Write(Byte[], Int32, Int32)</td>
<td>将字节块写入文件流</td>
</tr>
<tr>
<td>WriteByte(Byte)</td>
<td>将一个字节写入文件流中的当前位置</td>
</tr>
</tbody></table>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">c.biancheng.net</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Demo</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> </span><br><span class="line">        &#123;</span><br><span class="line">            FileStream file = <span class="keyword">new</span> FileStream(<span class="string">&quot;test.txt&quot;</span>, FileMode.OpenOrCreate, FileAccess.ReadWrite);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)&#123;</span><br><span class="line">                file.WriteByte((<span class="built_in">byte</span>)i);</span><br><span class="line">            &#125;</span><br><span class="line">            file.Position = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)&#123;</span><br><span class="line">                Console.Write(file.ReadByte() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            file.Close();</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>FileStream</code> 是一个较低级别的类，是直接操作文件的字节流的，无论是读取还是写入都是基于字节的,它适用于需要对原始二进制数据进行精确控制的场合，例如读写图像、音频、自定义格式的数据文件等。但如果需要更复杂的数据读取写入操作,那么应该考虑下面的两种方式</p>
<ul>
<li><a href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99">二进制文件读写</a>  用于各种数据类型的二进制读写</li>
<li><a href="#%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99">文本文件的读写</a>  用于文本的读写</li>
</ul>
<h4 id="二进制文件读写"><a href="#二进制文件读写" class="headerlink" title="二进制文件读写"></a>二进制文件读写</h4><p>C# 中的 <strong>BinaryReader</strong> 和 <strong>BinaryWriter</strong> 类可以用于二进制文件的读写。</p>
<h5 id="BinaryReader"><a href="#BinaryReader" class="headerlink" title="BinaryReader"></a>BinaryReader</h5><p>BinaryReader 类用于从文件读取二进制数据，类中的常用方法如下所示：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>public override void Close()</td>
<td>关闭 BinaryReader 对象和基础流</td>
</tr>
<tr>
<td>public virtual int Read()</td>
<td>从基础流中读取字符，并根据所使用的编码和从流中读取的特定字符，将流的当前位置前移</td>
</tr>
<tr>
<td>public virtual bool ReadBoolean()</td>
<td>从当前流中读取一个布尔值，并将流的当前位置前移一个字节</td>
</tr>
<tr>
<td>public virtual byte ReadByte()</td>
<td>从当前流中读取下一个字节，并将流的当前位置前移一个字节</td>
</tr>
<tr>
<td>public virtual byte[] ReadBytes(int count)</td>
<td>从当前流中读取指定数目的字节到一个字节数组中，并将流的当前位置前移指定数目的字节</td>
</tr>
<tr>
<td>public virtual char ReadChar()</td>
<td>从当前流中读取下一个字节，并把流的当前位置按照所使用的编码和从流中读取的指定的字符往前移</td>
</tr>
<tr>
<td>public virtual char[] ReadChars(int count)</td>
<td>从当前流中读取指定数目的字符，并以字符数组的形式返回数据，并把流的当前位置按照所使用的编码和从流中读取的指定的字符往前移</td>
</tr>
<tr>
<td>public virtual double ReadDouble()</td>
<td>从当前流中读取一个 8 字节浮点值，并把流的当前位置前移八个字节</td>
</tr>
<tr>
<td>public virtual int ReadInt32()</td>
<td>从当前流中读取一个 4 字节有符号整数，并把流的当前位置前移四个字节</td>
</tr>
<tr>
<td>public virtual string ReadString()</td>
<td>从当前流中读取一个字符串，字符串以长度作为前缀，同时编码为一个七位的整数</td>
</tr>
</tbody></table>
<p>完整的方法列表查阅 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.binaryreader">C# 的官方文档</a>。</p>
<h5 id="BinaryWriter"><a href="#BinaryWriter" class="headerlink" title="BinaryWriter"></a>BinaryWriter</h5><p>BinaryWriter 类用于向文件写入二进制数据，类中的常用方法如下表所示：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>public override void Close()</td>
<td>关闭 BinaryWriter 对象和基础流</td>
</tr>
<tr>
<td>public virtual void Flush()</td>
<td>清理当前编写器的所有缓冲区，使得所有缓冲数据写入基础设备</td>
</tr>
<tr>
<td>public virtual long Seek(int offset,SeekOrigin origin)</td>
<td>设置当前流中的位置</td>
</tr>
<tr>
<td>public virtual void Write(bool value)</td>
<td>将一个字节的布尔值写入到当前流中，0 表示 false，1 表示 true</td>
</tr>
<tr>
<td>public virtual void Write(byte value)</td>
<td>将一个无符号字节写入到当前流中，并把流的位置前移一个字节</td>
</tr>
<tr>
<td>public virtual void Write(byte[] buffer)</td>
<td>将一个字节数组写入到基础流中</td>
</tr>
<tr>
<td>public virtual void Write(char ch)</td>
<td>将一个 Unicode 字符写入到当前流中，并把流的当前位置按照所使用的编码和要写入到流中的指定字符往前移</td>
</tr>
<tr>
<td>public virtual void Write(char[] chars)</td>
<td>将一个字符数组写入到当前流中，并把流的当前位置按照所使用的编码和要写入到流中的指定字符往前移</td>
</tr>
<tr>
<td>public virtual void Write(double value)</td>
<td>将一个 8 字节浮点值写入到当前流中，并把流位置前移八个字节</td>
</tr>
<tr>
<td>public virtual void Write(int value)</td>
<td>将一个 4 字节有符号整数写入到当前流中，并把流位置前移四个字节</td>
</tr>
<tr>
<td>public virtual void Write(string value)</td>
<td>将一个有长度前缀的字符串按 BinaryWriter 的当前编码写如到流中，并把流的当前位置按照所使用的编码和要写入到流中的指定字符往前移</td>
</tr>
</tbody></table>
<p>完整的方法列表请查阅 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.binarywriter">C# 的官方文档</a>。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">BinaryWriter bw;</span><br><span class="line">BinaryReader br;</span><br><span class="line"><span class="built_in">int</span> i = <span class="number">25</span>;</span><br><span class="line"><span class="built_in">double</span> d = <span class="number">3.14157</span>;</span><br><span class="line"><span class="built_in">bool</span> b = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">string</span> s = <span class="string">&quot;你好世界&quot;</span>;</span><br><span class="line"><span class="comment">// 创建文件</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    bw = <span class="keyword">new</span> BinaryWriter(<span class="keyword">new</span> FileStream(<span class="string">&quot;mydata&quot;</span>, FileMode.Create));</span><br><span class="line">&#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">    Console.WriteLine(e.Message + <span class="string">&quot;\n 文件创建失败！&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写入文件</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    bw.Write(i);</span><br><span class="line">    bw.Write(d);</span><br><span class="line">    bw.Write(b);</span><br><span class="line">    bw.Write(s);</span><br><span class="line">&#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">    Console.WriteLine(e.Message + <span class="string">&quot;\n 文件写入失败！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">bw.Close();</span><br><span class="line"><span class="comment">// 读取文件</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    br = <span class="keyword">new</span> BinaryReader(<span class="keyword">new</span> FileStream(<span class="string">&quot;mydata&quot;</span>, FileMode.Open));</span><br><span class="line">&#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">    Console.WriteLine(e.Message + <span class="string">&quot;\n 文件打开失败！&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    i = br.ReadInt32();</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Integer data: &#123;0&#125;&quot;</span>, i);</span><br><span class="line">    d = br.ReadDouble();</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Double data: &#123;0&#125;&quot;</span>, d);</span><br><span class="line">    b = br.ReadBoolean();</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Boolean data: &#123;0&#125;&quot;</span>, b);</span><br><span class="line">    s = br.ReadString();</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;String data: &#123;0&#125;&quot;</span>, s);</span><br><span class="line">&#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">    Console.WriteLine(e.Message + <span class="string">&quot;\n 文件读取失败！.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">br.Close();</span><br></pre></td></tr></table></figure>

<h4 id="文本文件的读写"><a href="#文本文件的读写" class="headerlink" title="文本文件的读写"></a>文本文件的读写</h4><p>System.IO 命名空间下的 <strong>StreamReader</strong> 和 <strong>StreamWriter</strong> 类可以用于文本文件的数据读写。这些类继承自抽象基类 Stream，Stream 类提供了对文件流读写的功能。</p>
<h5 id="StreamReader"><a href="#StreamReader" class="headerlink" title="StreamReader"></a>StreamReader</h5><p>StreamReader 类继承自抽象基类 TextReader，用来从文件中读取一系列字符，下表列出了 StreamReader 类中一些常用的方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>public override void Close()</td>
<td>关闭 StreamReader 对象和基础流，并释放任何与之相关的系统资源</td>
</tr>
<tr>
<td>public override int Peek()</td>
<td>返回下一个可用的字符，但不使用它</td>
</tr>
<tr>
<td>public override int Read()</td>
<td>从输入流中读取下一个字符，并把字符位置往前移一个字符</td>
</tr>
</tbody></table>
<p>完整的方法列表，可以访问 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.streamreader">C# 的官网文档</a>。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 StreamReader 类的对象</span></span><br><span class="line">StreamReader file = <span class="keyword">new</span> StreamReader(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line"><span class="built_in">string</span> line;</span><br><span class="line"><span class="comment">// 从文件中读取内容</span></span><br><span class="line"><span class="keyword">while</span>((line = file.ReadLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">    Console.WriteLine(line);</span><br><span class="line">&#125;</span><br><span class="line">file.Close();</span><br></pre></td></tr></table></figure>

<h5 id="StreamWriter"><a href="#StreamWriter" class="headerlink" title="StreamWriter"></a>StreamWriter</h5><p>StreamWriter 类同样继承自抽象类 TextWriter，用来向文件中写入一系列字符，下表列出了 StreamWriter 类中一些常用的方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>public override void Close()</td>
<td>关闭当前的 StreamWriter 对象和基础流</td>
</tr>
<tr>
<td>public override void Flush()</td>
<td>清理当前所有的缓冲区，使所有缓冲数据写入基础流</td>
</tr>
<tr>
<td>public virtual void Write(bool value)</td>
<td>将布尔值的文本表示形式写入文本流</td>
</tr>
<tr>
<td>public override void Write(char value)</td>
<td>将一个字符写入流</td>
</tr>
<tr>
<td>public virtual void Write(decimal value)</td>
<td>将一个小数值的文本表示形式写入文本流</td>
</tr>
<tr>
<td>public virtual void Write(double value)</td>
<td>将一个 8 字节浮点值的文本表示形式写入文本流</td>
</tr>
<tr>
<td>public virtual void Write(int value)</td>
<td>将一个 4 字节有符号整数的文本表示形式写入文本流</td>
</tr>
<tr>
<td>public override void Write(string value)</td>
<td>将一个字符串写入文本流</td>
</tr>
<tr>
<td>public virtual void WriteLine()</td>
<td>将行结束符写入文本流</td>
</tr>
</tbody></table>
<p>完整的方法列表查阅 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.streamwriter">C# 的官方文档</a>。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要写入文件中的数据</span></span><br><span class="line"><span class="built_in">string</span>[] str = <span class="keyword">new</span> <span class="built_in">string</span>[]&#123;</span><br><span class="line">    <span class="string">&quot;你好世界&quot;</span>,</span><br><span class="line">    <span class="string">&quot;hello world&quot;</span>,</span><br><span class="line">    <span class="string">&quot;C#&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 创建 StreamWriter 类的对象</span></span><br><span class="line">StreamWriter file = <span class="keyword">new</span> StreamWriter(<span class="string">&quot;demo.txt&quot;</span>);</span><br><span class="line"><span class="comment">// 将数组中的数据写入文件</span></span><br><span class="line"><span class="keyword">foreach</span>(<span class="built_in">string</span> s <span class="keyword">in</span> str)&#123;</span><br><span class="line">    file.WriteLine(s);</span><br><span class="line">&#125;</span><br><span class="line">file.Close();</span><br></pre></td></tr></table></figure>

<h1 id="CSharp-目录操作"><a href="#CSharp-目录操作" class="headerlink" title="CSharp 目录操作"></a>CSharp 目录操作</h1><h2 id="DirectoryInfo"><a href="#DirectoryInfo" class="headerlink" title="DirectoryInfo"></a>DirectoryInfo</h2><p>DirectoryInfo 类派生自 FileSystemInfo 类，其中提供了各种用于创建、移动、浏览目录和子目录的方法。需要注意的是，该类不能被继承。</p>
<p><strong>常用属性</strong></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Attributes</td>
<td>获取当前文件或目录的属性</td>
</tr>
<tr>
<td>CreationTime</td>
<td>获取当前文件或目录的创建时间</td>
</tr>
<tr>
<td>Exists</td>
<td>获取一个表示目录是否存在的布尔值</td>
</tr>
<tr>
<td>Extension</td>
<td>获取表示文件存在的字符串</td>
</tr>
<tr>
<td>FullName</td>
<td>获取目录或文件的完整路径</td>
</tr>
<tr>
<td>LastAccessTime</td>
<td>获取当前文件或目录最后被访问的时间</td>
</tr>
<tr>
<td>Name</td>
<td>获取该 DirectoryInfo 实例的名称</td>
</tr>
</tbody></table>
<p><strong>常用方法</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>public void Create()</td>
<td>创建一个目录</td>
</tr>
<tr>
<td>public DirectoryInfo CreateSubdirectory(string path)</td>
<td>在指定的路径上创建子目录，指定的路径可以是相对于 DirectoryInfo 类的实例的路径</td>
</tr>
<tr>
<td>public override void Delete()</td>
<td>如果为空的，则删除该 DirectoryInfo</td>
</tr>
<tr>
<td>public DirectoryInfo[] GetDirectories()</td>
<td>返回当前目录的子目录</td>
</tr>
<tr>
<td>public FileInfo[] GetFiles()</td>
<td>从当前目录返回文件列表</td>
</tr>
</tbody></table>
<p>完整的方法以及属性介绍，查阅 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.directoryinfo">C# 官方文档</a>。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前目录文件列表</span></span><br><span class="line"><span class="comment">// 创建一个 DirectoryInfo 对象</span></span><br><span class="line">DirectoryInfo mydir = <span class="keyword">new</span> DirectoryInfo(<span class="string">@&quot;./&quot;</span>);</span><br><span class="line"><span class="comment">// 获取目录中的文件以及它们的名称和大小</span></span><br><span class="line">FileInfo[] f = mydir.GetFiles();</span><br><span class="line"><span class="keyword">foreach</span> (FileInfo file <span class="keyword">in</span> f)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;文件名称：&#123;0&#125; 大小：&#123;1&#125;&quot;</span>, file.Name, file.Length);</span><br><span class="line">&#125;</span><br><span class="line">Console.ReadKey();</span><br></pre></td></tr></table></figure>

<h1 id="CSharp-文件操作"><a href="#CSharp-文件操作" class="headerlink" title="CSharp 文件操作"></a>CSharp 文件操作</h1><h2 id="FileInfo"><a href="#FileInfo" class="headerlink" title="FileInfo"></a>FileInfo</h2><p>FileInfo 类派生自 FileSystemInfo 类，其中提供了用于创建、复制、删除、移动、打开文件的属性和方法。与 DirectoryInfo 类相同，FileInfo 类也不能被继承。</p>
<p><strong>常用属性</strong></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Attributes</td>
<td>获取当前文件的属性</td>
</tr>
<tr>
<td>CreationTime</td>
<td>获取当前文件的创建时间</td>
</tr>
<tr>
<td>Directory</td>
<td>获取文件所属目录的一个实例</td>
</tr>
<tr>
<td>Exists</td>
<td>获取一个表示文件是否存在的布尔值</td>
</tr>
<tr>
<td>Extension</td>
<td>获取表示文件存在的字符串</td>
</tr>
<tr>
<td>FullName</td>
<td>获取文件的完整路径</td>
</tr>
<tr>
<td>LastAccessTime</td>
<td>获取当前文件最后被访问的时间</td>
</tr>
<tr>
<td>LastWriteTime</td>
<td>获取文件最后被写入的时间</td>
</tr>
<tr>
<td>Length</td>
<td>获取当前文件的大小，以字节为单位</td>
</tr>
<tr>
<td>Name</td>
<td>获取文件的名称</td>
</tr>
</tbody></table>
<p><strong>常用方法</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>public StreamWriter AppendText()</td>
<td>创建一个 StreamWriter，追加文本到由 FileInfo 的实例表示的文件中</td>
</tr>
<tr>
<td>public FileStream Create()</td>
<td>创建一个文件</td>
</tr>
<tr>
<td>public override void Delete()</td>
<td>永久删除一个文件</td>
</tr>
<tr>
<td>public void MoveTo(string destFileName)</td>
<td>移动一个指定的文件到一个新的位置，提供选项来指定新的文件名</td>
</tr>
<tr>
<td>public FileStream Open(FileMode mode)</td>
<td>以指定的模式打开一个文件</td>
</tr>
<tr>
<td>public FileStream Open(FileMode mode,FileAccess access)</td>
<td>以指定的模式，使用 read、write 或 read&#x2F;write 访问，来打开一个文件</td>
</tr>
<tr>
<td>public FileStream Open(FileMode mode,FileAccess access,FileShare share)</td>
<td>以指定的模式，使用 read、write 或 read&#x2F;write 访问，以及指定的分享选项，来打开一个文件</td>
</tr>
<tr>
<td>public FileStream OpenRead()</td>
<td>创建一个只读的 FileStream</td>
</tr>
<tr>
<td>public FileStream OpenWrite()</td>
<td>创建一个只写的 FileStream</td>
</tr>
</tbody></table>
<p>完整的方法以及属性介绍，查阅 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.fileinfo">C# 官方文档</a></p>
<h1 id="CSharp-特性"><a href="#CSharp-特性" class="headerlink" title="CSharp 特性"></a>CSharp 特性</h1><p>特性（Attribute）是一种用于在程序运行时传递各种元素（例如类、方法、结构、枚举等）<strong>行为信息的声明性代码</strong>。使用特性可以将元数据（例如编译器指令、注释、描述、方法和类等信息）添加到程序中。.Net Framework 提供了两种类型的特性，分别是</p>
<ul>
<li><a href="#%E9%A2%84%E5%AE%9A%E4%B9%89%E7%89%B9%E6%80%A7">预定义特性</a></li>
<li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%89%B9%E6%80%A7">自定义特性</a></li>
</ul>
<p>在 C# 中，特性具有以下属性：</p>
<ul>
<li>使用特性可以向程序中添加元数据，元数据是指程序中各种元素的相关信息，所有 .NET 程序中都包含一组指定的元数据；</li>
<li>可以将一个或多个特性应用于整个程序、模块或者较小的程序元素（例如类和属性）中；</li>
<li>特性可以像方法和属性一样接受自变量；</li>
<li>程序可使用反射来检查自己的元数据或其他程序中的元数据。</li>
</ul>
<h2 id="预定义特性"><a href="#预定义特性" class="headerlink" title="预定义特性"></a>预定义特性</h2><p>.Net Framework 中提供了三个预定义的属性：</p>
<ul>
<li><a href="#AttributeUsage">AttributeUsage</a></li>
<li><a href="#Conditional">Conditional</a></li>
<li><a href="#Obsolete">Obsolete</a></li>
</ul>
<h3 id="AttributeUsage"><a href="#AttributeUsage" class="headerlink" title="AttributeUsage"></a>AttributeUsage</h3><p>预定义特性 AttributeUsage 用来描述如何使用自定义特性类，其中定义了可以应用特性的项目类型。AttributeUsage 的语法格式如下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">AttributeUsage (</span></span><br><span class="line"><span class="meta">   validon,</span></span><br><span class="line"><span class="meta">   AllowMultiple = allowmultiple,</span></span><br><span class="line"><span class="meta">   Inherited = inherited</span></span><br><span class="line"><span class="meta">)</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//如:</span></span><br><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.Class |</span></span><br><span class="line"><span class="meta">AttributeTargets.Constructor |</span></span><br><span class="line"><span class="meta">AttributeTargets.Field |</span></span><br><span class="line"><span class="meta">AttributeTargets.Method |</span></span><br><span class="line"><span class="meta">AttributeTargets.Property,</span></span><br><span class="line"><span class="meta">AllowMultiple = true)</span>]</span><br></pre></td></tr></table></figure>

<p>参数说明如下：</p>
<ul>
<li>参数 validon 用来定义特性可被放置的语言元素。它是枚举器 AttributeTargets 的值的组合。默认值是 AttributeTargets.All；</li>
<li>参数 allowmultiple（可选参数）用来为该特性的 AllowMultiple 属性（property）提供一个布尔值，默认值为 false（单用的），如果为 true，则该特性是多用的；</li>
<li>参数 inherited（可选参数）用来为该特性的 Inherited 属性（property）提供一个布尔值，默认为 false（不被继承），如果为 true，则该特性可被派生类继承。</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Demo</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//该特性允许使用别名?来取代Help</span></span><br><span class="line">    [<span class="meta">CommandLineSwitchAlias(<span class="string">&quot;?&quot;</span>)</span>]</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">bool</span> Help</span><br><span class="line">  &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//该特性指出Out是一个必要参数</span></span><br><span class="line">    [<span class="meta">CommandLineSwitchRequired</span>]</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">string</span> Out</span><br><span class="line">  &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Conditional"><a href="#Conditional" class="headerlink" title="Conditional"></a>Conditional</h3><p>预定义特性 Conditional 用来标记一个方法，它的执行依赖于指定的预处理标识符。根据该特性值的不同，在编译时会起到不同的效果，例如当值为 Debug 或 Trace 时，会在调试代码时显示变量的值。</p>
<p>预定义特性 Conditional 的语法格式如下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Conditional(</span></span><br><span class="line"><span class="meta">  conditionalSymbol</span></span><br><span class="line"><span class="meta">)</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//如:</span></span><br><span class="line">[<span class="meta">Conditional(<span class="string">&quot;DEBUG&quot;</span>)</span>]</span><br><span class="line"><span class="comment">//用于在特定的编译条件下包含或排除方法的调用。具体来说，当编译器定义了 DEBUG 符号时，标记了 [Conditional(&quot;DEBUG&quot;)] 的方法会被包含在编译结果中；否则，这些方法的调用会被忽略。</span></span><br></pre></td></tr></table></figure>

<p>案例</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Diagnostics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">c.biancheng.net</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Demo</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function1</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Myclass.Message(<span class="string">&quot;Function1 函数&quot;</span>);</span><br><span class="line">            function2();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function2</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Myclass.Message(<span class="string">&quot;Function2 函数&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> </span><br><span class="line">        &#123;</span><br><span class="line">            Myclass.Message(<span class="string">&quot;Main 函数&quot;</span>);</span><br><span class="line">            function1();</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Myclass</span></span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="meta">Conditional(<span class="string">&quot;DEBUG&quot;</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Message</span>(<span class="params"><span class="built_in">string</span> msg</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码中，<code>[Conditional(&quot;DEBUG&quot;)]</code> 特性作用于 <code>Myclass.Message</code> 方法，它告诉编译器该方法的执行应取决于预处理器符号 <code>DEBUG</code> 是否被定义。在代码顶部，有一个预处理器指令 <code>#define DEBUG</code>，这意味着在编译阶段，<code>DEBUG</code> 符号被定义。当 <code>Message</code> 方法前面加上 <code>[Conditional(&quot;DEBUG&quot;)]</code> 特性时，意味着在调试版本（即 <code>DEBUG</code> 符号被定义时）编译代码时，<code>Message</code> 方法会被正常编译并执行。而<strong>在发布版本（即 <code>DEBUG</code> 符号未定义时），编译器将会移除所有对该方法的调用，就像这些调用从未存在过一样</strong>。这样一来，当你在发布版中运行这段代码时，<code>Myclass.Message</code> 方法不会输出任何消息，因为它在编译阶段就被优化掉了。而在调试版中运行时，你将看到所有的消息打印出来。这种方法常用于插入调试代码，以便在调试阶段辅助追踪程序流程，而不影响最终发布产品的性能或体积。</p>
<h3 id="Obsolete"><a href="#Obsolete" class="headerlink" title="Obsolete"></a>Obsolete</h3><p>预定义特性 Obsolete 用来标记不应被使用的程序，您可以使用它来通知编译器放弃某个目标元素。例如当您需要使用一个新方法来替代类中的某个旧方法时，就可以使用该特性将旧方法标记为 obsolete（过时的）并来输出一条消息，来提示我们应该使用新方法代替旧方法。</p>
<p>预定义特性 Obsolete 的语法格式如下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两种任选一种</span></span><br><span class="line">[<span class="meta">Obsolete (</span></span><br><span class="line"><span class="meta">  message</span></span><br><span class="line"><span class="meta">)</span>]</span><br><span class="line"></span><br><span class="line">[<span class="meta">Obsolete (</span></span><br><span class="line"><span class="meta">  message,</span></span><br><span class="line"><span class="meta">  iserror</span></span><br><span class="line"><span class="meta">)</span>]</span><br></pre></td></tr></table></figure>

<p>语法说明如下：</p>
<ul>
<li>参数 <code>message</code> 是一个字符串，用来描述项目为什么过时以及应该使用什么替代；</li>
<li>参数 <code>iserror</code> 是一个布尔值，默认值是 false（编译器会生成一个警告），如果设置为 true，那么编译器会把该项目的当作一个错误。</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">c.biancheng.net</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Demo</span></span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="meta">Obsolete(<span class="string">&quot;OldMethod 已弃用，请改用 NewMethod&quot;</span>, true)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OldMethod</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">          Console.WriteLine(<span class="string">&quot;已弃用的函数&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">NewMethod</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">          Console.WriteLine(<span class="string">&quot;新定义的函数&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> </span><br><span class="line">        &#123;</span><br><span class="line">            OldMethod();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//demo.cs(18,10): error CS0619: “c.biancheng.net.Demo.OldMethod()”已过时:“OldMethod 已弃用，请改用 NewMethod”</span></span><br></pre></td></tr></table></figure>

<h2 id="自定义特性"><a href="#自定义特性" class="headerlink" title="自定义特性"></a>自定义特性</h2><p>.Net Framework 允许您创建自定义特性，自定义特性不仅可以用于存储声明性的信息，还可以在运行时被检索。创建并使用自定义特性可以分为四个步骤：</p>
<ul>
<li>声明自定义特性；</li>
<li>构建自定义特性；</li>
<li>在目标程序上应用自定义特性；</li>
<li>通过反射访问特性。</li>
</ul>
<p>最后一步涉及编写一个简单的程序来读取元数据以便查找各种符号。元数据是有关数据或用于描述其他数据信息的数据。该程序应在运行时使用反射来访问属性</p>
<h3 id="声明自定义属性"><a href="#声明自定义属性" class="headerlink" title="声明自定义属性"></a>声明自定义属性</h3><p>自定义特性应该继承 System.Attribute 类，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个自定义特性 BugFix 被赋给类及其成员</span></span><br><span class="line">[<span class="meta">AttributeUsage(</span></span><br><span class="line"><span class="meta">   AttributeTargets.Class |</span></span><br><span class="line"><span class="meta">   AttributeTargets.Constructor |</span></span><br><span class="line"><span class="meta">   AttributeTargets.Field |</span></span><br><span class="line"><span class="meta">   AttributeTargets.Method |</span></span><br><span class="line"><span class="meta">   AttributeTargets.Property,</span></span><br><span class="line"><span class="meta">   AllowMultiple = true)</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DeBugInfo</span> : <span class="title">System.Attribute</span></span><br><span class="line"><span class="comment">//声明了一个名为 DeBugInfo 的自定义属性</span></span><br></pre></td></tr></table></figure>

<h3 id="构建自定义特性"><a href="#构建自定义特性" class="headerlink" title="构建自定义特性"></a>构建自定义特性</h3><p>让我们构建一个名为 DeBugInfo 的自定义特性，该特性可以存储下面列举的调试信息：</p>
<ul>
<li>bug 的代码编号；</li>
<li>该 bug 的开发人员名字；</li>
<li>上次审查代码的日期；</li>
<li>一个存储了开发人员标记的字符串消息。</li>
</ul>
<p>DeBugInfo 类中带有三个用于存储前三个信息的私有属性（property）和一个用于存储消息的公有属性（public）。所以 bug 编号、开发人员名字和审查日期将是 DeBugInfo 类的必需的定位（ positional）参数，而消息则是一个可选的命名（named）参数。</p>
<p>每个特性都至少有一个构造函数，而且定位（ positional）参数需要通过构造函数传递</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个自定义特性 BugFix 被赋给类及其成员</span></span><br><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.Class |</span></span><br><span class="line"><span class="meta">AttributeTargets.Constructor |</span></span><br><span class="line"><span class="meta">AttributeTargets.Field |</span></span><br><span class="line"><span class="meta">AttributeTargets.Method |</span></span><br><span class="line"><span class="meta">AttributeTargets.Property,</span></span><br><span class="line"><span class="meta">AllowMultiple = true)</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DeBugInfo</span> : <span class="title">System.Attribute</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="built_in">int</span> bugNo;</span><br><span class="line">  <span class="keyword">private</span> <span class="built_in">string</span> developer;</span><br><span class="line">  <span class="keyword">private</span> <span class="built_in">string</span> lastReview;</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">string</span> message;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DeBugInfo</span>(<span class="params"><span class="built_in">int</span> bg, <span class="built_in">string</span> dev, <span class="built_in">string</span> d</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">this</span>.bugNo = bg;</span><br><span class="line">      <span class="keyword">this</span>.developer = dev;</span><br><span class="line">      <span class="keyword">this</span>.lastReview = d;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">int</span> BugNo</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">get</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">return</span> bugNo;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">string</span> Developer</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">get</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">return</span> developer;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">string</span> LastReview</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">get</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">return</span> lastReview;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">string</span> Message</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">get</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">return</span> message;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">set</span></span><br><span class="line">      &#123;</span><br><span class="line">          message = <span class="keyword">value</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="应用自定义特性"><a href="#应用自定义特性" class="headerlink" title="应用自定义特性"></a>应用自定义特性</h3><p>通过把特性放置在紧挨着它的目标上面来应用该特性</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">c.biancheng.net</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Demo</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> </span><br><span class="line">        &#123;</span><br><span class="line">            Rectangle rec = <span class="keyword">new</span> Rectangle(<span class="number">12</span>, <span class="number">15</span>);</span><br><span class="line">            rec.Display();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">DeBugInfo(45, <span class="string">&quot;Zara Ali&quot;</span>, <span class="string">&quot;12/8/2012&quot;</span>, Message = <span class="string">&quot;返回值类型不匹配&quot;</span>)</span>]</span><br><span class="line">    [<span class="meta">DeBugInfo(49, <span class="string">&quot;Nuha Ali&quot;</span>, <span class="string">&quot;10/10/2012&quot;</span>, Message = <span class="string">&quot;未使用变量&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Rectangle</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 成员变量</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="built_in">double</span> length;</span><br><span class="line">        <span class="keyword">protected</span> <span class="built_in">double</span> width;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span>(<span class="params"><span class="built_in">double</span> l, <span class="built_in">double</span> w</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            length = l;</span><br><span class="line">            width = w;</span><br><span class="line">        &#125;</span><br><span class="line">        [<span class="meta">DeBugInfo(55, <span class="string">&quot;Zara Ali&quot;</span>, <span class="string">&quot;19/10/2012&quot;</span>,</span></span><br><span class="line"><span class="meta">        Message = <span class="string">&quot;返回值类型不匹配&quot;</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">GetArea</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> length * width;</span><br><span class="line">        &#125;</span><br><span class="line">        [<span class="meta">DeBugInfo(56, <span class="string">&quot;Zara Ali&quot;</span>, <span class="string">&quot;19/10/2012&quot;</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Display</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Length: &#123;0&#125;&quot;</span>, length);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Width: &#123;0&#125;&quot;</span>, width);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Area: &#123;0&#125;&quot;</span>, GetArea());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一个自定义特性 BugFix 被赋给类及其成员</span></span><br><span class="line">    [<span class="meta">AttributeUsage(AttributeTargets.Class |</span></span><br><span class="line"><span class="meta">    AttributeTargets.Constructor |</span></span><br><span class="line"><span class="meta">    AttributeTargets.Field |</span></span><br><span class="line"><span class="meta">    AttributeTargets.Method |</span></span><br><span class="line"><span class="meta">    AttributeTargets.Property,</span></span><br><span class="line"><span class="meta">    AllowMultiple = true)</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DeBugInfo</span> : <span class="title">System.Attribute</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">int</span> bugNo;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">string</span> developer;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">string</span> lastReview;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> message;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DeBugInfo</span>(<span class="params"><span class="built_in">int</span> bg, <span class="built_in">string</span> dev, <span class="built_in">string</span> d</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.bugNo = bg;</span><br><span class="line">            <span class="keyword">this</span>.developer = dev;</span><br><span class="line">            <span class="keyword">this</span>.lastReview = d;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> BugNo</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> bugNo;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Developer</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> developer;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> LastReview</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> lastReview;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Message</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> message;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">set</span></span><br><span class="line">            &#123;</span><br><span class="line">                message = <span class="keyword">value</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Length: 12</span></span><br><span class="line"><span class="comment">Width: 15</span></span><br><span class="line"><span class="comment">Area: 180</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>通过把特性放置在紧挨着它的目标上面来应用该特性</p>
<blockquote>
<p><code>DeBugInfo</code> 是一个自定义特性（Attribute），它主要用于记录与调试和错误修复相关的信息,这些信息并不是直接参与到程序的运行逻辑中，而是在编译后的元数据中保存，可以通过反射在运行时读取这些信息。这段代码中并未提供如何在运行时读取并利用这些自定义特性所携带的信息。要真正发挥其作用，通常还需要额外编写代码，通过反射API来提取和展示这些元数据。</p>
</blockquote>
<h1 id="CSharp-属性"><a href="#CSharp-属性" class="headerlink" title="CSharp 属性"></a>CSharp 属性</h1><p>属性（Property）是类（class）、结构体(struct)和接口（interface）的成员，类或结构体中的成员变量称为字段，属性是字段的扩展，使用访问器（accessors）可以读写私有字段的值。</p>
<p>属性没有确切的内存位置，但具有可读写或计算的访问器。例如有一个名为 Student 的类，其中包含 age、name 和 code 三个私有字段，我们不能在类的范围以外直接访问这些字段，但是可以访问这些私有字段的属性。</p>
<blockquote>
<p>在C#中，属性提供了一种封装类字段并公开对其访问的方式。属性允许您定义对类成员的访问方法，这样您可以控制对类的数据的访问方式。通过属性，您可以实现对类的字段的读取和写入操作，并在必要时执行其他逻辑（比如验证输入或触发事件）。属性使代码更易读，更易维护，并提供了一种更安全的方式来访问类的数据。</p>
</blockquote>
<h2 id="访问器"><a href="#访问器" class="headerlink" title="访问器"></a>访问器</h2><p>属性访问器有两种，分别是 get 属性访问器和 set 属性访问器。其中 get 访问器用来返回属性的值，set 访问器用来为属性设置新值。在声明访问器时可以仅声明其中一个，也可以两个访问器同时声明，如下例所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明 string 类型的 Code 属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> Code &#123;</span><br><span class="line">   <span class="keyword">get</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> code;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">set</span> &#123;</span><br><span class="line">      code = <span class="keyword">value</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明 string 类型的 Name 属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> Name &#123;</span><br><span class="line">   <span class="keyword">get</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">set</span> &#123;</span><br><span class="line">      name = <span class="keyword">value</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明 int 类型的 Age 属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> Age &#123;</span><br><span class="line">   <span class="keyword">get</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> age;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">set</span> &#123;</span><br><span class="line">      age = <span class="keyword">value</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//学生信息: 编号 = 001, 姓名 = Zara, 年龄 = 9</span></span><br><span class="line"><span class="comment">//学生信息: 编号 = 001, 姓名 = Zara, 年龄 = 10</span></span><br></pre></td></tr></table></figure>

<h2 id="抽象属性"><a href="#抽象属性" class="headerlink" title="抽象属性"></a>抽象属性</h2><p>抽象类中可以拥有抽象属性，这些属性会在派生类中实现，下面就通过一个示例来演示一下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">c.biancheng.net</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Demo</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 创建一个新的 Student 对象</span></span><br><span class="line">            Student s = <span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置 student 的 code、name 和 age</span></span><br><span class="line">            s.Code = <span class="string">&quot;001&quot;</span>;</span><br><span class="line">            s.Name = <span class="string">&quot;Zara&quot;</span>;</span><br><span class="line">            s.Age = <span class="number">9</span>;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;学生信息: &#123;0&#125;&quot;</span>, s);</span><br><span class="line">            <span class="comment">// 增加年龄</span></span><br><span class="line">            s.Age += <span class="number">1</span>;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;学生信息: &#123;0&#125;&quot;</span>, s);</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">string</span> Name</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span>;</span><br><span class="line">            <span class="keyword">set</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">int</span> Age</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span>;</span><br><span class="line">            <span class="keyword">set</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">string</span> code = <span class="string">&quot;N.A&quot;</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">string</span> name = <span class="string">&quot;not known&quot;</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">int</span> age = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明类型为 string 的 Code 属性</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Code</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> code;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">set</span></span><br><span class="line">            &#123;</span><br><span class="line">                code = <span class="keyword">value</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明类型为 string 的 Name 属性</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> name;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">set</span></span><br><span class="line">            &#123;</span><br><span class="line">                name = <span class="keyword">value</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明类型为 int 的 Age 属性</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Age</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> age;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">set</span></span><br><span class="line">            &#123;</span><br><span class="line">                age = <span class="keyword">value</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;编号 = &quot;</span> + Code +<span class="string">&quot;, 姓名 = &quot;</span> + Name + <span class="string">&quot;, 年龄 = &quot;</span> + Age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//学生信息: 编号 = 001, 姓名 = Zara, 年龄 = 9</span></span><br><span class="line"><span class="comment">//学生信息: 编号 = 001, 姓名 = Zara, 年龄 = 10</span></span><br></pre></td></tr></table></figure>

<h1 id="CSharp-索引器"><a href="#CSharp-索引器" class="headerlink" title="CSharp 索引器"></a>CSharp 索引器</h1><p>索引器（英文名：Indexer）是类中的一个特殊成员，它能够让对象以类似数组的形式来操作，使程序看起来更为直观，更容易编写。索引器与[属性](#CSharp 属性)类似，在定义索引器时同样会用到 get 和 set 访问器，不同的是，访问属性不需要提供参数而访问索引器则需要提供相应的参数。</p>
<p>C# 中属性的定义需要提供属性名称，而索引器则不需要具体名称，而是使用 this 关键字来定义，语法格式如下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">索引器类型 <span class="keyword">this</span>[<span class="built_in">int</span> index]</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// get 访问器</span></span><br><span class="line">  <span class="keyword">get</span></span><br><span class="line">  &#123;  </span><br><span class="line">    <span class="comment">// 返回 index 指定的值</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set 访问器</span></span><br><span class="line">  <span class="keyword">set</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 设置 index 指定的值</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>索引器的使用</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">c.biancheng.net</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Demo</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span>&#123;</span><br><span class="line">            Demo names = <span class="keyword">new</span> Demo();</span><br><span class="line">            names[<span class="number">0</span>] = <span class="string">&quot;C语言中文网&quot;</span>;</span><br><span class="line">            names[<span class="number">1</span>] = <span class="string">&quot;http://c.biancheng.net/&quot;</span>;</span><br><span class="line">            names[<span class="number">2</span>] = <span class="string">&quot;C#教程&quot;</span>;</span><br><span class="line">            names[<span class="number">3</span>] = <span class="string">&quot;索引器&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="built_in">int</span> i = <span class="number">0</span>; i &lt; Demo.size; i++ )&#123;</span><br><span class="line">                Console.WriteLine(names[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">public</span> <span class="built_in">int</span> size = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">string</span>[] namelist = <span class="keyword">new</span> <span class="built_in">string</span>[size];</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Demo</span>()</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                namelist[i] = <span class="string">&quot;NULL&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> <span class="keyword">this</span>[<span class="built_in">int</span> index]&#123;<span class="comment">//索引器定义</span></span><br><span class="line">            <span class="keyword">get</span>&#123;</span><br><span class="line">                <span class="built_in">string</span> tmp;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>( index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= size<span class="number">-1</span> )&#123;</span><br><span class="line">                    tmp = namelist[index];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    tmp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> ( tmp );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">set</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>( index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= size<span class="number">-1</span> )&#123;</span><br><span class="line">                    namelist[index] = <span class="keyword">value</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="索引器重载"><a href="#索引器重载" class="headerlink" title="索引器重载"></a>索引器重载</h2><p>索引器可以被重载，而且在声明索引器时也可以带有多个参数，每个参数可以是不同的类型。另外，索引器中的索引不必是整数，也可以是其他类型，例如字符串类型。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">c.biancheng.net</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Demo</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span>&#123;</span><br><span class="line">            Demo names = <span class="keyword">new</span> Demo();</span><br><span class="line">            names[<span class="number">0</span>] = <span class="string">&quot;C语言中文网&quot;</span>;</span><br><span class="line">            names[<span class="number">1</span>] = <span class="string">&quot;http://c.biancheng.net/&quot;</span>;</span><br><span class="line">            names[<span class="number">2</span>] = <span class="string">&quot;C#教程&quot;</span>;</span><br><span class="line">            names[<span class="number">3</span>] = <span class="string">&quot;索引器&quot;</span>;</span><br><span class="line">            <span class="comment">// 使用带有 int 参数的第一个索引器</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; Demo.size; i++)&#123;</span><br><span class="line">                Console.WriteLine(names[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 使用带有 string 参数的第二个索引器</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;“C#教程”的索引为：&#123;0&#125;&quot;</span>,names[<span class="string">&quot;C#教程&quot;</span>]);</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">public</span> <span class="built_in">int</span> size = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">string</span>[] namelist = <span class="keyword">new</span> <span class="built_in">string</span>[size];</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Demo</span>()</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                namelist[i] = <span class="string">&quot;NULL&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> <span class="keyword">this</span>[<span class="built_in">int</span> index]&#123;</span><br><span class="line">            <span class="keyword">get</span>&#123;</span><br><span class="line">                <span class="built_in">string</span> tmp;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>( index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= size<span class="number">-1</span> )&#123;</span><br><span class="line">                    tmp = namelist[index];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    tmp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> ( tmp );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">set</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>( index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= size<span class="number">-1</span> )&#123;</span><br><span class="line">                    namelist[index] = <span class="keyword">value</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> <span class="keyword">this</span>[<span class="built_in">string</span> name]&#123;</span><br><span class="line">            <span class="keyword">get</span>&#123;</span><br><span class="line">                <span class="built_in">int</span> index = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(index &lt; size)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(namelist[index] == name)&#123;</span><br><span class="line">                        <span class="keyword">return</span> index;</span><br><span class="line">                    &#125;</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="CSharp-委托"><a href="#CSharp-委托" class="headerlink" title="CSharp 委托"></a>CSharp 委托</h1><p>C# 中的委托（Delegate）类似于 C 或 C++ 中的函数指针，是一种引用类型，表示对具有特定参数列表和返回类型的方法的引用。委托特别适用于实现事件和回调方法，所有的委托都派生自 System.Delegate 类。在实例化委托时，可以将委托的实例与具有相同返回值类型的方法相关联，这样就可以通过委托来调用方法。另外，使用委托还可以将方法作为参数传递给其他方法，</p>
<p>委托具有以下特点：</p>
<ul>
<li>委托类似于 C&#x2F;C++ 中的函数指针，但委托是完全面向对象的。另外，C++ 中的指针会记住函数，而委托则是同时封装对象实例和方法；</li>
<li>委托允许将方法作为参数进行传递；</li>
<li>委托可用于定义回调方法；</li>
<li>委托可以链接在一起，例如可以对一个事件调用多个方法；</li>
<li>方法不必与委托类型完全匹配；</li>
<li>C# 2.0 版引入了 匿名函数 的概念，可以将代码块作为参数（而不是单独定义的方法）进行传递。C# 3.0 引入了 Lambda 表达式，利用它们可以更简练地编写内联代码块。匿名方法和 Lambda 表达式都可编译为委托类型，这些功能现在统称为匿名函数。</li>
</ul>
<h2 id="声明委托"><a href="#声明委托" class="headerlink" title="声明委托"></a>声明委托</h2><p>声明委托需要使用 delegate 关键字，语法格式如下：</p>
<p><code>delegate &lt;return type&gt; delegate-name(&lt;parameter list&gt;)</code></p>
<p>其中 <code>return type</code> 为返回值类型，<code>delegate-name</code> 为委托的名称，<code>parameter list</code> 为参数列表。</p>
<blockquote>
<p>提示：委托可以引用与委托具有相同签名的方法，也就是说委托在声明时即确定了委托可以引用的方法。</p>
</blockquote>
<h2 id="实例化委托"><a href="#实例化委托" class="headerlink" title="实例化委托"></a>实例化委托</h2><p>委托一旦声明，想要使用就必须使用 new 关键字来创建委托的对象，同时将其与特定的方法关联。如下例所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">printString</span>(<span class="params"><span class="built_in">string</span> s</span>)</span>;           <span class="comment">// 声明一个委托</span></span><br><span class="line">...</span><br><span class="line">printString ps1 = <span class="keyword">new</span> printString(WriteToScreen);    <span class="comment">// 实例化委托对象并将其与 WriteToScreen 方法关联</span></span><br><span class="line">printString ps2 = <span class="keyword">new</span> printString(WriteToFile);      <span class="comment">// 实例化委托对象并将其与 WriteToFile 方法关联</span></span><br></pre></td></tr></table></figure>

<p>委托案例</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">NumberChanger</span>(<span class="params"><span class="built_in">int</span> n</span>)</span>;      <span class="comment">// 定义委托</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">c.biancheng.net</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Demo</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">int</span> num = <span class="number">10</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">AddNum</span>(<span class="params"><span class="built_in">int</span> p</span>)</span>&#123;<span class="comment">//被委托的函数</span></span><br><span class="line">            num += p;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">MultNum</span>(<span class="params"><span class="built_in">int</span> q</span>)</span>&#123;<span class="comment">//被委托的函数</span></span><br><span class="line">            num *= q;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">getNum</span>()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span>&#123;</span><br><span class="line">            <span class="comment">// 创建委托实例</span></span><br><span class="line">            NumberChanger nc1 = <span class="keyword">new</span> NumberChanger(AddNum);<span class="comment">//实例化委托</span></span><br><span class="line">            NumberChanger nc2 = <span class="keyword">new</span> NumberChanger(MultNum);<span class="comment">//实例化委托</span></span><br><span class="line">            <span class="comment">// 使用委托对象调用方法</span></span><br><span class="line">            nc1(<span class="number">25</span>);<span class="comment">//使用委托</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;num 的值为: &#123;0&#125;&quot;</span>, getNum());</span><br><span class="line">            nc2(<span class="number">5</span>);<span class="comment">//使用委托</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;num 的值为: &#123;0&#125;&quot;</span>, getNum());</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常用的委托类型"><a href="#常用的委托类型" class="headerlink" title="常用的委托类型"></a>常用的委托类型</h2><ul>
<li><code>Func&lt;T, TResult&gt;</code>: 表示带有一个输入参数和一个返回值的方法。</li>
<li><code>Action&lt;T&gt;</code>: 表示没有返回值的方法。</li>
<li><code>Predicate&lt;T&gt;</code>: 表示用于定义一组条件的方法并返回布尔值。</li>
</ul>
<p>如<code>Predicate&lt;T&gt;</code>实际上就等同于<code>Func&lt;T,bool&gt;</code></p>
<h2 id="多播委托（合并委托）"><a href="#多播委托（合并委托）" class="headerlink" title="多播委托（合并委托）"></a>多播委托（合并委托）</h2><p>委托对象有一个非常有用的属性，那就是可以通过使用<code>+</code>运算符将多个对象分配给一个委托实例，同时还可以使用<code>-</code>运算符从委托中移除已分配的对象，当委托被调用时会依次调用列表中的委托。委托的这个属性被称为委托的多播，也可称为组播，利用委托的这个属性，您可以创建一个调用委托时要调用的方法列表。</p>
<p>注意：仅可合并类型相同的委托。</p>
<blockquote>
<p>所有委托都支持单一回调(换言之,多重性(multiplicity)等于1).然而,一个委托变量可以引用一系列委托,在这一系列委托中,每个委托都顺序指向一个后续的委托,从而形成了一个委托链,或者称为多播委托(multicast delegate).使用<strong>多播委托</strong>,可以通过一个方法对象来调用一个方法链,创建变量来引用</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">NumberChanger</span>(<span class="params"><span class="built_in">int</span> n</span>)</span>;      <span class="comment">// 定义委托</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">c.biancheng.net</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Demo</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">int</span> num = <span class="number">10</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">AddNum</span>(<span class="params"><span class="built_in">int</span> p</span>)</span>&#123;</span><br><span class="line">            num += p;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">MultNum</span>(<span class="params"><span class="built_in">int</span> q</span>)</span>&#123;</span><br><span class="line">            num *= q;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">getNum</span>()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span>&#123;</span><br><span class="line">            <span class="comment">// 创建委托实例</span></span><br><span class="line">            NumberChanger nc;</span><br><span class="line">            NumberChanger nc1 = <span class="keyword">new</span> NumberChanger(AddNum);</span><br><span class="line">            NumberChanger nc2 = <span class="keyword">new</span> NumberChanger(MultNum);</span><br><span class="line">            nc = nc1;</span><br><span class="line">            nc += nc2;</span><br><span class="line">            <span class="comment">// 调用多播</span></span><br><span class="line">            nc(<span class="number">5</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;num 的值为: &#123;0&#125;&quot;</span>, getNum());</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//num 的值为: 75</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>自我理解:相当于C++指针,但比指针多了一个组合功能,可以让一个委托为好几个不同的委托的组合</p>
</blockquote>
<p>打印案例</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个委托 printString，我们使用这个委托来调用两个方法，第一个把字符串打印到控制台，第二个把字符串打印到文件</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">c.biancheng.net</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Demo</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">static</span> FileStream fs;</span><br><span class="line">        <span class="keyword">static</span> StreamWriter sw;</span><br><span class="line">        <span class="comment">// 委托声明</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">printString</span>(<span class="params"><span class="built_in">string</span> s</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 该方法打印到控制台</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">WriteToScreen</span>(<span class="params"><span class="built_in">string</span> str</span>)</span>&#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;The String is: &#123;0&#125;&quot;</span>, str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 该方法打印到文件</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">WriteToFile</span>(<span class="params"><span class="built_in">string</span> s</span>)</span>&#123;</span><br><span class="line">            fs = <span class="keyword">new</span> FileStream(<span class="string">&quot;./message.txt&quot;</span>, FileMode.Append, FileAccess.Write);</span><br><span class="line">            sw = <span class="keyword">new</span> StreamWriter(fs);</span><br><span class="line">            sw.WriteLine(s);</span><br><span class="line">            sw.Flush();</span><br><span class="line">            sw.Close();</span><br><span class="line">            fs.Close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 该方法把委托作为参数，并使用它调用方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendString</span>(<span class="params">printString ps</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            ps(<span class="string">&quot;C语言中文网&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span>&#123;</span><br><span class="line">            printString ps1 = <span class="keyword">new</span> printString(WriteToScreen);</span><br><span class="line">            printString ps2 = <span class="keyword">new</span> printString(WriteToFile);</span><br><span class="line">            sendString(ps1);</span><br><span class="line">            sendString(ps2);</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="CSharp-事件"><a href="#CSharp-事件" class="headerlink" title="CSharp 事件"></a>CSharp 事件</h1><p>在 C# 中，事件（Event）可以看作是用户的一系列操作，例如点击键盘的某个按键、单击&#x2F;移动鼠标等，当事件发生时我们可以针对事件做出一系列的响应，例如退出程序、记录日志等等。<strong>C# 中线程之间的通信就是使用事件机制实现的</strong>。</p>
<blockquote>
<p>在C#中，事件是一种特殊的委托，它<strong>允许类对象通知其他类对象发生的特定动作</strong>。在C++中，你可以使用回调函数来实现类似的功能，但是事件在C#中提供了更强大和更易于使用的机制来实现类似的行为。</p>
</blockquote>
<p><strong>事件需要在类中声明和触发，并通过委托与事件处理程序关联</strong>。<strong>事件可以分为发布器和订阅器两个部分，其中发布器是一个包含事件和委托的对象，事件和委托之间的联系也定义在这个类中，发布器类的对象可以触发事件，并使用委托通知其他的对象；订阅器则是一个接收事件并提供事件处理程序的对象，发布器类中的委托调用订阅器类中的方法（事件处理程序）。</strong></p>
<p>有关事件我们需要注意以下几点：</p>
<ul>
<li>发布器确定何时触发事件，订阅器确定对事件作出何种响应；</li>
<li>一个事件可以拥有多个订阅器，同时订阅器也可以处理来自多个发布器的事件；</li>
<li>没有订阅器的事件永远也不会触发；</li>
<li>事件通常用于定义针对用户的操作，例如单击某个按钮；</li>
<li>如果事件拥有多个订阅器，当事件被触发时会同步调用所有的事件处理程序；</li>
<li>在 .NET 类库中，事件基于 EventHandler 委托和 EventArgs 基类。</li>
</ul>
<p>若要在类中声明一个事件，首先需要为该事件声明一个委托类型，例如：</p>
<p><code>public delegate void delegate_name(string status);</code></p>
<p>然后使用 event 关键字来声明事件本身，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于上面的委托定义事件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> delegate_name event_name;</span><br></pre></td></tr></table></figure>

<p>上例中定义了一个名为 delegate_name 和名为 event_name 的事件，当事件触发的时侯会调用委托。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">c.biancheng.net</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Demo</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span>&#123;</span><br><span class="line">            PublisherDemo e = <span class="keyword">new</span> PublisherDemo(); <span class="comment">/* 实例发布器类*/</span></span><br><span class="line">            SubscriberDemo v = <span class="keyword">new</span> SubscriberDemo(); <span class="comment">/* 实例订阅器类 */</span></span><br><span class="line">            e.MyEvent += <span class="keyword">new</span> PublisherDemo.MyEntrust( v.printf );</span><br><span class="line">            e.SetValue(<span class="string">&quot;C语言中文网&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***********发布器类***********/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PublisherDemo</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">string</span> <span class="keyword">value</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyEntrust</span>(<span class="params"><span class="built_in">string</span> str</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">event</span> MyEntrust MyEvent;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetValue</span>(<span class="params"> <span class="built_in">string</span> s </span>)</span>&#123;</span><br><span class="line">            <span class="keyword">value</span> = s;</span><br><span class="line">            MyEvent(<span class="keyword">value</span>);     <span class="comment">// 触发事件</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***********订阅器类***********/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SubscriberDemo</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printf</span>(<span class="params"><span class="built_in">string</span> str</span>)</span>&#123;</span><br><span class="line">            Console.WriteLine(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>A事件添加B事件,B事件添加A事件,会产生事件循环</p>
<h1 id="CSharp-集合"><a href="#CSharp-集合" class="headerlink" title="CSharp 集合"></a>CSharp 集合</h1><p>C# 中的集合类（Collection）是专门用于数据存储和检索的类，类中提供了对栈（stack）、队列（queue）、列表（list）和哈希表（hash table）的支持。大多数集合类都实现了相同的接口。</p>
<p>集合类的用途多种多样，例如可以动态的为元素分配内存、根据索引访问列表项等等，这些类创建 Object 类的对象集合，Object 类是 C# 中所有数据类型的基类。</p>
<table>
<thead>
<tr>
<th>类</th>
<th>描述和用法</th>
</tr>
</thead>
<tbody><tr>
<td><a href="#ArrayList%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84">动态数组（ArrayList）</a></td>
<td>动态数组表示可被单独索引的对象的有序集合。 动态数组基本上与数组相似，唯一不同的是动态数组可以使用索引在指定的位置添加和移除项目，动态数组会自动重新调整自身的大小。 另外，动态数组也允许在列表中进行动态内存分配、增加、搜索、排序等等。</td>
</tr>
<tr>
<td><a href="#Hashtable%E5%93%88%E5%B8%8C%E8%A1%A8">哈希表（Hashtable）</a></td>
<td>哈希表可以使用键来访问集合中的元素。 哈希表中的每一项都由一个键&#x2F;值对组成，键用于访问集合中的指定项。</td>
</tr>
<tr>
<td><a href="#SortedList%E6%8E%92%E5%BA%8F%E5%88%97%E8%A1%A8">排序列表（SortedList&lt;key,value&gt;）</a></td>
<td>排序列表是数组和哈希表的组合，可以使用键或索引来访问列表中的各项。 排序列表中包含一个可使用键或索引访问各项的列表，如果您使用索引访问各项，则它是一个动态数组，如果您使用键访问各项，则它就是一个哈希表。 另外，排序列表中的各项总是按键值进行排序的。</td>
</tr>
<tr>
<td>SortedSet<T></td>
<td>自排序,与SortedList一致,键必须唯一</td>
</tr>
<tr>
<td><a href="#Stack%E5%A0%86%E6%A0%88">堆栈（Stack）</a></td>
<td>堆栈代表了一个后进先出的对象集合。 当您需要对各项进行后进先出的访问时，则可以使用堆栈。为堆栈中添加一项称为推入项目，从堆栈中移除一项称为弹出项目。</td>
</tr>
<tr>
<td><a href="#Queue%E9%98%9F%E5%88%97">队列（Queue）</a></td>
<td>队列代表了一个先进先出的对象集合。 当您需要对各项进行先进先出的访问时，则可以使用队列。为队列中添加项目称为入队，为队列中移除项目称为出队。</td>
</tr>
<tr>
<td><a href="#BitArray%E7%82%B9%E9%98%B5%E5%88%97">点阵列（BitArray）</a></td>
<td>点阵列代表了一个使用 1 和 0 来表示的二进制数组。 当您需要存储比特位，但是事先不知道具体位数时，则可以使用点阵列。可以使用整型索引从点阵列集合中访问各项，索引从零开始。</td>
</tr>
</tbody></table>
<h2 id="ArrayList动态数组"><a href="#ArrayList动态数组" class="headerlink" title="ArrayList动态数组"></a>ArrayList动态数组</h2><p>在 C# 中，动态数组（<code>ArrayList</code>）代表了可被单独索引的对象的有序集合。动态数组基本上可以代替数组，唯一与数组不同的是，动态数组可以使用索引在指定的位置添加和移除指定的项目，动态数组会自动重新调整自身的大小。另外，动态数组允许在列表中进行动态内存分配、增加、搜索、排序等操作。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Capacity</td>
<td>获取或设置动态数组中可以包含的元素个数</td>
</tr>
<tr>
<td>Count</td>
<td>获取动态数组中实际包含的元素个数</td>
</tr>
<tr>
<td>IsFixedSize</td>
<td>判断动态数组是否具有固定大小</td>
</tr>
<tr>
<td>IsReadOnly</td>
<td>判断动态数组是否只读</td>
</tr>
<tr>
<td>IsSynchronized</td>
<td>判断访问动态数组是否同步（线程安全）</td>
</tr>
<tr>
<td>Item[Int32]</td>
<td>获取或设置指定索引处的元素</td>
</tr>
<tr>
<td>SyncRoot</td>
<td>获取一个对象用于同步访问动态数组</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>public virtual int Add(object value)</td>
<td>将对象添加到动态数组的末尾</td>
</tr>
<tr>
<td>public virtual void AddRange(ICollection c)</td>
<td>将 ICollection 的元素添加到动态数组的末尾</td>
</tr>
<tr>
<td>public virtual void Clear()</td>
<td>从动态数组中移除所有的元素</td>
</tr>
<tr>
<td>public virtual bool Contains(object item)</td>
<td>判断某个元素是否在动态数组中</td>
</tr>
<tr>
<td>public virtual ArrayList GetRange(int index, int count)</td>
<td>返回一个动态数组，表示源动态数组中元素的子集</td>
</tr>
<tr>
<td>public virtual int IndexOf(object)</td>
<td>搜索整个动态数组，并返回对象在动态数组中第一次出现的索引，索引从零开始</td>
</tr>
<tr>
<td>public virtual void Insert(int index, object value)</td>
<td>在动态数组的指定索引处插入一个元素</td>
</tr>
<tr>
<td>public virtual void InsertRange(int index, ICollection c)</td>
<td>在动态数组的指定索引处插入某个集合的元素</td>
</tr>
<tr>
<td>public virtual void Remove(object obj)</td>
<td>从动态数组中移除指定的对象</td>
</tr>
<tr>
<td>public virtual void RemoveAt(int index)</td>
<td>移除动态数组中指定索引处的元素</td>
</tr>
<tr>
<td>public virtual void RemoveRange(int index, int count)</td>
<td>从动态数组中移除某个范围的元素</td>
</tr>
<tr>
<td>public virtual void Reverse()</td>
<td>逆转动态数组中元素的顺序</td>
</tr>
<tr>
<td>public virtual void SetRange(int index, ICollection c)</td>
<td>复制某个集合的元素到动态数组中某个范围的元素上</td>
</tr>
<tr>
<td>public virtual void Sort()</td>
<td>对动态数组中的元素进行排序</td>
</tr>
<tr>
<td>public virtual void TrimToSize()</td>
<td>将容量设置为动态数组中元素的实际个数</td>
</tr>
</tbody></table>
<p>关于 ArrayList 类中的完整属性和方法介绍，可以查阅 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.arraylist?view=net-5.0#properties">C# 官方文档</a>。</p>
<p>存double案例:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        ArrayList arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加double类型数据到ArrayList</span></span><br><span class="line">        <span class="built_in">double</span> number1 = <span class="number">3.14</span>;</span><br><span class="line">        <span class="built_in">double</span> number2 = <span class="number">5.67</span>;</span><br><span class="line">        arrayList.Add(number1);</span><br><span class="line">        arrayList.Add(number2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历ArrayList并输出double类型数据</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">object</span> obj <span class="keyword">in</span> arrayList)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (obj <span class="keyword">is</span> <span class="built_in">double</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">double</span> num = (<span class="built_in">double</span>)obj;</span><br><span class="line">                Console.WriteLine(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Hashtable哈希表"><a href="#Hashtable哈希表" class="headerlink" title="Hashtable哈希表"></a>Hashtable哈希表</h2><p>在 C# 中，Hashtable（哈希表） 类表示根据键的哈希代码进行组织的键（key）&#x2F;值（value）对的集合，可以使用键来访问集合中的元素。也就是说当您需要使用键来访问指定元素时，可以选择使用哈希表。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Count</td>
<td>获取哈希表中包含的键值对的个数</td>
</tr>
<tr>
<td>IsFixedSize</td>
<td>获取一个值，用来表示哈希表是否具有固定大小</td>
</tr>
<tr>
<td>IsReadOnly</td>
<td>获取一个值，用来表示哈希表是否只读</td>
</tr>
<tr>
<td>Item</td>
<td>获取或设置与指定键关联的值</td>
</tr>
<tr>
<td>Keys</td>
<td>获取一个 ICollection，其中包含哈希表中的键</td>
</tr>
<tr>
<td>Values</td>
<td>获取一个 ICollection，其中包含哈希表中的值</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>public virtual void Add(object key, object value)</td>
<td>向哈希表中添加一个带有指定的键和值的元素</td>
</tr>
<tr>
<td>public virtual void Clear()</td>
<td>从哈希表中移除所有的元素</td>
</tr>
<tr>
<td>public virtual bool ContainsKey(object key)</td>
<td>判断哈希表是否包含指定的键</td>
</tr>
<tr>
<td>public virtual bool ContainsValue(object value)</td>
<td>判断哈希表是否包含指定的值</td>
</tr>
<tr>
<td>public virtual void Remove(object key)</td>
<td>从哈希表中移除带有指定的键的元素</td>
</tr>
</tbody></table>
<p>关于 Hashtable 类中的完整属性和方法介绍，可以查阅 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.hashtable?view=net-5.0#properties">C# 官方文档</a>。</p>
<h2 id="SortedList排序列表"><a href="#SortedList排序列表" class="headerlink" title="SortedList排序列表"></a>SortedList排序列表</h2><p>在 C# 中，SortedList 类用来表示键&#x2F;值对的集合，这些键&#x2F;值对按照键值进行排序，并且可以通过键或索引访问集合中的各个项。</p>
<p>我们可以将排序列表看作是数组和哈希表的组合，其中包含了可以使用键或索引访问各项的列表。如果您使用索引访问各项，那么它就是一个动态数组（ArrayList），如果您使用键访问各项，那么它就是一个哈希表（Hashtable）。另外，集合中的各项总是按键值进行排序。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Capacity</td>
<td>获取或设置排序列表中可包含的元素个数</td>
</tr>
<tr>
<td>Count</td>
<td>获取排序列表中的元素个数</td>
</tr>
<tr>
<td>IsFixedSize</td>
<td>判断排序列表是否具有固定大小</td>
</tr>
<tr>
<td>IsReadOnly</td>
<td>判断排序列表是否只读</td>
</tr>
<tr>
<td>Item</td>
<td>获取或设置排序列表中指定键所关联的值</td>
</tr>
<tr>
<td>Keys</td>
<td>获取一个包含排序列表中所有键的集合</td>
</tr>
<tr>
<td>Values</td>
<td>获取一个包含排序列表中所有值的集合</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>public virtual void Add(object key, object value)</td>
<td>向排序列表中添加一个带有指定的键和值的元素</td>
</tr>
<tr>
<td>public virtual void Clear()</td>
<td>从排序列表中移除所有的元素</td>
</tr>
<tr>
<td>public virtual bool ContainsKey(object key)</td>
<td>判断排序列表中是否包含指定的键</td>
</tr>
<tr>
<td>public virtual bool ContainsValue(object value)</td>
<td>判断排序列表中是否包含指定的值</td>
</tr>
<tr>
<td>public virtual object GetByIndex(int index)</td>
<td>获取排序列表中指定索引处的值</td>
</tr>
<tr>
<td>public virtual object GetKey(int index)</td>
<td>获取排序列表中指定索引处的键</td>
</tr>
<tr>
<td>public virtual IList GetKeyList()</td>
<td>获取排序列表中的键</td>
</tr>
<tr>
<td>public virtual IList GetValueList()</td>
<td>获取排序列表中的值</td>
</tr>
<tr>
<td>public virtual int IndexOfKey(object key)</td>
<td>返回排序列表中指定键的索引，索引从零开始</td>
</tr>
<tr>
<td>public virtual int IndexOfValue(object value)</td>
<td>返回排序列表中指定值第一次出现的索引，索引从零开始</td>
</tr>
<tr>
<td>public virtual void Remove(object key)</td>
<td>从排序列表中移除带有指定键的元素</td>
</tr>
<tr>
<td>public virtual void RemoveAt(int index)</td>
<td>移除排序列表中指定索引处的元素</td>
</tr>
<tr>
<td>public virtual void TrimToSize()</td>
<td>将排序列表的容量设置为排序列表中元素的实际个数</td>
</tr>
</tbody></table>
<p>关于 SortedList 类中的完整属性和方法介绍，可以查阅 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.generic.sortedlist-2?view=net-5.0#properties">C# 官方文档</a>。</p>
<h2 id="Stack堆栈"><a href="#Stack堆栈" class="headerlink" title="Stack堆栈"></a>Stack堆栈</h2><p>在 C# 中，堆栈（Stack）类表示一个<strong>后进先出</strong>的对象集合，当您需要对项目进行后进先出的访问时，则可以使用堆栈。向堆栈中添加元素称为推入元素，从堆栈中移除元素称为弹出元素。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Count</td>
<td>获取堆栈中包含的元素个数</td>
</tr>
<tr>
<td>IsSynchronized</td>
<td>判断是否同步对堆栈的访问（线程安全）</td>
</tr>
<tr>
<td>SyncRoot</td>
<td>获取可用于同步对堆栈访问的对象</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>public virtual void Clear()</td>
<td>从堆栈中移除所有的元素</td>
</tr>
<tr>
<td>public virtual bool Contains(object obj)</td>
<td>判断某个元素是否在堆栈中</td>
</tr>
<tr>
<td>public virtual object Peek()</td>
<td>返回在堆栈顶部的对象，但不移除它</td>
</tr>
<tr>
<td>public virtual object Pop()</td>
<td>移除并返回在堆栈顶部的对象</td>
</tr>
<tr>
<td>public virtual void Push(object obj)</td>
<td>向堆栈顶部添加一个对象</td>
</tr>
<tr>
<td>public virtual object[] ToArray()</td>
<td>复制堆栈到一个新的数组中</td>
</tr>
</tbody></table>
<p>关于 Stack 类中的完整属性和方法介绍，可以查阅 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.stack?view=net-5.0#properties">C# 官方文档</a>。</p>
<h2 id="Queue队列"><a href="#Queue队列" class="headerlink" title="Queue队列"></a>Queue队列</h2><p>在 C# 中，队列（Queue 类）与<a href="#Stack%E5%A0%86%E6%A0%88">堆栈</a>类似，它代表了一个<strong>先进先出</strong>的对象集合，当您需要对项目进行先进先出访问时，则可以使用队列。向队列中添加元素称为入队（enqueue），从堆栈中移除元素称为出队（deque）。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Count</td>
<td>获取队列中包含的元素个数</td>
</tr>
<tr>
<td>IsSynchronized</td>
<td>判断是否同步对队列的访问（线程安全）</td>
</tr>
<tr>
<td>SyncRoot</td>
<td>获取可用于同步对队列访问的对象</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>public virtual void Clear()</td>
<td>从队列中移除所有的元素</td>
</tr>
<tr>
<td>public virtual bool Contains(object obj)</td>
<td>判断某个元素是否在队列中</td>
</tr>
<tr>
<td>public virtual object Dequeue()</td>
<td>移除并返回在队列开头的对象</td>
</tr>
<tr>
<td>public virtual void Enqueue(object obj)</td>
<td>向队列的末尾处添加一个对象</td>
</tr>
<tr>
<td>public virtual object[] ToArray()</td>
<td>复制队列到一个新的数组中</td>
</tr>
<tr>
<td>public virtual void TrimToSize()</td>
<td>将队列的容量设置为队列中元素的实际个数</td>
</tr>
</tbody></table>
<h2 id="BitArray点阵列"><a href="#BitArray点阵列" class="headerlink" title="BitArray点阵列"></a>BitArray点阵列</h2><p>在 C# 中，BitArray 类用来管理一个紧凑型的位值数组，数组中的值均为布尔类型，其中 true（1）表示此位为开启，false（0）表示此位为关闭。</p>
<p>当您需要存储位（英文名“bit”数据存储的最小单位，也可称为比特），但事先又不知道具体位数时，就可以使用点阵列。当需要访问点阵列中的元素时，可以使用整型索引从点阵列中访问指定元素，索引从零开始。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Count</td>
<td>获取点阵列中包含的元素个数</td>
</tr>
<tr>
<td>IsReadOnly</td>
<td>判断 点阵列是否只读</td>
</tr>
<tr>
<td>Item</td>
<td>获取或设置点阵列中指定位置的值</td>
</tr>
<tr>
<td>Length</td>
<td>获取或设置点阵列中的元素个数</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>public BitArray And(BitArray value)</td>
<td>对当前的点阵列中的元素和指定点阵列中相对应的元素执行按位与操作</td>
</tr>
<tr>
<td>public bool Get(int index)</td>
<td>获取点阵列中指定位置的位值</td>
</tr>
<tr>
<td>public BitArray Not()</td>
<td>反转当前点阵列中所有位的值，即将 true 设置为 false，将 false 设置为 true</td>
</tr>
<tr>
<td>public BitArray Or(BitArray value)</td>
<td>对当前点阵列中的元素和指定点阵列中的相对应的元素执行按位或操作</td>
</tr>
<tr>
<td>public void Set(int index, bool value)</td>
<td>把点阵列中指定位置的位设置为指定的值</td>
</tr>
<tr>
<td>public void SetAll(bool value)</td>
<td>把点阵列中的所有位设置为指定的值</td>
</tr>
<tr>
<td>public BitArray Xor(BitArray value)</td>
<td>对当前点阵列中的元素和指定点阵列中的相对应的元素执行按位异或操作</td>
</tr>
</tbody></table>
<p>关于 BitArray 类中的完整属性和方法介绍，可以查阅 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.bitarray?view=net-5.0#properties">C# 官方文档</a>。</p>
<h2 id="ConcurrentQueue并发队列"><a href="#ConcurrentQueue并发队列" class="headerlink" title="ConcurrentQueue并发队列"></a>ConcurrentQueue并发队列</h2><ul>
<li><code>ConcurrentQueue&lt;T&gt;</code> 是一个线程安全的队列，适用于多线程环境。</li>
<li>提供了 <code>Enqueue</code>、<code>TryDequeue</code> 和 <code>TryPeek</code> 等方法来操作队列。</li>
<li>适合于需要高并发读写的场景，能够有效地避免锁竞争。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202408081718762.png" alt="在这里插入图片描述"></p>
<p> 综合以上两种实现方式，在支持多线程并发出队并发入队的情况下，ConcurrentQueue使用了分段存储的概念（如上图所示），ConcurrentQueue分配内存时以段(Segment)为单位，一个段内部含有一个默认长度为32的数组和执行下一个段的指针，有个和Head和Tail指针分别指向了起始段和结束段（这种结构有点像操作系统的段式内存管理和页式内存管理策略）。这种分配内存的实现方式不但减轻的GC的压力而且调用者也不用显示的调用TrimToSize()方法回收内存（在某段内存为空时，会由GC来回收该段内存）。</p>
<p>Segment内部和用数组实现的普通队列相当，只不过对于入队和出队操作使用了<strong>原子操作</strong>来防止多线程竞争问题，使用随机退让等技术保证活锁等问题，实现机制和ConcurrentStack差别不大，跟多TryAppend的实现细节在源码注释中已经阐述的非常清楚这里就再做不过多的解释。</p>
<blockquote>
<p>随机退让技术说明: 使用随机退让技术时，线程 A 在发现无法获取资源时，不会立即重试，而是会随机等待一段时间。这样，线程 B 可能会在 A 之后成功获取资源，从而打破活锁状态。</p>
</blockquote>
<p>引入命名空间并初始化</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Concurrent;</span><br><span class="line"></span><br><span class="line">ConcurrentQueue&lt;<span class="built_in">int</span>&gt; queue = <span class="keyword">new</span> ConcurrentQueue&lt;<span class="built_in">int</span>&gt;();</span><br></pre></td></tr></table></figure>

<h3 id="属性盘点"><a href="#属性盘点" class="headerlink" title="属性盘点"></a>属性盘点</h3><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Count</td>
<td>获取 ConcurrentQueue 中包含的元素数。</td>
</tr>
<tr>
<td>IsEmpty</td>
<td>获取一个值，该值指示 ConcurrentQueue 是否为空。</td>
</tr>
</tbody></table>
<h3 id="方法盘点"><a href="#方法盘点" class="headerlink" title="方法盘点"></a>方法盘点</h3><ul>
<li><p><strong>Clear()</strong><br>从 <code>ConcurrentQueue&lt;T&gt;</code> 中移除所有对象。</p>
</li>
<li><p><strong>CopyTo(T[], Int32)</strong><br>从指定数组索引开始将 <code>ConcurrentQueue&lt;T&gt;</code> 元素复制到现有一维数组中。</p>
</li>
<li><p><strong>Enqueue(T)</strong><br>将对象添加到 <code>ConcurrentQueue&lt;T&gt;</code> 的结尾处。</p>
</li>
<li><p><strong>Equals(Object)</strong><br>确定指定对象是否等于当前对象。</p>
</li>
<li><p><strong>GetEnumerator()</strong><br>返回循环访问 <code>ConcurrentQueue&lt;T&gt;</code> 的枚举数。</p>
</li>
<li><p><strong>GetHashCode()</strong><br>作为默认哈希函数。</p>
</li>
<li><p><strong>GetType()</strong><br>获取当前实例的 Type。</p>
</li>
<li><p><strong>MemberwiseClone()</strong><br>创建当前对象的浅表副本。</p>
</li>
<li><p><strong>ToArray()</strong><br>将 <code>ConcurrentQueue&lt;T&gt;</code> 中存储的元素复制到新数组中。</p>
</li>
<li><p><strong>ToString()</strong><br>返回表示当前对象的字符串。</p>
</li>
<li><p><strong>TryDequeue(T)</strong><br>尝试移除并返回并发队列开头处的对象。</p>
</li>
<li><p><strong>TryPeek(T)</strong><br>尝试返回 <code>ConcurrentQueue&lt;T&gt;</code> 开头处的对象但不将其移除。</p>
</li>
</ul>
<p>主要成员:入队(EnQueue) 、出队(TryDequeue) 、是否为空(IsEmpty)、获取队列内元素数量(Count)。</p>
<h2 id="阻塞集合BlockingCollection"><a href="#阻塞集合BlockingCollection" class="headerlink" title="阻塞集合BlockingCollection"></a>阻塞集合BlockingCollection</h2><p><code>BlockingCollection&lt;T&gt;</code> 是 .NET 中提供的一个线程安全的集合类，<strong>主要用于在生产者-消费者模式中进行数据的安全传递</strong>。它实现了 <code>IProducerConsumerCollection&lt;T&gt;</code> 接口，支持多线程环境下的并发操作。</p>
<blockquote>
<p>BlockingCollection实际上就是一个自带信号量的ConcurrentQueue</p>
<p><code>BlockingCollection</code> 在 <code>ConcurrentQueue</code> 的基础上，通过<strong>内置信号量机制</strong>扩展了堵塞功能</p>
</blockquote>
<p><strong>主要特性</strong></p>
<ol>
<li><strong>线程安全</strong>：<code>BlockingCollection&lt;T&gt;</code> 是线程安全的，多个线程可以同时添加和取出元素。</li>
<li><strong>阻塞操作</strong>：当集合为空时，尝试取出元素的线程会被阻塞，直到有元素可用；当集合达到最大容量时，尝试添加元素的线程会被阻塞，直到有空间可用。</li>
<li><strong>可设置的容量</strong>：可以指定集合的最大容量，防止内存过度使用。</li>
</ol>
<p><strong>构造&#x2F;设置容量</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BlockingCollection&lt;<span class="built_in">int</span>&gt; collection = <span class="keyword">new</span> BlockingCollection&lt;<span class="built_in">int</span>&gt;(capacity);<span class="comment">//设置容量大小,如果不传参表示无限容量</span></span><br></pre></td></tr></table></figure>

<p>如果集合达到这个容量，尝试添加新元素的线程将会被阻塞，直到有空间可用</p>
<h3 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h3><h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params">T item</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params">T item, CancellationToken cancellationToken</span>)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Add(T item)</code>：将元素添加到集合中，如果集合已满，则阻塞直到有空间可用。</li>
<li><code>Add(T item, CancellationToken cancellationToken)</code>：支持取消操作。</li>
</ul>
<h4 id="取出元素"><a href="#取出元素" class="headerlink" title="取出元素"></a>取出元素</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">Take</span>()</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">Take</span>(<span class="params">CancellationToken cancellationToken</span>)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Take()</code>：从集合中取出一个元素，如果集合为空，则阻塞直到有元素可用。</li>
<li><code>Take(CancellationToken cancellationToken)</code>：支持取消操作。</li>
</ul>
<h5 id="GetConsumingEnumerable"><a href="#GetConsumingEnumerable" class="headerlink" title="GetConsumingEnumerable"></a>GetConsumingEnumerable</h5><p>用途: GetConsumingEnumerable 返回一个 <code>IEnumerable&lt;T&gt;</code>，消费者可以通过这个枚举器逐个消费集合中的元素。<br>行为:</p>
<ul>
<li>当集合中没有元素时，GetConsumingEnumerable 会阻塞当前线程，直到有新的元素被添加到集合中。</li>
<li>一旦消费者从枚举器中获取了一个元素，该元素会从集合中移除。</li>
<li>当 CompleteAdding 被调用并且集合中没有更多元素时，枚举器会结束。</li>
</ul>
<p>适用场景: 适用于<strong>需要持续消费元素的场景</strong>，特别是在生产者-消费者模式中，消费者线程需要不断处理新元素。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消费者任务1: 使用 GetConsumingEnumerable</span></span><br><span class="line">Task consumer1 = Task.Run(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> collection.GetConsumingEnumerable())</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Consumed (GetConsumingEnumerable): <span class="subst">&#123;item&#125;</span>&quot;</span>);</span><br><span class="line">        Thread.Sleep(<span class="number">200</span>); <span class="comment">// 模拟消费延迟</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="尝试添加元素"><a href="#尝试添加元素" class="headerlink" title="尝试添加元素"></a>尝试添加元素</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">TryAdd</span>(<span class="params">T item</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">TryAdd</span>(<span class="params">T item, TimeSpan timeout</span>)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>TryAdd(T item)</code>：尝试添加元素，如果集合已满则返回 <code>false</code>。</li>
<li><code>TryAdd(T item, TimeSpan timeout)</code>：在指定的时间内尝试添加元素。</li>
</ul>
<h4 id="尝试取出元素"><a href="#尝试取出元素" class="headerlink" title="尝试取出元素"></a>尝试取出元素</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">TryTake</span>(<span class="params"><span class="keyword">out</span> T item</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">TryTake</span>(<span class="params"><span class="keyword">out</span> T item, TimeSpan timeout</span>)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>TryTake(out T item)</code>：尝试从集合中取出一个元素，如果集合为空则返回 <code>false</code>。</li>
<li><code>TryTake(out T item, TimeSpan timeout)</code>：在指定的时间内尝试取出元素。</li>
</ul>
<h4 id="完成添加"><a href="#完成添加" class="headerlink" title="完成添加"></a>完成添加</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CompleteAdding</span>()</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>标记集合为完成添加，之后不再允许添加新元素。</li>
</ul>
<p>调用后会将IsAddingCompleted设置为true</p>
<p>任何尝试调用 Add 或 TryAdd 方法向集合中添加新元素的操作都会抛出 InvalidOperationException 异常。<br>调用 CompleteAdding 后，消费者仍然可以继续消费集合中剩余的元素，直到集合为空</p>
<h4 id="检查是否已完成"><a href="#检查是否已完成" class="headerlink" title="检查是否已完成"></a>检查是否已完成</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">bool</span> IsAddingCompleted &#123; <span class="keyword">get</span>; &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>检查是否已完成添加。</li>
</ul>
<h1 id="CSharp所有容器总结"><a href="#CSharp所有容器总结" class="headerlink" title="CSharp所有容器总结"></a>CSharp所有容器总结</h1><p>盘点所有容器</p>
<ol>
<li><strong>Array（数组）</strong>：固定大小的连续内存块，用于存储相同类型的数据。</li>
<li><strong>List（列表）</strong>：动态大小的数组，支持快速随机访问，但插入和删除操作在中间位置可能比较慢。</li>
<li><strong>Dictionary&lt;TKey, TValue&gt;（字典）</strong>：使用键值对存储数据，支持快速查找、插入和删除操作，键必须是唯一的。</li>
<li><strong>HashSet（哈希集）</strong>：存储不重复的元素，支持快速查找、插入和删除操作。</li>
<li><strong>LinkedList（链表）</strong>：使用节点存储数据，节点之间通过指针链接，支持快速插入和删除操作，但随机访问比较慢。</li>
<li><strong>Queue（队列）</strong>：先进先出 (FIFO) 的数据结构，支持快速入队和出队操作。</li>
<li><strong>Stack（栈）</strong>：后进先出 (LIFO) 的数据结构，支持快速入栈和出栈操作。</li>
<li><strong>ObservableCollection（可观察集合）</strong>：支持通知机制，当集合发生变化时，会通知订阅者。</li>
<li><strong>IEnumerable<T>（可枚举集合）</strong>：定义了遍历集合的接口，允许使用 <code>foreach</code> 循环访问集合中的元素。</li>
<li><strong>IQueryable<T>（可查询集合）</strong>：定义了查询集合的接口，允许使用 LINQ 查询语言对集合进行查询。</li>
<li><strong>SortedList（排序列表）</strong>：存储键值对，根据键进行排序，支持快速查找操作。</li>
<li><strong>SortedDictionary（排序字典）</strong>：存储键值对，根据键进行排序，支持快速查找、插入和删除操作。</li>
<li><strong>ConcurrentBag（并发背包）</strong>：线程安全的集合，支持并发添加和删除操作，但不保证元素的顺序。</li>
<li><strong>ConcurrentQueue（并发队列）</strong>：线程安全的队列，支持并发入队和出队操作。</li>
<li><strong>ConcurrentStack（并发栈）</strong>：线程安全的栈，支持并发入栈和出栈操作。</li>
<li><strong>ConcurrentDictionary（并发字典）</strong>：线程安全的字典，支持并发查找、插入和删除操作。</li>
<li><strong>BlockingCollection（阻塞集合）</strong>：线程安全的集合，支持生产者 - 消费者模式，当集合为空时，消费者会阻塞等待生产者添加元素。</li>
<li><strong>ReadOnlyCollection（只读集合）</strong>：只读集合，不允许修改集合中的元素。</li>
<li><strong>ReadOnlyDictionary（只读字典）</strong>：只读字典，不允许修改字典中的键值对。</li>
<li><strong>ImmutableDictionary(不可变字典)</strong>: <strong>不可变性</strong> 和 <strong>线程安全机制</strong></li>
</ol>
<p>CSharp中所有的容器都实现了实现<a href="IEnumerable%E6%8E%A5%E5%8F%A3">IEnumerable接口</a></p>
<h2 id="IEnumerable接口"><a href="#IEnumerable接口" class="headerlink" title="IEnumerable接口"></a>IEnumerable接口</h2><p>通过实现<code>IEnumerable</code>接口，可以使自定义的集合类能够被<code>foreach</code>语句简单遍历，提供了一种统一的遍历集合元素的方式</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">System.Collections.Generic</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 摘要:</span></span><br><span class="line">    <span class="comment">//     公开枚举器，支持对指定类型的集合进行简单迭代。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 类型参数:</span></span><br><span class="line">    <span class="comment">//   T:</span></span><br><span class="line">    <span class="comment">//     要枚举的对象的类型。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEnumerable</span>&lt;<span class="keyword">out</span> <span class="title">T</span>&gt; : <span class="title">IEnumerable</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 摘要:</span></span><br><span class="line">        <span class="comment">//     返回一个枚举器，用于遍历集合。</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 返回结果:</span></span><br><span class="line">        <span class="comment">//     一个可用于遍历集合的枚举器。</span></span><br><span class="line">        <span class="function">IEnumerator&lt;T&gt; <span class="title">GetEnumerator</span>()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h3><ol>
<li><p>foreach</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MyCollection实现了IEnumerable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyCollection</span> : <span class="title">IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="built_in">int</span>[] data = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>()</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> data.GetEnumerator();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyCollection collection = <span class="keyword">new</span> MyCollection();</span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> item <span class="keyword">in</span> collection)</span><br><span class="line">&#123;</span><br><span class="line">  Console.WriteLine(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用<code>IEnumerator</code>接口手动迭代</strong>：</p>
<ul>
<li>可以通过手动调用枚举器对象的方法来遍历集合元素，而不是使用<code>foreach</code>语句。</li>
<li>使用<code>IEnumerator</code>接口的方法可以实现更灵活的遍历方式，例如条件遍历、跳过元素等操作。</li>
</ul>
</li>
<li><p><strong>LINQ查询</strong>：</p>
<ul>
<li>LINQ（Language Integrated Query）提供了丰富的查询操作符，可以对实现了<code>IEnumerable</code>接口的集合进行查询和筛选。</li>
<li>可以使用LINQ查询来对集合进行排序、过滤、投影等操作。</li>
</ul>
</li>
</ol>
<h1 id="CSharp-泛型"><a href="#CSharp-泛型" class="headerlink" title="CSharp 泛型"></a>CSharp 泛型</h1><p>在 C# 中，泛型（Generic）是一种规范，它允许我们使用占位符来定义类和方法，编译器会在编译时将这些占位符替换为指定的类型，利用泛型的这一特性我们可以定义为</p>
<ul>
<li><p>通用类（泛型类）</p>
</li>
<li><p>通用方法（泛型方法）</p>
</li>
</ul>
<p>定义通用类需要使用尖括号<code>&lt;&gt;</code>，这里的尖括号用于将类或方法声明为泛型。</p>
<blockquote>
<p>可以将泛型看作是一种增强程序功能的技术，泛型类和泛型方法兼具可重用性、类型安全性和效率，这是非泛型类和非泛型方法无法实现的。泛型通常与集合以及作用于集合的方法一起使用，System.Collections.Generic 命名空间下就包含几个基于泛型的集合类。下面总结了一些关于泛型的特性：</p>
<ul>
<li>使用泛型类型可以最大限度地重用代码、保护类型的安全性以及提高性能；</li>
<li>泛型最常见的用途是创建集合类；</li>
<li>.NET 类库在 System.Collections.Generic 命名空间中包含几个新的泛型集合类，您可以使用这些类来代替 System.Collections 中的集合类；</li>
<li>您可以创建自己的<strong>泛型接口、泛型类、泛型方法、泛型事件和泛型委托</strong>；</li>
<li>您也可以对泛型类进行约束以访问特定数据类型的方法；</li>
<li>在<strong>泛型数据类型中所用类型的信息可在运行时通过使用反射来获取</strong>。</li>
</ul>
</blockquote>
<h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">GenericClass</span>&lt;<span class="title">T</span>&gt;&#123;</span><br><span class="line">  <span class="comment">// 泛型方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">GenericClass</span>(<span class="params">T msg</span>)</span>&#123;</span><br><span class="line">    Console.WriteLine(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Demo</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span>&#123;</span><br><span class="line">    GenericClass&lt;<span class="built_in">string</span>&gt; str_gen = <span class="keyword">new</span> GenericClass&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;C语言中文网&quot;</span>);</span><br><span class="line">    GenericClass&lt;<span class="built_in">int</span>&gt; int_gen = <span class="keyword">new</span> GenericClass&lt;<span class="built_in">int</span>&gt;(<span class="number">1234567</span>);</span><br><span class="line">    GenericClass&lt;<span class="built_in">char</span>&gt; char_gen = <span class="keyword">new</span> GenericClass&lt;<span class="built_in">char</span>&gt;(<span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Demo</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Swap</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">ref</span> T lhs, <span class="keyword">ref</span> T rhs</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    T temp;</span><br><span class="line">    temp = lhs;</span><br><span class="line">    lhs = rhs;</span><br><span class="line">    rhs = temp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">int</span> a, b;</span><br><span class="line">    <span class="built_in">char</span> c, d;</span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    b = <span class="number">20</span>;</span><br><span class="line">    c = <span class="string">&#x27;I&#x27;</span>;</span><br><span class="line">    d = <span class="string">&#x27;V&#x27;</span>;</span><br><span class="line">    <span class="comment">// 在交换之前显示值</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;调用 swap 之前的 Int 值:&quot;</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;a = &#123;0&#125;, b = &#123;1&#125;&quot;</span>, a, b);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;调用 swap 之前的字符值:&quot;</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;c = &#123;0&#125;, d = &#123;1&#125;&quot;</span>, c, d);</span><br><span class="line">    <span class="comment">// 调用 swap</span></span><br><span class="line">    Swap&lt;<span class="built_in">int</span>&gt;(<span class="keyword">ref</span> a, <span class="keyword">ref</span> b);</span><br><span class="line">    Swap&lt;<span class="built_in">char</span>&gt;(<span class="keyword">ref</span> c, <span class="keyword">ref</span> d);</span><br><span class="line">    <span class="comment">// 在交换之后显示值</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;调用 swap 之后的 Int 值:&quot;</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;a = &#123;0&#125;, b = &#123;1&#125;&quot;</span>, a, b);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;调用 swap 之后的字符值:&quot;</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;c = &#123;0&#125;, d = &#123;1&#125;&quot;</span>, c, d);</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型委托"><a href="#泛型委托" class="headerlink" title="泛型委托"></a>泛型委托</h2><p><code>delegate T NumberChanger&lt;T&gt;(T n);</code></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Demo</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="built_in">delegate</span> T <span class="title">NumberChanger</span>&lt;<span class="title">T</span>&gt;(<span class="params">T n</span>)</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">int</span> num = <span class="number">10</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">AddNum</span>(<span class="params"><span class="built_in">int</span> p</span>)</span>&#123;</span><br><span class="line">    num += p;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">MultNum</span>(<span class="params"><span class="built_in">int</span> q</span>)</span>&#123;</span><br><span class="line">    num *= q;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">getNum</span>()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 创建委托实例</span></span><br><span class="line">    NumberChanger&lt;<span class="built_in">int</span>&gt; nc1 = <span class="keyword">new</span> NumberChanger&lt;<span class="built_in">int</span>&gt;(AddNum);</span><br><span class="line">    NumberChanger&lt;<span class="built_in">int</span>&gt; nc2 = <span class="keyword">new</span> NumberChanger&lt;<span class="built_in">int</span>&gt;(MultNum);</span><br><span class="line">    <span class="comment">// 使用委托对象调用方法</span></span><br><span class="line">    nc1(<span class="number">25</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Num 的值为: &#123;0&#125;&quot;</span>, getNum());</span><br><span class="line">    nc2(<span class="number">5</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Num 的值为: &#123;0&#125;&quot;</span>, getNum());</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="CSharp-匿名函数-方法"><a href="#CSharp-匿名函数-方法" class="headerlink" title="CSharp 匿名函数&#x2F;方法"></a>CSharp 匿名函数&#x2F;方法</h1><p>在 C# 中，可以将匿名函数简单的理解为没有名称只有函数主体的函数。匿名函数提供了一种将代码块作为委托参数传递的技术，它是一个“内联”语句或表达式，可在任何需要委托类型的地方使用。匿名函数可以用来初始化命名委托或传递命名委托作为方法参数。</p>
<blockquote>
<p>无需在匿名函数中指定返回类型，返回值类型是从方法体内的 return 语句推断出来的。</p>
</blockquote>
<p>名函数是通过使用 delegate 关键字创建的委托实例来声明的</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">NumberChanger</span>(<span class="params"><span class="built_in">int</span> n</span>)</span>;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//匿名函数传递给了nc委托</span></span><br><span class="line">NumberChanger nc = <span class="built_in">delegate</span>(<span class="built_in">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Anonymous Method: &#123;0&#125;&quot;</span>, x);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//作为对比,查看命名函数实例化委托(假设这个命名函数名为xxx)</span></span><br><span class="line"><span class="comment">//NumberChanger nc = new NumberChanger(xxx);</span></span><br></pre></td></tr></table></figure>

<p>委托可以通过匿名函数调用，也可以通过普通有名称的函数调用，只需要向委托对象中传递相应的方法参数即可。注意，<strong>匿名函数的主体后面需要使用<code>;</code>结尾</strong>。</p>
<h3 id="CSharp-new-Action的方式定义匿名函数"><a href="#CSharp-new-Action的方式定义匿名函数" class="headerlink" title="CSharp new Action的方式定义匿名函数"></a>CSharp new Action的方式定义匿名函数</h3><p>在C#中，Action是一种代表<strong>不返回值的委托类型</strong>。它可以用来定义一个接受零个到多个参数的方法，并且不返回任何值。下面是一个示例，演示了如何使用C#中的new Action来定义一个没有参数的方法：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Action myAction = () =&gt; Console.WriteLine(<span class="string">&quot;Hello, Action!&quot;</span>);</span><br><span class="line">        myAction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用   <code>Action&lt;T1, T2, ...&gt;</code>   来定义一个带有多个参数的委托。以下是一个示例：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Action&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt; myAction = (num, str) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;Number: <span class="subst">&#123;num&#125;</span>, String: <span class="subst">&#123;str&#125;</span>&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myAction(<span class="number">10</span>, <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="comment">//可以直接整合到一块,一步到位调用</span></span><br><span class="line"><span class="keyword">new</span> Action&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt;(</span><br><span class="line">    (num, str) =&gt; &#123; </span><br><span class="line">             Console.WriteLine(<span class="string">$&quot;Number: <span class="subst">&#123;num&#125;</span>, String:     <span class="subst">&#123;str&#125;</span>&quot;</span>); </span><br><span class="line">&#125;</span><br><span class="line">)(<span class="number">10</span>,<span class="string">&quot;hello world!&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>定义了一个带有两个参数（一个整数和一个字符串）的   Action   委托，并创建了一个匿名函数来输出这两个参数的值。</p>
<h1 id="CSharp-指针变量与unsafe"><a href="#CSharp-指针变量与unsafe" class="headerlink" title="CSharp 指针变量与unsafe"></a>CSharp 指针变量与unsafe</h1><p>为了保持类型的安全性，默认情况下 C# 是不支持指针的，但是如果使用 unsafe 关键字来修饰类或类中的成员，这样的类或类中成员就会被视为不安全代码，C# 允许在不安全代码中使用指针变量。在公共语言运行时 (CLR) 中，不安全代码是指无法验证的代码，不安全代码不一定是危险的，只是 CLR 无法验证该代码的安全性。因此 CLR 仅会执行信任程序集中包含的不安全代码。</p>
<h2 id="指针变量"><a href="#指针变量" class="headerlink" title="指针变量"></a>指针变量</h2><p>在 C# 中，指针同样是一个变量，但是它的值是另一个变量的内存地址，在使用指针之前我们同样需要先声明指针，声明指针的语法格式如下所示：</p>
<table>
<thead>
<tr>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>int* p</td>
<td>p 是指向整数的指针</td>
</tr>
<tr>
<td>double* p</td>
<td>p 是指向双精度数的指针</td>
</tr>
<tr>
<td>float* p</td>
<td>p 是指向浮点数的指针</td>
</tr>
<tr>
<td>int** p</td>
<td>p 是指向整数的指针的指针</td>
</tr>
<tr>
<td>int*[] p</td>
<td>p 是指向整数的指针的一维数组</td>
</tr>
<tr>
<td>char* p</td>
<td>p 是指向字符的指针</td>
</tr>
<tr>
<td>void* p</td>
<td>p 是指向未知类型的指针</td>
</tr>
</tbody></table>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Demo</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">unsafe</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">double</span> f = <span class="number">3.1415</span>;</span><br><span class="line">    <span class="built_in">double</span>* p = &amp;f;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;数据的内容是: &#123;0&#125; &quot;</span>,  f);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;数据在内存中的地址是: &#123;0&#125;&quot;</span>,  (<span class="built_in">int</span>)p);</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：在编译上述代码时需要在编译命令中添加<code>-unsafe</code>，例如<code>csc -unsafe demo.cs</code>。</p>
</blockquote>
<p>在 C# 中，我们可以使用 <code>ToString()</code> 来获取指针变量所指向的数据的值</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Demo</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">unsafe</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">int</span> <span class="keyword">var</span> = <span class="number">123456</span>;</span><br><span class="line">      <span class="built_in">int</span>* p = &amp;<span class="keyword">var</span>;</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;变量 var 的值为: &#123;0&#125; &quot;</span> , <span class="keyword">var</span>);</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;指针 p 指向的值为: &#123;0&#125; &quot;</span> , p-&gt;ToString());</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;指针 p 的值为: &#123;0&#125; &quot;</span> , (<span class="built_in">int</span>)p);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用指针访问数组元素</strong></p>
<p>在 C# 中，数组和指向该数组且与数组名称相同的指针是不同的数据类型，例如<code>int* p</code>和<code>int[] p</code>就是不同的数据类型。您可以增加指针变量 p 的值，因为它在内存中不是固定的，但数组地址在内存中是固定的，因此您不能增加数组 p 的值。如果您需要使用指针变量访问数组数据，使用 fixed 关键字来固定指针。下面通过示例演示一下：</p>
<blockquote>
<p>在C#中，固定语句（fixed statement）通常用于与非托管代码进行交互。非托管代码是指直接操作内存或者由其他语言编写的代码，通常不受C#垃圾回收器的管理。当你需要将C#中的托管对象传递给非托管代码时，必须确保这些对象在内存中不会被移动，因为非托管代码可能会持有指向这些对象的指针。通过使用固定语句，你可以确保在固定块内的对象不会被垃圾回收器移动，从而保证非托管代码能够正确地访问这些对象的内存位置。</p>
<p>C#中的垃圾回收器是自动管理的，它负责在程序运行时检测和回收不再被程序使用的内存。垃圾回收器使用一种叫做”标记-清除”的算法来确定哪些内存块是可以回收的。当垃圾回收器检测到某个对象不再被引用时，它会将其标记为可回收，并在适当的时机清除这些对象以释放内存。这种自动内存管理机制让开发人员不必手动管理内存，减少了内存泄漏和其他内存相关的问题。</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Demo</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">unsafe</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">int</span>[]  list = &#123;<span class="number">10</span>, <span class="number">100</span>, <span class="number">200</span>&#125;;</span><br><span class="line">    <span class="keyword">fixed</span>(<span class="built_in">int</span> *ptr = list)<span class="comment">//fixed!!!</span></span><br><span class="line">      <span class="comment">/* 显示指针中数组地址 */</span></span><br><span class="line">      <span class="keyword">for</span> ( <span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">      &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;list[&#123;0&#125;] 的内存地址为：&#123;1&#125;&quot;</span>,i,(<span class="built_in">int</span>)(ptr + i));</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;list[&#123;0&#125;] 的值为：&#123;1&#125;&quot;</span>, i, *(ptr + i));</span><br><span class="line">      &#125;</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编译不安全代码"><a href="#编译不安全代码" class="headerlink" title="编译不安全代码"></a>编译不安全代码</h2><p>为了编译不安全代码，在编译时必须使用<code>unsafe</code>命令，例如编译包含不安全代码的 demo.cs 程序的命令如下所示：</p>
<p><code>csc /unsafe demo.cs</code><br>或<br><code>csc -unsafe demo.cs</code></p>
<p>如果您使用的是 Visual Studio，那么您需要在项目属性中启用不安全代码，具体步骤如下：</p>
<ul>
<li>通过双击资源管理器（Solution Explorer）中的属性（properties）节点，打开项目属性（project properties）；</li>
<li>点击 Build 标签页；</li>
<li>选择选项“Allow unsafe code”。</li>
</ul>
<h1 id="CSharp-多线程"><a href="#CSharp-多线程" class="headerlink" title="CSharp 多线程"></a>CSharp 多线程</h1><p>多线程就是多个线程同时工作的过程，我们可以将线程看作是程序的执行路径，每个线程都定义了一个独特的控制流，用来完成特定的任务。如果您的应用程序涉及到复杂且耗时的操作，那么使用多线程来执行是非常有益的。使用多线程可以节省 CPU 资源，同时提高应用程序的执行效率，例如现代操作系统对并发编程的实现就用到了多线程。到目前为止我们编写的示例程序都是单线程的应用程序，这样的应用程序一次只能执行一个任务。</p>
<h2 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h2><p>线程生命周期开始于我们创建 <code>System.Threading.Thread</code> 类对象的时候，当线程被终止或完成执行时生命周期终止。</p>
<p>下面列出了线程生命周期中的各种状态：</p>
<ul>
<li>未启动状态：当线程实例被创建但 Start 方法未被调用时的状况；</li>
<li>就绪状态：当线程准备好运行并等待 CPU 周期时的状况；</li>
<li>不可运行状态：下面的几种情况下线程是不可运行的：<ul>
<li>已经调用 Sleep 方法；</li>
<li>已经调用 Wait 方法；</li>
<li>通过 I&#x2F;O 操作阻塞。</li>
</ul>
</li>
<li>死亡状态：当线程已完成执行或已中止时的状况。</li>
</ul>
<h2 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h2><p>在 C# 中，System.Threading.Thread 类用于处理线程，它允许在多线程应用程序中创建和访问各个线程。在多线程中执行的第一个线程称为主线程，当 C# 程序开始执行时，将自动创建主线程，而使用 Thread 类创建的线程则称为子线程，您可以使用 Thread 类的 CurrentThread 属性访问线程。下面通过示例程序演示主线程的执行：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Demo</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    Thread th = Thread.CurrentThread;</span><br><span class="line">    th.Name = <span class="string">&quot;主线程&quot;</span>;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;这是&#123;0&#125;&quot;</span>, th.Name);</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出:这是主线程</span></span><br></pre></td></tr></table></figure>

<h2 id="Thread-类"><a href="#Thread-类" class="headerlink" title="Thread 类"></a>Thread 类</h2><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>CurrentContext</td>
<td>获取线程正在执行的上下文</td>
</tr>
<tr>
<td>CurrentCulture</td>
<td>获取或设置当前线程的区域性</td>
</tr>
<tr>
<td>CurrentPrincipal</td>
<td>获取或设置线程的当前负责人（对基于角色的安全性而言）</td>
</tr>
<tr>
<td>CurrentThread</td>
<td>获取当前正在运行的线程</td>
</tr>
<tr>
<td>CurrentUICulture</td>
<td>获取或设置资源管理器使用的当前区域性以便在运行时查找区域性特定的资源</td>
</tr>
<tr>
<td>ExecutionContext</td>
<td>获取一个 ExecutionContext 对象，该对象包含有关当前线程的各种上下文的信息</td>
</tr>
<tr>
<td>IsAlive</td>
<td>获取当前线程的执行状态</td>
</tr>
<tr>
<td>IsBackground</td>
<td>获取或设置一个值，该值表示某个线程是否为后台线程</td>
</tr>
<tr>
<td>IsThreadPoolThread</td>
<td>获取线程是否属于托管线程池</td>
</tr>
<tr>
<td>ManagedThreadId</td>
<td>获取当前托管线程的唯一标识符</td>
</tr>
<tr>
<td>Name</td>
<td>获取或设置线程的名称</td>
</tr>
<tr>
<td>Priority</td>
<td>获取或设置线程的调度优先级</td>
</tr>
<tr>
<td>ThreadState</td>
<td>获取当前线程的状态</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>public void Abort()</td>
<td>在调用此方法的线程上引发 ThreadAbortException，以终止此线程</td>
</tr>
<tr>
<td>public static LocalDataStoreSlot AllocateDataSlot()</td>
<td>在所有的线程上分配未命名的数据槽，为了获得更好的性能，请改用以 ThreadStaticAttribute 特性标记的字段</td>
</tr>
<tr>
<td>public static LocalDataStoreSlot AllocateNamedDataSlot(string name)</td>
<td>在所有线程上分配已命名的数据槽，为了获得更好的性能，请改用以 ThreadStaticAttribute 特性标记的字段</td>
</tr>
<tr>
<td>public static void BeginCriticalRegion()</td>
<td>通知主机执行将要进入一个代码区域，在该代码区域内线程中止或未经处理的异常的影响可能会危害应用程序域中的其他任务</td>
</tr>
<tr>
<td>public static void BeginThreadAffinity()</td>
<td>通知主机托管代码将要执行依赖于当前物理操作系统线程的标识指令</td>
</tr>
<tr>
<td>public static void EndCriticalRegion()</td>
<td>通知主机执行将要进入一个代码区域，在该代码区域内线程中止或未经处理的异常仅影响当前任务</td>
</tr>
<tr>
<td>public static void EndThreadAffinity()</td>
<td>通知主机托管代码已执行完依赖于当前物理操作系统线程的标识指令</td>
</tr>
<tr>
<td>public static void FreeNamedDataSlot(string name)</td>
<td>为进程中的所有线程消除名称与数据槽之间的关联。为了获得更好的性能，请改用以 ThreadStaticAttribute 特性标记的字段</td>
</tr>
<tr>
<td>public static Object GetData(LocalDataStoreSlot slot)</td>
<td>检索当前线程中指定的值。为了获得更好的性能，请改用以 ThreadStaticAttribute 特性标记的字段</td>
</tr>
<tr>
<td>public static AppDomain GetDomain()</td>
<td>返回当前线程运行的域</td>
</tr>
<tr>
<td>public static AppDomain GetDomainID()</td>
<td>返回应用程序域的唯一标识符</td>
</tr>
<tr>
<td>public static LocalDataStoreSlot GetNamedDataSlot(string name)</td>
<td>查找已命名的数据槽。为了获得更好的性能，请改用以 ThreadStaticAttribute 特性标记的字段</td>
</tr>
<tr>
<td>public void Interrupt()</td>
<td>中断处于 WaitSleepJoin 状态的线程</td>
</tr>
<tr>
<td>public void Join()</td>
<td>在继续执行标准的 COM 和 SendMessage 消息泵处理期间，阻塞调用线程，直到某个线程终止为止。此方法有不同的重载形式</td>
</tr>
<tr>
<td>public static void MemoryBarrier()</td>
<td>按如下方式同步内存访问：执行当前线程的处理器在对指令重新排序时不能采用先执行 MemoryBarrier 调用之后的内存存取，再执行 MemoryBarrier 调用之前的内存存取的方式</td>
</tr>
<tr>
<td>public static void ResetAbort()</td>
<td>取消为当前线程请求的 Abort</td>
</tr>
<tr>
<td>public static void SetData(LocalDataStoreSlot slot, Object data)</td>
<td>在当前正在运行的线程上的指定槽中为此线程的当前域设置数据。为了获得更好的性能，请改用以 ThreadStaticAttribute 特性标记的字段</td>
</tr>
<tr>
<td>public void Start()</td>
<td>开始一个线程</td>
</tr>
<tr>
<td>public static void Sleep(int millisecondsTimeout)</td>
<td>让线程暂停一段时间</td>
</tr>
<tr>
<td>public static void SpinWait(int iterations)</td>
<td>让线程等待一段时间，时间长短由 iterations 参数定义</td>
</tr>
<tr>
<td>public static byte VolatileRead(ref byte address) public static double VolatileRead(ref double address) public static int VolatileRead(ref int address) public static Object VolatileRead(ref Object address)</td>
<td>读取字段值。无论处理器的数目或处理器缓存状态如何，该值都是由计算机处理器写入的最新值</td>
</tr>
<tr>
<td>public static void VolatileWrite(ref byte address, byte value) public static void VolatileWrite(ref double address, double value) public static void VolatileWrite(ref int address, int value) public static void VolatileWrite(ref Object address, Object value)</td>
<td>立即向字段中写入一个值，并使该值对计算机中的所有处理器都可见</td>
</tr>
<tr>
<td>public static bool Yield()</td>
<td>终止当前正在调用的线程并执行另一个准备运行的线程（由操作系统选择将要执行的另一个线程）</td>
</tr>
</tbody></table>
<h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><p>C# 是通过扩展 Thread 类来创建线程的，然后使用扩展的 Thread 类调用 Start() 方法开始执行子线程</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Demo</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CallToChildThread</span>()</span></span><br><span class="line">  &#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;执行子线程&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    ThreadStart childref = <span class="keyword">new</span> ThreadStart(CallToChildThread);<span class="comment">//这行代码定义了一个 ThreadStart 委托(该委托不支持返回值也不支持传参)类型的变量 childref ，它指向一个名为 CallToChildThread 的方法。</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;在 Main 函数中创建子线程&quot;</span>);</span><br><span class="line">    Thread childThread = <span class="keyword">new</span> Thread(childref);<span class="comment">//这行代码创建了一个新的线程对象 childThread ，并将之前定义的委托 childref 作为参数传递给线程对象。</span></span><br><span class="line">    childThread.Start();<span class="comment">//启动了子线程</span></span><br><span class="line">    Thread.Sleep(<span class="number">2000</span>);</span><br><span class="line">    childThread.Abort();<span class="comment">//中止子线程(m1 mac上不支持该函数)</span></span><br><span class="line">    Console.ReadKey();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CSharp-BackgroundWorker"><a href="#CSharp-BackgroundWorker" class="headerlink" title="CSharp BackgroundWorker"></a>CSharp BackgroundWorker</h2><p>以下是一个简单的示例，演示如何使用BackgroundWorker在C#中执行异步操作：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.ComponentModel;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> BackgroundWorker backgroundWorker = <span class="keyword">new</span> BackgroundWorker();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        backgroundWorker.DoWork += DoWork;</span><br><span class="line">        backgroundWorker.ProgressChanged += ProgressChanged;</span><br><span class="line">        backgroundWorker.RunWorkerCompleted += RunWorkerCompleted;</span><br><span class="line">        backgroundWorker.WorkerReportsProgress = <span class="literal">true</span>;</span><br><span class="line">        backgroundWorker.RunWorkerAsync();</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Main thread is not blocked!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Console.ReadLine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DoWork</span>(<span class="params"><span class="built_in">object</span> sender, DoWorkEventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Thread.Sleep(<span class="number">100</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 报告进度</span></span><br><span class="line">            backgroundWorker.ReportProgress(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ProgressChanged</span>(<span class="params"><span class="built_in">object</span> sender, ProgressChangedEventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Progress: <span class="subst">&#123;e.ProgressPercentage&#125;</span>%&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RunWorkerCompleted</span>(<span class="params"><span class="built_in">object</span> sender, RunWorkerCompletedEventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Async operation completed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，BackgroundWorker在后台线程中执行一个简单的计数操作，每次递增并报告进度。主线程不会被阻塞，可以继续执行其他操作。</p>
<blockquote>
<p>与Thread的区别:</p>
<ul>
<li>BackgroundWorker是一个<strong>高级别的组件</strong>，封装了在后台执行操作的细节，使得在UI线程上执行操作和在后台线程上执行操作更加容易。它提供了事件来报告进度和完成状态，并且可以在UI线程中方便地更新UI元素。 </li>
<li>Thread是一个更底层的多线程类，可以更灵活地控制线程的创建和管理。但是使用Thread需要手动处理线程的生命周期、线程同步和异常处理等问题，相对复杂一些。</li>
</ul>
</blockquote>
<h2 id="CSharp-获取线程id"><a href="#CSharp-获取线程id" class="headerlink" title="CSharp 获取线程id"></a>CSharp 获取线程id</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread.CurrentThread.ManagedThreadId<span class="comment">//不推荐使用这个</span></span><br><span class="line">Environment.CurrentManagedThreadId.Dump(title);<span class="comment">//这种方式更轻量化</span></span><br></pre></td></tr></table></figure>

<p>打印线程id函数可封装成如下:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.CompilerServices;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Helper</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> index = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//[CallerMemberName]的效果: name会被传入调用者的方法名</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintThreadId</span>(<span class="params"><span class="built_in">string</span>? message = <span class="literal">null</span>, [CallerMemberName] <span class="built_in">string</span>? name = <span class="literal">null</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> title = <span class="string">$&quot;<span class="subst">&#123;index&#125;</span>：<span class="subst">&#123;name&#125;</span>&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">string</span>.IsNullOrEmpty(message))</span><br><span class="line">        &#123;</span><br><span class="line">            title += <span class="string">$&quot; @ <span class="subst">&#123;message&#125;</span>&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;线程 ID: <span class="subst">&#123;Environment.CurrentManagedThreadId&#125;</span>, <span class="subst">&#123;title&#125;</span>&quot;</span>);</span><br><span class="line">        Interlocked.Increment(<span class="keyword">ref</span> index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CSharp-异步编程模型"><a href="#CSharp-异步编程模型" class="headerlink" title="CSharp 异步编程模型"></a>CSharp 异步编程模型</h2><blockquote>
<p>什么是异步?</p>
<p>异步是一个更广泛的行为,开个线程也叫异步,回调也叫异步</p>
</blockquote>
<p>C# 中的 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/async">Async</a> 和 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/await">Await</a> 关键字是异步编程的核心。 通过这两个关键字，可以使用 .NET Framework、.NET Core 或 Windows 运行时中的资源，轻松创建异步方法（几乎与创建同步方法一样轻松）。 </p>
<ul>
<li><p><code>async</code>：将方法标记为异步方法，表示该方法可能包含异步操作。</p>
<p>最终是否采用异步执行(是否真使用了多线程)，<strong>不决定于是否用<code>await</code>方式调用这个方法，而决定于这个方法内部，是否有<code>await</code>方式的调用。</strong></p>
<p>只有将方法标记async后,才可以在方法中使用await关键字</p>
</li>
<li><p><code>await</code>：用于等待一个操作完成的结果，然后继续执行下面的代码。<code>await</code>只能在<code>async</code>方法内部使用。</p>
<p>在异步中，<code>await</code>表达的意思是：当前线程&#x2F;方法中，<code>await</code>引导的方法出结果前，跳出当前线程&#x2F;方法，从调用当前线程&#x2F;方法的位置，去执行其它可能执行的线程&#x2F;方法，并在引导的方法出结果后，把运行点拉回到当前位置继续执行；直到遇到下一个<code>await</code>，或线程&#x2F;方法完成返回，跳回去刚才外部最后执行的位置继续执行。(<strong>因此await不会堵塞线程,虽然表现上是停止往后运行了,可以理解为堵塞了逻辑,但不堵塞线程,线程实际上去干别的了</strong>)</p>
<p>在通过await函数时,会等待函数执行完才回来继续执行下一句代码,但如果不通过await执行一个内含await的async函数,那么程序才是真正异步执行(存在子线程执行的情况)</p>
</li>
</ul>
<p><strong>注意</strong> await可以作用于[Task任务](#CSharp Task),而不一定要作用于async方法</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">async</span> Task <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">await</span> FooAsync();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Task <span class="title">FooAsync</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Task.Delay(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>要真正使用异步:</strong></p>
<ul>
<li><p><strong>被调用函数被async标记,被调用函数内部使用了await</strong></p>
</li>
<li><p><strong>调用被调用函数的时候没写await,才是真正使用异步</strong></p>
<p>如果使用了await方式调用被调用函数,那么实际上是堵塞了代码逻辑</p>
</li>
</ul>
</blockquote>
<h3 id="线程切换时机"><a href="#线程切换时机" class="headerlink" title="线程切换时机"></a>线程切换时机</h3><p>此处结合使用了[CSharp 获取线程id](CSharp 获取线程id)中的代码,案例如下:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">async</span> Task <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">  Helper.PrintThreadId(<span class="string">&quot;Before&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> FooAsync();</span><br><span class="line">  Helper.PrintThreadId(<span class="string">&quot;After&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">async</span> Task <span class="title">FooAsync</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">  Helper.PrintThreadId(<span class="string">&quot;Before&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> Task.Delay(<span class="number">1000</span>);</span><br><span class="line">  Helper.PrintThreadId(<span class="string">&quot;After&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">线程 ID: 1, 1：Main @ Before</span><br><span class="line">线程 ID: 1, 2：FooAsync @ Before</span><br><span class="line">线程 ID: 5, 3：FooAsync @ After</span><br><span class="line">线程 ID: 5, 4：Main @ After</span><br></pre></td></tr></table></figure>

<p>可见在<code>await Task.Delay(1000)</code>之前是同一个线程执行,在其之后包括<code>await Task.Delay(1000)</code>本身是另一个线程执行</p>
<p>使用<code>await Task.Delay(1000).ConfigureAwait(true);</code>可以让等待后回来执行的线程与离开的线程是同一个,即不会切换线程(等待后继续在原来的上下文中执行后续代码).但是注意该效果只在wpf或winform中有效,控制台程序无效</p>
<blockquote>
<p>理解 <code>ConfigureAwait(true)</code></p>
<p><strong>同步上下文</strong>：</p>
<ul>
<li>在 WPF 和 WinForms 应用程序中，存在一个“同步上下文”（SynchronizationContext），它负责管理 UI 线程的执行。当你在 UI 线程上运行异步代码时，<code>await</code> 会捕获当前的同步上下文，并在等待完成后返回到同一个上下文中继续执行后续代码。</li>
<li>这意味着如果你在 UI 线程上调用 <code>await Task.Delay(1000).ConfigureAwait(true);</code>，那么在等待结束后，代码会在 UI 线程中继续执行，从而可以安全地更新 UI 控件。</li>
</ul>
<p><strong>控制台程序</strong>：</p>
<ul>
<li>控制台应用程序默认没有同步上下文，这意味着在控制台程序中使用 <code>await</code> 时，<code>ConfigureAwait(true)</code> 不会有任何效果。因为没有上下文可供返回，<code>await</code> 完成后会在线程池线程上继续执行后续代码。</li>
<li>因此，在控制台应用程序中，即使你使用 <code>ConfigureAwait(true)</code>，也不会保证后续代码在原来的线程上执行。</li>
</ul>
<p><strong>WPF&#x2F;WINFORM中</strong></p>
<p>在 WPF 中，UI 线程会有一个与之关联的 <code>SynchronizationContext</code>。当你在 UI 线程上调用一个 <code>async</code> 方法并使用 <code>await</code> 时，<code>await</code> 会自动捕获当前的同步上下文（即 UI 线程的上下文），并在异步操作完成后返回到同一个上下文中继续执行后续代码。</p>
<p><strong>无需使用 ConfigureAwait</strong>：由于 WPF 的 <code>SynchronizationContext</code> 会自动处理上下文切换，因此在 WPF 中通常不需要使用 <code>ConfigureAwait(true)</code>。这意味着你可以安全地在 <code>async</code> 方法中更新 UI 控件，而不必担心线程安全问题。</p>
</blockquote>
<p>异步编程的重要思想是<strong>不阻塞</strong>!</p>
<ul>
<li>await会暂时释放当前线程,使得该线程可以执行其他工作,而不必阻塞线程直到异常操作完成</li>
<li>不应该在异步方法中用任何方式阻塞当前线程(更细地讲就是wpf或winform中await之前一定不能阻塞,此时还在原线程中)</li>
</ul>
<p>下面罗列常见阻塞线程情形</p>
<ul>
<li>Task.Wait()   Task.Result()</li>
<li>Thread.Sleep()</li>
<li>IO等操作的同步方法</li>
<li>其他繁重且耗时的任务</li>
</ul>
<blockquote>
<p>因此要注意,当这些阻塞线程的行为在async方法中的第一次使用await代码之前调用的时候,实际上还是会被阻塞线程,因为<a href="#%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E6%97%B6%E6%9C%BA">此时还没有切到别的线程</a></p>
</blockquote>
<h3 id="同步上下文的理解"><a href="#同步上下文的理解" class="headerlink" title="同步上下文的理解"></a>同步上下文的理解</h3><p>同步上下文是一种管理和协调线程的机制,允许开发者将代码的执行切换到特定的线程</p>
<p>WinForms 与 WPF 拥有同步上下文（UI线程），而控制台程序默认没有</p>
<h4 id="ConfigureAwait"><a href="#ConfigureAwait" class="headerlink" title="ConfigureAwait"></a>ConfigureAwait</h4><p>通过<code>Task.ConfigureAwait(false/true)</code>来设置await执行Task后是否回到原线程,true表示回到原线程</p>
<p>一般只有UI线程会采用这种策略:<code>Task.ConfigureAwait(false)</code></p>
<h4 id="关于同步上下文导致的死锁"><a href="#关于同步上下文导致的死锁" class="headerlink" title="关于同步上下文导致的死锁"></a>关于同步上下文导致的死锁</h4><p>此处记录一个关于同步上下文导致的死锁情况的经典案例</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">async</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">HeavyJob</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">await</span> Task.Delay(<span class="number">2000</span>);<span class="comment">//2.Delay完成后将回到ui线程</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按钮点击事件绑定的方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Button_click</span>(<span class="params"><span class="built_in">object</span> sender,RoutedEventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> res = HeavyJob().Result;<span class="comment">//1. 内部调用了Task.Wait(),会导致ui线程堵塞,直到得到HeavyJob的返回结果  3,HeavyJob的结果需要2号代码能返回到ui线程,可ui线程又正在被堵塞中,于是陷入死锁</span></span><br><span class="line">  txt.Text = res.ToString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码将导致死锁,不是卡住2秒,而是一直卡住</p>
<p>通俗地讲就是 **你托线程带个东西回来,东西不带回来就线程别想回来,还只能当前线程带回来.**于是导致死锁</p>
<p>解决方法是改编号2的代码为:<code>await Task.Delay(2000).ConfigureAwait(false);</code>,可以通俗理解为: <strong>你要求A线程带个东西回来,东西不带回来A线程就别想回来,但可以托别的线程带回来,别的线程把东西带回来了,A线程也就可以回来了</strong></p>
<h4 id="TaskScheduler"><a href="#TaskScheduler" class="headerlink" title="TaskScheduler"></a>TaskScheduler</h4><p>控制Task的调度方式和运行线程</p>
<p><a href="#%E9%9C%80%E8%A6%81%E6%9B%B4%E7%BB%86%E7%B2%92%E5%BA%A6%E7%9A%84%E6%8E%A7%E5%88%B6">用法可参考此处</a></p>
<ul>
<li>线程池线程 Default</li>
<li>当前线程 CurrentThread</li>
<li>单线程上下文  STAThread</li>
<li>长时间运行线程 LongRunning</li>
</ul>
<p>也可以设置优先级,上下文,执行状态等</p>
<h3 id="直接调用async方法"><a href="#直接调用async方法" class="headerlink" title="直接调用async方法"></a>直接调用async方法</h3><p>一发即忘 Fire-and-forget</p>
<p>调用一个异步方法,但是不使用await或阻塞的方式去等待它的结束</p>
<p>无法观察任务的状态(是否完成,是否报错等)</p>
<h3 id="返回值相关"><a href="#返回值相关" class="headerlink" title="返回值相关"></a>返回值相关</h3><p><strong>使用async关键字标记的函数通常需要返回一个下面类型的结果</strong></p>
<ul>
<li><code>Task</code>类型: 表示<strong>异步操作完成后不返回任何结果</strong></li>
<li><code>Task&lt;T&gt;</code> 类型：表示<strong>异步操作完成后返回一个T类型的值</strong>。</li>
<li><code>void</code> 类型：通常用于事件处理程序等异步操作中，表示异步操作完成后不返回任何结果，但可能通过事件或其他机制通知调用方。</li>
</ul>
<p><strong>命名规范</strong>: 命名异步方法时，可以在方法名后面加上<code>Async</code>后缀，以明确表示它是一个异步方法，例如<code>DownloadDataAsync</code>。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Net.Http;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> DownloadWebsiteAsync();<span class="comment">//堵塞</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;下载完成！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">DownloadWebsiteAsync</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> (HttpClient client = <span class="keyword">new</span> HttpClient())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> website = <span class="string">&quot;https://www.example.com&quot;</span>;</span><br><span class="line">            <span class="built_in">string</span> content = <span class="keyword">await</span> client.GetStringAsync(website);<span class="comment">//堵塞</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;下载内容长度：&quot;</span> + content.Length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Main</code>方法和<code>DownloadWebsiteAsync</code>方法都被标记为<code>async</code>，在<code>DownloadWebsiteAsync</code>方法内部，通过<code>await</code>等待<code>GetStringAsync</code>方法的异步操作完成。这样，程序能够在等待异步操作的同时，继续执行其他代码，提高了程序的并发性和响应性。</p>
<p><strong>执行流程</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202404091349756.png" alt="image-20240409134922876" style="zoom: 33%;" />

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202406210902330.png" alt="image-20240621090250722" style="zoom: 67%;" />

<p>调用Func1函数的时候,没有前缀await,Func1又是一个被async标识的函数,因此Func1函数会由子线程执行</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出为</span></span><br><span class="line">Async proccess - start</span><br><span class="line">Async proccess - enter Func1</span><br><span class="line">Func1 proccess - start</span><br><span class="line">Async proccess - <span class="keyword">out</span> Func1</span><br><span class="line">Async proccess - done</span><br><span class="line">Func1 proccess - end</span><br><span class="line">Main proccess - done</span><br></pre></td></tr></table></figure>

<h3 id="原理相关"><a href="#原理相关" class="headerlink" title="原理相关"></a>原理相关</h3><p>async与await组合使用会将方法包装成[[设计模式#状态模式|状态机],MoveNext方法会被底层调用,从而切换状态</p>
<p>查看<a target="_blank" rel="noopener" href="https://sharplab.io/">SharpLab</a></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">Foo</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">await</span> Task.Delay(<span class="number">1</span>);</span><br><span class="line">  Console.WriteLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码会被编译器编译的时候包装成一个状态机:(经过一定的变量名修改,以及提取核心代码段后的代码如下)</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CompilerGenerated 属性表示下面的类是编译器生成的，通常用于异步方法的状态机。 </span></span><br><span class="line">[<span class="meta">CompilerGenerated</span>]</span><br><span class="line"><span class="comment">// 定义一个名为 FooStateMachine 的密封类，它继承自 IAsyncStateMachine。密封类意味着这个类不能被继承，并且所有成员都是私有的，除非声明为公共或受保护。 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">FooStateMachine</span> : <span class="title">IAsyncStateMachine</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义一个名为 currentState 的公共整数属性，用于存储状态机的当前状态。这个属性没有指定的访问修饰符，默认为 private。  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> currentState;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个名为 t__builder 的公共 AsyncTaskMethodBuilder 类型的属性。AsyncTaskMethodBuilder 用于异步方法的启动和完成，并跟踪异步操作的状态。 </span></span><br><span class="line">    <span class="keyword">public</span> AsyncTaskMethodBuilder&lt;&gt; t__builder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个名为 4__this 的公共 C&lt;&gt; 类型的属性。这个属性通常用于存储异步操作的实例（如果有）。 </span></span><br><span class="line">    <span class="keyword">public</span> C&lt;&gt; <span class="number">4</span>__this;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个名为 taskAwaiter 的私有 TaskAwaiter 类型的字段。这个字段用于存储异步操作的等待器，允许状态机在异步操作完成时恢复执行。 </span></span><br><span class="line">    <span class="keyword">private</span> TaskAwaiter taskAwaiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个名为 MoveNext 的私有方法。这个方法包含了状态机的逻辑，根据当前状态执行相应的操作。 </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">MoveNext</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 声明一个名为 num 的整型变量并初始化为当前状态  </span></span><br><span class="line">        <span class="built_in">int</span> num = currentState;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 声明一个名为 awaiter 的 TaskAwaiter 类型局部变量  </span></span><br><span class="line">            TaskAwaiter awaiter;</span><br><span class="line">            <span class="comment">// 判断当前状态是否为 0  </span></span><br><span class="line">            <span class="keyword">if</span> (num!= <span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果当前状态不是 0 ，通过 Task.Delay(1) 创建一个新的 awaiter  </span></span><br><span class="line">                awaiter = Task.Delay(<span class="number">1</span>).GetAwaiter();</span><br><span class="line">                <span class="comment">// 判断新创建的 awaiter 是否已完成，如果没有完成，则将当前状态设置为 0，并将新创建的 awaiter 赋给 taskAwaiter，以便之后恢复执行  </span></span><br><span class="line">                <span class="keyword">if</span> (!awaiter.IsCompleted)</span><br><span class="line">                &#123;</span><br><span class="line">                    num = (currentState = <span class="number">0</span>); </span><br><span class="line">                    taskAwaiter = awaiter;</span><br><span class="line">                        <span class="comment">// 创建一个名为 stateMachine 的 FooStateMachine 类的实例，以便在之后使用它恢复执行  </span></span><br><span class="line">                        &lt;Foo&gt;d__1 stateMachine = <span class="keyword">this</span>; </span><br><span class="line">                        <span class="comment">// 通过引用 t__builder、awaiter 和 stateMachine，启动一个异步等待操作，这样当 awaiter 完成时，状态机可以恢复执行  </span></span><br><span class="line">                        &lt;&gt;t__builder.AwaitUnsafeOnCompleted(<span class="keyword">ref</span> awaiter, <span class="keyword">ref</span> stateMachine); </span><br><span class="line">                    <span class="keyword">return</span>; </span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果当前状态是 0 ，则将 taskAwaiter 的值赋给 awaiter，并将当前状态设置为 -1，标记为完成  </span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 等待 taskAwaiter 完成  </span></span><br><span class="line">                awaiter = taskAwaiter; </span><br><span class="line">                <span class="comment">// 重置 taskAwaiter 为默认状态  </span></span><br><span class="line">                taskAwaiter = <span class="literal">default</span>(TaskAwaiter); </span><br><span class="line">                num = (currentState = <span class="number">-1</span>); </span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">// 获取 awaiter 的结果，如果有异常则抛出  </span></span><br><span class="line">            awaiter.GetResult(); </span><br><span class="line">            Console.WriteLine(); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception exception)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果发生异常，将当前状态设置为 -2，并通过引用 t__builder，设置异常给异步任务  </span></span><br><span class="line">            currentState = <span class="number">-2</span>; </span><br><span class="line">            &lt;&gt;t__builder.SetException(exception); </span><br><span class="line">            <span class="keyword">return</span>; </span><br><span class="line">        &#125; </span><br><span class="line">            <span class="comment">// 执行结束，将当前状态设置为 -2，表示异步任务已完成  </span></span><br><span class="line">            currentState = <span class="number">-2</span>; </span><br><span class="line">            <span class="comment">// 通过引用 t__builder，设置异步任务完成  </span></span><br><span class="line">            &lt;&gt;t__builder.SetResult(); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个名为 Foo 的公共方法，这个方法可能是异步操作的入口点  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Task <span class="title">Foo</span>()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建一个 FooStateMachine 类的实例 stateMachine，用于管理异步操作的状态   </span></span><br><span class="line">        &lt;Foo&gt;d__1 stateMachine = <span class="keyword">new</span> &lt;Foo&gt;d__1();</span><br><span class="line">        <span class="comment">// 获取或创建一个 AsyncTaskMethodBuilder 实例，并将其赋值给 stateMachine.t__builder；这个对象将允许启动和跟踪异步操作的进度  </span></span><br><span class="line">        stateMachine.&lt;&gt;t__builder = AsyncTaskMethodBuilder.Create();</span><br><span class="line">        <span class="comment">// 将当前类的实例 this 赋值给 stateMachine.4__this，可能是为了在异步操作中访问当前类的成员或方法  </span></span><br><span class="line">        stateMachine.&lt;&gt;<span class="number">4</span>__this = <span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">// 设置 stateMachine 的当前状态为 -1，可能表示异步操作的初始状态，或者是某种特定的起始状态  </span></span><br><span class="line">        stateMachine.currentState = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 启动 stateMachine 的异步操作，通过引用 stateMachine 实例，异步操作会根据 currentState 的值执行相应的逻辑  </span></span><br><span class="line">        stateMachine.&lt;&gt;t__builder.Start(<span class="keyword">ref</span> stateMachine);</span><br><span class="line">        <span class="comment">// 返回 stateMachine.t__builder 创建的 Task 对象，这个 Task 对象代表了异步操作的执行，可以通过它来跟踪异步操作的进度或等待其完成   </span></span><br><span class="line">        <span class="keyword">return</span> stateMachine.&lt;&gt;t__builder.Task;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>async只是决定是否将其转换为一个状态机,而被包装的方法还是个Task.但是如果async方法中没有await操作,他其实是个同步方法,因为遇到await才可能涉及到线程切换</p>
<p>因此async是给编译器看的,本质上返回的仍然是Task,只不过通过编译器提供了语法糖,也因此接口中无法声明async Task</p>
<p>p.s.  async还带另一个语法糖,在其中写返回值可以直接写 <code>Task&lt;T&gt;</code>中的T类型，不用包装成 <code>Task&lt;T&gt;</code>,如下:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">Foo</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> Task.Run(()=&gt;<span class="number">42</span>);<span class="comment">//必须返回Task&lt;int&gt;</span></span><br><span class="line">  <span class="comment">//return Task.FromResult(42);//同理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加了async后</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">Foo</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="async-void理解"><a href="#async-void理解" class="headerlink" title="async void理解"></a>async void理解</h4><blockquote>
<p><strong>几乎只用于对事件的注册</strong>,因为对事件的注册没办法写async Task</p>
</blockquote>
<p>与async Task相比,同样会被包装成状态机,但缺少记录状态的Task对象</p>
<p>由于Task还包含了异步任务里面的异常信息,因此async void无法聚合异常(Aggregate Exception),需要谨慎处理异常</p>
<blockquote>
<p>下面展示一个异常案例:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">async</span> Task <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">    VoidAsync();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">catch</span>(Exception ex)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;捕获异常&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">  Console.ReadLine();<span class="comment">//等待异步完成</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">async</span> <span class="keyword">void</span> <span class="title">VoidAsync</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">await</span> Task.Delay(<span class="number">1000</span>);</span><br><span class="line">  Console.WriteLine(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Something was wrong!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此抛出的异常不会被try,catch块捕获</p>
<p>因此在使用事件注册的时候,需要异步的情况下不得不使用async void的时候,一定注意在事件注册方法中做异常处理</p>
</blockquote>
<p>只有返回Task的才能被await等待结果</p>
<h3 id="异步完成后执行的另一种方式"><a href="#异步完成后执行的另一种方式" class="headerlink" title="异步完成后执行的另一种方式"></a>异步完成后执行的另一种方式</h3><p><code>.ContinueWith</code>是用于任务(Task)的延续操作(continuation)的方法，它允许您在一个任务完成后执行另一个任务。<code>.ContinueWith</code>方法接受一个<code>Action&lt;Task&gt;</code>委托作为参数，表示在原始任务完成后要执行的操作。</p>
<p>使用<code>.ContinueWith</code>方法可以实现任务之间的串行执行，<strong>确保一个任务完成后再执行另一个任务</strong>。您还可以通过<code>.ContinueWith</code>方法指定不同的任务调度选项和取消标记，以满足更复杂的需求。<code>.ContinueWith</code>是异步编程中一个非常有用的方法，可以帮助您构建复杂的任务流程和处理异步操作的结果。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Task originalTask = Task.Run(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 执行一些耗时操作</span></span><br><span class="line">    Thread.Sleep(<span class="number">2000</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;原始任务完成&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Task continuationTask = originalTask.ContinueWith((task) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;延续任务开始&quot;</span>);</span><br><span class="line">    <span class="comment">// 在原始任务完成后执行的操作</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堵塞等待延续任务完成</span></span><br><span class="line">continuationTask.Wait();</span><br></pre></td></tr></table></figure>

<h3 id="传染性"><a href="#传染性" class="headerlink" title="传染性"></a>传染性</h3><p>异步编程具有传染性(Contagious)</p>
<ul>
<li><p>一处async,处处async</p>
</li>
<li><p>几乎所有自带方法都提供了异步的版本</p>
<p>如果真的遇到了只提供同步的方案,也可以使用<code>Task.Run</code>把他包装成一个异步的方法</p>
</li>
</ul>
<p>内置异步方法非常多,随意罗列一些:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HttpClient.GetAsync</span><br><span class="line">File.WriteAllTextAsync</span><br><span class="line">MemoryStream.ReadAsync</span><br><span class="line">Console.Out.WriteLineAsync</span><br></pre></td></tr></table></figure>

<h3 id="同步异步技巧"><a href="#同步异步技巧" class="headerlink" title="同步异步技巧"></a>同步异步技巧</h3><h4 id="如何创建异步任务"><a href="#如何创建异步任务" class="headerlink" title="如何创建异步任务"></a>如何创建异步任务</h4><ul>
<li><p>Task.Run()</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">HeavyJob</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span>  res = <span class="keyword">await</span> Task.Run(HeavyJob);<span class="comment">//将同步任务直接包装成异步任务</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Task.Factory.StartNew()</p>
</li>
<li><p>new Task+Task.Start()</p>
</li>
</ul>
<h4 id="如何同时开启多个异步任务"><a href="#如何同时开启多个异步任务" class="headerlink" title="如何同时开启多个异步任务"></a>如何同时开启多个异步任务</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tasks = <span class="keyword">new</span> List&lt;Task&lt;<span class="built_in">int</span>&gt;&gt;();</span><br><span class="line"><span class="keyword">foreach</span>(<span class="keyword">var</span> input <span class="keyword">in</span> inputs)</span><br><span class="line">&#123;</span><br><span class="line">  tasks.Add(HeavyJob(input));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">await</span> Task.WhenAll(tasks);</span><br></pre></td></tr></table></figure>

<h4 id="如何取消任务"><a href="#如何取消任务" class="headerlink" title="如何取消任务"></a>如何取消任务</h4><p>使用CancellationTokenSource + CancellationToken取消任务</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> cts = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line">  <span class="keyword">var</span> task = <span class="keyword">await</span> Task.Delay(<span class="number">100000</span>,cts.token);</span><br><span class="line">  Thread.Sleep(<span class="number">2000</span>);</span><br><span class="line">  cts.Cancel();</span><br><span class="line">  <span class="keyword">await</span> task;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(TaskCanceledException)</span><br><span class="line">&#123;</span><br><span class="line">  Console.WriteLine(<span class="string">&quot;任务取消&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">    cts.Dispose();</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p><strong>推荐所有的异步方法都带上CancellationToken这一传参</strong></p>
<h5 id="CancellationToken-CancellationTokenSource"><a href="#CancellationToken-CancellationTokenSource" class="headerlink" title="CancellationToken&#x2F;CancellationTokenSource"></a>CancellationToken&#x2F;CancellationTokenSource</h5><p><code>CancellationToken</code> 是 C# 中处理异步操作取消的重要工具。通过合理使用 <code>CancellationToken</code> 和 <code>CancellationTokenSource</code>，可以有效地管理长时间运行的任务，并在需要时安全地取消它们。</p>
<ol>
<li><strong>CancellationToken</strong>：表示请求取消操作的标志。它是一个轻量级的结构，通常用于传递给支持取消的异步方法。</li>
<li><strong>CancellationTokenSource</strong>：用于创建 <code>CancellationToken</code> 的对象，并提供取消操作的功能。</li>
</ol>
<p>创建 CancellationTokenSource</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CancellationTokenSource cts = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line">CancellationToken token = cts.Token;</span><br></pre></td></tr></table></figure>

<p>CancellationToken也可以用于同步任务,不是只能用于异步任务 </p>
<h4 id="任务超时如何实现"><a href="#任务超时如何实现" class="headerlink" title="任务超时如何实现"></a>任务超时如何实现</h4><h4 id="使用Channel实现异步任务之间的通信"><a href="#使用Channel实现异步任务之间的通信" class="headerlink" title="使用Channel实现异步任务之间的通信"></a>使用Channel实现异步任务之间的通信</h4><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1MN41157AU">参考视频</a></p>
<p>类似<a href="#%E9%98%BB%E5%A1%9E%E9%9B%86%E5%90%88BlockingCollection">BlockingCollection</a>以及<a href="#ConcurrentQueue%E5%B9%B6%E5%8F%91%E9%98%9F%E5%88%97">ConcurrentQueue</a>这种内部函数本质都是同步方法</p>
<h5 id="Chanel"><a href="#Chanel" class="headerlink" title="Chanel"></a>Chanel</h5><p><code>Channels</code> 是一个高性能的线程安全库，专为 <strong>生产者-消费者场景</strong> 设计，用于解耦生产者和消费者任务，提升并发处理能力</p>
<p>命名空间: <code>System.Threading.Channels</code></p>
<blockquote>
<p>核心作用与优势</p>
<ul>
<li><strong>解耦生产者与消费者</strong>：通过异步读写机制，允许生产者和消费者独立工作，互不阻塞，提高吞吐率</li>
<li><strong>动态扩展性</strong>：支持按需增加生产者或消费者数量，应对负载不均衡场景</li>
<li><strong>高性能</strong>：相比 <code>BlockingCollection</code> 和 <code>TPL Dataflow</code>，Channel 在单一职责（存储）场景下性能更高 </li>
<li><strong>线程安全</strong>：内置同步机制，支持多线程并发读写</li>
</ul>
<table>
<thead>
<tr>
<th>特性</th>
<th>Channel</th>
<th>TPL Dataflow</th>
<th>BlockingCollection</th>
</tr>
</thead>
<tbody><tr>
<td><strong>核心职责</strong></td>
<td>存储</td>
<td>存储 + 处理流水线</td>
<td>存储</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>高（线程安全优化）</td>
<td>中</td>
<td>低</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>纯生产者-消费者模型</td>
<td>复杂数据处理流水线</td>
<td>简单同步队列</td>
</tr>
</tbody></table>
</blockquote>
<h6 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h6><ul>
<li><p>无限容量通道(Unbounded)</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> channel = Channel.CreateUnbounded&lt;<span class="built_in">string</span>&gt;();</span><br></pre></td></tr></table></figure>

<p>适用于不确定数据量或瞬时高吞吐场景。</p>
<p>可配置 <code>SingleWriter</code> 和 <code>SingleReader</code> 限制多线程操作,默认为单线程操作</p>
</li>
<li><p>有限容量通道(Bounded)</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> channel = Channel.CreateBounded&lt;<span class="built_in">string</span>&gt;(<span class="keyword">new</span> BoundedChannelOptions(<span class="number">1000</span>)</span><br><span class="line">&#123;</span><br><span class="line">    FullMode = BoundedChannelFullMode.Wait, <span class="comment">// 设置满容策略</span></span><br><span class="line">    SingleReader= <span class="literal">true</span>,<span class="comment">//单线程</span></span><br><span class="line">    SingleWriter=<span class="literal">true</span>,<span class="comment">//单线程</span></span><br><span class="line">  	<span class="comment">//Capacity</span></span><br><span class="line">  	<span class="comment">//AllowSynchronousContinuations </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>满容策略</strong>：</p>
<ul>
<li><code>Wait</code>：阻塞写入直到有空间。</li>
<li><code>DropWrite</code>：丢弃新写入的数据。</li>
<li><code>DropOldest</code>：丢弃最旧数据腾出空间</li>
<li><code>DropNewest</code>：丢弃最新数据腾出空间</li>
</ul>
</li>
</ul>
<h6 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作"></a>读写操作</h6><table>
<thead>
<tr>
<th>方法</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td><code>TryWrite</code></td>
<td>非阻塞写入（同步）</td>
</tr>
<tr>
<td><code>WriteAsync</code></td>
<td><strong>异步阻塞</strong>写入(参数可以接受CancellationToken)</td>
</tr>
<tr>
<td><code>TryRead</code></td>
<td>非阻塞读取（同步）</td>
</tr>
<tr>
<td><code>ReadAsync</code></td>
<td><strong>异步阻塞</strong>读取(参数可以接受CancellationToken)</td>
</tr>
<tr>
<td><code>WaitToWriteAsync</code></td>
<td>异步等待直到允许写入</td>
</tr>
<tr>
<td><code>WaitToReadAsync</code></td>
<td>异步等待直到允许读取</td>
</tr>
</tbody></table>
<p>通过 <code>Writer.WriteAsync()</code> 异步写入 <code>await channel.Writer.WriteAsync(&quot;Hello World&quot;);</code></p>
<p>通过 <code>Reader.ReadAsync()</code> 或非阻塞循环读取</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">await</span> channel.Reader.WaitToReadAsync())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (channel.Reader.TryRead(<span class="keyword">out</span> <span class="keyword">var</span> message))</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>WaitToReadAsync()</code> 异步等待数据到达，避免忙等待。</li>
<li><code>TryRead()</code> 确保并发场景下安全读取</li>
</ul>
<h6 id="生产完成通知"><a href="#生产完成通知" class="headerlink" title="生产完成通知"></a>生产完成通知</h6><p><code>Chanel.Writer.Complete()</code>告诉Chanel,生产完成了,当消费者消费完剩余量后,将会触发<code>ChannelClosedException</code>异常</p>
<p>虽然使用reader.Completion.IsCompleted也可以判断是否完成了(但是只有读取的那瞬间能确定是否完成),由于程序执行流程的不确定性,建议通过<code>ChannelClosedException</code>来判断已完成</p>
<h6 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h6><p>多生产者-多消费者模型</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> channel = Channel.CreateUnbounded&lt;<span class="built_in">string</span>&gt;(<span class="keyword">new</span> UnboundedChannelOptions &#123; SingleWriter = <span class="literal">false</span> &#125;);</span><br><span class="line"><span class="comment">// 多线程写入</span></span><br><span class="line">Parallel.For(<span class="number">0</span>, <span class="number">10</span>, i =&gt; channel.Writer.WriteAsync(<span class="string">&quot;Msg_&quot;</span> + i));</span><br><span class="line"><span class="comment">// 多线程读取</span></span><br><span class="line">Parallel.ForEach(channel.Reader.ReadAllAsync().ToEnumerable(), msg =&gt; Process(msg));</span><br></pre></td></tr></table></figure>

<p><code>ReadAllAsync()</code> 返回异步流，支持并行处理 </p>
<blockquote>
<p>如果是消费者的需要使用Chanel,可以直接传<code>ChannelWriter&lt;T&gt;</code>也可以,而不必要整个Chanel传过去</p>
</blockquote>
<h4 id="在异步任务中汇报进度"><a href="#在异步任务中汇报进度" class="headerlink" title="在异步任务中汇报进度"></a>在异步任务中汇报进度</h4><p><a href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E8%BF%9B%E5%BA%A6%E9%80%9A%E7%9F%A5">参考此处</a></p>
<h4 id="如何在同步方法中调用异步方法"><a href="#如何在同步方法中调用异步方法" class="headerlink" title="如何在同步方法中调用异步方法"></a>如何在同步方法中调用异步方法</h4><p>使用Task.Run包裹就可以很简单的将一个同步方法转换为一个异步方法,也就可以使用await等待结果</p>
<h5 id="如何终止一个同步任务"><a href="#如何终止一个同步任务" class="headerlink" title="如何终止一个同步任务"></a>如何终止一个同步任务</h5><p>下面方式似乎可行,<strong>实则不行</strong>,因为下面的两个方法均是只是获得了超时的执行时间点,并没有真正将同步任务给终止</p>
<p>控制被封装为异步任务的同步任务的执行超时时间,可以使用<code>Task.Run</code>封装起来之后,使用使用WaitAsync并传超时时间参数来设置超时时间</p>
<p>还有一种很巧妙的方式</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> task1 = Task.Run(LongRunningJob);<span class="comment">//LongRunningJob是个同步任务</span></span><br><span class="line"><span class="keyword">var</span> task2 = Task.Delay(<span class="number">3000</span>);</span><br><span class="line"><span class="keyword">await</span> Task.WhenAny(task1,task2);</span><br></pre></td></tr></table></figure>

<p>未完待续…</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1im421M7if">真正终止同步方法参考此视频</a></p>
<h3 id="Task-Run和async方法的区别"><a href="#Task-Run和async方法的区别" class="headerlink" title="Task.Run和async方法的区别"></a>Task.Run和async方法的区别</h3><ul>
<li><code>Task.Run</code> 用于将一个同步方法或代码块放到线程池中异步执行。它通常用于将 CPU 密集型的任务移出主线程，以避免阻塞用户界面。</li>
<li><code>async Task</code> 是用于定义一个异步方法，这个方法可以使用 <code>await</code> 操作符来异步等待其他异步任务的完成。它通常用于 IO 密集型的操作，例如网络请求或文件读取。</li>
</ul>
<p>在 C# 中，使用 <code>Task.Run</code> 启动的任务可以通过 <code>await</code> 关键字异步等待其结果，同时保持主线程不被阻塞</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主线程（如 UI 线程）调用的示例</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Button_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使用 Task.Run 将 CPU 密集型任务放到线程池</span></span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">await</span> Task.Run(() =&gt; </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 模拟耗时计算（如复杂数学运算）</span></span><br><span class="line">        Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里会回到主线程上下文（UI 线程）</span></span><br><span class="line">    label.Text = <span class="string">$&quot;Result: <span class="subst">&#123;result&#125;</span>&quot;</span>; <span class="comment">// 安全更新 UI</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>❌ 错误方式：<code>var result = Task.Run(...).Result;</code>（会阻塞主线程）</li>
<li>✅ 正确方式：<code>var result = await Task.Run(...);</code>（非阻塞）   Task.Run的参数可以接受同步函数</li>
</ul>
<p>CPU 密集型任务才需要 <code>Task.Run</code>，IO 密集型任务应直接使用异步 API（如 <code>File.ReadAllTextAsync</code>）</p>
<p>性能注意:  不要对已经异步的方法使用 <code>Task.Run</code></p>
<h3 id="TaskCompletionSource高级异步"><a href="#TaskCompletionSource高级异步" class="headerlink" title="TaskCompletionSource高级异步"></a>TaskCompletionSource高级异步</h3><p>TaskCompletionSource探讨的是如何让一些事务处理变成异步的</p>
<p>虽然<code>Task.Run</code>能让一些同步代码变成一个Task(通过在一个单独的线程上运行),TaskCompletionSource能让一些已经异步的代码变成Task(当然它最重要的功能使能够让一些基于回调的代码变成更好看的async&#x2F;await)</p>
<p>但如果他已经是异步的,为啥还需要让他变成一个Task呢?这是因为Task只是一个好用的异步模型,已经异步的代码需要转换为Task才能更优雅的被async&#x2F;await使用</p>
<p>使得异步代码执行的东西可以被等待,如果本身就是async&#x2F;await实现的异步因为返回本身就是Task,这种情况下使用TaskCompletionSource就没什么意义,但是如果是用其他方式实现的异步就意义非凡</p>
<p>一个很经典的例子在于,对于子线程中更新界面的控件效果,需要通过<code>Dispatcher.Invoke</code>来执行ui改动界面代码,即<code>Dispatcher.Invoke</code>对于子线程中的代码来说是异步的,这样实际上外部的代码是无法等待Dispatcher.Invoke中执行的代码结束才返回的结果的.这时候就可以<code>TaskCompletionSource</code>来实现等待异步结果的效果:案例如下:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面代码在子线程中执行</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">  Thread.Sleep(<span class="number">5000</span>);</span><br><span class="line">  TaskCompletionSource&lt;<span class="built_in">int</span>&gt; tcs = <span class="keyword">new</span>();</span><br><span class="line">  Dispatcher.Invoke(()=&gt;&#123;</span><br><span class="line">    ChooseWindow1 chooseWindow1 = <span class="keyword">new</span>();<span class="comment">//供用户选择一边的数字的窗口</span></span><br><span class="line">    chooseWindow1.ShowDialog();</span><br><span class="line">    </span><br><span class="line">    tcs.SetResult(chooseWindow1.Result);</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  Debug.Show(<span class="string">&quot;你的选择:&quot;</span>+<span class="keyword">await</span> tcs.Task);<span class="comment">//可以等待用户选择后才返回用户选择的结果!</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>即使是在异步编程模型使用本身,也可以使用TaskCompletionSource将某些返回值封装成可异步获取的结果,十分方便</p>
<h3 id="wpf异步编程的死锁避免"><a href="#wpf异步编程的死锁避免" class="headerlink" title="wpf异步编程的死锁避免"></a>wpf异步编程的死锁避免</h3><p>在默认情况下，<code>await</code> 会尝试在原始线程上下文（如UI线程或ASP.NET请求上下文）中恢复后续代码的执行。但在同步阻塞操作（如 <code>.Result</code> 或 <code>.GetAwaiter().GetResult()</code>或 <code>.Wait()</code>等等）中，如果原始线程正被阻塞等待异步任务完成，而异步任务又尝试返回到该线程继续执行，就会导致<strong>死锁</strong>。</p>
<p>如:在WinForm&#x2F;WPF的UI线程中调用 <code>task.Result</code>，而异步方法内部未使用 <code>ConfigureAwait(false)</code>。此时，UI线程被阻塞，但异步任务完成后需要返回到UI线程执行后续代码，两者相互等待，形成死锁</p>
<p>即使使用了<code>ConfigureAwait(false)</code>也不能在子线程中通过dispatcher调度到ui线程执行,这样也会导致死锁,如果不使用dispatcher当需要操作界面元素的时候又是不合理的,因此也不行</p>
<h2 id="多线程环境下的进度通知"><a href="#多线程环境下的进度通知" class="headerlink" title="多线程环境下的进度通知"></a>多线程环境下的进度通知</h2><p><code>Progress&lt;T&gt;</code>对象继承自<code>IProgress&lt;T&gt;</code>接口</p>
<ul>
<li>是.NET框架的标准接口,位于System命名空间中</li>
<li>专门用于异步操作中的进度报告(实际上是可以用于多线程,不仅仅是异步编程)</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Button_Click</span>(<span class="params"><span class="built_in">object</span> sender,RoutedEventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	button.IsEnabled = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">//value=&gt; progressBar.Value = value 就是每次Report会做的事情</span></span><br><span class="line">  <span class="keyword">var</span> progress = <span class="keyword">new</span> Progress&lt;<span class="built_in">double</span>&gt;(<span class="keyword">value</span>=&gt; progressBar.Value = <span class="keyword">value</span>);</span><br><span class="line">  <span class="keyword">await</span> DoJobAsync(progress);</span><br><span class="line">  button.IsEnabled = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里传进来的是IProgress接口的意义在于,隐藏除了Report之外的其他没有意义的成员</span></span><br><span class="line"><span class="function"><span class="keyword">async</span> Task <span class="title">DoJobAsync</span>(<span class="params">IProgress&lt;<span class="built_in">double</span>&gt; progress</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">await</span> Task.Delay(<span class="number">50</span>).ConfigureAwait(<span class="literal">false</span>);<span class="comment">//执行完成后不会回到ui线程上,也可以正常执行下面的progress.Report(i);</span></span><br><span class="line">    progress.Report(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Report的内部原理是在new他本身的线程上下文中去执行new他时传递的操作参数</strong></p>
<p>除此之外,<code>progress.ProgressChanged+=</code>可以注册事件,在每次被Report的时候,同时也调用这个事件</p>
<p>Progress中存在OnReport函数,可以被重写,该函数是Report被调用的时候首先会执行的函数</p>
<p>IProgress才可以调用Report函数,Progress对象如果需要调用Report函数需要转换为IProgress接口</p>
<h2 id="Invoke与BeginInvoke"><a href="#Invoke与BeginInvoke" class="headerlink" title="Invoke与BeginInvoke"></a>Invoke与BeginInvoke</h2><p>可以参考<a href="#cSharp%E7%AA%97%E5%8F%A3ui%E7%BA%BF%E7%A8%8B%E9%98%B2%E5%A0%B5%E5%A1%9E">c#窗口ui线程防堵塞</a>,参考特定于Windows窗体控件的线程安全方法,使用方式类似</p>
<h3 id="Delegate-Invoke"><a href="#Delegate-Invoke" class="headerlink" title="Delegate.Invoke"></a>Delegate.Invoke</h3><p>Delegate.Invoke是同步的方法，会卡住调用它的UI线程。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">TestDelegateInvoke</span>()</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DelegateInvokeMethod</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">        Thread.Sleep(<span class="number">5000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">btn_DelegateInvoke_Click</span>(<span class="params"><span class="built_in">object</span> sender , EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        TestDelegateInvoke testDelegate = <span class="keyword">new</span> TestDelegateInvoke(DelegateInvokeMethod);</span><br><span class="line">        testDelegate.Invoke();</span><br><span class="line">              <span class="comment">//testDelegate();跟这样没什么区别</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Delegate.Invoke</code>是用于委托的通用调用，而<code>Control.Invoke</code>是一个特定于Windows窗体控件的线程安全方法，用于跨线程操作界面元素。如果你不需要处理多线程的UI更新，那么你可能不会使用到<code>Control.Invoke</code>。</p>
<h3 id="Delegate-BeginInvoke"><a href="#Delegate-BeginInvoke" class="headerlink" title="Delegate.BeginInvoke"></a>Delegate.BeginInvoke</h3><p>在C#中，委托提供了<code>BeginInvoke</code>方法来启动委托的异步执行。这是.NET Framework中实现异步编程的早期方式之一（在<code>Task</code>并发模型出现之前）。通过委托的<code>BeginInvoke</code>方法，您可以在另一个线程上异步执行委托指向的方法，而不会阻塞当前线程。</p>
<p>简单案例</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义委托</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">BinaryOperation</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 委托指向的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步执行委托</span></span><br><span class="line">BinaryOperation op = <span class="keyword">new</span> BinaryOperation(Add);</span><br><span class="line">IAsyncResult asyncResult = op.BeginInvoke(<span class="number">2</span>, <span class="number">3</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里可以执行其他工作...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待异步操作完成并获取结果</span></span><br><span class="line"><span class="built_in">int</span> result = op.EndInvoke(asyncResult);</span><br></pre></td></tr></table></figure>

<p>尽管委托的Invoke和BeginInvoke方法仍然可用，但在新的开发中，通常建议使用[基于Task的模式](#CSharp 异步编程模型)，因为它提供了更简单、更可靠的异步编程体验。</p>
<p>在这个示例中，我们定义了一个名为<code>BinaryOperation</code>的委托，它接受两个<code>int</code>参数并返回一个<code>int</code>结果。接着，我们创建了这个委托的实例<code>op</code>并将其与<code>Add</code>方法绑定。然后，我们使用<code>BeginInvoke</code>来异步调用这个委托。</p>
<p><code>BeginInvoke</code>方法的参数与委托的签名相匹配，外加两个额外的参数：一个是<code>AsyncCallback</code>委托，用于指定一个回调方法，另一个是一个<code>object</code>类型的状态对象。在这个示例中，我们没有使用回调，所以传递了<code>null</code>。</p>
<p>当异步执行完成后，可以通过调用委托的<code>EndInvoke</code>方法来获取结果。<code>EndInvoke</code>方法接受一个<code>IAsyncResult</code>接口作为参数，这个参数是<code>BeginInvoke</code>方法返回的。</p>
<h2 id="CSharp-Task"><a href="#CSharp-Task" class="headerlink" title="CSharp Task"></a>CSharp Task</h2><p>Task是.NET4.0加入的，跟线程池ThreadPool的功能类似，用Task开启新任务时，会从线程池中调用线程，而Thread每次实例化都会创建一个新的线程。</p>
<p> 我们可以说Task是一种基于任务的编程模型。它与thread的主要区别是，它更加方便对线程进程调度和获取线程的执行结果。</p>
<p><code>Task</code>类和<code>Task&lt;TResult&gt;</code>类</p>
<ul>
<li>前者接收的是<code>Action</code>委托类型</li>
<li>后者接收的是<code>Func&lt;TResult&gt;</code>委托类型</li>
</ul>
<p>任务和线程的区别：</p>
<ol>
<li>任务是架构在线程之上的，也就是说任务最终还是要抛给线程去执行。</li>
<li>任务跟线程不是一对一的关系，比如开10个任务并不是说会开10个线程，这一点任务有点类似线程池，但是任务相比线程池有很小的开销和精确的控制。</li>
</ol>
<blockquote>
<p>什么是异步任务(Task)</p>
<ol>
<li>包含了对异步任务的各种状态的一个引用类型<ul>
<li>正在运行,完成,结果,报错等</li>
</ul>
</li>
<li>对于异步任务的抽象<ul>
<li>开启异步任务后,当前线程不会被阻塞,而是可以做其他事情</li>
<li>异步任务(默认)会借助线程池在其他线程上运行</li>
<li>获取结果后回到之前的状态</li>
</ul>
</li>
</ol>
</blockquote>
<p>最好使用[CSharp 异步编程模型](#CSharp 异步编程模型)</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">LoadDataAsync</span>()</span></span><br><span class="line"> &#123;</span><br><span class="line">     Task.Run(() =&gt;</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="comment">//子线程中执行,可以使用主线程中的变量,但要注意是否需要锁</span></span><br><span class="line">         <span class="keyword">var</span> allEvents = EventInfoRepository.GetAll();</span><br><span class="line">         <span class="keyword">return</span> allEvents;</span><br><span class="line">     &#125;).ContinueWith(task =&gt;</span><br><span class="line">     &#123;</span><br><span class="line">            <span class="comment">//主线程中执行的回调函数,子线程运行完后由主线程回调,并且可以得到子线程执行完成传回来的返回值</span></span><br><span class="line">         <span class="keyword">var</span> allEvents = task.Result;</span><br><span class="line">         ViewSource = CollectionViewSource.GetDefaultView(allEvents.ToList());</span><br><span class="line">         ViewSource.Refresh();</span><br><span class="line">     &#125;,TaskScheduler.FromCurrentSynchronizationContext());</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//TaskScheduler.FromCurrentSynchronizationContext()可以让ContinueWith在ui线程上执行</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">async</span> <span class="keyword">void</span> <span class="title">LoadUsersAsync</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> allUsers = <span class="keyword">await</span> Task.Run(() =&gt; UserInfoRepository.GetAll());</span><br><span class="line">      <span class="comment">// 将代码调度到UI线程上执行</span></span><br><span class="line">    System.Windows.Application.Current.Dispatcher.Invoke(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        UserList = allUsers;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>UI线程相关解释</strong></p>
<blockquote>
<p><code>TaskScheduler.FromCurrentSynchronizationContext()</code>方法返回与当前<a href="#%E5%90%8C%E6%AD%A5%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E7%90%86%E8%A7%A3">同步上下文</a>关联的任务调度程序。在理解这个方法在<code>Task.Run</code>中的作用之前，让我们先介绍一下同步上下文和任务调度程序的概念：</p>
<ol>
<li><p>同步上下文</p>
<p>：</p>
<ul>
<li>同步上下文是一个抽象概念，用于跟踪和管理代码执行的上下文环境。在UI应用程序中，同步上下文通常与UI线程关联，用于确保UI操作在UI线程上执行。</li>
</ul>
</li>
<li><p>任务调度程序</p>
<p>：</p>
<ul>
<li>任务调度程序用于管理和调度任务的执行。不同的任务调度程序可以决定任务在何时何地执行，例如在线程池中执行、在UI线程上执行等。</li>
</ul>
</li>
</ol>
<p>现在，让我们来解释<code>TaskScheduler.FromCurrentSynchronizationContext()</code>在<code>Task.Run</code>中的作用：</p>
<ul>
<li>在UI应用程序中，通常需要确保UI操作在UI线程上执行，以避免UI线程阻塞或出现线程安全问题。</li>
<li>当您在UI线程上启动一个任务（例如使用<code>Task.Run</code>），默认情况下，任务会在线程池中执行，而不是在UI线程上执行。</li>
<li>通过使用<code>TaskScheduler.FromCurrentSynchronizationContext()</code>方法，您可以获取当前同步上下文关联的任务调度程序，从而将任务调度到与UI线程关联的同步上下文中执行。</li>
<li>这样可以确保任务在UI线程上执行，避免了UI操作的线程安全问题。</li>
</ul>
</blockquote>
<p>Application.Current.Dispatcher详解</p>
<blockquote>
<p><code>Application.Current.Dispatcher</code>是在WPF应用程序中用于访问UI线程调度程序（Dispatcher）的静态属性。在WPF中，UI元素通常只能在创建它们的UI线程上进行更新和操作，以确保UI的响应性和避免线程安全问题。<code>Dispatcher</code>类提供了一种在UI线程上执行代码的机制，而<code>Application.Current.Dispatcher</code>允许您访问当前应用程序的UI线程调度程序。</p>
<p>以下是关于<code>Application.Current.Dispatcher</code>的一些详解：</p>
<ol>
<li><strong>UI线程调度程序（Dispatcher）</strong>：<ul>
<li><code>Dispatcher</code>是一个用于调度和执行代码的类，它负责将操作调度到与其关联的线程上执行。在WPF应用程序中，每个UI线程都有一个关联的<code>Dispatcher</code>对象，用于管理UI元素的更新和操作。</li>
</ul>
</li>
<li><strong>Application.Current</strong>：<ul>
<li><code>Application.Current</code>是一个静态属性，用于获取当前正在运行的应用程序实例。通过<code>Application.Current</code>可以访问当前应用程序的各种属性和方法，包括UI线程的调度程序。</li>
</ul>
</li>
<li><strong>Dispatcher.Invoke和Dispatcher.BeginInvoke</strong>：<ul>
<li><code>Dispatcher</code>类提供了<code>Invoke</code>和<code>BeginInvoke</code>等方法，用于将操作调度到与其关联的线程上执行。<code>Invoke</code>是同步执行操作，会阻塞调用线程直到操作完成，而<code>BeginInvoke</code>是异步执行操作，不会阻塞调用线程。</li>
</ul>
</li>
</ol>
<p>通过使用<code>Application.Current.Dispatcher</code>，您可以在任何地方访问当前应用程序的UI线程调度程序，从而确保在需要在UI线程上执行代码时，能够正确地调度操作。这对于在异步操作完成后更新UI或在后台线程中执行UI操作非常有用。</p>
</blockquote>
<p><code>await Task.Run</code> 可以等待线程执行完再执行</p>
<h3 id="Task相关方法盘点"><a href="#Task相关方法盘点" class="headerlink" title="Task相关方法盘点"></a>Task相关方法盘点</h3><p><strong>创建任务</strong></p>
<ul>
<li><p><strong>Task.Run</strong>：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Task task = Task.Run(() =&gt; &#123; <span class="comment">/* 执行的代码 */</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>用于在线程池中启动一个新任务。<code>Task.Run</code> 与调用async方法并非马上调用线程切换不同,会导致立即的线程切换，因为它会在不同的线程上执行任务。</p>
</li>
<li><p><strong>Task.Factory.StartNew</strong>：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Task task = Task.Factory.StartNew(() =&gt; &#123; <span class="comment">/* 执行的代码 */</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>也是用于创建并启动一个新任务，具有更多的配置选项。</p>
</li>
<li><p><strong>Task.FromResult</strong>：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Task&lt;<span class="built_in">int</span>&gt; task = Task.FromResult(<span class="number">42</span>);</span><br></pre></td></tr></table></figure>

<p>创建一个已完成的任务，返回指定的结果。</p>
</li>
</ul>
<p><strong>组合任务</strong></p>
<ul>
<li><p><strong>Task.WhenAll</strong>：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Task.WhenAll(task1, task2, task3);</span><br></pre></td></tr></table></figure>

<p>接受多个任务并返回一个新的任务，该任务在所有传入任务完成时完成。可以用于并行执行多个异步操作。</p>
</li>
<li><p><strong>Task.WhenAny</strong>：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Task.WhenAny(task1, task2, task3);</span><br></pre></td></tr></table></figure>

<p>接受多个任务并返回一个新的任务，该任务在任意一个传入任务完成时完成。</p>
</li>
</ul>
<p><strong>任务状态</strong></p>
<ul>
<li><p><strong>Task.Status</strong>：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Task task = Task.Run(() =&gt; &#123; <span class="comment">/* 执行的代码 */</span> &#125;);</span><br><span class="line"><span class="keyword">var</span> status = task.Status; <span class="comment">// 获取任务的状态</span></span><br></pre></td></tr></table></figure>

<p>返回任务的当前状态（如 <code>RanToCompletion</code>, <code>Faulted</code>, <code>Canceled</code> 等）。</p>
</li>
</ul>
<p><strong>处理异常</strong></p>
<ul>
<li><p><strong>Task.Exception</strong>：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">await</span> task;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (AggregateException ex)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果任务失败，<code>Exception</code> 属性将包含导致失败的异常。</p>
</li>
</ul>
<p><strong>取消任务</strong></p>
<ul>
<li><p><strong>CancellationToken</strong>：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CancellationTokenSource cts = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line">Task task = Task.Run(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 检查是否已请求取消</span></span><br><span class="line">    cts.Token.ThrowIfCancellationRequested();</span><br><span class="line">&#125;, cts.Token);</span><br></pre></td></tr></table></figure>

<p>使用 <code>CancellationToken</code> 允许你在任务中响应取消请求。</p>
</li>
</ul>
<p><strong>继续任务</strong></p>
<ul>
<li><p><strong>ContinueWith</strong>：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Task task = Task.Run(() =&gt; &#123; <span class="comment">/* 执行的代码 */</span> &#125;);</span><br><span class="line">task.ContinueWith(t =&gt; &#123; <span class="comment">/* 继续的代码 */</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>在任务完成后执行后续操作。</p>
</li>
</ul>
<p><strong>异步等待</strong></p>
<ul>
<li><p><strong>Task.Delay</strong>：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> Task.Delay(<span class="number">1000</span>); <span class="comment">// 等待1秒</span></span><br></pre></td></tr></table></figure>

<p>创建一个任务，该任务在指定的时间后完成。</p>
<p><strong>其他有用的方法</strong></p>
</li>
<li><p><strong>Task.Wait</strong>：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">task.Wait(); <span class="comment">// 阻塞当前线程，直到任务完成</span></span><br></pre></td></tr></table></figure>

<p>等待任务完成。</p>
</li>
<li><p><strong>Task.WaitAll</strong>：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Task.WaitAll(task1, task2); <span class="comment">// 阻塞当前线程，直到所有任务完成</span></span><br></pre></td></tr></table></figure>

<p>等待所有任务完成。</p>
</li>
</ul>
<h3 id="需要更细粒度的控制"><a href="#需要更细粒度的控制" class="headerlink" title="需要更细粒度的控制"></a>需要更细粒度的控制</h3><p>使用<code>Task.Factory.StartNew</code></p>
<p>Task.Factory.StartNew提供了更多的灵活性和选项，例如可以指定TaskCreationOptions、TaskScheduler等参数来对任务进行更详细的控制。在一些需要更细粒度控制任务行为的场景下，可能会选择使用Task.Factory.StartNew。</p>
<blockquote>
<p>TaskScheduler可以指定任务的调度器,比如可以指定由UI线程调用</p>
<p>TaskCreationOptions是用于指定任务的创建选项的枚举类型。通过指定TaskCreationOptions，可以对任务的创建和执行行为进行一些控制和定制。</p>
<p>以下是一些常用的TaskCreationOptions选项：</p>
<ol>
<li>None：默认选项，表示不指定任何特殊的创建选项。</li>
<li>PreferFairness：指示任务调度器在选择下一个要执行的任务时，优先考虑公平性。</li>
<li>LongRunning：指示任务是一个长时间运行的任务，可以让任务调度器做出一些优化。</li>
<li>AttachedToParent：指示新任务将作为父任务的子任务运行，父任务完成时，子任务也会被取消。</li>
<li>DenyChildAttach：禁止将新任务作为父任务的子任务运行。</li>
</ol>
</blockquote>
<h3 id="Task-Delay"><a href="#Task-Delay" class="headerlink" title="Task.Delay"></a>Task.Delay</h3><p>在大多数情况下，使用 <code>await Task.Delay(200);</code> 都优于使用 <code>Thread.Sleep(200);</code>，无论是在 UI 线程还是其他线程中。这是因为 <code>await Task.Delay(200);</code> 和 <code>Thread.Sleep(200);</code> 在行为上有本质的不同，尤其是在资源管理和线程利用率方面。</p>
<ol>
<li><strong>资源利用和效率</strong></li>
</ol>
<ul>
<li><strong><code>Thread.Sleep(200);</code></strong><ul>
<li><strong>阻塞线程</strong>：当调用 <code>Thread.Sleep(200);</code> 时，当前线程将停止执行 200 毫秒。在这段时间内，线程不会做任何其他工作，只是处于等待状态。</li>
<li><strong>资源浪费</strong>：阻塞线程会占用系统资源（如线程栈和上下文信息），尽管它在 <code>Sleep</code> 期间不消耗 CPU 时间。</li>
</ul>
</li>
<li><strong><code>await Task.Delay(200);</code></strong><ul>
<li><strong>非阻塞等待</strong>：<code>Task.Delay(200);</code> 返回一个未完成的任务，而 <code>await</code> 关键字会使方法异步等待该任务的完成。这种等待不会阻塞线程，允许操作系统将该线程的资源调度给其他任务。</li>
<li><strong>资源释放</strong>：因为线程不被阻塞，所以可以释放资源以供其他任务使用，提高资源利用率和系统的整体响应性。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>在 UI 线程中的表现</strong></li>
</ol>
<ul>
<li><code>Thread.Sleep(200);</code><ul>
<li>在 UI 线程中使用 <code>Thread.Sleep</code> 会冻结用户界面，因为 UI 线程被阻塞，无法处理其他事件或更新界面。</li>
</ul>
</li>
<li><code>await Task.Delay(200);</code><ul>
<li>在 UI 线程中使用 <code>await Task.Delay</code> 不会阻塞 UI 线程。<code>await</code> 关键字会在任务完成时自动恢复执行上下文（例如 UI 线程），这确保了界面的响应性和流畅性。</li>
</ul>
</li>
</ul>
<ol start="3">
<li><strong>上下文恢复</strong></li>
</ol>
<ul>
<li><strong><code>Thread.Sleep(200);</code></strong><ul>
<li>没有上下文恢复的概念，因为它完全阻塞线程。</li>
</ul>
</li>
<li><strong><code>await Task.Delay(200);</code></strong><ul>
<li>当任务完成后，<code>await</code> 会尝试在原始同步上下文中恢复执行，例如在 UI 应用中，这意味着任务会在 UI 线程上继续执行。这对于保持 UI 操作的顺序性和一致性非常重要。</li>
</ul>
</li>
</ul>
<p>总结</p>
<p>在绝大多数情况下，<code>await Task.Delay(200);</code> 是更好的选择，因为它允许线程在等待期间执行其他操作，提高了应用程序的整体效率和响应性。特别是在 UI 应用中，这种方法能够避免界面冻结，提供更好的用户体验。唯一可能的例外是在极少数需要精确控制线程行为的场景下，但这种情况通常非常罕见且特定。</p>
<p><code>await Task.Delay(200);</code> 不会面临创建线程的开销，这是它的一个重要优势。要理解这一点，我们需要深入了解 <code>Task.Delay</code> 的内部工作原理以及异步编程模型。</p>
<p>Task.Delay 的工作原理</p>
<p><code>Task.Delay(200)</code> 返回一个 <code>Task</code> 对象，这个任务会在 200 毫秒后完成。关键点在于，它不创建新的线程来处理这个延迟。相反，<code>Task.Delay</code> 通过以下机制来实现延迟：</p>
<ol>
<li><strong>基于定时器的延迟</strong>： <code>Task.Delay</code> 实际上是使用系统的定时器机制来管理延迟。它会请求操作系统在 200 毫秒后触发一个事件，这个事件会使 <code>Task</code> 状态变为已完成。因此，不需要线程来等待这个时间，只需一个定时器来完成这一操作。</li>
<li><strong>非阻塞等待</strong>： 当你使用 <code>await Task.Delay(200)</code> 时，当前方法的执行会被挂起，但这不会阻塞线程。相反，<code>await</code> 会将控制权返回给调用者，线程可以继续处理其他工作或进入空闲状态。直到 200 毫秒后，系统会发出一个信号，使得 <code>Task</code> 完成，然后 <code>await</code> 会恢复方法的执行。</li>
</ol>
<p>与线程相关的开销</p>
<ul>
<li><strong>不创建线程</strong>： <code>Task.Delay</code> 不涉及线程创建。它利用系统的定时器机制来处理延迟，而不需要额外的线程资源。这与 <code>Thread.Sleep</code> 不同，<code>Thread.Sleep</code> 需要阻塞当前线程，无法利用系统定时器的非阻塞机制。</li>
<li><strong>轻量级操作</strong>： <code>Task.Delay</code> 的实现是轻量级的，因为它只需注册一个定时器，而不涉及线程调度或上下文切换开销。这使得它非常适合用于异步编程模型中，能够有效地管理延迟而不会增加不必要的开销。</li>
</ul>
<p>异步编程模型的优势</p>
<ul>
<li><strong>响应性</strong>： 通过使用 <code>await</code> 和 <code>Task.Delay</code>，你可以保持应用程序的响应性，特别是在需要处理 I&#x2F;O 操作或长时间运行的任务时。例如，在 UI 应用程序中，<code>await Task.Delay</code> 允许 UI 线程处理其他用户输入事件，而不是冻结界面。</li>
<li><strong>资源利用</strong>： 异步编程模型能够更有效地利用系统资源。与阻塞线程相比，异步方法可以让线程在等待期间处理其他任务，提高了系统的并发性能。</li>
</ul>
<p>总结</p>
<p><code>await Task.Delay(200);</code> 是一种非阻塞的延迟实现方式，不涉及额外的线程创建开销。它利用系统定时器机制和异步编程模型来管理延迟，使得在等待期间线程可以自由地处理其他任务。这是它在异步编程中相比 <code>Thread.Sleep</code> 更具优势的原因。</p>
<blockquote>
<p>C++新版本中提供了协程机制,这是一种更接近于异步编程模型的机制，能够更优雅地处理异步操作。协程可以暂停执行，直到某个操作完成，类似于 C# 中的 <code>await</code>。</p>
<p>也提供了<code>std::async</code> 和 <code>std::future</code>,一种简单的异步编程方式，能够启动异步任务并获得结果。虽然它主要用于并行计算，但也可以用于执行延迟任务.这虽然不是完全类似于 C# 的 <code>async</code>&#x2F;<code>await</code>，但在许多情况下可以达到类似的效果。</p>
<p>C++有更强大的异步库,如<strong>Boost.Asio</strong>,但是复杂性比较高</p>
</blockquote>
<h2 id="Parallel-For"><a href="#Parallel-For" class="headerlink" title="Parallel.For"></a>Parallel.For</h2><p><code>Parallel.For</code>是.NET Framework中用于并行循环的功能，它允许在多个线程上并行执行循环迭代，从而提高循环的执行效率。以下是关于<code>Parallel.For</code>的详解：</p>
<p><strong>工作原理</strong></p>
<ul>
<li><code>Parallel.For</code>会将循环的迭代分配给多个线程，每个线程负责处理一部分迭代。</li>
<li>循环迭代的分配和同步由并行任务调度器（Task Scheduler）负责管理。</li>
<li>并行执行的迭代不一定按照顺序执行，因此<strong>需要注意并行执行可能会改变迭代的顺序</strong>。</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Parallel.For(startIndex, endIndex, (i) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 循环体内的代码，i为当前迭代的索引</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>startIndex</code>：循环的起始索引。</li>
<li><code>endIndex</code>：循环的结束索引（不包含）。</li>
<li>循环体内的代码会在多个线程上并行执行。</li>
</ul>
<p><strong>控制并行度</strong></p>
<ul>
<li>可以通过<code>ParallelOptions</code>类中的<code>MaxDegreeOfParallelism</code>属性来控制并行度，即同时执行的线程数量。</li>
<li>默认情况下，<code>Parallel.For</code>会根据系统的处理器数量来确定并行度。</li>
</ul>
<p><strong>注意事项</strong></p>
<ul>
<li><strong>循环体内的代码应该是线程安全的</strong>，避免出现竞争条件。</li>
<li>避免在循环体内进行对共享资源的写操作，可以考虑使用<code>lock</code>或其他同步机制来保护共享资源。</li>
</ul>
<p><strong>适用场景</strong></p>
<ul>
<li>处理大量数据或计算密集型任务时，可以使用<code>Parallel.For</code>来提高处理效率。</li>
<li>在需要并行执行独立迭代的情况下，可以使用<code>Parallel.For</code>来并行化循环。</li>
</ul>
<p>通过合理使用<code>Parallel.For</code>，可以充分利用多核处理器的优势，加快循环的执行速度。但需要注意线程安全和并行度控制等问题，以确保并行执行的正确性和效率。</p>
<h2 id="CSharp-异步定时器"><a href="#CSharp-异步定时器" class="headerlink" title="CSharp 异步定时器"></a>CSharp 异步定时器</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建一个取消令牌源</span></span><br><span class="line">        CancellationTokenSource cts = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动异步定时器</span></span><br><span class="line">        <span class="keyword">var</span> timerTask = StartTimerAsync(<span class="number">1000</span>, cts.Token); <span class="comment">// 每1000毫秒（1秒）执行一次</span></span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;按任意键停止定时器...&quot;</span>);</span><br><span class="line">        Console.ReadKey();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取消定时器</span></span><br><span class="line">        cts.Cancel();</span><br><span class="line">        <span class="keyword">await</span> timerTask; <span class="comment">// 等待定时器任务完成</span></span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;定时器已停止。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">async</span> Task <span class="title">StartTimerAsync</span>(<span class="params"><span class="built_in">int</span> interval, CancellationToken token</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 等待指定的时间间隔</span></span><br><span class="line">                <span class="keyword">await</span> Task.Delay(interval, token);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 执行定时操作</span></span><br><span class="line">                Console.WriteLine(<span class="string">$&quot;当前时间: <span class="subst">&#123;DateTime.Now&#125;</span>&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (TaskCanceledException)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 处理任务被取消的情况</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;定时器任务被取消。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><h3 id="AutoResetEvent"><a href="#AutoResetEvent" class="headerlink" title="AutoResetEvent"></a>AutoResetEvent</h3><p>AutoResetEvent是.NET中的一个同步原语，用于线程间的同步和通信。它允许一个线程在某个事件发生时等待，而其他线程可以在事件发生时通知等待的线程继续执行。</p>
<p>AutoResetEvent有两个主要状态：有信号和无信号。</p>
<ul>
<li>当AutoResetEvent处于有信号状态时，等待的线程可以继续执行；</li>
<li>当AutoResetEvent处于无信号状态时，等待的线程将被阻塞，直到其他线程将其设置为有信号状态。</li>
</ul>
<p>下面是AutoResetEvent的一些主要成员方法和属性：</p>
<ul>
<li><code>WaitOne()</code>: 当AutoResetEvent处于无信号状态时，调用此方法会阻塞当前线程，直到AutoResetEvent被设置为有信号状态。</li>
<li><code>Set()</code>: 将AutoResetEvent设置为有信号状态，唤醒一个等待的线程。</li>
<li><code>Reset()</code>: 将AutoResetEvent设置为无信号状态。</li>
<li><code>WaitOne(int millisecondsTimeout)</code>: 在指定的超时时间内等待AutoResetEvent的信号。</li>
</ul>
<p>使用AutoResetEvent可以实现线程间的同步和协作，例如一个线程等待另一个线程完成某个任务后再继续执行。AutoResetEvent是多线程编程中常用的同步机制之一，可以帮助确保线程之间的顺序和协作。</p>
<p>除此之外还有如下用于解决不同情况的存在:</p>
<ol>
<li><p><code>ManualResetEvent</code>：ManualResetEvent与AutoResetEvent类似，但它在被设置为有信号状态后会一直保持该状态，直到调用Reset()方法将其恢复为无信号状态。适用于一次性事件通知的场景。</p>
</li>
<li><p><code>CountdownEvent</code>：CountdownEvent是一个倒计时事件，可以设置一个初始计数值，每次调用Signal()方法减少计数值，直到计数值为0时触发事件。适用于需要等待多个任务完成后再继续执行的场景。</p>
</li>
<li><p><code>TaskCompletionSource</code>：TaskCompletionSource是一个用于创建和控制异步任务的类，可以通过SetResult()方法设置任务完成的结果。适用于异步任务的协作和同步。</p>
</li>
<li><p><code>Monitor</code>类：Monitor类提供了基于锁的同步机制，可以使用lock关键字或Monitor类的方法来实现线程同步。适用于简单的线程同步场景。</p>
</li>
<li><p><code>Semaphore</code>类：Semaphore类是一个计数信号量，可以控制同时访问共享资源的线程数量。适用于限制并发访问的场景。</p>
</li>
</ol>
<h1 id="CSharp线程同步机制"><a href="#CSharp线程同步机制" class="headerlink" title="CSharp线程同步机制"></a>CSharp线程同步机制</h1><h2 id="CSharp读写锁"><a href="#CSharp读写锁" class="headerlink" title="CSharp读写锁"></a>CSharp读写锁</h2><p><strong>ReaderWriterLock</strong>是C#中用于同步访问共享资源的机制。它允许多个线程同时进行读取操作，但只允许一个线程进行写入操作。这种锁定机制提高了在读取操作远远多于写入操作的场景下的性能。</p>
<ul>
<li><strong>ReaderWriterLock</strong>适用于读多写少、写持续时间短的场景，提高了并发读的效率，写入时会阻塞所有读锁 。</li>
<li>它解决了并发读的性能问题，大大提高了数据并发访问的性能，只有在写入时才会阻塞所有读锁 。</li>
<li>在多线程环境下，选择合适的锁机制非常重要，ReaderWriterLock是一种在多读少写场景下非常高效的选择。</li>
</ul>
<p>缺点:</p>
<ol>
<li><strong>不支持递归锁</strong>：<code>ReaderWriterLock</code> 不支持递归锁，这意味着在同一个线程持有锁时，不允许再次获取锁。这可能在某些情况下导致不便，特别是在需要递归锁的情况下。</li>
<li><strong>性能相对较慢</strong>：相对于一些其他锁的类型，如 <code>Monitor</code>，<code>ReaderWriterLock</code> 可能在某些情况下速度较慢。有性能测试表明，<code>ReaderWriterLockSlim</code> 比 <code>ReaderWriterLock</code> 更快一倍，但它也有自己的限制。</li>
<li><strong>复杂性和潜在死锁</strong>：使用 <code>ReaderWriterLock</code> 可能引入额外的复杂性，需要谨慎使用，因为不正确的使用锁可能导致死锁和性能问题。需要仔细考虑何时以及如何使用这种锁，以确保安全性和性能。</li>
<li><strong>可能导致写饥饿</strong>：如果写操作频繁，读操作也频繁，那么写操作可能会一直等待，因为每次有读锁的线程时，写操作都无法获取写锁。</li>
</ol>
<blockquote>
<p>ReaderWriterLock 类：定义支持单个写线程和多个读线程的锁。</p>
<p>ReaderWriterLockSlim 类：表示用于管理资源访问的锁定状态，可实现多线程读取或进行独占式写入访问。</p>
</blockquote>
<h3 id="ReaderWriterLockSlim"><a href="#ReaderWriterLockSlim" class="headerlink" title="ReaderWriterLockSlim"></a>ReaderWriterLockSlim</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>EnterReadLock</strong>()</td>
<td>尝试进入读取模式锁定状态。</td>
</tr>
<tr>
<td>EnterUpgradeableReadLock()</td>
<td>尝试进入可升级模式读锁定状态。(锁升级指的是从<strong>读锁升级为写锁</strong>)</td>
</tr>
<tr>
<td><strong>EnterWriteLock</strong>()</td>
<td>尝试进入写入模式锁定状态。(可升级模式的读锁也使用这个函数升级)</td>
</tr>
<tr>
<td><strong>ExitReadLock</strong>()</td>
<td>减少读取模式的递归计数，并在生成的计数为 0（零）时退出读取模式。</td>
</tr>
<tr>
<td>ExitUpgradeableReadLock()</td>
<td>减少可升级模式的递归计数，并在生成的计数为 0（零）时退出可升级模式。</td>
</tr>
<tr>
<td><strong>ExitWriteLock</strong>()</td>
<td>减少写入模式的递归计数，并在生成的计数为 0（零）时退出写入模式。</td>
</tr>
<tr>
<td>TryEnterReadLock(Int32)</td>
<td>尝试进入读取模式锁定状态，可以选择整数超时时间。</td>
</tr>
<tr>
<td>TryEnterReadLock(TimeSpan)</td>
<td>尝试进入读取模式锁定状态，可以选择超时时间。</td>
</tr>
<tr>
<td>TryEnterUpgradeableReadLock(Int32)</td>
<td>尝试进入可升级模式锁定状态，可以选择超时时间。</td>
</tr>
<tr>
<td>TryEnterUpgradeableReadLock(TimeSpan)</td>
<td>尝试进入可升级模式锁定状态，可以选择超时时间。</td>
</tr>
<tr>
<td>TryEnterWriteLock(Int32)</td>
<td>尝试进入写入模式锁定状态，可以选择超时时间。</td>
</tr>
<tr>
<td>TryEnterWriteLock(TimeSpan)</td>
<td>尝试进入写入模式锁定状态，可以选择超时时间。</td>
</tr>
</tbody></table>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">int</span> lockTarget = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span>  ReaderWriterLockSlim rwLock= <span class="keyword">new</span> ReaderWriterLockSlim();</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">threadWriteFunc</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">      rwLock.EnterUpgradeableReadLock();</span><br><span class="line">      <span class="keyword">if</span> (lockTarget &gt; <span class="number">10</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        rwLock.EnterWriteLock();</span><br><span class="line">        Console.WriteLine(Thread.CurrentThread.ManagedThreadId + <span class="string">&quot;&gt;&gt;get write lock&quot;</span>);</span><br><span class="line">        lockTarget--;</span><br><span class="line">        rwLock.ExitWriteLock();</span><br><span class="line">      &#125;</span><br><span class="line">      rwLock.ExitUpgradeableReadLock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(rwLock.IsWriteLockHeld)</span><br><span class="line">        rwLock.ExitWriteLock();</span><br><span class="line">      <span class="keyword">if</span>(rwLock.IsUpgradeableReadLockHeld)</span><br><span class="line">        rwLock.ExitUpgradeableReadLock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以参考一个标准做法:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写入操作，先以可升级读锁开始</span></span><br><span class="line">rwLock.EnterUpgradeableReadLock();</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 检查是否需要写入</span></span><br><span class="line">    <span class="keyword">if</span> (需要写入的条件)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 升级到写锁</span></span><br><span class="line">        rwLock.EnterWriteLock();</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 执行写入操作</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            rwLock.ExitWriteLock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">    rwLock.ExitUpgradeableReadLock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以加上超时机制</p>
<h3 id="ReaderWriterLock"><a href="#ReaderWriterLock" class="headerlink" title="ReaderWriterLock"></a>ReaderWriterLock</h3><p>大多数情况下都是推荐 <a href="#ReaderWriterLockSlim">ReaderWriterLockSlim</a> 的，而且两者的使用方法十分接近。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>AcquireReaderLock(Int32)</td>
<td>使用一个 Int32 超时值获取读线程锁。</td>
</tr>
<tr>
<td>AcquireReaderLock(TimeSpan)</td>
<td>使用一个 TimeSpan 超时值获取读线程锁。</td>
</tr>
<tr>
<td>AcquireWriterLock(Int32)</td>
<td>使用一个 Int32 超时值获取写线程锁。</td>
</tr>
<tr>
<td>AcquireWriterLock(TimeSpan)</td>
<td>使用一个 TimeSpan 超时值获取写线程锁。</td>
</tr>
<tr>
<td>AnyWritersSince(Int32)</td>
<td>指示获取序列号之后是否已将写线程锁授予某个线程。</td>
</tr>
<tr>
<td>DowngradeFromWriterLock(LockCookie)</td>
<td>将线程的锁状态还原为调用 UpgradeToWriterLock(Int32) 前的状态。</td>
</tr>
<tr>
<td>ReleaseLock()</td>
<td>释放锁，不管线程获取锁的次数如何。</td>
</tr>
<tr>
<td>ReleaseReaderLock()</td>
<td>减少锁计数。</td>
</tr>
<tr>
<td>ReleaseWriterLock()</td>
<td>减少写线程锁上的锁计数。</td>
</tr>
<tr>
<td>RestoreLock(LockCookie)</td>
<td>将线程的锁状态还原为调用 ReleaseLock() 前的状态。</td>
</tr>
<tr>
<td>UpgradeToWriterLock(Int32)</td>
<td>使用一个 Int32 超时值将读线程锁升级为写线程锁。</td>
</tr>
<tr>
<td>UpgradeToWriterLock(TimeSpan)</td>
<td>使用一个 <code>TimeSpan</code> 超时值将读线程锁升级为写线程锁。</td>
</tr>
</tbody></table>
<h2 id="CSharp信号量"><a href="#CSharp信号量" class="headerlink" title="CSharp信号量"></a>CSharp信号量</h2><p><code>lock</code>不能与异步操作一起使用，因为它会阻止同步上下文的释放。应该使用异步锁代替，例如使用<code>SemaphoreSlim</code>。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> SemaphoreSlim _semaphore = <span class="keyword">new</span> SemaphoreSlim(<span class="number">1</span>, <span class="number">1</span>);<span class="comment">//初始化 表示最初只有一个线程可以访问共享资源,并且最大只允许一个线程访问共享资源</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//进入临界区</span></span><br><span class="line"><span class="keyword">await</span> _semaphore.WaitAsync();</span><br><span class="line"><span class="comment">//离开临界区</span></span><br><span class="line">_semaphore.Release();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//加上超时的做法,还未测试</span></span><br><span class="line"><span class="comment">//添加超时时间1秒</span></span><br><span class="line"><span class="keyword">var</span> lockAcquired = <span class="keyword">await</span> _semaphore.WaitAsync(TimeSpan.FromSeconds(<span class="number">1</span>))</span><br><span class="line"><span class="comment">// 离开临界区，确保只有在获取到锁的情况下才释放</span></span><br><span class="line">  <span class="keyword">if</span>(lockAcquired)</span><br><span class="line">          _semaphore.Release();</span><br></pre></td></tr></table></figure>

<h1 id="CSharp-手动垃圾回收"><a href="#CSharp-手动垃圾回收" class="headerlink" title="CSharp 手动垃圾回收"></a>CSharp 手动垃圾回收</h1><p>在.NET的环境中，托管的资源都将由.NET的垃圾回收机制来释放，而一些非托管的资源则需要程序员手动地将它们释放。</p>
<blockquote>
<p>非托管资源是指在垃圾回收器管理下不能自动释放的资源。这意味着当不再需要非托管资源时，需要手动调用其Dispose()方法来释放它所占用的内存。常见的非托管资源有：</p>
<ol>
<li>操作系统资源：如文件句柄、进程句柄、线程句柄等。</li>
<li>COM对象：使用COM互操作时所涉及的对象。</li>
<li>外部设备资源：如串行端口、网络套接字等。</li>
<li>非托管代码资源：通过P&#x2F;Invoke调用的非托管代码或第三方库。</li>
<li>数据库连接资源：与数据库交互时所使用的连接对象。</li>
<li>图形设备接口资源：与图形设备交互时所用到的资源。</li>
<li>其他需要手动分配和释放内存的资源。</li>
</ol>
<p><strong>但注意这里指的是原生的,C#提供的那些封装库都是托管的,比如说SerialPort,Stream,TcpClient,TcpServer是托管的</strong></p>
</blockquote>
<p>.NET提供了主动和被动两种释放非托管资源的方式，即</p>
<ul>
<li>IDisposable接口的Dispose方法</li>
<li>类型自己的Finalize方法。</li>
</ul>
<p>任何带有非托管资源的类型，都有必要实现IDisposable的Dispose方法，并且在使用完这些类型后需要手动地调用对象的Dispose方法来释放对象中的非托管资源。</p>
<p>如果类型正确地实现了Finalize方法，那么即使不调用Dispose方法，非托管资源也最终会被释放，但那时资源已经被很长时间无谓地占据了。</p>
<blockquote>
<p><code>using </code>语句用于<strong>管理非托管资源（如文件句柄、数据库连接等）的释放</strong></p>
</blockquote>
<p><code>using</code>语句的作用就是提供了一个高效的调用对象Dispose方法的方式。对于任何IDisposable接口的类型，都可以使用using语句，而对于那些没有实现IDisposable接口的类型，使用using语句会导致一个编译错误。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span>(StreamWriter sw= <span class="keyword">new</span> StreamWriter())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 中间处理逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>using语句一开始定义了一个StreamWriter的对象，之后在整个语句块中都可以使用sw，在using语句块结束的时候，sw的Dispose方法将会被自动调用。using语句不仅免除了程序员输入Dispose调用的代码，它还<strong>提供了机制保证Dispose方法被调用，无论using语句块顺利执行结束，还是抛出了一个异常</strong>。下面的代码演示了using的这一保护机制。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">usingDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 使用using</span></span><br><span class="line">                <span class="keyword">using</span> (MyDispose md = <span class="keyword">new</span> MyDispose())</span><br><span class="line">                &#123;</span><br><span class="line">                    md.DoWork();</span><br><span class="line">                    <span class="comment">// 抛出一个异常来测试using</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;抛出一个异常&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span></span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.ReadKey();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 继承自IDisposable接口，仅仅用来做测试，不使用任何非托管资源</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyDispose</span> : <span class="title">IDisposable</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Dispose方法被调用&quot;</span>);</span><br><span class="line">          <span class="comment">//在此处做回收工作</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoWork</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;做了很多工作&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出:</span></span><br><span class="line"><span class="comment">//做了很多工作</span></span><br><span class="line"><span class="comment">//Dispose方法被调用</span></span><br></pre></td></tr></table></figure>

<p>事实上，C#编译器为using语句自动添加了try&#x2F;finally块，所以Dispose方法能够保证被调用到，所以如下两段代码经过编译后内容将完全一致：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (MyDispose md = <span class="keyword">new</span> MyDispose())</span><br><span class="line">&#123;</span><br><span class="line">      md.DoWork();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//与下面完全一致</span></span><br><span class="line">MyDispose md;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    md = <span class="keyword">new</span> MyDispose();</span><br><span class="line">    md.DoWork();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">    md.Dispose();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>应该注意一点使用using时常犯的错误，那就是千万不要试图在using语句块外初始化对象</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MyDispose md = <span class="keyword">new</span> MyDispose();</span><br><span class="line"><span class="keyword">using</span> (md)</span><br><span class="line">&#123;</span><br><span class="line">    md.DoWork();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="CSharp中的代码块"><a href="#CSharp中的代码块" class="headerlink" title="CSharp中的代码块"></a>CSharp中的代码块</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">region</span> xxxxxx</span></span><br><span class="line">  <span class="comment">//代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">endregion</span></span></span><br></pre></td></tr></table></figure>

<p>这样就形成了可以折叠的代码块</p>
<h1 id="visual-studio开发环境相关"><a href="#visual-studio开发环境相关" class="headerlink" title="visual studio开发环境相关"></a>visual studio开发环境相关</h1><h2 id="官方组件"><a href="#官方组件" class="headerlink" title="官方组件"></a>官方组件</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u014361280/article/details/116428050">类设计器参考</a></p>
<p>可以图形化查看类结构</p>
<h2 id="重构技巧盘点"><a href="#重构技巧盘点" class="headerlink" title="重构技巧盘点"></a>重构技巧盘点</h2><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p>展开所有代码块: ctrl+k,ctrl+j</p>
<p>折叠所有代码块: ctrl+k,ctrl+0</p>
<h3 id="上下文菜单妙用"><a href="#上下文菜单妙用" class="headerlink" title="上下文菜单妙用"></a>上下文菜单妙用</h3><p><code>alt+enter</code>可以打开上下文菜单</p>
<h4 id="数值进制转换"><a href="#数值进制转换" class="headerlink" title="数值进制转换"></a>数值进制转换</h4><p>vs中可以直接进行数值进制的转换,打开上下文菜单,转换数字</p>
<h4 id="引入常量-引入局部变量-引入参数"><a href="#引入常量-引入局部变量-引入参数" class="headerlink" title="引入常量&#x2F;引入局部变量&#x2F;引入参数"></a>引入常量&#x2F;引入局部变量&#x2F;引入参数</h4><p>可以将某个变量提取到常量&#x2F;局部变量&#x2F;参数</p>
<h4 id="提取接口-基类"><a href="#提取接口-基类" class="headerlink" title="提取接口&#x2F;基类"></a>提取接口&#x2F;基类</h4><p>可以针对一个类打开上下文菜单,可以选择 提取接口&#x2F;提取基类&#x2F;移动到命名空间等等</p>
<p>在一个现有类上生成接口,并移动到想让他去的地方</p>
<h3 id="选择性黏贴"><a href="#选择性黏贴" class="headerlink" title="选择性黏贴"></a>选择性黏贴</h3><p>编辑-选择性黏贴-将JSON粘贴为类&#x2F;将XML粘贴为类</p>
<h3 id="显示结构"><a href="#显示结构" class="headerlink" title="显示结构"></a>显示结构</h3><p>右键-注释-显示结构</p>
<p>快捷键为: <code>ctrl+K,ctrl+G</code></p>
<p>可以显示当前的代码结构的所有外部结构的层次结构</p>
<p>在vscode中直接查看大纲</p>
<p>可以使用 ctrl+shift+O 快速在成员中跳转</p>
<h3 id="新建解决方案资源管理器视图"><a href="#新建解决方案资源管理器视图" class="headerlink" title="新建解决方案资源管理器视图"></a>新建解决方案资源管理器视图</h3><p>可以在创建一个局部的解决方案资源管理器</p>
<h2 id="插件相关"><a href="#插件相关" class="headerlink" title="插件相关"></a>插件相关</h2><p>下载插件位置:visual studio菜单中-拓展-管理拓展-Visual Studio Marketplace</p>
<h3 id="简易插件"><a href="#简易插件" class="headerlink" title="简易插件"></a>简易插件</h3><ul>
<li>Viasfora 括号颜色配对</li>
<li>VSColorOutput  输出栏多颜色显示</li>
<li><a target="_blank" rel="noopener" href="https://marketplace.visualstudio.com/items?itemName=SamirBoulema.CodeNav">CodeNav 代码导航</a>  (实测占用有点高)</li>
</ul>
<h3 id="CodeRush"><a href="#CodeRush" class="headerlink" title="CodeRush"></a>CodeRush</h3><p><a target="_blank" rel="noopener" href="https://marketplace.visualstudio.com/items?itemName=DevExpress.CodeRushforRoslyn">插件CodeRush下载地址</a></p>
<ol>
<li><p>Code Template Expansion   按下空格  代码模板展开</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ps<span class="comment">//-&gt;按下空格   </span></span><br><span class="line"><span class="comment">//转换为如下:</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> xxxxxx&#123;</span><br><span class="line">    <span class="keyword">get</span>&#123;<span class="keyword">return</span> xxxx;&#125;</span><br><span class="line">  <span class="keyword">set</span>&#123;xxxxx=<span class="keyword">value</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Tab键可以在跳到选中目标的下一个引用</p>
</li>
<li><p>拼写检查</p>
</li>
<li><p>调试可视化   可直接在复合表达式上看到他的值</p>
</li>
<li><p>一键选择嵌入功能  允许选中部分代码,通过按如下键一键用下面框架包裹住选中代码 (默认未启用)</p>
<ul>
<li><code>b</code> 尖括号</li>
<li><code>c</code> try&#x2F;catch块</li>
<li><code>f</code> try&#x2F;finally块</li>
<li><code>t</code> try&#x2F;catch&#x2F;finally块</li>
</ul>
</li>
<li><p>大写键+空格添加修饰符 (默认未启用)</p>
</li>
</ol>
<h3 id="CodeGeeX"><a href="#CodeGeeX" class="headerlink" title="CodeGeeX"></a>CodeGeeX</h3><p>ai补全+聊天插件</p>
<p><a target="_blank" rel="noopener" href="https://codegeex.cn/">插件网页</a></p>
<p>优势:</p>
<ul>
<li>Visual studio可用</li>
<li>有免费版</li>
</ul>
<h3 id="保存的时候格式化"><a href="#保存的时候格式化" class="headerlink" title="保存的时候格式化"></a>保存的时候格式化</h3><p><a target="_blank" rel="noopener" href="https://marketplace.visualstudio.com/items?itemName=mynkow.FormatdocumentonSave">Format document On Save插件</a></p>
<p>vs2022版本使用<a target="_blank" rel="noopener" href="https://marketplace.visualstudio.com/items?itemName=WinstonFeng.VSFormatOnSave2022">Format document On Save for VS2022插件</a></p>
<h3 id="一键展开排列代码"><a href="#一键展开排列代码" class="headerlink" title="一键展开排列代码"></a>一键展开排列代码</h3><p>会将函数参数过长的,每个参数排一行,初始化过长的排成多行等等</p>
<p>在vs中展开排列使用动词wrap,翻译为包装每个参数,实际上是把参数排成一行一个展示,这个插件只是帮我们省了点击vs自带的包装每个参数等功能的时间</p>
<p><a target="_blank" rel="noopener" href="https://marketplace.visualstudio.com/items?itemName=csharpier.CSharpier">CSharpier</a>  默认快捷键: ctrl+K,ctrl+y</p>
<p>安装好插件后,进入vs后会有提示安装dotnet工具才能真正使用</p>
<h3 id="xaml代码格式化"><a href="#xaml代码格式化" class="headerlink" title="xaml代码格式化"></a>xaml代码格式化</h3><p><a target="_blank" rel="noopener" href="https://marketplace.visualstudio.com/items?itemName=TeamXavalon.XAMLStyler2022">XAML Styler for visual studio 2022</a></p>
<h3 id="翻译插件"><a href="#翻译插件" class="headerlink" title="翻译插件"></a>翻译插件</h3><p><a target="_blank" rel="noopener" href="https://marketplace.visualstudio.com/items?itemName=vs-publisher-1462295.Visual-Studio-Translator">Visual-Studio-Translator - Visual Studio Marketplace</a></p>
<h2 id="windows下vs的NuGet包管理器"><a href="#windows下vs的NuGet包管理器" class="headerlink" title="windows下vs的NuGet包管理器"></a>windows下vs的NuGet包管理器</h2><p>通过nuGet可以很方便的安装第三方库</p>
<p>在Visual Studio中使用NuGet包的步骤如下：</p>
<ol>
<li><strong>安装NuGet包管理器</strong>：在Visual Studio中，选择“工具”&gt;“扩展与更新”，然后搜索并安装NuGet</li>
<li><strong>打开NuGet包管理器</strong>：在解决方案管理器中，右键点击项目，然后选择“管理NuGet程序包”</li>
<li><strong>搜索并安装NuGet包</strong>：在NuGet包管理器中，选择nuget.org作为包源。在“浏览”选项卡中，搜索你需要的包（例如Newtonsoft.Json），在列表中选择它，然后选择“安装”</li>
<li><strong>使用NuGet包</strong>：安装NuGet包后，可以在代码中通过<code>using </code>语句引用它，其中&#96;&#96;是你正在使用的包的名称。创建引用后，就可以通过API调用包</li>
</ol>
<p><strong>在命令行中使用NuGet的步骤如下：</strong></p>
<ol>
<li><strong>下载并安装NuGet CLI</strong>：<a target="_blank" rel="noopener" href="https://dist.nuget.org/win-x86-commandline/latest/nuget.exe">你可以从nuget.org下载NuGet CLI</a>。将nuget.exe文件保存到合适的目录，并确保该目录位于PATH环境变量中</li>
<li><strong>打开命令行窗口</strong>：你可以通过在Windows上按Win+R并输入cmd，或在Mac&#x2F;Linux上打开终端来打开命令行窗口</li>
<li><strong>运行NuGet命令</strong>：在命令行窗口中，你可以运行nuget并后跟你想要执行的命令和相应的选项。例如，你可以运行<code>nuget help pack</code>来查看pack命令的帮助信息</li>
</ol>
<p><strong>以下是一些常用的NuGet CLI命令</strong></p>
<ul>
<li><code>nuget install &lt;packageID&gt;</code>：安装指定的NuGet包。</li>
<li><code>nuget restore</code>：还原项目的依赖项。</li>
<li><code>nuget push &lt;packageID&gt;</code>：将包发布到包源。</li>
<li><code>nuget delete &lt;packageID&gt;</code>：从包源中删除或取消列出包。</li>
<li><code>nuget list</code>：显示来自给定源的包。</li>
</ul>
<h2 id="windows下的winget"><a href="#windows下的winget" class="headerlink" title="windows下的winget"></a>windows下的winget</h2><h3 id="win商店下载方式"><a href="#win商店下载方式" class="headerlink" title="win商店下载方式"></a>win商店下载方式</h3><p>要在 Windows 11 或 10 上安裝 Windows 包管理器，請使用以下步驟：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://www.microsoft.com/en-us/p/app-installer/9nblggh4nns1#activetab=pivot:overviewtab">打開應用程序安裝程序頁面</a>。</li>
<li>單擊<strong>獲取</strong>按鈕。</li>
<li>單擊<strong>打開 Microsoft Store</strong>按鈕。</li>
<li>單擊<strong>更新</strong>按鈕。</li>
</ol>
<h3 id="GitHub下载方式"><a href="#GitHub下载方式" class="headerlink" title="GitHub下载方式"></a>GitHub下载方式</h3><p>在<a target="_blank" rel="noopener" href="https://github.com/microsoft/winget-cli/releases">下载地址</a>点击msixbundle后缀文件,下载安装后即可</p>
<h2 id="vs相关设置"><a href="#vs相关设置" class="headerlink" title="vs相关设置"></a>vs相关设置</h2><h3 id="vs生成注释"><a href="#vs生成注释" class="headerlink" title="vs生成注释"></a>vs生成注释</h3><p><code>工具-选项-C#-高级-为///生成XML文档注释</code>打上勾</p>
<h3 id="vs函数参数数据类型显示"><a href="#vs函数参数数据类型显示" class="headerlink" title="vs函数参数数据类型显示"></a>vs函数参数数据类型显示</h3><p>函数的每一个内联参数的数据类型都在写代码的时候显示了出来，这样我们在编写代码的时候就可以很方便的进行参数的填写，也能避免一些参数位置填错的惨案</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202406201126452.png" alt="image-20240620112651018" style="zoom: 67%;" />

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202406201126370.png" alt="image-20240620112617839" style="zoom: 67%;" />

<h3 id="vs添加方法的引用计数"><a href="#vs添加方法的引用计数" class="headerlink" title="vs添加方法的引用计数"></a>vs添加方法的引用计数</h3><blockquote>
<p>vs内置的CodeLens:CodeLens是一个帮助开发人员在代码编辑器中获取代码引用、单元测试、源代码管理等信息的工具</p>
</blockquote>
<p>工具-选项-文本编辑器-所有语言-CodeLens - 启用<code>显示C#和Visaul Basic参考</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202406270853448.png" alt="image-20240627085351760"></p>
<ul>
<li><p>显示 测试状态(C++, C# 和 Visual Basic)：</p>
<p> 这一选项启用后，会在代码编辑器中显示代码的测试状态信息，包括哪些测试覆盖了当前代码，测试是否通过等。</p>
</li>
<li><p>显示 C# 和 Visual Basic 参考：</p>
<p> 这一选项启用后，会在代码编辑器中显示C#和Visual Basic代码的引用信息，例如该方法或类被哪些代码引用了。</p>
</li>
<li><p>显示 JavaScript&#x2F;TypeScript 引用：</p>
<p> 这一选项启用后，会在代码编辑器中显示JavaScript和TypeScript代码的引用信息，帮助开发者了解代码在项目中的引用情况。</p>
</li>
<li><p>显示 测试者(C# 和 Visual Basic)：</p>
<p> 这一选项启用后，会在代码编辑器中显示C#和Visual Basic代码的测试者信息，即哪些测试用例涉及了当前代码。</p>
</li>
<li><p>显示 C++ #include 引用：</p>
<p> 这一选项启用后，会在代码编辑器中显示C++代码中的#include引用信息，帮助开发者了解当前文件被哪些其他文件引用了。</p>
</li>
<li><p>显示 C++ 编译时间：</p>
<p> 这一选项启用后，会在代码编辑器中显示C++代码的编译时间信息，帮助开发者优化代码编译效率。</p>
</li>
<li><p>显示 请求(Application Insights)：</p>
<p> 这一选项启用后，会在代码编辑器中显示Application Insights收集的请求信息，帮助开发者了解代码在实际运行中的请求情况和性能指标。</p>
</li>
<li><p>显示 异常(Application Insights)：</p>
<p> 这一选项启用后，会在代码编辑器中显示Application Insights收集的异常信息，帮助开发者快速定位和解决代码中的异常问题。</p>
</li>
</ul>
<h2 id="重要的快捷键"><a href="#重要的快捷键" class="headerlink" title="重要的快捷键"></a>重要的快捷键</h2><p>ctrl+j 获取建议</p>
<h1 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h1><h2 id="winForm项目结构"><a href="#winForm项目结构" class="headerlink" title="winForm项目结构"></a>winForm项目结构</h2><ul>
<li><p>App.config  应用配置</p>
</li>
<li><p>Form1.cs  源码文件(窗口) 双击打开界面设计器(右键可以选择查看源码还是设计器)</p>
<ul>
<li><p>Form1.Designer.cs   源码文件(界面设计)</p>
<p>在定义Form1类的时候含有一个关键字<strong>partial</strong>，这里就不得不说C#语言设计一个重要的特性了，能作为大多数人开发上位机的首选，C#有一个特性就是设计的时候<strong>界面与后台分离，但是类名相同</strong></p>
</li>
<li><p>Form1.resx   资源文件</p>
</li>
</ul>
</li>
<li><p>Program.cs   Main入口所在的源码文件</p>
</li>
<li><p>引用  项目依赖的一些系统库</p>
</li>
<li><p>Properties   通常包含一些项目的配置和属性信息，用于管理项目的设置和行为</p>
<ul>
<li>Assemblylnfo.cs   应用程序发布时的一些属性设置,版本号,属性,版权之类的</li>
<li>其余两个文件是工具自动生成的一些设置文件</li>
<li>Resources.resx</li>
<li>Settings.settings</li>
</ul>
</li>
</ul>
<h1 id="CSharp语法主要版本迭代"><a href="#CSharp语法主要版本迭代" class="headerlink" title="CSharp语法主要版本迭代"></a>CSharp语法主要版本迭代</h1><ol>
<li><p>C# 1.0：最初的C#版本，包含了基本的面向对象编程特性，如类、接口、继承、多态等。</p>
</li>
<li><p>C# 2.0：引入了泛型、迭代器、匿名方法等新特性，提高了代码的灵活性和可读性。</p>
</li>
<li><p>C# 3.0：引入了LINQ（Language Integrated Query）特性，使查询数据变得更加简洁和直观。(统一查询语法)</p>
</li>
<li><p>C# 4.0：引入了动态类型（dynamic）、命名参数、可选参数等新特性，增强了语言的灵活性。</p>
</li>
<li><p>C# 5.0：引入了异步编程模型（async&#x2F;await），使异步操作更加简单和直观。</p>
</li>
<li><p>C# 6.0：引入了自动属性初始化、表达式体成员、字符串插值等新特性，提高了开发效率。</p>
</li>
<li><p>C# 7.0：引入了元组、模式匹配、局部函数等新特性，增强了语言的表达能力和功能性。</p>
</li>
<li><p>C# 8.0：引入了nullable引用类型、异步序列等新特性，提高了代码的安全性和可靠性。</p>
</li>
</ol>
<h1 id="与C-的相互调用关系"><a href="#与C-的相互调用关系" class="headerlink" title="与C++的相互调用关系"></a>与C++的相互调用关系</h1><ul>
<li>Platform Invocation Services (P&#x2F;Invoke)</li>
<li>创建C++&#x2F;CLI封装器来实现。</li>
<li>P&#x2F;Invoke允许您在C#代码中调用原生C++函数，而C++&#x2F;CLI是一种混合语言，可以让您在同一个项目中同时使用C#和C++代码。</li>
</ul>
<p>其实差别就两种:</p>
<ul>
<li><strong>非托管方式（P&#x2F;Invoke）</strong>：适用于已有C++ DLL且不打算修改其源码，仅需C#调用其C兼容接口的情况。简单快捷，无需额外工具链支持，但需要处理数据类型转换和内存管理问题。</li>
<li><strong>托管方式（C++&#x2F;CLI）</strong>：适用于愿意调整C++代码以支持.NET框架，追求更紧密集成和更易用性的场景。C#可以直接使用封装好的托管类，但可能增加项目复杂度，需要维护C++&#x2F;CLI中间层。</li>
</ul>
<h2 id="非托管方式调用（P-Invoke）"><a href="#非托管方式调用（P-Invoke）" class="headerlink" title="非托管方式调用（P&#x2F;Invoke）"></a>非托管方式调用（P&#x2F;Invoke）</h2><p>这种情况是不需要修改C++的DLL的</p>
<p>c#调用C++开发的DLL</p>
<p>如果是C++编写的dll,如,该函数:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    __declspec(dllexport) <span class="function"><span class="type">void</span> <span class="title">ProcessVector</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里是函数的实现，处理传入的整型数组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以直接使用下面的方式对接:</p>
<blockquote>
<p>注意:只有C#编写的DLL才可以在项目中被引用</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.InteropServices;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CppWrapper</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">DllImport(<span class="string">&quot;YourCppLibrary.dll&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">ProcessVector</span>(<span class="params">vector&lt;<span class="built_in">int</span>&gt; arr</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ProcessVectorWrapper</span>(<span class="params"><span class="built_in">int</span>[] vec,<span class="built_in">int</span> vecSize</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ProcessVector(vec,vecSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要使用DllImport,必须使用<code>using System.Runtime.InteropServices;</code></p>
<p>再给一个更简单的案例:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假如C++ 动态DLL库里面有下面两数相加的方法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Sum</span><span class="params">(<span class="type">int</span> value1, <span class="type">int</span> value2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sumValue = value1 + value2;</span><br><span class="line">    <span class="keyword">return</span> sumValue;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//----------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//我们在C#里面想调用C++ dll库，方法如下</span></span><br><span class="line"><span class="comment">//先声明方法</span></span><br><span class="line">[<span class="built_in">DllImport</span>(<span class="string">&quot;myDll.dll&quot;</span>)]</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">extern</span> <span class="type">int</span> <span class="title">Sum</span><span class="params">(<span class="type">int</span> value1, <span class="type">int</span> value2)</span></span>;</span><br><span class="line"><span class="comment">//之后就可以像C#普通方法一样调用 如下</span></span><br><span class="line"><span class="built_in">Sun</span>(<span class="number">5</span>,<span class="number">6</span>);<span class="comment">//计算结果为11</span></span><br></pre></td></tr></table></figure>

<p>在C#通过P&#x2F;Invoke（平台调用）调用C++ DLL时，数据类型转换和内存管理是需要特别关注的两个方面</p>
<h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><h4 id="基本类型转换"><a href="#基本类型转换" class="headerlink" title="基本类型转换"></a>基本类型转换</h4><ul>
<li><strong>数值类型</strong>：C#与C++的基本整数和浮点数类型通常有一一对应关系，如<code>int</code>、<code>long</code>、<code>float</code>、<code>double</code>等。在定义P&#x2F;Invoke函数签名时，使用对应的C#类型即可。</li>
<li><strong>字符与字符串</strong>：<ul>
<li><code>char</code>：C++的<code>char</code>通常对应C#的<code>byte</code>或<code>char</code>（取决于是否区分字节和字符）。</li>
<li><code>wchar_t</code>：C++的宽字符（<code>wchar_t</code>）通常对应C#的<code>char</code>（在.NET Core 3.0及更高版本中，<code>.NET</code>默认使用UTF-8编码，因此宽字符可能需要转换为字符串）。</li>
<li><code>std::string</code> &#x2F; <code>std::wstring</code>：C++的字符串类通常需要转换为C风格的字符串（以<code>\0</code>结尾的字符数组）才能通过P&#x2F;Invoke传递。在C#端使用<code>MarshalAsAttribute</code>指定为<code>UnmanagedType.LPStr</code>（对于ANSI字符串）或<code>UnmanagedType.LPWStr</code>（对于Unicode字符串）。返回字符串时，通常C++函数会返回指向缓冲区的指针，C#需要负责释放该内存（见内存管理部分）。</li>
</ul>
</li>
</ul>
<h4 id="结构体与枚举"><a href="#结构体与枚举" class="headerlink" title="结构体与枚举"></a>结构体与枚举</h4><ul>
<li><strong>结构体</strong>：如果C++ DLL中定义了结构体供C#使用，需要在C#中创建对应的结构体类，并使用<code>StructLayout(LayoutKind.Sequential)</code>（或<code>Explicit</code>)、<code>FieldOffset</code>等特性确保布局与C++端一致。对于嵌套结构体和数组成员，同样需要正确处理。</li>
<li><strong>枚举</strong>：C++的枚举类型可以映射为C#的枚举类型，注意保持枚举值的对应关系，并指定适当的底层类型（如<code>int</code>、<code>uint</code>等）。</li>
</ul>
<h4 id="特殊类型"><a href="#特殊类型" class="headerlink" title="特殊类型"></a><strong>特殊类型</strong></h4><ul>
<li><strong>指针与句柄</strong>：C++的原始指针通常映射为C#的<code>IntPtr</code>类型。对于需要传递或返回的句柄（如Windows API中的<code>HANDLE</code>），也通常使用<code>IntPtr</code>。</li>
<li><strong>数组</strong>：C++数组可以通过固定大小的C#数组、<code>IntPtr</code>结合长度参数，或者使用<code>Marshal.Copy</code>等方法进行传递。</li>
</ul>
<p>C++标准库中的容器（如<code>std::vector</code>)通常包含复杂的内部结构，如动态分配的内存、迭代器、容量信息等，这些都不适合直接通过P&#x2F;Invoke传递给C#。然而，有几种方法可以间接地在C#与C++之间交换<code>std::vector</code>所存储的数据</p>
<h4 id="传递容器"><a href="#传递容器" class="headerlink" title="传递容器"></a>传递容器</h4><p>通过P&#x2F;Invoke从C++ DLL向C#传递容器数据时，通常不会直接传递容器本身，而是传递<strong>容器内容（如通过<a href="#%E9%80%9A%E8%BF%87%E6%95%B0%E7%BB%84%E4%BC%A0%E9%80%92%E5%AE%B9%E5%99%A8%E5%86%85%E5%AE%B9">数组</a>、<a href="#%E9%80%9A%E8%BF%87%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%9D%97%E4%BC%A0%E9%80%92%E5%86%85%E5%AE%B9">连续内存块</a>或<a href="#%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">自定义数据结构</a>）</strong>。在C#端，将接收到的数据转换为相应的C#集合类（如<code>List&lt;T&gt;</code>）后使用</p>
<h5 id="通过数组传递容器内容"><a href="#通过数组传递容器内容" class="headerlink" title="通过数组传递容器内容"></a>通过数组传递容器内容</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllexport)</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">GetDynamicArray</span><span class="params">(<span class="type">int</span>* outputArray, <span class="type">int</span>&amp; arraySize)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       std::vector&lt;<span class="type">int</span>&gt; vec = ...; <span class="comment">// 动态长度数组</span></span><br><span class="line"></span><br><span class="line">       arraySize = vec.<span class="built_in">size</span>();</span><br><span class="line">       <span class="built_in">memcpy</span>(outputArray, vec.<span class="built_in">data</span>(), arraySize * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">DllImport(<span class="string">&quot;MyCppDll.dll&quot;</span>, CallingConvention = CallingConvention.Cdecl)</span>]</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">GetDynamicArray</span>(<span class="params"><span class="keyword">out</span> <span class="built_in">int</span>[] outputArray, <span class="keyword">out</span> <span class="built_in">int</span> arraySize</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>拿vector来举例:</p>
<p>vector-&gt;<code>int* 指针,int&amp; 长度</code>–进入C#-&gt;<code>int[] 数组,int&amp; 长度</code>-&gt;List</p>
<h5 id="通过连续内存块传递内容"><a href="#通过连续内存块传递内容" class="headerlink" title="通过连续内存块传递内容"></a>通过连续内存块传递内容</h5><ol>
<li><p>C++端将动态长度数组序列化为字节数组，并提供一个函数返回该数组的指针和长度。</p>
</li>
<li><p>C#端接收字节数组和长度，然后在C#中反序列化。</p>
<p>示例：</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllexport)</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">GetDynamicArraySerialized</span><span class="params">(<span class="type">char</span>* outputBuffer, <span class="type">int</span>&amp; bufferSize)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       std::vector&lt;std::string&gt; vec = ...; <span class="comment">// 动态长度数组</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 序列化vec到outputBuffer中，记录所需的bufferSize</span></span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">DllImport(<span class="string">&quot;MyCppDll.dll&quot;</span>, CallingConvention = CallingConvention.Cdecl)</span>]</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">GetDynamicArraySerialized</span>(<span class="params"><span class="built_in">byte</span>[] outputBuffer, <span class="keyword">out</span> <span class="built_in">int</span> bufferSize</span>)</span>;</span><br></pre></td></tr></table></figure>

<h5 id="使用自定义数据结构"><a href="#使用自定义数据结构" class="headerlink" title="使用自定义数据结构"></a>使用自定义数据结构</h5><ul>
<li>定义一个包含动态长度数组数据的自定义结构体，包括数据缓冲区和长度信息。</li>
<li>C++端提供函数填充该结构体。</li>
<li>C#端声明对应的结构体，并解析结构体中的数据。</li>
</ul>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a><strong>内存管理</strong></h3><h4 id="手动管理"><a href="#手动管理" class="headerlink" title="手动管理"></a><strong>手动管理</strong></h4><ul>
<li><strong>堆内存分配</strong>：当C++ DLL函数返回指向堆上分配的内存的指针时，C#需要负责释放该内存。通常通过<code>Marshal.FreeCoTaskMem</code>或<code>Marshal.FreeHGlobal</code>函数释放。务必确保释放时机正确，避免内存泄漏。</li>
<li><strong>字符串缓冲区</strong>：如前所述，C++返回的字符串缓冲区通常需要C#释放。可以使用<code>Marshal.PtrToStringAnsi</code>、<code>Marshal.PtrToStringUni</code>等方法将指针转换为托管字符串，同时释放原始内存。</li>
</ul>
<h4 id="自动管理"><a href="#自动管理" class="headerlink" title="自动管理"></a><strong>自动管理</strong></h4><ul>
<li><strong>使用<code>out</code>或<code>ref</code>参数</strong>：对于简单的数据类型或结构体，可以使用<code>out</code>或<code>ref</code>参数让C#自动管理内存。这样，C++函数可以直接修改传入的变量，而无需返回新分配的内存。</li>
<li><strong>内联缓冲区</strong>：对于小尺寸的字符串或数据，可以考虑在C#结构体中预留内联缓冲区，并使用<code>MarshalAsAttribute</code>指定为<code>UnmanagedType.ByValArray</code>。这样，C++函数可以直接写入缓冲区，避免额外分配内存。</li>
</ul>
<h4 id="COM接口与智能指针"><a href="#COM接口与智能指针" class="headerlink" title="COM接口与智能指针"></a><strong>COM接口与智能指针</strong></h4><ul>
<li><strong>COM接口</strong>：如果C++ DLL提供了COM接口，C#可以直接通过<code>System.Runtime.InteropServices.ComImport</code>、<code>Guid</code>属性等创建COM对象代理，内存管理由COM机制自动处理。</li>
<li><strong>智能指针</strong>：如果C++ DLL使用C++11或更高版本的智能指针（如<code>std::unique_ptr</code>、<code>std::shared_ptr</code>），则需要设计合适的接口让C#能够安全地使用这些智能指针所管理的对象，可能涉及原始指针与智能指针的互操作。</li>
</ul>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a><strong>最佳实践</strong></h3><ul>
<li><strong>遵循约定</strong>：确保C++ DLL导出函数遵循特定的调用约定（如<code>__stdcall</code>或<code>__cdecl</code>），并在C#的<code>DllImport</code>属性中指定正确的<code>CallingConvention</code>。</li>
<li><strong>错误处理</strong>：定义并文档化C++ DLL函数返回错误代码的方式，C#端应检查并妥善处理这些错误。</li>
<li><strong>性能优化</strong>：对于频繁调用或大数据量传输的情况，考虑使用<code>unsafe</code>代码、<code>fixed</code>语句、预分配的缓冲区等手段提高效率，但需谨慎处理以避免内存安全问题。</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>平台调用依赖于元数据在运行时查找导出的函数并封送其参数。下图显示了这一过程。</p>
<p>对非托管 DLL 函数的“平台调用”调用</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202405161955269.png" alt="image-20240516195540536" style="zoom: 67%;" />

<h2 id="使用自动化工具生成P-Invoke代码"><a href="#使用自动化工具生成P-Invoke代码" class="headerlink" title="使用自动化工具生成P&#x2F;Invoke代码"></a>使用自动化工具生成P&#x2F;Invoke代码</h2><p>有一些工具可以帮助自动生成P&#x2F;Invoke函数声明和相关的类型定义，减少手动编写的工作量。例如：</p>
<ul>
<li><a href="#SWIG"><strong>SWIG</strong></a>（Simplified Wrapper and Interface Generator）：跨语言开发工具，可以生成C#（以及其他多种语言）绑定代码，封装C++库。需要编写SWIG接口文件描述C++接口，然后通过SWIG生成C#绑定代码。</li>
<li><a href="#ClangSharp.PInvokeGenerator"><strong>ClangSharp.PInvokeGenerator</strong></a>：基于Clang的工具，可以从C&#x2F;C++头文件生成C# P&#x2F;Invoke绑定代码。支持自动处理数据类型转换和内存管理。</li>
</ul>
<p>使用这些工具，您只需提供C++头文件或接口描述，工具会自动生成对应的C# P&#x2F;Invoke代码。然后在C#项目中引用生成的代码文件，即可调用C++ DLL函数。</p>
<blockquote>
<p>总的说，SWIG和ClangSharp.PInvokeGenerator都是用于简化C#调用C++代码过程的工具，它们通过自动化的方式生成封装代码，大大减轻了手动编写P&#x2F;Invoke绑定的工作量。SWIG具有更广泛的语言支持和丰富的定制化选项，而ClangSharp.PInvokeGenerator则依托于Clang编译器，提供了精准的类型映射和对现代C++特性的良好支持。</p>
<p>各自最大优势</p>
<ul>
<li>SWIG  广泛语言支持</li>
<li>ClangSharp.PInvokeGenerator  对于使用现代C++特性的库，尤其是模板、C++11及以后标准特性丰富的库，ClangSharp.PInvokeGenerator可能由于其精准的类型映射和对最新C++标准的良好支持，成为更合适的选择</li>
</ul>
</blockquote>
<h3 id="SWIG"><a href="#SWIG" class="headerlink" title="SWIG"></a>SWIG</h3><p>SWIG是一个广泛使用的跨语言接口生成器，它能够自动将C&#x2F;C++代码包装成其他多种高级编程语言（包括C#）可以调用的形式。SWIG通过解析C&#x2F;C++头文件（或者用户提供的接口文件），生成对应的封装代码，使得原生C&#x2F;C++函数、类和数据结构可以被非C&#x2F;C++语言（如C#）透明地调用。</p>
<p><strong>主要特点与功能</strong>：</p>
<ol>
<li><strong>广泛的语言支持</strong>：SWIG除了支持C#外，还支持许多其他语言，如Python、Java、JavaScript、Perl、Ruby、PHP、Lua等，使得同一套C&#x2F;C++代码可以轻松地为多个平台和编程环境提供接口。</li>
<li><strong>自动类型映射</strong>：SWIG能够识别C&#x2F;C++的基本类型、结构体、枚举、类等，并自动映射到目标语言的等价类型。对于复杂类型，SWIG还可以生成必要的适配器代码以保证类型兼容性。</li>
<li><strong>智能指针支持</strong>：SWIG可以处理C++中的智能指针（如<code>std::shared_ptr</code>、<code>std::unique_ptr</code>），在生成的C#接口中提供适当的生命周期管理。</li>
<li><strong>成员函数封装</strong>：对于C++类的成员函数，SWIG会生成对应的代理方法，使C#代码可以直接调用这些方法，如同在C#中操作本地对象。</li>
<li><strong>模板支持</strong>：SWIG能够处理部分C++模板，并生成特定实例化的代码。对于模板类或函数，可能需要在SWIG接口文件中显式实例化。</li>
<li><strong>扩展性与定制化</strong>：SWIG提供了丰富的预处理器指令和宏系统，允许用户自定义类型映射规则、控制代码生成细节、添加额外的包装逻辑等。</li>
</ol>
<p><strong>使用流程</strong>：</p>
<ol>
<li><strong>编写SWIG接口文件</strong>（<code>.i</code> 文件）：定义需要导出的C&#x2F;C++接口，包括头文件包含、模块定义、类型映射规则等。可以使用 <code>%include</code> 指令包含C&#x2F;C++头文件。</li>
<li><strong>运行SWIG</strong>：使用SWIG命令行工具，指定接口文件和目标语言（如<code>-csharp</code>），生成对应的接口代码。</li>
<li><strong>编译生成的代码</strong>：SWIG生成的C#代码通常包括两个部分：C#接口库（<code>.cs</code> 文件）和C++包装代码（<code>.cpp</code> 文件）。需要分别编译这两个部分：C#接口库编译成DLL或NET Assembly，C++包装代码与原生C++库一起编译链接。</li>
<li><strong>在C#项目中引用</strong>：将生成的C#接口库添加为C#项目的引用，即可在C#代码中直接调用原生C++函数和类。</li>
</ol>
<h3 id="ClangSharp-PInvokeGenerator"><a href="#ClangSharp-PInvokeGenerator" class="headerlink" title="ClangSharp.PInvokeGenerator"></a>ClangSharp.PInvokeGenerator</h3><p>ClangSharp.PInvokeGenerator是基于Clang编译器前端的一个工具，用于从C&#x2F;C++头文件生成C# P&#x2F;Invoke绑定代码。它利用Clang的完整C&#x2F;C++语法解析能力，提供精确的类型映射和函数签名生成。</p>
<p><strong>主要特点与功能</strong>：</p>
<ol>
<li><strong>基于Clang</strong>：得益于Clang强大的C&#x2F;C++解析能力，ClangSharp.PInvokeGenerator能够准确处理复杂的C&#x2F;C++特性，包括模板、宏、内联函数、C++11及以上标准的新特性等。</li>
<li><strong>精准类型映射</strong>：ClangSharp.PInvokeGenerator根据C&#x2F;C++类型生成对应的C# P&#x2F;Invoke类型，包括指针、引用、数组、结构体、枚举、模板实例等，并处理C++特有的类型修饰符（const、volatile、restrict等）。</li>
<li><strong>函数签名生成</strong>：生成符合C# P&#x2F;Invoke规范的函数声明，包括名称修饰、参数传递规则、返回值处理等，确保C#代码能够正确调用C++函数。</li>
<li><strong>支持C++标准库容器</strong>：对于C++标准库容器（如<code>std::vector</code>、<code>std::string</code>等），ClangSharp.PInvokeGenerator可以生成适配器代码，使得C#能够以接近原生的方式使用这些容器。</li>
<li><strong>代码注释保留</strong>：ClangSharp.PInvokeGenerator在生成C#代码时，尽可能保留C++源码中的注释，有助于C#开发者理解封装的C++接口。</li>
</ol>
<p><strong>使用流程</strong>：</p>
<ol>
<li><strong>安装ClangSharp.PInvokeGenerator</strong>：通常通过NuGet包管理器将ClangSharp.PInvokeGenerator工具包添加到项目中。</li>
<li><strong>配置项目</strong>：在项目中指定要解析的C&#x2F;C++头文件路径，以及生成的C#代码输出路径。</li>
<li><strong>运行生成</strong>：调用ClangSharp.PInvokeGenerator提供的API或命令行工具，指定头文件和输出选项，生成C# P&#x2F;Invoke绑定代码。</li>
<li><strong>集成到C#项目</strong>：将生成的C#代码（通常是<code>.cs</code>文件）添加到C#项目中，同时确保项目引用了必要的C++ DLL。C#代码现在可以直接调用C++函数。</li>
</ol>
<h2 id="托管方式调用（CLR-C-CLI）"><a href="#托管方式调用（CLR-C-CLI）" class="headerlink" title="托管方式调用（CLR&#x2F;C++&#x2F;CLI）"></a>托管方式调用（CLR&#x2F;C++&#x2F;CLI）</h2><p><strong>如果愿意修改C++ DLL以支持.NET框架</strong>，可以创建一个混合模式（Managed&#x2F;Unmanaged）的C++&#x2F;CLI DLL，它既包含原生C++代码，又包含托管C++代码，可以直接被C#项目引用。这种方法适用于需要深度集成C++功能，或者希望C++代码能更方便地使用.NET类库的情况。</p>
<ol>
<li><p><strong>创建C++&#x2F;CLI项目</strong>：</p>
<ul>
<li>使用Visual Studio创建一个C++&#x2F;CLI类库项目。</li>
</ul>
</li>
<li><p><strong>封装原生C++代码</strong>：</p>
<ul>
<li><p>在C++&#x2F;CLI项目中，编写托管类（使用<code>.NET</code>命名空间和关键字如<code>ref class</code>），并在其内部封装对原生C++代码的调用。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line">     </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> System;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">public</span> ref <span class="keyword">class</span> <span class="title class_">ManagedWrapper</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ManagedWrapper</span>();</span><br><span class="line">    ~<span class="built_in">ManagedWrapper</span>();</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line">    String^ <span class="built_in">Say</span>(String^ str);</span><br><span class="line">&#125;;</span><br><span class="line">     </span><br><span class="line"><span class="comment">// .cpp文件中实现托管类的方法，调用原生C++代码</span></span><br><span class="line">ManagedWrapper::<span class="built_in">ManagedWrapper</span>() &#123;&#125;</span><br><span class="line">ManagedWrapper::~<span class="built_in">ManagedWrapper</span>() &#123;&#125;</span><br><span class="line">     </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ManagedWrapper::Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b; <span class="comment">// 假设这里实际调用了原生C++代码</span></span><br><span class="line">&#125;</span><br><span class="line">     </span><br><span class="line">String^ ManagedWrapper::<span class="built_in">Say</span>(String^ str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> str; <span class="comment">// 同样，这里实际应调用原生C++代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>编译并生成C++&#x2F;CLI DLL</strong>：</p>
<ul>
<li>编译C++&#x2F;CLI项目，生成<code>.dll</code>文件。由于这个DLL现在包含托管代码，它可以被C#项目直接引用。</li>
</ul>
</li>
<li><p><strong>在C#项目中引用C++&#x2F;CLI DLL</strong>：</p>
<ul>
<li>在C#项目中添加对C++&#x2F;CLI DLL的引用，如同引用其他托管DLL一样。然后直接实例化并使用其中的托管类：</li>
</ul>
</li>
</ol>
<h1 id="CSharp-winform"><a href="#CSharp-winform" class="headerlink" title="CSharp winform"></a>CSharp winform</h1><p><a href="#https://blog.csdn.net/ba_wang_mao/article/details/113642066">C#串口通信测试小工具教程</a></p>
<blockquote>
<ul>
<li><strong>事件源（EventSource）</strong>：描述人机交互中事件的来源，通常是一些控件；</li>
<li><strong>事件（ActionEvent）</strong>：事件源产生的交互内容，比如按下按钮；</li>
<li><strong>事件处理</strong>：这部分也在C++中被叫做回调函数，当事件发生时用来处理事件；</li>
</ul>
<p>这部分在单片机中也是如此，中断源产生中断，然后进入中断服务函数进行响应；</p>
</blockquote>
<p>和qt非常像</p>
<h2 id="容器控件Panel"><a href="#容器控件Panel" class="headerlink" title="容器控件Panel"></a>容器控件Panel</h2><p>Panel是容器控件，是一些小控件的容器池，用来给控件进行大致分组，要注意容器是一个虚拟的，只会在设计的时候出现，不会显示在设计完成的界面上，这里我们将整个界面分为6个容器池，如图：</p>
<h2 id="文本标签控件（Lable）"><a href="#文本标签控件（Lable）" class="headerlink" title="文本标签控件（Lable）"></a>文本标签控件（Lable）</h2><p>用于显示一些文本，但是不可被编辑；改变其显示内容有两种方法：一是直接在属性面板修改“Text”的值，二是通过代码修改其属性，见如下代码；另外，可以修改Font属性修改其显示字体及大小，这里我们选择微软雅黑，12号字体；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label1.Text = &quot;串口&quot;;    //设置label的Text属性值</span><br></pre></td></tr></table></figure>

<h2 id="下拉组合框控件（ComboBox）"><a href="#下拉组合框控件（ComboBox）" class="headerlink" title="下拉组合框控件（ComboBox）"></a>下拉组合框控件（ComboBox）</h2><p>用来显示下拉列表；通常有两种模式</p>
<p>两种模式通过设置DropDownStyle属性选择</p>
<ul>
<li>DropDown模式，既可以选择下拉项，也可以选择直接编辑</li>
<li>DropDownList模式，只能从下拉列表中选择</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Form1_Load</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">int</span> i;</span><br><span class="line">  <span class="comment">//单个添加for (i = 300; i &lt;= 38400; i = i*2)</span></span><br><span class="line">  &#123;</span><br><span class="line">    comboBox2.Items.Add(i.ToString());  <span class="comment">//添加波特率列表</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//批量添加波特率列表</span></span><br><span class="line">  <span class="built_in">string</span>[] baud = &#123; <span class="string">&quot;43000&quot;</span>,<span class="string">&quot;56000&quot;</span>,<span class="string">&quot;57600&quot;</span>,<span class="string">&quot;115200&quot;</span>,<span class="string">&quot;128000&quot;</span>,<span class="string">&quot;230400&quot;</span>,<span class="string">&quot;256000&quot;</span>,<span class="string">&quot;460800&quot;</span> &#125;; </span><br><span class="line">  comboBox2.Items.AddRange(baud);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//设置默认值</span></span><br><span class="line">  comboBox1.Text = <span class="string">&quot;COM1&quot;</span>;</span><br><span class="line">  comboBox2.Text = <span class="string">&quot;115200&quot;</span>;</span><br><span class="line">  comboBox3.Text = <span class="string">&quot;8&quot;</span>;</span><br><span class="line">  comboBox4.Text = <span class="string">&quot;None&quot;</span>;</span><br><span class="line">  comboBox5.Text = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="按钮控件（Button）"><a href="#按钮控件（Button）" class="headerlink" title="按钮控件（Button）"></a>按钮控件（Button）</h2><p>略</p>
<h2 id="文本框控件（TextBox）"><a href="#文本框控件（TextBox）" class="headerlink" title="文本框控件（TextBox）"></a>文本框控件（TextBox）</h2><p>TextBox控件与label控件不同的是，文本框控件的内容可以由用户修改，这也满足我们的发送文本框需求</p>
<p>需要多行显示,设置:其Multiline属性为true</p>
<p>TextBox的方法中最多的是APPendText方法，它的作用是将新的文本数据从末尾处追加至TextBox中，那么当TextBox一直追加文本后就会带来本身长度不够而无法显示全部文本的问题，此时我们需要使能TextBox的纵向滚动条来跟踪显示最新文本，所以我们将TextBox的属性ScrollBars的值设置为Vertical即可；</p>
<h2 id="CSharp中的窗体事件驱动"><a href="#CSharp中的窗体事件驱动" class="headerlink" title="CSharp中的窗体事件驱动"></a>CSharp中的窗体事件驱动</h2><p><code>new EventHandler</code>是C#中用于创建事件处理程序委托实例的语法。在C#中，事件处理程序委托是一种特殊的委托类型，用于表示事件处理程序的方法签名。EventHandler是.NET Framework中预定义的委托类型，用于处理不包含数据的事件。</p>
<p>当您使用<code>new EventHandler</code>语法时，您正在实例化一个EventHandler委托，并指定事件处理程序的方法作为参数。在这种情况下，您需要指定事件处理程序方法的签名，即接受两个参数：一个object类型的sender参数和一个EventArgs类型的e参数。</p>
<p>下面是一个示例，演示如何使用<code>new EventHandler</code>语法创建事件处理程序委托实例：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义事件处理程序方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyEventHandler</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 事件处理程序逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建事件处理程序委托实例</span></span><br><span class="line">EventHandler eventHandler = <span class="keyword">new</span> EventHandler(MyEventHandler);</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们首先定义了一个名为MyEventHandler的事件处理程序方法，然后使用<code>new EventHandler</code>语法创建了一个EventHandler委托实例，将MyEventHandler方法作为参数传递给该委托实例。这样就创建了一个用于处理不包含数据的事件的事件处理程序委托实例。</p>
<h2 id="CSharp窗口ui线程防堵塞"><a href="#CSharp窗口ui线程防堵塞" class="headerlink" title="CSharp窗口ui线程防堵塞"></a>CSharp窗口ui线程防堵塞</h2><p>在 Windows 窗体程序中，UI 组件（比如文本框、按钮等）是不安全的线程资源。这意味着，只能在创建 UI 组件的线程（通常是主线程或 UI 线程）上对这些组件进行操作。当从非 UI 线程（如串口接收事件处理线程）尝试访问 UI 组件时，就必须使用某种同步方法来确保操作的安全性。</p>
<p>Invoke 是委托类型的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95&spm=1001.2101.3001.7020">实例方法</a>，用于调用委托所引用的方法。委托是一种类型，它允许我们将方法作为参数传递并存储在字段或属性中。当委托实例被调用时，它会调用与之关联的方法。可以使用 +&#x3D; 运算符将一个方法添加到委托中，使用 -&#x3D; 运算符将其从委托中删除。</p>
<p>在具体使用上，委托被定义为一个类实例，其具有与特定方法签名匹配的方法。每个委托实例都与一个特定方法绑定，并且可以通过委托实例调用该方法。 </p>
<p><strong>使用event修饰的委托，就变成了事件，在类外部是不能把该委托当做方法直接调用的，这就是用不用event的区别。</strong> </p>
<h3 id="Invoke-BeginInvoke"><a href="#Invoke-BeginInvoke" class="headerlink" title="Invoke&#x2F;BeginInvoke"></a>Invoke&#x2F;BeginInvoke</h3><p><code>Invoke</code> 方法是一个同步方法，它可以将一个操作的执行权转交给 UI 线程。这样做可以避免因为多线程访问同一个 UI 组件而引起的竞争条件或冲突。<code>Invoke</code> 方法接受一个委托（Delegate）作为参数，<strong>该委托指向将要在 UI 线程上执行的方法</strong>。</p>
<p><strong>Invoke方式</strong>，<strong>这种方式专门被用于解决从不是创建控件的线程访问控件</strong></p>
<p>首先说下，Invoke和BeginInvoke的使用有两种情况：</p>
<p><code>control.Invoke(参数delegate)</code>方法:在拥有此控件的基础窗口句柄的线程上<strong>同步</strong>执行指定的委托。</p>
<p><code>control.BeginInvoke(参数delegate)</code>方法:在创建控件的基础句柄所在线程上<strong>异步</strong>执行指定委托。</p>
<p>Invoke的含义是：在拥有此控件的基础窗口句柄的现呈上同步执行指定的委托（同步）<br>BeginInvoke的含义是：在创建控件的基础句柄所在线程上异步执行的委托（异步）</p>
<ol>
<li>Invoke() 调用时，Invoke会阻止当前主线程的运行，等到 Invoke() 方法返回才继续执行后面的代码，表现出“同步”的概念。</li>
<li>BeginInvoke() 调用时，当前线程会启用线程池中的某个线程来执行此方法，BeginInvoke不会阻止当前主线程的运行，而是等当前主线程做完事情之后再执行BeginInvoke中的代码内容，表现出“异步”的概念。在想获取 BeginInvoke() 执行完毕后的结果时，调用EndInvoke() 方法来获取。而这两个方法中执行的是一个委托。</li>
</ol>
<blockquote>
<p><strong>使用场景</strong>：</p>
<ul>
<li>当您需要立即更新UI并且不介意等待时，使用<code>Invoke</code>。</li>
<li>当您不需要立即知道操作结果，并且不希望阻塞当前线程时，使用<code>BeginInvoke</code>。</li>
</ul>
<p><strong>返回值和异常</strong>：</p>
<ul>
<li><code>Invoke</code>可以返回值，并且如果委托中引发异常，它将被传递回调用线程。</li>
<li><code>BeginInvoke</code>不能直接返回值，如果委托中引发异常，它将不会传递回调用线程。</li>
</ul>
</blockquote>
<h4 id="Control-Invoke"><a href="#Control-Invoke" class="headerlink" title="Control.Invoke"></a>Control.Invoke</h4><p>Control的Invoke一般用于解决跨线程访问的问题，比如你想操作一个按钮button,你就要用button.Invoke,你想操作一个文本label,你就要用label.Invoke.但是大家会发现很麻烦，如果我既然想操作button,又操作label,能不能写在一起呢？有没有更简单的方法呢？</p>
<p>其实主窗体使一个Form,Form自然也是继承了Control的，所以Form也有Invoke的方法，如果你想省点事，就可以直接调用Form.Invoke,这就是常见的<code>this.Invoke.</code></p>
<p>为什么有的Invoke前面啥都没有?其实前面是this,只不过省略了.</p>
<p>对于Control 的Invoke ,更标准的用法是先加判断，再调用</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.InvokeRequired)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">this</span>.Invoke(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>InvokeRequired是Control的一个属性</p>
<p>获取一个值，该值指示调用方在对控件进行方法调用时是否必须调用 Invoke 方法，因为调用方位于创建控件所在的线程以外的线程中。如果控件的 Handle 是在与调用线程不同的线程上创建的（说明您必须通过 Invoke 方法对控件进行调用），则为 true；否则为 false。</p>
</blockquote>
<p><code>Invoke</code>方法接受两个参数：一个委托和一个对象数组。委托定义了要在UI线程上执行的操作，对象数组则提供了传递给委托的参数。</p>
<blockquote>
<p>与之对比的,在MFC和QT中防止UI线程卡住的方法分别如下:</p>
<ul>
<li><p>MFC  PostMessage<code>或</code>SendMessage</p>
<ul>
<li>QT   <strong>信号和槽机制</strong></li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="隐式控件"><a href="#隐式控件" class="headerlink" title="隐式控件"></a>隐式控件</h2><p>运行于后台的，用户看不见，更不能直接控制，所以也成为组件，接下来我们添加最主要的串口组件；</p>
<h3 id="串口组件（SerialPort）"><a href="#串口组件（SerialPort）" class="headerlink" title="串口组件（SerialPort）"></a>串口组件（SerialPort）</h3><p>这种隐式控件添加后位于设计器下面 ，串口常用的属性有两个，一个是端口号（PortName），一个是波特率（BaudRate），当然还有数据位，停止位，奇偶校验位等；串口打开与关闭都有接口可以直接调用，串口同时还有一个IsOpen属性，IsOpen为true表示串口已经打开，IsOpen为flase则表示串口已经关闭。</p>
<blockquote>
<p>SerialPort类是相当容易上手的。在进行串口通讯时，一般的流程是设置通讯端口号及波特率、数据位、停止位和校验位，再打开端口连接，发送数据，接收数据，最后关闭端口连接这样几个步骤。</p>
</blockquote>
<p>添加了串口组件后，我们就可以通过它来获取电脑当前端口，并添加到可选列表中</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取电脑当前可用串口并添加到选项列表中</span></span><br><span class="line">comboBox1.Items.AddRange(System.IO.Ports.SerialPort.GetPortNames());</span><br></pre></td></tr></table></figure>

<h4 id="编辑串口通信逻辑"><a href="#编辑串口通信逻辑" class="headerlink" title="编辑串口通信逻辑"></a>编辑串口通信逻辑</h4><h5 id="开关串口"><a href="#开关串口" class="headerlink" title="开关串口"></a>开关串口</h5><p>首先，我们先来控制打开&#x2F;关闭串口，大致思路是：当按下打开串口按钮后，将设置值传送到串口控件的属性中，然后打开串口，按钮显示关闭串口，再次按下时，串口关闭，显示打开按钮；</p>
<blockquote>
<p>　在这个过程中，要注意一点，当我们点击打开按钮时，会发生一些我们编程时无法处理的事件，比如硬件串口没有连接，串口打开的过程中硬件突然断开，这些被称之为<strong>异常</strong>，针对这些异常，<strong>C#也有try..catch处理机制，在try中放置可能产生异常的代码，比如打开串口，在catch中捕捉异常进行处理</strong>。</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打开串口按钮</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">button1_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span>        &#123;</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//将可能产生异常的代码放置在try块中</span></span><br><span class="line">    <span class="comment">//根据当前串口属性来判断是否打开</span></span><br><span class="line">    <span class="keyword">if</span> (serialPort1.IsOpen)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//串口已经处于打开状态</span></span><br><span class="line">      serialPort1.Close();    <span class="comment">//关闭串口</span></span><br><span class="line">      button1.Text = <span class="string">&quot;打开串口&quot;</span>;</span><br><span class="line">      button1.BackColor = Color.ForestGreen;</span><br><span class="line">      comboBox1.Enabled = <span class="literal">true</span>;</span><br><span class="line">      comboBox2.Enabled = <span class="literal">true</span>;</span><br><span class="line">      comboBox3.Enabled = <span class="literal">true</span>;</span><br><span class="line">      comboBox4.Enabled = <span class="literal">true</span>;</span><br><span class="line">      comboBox5.Enabled = <span class="literal">true</span>;</span><br><span class="line">      textBox_receive.Text = <span class="string">&quot;&quot;</span>;  <span class="comment">//清空接收区</span></span><br><span class="line">      textBox_send.Text = <span class="string">&quot;&quot;</span>;     <span class="comment">//清空发送区</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//串口已经处于关闭状态，则设置好串口属性后打开</span></span><br><span class="line">      comboBox1.Enabled = <span class="literal">false</span>;</span><br><span class="line">      comboBox2.Enabled = <span class="literal">false</span>;</span><br><span class="line">      comboBox3.Enabled = <span class="literal">false</span>;</span><br><span class="line">      comboBox4.Enabled = <span class="literal">false</span>;</span><br><span class="line">      comboBox5.Enabled = <span class="literal">false</span>;</span><br><span class="line">      serialPort1.PortName = comboBox1.Text;</span><br><span class="line">      serialPort1.BaudRate = Convert.ToInt32(comboBox2.Text);</span><br><span class="line">      serialPort1.DataBits = Convert.ToInt16(comboBox3.Text);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (comboBox4.Text.Equals(<span class="string">&quot;None&quot;</span>))</span><br><span class="line">        serialPort1.Parity = System.IO.Ports.Parity.None;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(comboBox4.Text.Equals(<span class="string">&quot;Odd&quot;</span>))</span><br><span class="line">        serialPort1.Parity = System.IO.Ports.Parity.Odd;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (comboBox4.Text.Equals(<span class="string">&quot;Even&quot;</span>))</span><br><span class="line">        serialPort1.Parity = System.IO.Ports.Parity.Even;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (comboBox4.Text.Equals(<span class="string">&quot;Mark&quot;</span>))</span><br><span class="line">        serialPort1.Parity = System.IO.Ports.Parity.Mark;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (comboBox4.Text.Equals(<span class="string">&quot;Space&quot;</span>))</span><br><span class="line">        serialPort1.Parity = System.IO.Ports.Parity.Space;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (comboBox5.Text.Equals(<span class="string">&quot;1&quot;</span>))</span><br><span class="line">        serialPort1.StopBits = System.IO.Ports.StopBits.One;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (comboBox5.Text.Equals(<span class="string">&quot;1.5&quot;</span>))</span><br><span class="line">        serialPort1.StopBits = System.IO.Ports.StopBits.OnePointFive;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (comboBox5.Text.Equals(<span class="string">&quot;2&quot;</span>))</span><br><span class="line">        serialPort1.StopBits = System.IO.Ports.StopBits.Two;</span><br><span class="line"></span><br><span class="line">      serialPort1.Open();     <span class="comment">//打开串口</span></span><br><span class="line">      button1.Text = <span class="string">&quot;关闭串口&quot;</span>;</span><br><span class="line">      button1.BackColor = Color.Firebrick;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//捕获可能发生的异常并进行处理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//捕获到异常，创建一个新的对象，之前的不可以再用</span></span><br><span class="line">    serialPort1 = <span class="keyword">new</span> System.IO.Ports.SerialPort();</span><br><span class="line">    <span class="comment">//刷新COM口选项</span></span><br><span class="line">    comboBox1.Items.Clear();</span><br><span class="line">    comboBox1.Items.AddRange(System.IO.Ports.SerialPort.GetPortNames());</span><br><span class="line">    <span class="comment">//响铃并显示异常给用户</span></span><br><span class="line">    System.Media.SystemSounds.Beep.Play();</span><br><span class="line">    button1.Text = <span class="string">&quot;打开串口&quot;</span>;</span><br><span class="line">    button1.BackColor = Color.ForestGreen;</span><br><span class="line">    MessageBox.Show(ex.Message);</span><br><span class="line">    comboBox1.Enabled = <span class="literal">true</span>;</span><br><span class="line">    comboBox2.Enabled = <span class="literal">true</span>;</span><br><span class="line">    comboBox3.Enabled = <span class="literal">true</span>;</span><br><span class="line">    comboBox4.Enabled = <span class="literal">true</span>;</span><br><span class="line">    comboBox5.Enabled = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="发送和接收串口"><a href="#发送和接收串口" class="headerlink" title="发送和接收串口"></a>发送和接收串口</h5><h6 id="串口发送"><a href="#串口发送" class="headerlink" title="串口发送"></a>串口发送</h6><p>　　串口发送有两种方法，一种是字符串发送WriteLine，一种是Write（），可以发送一个字符串或者16进制发送（见下篇），其中字符串发送WriteLine默认已经在末尾添加换行符；</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">button2_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//首先判断串口是否开启</span></span><br><span class="line">                <span class="keyword">if</span> (serialPort1.IsOpen)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//串口处于开启状态，将发送区文本发送</span></span><br><span class="line">                    serialPort1.Write(textBox_send.Text);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//捕获到异常，创建一个新的对象，之前的不可以再用</span></span><br><span class="line">                serialPort1 = <span class="keyword">new</span> System.IO.Ports.SerialPort();</span><br><span class="line">                <span class="comment">//刷新COM口选项</span></span><br><span class="line">                comboBox1.Items.Clear();</span><br><span class="line">                comboBox1.Items.AddRange(System.IO.Ports.SerialPort.GetPortNames());</span><br><span class="line">                <span class="comment">//响铃并显示异常给用户</span></span><br><span class="line">                System.Media.SystemSounds.Beep.Play();</span><br><span class="line">                button1.Text = <span class="string">&quot;打开串口&quot;</span>;</span><br><span class="line">                button1.BackColor = Color.ForestGreen;</span><br><span class="line">                MessageBox.Show(ex.Message);</span><br><span class="line">                comboBox1.Enabled = <span class="literal">true</span>;</span><br><span class="line">                comboBox2.Enabled = <span class="literal">true</span>;</span><br><span class="line">                comboBox3.Enabled = <span class="literal">true</span>;</span><br><span class="line">                comboBox4.Enabled = <span class="literal">true</span>;</span><br><span class="line">                comboBox5.Enabled = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h6 id="串口接受"><a href="#串口接受" class="headerlink" title="串口接受"></a>串口接受</h6><blockquote>
<p>在SerialPort类中有DataReceived事件，当串口的读缓存有数据到达时则触发DataReceived事件，其中SerialPort.ReceivedBytesThreshold属性决定了当串口读缓存中数据多少个时才触发DataReceived事件，默认为1。<br>另外，SerialPort.DataReceived事件运行比较特殊，其运行在辅线程，不能与主线程中的显示数据控件直接进行数据传输，必须用间接的方式实现。</p>
</blockquote>
<p>使用串口接收之前要先为串口注册一个Receive事件，相当于单片机中的串口接收中断，然后在中断内部对缓冲区的数据进行读取</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//串口接收事件处理</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SerialPort1_DataReceived</span>(<span class="params"><span class="built_in">object</span> sender, System.IO.Ports.SerialDataReceivedEventArgs e</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>串口接收也有两种方法，一种是16进制方式读（下篇介绍），一种是字符串方式读，在刚刚生成的代码中编写，如下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//串口接收事件处理</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SerialPort1_DataReceived</span>(<span class="params"><span class="built_in">object</span> sender, System.IO.Ports.SerialDataReceivedEventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//因为要访问UI资源，所以需要使用Invoke方式同步ui</span></span><br><span class="line">    <span class="keyword">this</span>.Invoke((EventHandler)(<span class="built_in">delegate</span></span><br><span class="line">                               &#123;</span><br><span class="line">                                 textBox_receive.AppendText(serialPort1.ReadExisting());</span><br><span class="line">                               &#125;</span><br><span class="line">                              )</span><br><span class="line">               );</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//响铃并显示异常给用户</span></span><br><span class="line">    System.Media.SystemSounds.Beep.Play();</span><br><span class="line">    MessageBox.Show(ex.Message);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面是整体读=================</span></span><br><span class="line"><span class="comment">//下面是按字节租步读=================</span></span><br><span class="line"><span class="comment">//串口接收事件处理</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SerialPort1_DataReceived</span>(<span class="params"><span class="built_in">object</span> sender, System.IO.Ports.SerialDataReceivedEventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">int</span> num = serialPort1.BytesToRead;      <span class="comment">//获取接收缓冲区中的字节数</span></span><br><span class="line">  <span class="built_in">byte</span>[] received_buf = <span class="keyword">new</span> <span class="built_in">byte</span>[num];    <span class="comment">//声明一个大小为num的字节数据用于存放读出的byte型数据</span></span><br><span class="line"></span><br><span class="line">  receive_count += num;                   <span class="comment">//接收字节计数变量增加nun</span></span><br><span class="line">  serialPort1.Read(received_buf,<span class="number">0</span>,num);   <span class="comment">//读取接收缓冲区中num个字节到byte数组中</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//接第二步中的代码</span></span><br><span class="line">  sb.Clear();     <span class="comment">//防止出错,首先清空字符串构造器</span></span><br><span class="line">  <span class="comment">//遍历数组进行字符串转化及拼接</span></span><br><span class="line">  <span class="keyword">foreach</span> (<span class="built_in">byte</span> b <span class="keyword">in</span> received_buf)</span><br><span class="line">  &#123;</span><br><span class="line">    sb.Append(b.ToString());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//因为要访问UI资源，所以需要使用Invoke方式同步ui</span></span><br><span class="line">    Invoke((EventHandler)(<span class="built_in">delegate</span></span><br><span class="line">                          &#123;</span><br><span class="line">                            textBox_receive.AppendText(sb.ToString());</span><br><span class="line">                            label7.Text = <span class="string">&quot;Rx:&quot;</span> + receive_count.ToString() + <span class="string">&quot;Bytes&quot;</span>;</span><br><span class="line">                          &#125;</span><br><span class="line">                         )</span><br><span class="line">          );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//代码省略&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="CSharp-绘图"><a href="#CSharp-绘图" class="headerlink" title="CSharp 绘图"></a>CSharp 绘图</h2><p><code>Graphics</code> 对象在 .NET Framework 中非常灵活，可以在多种不同的上下文中进行绘制。除了在打印文档中使用外，它还可以在以下地方进行绘制：</p>
<ol>
<li><p><strong>控件和窗体的自定义绘制</strong>：</p>
<ul>
<li>通过覆盖控件或窗体的 <code>OnPaint</code> 方法，可以在控件或窗体的表面上直接进行绘制。</li>
<li>这允许开发者创建自定义的控件外观或动画效果。</li>
</ul>
</li>
<li><p><strong>图像对象</strong>：</p>
<ul>
<li>可以使用 <code>Graphics</code> 对象在 <code>Bitmap</code> 对象上进行绘制，从而创建或修改图像。</li>
<li>这常用于图像处理和修改，例如添加文字、图形或进行颜色调整。</li>
</ul>
</li>
<li><p><strong>内存中的绘图</strong>：</p>
<ul>
<li><code>Graphics</code> 可以从一个 <code>Bitmap</code> 创建，并用于在内存中的图像上绘制，而不需要直接绘制到屏幕上。</li>
</ul>
</li>
<li><p><strong>打印图形</strong>：</p>
<ul>
<li>除了 <code>PrintDocument</code>，<code>Graphics</code> 还可以用于绘制打印预览和打印输出。</li>
</ul>
</li>
<li><p><strong>自定义的窗口装饰</strong>：</p>
<ul>
<li>通过自定义窗口的非客户区（如窗口边框和标题栏），可以在窗口的这些区域进行绘制。</li>
</ul>
</li>
<li><p><strong>图形用户界面（GUI）组件</strong>：</p>
<ul>
<li>在自定义 GUI 组件开发中，<code>Graphics</code> 对象可以用于绘制各种视觉元素。</li>
</ul>
</li>
<li><p><strong>游戏开发</strong>：</p>
<ul>
<li>在简单的游戏开发中，<code>Graphics</code> 可以用于绘制游戏中的图形和动画。</li>
</ul>
</li>
<li><p><strong>数据可视化</strong>：</p>
<ul>
<li>用于绘制图表、图形和其他数据可视化元素。</li>
</ul>
</li>
</ol>
<p>在窗口上直接进行绘制的示例代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设 this 是窗体或控件的实例</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CustomDrawMethod</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Graphics g = <span class="keyword">this</span>.CreateGraphics(); <span class="comment">// 创建与当前窗体或控件关联的 Graphics 对象</span></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 使用 g 对象绘制内容</span></span><br><span class="line">        g.Clear(<span class="keyword">this</span>.BackColor); <span class="comment">// 清除背景</span></span><br><span class="line">        g.DrawString(<span class="string">&quot;Hello, World!&quot;</span>, <span class="keyword">this</span>.Font, Brushes.Black, <span class="keyword">this</span>.ClientRectangle); <span class="comment">// 绘制文本</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        g.Dispose(); <span class="comment">// 释放 Graphics 对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>CreateGraphics</code> 方法用于创建与当前控件或窗体关联的 <code>Graphics</code> 对象，然后使用该对象在控件或窗体上绘制文本。绘制完成后，需要调用 <code>Dispose</code> 方法来释放 <code>Graphics</code> 对象所占用的资源。</p>
<p>需要注意的是，在进行自定义绘制时，应该在 <code>Dispose</code> 方法中正确管理 <code>Graphics</code> 对象的生命周期，以避免资源泄漏和其他问题。此外，绘制操作可能会影响应用程序的性能，特别是在复杂的绘制任务或高频绘制操作中。</p>
<h4 id="获取Graphics对象"><a href="#获取Graphics对象" class="headerlink" title="获取Graphics对象"></a>获取Graphics对象</h4><p>演示如何获取一个控件的 <code>Graphics</code> 对象并使用它来绘制控件的内容</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设 myControl 是您想要打印的控件</span></span><br><span class="line">Control myControl = <span class="keyword">this</span>.myControl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个与 myControl 控件大小相同的 Bitmap 对象</span></span><br><span class="line">Bitmap bitmap = <span class="keyword">new</span> Bitmap(myControl.Width, myControl.Height);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 CreateGraphics 方法从控件获取 Graphics 对象</span></span><br><span class="line">Graphics graphics = myControl.CreateGraphics();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使用 Graphics 对象绘制控件内容</span></span><br><span class="line">    <span class="comment">// 这里我们简单地将控件的图像绘制到 bitmap 上</span></span><br><span class="line">    graphics.CopyFromScreen(myControl.Location, Point.Empty, myControl.Size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他绘制操作...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 释放 Graphics 对象</span></span><br><span class="line">    graphics.Dispose();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bitmap 现在包含了 myControl 控件的图像</span></span><br><span class="line"><span class="comment">// 您可以使用 bitmap 进行进一步的操作，比如打印或保存到文件</span></span><br></pre></td></tr></table></figure>

<h3 id="如何在现有控件上进行绘图"><a href="#如何在现有控件上进行绘图" class="headerlink" title="如何在现有控件上进行绘图"></a>如何在现有控件上进行绘图</h3><p>如果您需要在已经存在的控件上进行绘图，您通常会处理该控件的 <code>Paint</code> 事件。当控件需要重绘时（例如，当控件被覆盖或其 <code>Invalidate</code> 方法被调用时），<code>Paint</code> 事件会被触发。在 <code>Paint</code> 事件的处理程序中，您可以使用传入的 <code>PaintEventArgs</code> 参数中的 <code>Graphics</code> 对象来绘制您的自定义图形。</p>
<p>以下是如何为控件添加自定义绘图的步骤：</p>
<ol>
<li><p><strong>订阅 <code>Paint</code> 事件</strong>：<br>为您想要绘制的控件订阅 <code>Paint</code> 事件。</p>
</li>
<li><p><strong>创建 <code>Paint</code> 事件处理器</strong>：<br>编写一个事件处理器来响应 <code>Paint</code> 事件。</p>
</li>
<li><p><strong>使用 <code>Graphics</code> 对象绘制</strong>：<br>在事件处理器中，使用 <code>PaintEventArgs</code> 的 <code>Graphics</code> 对象绘制您的图形。</p>
</li>
<li><p><strong>触发重绘</strong>：<br>如果需要，可以调用控件的 <code>Invalidate</code> 方法来触发重绘。</p>
</li>
</ol>
<p>以下是示例代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设 myControl 是您想要在其上绘制的控件</span></span><br><span class="line">Control myControl = <span class="keyword">this</span>.myControl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅 Paint 事件</span></span><br><span class="line">myControl.Paint += <span class="keyword">new</span> PaintEventHandler(myControl_Paint);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">myControl_Paint</span>(<span class="params"><span class="built_in">object</span> sender, PaintEventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 在这里使用 e.Graphics 对象绘制您的自定义图形</span></span><br><span class="line">    Graphics g = e.Graphics;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制示例：在控件上绘制一个红色的矩形</span></span><br><span class="line">    g.Clear(myControl.BackColor); <span class="comment">// 清除背景</span></span><br><span class="line">    g.FillRectangle(Brushes.Red, <span class="keyword">new</span> Rectangle(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>)); <span class="comment">// 绘制填充矩形</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要，绘制文本</span></span><br><span class="line">    g.DrawString(<span class="string">&quot;Hello, World!&quot;</span>, myControl.Font, Brushes.Black, <span class="keyword">new</span> PointF(<span class="number">10</span>, <span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用完 Graphics 对象后，不需要调用 Dispose，因为它是由系统管理的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果需要手动触发重绘</span></span><br><span class="line">myControl.Invalidate(); <span class="comment">// 这将导致 Paint 事件被触发</span></span><br></pre></td></tr></table></figure>

<p>在上面的代码中，<code>myControl_Paint</code> 方法是 <code>Paint</code> 事件的处理器。当控件需要重绘时，会调用此方法，并传入 <code>PaintEventArgs</code> 对象，其中包含 <code>Graphics</code> 对象和绘制区域的 <code>Rectangle</code> 等信息。</p>
<p>请注意，您不应该手动释放 <code>Graphics</code> 对象，因为它是由系统管理的资源。只需确保不要在 <code>Dispose</code> 方法调用之后使用它即可。</p>
<p>使用此方法，您可以在控件上绘制文本、形状、图像等，实现完全自定义的控件外观。</p>
<h3 id="CSharp-窗体相关的事件"><a href="#CSharp-窗体相关的事件" class="headerlink" title="CSharp 窗体相关的事件"></a>CSharp 窗体相关的事件</h3><p>在 .NET Framework 中，Windows Forms 应用程序中的窗体（Form）可以触发多种事件。这些事件按照不同的阶段和操作进行排序，以下是一些常见的窗体事件，按时间顺序排列：</p>
<ol>
<li><strong>构造和初始化事件</strong>：<ul>
<li><code>Load</code>：在窗体构造后，窗体的控件被创建和布局完成后触发。</li>
</ul>
</li>
<li><strong>显示和隐藏事件</strong>：<ul>
<li><code>Shown</code>：在窗体首次显示后触发。</li>
<li><code>Hide</code>：在调用 <code>Hide</code> 方法隐藏窗体时触发。</li>
</ul>
</li>
<li><strong>激活和取消激活事件</strong>：<ul>
<li><code>Activated</code>：在窗体被激活时触发。</li>
<li><code>Deactivate</code>：在窗体失去焦点时触发。</li>
</ul>
</li>
<li><strong>大小和布局事件</strong>：<ul>
<li><code>Resize</code>：在调整窗体大小时触发。</li>
<li><code>Layout</code>：在控件布局发生更改时触发。</li>
</ul>
</li>
<li><strong>移动事件</strong>：<ul>
<li><code>Move</code>：在窗体位置发生移动时触发。</li>
</ul>
</li>
<li><strong>输入和焦点事件</strong>：<ul>
<li><code>Enter</code>：在控件获得焦点时触发。</li>
<li><code>Leave</code>：在控件失去焦点时触发。</li>
<li><code>GotFocus</code> 和 <code>LostFocus</code>：与 <code>Enter</code> 和 <code>Leave</code> 类似，但更常用于控件。</li>
</ul>
</li>
<li><strong>点击和双击事件</strong>：<ul>
<li><code>MouseEnter</code>：当鼠标进入窗体时触发。</li>
<li><code>MouseLeave</code>：当鼠标离开窗体时触发。</li>
<li><code>MouseDown</code>：当鼠标在窗体内部按下时触发。</li>
<li><code>MouseUp</code>：当释放鼠标按钮时触发。</li>
<li><code>Click</code>：当用户点击窗体时触发（<code>MouseDown</code> 和 <code>MouseUp</code> 之间）。</li>
<li><code>DoubleClick</code>：当用户在窗体上双击时触发。</li>
</ul>
</li>
<li><strong>键盘事件</strong>：<ul>
<li><code>KeyDown</code>：当键盘上的键被按下时触发。</li>
<li><code>KeyUp</code>：当键盘上的键被释放时触发。</li>
<li><code>KeyPress</code>：当键盘上的键被按下并释放时触发。</li>
</ul>
</li>
<li><strong>关闭事件</strong>：<ul>
<li><code>FormClosing</code>：在窗体关闭前触发，可以取消关闭操作。</li>
<li><code>FormClosed</code>：在窗体关闭后触发。</li>
</ul>
</li>
<li><strong>绘图事件</strong>：<ul>
<li><code>Paint</code>：在需要重绘窗体或控件的任何部分时触发。</li>
<li><code>PaintBackground</code>：在绘制窗体背景时触发。</li>
</ul>
</li>
<li><strong>拖放事件</strong>：<ul>
<li><code>DragEnter</code>：在开始拖动操作时触发。</li>
<li><code>DragOver</code>：在拖动操作过程中触发。</li>
<li><code>DragDrop</code>：在完成拖动操作时触发。</li>
<li><code>DragLeave</code>：当拖动操作离开窗体时触发。</li>
</ul>
</li>
<li><strong>帮助事件</strong>：<ul>
<li><code>HelpRequested</code>：当用户请求帮助时触发。</li>
</ul>
</li>
</ol>
<p>这些事件为开发者提供了丰富的交互性，允许对用户的操作做出响应，并执行相应的逻辑处理。开发者可以根据需要在窗体或控件的事件处理器中编写代码，以实现特定的功能。</p>
<h1 id="CSharp-DLL开发"><a href="#CSharp-DLL开发" class="headerlink" title="CSharp DLL开发"></a>CSharp DLL开发</h1><h2 id="创建DLL"><a href="#创建DLL" class="headerlink" title="创建DLL"></a>创建DLL</h2><p>在VS中创建项目选择类库</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202404110918454.png" alt="img"></p>
<p>封装成DLL时程序集名字要跟程序里的 namespace 命名一致，如下图，否则应用DLL时无法引用成功</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202404110919193.png" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202404110919595.png" alt="img"></p>
<h2 id="CSharp中调用该DLL"><a href="#CSharp中调用该DLL" class="headerlink" title="CSharp中调用该DLL"></a>CSharp中调用该DLL</h2><ol>
<li>把DLL放在项目文件夹的bin目录的Debug目录下</li>
<li>点击项目里的引用添加DLL</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202404110921263.png" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202404110921865.png" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202404110921865.png" alt="img"></p>
<p>添加完后可以在引用里看到DLL</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202404110921757.png" alt="img"></p>
<p>使用using包含进去,并调用dll中的函数</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> myDLL;</span><br><span class="line"></span><br><span class="line">Class1 test = <span class="keyword">new</span> Class1(); <span class="comment">//新建类</span></span><br><span class="line"><span class="built_in">int</span> a = test.<span class="keyword">add</span>(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">//调用DLL的函数</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot; a = &quot;</span> + a);<span class="comment">//查看调用结果</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>C#封装的DLL是非标准的DLL（托管类），不可以用 DllImport 调用，DllImport是用来调用标准类（非托管类）的，这类DLL一般是用C++写的</p>
</blockquote>
<h2 id="DLL中自定义窗口"><a href="#DLL中自定义窗口" class="headerlink" title="DLL中自定义窗口"></a>DLL中自定义窗口</h2><p>项目上右键添加-添加-新建项-窗体(Windows 窗体)</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">testDll</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Class1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShowWindow</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Form1 form = <span class="keyword">new</span> Form1();</span><br><span class="line">            form.Text = <span class="string">&quot;Hello from DLL&quot;</span>;</span><br><span class="line">            MessageBox.Show(<span class="string">&quot;Hello from DLL&quot;</span>);<span class="comment">//弹消息框</span></span><br><span class="line">            <span class="comment">//form.Show();//非模态弹自定义窗口</span></span><br><span class="line">            form.ShowDialog();<span class="comment">//模态弹自定义窗口窗口</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="NuGet程序包管理器"><a href="#NuGet程序包管理器" class="headerlink" title="NuGet程序包管理器"></a>NuGet程序包管理器</h1><p>开发过程中几乎不可避免地要使用第三方包，当然可以不用包管理器。对于开源的项目可以直接引用源文件，预先构建好了的库也可以直接引用dll。但是用nuget之类的包管理器可以<strong>更方便地进行管理，比如最基本的安装、更新、卸载功能可以直接通过命令行或者IDE来操作。</strong></p>
<p><strong>常用的包管理工具</strong></p>
<ul>
<li>Linux：apt、yum</li>
<li>Javascript：npm</li>
<li>Java：Maven、Gradle</li>
<li>Python：pip</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.nuget.org/">NuGet</a>是.NET平台上的包管理器，可以帮助开发者轻松地安装、更新和卸载第三方库和工具。</p>
<p>NuGet可以提高项目的开发效率和质量，因为它可以让开发者复用已有的优秀的代码，而不需要自己从头编写或者手动管理依赖关系。</p>
<h2 id="NuGet使用方式"><a href="#NuGet使用方式" class="headerlink" title="NuGet使用方式"></a><strong>NuGet使用方式</strong></h2><ul>
<li>[NuGet CLI](NuGet CLI)</li>
<li><a href="VS%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2">VS图形界面</a><br>(推荐)VS命令行【程序包管理器控制台】</li>
</ul>
<h3 id="NuGet-CLI"><a href="#NuGet-CLI" class="headerlink" title="NuGet CLI"></a>NuGet CLI</h3><p>安装前要先查看当前包是否支持自己的项目框架(如下)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202404271028370.webp" alt="NuGet程序包管理器_管理工具"></p>
<p>查看安装命令，复制到命令行执行</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202404271028512.webp" alt="NuGet程序包管理器_asp.net_02"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">大致语法</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">下面命令可以直接在终端中运行</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">安装：</span></span><br><span class="line">Install-Package XXX -Version 指定版本。</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">卸载：</span></span><br><span class="line">UnInstall-Package XXX</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">更新到最新版：</span></span><br><span class="line">Update-Package XXX</span><br></pre></td></tr></table></figure>

<h3 id="VS图形界面"><a href="#VS图形界面" class="headerlink" title="VS图形界面"></a>VS图形界面</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202404271031608.webp" alt="NuGet程序包管理器_管理工具_05" style="zoom: 50%;" />

<h1 id="CSharp-合并程序集"><a href="#CSharp-合并程序集" class="headerlink" title="CSharp 合并程序集"></a>CSharp 合并程序集</h1><p>我们有多种工具可以将程序<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E9%9B%86%E5%90%88&spm=1001.2101.3001.7020">集合</a>并成为一个。比如 ILMerge、Mono.Merge。前者不可定制、运行缓慢、消耗资源（不过好消息是现在开源了）；后者已被弃用、不受支持且基于旧版本的 Mono.Cecil。</p>
<p>用来替代它们的 ILRepack，使用 ILRepack 来合并程序集。</p>
<h2 id="ILRepack"><a href="#ILRepack" class="headerlink" title="ILRepack"></a>ILRepack</h2><p>il-repack 是一款开源的 .NET 类库重打包工具，它能够将多个 DLL 文件合并成一个单一的 DLL 或 EXE 文件。这在处理依赖性复杂的问题时非常有用，并且可以提高应用程序的部署效率。</p>
<blockquote>
<p>以帮助开发者解决以下问题：</p>
<ul>
<li>将多个类库合并为一个文件，减少部署所需的文件数量。</li>
<li>合并类库中的类型冲突。il-repack 可以自动解决这些冲突，并确保程序正常运行。</li>
<li>支持 .NET Framework 和 .NET Core。</li>
<li>支持 Windows、Linux 和 macOS 操作系统。</li>
</ul>
<p>此外，il-repack 还具有以下特点：</p>
<ul>
<li>易于使用：只需要在命令行中输入简单的指令即可完成操作。</li>
<li>高效：il-repack 使用 IL 指令进行操作，因此速度非常快。</li>
<li>灵活：支持自定义输出目录和输出文件名。</li>
</ul>
</blockquote>
<p>使用 ILRepack 来合并程序集使用方式</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">PM&gt; </span><span class="language-bash">NuGet\Install-Package ILRepack -Version 2.0.31</span></span><br></pre></td></tr></table></figure>

<p>项目根目录下出现的<code>packages\ILRepack.2.0.31\tools</code>下会出现ILRepack.exe</p>
<p>使用类似这样的命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将dll1.dll和dll2.dll以及dll3.dll(以dll1.dll为主)合并为一个output.dll</span></span><br><span class="line">./ILRepack.exe /out:output.dll /target:library dll1.dll dll2.dll dll3.dll</span><br></pre></td></tr></table></figure>

<p>比如说如果<code>dll3.dll</code>还依赖<code>dll4.dll</code>,将<code>dll4.dll</code>一起拉进来合成dll</p>
<h1 id="CSharp-单元测试"><a href="#CSharp-单元测试" class="headerlink" title="CSharp 单元测试"></a>CSharp 单元测试</h1><h2 id="为什么要使用单元测试？"><a href="#为什么要使用单元测试？" class="headerlink" title="为什么要使用单元测试？"></a>为什么要使用单元测试？</h2><ul>
<li>大大节约了测试和修改的时间，有效且便于测试各种情况。</li>
<li>能快速定位bug（每一个测试用例都是具有针对性）。</li>
<li>能使开发人员重新审视需求和功能的设计（难以单元测试的代码，就需要重新设计）。</li>
<li>强迫开发者以调用者而不是实现者的角度来设计代码，利于代码之间的解耦。</li>
<li>自动化的单元测试能保证回归测试的有效执行。</li>
<li>使代码可以放心修改和重构。</li>
<li>测试用例，可作为开发文档使用（测试即文档）。</li>
<li>测试用例永久保存，支持随时测试。</li>
</ul>
<p>对于我个人来说，主要是防止自己犯低级错误的，同时也方便修改（BUG修复）而不引入新的问题。可以放心大胆的重构。简言之，这个简单有效的技术就是为了令代码变得更加完美。</p>
<p>c#常用单元测试框架：MSTest (Visual Studio官方)、XUnit 和 NUnit。</p>
<ol>
<li>MS Test为微软产品，集成在Visual Studio 2008+工具中。</li>
<li>NUnit为.Net开源测试框架（采用C#开发），广泛用于.Net平台的单元测试和回归测试中，官方网址(<a target="_blank" rel="noopener" href="http://www.nunit.org/">www.nunit.org</a>)。</li>
<li>XUnit.Net为NUnit的改进版。</li>
</ol>
<h2 id="mock技术"><a href="#mock技术" class="headerlink" title="mock技术"></a>mock技术</h2><p>在进行单元测试时，如果函数依赖于许多资源而不仅仅是参数，可以考虑使用mocking技术。Mocking是一种在单元测试中模拟依赖项的技术，以确保测试的独立性和可靠性。通过使用mocking框架或手动创建模拟对象，您可以模拟函数所依赖的资源，从而使测试更加可控和可靠。这样，您就可以专注于测试函数的逻辑而不必担心外部资源的影响。希望这可以帮助您进行函数的单元测试。</p>
<p>Visual Studio本身并不提供内置的mocking框架，但您可以使用第三方的mocking框架来进行单元测试。一些流行的C# mocking框架如Moq、NSubstitute和Rhino Mocks可以与Visual Studio集成，并且可以很容易地在Visual Studio中使用这些框架来进行单元测试</p>
<h2 id="自动生成单元测试"><a href="#自动生成单元测试" class="headerlink" title="自动生成单元测试"></a>自动生成单元测试</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/anayigeren/p/10020811.html">参考链接</a></p>
<blockquote>
<p>仅公共类或公共方法中支持创建单元测试</p>
</blockquote>
<p>在需要测试的函数内右键创建单元测试,会打开一个窗口供你配置(直接按默认的设置项就可以)</p>
<p>配置好后会新建一个测试类和一个测试函数,在测试函数中编写断言</p>
<p>测试框架可以选择MSTest和MSTestv2</p>
<blockquote>
<p>MSTest和MSTestv2区别:</p>
<p>MSTest 和 MSTest v2 是 Microsoft 提供的两代测试框架，用于在 .NET 中编写和运行单元测试。MSTest v2 是 MSTest 的继任者，改进了许多功能，并且增加了更多的灵活性和现代化特性。以下是两者之间的一些主要区别：</p>
<h3 id="1-包和命名空间"><a href="#1-包和命名空间" class="headerlink" title="1. 包和命名空间"></a>1. <strong>包和命名空间</strong></h3><ul>
<li><strong>MSTest</strong>:<ul>
<li>包名：<code>Microsoft.VisualStudio.QualityTools.UnitTestFramework</code></li>
<li>命名空间：<code>Microsoft.VisualStudio.TestTools.UnitTesting</code></li>
</ul>
</li>
<li><strong>MSTest v2</strong>:<ul>
<li>包名：<code>MSTest.TestFramework</code> 和 <code>MSTest.TestAdapter</code></li>
<li>命名空间：<code>Microsoft.VisualStudio.TestTools.UnitTesting</code></li>
</ul>
</li>
</ul>
<h3 id="2-跨平台支持"><a href="#2-跨平台支持" class="headerlink" title="2. 跨平台支持"></a>2. <strong>跨平台支持</strong></h3><ul>
<li><strong>MSTest</strong>: 主要针对 Windows 平台。</li>
<li><strong>MSTest v2</strong>: 支持跨平台，可以在 Windows、Linux 和 macOS 上运行。</li>
</ul>
<h3 id="3-与-NET-Core-的兼容性"><a href="#3-与-NET-Core-的兼容性" class="headerlink" title="3. 与 .NET Core 的兼容性"></a>3. <strong>与 .NET Core 的兼容性</strong></h3><ul>
<li><strong>MSTest</strong>: 不支持 .NET Core，只能用于 .NET Framework 项目。</li>
<li><strong>MSTest v2</strong>: 支持 .NET Core 和 .NET Framework，可以在新的 .NET 平台上使用。</li>
</ul>
<h3 id="4-NuGet-包管理"><a href="#4-NuGet-包管理" class="headerlink" title="4. NuGet 包管理"></a>4. <strong>NuGet 包管理</strong></h3><ul>
<li><strong>MSTest</strong>: 一般情况下，它是通过 Visual Studio 自带的组件安装的，不使用 NuGet 包管理。</li>
<li><strong>MSTest v2</strong>: 通过 NuGet 包进行安装和管理，非常方便。</li>
</ul>
<h3 id="5-特性-Attributes"><a href="#5-特性-Attributes" class="headerlink" title="5. 特性 (Attributes)"></a>5. <strong>特性 (Attributes)</strong></h3><ul>
<li><p><strong>MSTest</strong> 和 <strong>MSTest v2</strong> 都使用类似的特性来标记测试方法和类，例如 <code>[TestMethod]</code>, <code>[TestClass]</code>, <code>[TestInitialize]</code>, <code>[TestCleanup]</code>, <code>[ClassInitialize]</code>, <code>[ClassCleanup]</code>。不过 MSTest v2 增加了一些新的特性，如 <code>[DataRow]</code>, <code>[DataTestMethod]</code>，用于数据驱动测试。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">TestClass</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyTests</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">DataTestMethod</span>]</span><br><span class="line">    [<span class="meta">DataRow(1, 2, 3)</span>]</span><br><span class="line">    [<span class="meta">DataRow(2, 3, 5)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddTest</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b, <span class="built_in">int</span> expected</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Assert.AreEqual(expected, a + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-改进的-TestContext"><a href="#6-改进的-TestContext" class="headerlink" title="6. 改进的 TestContext"></a>6. <strong>改进的 TestContext</strong></h3><ul>
<li><strong>MSTest</strong>: <code>TestContext</code> 用于提供测试信息和数据，但是功能相对有限。</li>
<li><strong>MSTest v2</strong>: 改进了 <code>TestContext</code>，增加了更多的功能和更好的灵活性。</li>
</ul>
<h3 id="7-配置和运行设置"><a href="#7-配置和运行设置" class="headerlink" title="7. 配置和运行设置"></a>7. <strong>配置和运行设置</strong></h3><ul>
<li><strong>MSTest</strong>: 使用 <code>.testsettings</code> 和 <code>.runsettings</code> 文件进行配置。</li>
<li><strong>MSTest v2</strong>: 更加强调使用 <code>.runsettings</code> 文件，同时支持更多的配置选项。</li>
</ul>
<h3 id="8-集成和扩展"><a href="#8-集成和扩展" class="headerlink" title="8. 集成和扩展"></a>8. <strong>集成和扩展</strong></h3><ul>
<li><strong>MSTest</strong>: 集成和扩展的能力相对有限。</li>
<li><strong>MSTest v2</strong>: 提供了更好的扩展机制和更强的集成能力，可以更容易地与其他测试工具和框架（如 Azure DevOps）集成。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>MSTest v2 是 MSTest 的现代化替代品，提供了更多的功能、更好的跨平台支持和更强的灵活性。如果你开始一个新的项目，或者需要在 .NET Core 或 .NET 5&#x2F;6+ 上进行单元测试，推荐使用 MSTest v2。而对于已经使用 MSTest 的现有项目，可以考虑逐步迁移到 MSTest v2 以利用其改进和新特性。</p>
</blockquote>
<p>一个例子如下:(包含输出打印,数据驱动的MSTestv2的列子)</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Algorithm.Tests</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">TestClass()</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FrechetTests</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//用于打印数据显示</span></span><br><span class="line">        <span class="keyword">public</span> TestContext TestContext &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> IEnumerable&lt;<span class="built_in">object</span>[]&gt; GetData()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 示例数据集</span></span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">object</span>[]</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">new</span> List&lt;<span class="built_in">double</span>&gt; &#123; <span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span> List&lt;<span class="built_in">double</span>&gt; &#123; <span class="number">4.4</span>, <span class="number">5.5</span>, <span class="number">6.6</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span> List&lt;<span class="built_in">double</span>&gt; &#123; <span class="number">7.7</span>, <span class="number">8.8</span>, <span class="number">9.9</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span> List&lt;<span class="built_in">double</span>&gt; &#123; <span class="number">10.10</span>, <span class="number">11.11</span>, <span class="number">12.12</span> &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">object</span>[]</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">new</span> List&lt;<span class="built_in">double</span>&gt; &#123; <span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span> List&lt;<span class="built_in">double</span>&gt; &#123; <span class="number">1.4</span>, <span class="number">1.5</span>, <span class="number">1.6</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span> List&lt;<span class="built_in">double</span>&gt; &#123; <span class="number">2.7</span>, <span class="number">2.8</span>, <span class="number">2.9</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span> List&lt;<span class="built_in">double</span>&gt; &#123; <span class="number">3.10</span>, <span class="number">3.11</span>, <span class="number">3.12</span> &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">object</span>[]</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">new</span> List&lt;<span class="built_in">double</span>&gt; &#123; <span class="number">0.1</span>, <span class="number">0.2</span> , <span class="number">0.3</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span> List&lt;<span class="built_in">double</span>&gt; &#123; <span class="number">1.4</span>, <span class="number">1.5</span> , <span class="number">1.1</span>&#125;,</span><br><span class="line">            <span class="keyword">new</span> List&lt;<span class="built_in">double</span>&gt; &#123; <span class="number">2.7</span>, <span class="number">2.8</span>, <span class="number">2.9</span> , <span class="number">4.5</span>&#125;,</span><br><span class="line">            <span class="keyword">new</span> List&lt;<span class="built_in">double</span>&gt; &#123; <span class="number">3.10</span>, <span class="number">3.11</span>, <span class="number">3.12</span> , <span class="number">6.7</span>&#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">object</span>[]</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">new</span> List&lt;<span class="built_in">double</span>&gt; &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span> List&lt;<span class="built_in">double</span>&gt; &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span> List&lt;<span class="built_in">double</span>&gt; &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span> List&lt;<span class="built_in">double</span>&gt; &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">// 添加更多数据集</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">TestMethod()</span>]</span><br><span class="line">        [<span class="meta">DynamicData(nameof(GetData), DynamicDataSourceType.Method)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CalcTest</span>(<span class="params">List&lt;<span class="built_in">double</span>&gt; list1,List&lt;<span class="built_in">double</span>&gt; list2,List&lt;<span class="built_in">double</span>&gt; list3,List&lt;<span class="built_in">double</span>&gt; list4</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">double</span> res = Frechet.Calc(list1, list2, list3, list4);</span><br><span class="line">            <span class="comment">//Assert.AreEqual(res, 0);//Assert中有很多断言方法</span></span><br><span class="line">            TestContext.WriteLine(<span class="string">$&quot;曲线1x: <span class="subst">&#123;<span class="built_in">string</span>.Join(<span class="string">&quot;, &quot;</span>, list1)&#125;</span>&quot;</span>);</span><br><span class="line">            TestContext.WriteLine(<span class="string">$&quot;曲线1y: <span class="subst">&#123;<span class="built_in">string</span>.Join(<span class="string">&quot;, &quot;</span>, list2)&#125;</span>&quot;</span>);</span><br><span class="line">            TestContext.WriteLine(<span class="string">$&quot;曲线2x: <span class="subst">&#123;<span class="built_in">string</span>.Join(<span class="string">&quot;, &quot;</span>, list3)&#125;</span>&quot;</span>);</span><br><span class="line">            TestContext.WriteLine(<span class="string">$&quot;曲线2y: <span class="subst">&#123;<span class="built_in">string</span>.Join(<span class="string">&quot;, &quot;</span>, list4)&#125;</span>&quot;</span>);</span><br><span class="line">            TestContext.WriteLine(<span class="string">&quot;相似度为&quot;</span> + res.ToString());</span><br><span class="line">            <span class="comment">//Assert.Fail(e.Message);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异常相关"><a href="#异常相关" class="headerlink" title="异常相关"></a>异常相关</h3><ul>
<li>如果方法在测试过程中抛出异常，而没有使用 [ExpectedException] 特性或 Assert.ThrowsException 方法来捕获异常，测试将失败。</li>
<li>如果方法在测试过程中没有抛出异常，即使不写任何断言，测试也会通过。</li>
</ul>
<h1 id="CSharp-XML操作"><a href="#CSharp-XML操作" class="headerlink" title="CSharp XML操作"></a>CSharp XML操作</h1><blockquote>
<p>此处记录一个vs很实用的工具,在编辑-选择性粘贴-将XML粘贴为类<br>可以将XML字符串数据转换为类结构</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/337698648">参考链接</a></p>
<p>CSharp XML操作 与 [CSharp Json处理](#CSharp Json处理)  有很大的不同</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个新的 XML 文档对象</span></span><br><span class="line">XmlDocument xmlDoc = <span class="keyword">new</span> XmlDocument();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 XML 声明</span></span><br><span class="line">XmlDeclaration xmlDecl = xmlDoc.CreateXmlDeclaration(<span class="string">&quot;1.0&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="comment">//插入XML声明</span></span><br><span class="line">xmlDoc.AppendChild(xmlDecl);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建根元素  (根元素是必须要有的)</span></span><br><span class="line">XmlElement rootElement = xmlDoc.CreateElement(<span class="string">&quot;Root&quot;</span>);</span><br><span class="line"><span class="comment">//插入根元素</span></span><br><span class="line">xmlDoc.AppendChild(rootElement);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在根元素下创建子元素并设置属性</span></span><br><span class="line"><span class="comment">//设置xml标签名为Child</span></span><br><span class="line">XmlElement childElement = xmlDoc.CreateElement(<span class="string">&quot;Child&quot;</span>);</span><br><span class="line">childElement.SetAttribute(<span class="string">&quot;attributeName&quot;</span>, <span class="string">&quot;AttributeValue&quot;</span>);</span><br><span class="line"><span class="comment">//设置Child标签中的值为&quot;Element Text&quot;</span></span><br><span class="line">childElement.InnerText = <span class="string">&quot;Element Text&quot;</span>;</span><br><span class="line">rootElement.AppendChild(childElement);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存到文件</span></span><br><span class="line">xmlDoc.Save(<span class="string">&quot;example.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;XML 文件创建成功。&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取示例:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个XmlDocument对象并加载XML文件</span></span><br><span class="line">XmlDocument doc = <span class="keyword">new</span> XmlDocument();</span><br><span class="line">doc.Load(<span class="string">&quot;example.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用SelectSingleNode方法选择匹配的第一个节点</span></span><br><span class="line">XmlNode node = doc.SelectSingleNode(<span class="string">&quot;/Root/Child&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取节点的文本内容</span></span><br><span class="line"><span class="built_in">string</span> nodeValue = node.InnerText;</span><br></pre></td></tr></table></figure>

<p>生成的xml文件内容如下:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Root</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Child</span> <span class="attr">attributeName</span>=<span class="string">&quot;AttributeValue&quot;</span>&gt;</span>Element Text<span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>也有GetAttribute函数用于读取</p>
<h2 id="XmlSerializer"><a href="#XmlSerializer" class="headerlink" title="XmlSerializer"></a>XmlSerializer</h2><p><code>XmlSerializer</code> 是一个非常重要的类，用于将对象序列化为 XML 格式，或者将 XML 反序列化为对象</p>
<p>C# 的 <code>System.Xml</code> 命名空间提供了多种 XML 操作类，包括 <code>XmlSerializer</code>,<code>XmlSerializer</code> 是这个库的一部分，主要用于对象与 XML 之间的序列化和反序列化操作</p>
   <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Xml.Serialization;</span><br><span class="line"></span><br><span class="line">[<span class="meta">XmlRoot(<span class="string">&quot;Person&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">XmlElement(<span class="string">&quot;Name&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">XmlElement(<span class="string">&quot;Age&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> person = <span class="keyword">new</span> Person &#123; Name = <span class="string">&quot;张三&quot;</span>, Age = <span class="number">30</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 序列化</span></span><br><span class="line">        <span class="keyword">var</span> serializer = <span class="keyword">new</span> XmlSerializer(<span class="keyword">typeof</span>(Person));</span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> writer = <span class="keyword">new</span> StringWriter())</span><br><span class="line">        &#123;</span><br><span class="line">            serializer.Serialize(writer, person);</span><br><span class="line">            <span class="built_in">string</span> xml = writer.ToString();</span><br><span class="line">            Console.WriteLine(xml);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        <span class="built_in">string</span> xmlData = <span class="string">&quot;&lt;Person&gt;&lt;Name&gt;张三&lt;/Name&gt;&lt;Age&gt;30&lt;/Age&gt;&lt;/Person&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> reader = <span class="keyword">new</span> StringReader(xmlData))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> deserializedPerson = (Person)serializer.Deserialize(reader);</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;Name: <span class="subst">&#123;deserializedPerson.Name&#125;</span>, Age: <span class="subst">&#123;deserializedPerson.Age&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意,如果是属性的话要使用:<code>XmlAttribute</code></p>
<h1 id="CSharp-反射"><a href="#CSharp-反射" class="headerlink" title="CSharp 反射"></a>CSharp 反射</h1><p>一句话说清楚,反射就是一种使用字符串当成代码用的方法</p>
<p><strong>反射</strong>是框架设计的基础。</p>
<p>反射在系统中另一个重要应用就是<a href="#%E5%8F%8D%E5%B0%84%E4%B8%8E%E7%89%B9%E6%80%A7%E7%BB%93%E5%90%88">与特性的结合使用</a></p>
<p>C#编程语言中，最常使用的是类和类中的函数和属性。正向调用的方法是，创建类，然后用类创建一个对象。接下来就可以用这个对象调用类中的方法和属性了。</p>
<p>而反射，就是相对于这种正向调用的存在。即，它是反向调用。</p>
<p>反射可以通过类名的字符串来创建类，可以通过函数名的字符串和属性名的字符串，来调用类下的函数和属性。</p>
<blockquote>
<p>为什么需要反射?<br>在不知道一个类型是什么的情况下,可以动态的去操作一个类型<br>典型的表现就是依赖注入容器,依赖注入容器是怎么做到我们要什么类型,他就给什么类型的?</p>
</blockquote>
<h2 id="类反射"><a href="#类反射" class="headerlink" title="类反射"></a>类反射</h2><p>两种通过类名称的字符串,反射出类的对象的用法,如下:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ReflectionSyntax</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Excute</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">      	<span class="comment">//&quot;Syntax.Kiba&quot;是一个完全限定名。什么是完全限定名？完全限定名就是命名空间+类名。在反射的时候，需要我们传递完全限定名来确定到底要去哪个命名空间，找哪个类。</span></span><br><span class="line">      	<span class="comment">//如果是反射时，只写了一个类名，那么速度就会变慢。因为它要遍历所有的命名空间，去找这个类。</span></span><br><span class="line">        Type type = GetType(<span class="string">&quot;Syntax.Kiba&quot;</span>);</span><br><span class="line">        Kiba kiba = (Kiba)Activator.CreateInstance(type);</span><br><span class="line">        Type type2 = GetType2(<span class="string">&quot;Syntax.Kiba&quot;</span>);</span><br><span class="line">        Kiba kiba2 = (Kiba)Activator.CreateInstance(type2);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">//先进行了加载Assembly(组件)，然后再由组件获取类型,即可以解析DLL中的类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Type <span class="title">GetType</span>(<span class="params"><span class="built_in">string</span> fullName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Assembly assembly = Assembly.Load(<span class="string">&quot;Syntax&quot;</span>);</span><br><span class="line">        Type type = assembly.GetType(fullName, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"> 	</span><br><span class="line">  	<span class="comment">//只能解析当前命名空间下的类。如果该类存在于引用的DLL中，就解析不了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Type <span class="title">GetType2</span>(<span class="params"><span class="built_in">string</span> fullName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Type t = Type.GetType(fullName);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Kiba</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintName</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Kiba518&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数反射"><a href="#函数反射" class="headerlink" title="函数反射"></a>函数反射</h2><h3 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数</h3><p>函数的反射应用主要是使用类MethodInfo类反射</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ExcuteMethod</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Assembly assembly = Assembly.Load(<span class="string">&quot;Syntax&quot;</span>);</span><br><span class="line">    Type type = assembly.GetType(<span class="string">&quot;Syntax.Kiba&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>);<span class="comment">//获取了Syntax命名空间下Kiba这个类的类型</span></span><br><span class="line">    MethodInfo method =  type.GetMethod(<span class="string">&quot;PrintName&quot;</span>);<span class="comment">//通过这个类型来获取指定名称的方法</span></span><br><span class="line">    <span class="built_in">object</span> kiba = assembly.CreateInstance(<span class="string">&quot;Syntax.Kiba&quot;</span>);<span class="comment">//实例化对象</span></span><br><span class="line">    <span class="built_in">object</span>[] pmts = <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; <span class="string">&quot;K  iba518&quot;</span> &#125;;<span class="comment">//定义了一个参数的Object数组</span></span><br><span class="line">    method.Invoke(kiba, pmts);<span class="comment">//执行方法 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Kiba</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintName</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> studentType = <span class="keyword">typeof</span>(Student);</span><br><span class="line"><span class="keyword">var</span> studentConstructor = studentType.GetConstructors()[<span class="number">0</span>];<span class="comment">//获取第一个构造函数</span></span><br><span class="line"><span class="keyword">var</span> s = studentConstructor.Invoke(<span class="keyword">new</span> <span class="built_in">object</span>[<span class="number">0</span>]);<span class="comment">//无参的方式调用第一个构造函数</span></span><br></pre></td></tr></table></figure>

<p>上面代码要求没有别的构造函数,但是如果想指定性的获取无参构造函数,可以使用LINQ来筛选出无参构造函数,如:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> studentType = <span class="keyword">typeof</span>(Student);</span><br><span class="line"><span class="keyword">var</span> constructors = studentType.GetConstructors();</span><br><span class="line"><span class="keyword">var</span> parameterlessConstructor = constructors.FirstOrDefault(c =&gt; c.GetParameters().Length == <span class="number">0</span>);<span class="comment">//通过构造函数的参数列表来判断</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (parameterlessConstructor != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> s = parameterlessConstructor.Invoke(<span class="keyword">new</span> <span class="built_in">object</span>[<span class="number">0</span>]); <span class="comment">// 调用无参构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理没有无参构造函数的情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="属性反射"><a href="#属性反射" class="headerlink" title="属性反射"></a>属性反射</h2><p>属性反射是用PropertyInfo类来实现</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ExcuteProperty</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Kiba kiba = <span class="keyword">new</span> Kiba();</span><br><span class="line">    kiba.Name = <span class="string">&quot;Kiba518&quot;</span>;</span><br><span class="line">    <span class="built_in">object</span> name = ReflectionSyntax.GetPropertyValue(kiba, <span class="string">&quot;Name&quot;</span>);</span><br><span class="line">    Console.WriteLine(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">object</span> <span class="title">GetPropertyValue</span>(<span class="params"><span class="built_in">object</span> obj, <span class="built_in">string</span> name</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    PropertyInfo property = obj.GetType().GetProperty(name);</span><br><span class="line">    <span class="keyword">if</span> (property != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">object</span> drv1 = property.GetValue(obj, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> drv1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="反射与特性结合"><a href="#反射与特性结合" class="headerlink" title="反射与特性结合"></a>反射与特性结合</h2><p>演示了如何在运行时根据属性的元数据动态修改对象的属性值,如通过反射，将拥有KibaAttribute特性的，且描述为Clear的属性，清空了</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 包含演示反射和自定义属性处理的主类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">ReflectionSyntax</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 用于演示使用反射执行 ClearKibaAttribute 方法的示例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ExcuteKibaAttribute</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建 Kiba 类的实例并设置其属性</span></span><br><span class="line">        Kiba kiba = <span class="keyword">new</span> Kiba();</span><br><span class="line">        kiba.ClearName = <span class="string">&quot;Kiba518&quot;</span>; <span class="comment">// 带有 &quot;Clear&quot; 自定义属性的属性</span></span><br><span class="line">        kiba.NoClearName = <span class="string">&quot;Kiba518&quot;</span>; <span class="comment">// 带有 &quot;NoClear&quot; 自定义属性的属性</span></span><br><span class="line">        kiba.NormalName = <span class="string">&quot;Kiba518&quot;</span>; <span class="comment">// 没有任何自定义属性的普通属性</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用方法清除带有 &quot;Clear&quot; 自定义属性的属性值</span></span><br><span class="line">        ClearKibaAttribute(kiba);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印属性值以观察更改</span></span><br><span class="line">        Console.WriteLine(kiba.ClearName); <span class="comment">// 应输出 null，因为此属性被清除</span></span><br><span class="line">        Console.WriteLine(kiba.NoClearName); <span class="comment">// 应输出 &quot;Kiba518&quot;，因为此属性未被清除</span></span><br><span class="line">        Console.WriteLine(kiba.NormalName); <span class="comment">// 应输出 &quot;Kiba518&quot;，因为此属性没有任何自定义属性</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据自定义属性清除 Kiba 对象的某些属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ClearKibaAttribute</span>(<span class="params">Kiba kiba</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取 Kiba 类的所有公共实例属性</span></span><br><span class="line">        List&lt;PropertyInfo&gt; plist = <span class="keyword">typeof</span>(Kiba)</span><br><span class="line">            .GetProperties(System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public)</span><br><span class="line">            .ToList();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历每个属性</span></span><br><span class="line">        <span class="keyword">foreach</span> (PropertyInfo pinfo <span class="keyword">in</span> plist)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取当前属性的所有 KibaAttribute 类型的自定义属性</span></span><br><span class="line">            <span class="keyword">var</span> attrs = pinfo.GetCustomAttributes(<span class="keyword">typeof</span>(KibaAttribute), <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查该属性是否具有 KibaAttribute 自定义属性</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> != attrs &amp;&amp; attrs.Length &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 将第一个自定义属性强制转换为 KibaAttribute 并获取其 Description 属性值</span></span><br><span class="line">                <span class="keyword">var</span> des = ((KibaAttribute)attrs[<span class="number">0</span>]).Description;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果 Description 为 &quot;Clear&quot;，将该属性值设置为 null</span></span><br><span class="line">                <span class="keyword">if</span> (des == <span class="string">&quot;Clear&quot;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    pinfo.SetValue(kiba, <span class="literal">null</span>); <span class="comment">// 清除属性值</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示对象的类，其属性将被操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Kiba</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">KibaAttribute(<span class="string">&quot;Clear&quot;</span>)</span>] <span class="comment">// 自定义属性，Description 设置为 &quot;Clear&quot;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> ClearName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">KibaAttribute(<span class="string">&quot;NoClear&quot;</span>)</span>] <span class="comment">// 自定义属性，Description 设置为 &quot;NoClear&quot;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> NoClearName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> NormalName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">// 没有任何自定义属性的普通属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义属性类，用于为属性添加元数据</span></span><br><span class="line">[<span class="meta">System.AttributeUsage(System.AttributeTargets.All)</span>] <span class="comment">// 该属性可以应用于所有程序元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">KibaAttribute</span> : <span class="title">System.Attribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Description &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">// 用于存储描述信息的属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数，用于初始化自定义属性的描述信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KibaAttribute</span>(<span class="params"><span class="built_in">string</span> description</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.Description = description;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在用反射，将DataTable转存到Model实体的时候，遍历属性并赋值的时候，就会多遍历那么几次。</p>
<p>如果只是一个实体，那么，多遍历几次也没影响。但，如果是数十万的数据，那这多几次的遍历影响就大了。</p>
<p>而用反射+特性，就可以减少这些额外遍历次数。即只需要遍历一次,根据属性来做不同的操作</p>
</blockquote>
<h2 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 字符串反射instance类对象中的变量设置为value值</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;instance&quot;&gt;</span>哪个类的实例<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;variableName&quot;&gt;</span>要设置的变量名<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;value&quot;&gt;</span>要设置的值<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SetVariableValue</span>(<span class="params"><span class="built_in">object</span> instance, <span class="built_in">string</span> variableName, <span class="built_in">object</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    variableName = <span class="built_in">char</span>.ToLower(variableName[<span class="number">0</span>]) + variableName.Substring(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 获取当前实例的类型</span></span><br><span class="line">    Type type = instance.GetType();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用反射获取字段并赋值</span></span><br><span class="line">    FieldInfo field = type.GetField(variableName, BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);</span><br><span class="line">    <span class="keyword">if</span> (field != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        field.SetValue(instance, <span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        StackTrace stackTrace = <span class="keyword">new</span> StackTrace(<span class="literal">true</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;反射的变量名不存在：&quot;</span> + variableName + <span class="string">&quot;  调用堆栈：&quot;</span> + stackTrace.ToString());<span class="comment">//打印调用堆栈信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用案例</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SetVariableValue(<span class="keyword">this</span>,varName, <span class="built_in">double</span>.Parse(control.Text));<span class="comment">//设定的值需要类型转化</span></span><br></pre></td></tr></table></figure>

<h2 id="反射置空案例"><a href="#反射置空案例" class="headerlink" title="反射置空案例"></a>反射置空案例</h2><p>在C#中，没有直接的方法可以将一个对象的所有属性都置为空。您需要逐个设置每个属性为null或默认值。这是因为C#中的对象初始化语法通常需要为每个属性提供明确的赋值。</p>
<p>如果您想要一种更通用的方法来将对象的所有属性置为空，您可能需要编写一个通用的方法或使用反射来实现这一目的。以下是一个使用反射的示例代码，可以将一个对象的所有属性置为空：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetPropertiesToNull</span>(<span class="params"><span class="built_in">object</span> obj</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Type type = obj.GetType();</span><br><span class="line">    PropertyInfo[] properties = type.GetProperties();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (PropertyInfo property <span class="keyword">in</span> properties)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (property.CanWrite)</span><br><span class="line">        &#123;</span><br><span class="line">            property.SetValue(obj, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Usage</span></span><br><span class="line">MyClass myObject = <span class="keyword">new</span> MyClass();</span><br><span class="line">SetPropertiesToNull(myObject);</span><br></pre></td></tr></table></figure>

<p>这个示例代码使用反射来获取对象的所有属性，并将它们的值设置为null。请注意，使用反射可能会影响性能，因此请根据实际情况谨慎使用。</p>
<h2 id="动态类型生成"><a href="#动态类型生成" class="headerlink" title="动态类型生成"></a>动态类型生成</h2><table>
<thead>
<tr>
<th>方法</th>
<th>适用场景</th>
<th>动态性</th>
<th>语法友好性</th>
<th>性能</th>
</tr>
</thead>
<tbody><tr>
<td><code>ExpandoObject</code></td>
<td>简单动态对象，无需强类型约束</td>
<td>高</td>
<td>⭐⭐⭐⭐</td>
<td>较高</td>
</tr>
<tr>
<td>自定义动态类型</td>
<td>复杂动态逻辑（如XML&#x2F;JSON解析）</td>
<td>高</td>
<td>⭐⭐⭐</td>
<td>中等</td>
</tr>
<tr>
<td>组合模式</td>
<td>保留原始对象强类型特性</td>
<td>低</td>
<td>⭐⭐</td>
<td>高</td>
</tr>
<tr>
<td>反射与动态代理</td>
<td>高级场景，需生成全新类型</td>
<td>中</td>
<td>⭐</td>
<td>低</td>
</tr>
</tbody></table>
<ul>
<li>若需完全动态行为，优先选择 <code>ExpandoObject</code> 或自定义动态对象。</li>
<li>若需与现有对象协作，使用组合模式或包装类。</li>
<li>避免尝试修改已编译类型的元数据（C#语言限制）</li>
</ul>
<h1 id="CSharp-元组"><a href="#CSharp-元组" class="headerlink" title="CSharp 元组"></a>CSharp 元组</h1><p>C#元组是C# 7.0版本引入的一种数据结构，用于组合多个值并将它们作为一个单元一起传递。元组可以包含不同类型的值，并且可以在不创建新的类或结构的情况下使用。以下是一些关于C#元组的介绍：</p>
<p><strong>语法</strong>：</p>
<ul>
<li>使用元组的语法是在圆括号中列出要组合的值，用逗号分隔。例如：<code>(int, string)</code>表示包含一个整数和一个字符串的元组</li>
<li>可以为元组的组成部分指定名称，例如：<code>(int Id, string Name)</code></li>
</ul>
<p><strong>创建元组</strong>：</p>
<ul>
<li>使用<code>Tuple.Create</code>方法创建元组，例如：<code>var person = Tuple.Create(1, &quot;Alice&quot;);</code></li>
<li>使用元组字面量语法创建元组，例如：<code>(1, &quot;Alice&quot;)</code>。</li>
</ul>
<p><strong>访问元组元素</strong>：</p>
<ul>
<li>可以使用<code>.</code>操作符访问元组中的元素，例如：<code>var id = person.Item1; var name = person.Item2;</code></li>
<li>在具有命名组件的元组中，可以使用组件名称访问元素，例如：<code>var id = person.Id; var name = person.Name;</code></li>
</ul>
<p><strong>返回元组</strong>：</p>
<ul>
<li>可以在方法中返回元组作为结果，例如：<code>public (int, string) GetPerson() &#123; return (1, &quot;Alice&quot;); &#125;</code></li>
</ul>
<p><strong>解构元组</strong>：</p>
<ul>
<li>可以使用解构语法将元组的值分配给多个变量，例如：<code>var (id, name) = GetPerson();</code></li>
</ul>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p><strong>异步方法返回多数据</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个方法体，要返回具体的业务数据，如果里面逻辑校验不通过或者出现了异常，则也要返回响应的错误信息。通过 ref 或者 out 等关键字，来实现多个数据回传</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span>  <span class="title">Method</span>(<span class="params"><span class="built_in">int</span> id,<span class="keyword">ref</span> <span class="built_in">string</span> errMsg</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ....<span class="comment">//具体的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//但是从async/await普及后,异步方法不支持ref,in或out参数,元组就有用了,写法变成了</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;(<span class="built_in">int</span> data,<span class="built_in">string</span> errMsg)&gt; MethodAsync(<span class="built_in">int</span> id)</span><br><span class="line">&#123;</span><br><span class="line">   ....<span class="comment">//具体的逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>临时数据</strong></p>
<p>只是想临时性记录一下某个对象的部分属性，比如一个包裹的体积(长，宽，高)，或者某个点的平面坐标，或者空间坐标等。 如果单独为其创建类，写起来其实挺费力的，但是如果使用元组，那就简单太多了</p>
<p><strong>变量值互换</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a= <span class="number">2</span>;</span><br><span class="line"><span class="built_in">int</span> b= <span class="number">3</span>;</span><br><span class="line">(a,b)=(b,a);</span><br></pre></td></tr></table></figure>

<h1 id="CSharp-dump"><a href="#CSharp-dump" class="headerlink" title="CSharp dump"></a>CSharp dump</h1><p>代码如下</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Flags</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> MINIDUMP_TYPE : <span class="built_in">uint</span></span><br><span class="line">&#123;</span><br><span class="line">    MiniDumpNormal = <span class="number">0x00000000</span>,</span><br><span class="line">    MiniDumpWithDataSegs = <span class="number">0x00000001</span>,</span><br><span class="line">    MiniDumpWithFullMemory = <span class="number">0x00000002</span>,</span><br><span class="line">    MiniDumpWithHandleData = <span class="number">0x00000004</span>,</span><br><span class="line">    MiniDumpWithThreadInfo = <span class="number">0x00001000</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">DllImport(<span class="string">&quot;Dbghelp.dll&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="built_in">bool</span> <span class="title">MiniDumpWriteDump</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    IntPtr hProcess,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="built_in">int</span> processId,</span></span></span><br><span class="line"><span class="params"><span class="function">    IntPtr hFile,</span></span></span><br><span class="line"><span class="params"><span class="function">    MINIDUMP_TYPE dumpType,</span></span></span><br><span class="line"><span class="params"><span class="function">    IntPtr exceptionParam,</span></span></span><br><span class="line"><span class="params"><span class="function">    IntPtr userStreamParam,</span></span></span><br><span class="line"><span class="params"><span class="function">    IntPtr callbackParam</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateDump</span>(<span class="params"><span class="built_in">string</span> dumpFileName</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">string</span> dumpsDirectory = Path.Combine(Directory.GetCurrentDirectory(), <span class="string">&quot;dumps&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (!Directory.Exists(dumpsDirectory))</span><br><span class="line">      &#123;</span><br><span class="line">          Directory.CreateDirectory(dumpsDirectory);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">string</span> dumpFilePath = Path.Combine(dumpsDirectory, dumpFileName);</span><br><span class="line">      <span class="keyword">using</span> (<span class="keyword">var</span> process = Process.GetCurrentProcess())</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">using</span> (FileStream fs = <span class="keyword">new</span> FileStream(dumpFilePath, FileMode.Create))</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="built_in">bool</span> result = MiniDumpWriteDump(</span><br><span class="line">                  process.Handle,</span><br><span class="line">                  process.Id,</span><br><span class="line">                  fs.SafeFileHandle.DangerousGetHandle(),</span><br><span class="line">                  MINIDUMP_TYPE.MiniDumpWithFullMemory | MINIDUMP_TYPE.MiniDumpWithHandleData | MINIDUMP_TYPE.MiniDumpWithThreadInfo,</span><br><span class="line">                  IntPtr.Zero,</span><br><span class="line">                  IntPtr.Zero,</span><br><span class="line">                  IntPtr.Zero);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//带文件数量限制的版本:</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateDump</span>(<span class="params"><span class="built_in">string</span> dumpFileName, <span class="built_in">int</span> maxNum = <span class="number">3</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> dumpsDirectory = Path.Combine(Directory.GetCurrentDirectory(), <span class="string">&quot;dumps&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!Directory.Exists(dumpsDirectory))</span><br><span class="line">    &#123;</span><br><span class="line">        Directory.CreateDirectory(dumpsDirectory);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取当前目录下所有dump文件,按创建时间排序</span></span><br><span class="line">        <span class="built_in">string</span>[] dumpFiles = Directory.GetFiles(dumpsDirectory).OrderBy(f =&gt; File.GetCreationTime(f)).ToArray();</span><br><span class="line">        <span class="keyword">if</span> (dumpFiles.Length &gt;= maxNum)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//删除最早的dump文件</span></span><br><span class="line">            File.Delete(dumpFiles[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> dumpFilePath = Path.Combine(dumpsDirectory, dumpFileName);</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> process = Process.GetCurrentProcess())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> (FileStream fs = <span class="keyword">new</span> FileStream(dumpFilePath, FileMode.Create))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">bool</span> result = MiniDumpWriteDump(</span><br><span class="line">                process.Handle,</span><br><span class="line">                process.Id,</span><br><span class="line">                fs.SafeFileHandle.DangerousGetHandle(),</span><br><span class="line">                MINIDUMP_TYPE.MiniDumpWithFullMemory | MINIDUMP_TYPE.MiniDumpWithHandleData | MINIDUMP_TYPE.MiniDumpWithThreadInfo,</span><br><span class="line"></span><br><span class="line">                IntPtr.Zero,</span><br><span class="line">                IntPtr.Zero,</span><br><span class="line">                IntPtr.Zero);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (result)</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.WriteLine(<span class="string">$&quot;Dump file created at <span class="subst">&#123;dumpFilePath&#125;</span>&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Debug.WriteLine(<span class="string">&quot;Failed to create dump file.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用方式</span></span><br><span class="line"><span class="built_in">string</span> dumpFileName = <span class="string">$&quot;IonImplantationSystem_<span class="subst">&#123;DateTime.Now:MM-dd_HH-mm-ss-ms&#125;</span>.dmp&quot;</span>;</span><br><span class="line">CreateDump(dumpFileName);</span><br></pre></td></tr></table></figure>

<h2 id="常用的其他-MiniDump-选项"><a href="#常用的其他-MiniDump-选项" class="headerlink" title="常用的其他 MiniDump 选项"></a>常用的其他 MiniDump 选项</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> MINIDUMP_TYPE : <span class="built_in">uint</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 基础选项</span></span><br><span class="line">    MiniDumpNormal = <span class="number">0x00000000</span>,</span><br><span class="line">    <span class="comment">// 仅包含最基本的崩溃信息：</span></span><br><span class="line">    <span class="comment">// - 异常信息</span></span><br><span class="line">    <span class="comment">// - 调用堆栈</span></span><br><span class="line">    <span class="comment">// - 线程列表</span></span><br><span class="line">    <span class="comment">// - 模块列表</span></span><br><span class="line"></span><br><span class="line">    MiniDumpWithDataSegs = <span class="number">0x00000001</span>,</span><br><span class="line">    <span class="comment">// 包含数据段：</span></span><br><span class="line">    <span class="comment">// - 加载的模块的数据段</span></span><br><span class="line">    <span class="comment">// - 有助于查看全局变量</span></span><br><span class="line"></span><br><span class="line">    MiniDumpWithFullMemory = <span class="number">0x00000002</span>,</span><br><span class="line">    <span class="comment">// 包含进程的完整内存转储：</span></span><br><span class="line">    <span class="comment">// - 包括所有可读写的内存页</span></span><br><span class="line">    <span class="comment">// - 可以查看完整的堆内存</span></span><br><span class="line">    <span class="comment">// - 文件较大</span></span><br><span class="line"></span><br><span class="line">    MiniDumpWithHandleData = <span class="number">0x00000004</span>,</span><br><span class="line">    <span class="comment">// 包含句柄信息：</span></span><br><span class="line">    <span class="comment">// - 进程打开的所有句柄</span></span><br><span class="line">    <span class="comment">// - 文件句柄</span></span><br><span class="line">    <span class="comment">// - 事件句柄</span></span><br><span class="line">    <span class="comment">// - 互斥体等</span></span><br><span class="line"></span><br><span class="line">    MiniDumpFilterMemory = <span class="number">0x00000008</span>,</span><br><span class="line">    <span class="comment">// 过滤内存数据：</span></span><br><span class="line">    <span class="comment">// - 仅包含有用的内存页</span></span><br><span class="line">    <span class="comment">// - 减小文件大小</span></span><br><span class="line"></span><br><span class="line">    MiniDumpScanMemory = <span class="number">0x00000010</span>,</span><br><span class="line">    <span class="comment">// 扫描内存：</span></span><br><span class="line">    <span class="comment">// - 查找特定的内存模式</span></span><br><span class="line">    <span class="comment">// - 用于内存分析</span></span><br><span class="line"></span><br><span class="line">    MiniDumpWithUnloadedModules = <span class="number">0x00000020</span>,</span><br><span class="line">    <span class="comment">// 包含已卸载的模块信息：</span></span><br><span class="line">    <span class="comment">// - 帮助诊断模块加载问题</span></span><br><span class="line">    <span class="comment">// - 分析模块依赖关系</span></span><br><span class="line"></span><br><span class="line">    MiniDumpWithIndirectlyReferencedMemory = <span class="number">0x00000040</span>,</span><br><span class="line">    <span class="comment">// 包含间接引用的内存：</span></span><br><span class="line">    <span class="comment">// - 包括指针引用的内存</span></span><br><span class="line">    <span class="comment">// - 有助于追踪内存关系</span></span><br><span class="line"></span><br><span class="line">    MiniDumpFilterModulePaths = <span class="number">0x00000080</span>,</span><br><span class="line">    <span class="comment">// 过滤模块路径：</span></span><br><span class="line">    <span class="comment">// - 仅包含必要的模块路径信息</span></span><br><span class="line">    <span class="comment">// - 减小文件大小</span></span><br><span class="line"></span><br><span class="line">    MiniDumpWithProcessThreadData = <span class="number">0x00000100</span>,</span><br><span class="line">    <span class="comment">// 包含进程和线程数据：</span></span><br><span class="line">    <span class="comment">// - 详细的线程状态</span></span><br><span class="line">    <span class="comment">// - 线程本地存储</span></span><br><span class="line"></span><br><span class="line">    MiniDumpWithPrivateReadWriteMemory = <span class="number">0x00000200</span>,</span><br><span class="line">    <span class="comment">// 包含私有读写内存：</span></span><br><span class="line">    <span class="comment">// - 进程私有的可读写内存页</span></span><br><span class="line">    <span class="comment">// - 不包含共享内存</span></span><br><span class="line"></span><br><span class="line">    MiniDumpWithoutOptionalData = <span class="number">0x00000400</span>,</span><br><span class="line">    <span class="comment">// 排除可选数据：</span></span><br><span class="line">    <span class="comment">// - 最小化转储大小</span></span><br><span class="line">    <span class="comment">// - 仅保留核心信息</span></span><br><span class="line"></span><br><span class="line">    MiniDumpWithFullMemoryInfo = <span class="number">0x00000800</span>,</span><br><span class="line">    <span class="comment">// 完整的内存信息：</span></span><br><span class="line">    <span class="comment">// - 内存管理信息</span></span><br><span class="line">    <span class="comment">// - 内存分配状态</span></span><br><span class="line">    <span class="comment">// - 保护属性</span></span><br><span class="line"></span><br><span class="line">    MiniDumpWithThreadInfo = <span class="number">0x00001000</span>,</span><br><span class="line">    <span class="comment">// 额外的线程信息：</span></span><br><span class="line">    <span class="comment">// - 线程时间</span></span><br><span class="line">    <span class="comment">// - 线程优先级</span></span><br><span class="line">    <span class="comment">// - 线程亲和性</span></span><br><span class="line"></span><br><span class="line">    MiniDumpWithCodeSegs = <span class="number">0x00002000</span>,</span><br><span class="line">    <span class="comment">// 包含代码段：</span></span><br><span class="line">    <span class="comment">// - 所有模块的代码段</span></span><br><span class="line">    <span class="comment">// - 用于反汇编分析</span></span><br><span class="line"></span><br><span class="line">    MiniDumpWithoutAuxiliaryState = <span class="number">0x00004000</span>,</span><br><span class="line">    <span class="comment">// 排除辅助状态：</span></span><br><span class="line">    <span class="comment">// - 不包含辅助数据结构</span></span><br><span class="line">    <span class="comment">// - 减小文件大小</span></span><br><span class="line"></span><br><span class="line">    MiniDumpWithFullAuxiliaryState = <span class="number">0x00008000</span>,</span><br><span class="line">    <span class="comment">// 完整的辅助状态：</span></span><br><span class="line">    <span class="comment">// - 包含所有辅助数据结构</span></span><br><span class="line">    <span class="comment">// - 用于深入分析</span></span><br><span class="line"></span><br><span class="line">    MiniDumpWithPrivateWriteCopyMemory = <span class="number">0x00010000</span>,</span><br><span class="line">    <span class="comment">// 私有写时复制内存：</span></span><br><span class="line">    <span class="comment">// - 包含写时复制页面</span></span><br><span class="line">    <span class="comment">// - 用于分析内存修改</span></span><br><span class="line"></span><br><span class="line">    MiniDumpIgnoreInaccessibleMemory = <span class="number">0x00020000</span>,</span><br><span class="line">    <span class="comment">// 忽略不可访问的内存：</span></span><br><span class="line">    <span class="comment">// - 跳过无法读取的内存页</span></span><br><span class="line">    <span class="comment">// - 避免转储失败</span></span><br><span class="line"></span><br><span class="line">    MiniDumpWithTokenInformation = <span class="number">0x00040000</span>,</span><br><span class="line">    <span class="comment">// 包含令牌信息：</span></span><br><span class="line">    <span class="comment">// - 安全令牌</span></span><br><span class="line">    <span class="comment">// - 权限信息</span></span><br><span class="line"></span><br><span class="line">    MiniDumpWithModuleHeaders = <span class="number">0x00080000</span>,</span><br><span class="line">    <span class="comment">// 包含模块头信息：</span></span><br><span class="line">    <span class="comment">// - PE头信息</span></span><br><span class="line">    <span class="comment">// - 导入导出表</span></span><br><span class="line"></span><br><span class="line">    MiniDumpFilterTriage = <span class="number">0x00100000</span>,</span><br><span class="line">    <span class="comment">// 筛选关键信息：</span></span><br><span class="line">    <span class="comment">// - 仅包含故障排除必需信息</span></span><br><span class="line">    <span class="comment">// - 优化文件大小</span></span><br><span class="line"></span><br><span class="line">    MiniDumpWithAvxXStateContext = <span class="number">0x00200000</span>,</span><br><span class="line">    <span class="comment">// AVX状态上下文：</span></span><br><span class="line">    <span class="comment">// - AVX寄存器状态</span></span><br><span class="line">    <span class="comment">// - SIMD相关信息</span></span><br><span class="line"></span><br><span class="line">    MiniDumpWithIptTrace = <span class="number">0x00400000</span>,</span><br><span class="line">    <span class="comment">// Intel处理器追踪：</span></span><br><span class="line">    <span class="comment">// - 处理器执行追踪信息</span></span><br><span class="line">    <span class="comment">// - 性能分析数据</span></span><br><span class="line"></span><br><span class="line">    MiniDumpScanInaccessiblePartialPages = <span class="number">0x00800000</span>,</span><br><span class="line">    <span class="comment">// 扫描不可访问的部分页面：</span></span><br><span class="line">    <span class="comment">// - 尝试读取部分可访问的页面</span></span><br><span class="line">    <span class="comment">// - 最大化信息收集</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 组合标志</span></span><br><span class="line">    MiniDumpWithFullMemoryEx = MiniDumpWithFullMemory | </span><br><span class="line">                              MiniDumpWithFullMemoryInfo | </span><br><span class="line">                              MiniDumpWithHandleData | </span><br><span class="line">                              MiniDumpWithThreadInfo | </span><br><span class="line">                              MiniDumpWithTokenInformation,</span><br><span class="line">    <span class="comment">// 常用的完整内存转储组合：</span></span><br><span class="line">    <span class="comment">// - 包含完整内存映像</span></span><br><span class="line">    <span class="comment">// - 内存管理信息</span></span><br><span class="line">    <span class="comment">// - 句柄数据</span></span><br><span class="line">    <span class="comment">// - 线程信息</span></span><br><span class="line">    <span class="comment">// - 安全令牌信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="组合盘点"><a href="#组合盘点" class="headerlink" title="组合盘点"></a>组合盘点</h3><ul>
<li><p><strong>初步分析</strong>：<code>MiniDumpNormal | MiniDumpWithDataSegs | MiniDumpWithThreadInfo</code></p>
<p>适用于生成较小的 Dump 文件，用于基本调试，如快速分析崩溃原因、线程状态等</p>
</li>
<li><p><strong>一般调试</strong>：<code>MiniDumpWithFullMemory | MiniDumpWithHandleData | MiniDumpWithThreadInfo | MiniDumpWithDataSegs</code></p>
<p>适合大多数问题分析，如内存泄漏、资源泄漏和多线程问题。</p>
</li>
<li><p><strong>全面诊断</strong>：<code>MINIDUMP_TYPE.MiniDumpWithFullMemory | MINIDUMP_TYPE.MiniDumpWithHandleData | MINIDUMP_TYPE.MiniDumpWithThreadInfo | MINIDUMP_TYPE.MiniDumpWithDataSegs |  MINIDUMP_TYPE.MiniDumpWithPrivateReadWriteMemory | MINIDUMP_TYPE.MiniDumpWithUnloadedModules | MINIDUMP_TYPE.MiniDumpWithFullMemoryInfo</code>;</p>
<p>全面分析复杂问题，包括内存和线程异常、模块加载&#x2F;卸载等。</p>
</li>
<li><p><strong>性能调优</strong>：<code>MiniDumpWithFullMemory | MiniDumpWithThreadInfo | MiniDumpWithCodeSegs</code></p>
<p>性能调优，检查内存和代码段的使用情况。</p>
</li>
</ul>
<h2 id="分析方式"><a href="#分析方式" class="headerlink" title="分析方式"></a>分析方式</h2><h3 id="visual-studio"><a href="#visual-studio" class="headerlink" title="visual studio"></a>visual studio</h3><p>Visual Studio 可以直接加载 <code>.dmp</code> 文件。打开 Visual Studio 后，选择 <code>“文件” &gt; “打开” &gt; “文件…”</code>，选择 <code>.dmp</code> 文件即可查看堆栈信息、异常上下文和托管对象。</p>
<h3 id="dotnet-dump"><a href="#dotnet-dump" class="headerlink" title="dotnet-dump"></a>dotnet-dump</h3><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2396061">超级详细使用方案实践参考</a></p>
<p>dotnet-dump工具也可用于分析</p>
<p>安装方式: <code>dotnet tool install --global dotnet-dump</code></p>
<p>进入交互式调试模式: <code>dotnet-dump analyze dump文件路径</code></p>
<p>进入交互式调试模式，可以执行类似 WinDbg 的命令，比如 clrstack、dumpheap、gcr 等</p>
<blockquote>
<p>其他工具还有:</p>
<ul>
<li>用于列出进程的 dotnet-trace</li>
<li>用于检查托管内存使用情况的 dotnet-counters</li>
<li>用于收集和分析转储文件的 dotnet-dump</li>
</ul>
</blockquote>
<h2 id="死锁排查"><a href="#死锁排查" class="headerlink" title="死锁排查"></a>死锁排查</h2><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1931037">参考链接</a></p>
<h2 id="CPU占用率排查"><a href="#CPU占用率排查" class="headerlink" title="CPU占用率排查"></a>CPU占用率排查</h2><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1931034">参考链接</a></p>
<h1 id="CSharp-拓展方法"><a href="#CSharp-拓展方法" class="headerlink" title="CSharp 拓展方法"></a>CSharp 拓展方法</h1><p>扩展方法自C# 3.0引入以来，就一直是C#语言及其运行环境（包括所有.NET版本）的一个重要特性</p>
<p>它允许你向现有的类型添加新方法，而无需修改这些类型的定义或创建子类。这对于增强不可修改的类（例如在.NET库中的类）或者避免使用继承来扩展类的功能是非常有用的</p>
<p><strong>使用场景</strong></p>
<ul>
<li><strong>不修改源码的情况下扩展功能</strong>：无须更改类的基础结构或继承，直接扩展功能。</li>
<li><strong>提供与实例方法类似的调用语法</strong>：在实际使用中，扩展方法看起来就像是实例方法。</li>
<li><strong>LINQ实现的基础</strong>：LINQ的查询操作符（如<code>Select</code>、<code>Where</code>等）都是通过扩展方法实现的。</li>
</ul>
<h2 id="实现扩展方法的关键点"><a href="#实现扩展方法的关键点" class="headerlink" title="实现扩展方法的关键点"></a>实现扩展方法的关键点</h2><ol>
<li><strong>静态方法所在的静态类</strong>：<br>扩展方法必须定义在一个静态类中。</li>
<li><strong>第一个参数使用<code>this</code>关键字</strong>：<br>扩展方法的第一个参数必须用<code>this</code>关键字来修饰，且紧跟着要扩展的类型。这样可以让编译器知道该方法是扩展方法。</li>
<li><strong>名称空间的导入</strong>：<br>如果你要使用某个扩展方法，必须在适用代码的文件中使用<code>using</code>指令来导入包含该扩展方法的命名空间。</li>
</ol>
<h2 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h2><p>下面是一个简单的扩展方法示例，它为<code>string</code>类型添加了一个方法来计算字符串内的单词数量</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ExtensionMethodsDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">StringExtensions</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 用 this 关键字在第一个参数前来定义为 string 的扩展方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">WordCount</span>(<span class="params"><span class="keyword">this</span> <span class="built_in">string</span> str</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrEmpty(str))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">string</span>[] words = str.Split(<span class="keyword">new</span>[] &#123; <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;\t&#x27;</span>, <span class="string">&#x27;\n&#x27;</span> &#125;, StringSplitOptions.RemoveEmptyEntries);</span><br><span class="line">            <span class="keyword">return</span> words.Length;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> sentence = <span class="string">&quot;Hello, this is a simple sentence.&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通过扩展方法，像调用实例方法一样使用 WordCount</span></span><br><span class="line">            <span class="built_in">int</span> count = sentence.WordCount();</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;Word count: <span class="subst">&#123;count&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>当你调用<code>sentence.WordCount()</code>时，编译器实际上是在字符串对象<code>sentence</code>上调用<code>StringExtensions.WordCount(sentence)</code>，把<code>sentence</code>传递给扩展方法的第一个参数<code>str</code>。</p>
<p>注意:</p>
<ul>
<li>扩展方法不可以覆盖已有的实例方法。</li>
<li>过度使用扩展方法可能导致代码可读性下降，因此扩展方法应该用于增强已有类的功能而非替代更具可读性、明确的设计模式</li>
</ul>
<h1 id="CSharp-LINQ"><a href="#CSharp-LINQ" class="headerlink" title="CSharp LINQ"></a>CSharp LINQ</h1><p><strong>LINQ: 语言集成查询(Language Integrated Query)</strong>,发音”link”,是微软的一项技术,新增一种自然查询的SQL语法到C#的编程语言中,当前可支持C#以及Visual Basic .NET语言.2007年11月18日随.NET Framework 3.5发布了LINQ技术,其中主要包括</p>
<blockquote>
<p>简单的理解为在C#中添加了一种类似SQL的语法,可以方便开发者进行数据的查询操作</p>
</blockquote>
<p>• LINQ to Objects（数组、集合）<br>• LINQ to SQL<br>• LINQ to Datasets<br>• LINQ to Entities<br>• LINQ to Data Source<br>• LINQ to XML&#x2F;XSD  <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1MM411M7sB/">参考</a></p>
<p>表现形式主要有以下两种</p>
<ul>
<li>查询表达式</li>
<li>链式编程</li>
</ul>
<h2 id="查询表达式"><a href="#查询表达式" class="headerlink" title="查询表达式"></a>查询表达式</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] nums=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="comment">//查询表达式,查询数组中大于4的奇数并降序排列</span></span><br><span class="line"><span class="keyword">var</span> query = <span class="keyword">from</span> num <span class="keyword">in</span> nums </span><br><span class="line">  <span class="keyword">where</span> num&gt; <span class="number">4</span> &amp;&amp; num%<span class="number">2</span>==<span class="number">1</span></span><br><span class="line">  <span class="keyword">orderby</span> num <span class="keyword">descending</span></span><br><span class="line">  <span class="keyword">select</span> num;</span><br><span class="line"><span class="comment">//遍历结果集(上面的查询语句实际上并没有查询,到这里遍历的时候才真正执行了查询操作)</span></span><br><span class="line"><span class="keyword">foreach</span>(<span class="keyword">var</span> item <span class="keyword">in</span> query)</span><br><span class="line">&#123;</span><br><span class="line">  Console.Write(item+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Console.WriteLine();</span><br><span class="line"></span><br><span class="line"><span class="comment">//交集查询</span></span><br><span class="line"><span class="built_in">int</span>[] nums=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="built_in">int</span>[] datas=&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> query2 = <span class="keyword">from</span> num <span class="keyword">in</span> nums </span><br><span class="line">  <span class="keyword">where</span> datas.Contains(num)</span><br><span class="line">  <span class="keyword">select</span> num;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按照字符长度分组排序</span></span><br><span class="line"><span class="built_in">string</span>[] languages = &#123; <span class="string">&quot;Java&quot;</span>, <span class="string">&quot;XML&quot;</span>, <span class="string">&quot;C#&quot;</span>, <span class="string">&quot;PHP&quot;</span>, <span class="string">&quot;HTML&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;C++&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> query3 = <span class="keyword">from</span> language <span class="keyword">in</span> languages</span><br><span class="line">  <span class="keyword">group</span> language <span class="keyword">by</span> language.Length <span class="keyword">into</span> g</span><br><span class="line">  <span class="keyword">orderby</span> g.Key</span><br><span class="line">  <span class="keyword">select</span> g;</span><br><span class="line"><span class="keyword">foreach</span>(<span class="keyword">var</span> item <span class="keyword">in</span> query3)</span><br><span class="line">&#123;</span><br><span class="line">  Console.WriteLine(<span class="string">$&quot;长度为<span class="subst">&#123;item.Key&#125;</span>的语言有:&quot;</span>);</span><br><span class="line">  <span class="keyword">foreach</span>(<span class="keyword">var</span> lan <span class="keyword">in</span> item)</span><br><span class="line">  &#123;</span><br><span class="line">    Console.Write(lan+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  Console.WriteLine();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">长度为1的语言有:</span></span><br><span class="line"><span class="comment">C,</span></span><br><span class="line"><span class="comment">长度为2的语言有:</span></span><br><span class="line"><span class="comment">C#,</span></span><br><span class="line"><span class="comment">长度为3的语言有:</span></span><br><span class="line"><span class="comment">XML,PHP,C++,</span></span><br><span class="line"><span class="comment">长度为4的语言有:</span></span><br><span class="line"><span class="comment">Java,HTML,</span></span><br><span class="line"><span class="comment">长度为10的语言有:</span></span><br><span class="line"><span class="comment">JavaScript,</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>注意:遍历结果集的时候才真正执行查询</p>
<h2 id="链式编程"><a href="#链式编程" class="headerlink" title="链式编程"></a>链式编程</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链式编程进行查询</span></span><br><span class="line"><span class="keyword">var</span> chain = nums.Where(num=&gt;num&gt;<span class="number">4</span> &amp;&amp; num%<span class="number">2</span>==<span class="number">1</span>).OrderByDescending(num=&gt;num).Select(num=&gt;num);</span><br><span class="line"><span class="comment">//遍历结果集(上面的查询语句实际上并没有查询,到这里遍历的时候才真正执行了查询操作)</span></span><br><span class="line"><span class="keyword">foreach</span>(<span class="keyword">var</span> item <span class="keyword">in</span> chain)</span><br><span class="line">&#123;</span><br><span class="line">  Console.Write(item+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Console.WriteLine();</span><br><span class="line"></span><br><span class="line"><span class="comment">//交集查询</span></span><br><span class="line"><span class="built_in">int</span>[] nums=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="built_in">int</span>[] datas=&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> chain2 = nums.Intersect(datas).Select(num=&gt;num);</span><br><span class="line"></span><br><span class="line"><span class="comment">//按照字符长度分组排序</span></span><br><span class="line"><span class="built_in">string</span>[] languages = &#123; <span class="string">&quot;Java&quot;</span>, <span class="string">&quot;XML&quot;</span>, <span class="string">&quot;C#&quot;</span>, <span class="string">&quot;PHP&quot;</span>, <span class="string">&quot;HTML&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;C++&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> chain3 = languages.</span><br><span class="line"><span class="keyword">foreach</span>(<span class="keyword">var</span> item <span class="keyword">in</span> chain3)</span><br><span class="line">&#123;</span><br><span class="line">  Console.WriteLine(<span class="string">$&quot;长度为<span class="subst">&#123;item.Key&#125;</span>的语言有:&quot;</span>);</span><br><span class="line">  <span class="keyword">foreach</span>(<span class="keyword">var</span> lan <span class="keyword">in</span> item)</span><br><span class="line">  &#123;</span><br><span class="line">    Console.Write(lan+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  Console.WriteLine();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按照字符长度分组排序</span></span><br><span class="line"><span class="built_in">string</span>[] languages = &#123; <span class="string">&quot;Java&quot;</span>, <span class="string">&quot;XML&quot;</span>, <span class="string">&quot;C#&quot;</span>, <span class="string">&quot;PHP&quot;</span>, <span class="string">&quot;HTML&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;C++&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> chain3 = languages.GroupBy(language=&gt;language.Length).OrderBy(g=&gt;g.Key).Select(g=&gt;g);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> chain3)</span><br><span class="line">&#123;</span><br><span class="line">  Console.WriteLine(<span class="string">$&quot;长度为<span class="subst">&#123;item.Key&#125;</span>的语言有:&quot;</span>);</span><br><span class="line">  <span class="keyword">foreach</span> (<span class="keyword">var</span> lan <span class="keyword">in</span> item)</span><br><span class="line">  &#123;</span><br><span class="line">    Console.Write(lan + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  Console.WriteLine();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">长度为1的语言有:</span></span><br><span class="line"><span class="comment">C,</span></span><br><span class="line"><span class="comment">长度为2的语言有:</span></span><br><span class="line"><span class="comment">C#,</span></span><br><span class="line"><span class="comment">长度为3的语言有:</span></span><br><span class="line"><span class="comment">XML,PHP,C++,</span></span><br><span class="line"><span class="comment">长度为4的语言有:</span></span><br><span class="line"><span class="comment">Java,HTML,</span></span><br><span class="line"><span class="comment">长度为10的语言有:</span></span><br><span class="line"><span class="comment">JavaScript,</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>LINQ查询结果</strong>：</p>
<p>LINQ查询结果（如<code>IEnumerable&lt;T&gt;</code>、<code>IQueryable&lt;T&gt;</code>等）也实现了<code>IEnumerable</code>接口，可以通过<code>foreach</code>循环对查询结果进行遍历。</p>
<h2 id="提供的高阶函数盘点"><a href="#提供的高阶函数盘点" class="headerlink" title="提供的高阶函数盘点"></a>提供的高阶函数盘点</h2><ul>
<li><p>Select</p>
<p>对集合中的每个元素应用一个函数，生成由结果组成的集合。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> squaredNumbers = numbers.Select(x =&gt; x * x);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Where</p>
<p>过滤集合中的元素，只保留符合条件的元素</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> evenNumbers = numbers.Where(x =&gt; x % <span class="number">2</span> == <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Aggregate</p>
<p>通过累积函数将集合元素规约为单一结果</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> sum = numbers.Aggregate((total, next) =&gt; total + next);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Any</p>
<p>检查集合中是否有任何元素满足给定条件</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> hasEven = numbers.Any(x =&gt; x % <span class="number">2</span> == <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>All</p>
<p>检查集合中的所有元素是否都满足给定条件</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> allEven = numbers.All(x =&gt; x % <span class="number">2</span> == <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>FirstOrDefault</p>
<p>查找集合中第一个满足条件的元素，如果不存在则返回类型的默认值(int则返回0,string则返回null)。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> firstEven = numbers.FirstOrDefault(x =&gt; x % <span class="number">2</span> == <span class="number">0</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="CSharp-断言"><a href="#CSharp-断言" class="headerlink" title="CSharp 断言"></a>CSharp 断言</h1><ol>
<li>Debug.Assert：这是在调试模式下使用的断言。它会在条件为假时引发异常，并且默认情况下在发布模式下会被忽略。</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Debug.Assert(condition, message);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Contract.Assert：这是在生产环境中使用的断言，可以在调试和发布模式下都生效。需要引用System.Diagnostics.Contracts命名空间。</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Contract.Assert(condition, message);</span><br></pre></td></tr></table></figure>

<p>在使用断言时，您可以指定一个条件和一个可选的消息。如果条件为假，断言会引发异常并显示消息。断言是一种在开发过程中帮助验证代码逻辑的有用工具，但应当注意，在生产环境中不要过度依赖断言。</p>
<h1 id="CSharp-网络通信"><a href="#CSharp-网络通信" class="headerlink" title="CSharp 网络通信"></a>CSharp 网络通信</h1><p>[[网络编程#CSharp网络通信|CSharp网络通信参考此处]]</p>
<h1 id="CSharp-计时"><a href="#CSharp-计时" class="headerlink" title="CSharp 计时"></a>CSharp 计时</h1><h2 id="Stopwatch"><a href="#Stopwatch" class="headerlink" title="Stopwatch"></a>Stopwatch</h2><p><code>Stopwatch</code>是C#中用于精确计时的核心工具，适用于性能调优、代码段耗时分析等场景。使用时需注意其<strong>非线程安全特性</strong>和环境稳定性，结合多次测量以提高结果可靠性</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>命名空间: <code>System.Diagnostics</code></p>
<p>计时操作盘点如下:</p>
<ul>
<li>开始计时: <code>Start()</code>  启动计时，支持多次调用以累积时间（需先停止计时）</li>
<li>停止计时: <code>Stop()</code>  暂停计时,可通过再次<code>Start()</code>继续累积</li>
<li>重启计时: <code>Restart()</code> 方法等同于<code>Stop()</code> + <code>Reset()</code> + <code>Start()</code>,清空历史时间后重新开始</li>
<li>重置计时器: <code>Reset()</code> 方法清空累积时间并停止计时</li>
</ul>
<p>获取时间结果操作盘点如下:</p>
<ul>
<li><strong>Elapsed</strong>：返回<code>TimeSpan</code>对象，表示总时间（如<code>00:00:02.1234567</code>）。</li>
<li><strong>ElapsedMilliseconds</strong>：返回总时间的毫秒数（如<code>2123</code>）。</li>
<li><strong>ElapsedTicks</strong>：返回计时器刻度数，需结合<code>Frequency</code>属性转换（高精度场景使用）</li>
</ul>
<p>状态检查操作: <code>IsRunning</code>：布尔属性，判断计时器是否正在运行 </p>
<p><strong>简化初始化</strong>：使用<code>Stopwatch.StartNew()</code>直接创建并启动实例</p>
<h3 id="最高效的Stopwatch使用方式"><a href="#最高效的Stopwatch使用方式" class="headerlink" title="最高效的Stopwatch使用方式"></a>最高效的Stopwatch使用方式</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> start = Stopwatch.GetTimestamp();</span><br><span class="line"><span class="comment">//需要计算的执行过程....</span></span><br><span class="line"><span class="keyword">var</span> elapsed = Stopwatch.GetElapsedTime(start);</span><br><span class="line"><span class="comment">//此时elapsed就是计算出来的执行过程的时间</span></span><br></pre></td></tr></table></figure>

<h1 id="CSharp-转换器"><a href="#CSharp-转换器" class="headerlink" title="CSharp 转换器"></a>CSharp 转换器</h1><h2 id="Converter"><a href="#Converter" class="headerlink" title="Converter"></a>Converter</h2><p>在C#中，<code>Convert</code>类是一个提供了各种数据类型之间转换的静态方法的类。<code>Convert</code>类提供了一系列用于将一种数据类型转换为另一种数据类型的方法，包括基本数据类型、日期时间类型、字符串等。以下是<code>Convert</code>类的一些常用方法：</p>
<ol>
<li><p><strong>ToBoolean</strong>：将其他数据类型转换为布尔类型。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;true&quot;</span>;</span><br><span class="line"><span class="built_in">bool</span> boolValue = Convert.ToBoolean(str);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>ToInt32</strong>：将其他数据类型转换为32位有符号整数。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;42&quot;</span>;</span><br><span class="line"><span class="built_in">int</span> intValue = Convert.ToInt32(str);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>ToDouble</strong>：将其他数据类型转换为双精度浮点数。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;3.14&quot;</span>;</span><br><span class="line"><span class="built_in">double</span> doubleValue = Convert.ToDouble(str);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>ToString</strong>：将其他数据类型转换为字符串。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> intValue = <span class="number">42</span>;</span><br><span class="line"><span class="built_in">string</span> str = Convert.ToString(intValue);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>ToDateTime</strong>：将其他数据类型转换为日期时间类型。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;2022-01-01&quot;</span>;</span><br><span class="line">DateTime dateTimeValue = Convert.ToDateTime(str);</span><br></pre></td></tr></table></figure></li>
</ol>
<p><code>Convert</code>类提供了一种方便的方式来进行数据类型之间的转换，避免了手动编写转换逻辑的繁琐。通过使用<code>Convert</code>类，您可以快速、安全地将不同数据类型之间进行转换，适用于各种数据处理和转换的场景。</p>
<h2 id="BitConverter"><a href="#BitConverter" class="headerlink" title="BitConverter"></a>BitConverter</h2><p><code>BitConverter</code>是C#中用于基本数据类型与字节数组之间相互转换的工具类。它提供了一系列静态方法，可以将各种基本数据类型（如整数、浮点数、布尔值等）转换为字节数组，或将字节数组转换为对应的基本数据类型。</p>
<ol>
<li><p><code>GetBytes</code>：将各种基本数据类型转换为字节数组。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> intValue = <span class="number">42</span>;</span><br><span class="line"><span class="built_in">byte</span>[] byteArray = BitConverter.GetBytes(intValue);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>ToInt32</code>：将4个字节的字节数组转换为32位有符号整数。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">byte</span>[] byteArray = &#123; <span class="number">0x2A</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span> &#125;;</span><br><span class="line"><span class="built_in">int</span> intValue = BitConverter.ToInt32(byteArray, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>ToSingle</code>：将4个字节的字节数组转换为单精度浮点数。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">byte</span>[] byteArray = &#123; <span class="number">0x40</span>, <span class="number">0x48</span>, <span class="number">0xF5</span>, <span class="number">0xC3</span> &#125;;</span><br><span class="line"><span class="built_in">float</span> floatValue = BitConverter.ToSingle(byteArray, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>GetBoolean</code> &#x2F; <code>GetChar</code> &#x2F; <code>GetDouble</code> &#x2F; <code>GetUInt16</code> &#x2F; <code>GetUInt32</code> 等：用于其他基本数据类型的转换。</p>
</li>
</ol>
<p><code>BitConverter</code>类提供了方便的方法来进行基本数据类型与字节数组之间的转换，适用于处理二进制数据、网络通信、文件操作等场景。</p>
<h2 id="Encoding"><a href="#Encoding" class="headerlink" title="Encoding"></a>Encoding</h2><p><code>Encoding</code>类是C#中用于字符编码和解码的类，位于<code>System.Text</code>命名空间中。它提供了一系列静态方法和属性，用于将文本数据转换为字节数组（编码）或将字节数组转换为文本数据（解码），支持多种字符编码方式，如UTF-8、UTF-16、ASCII等。</p>
<p>以下是<code>Encoding</code>类的一些常用方法和属性：</p>
<ol>
<li><p><code>GetBytes</code>：将字符串转换为字节数组，使用指定的编码方式。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="built_in">byte</span>[] byteArray = Encoding.UTF8.GetBytes(str);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>GetString</code>：将字节数组转换为字符串，使用指定的编码方式。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">byte</span>[] byteArray = &#123; <span class="number">72</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>, <span class="number">44</span>, <span class="number">32</span>, <span class="number">87</span>, <span class="number">111</span>, <span class="number">114</span>, <span class="number">108</span>, <span class="number">100</span>, <span class="number">33</span> &#125;;</span><br><span class="line"><span class="built_in">string</span> str = Encoding.UTF8.GetString(byteArray);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>UTF8</code> &#x2F; <code>UTF16</code> &#x2F; <code>ASCII</code>：表示常用的编码方式，如UTF-8编码、UTF-16编码、ASCII编码等。</p>
</li>
<li><p><code>GetEncoding</code>：根据编码名称获取对应的<code>Encoding</code>对象。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Encoding encoding = Encoding.GetEncoding(<span class="string">&quot;GBK&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<p><code>Encoding</code>类提供了丰富的功能和灵活的接口，可以帮助您在C#应用程序中处理不同编码方式的文本数据。通过使用<code>Encoding</code>类，您可以进行字符编码和解码操作，确保数据在不同系统和环境中的正确传输和处理。</p>
<h1 id="CSharp-Json处理"><a href="#CSharp-Json处理" class="headerlink" title="CSharp Json处理"></a>CSharp Json处理</h1><blockquote>
<p>此处记录一个vs很实用的工具,在编辑-选择性粘贴-将JSON粘贴为类<br>可以将Json字符串数据转换为类结构</p>
</blockquote>
<p> C# 中，处理 JSON 数据通常使用 <code>System.Text.Json</code> 或 <code>Newtonsoft.Json</code>（也称为 Json.NET）库。这两个库都非常流行且功能强大。以下是这两个库的详细介绍和使用示例。</p>
<blockquote>
<p>二者差异</p>
<p><strong>性能</strong>：</p>
<ul>
<li><code>System.Text.Json</code> 在性能上通常更快，尤其是在处理大量数据时。这是因为它是为 .NET Core 设计的，采用了更高效的内存管理策略。</li>
<li><code>Newtonsoft.Json</code> 在某些情况下可能会稍慢，但它的灵活性和功能丰富性弥补了这一点。</li>
</ul>
<p><strong>功能</strong>：</p>
<ul>
<li><code>Newtonsoft.Json</code> 提供了更多的功能，例如支持 LINQ to JSON、动态对象、复杂的自定义序列化和反序列化等。</li>
<li><code>System.Text.Json</code> 的功能相对较少，但在 .NET 5 及更高版本中，微软正在逐步添加更多功能。</li>
</ul>
<p><strong>配置选项</strong>：</p>
<ul>
<li><code>Newtonsoft.Json</code> 提供了丰富的配置选项，可以通过 <code>JsonSerializerSettings</code> 自定义序列化和反序列化的行为。</li>
<li><code>System.Text.Json</code> 的配置选项相对较少，但也在不断改进。</li>
</ul>
<p><strong>兼容性</strong>：</p>
<ul>
<li><code>Newtonsoft.Json</code> 可以在 .NET Framework 和 .NET Core 中使用，适用范围更广。</li>
<li><code>System.Text.Json</code> 是 .NET Core 3.0 及以上版本的内置库，适用于现代 .NET 应用程序。</li>
</ul>
</blockquote>
<h2 id="System-Text-Json"><a href="#System-Text-Json" class="headerlink" title="System.Text.Json"></a>System.Text.Json</h2><p><code>System.Text.Json</code> 是 .NET Core 3.0 和更高版本中内置的 JSON 处理库，性能较高且使用简单。</p>
<h3 id="序列化（对象转-JSON）"><a href="#序列化（对象转-JSON）" class="headerlink" title="序列化（对象转 JSON）"></a>序列化（对象转 JSON）</h3><p>将 C# 对象转换为 JSON 字符串：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Text.Json;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person &#123; Name = <span class="string">&quot;张三&quot;</span>, Age = <span class="number">30</span> &#125;;</span><br><span class="line">        <span class="built_in">string</span> jsonString = JsonSerializer.Serialize(person);</span><br><span class="line">        Console.WriteLine(jsonString); <span class="comment">// 输出: &#123;&quot;Name&quot;:&quot;张三&quot;,&quot;Age&quot;:30&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="反序列化（JSON-转对象）"><a href="#反序列化（JSON-转对象）" class="headerlink" title="反序列化（JSON 转对象）"></a>反序列化（JSON 转对象）</h3><p>将 JSON 字符串转换为 C# 对象：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Text.Json;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> jsonString = <span class="string">&quot;&#123;\&quot;Name\&quot;:\&quot;张三\&quot;,\&quot;Age\&quot;:30&#125;&quot;</span>;</span><br><span class="line">        Person person = JsonSerializer.Deserialize&lt;Person&gt;(jsonString);</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Name: <span class="subst">&#123;person.Name&#125;</span>, Age: <span class="subst">&#123;person.Age&#125;</span>&quot;</span>); <span class="comment">// 输出: Name: 张三, Age: 30</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="处理复杂类型"><a href="#处理复杂类型" class="headerlink" title="处理复杂类型"></a>处理复杂类型</h3><p>对于复杂类型（如嵌套对象、集合等），<code>System.Text.Json</code> 也支持：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Company</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Person&gt; Employees &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Company company = <span class="keyword">new</span> Company</span><br><span class="line">        &#123;</span><br><span class="line">            Name = <span class="string">&quot;ABC公司&quot;</span>,</span><br><span class="line">            Employees = <span class="keyword">new</span> List&lt;Person&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">new</span> Person &#123; Name = <span class="string">&quot;张三&quot;</span>, Age = <span class="number">30</span> &#125;,</span><br><span class="line">                <span class="keyword">new</span> Person &#123; Name = <span class="string">&quot;李四&quot;</span>, Age = <span class="number">25</span> &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> jsonString = JsonSerializer.Serialize(company);</span><br><span class="line">        Console.WriteLine(jsonString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更复杂的案例</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DeviceConfigs</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> ObservableDictionary&lt;<span class="built_in">string</span>, DeviceConfig&gt; model &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="keyword">new</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DeviceConfig</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">JsonConverter(typeof(PortConverter))</span>]</span><br><span class="line">    <span class="keyword">public</span> DevicePort port &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">DevicePort</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">string</span> Type &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SwitchPort</span> : <span class="title">DevicePort</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> Type =&gt; <span class="string">&quot;SwitchMatch&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> firstCtl &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> secondCtl &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> firstFbk &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> secondFbk &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AnalogMonitorPort</span> : <span class="title">DevicePort</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> Type =&gt; <span class="string">&quot;AnalogMonitorMatch&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> port &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ControllerPort</span> : <span class="title">DevicePort</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> Type =&gt; <span class="string">&quot;ControllerMatch&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> controlSet &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> controlFdbk &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DigitalPort</span> : <span class="title">DevicePort</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> Type =&gt; <span class="string">&quot;DigitalMatch&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> port &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PowerPort</span> : <span class="title">DevicePort</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> Type =&gt; <span class="string">&quot;PowerMatch&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> openSet &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> openFdbk &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> closeSet &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> closeFdbk &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> enableSet &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> enableFdbk &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> alarmFdbk &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> controlSet &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> controlFdbk &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> loadSet &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> loadFdbk &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TurboPumpPort</span> : <span class="title">DevicePort</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> Type =&gt; <span class="string">&quot;TurboPumpMatch&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> openSet &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> normal &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> alarm &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FaradayCupPort</span> : <span class="title">DevicePort</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> Type =&gt; <span class="string">&quot;FaradayCupMatch&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> range1 &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> range2 &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> range3 &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> current &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个自定义 JSON 转换器，用于处理 DevicePort 及其子类的序列化和反序列化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PortConverter</span> : <span class="title">JsonConverter</span>&lt;<span class="title">DevicePort</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 反序列化方法：将 JSON 数据转换为具体的 DevicePort 子类对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> DevicePort? Read(<span class="keyword">ref</span> Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 使用 JsonDocument 解析 JSON 数据，using 确保及时释放资源</span></span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">var</span> jsonDoc = JsonDocument.ParseValue(<span class="keyword">ref</span> reader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 JSON 根元素以便访问属性</span></span><br><span class="line">        <span class="keyword">var</span> root = jsonDoc.RootElement;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从 JSON 中获取必须的 Type 属性，用于确定具体子类类型</span></span><br><span class="line">        <span class="keyword">var</span> type = root.GetProperty(<span class="string">&quot;Type&quot;</span>).GetString();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据 Type 字段值选择对应的子类进行反序列化</span></span><br><span class="line">        <span class="keyword">return</span> type <span class="keyword">switch</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 当 Type 为 &quot;SwitchMatch&quot; 时，反序列化为 SwitchPort 对象</span></span><br><span class="line">            <span class="string">&quot;SwitchMatch&quot;</span> =&gt; JsonSerializer.Deserialize&lt;SwitchPort&gt;(root.GetRawText()),</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当 Type 为 &quot;AnalogMonitorMatch&quot; 时，反序列化为 AnalogMonitorPort 对象</span></span><br><span class="line">            <span class="string">&quot;AnalogMonitorMatch&quot;</span> =&gt; JsonSerializer.Deserialize&lt;AnalogMonitorPort&gt;(root.GetRawText()),</span><br><span class="line"></span><br><span class="line">            <span class="string">&quot;ControllerMatch&quot;</span> =&gt; JsonSerializer.Deserialize&lt;ControllerPort&gt;(root.GetRawText()),</span><br><span class="line"></span><br><span class="line">            <span class="string">&quot;DigitalMatch&quot;</span> =&gt; JsonSerializer.Deserialize&lt;DigitalPort&gt;(root.GetRawText()),</span><br><span class="line"></span><br><span class="line">            <span class="string">&quot;PowerMatch&quot;</span> =&gt; JsonSerializer.Deserialize&lt;PowerPort&gt;(root.GetRawText()),</span><br><span class="line"></span><br><span class="line">            <span class="string">&quot;TurboPumpMatch&quot;</span> =&gt; JsonSerializer.Deserialize&lt;TurboPumpPort&gt;(root.GetRawText()),</span><br><span class="line"></span><br><span class="line">            <span class="string">&quot;FaradayCupMatch&quot;</span> =&gt; JsonSerializer.Deserialize&lt;FaradayCupPort&gt;(root.GetRawText()),</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 在此处可以继续添加其他设备端口类型的处理逻辑...</span></span><br><span class="line">            <span class="comment">// 示例:</span></span><br><span class="line">            <span class="comment">// &quot;DigitalInputMatch&quot; =&gt; JsonSerializer.Deserialize&lt;DigitalInputPort&gt;(...),</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遇到未知类型时抛出异常，防止无效数据</span></span><br><span class="line">            _ =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> JsonException(<span class="string">$&quot;未知的设备端口类型: <span class="subst">&#123;type&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化方法：将 DevicePort 及其子类对象写入 JSON</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Write</span>(<span class="params">Utf8JsonWriter writer, DevicePort <span class="keyword">value</span>, JsonSerializerOptions options</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将对象转换为基类 object 类型进行序列化，以支持多态序列化</span></span><br><span class="line">        <span class="comment">// 这会触发系统默认的多态序列化处理，保留子类特有的属性</span></span><br><span class="line">        JsonSerializer.Serialize(writer, (<span class="built_in">object</span>)<span class="keyword">value</span>, options);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//序列化:</span></span><br><span class="line">DeviceConfigs deviceConfigs = <span class="keyword">new</span>();</span><br><span class="line">deviceConfigs.model.Add(<span class="string">&quot;device1&quot;</span>, <span class="keyword">new</span> DeviceConfig</span><br><span class="line">&#123;</span><br><span class="line">    port = <span class="keyword">new</span> SwitchPort</span><br><span class="line">    &#123;</span><br><span class="line">        firstCtl = <span class="string">&quot;xxxx.yyyy.zzz&quot;</span>,</span><br><span class="line">        secondCtl = <span class="string">&quot;&quot;</span>,</span><br><span class="line">        firstFbk = <span class="string">&quot;&quot;</span>,</span><br><span class="line">        secondFbk = <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">deviceConfigs.model.Add(<span class="string">&quot;device2&quot;</span>, <span class="keyword">new</span> DeviceConfig</span><br><span class="line">&#123;</span><br><span class="line">    port = <span class="keyword">new</span> AnalogMonitorPort</span><br><span class="line">    &#123;</span><br><span class="line">        port = <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">deviceConfigs.model.Add(<span class="string">&quot;device3&quot;</span>, <span class="keyword">new</span> DeviceConfig</span><br><span class="line">&#123;</span><br><span class="line">    port = <span class="keyword">new</span> PowerPort</span><br><span class="line">    &#123;</span><br><span class="line">        openSet = <span class="string">&quot;&quot;</span>,</span><br><span class="line">        openFdbk = <span class="string">&quot;&quot;</span>,</span><br><span class="line">        closeSet = <span class="string">&quot;&quot;</span>,</span><br><span class="line">        closeFdbk = <span class="string">&quot;&quot;</span>,</span><br><span class="line">        enableSet = <span class="string">&quot;&quot;</span>,</span><br><span class="line">        enableFdbk = <span class="string">&quot;&quot;</span>,</span><br><span class="line">        alarmFdbk = <span class="string">&quot;&quot;</span>,</span><br><span class="line">        controlSet = <span class="string">&quot;&quot;</span>,</span><br><span class="line">        controlFdbk = <span class="string">&quot;&quot;</span>,</span><br><span class="line">        loadSet = <span class="string">&quot;&quot;</span>,</span><br><span class="line">        loadFdbk = <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> jsonString2 = JsonSerializer.Serialize(deviceConfigs);</span><br></pre></td></tr></table></figure>

<h3 id="中文json序列化"><a href="#中文json序列化" class="headerlink" title="中文json序列化"></a>中文json序列化</h3><p>JSON序列化时默认将Unicode字符转义了,要让JSON文件中正确显示中文,我们需要修改JsonSerializerOptions的设置,如下:</p>
<p>原本JSON中显示中文为:<code>\u805A\u7126\u676F</code></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> JsonSerializerOptions _options = <span class="keyword">new</span>()</span><br><span class="line">&#123;</span><br><span class="line">    WriteIndented = <span class="literal">false</span>,</span><br><span class="line">    Encoder = System.Text.Encodings.Web.JavaScriptEncoder.UnsafeRelaxedJsonEscaping</span><br><span class="line">&#125;;</span><br><span class="line">JsonSerializer.Serialize(obj, _options);</span><br></pre></td></tr></table></figure>

<p>修改后JSON中的中文为:<code>聚焦杯</code></p>
<p><a href="#Newtonsoft.Json">Newtonsoft.Json</a>默认就支持正确显示中文</p>
<h2 id="Newtonsoft-Json"><a href="#Newtonsoft-Json" class="headerlink" title="Newtonsoft.Json"></a>Newtonsoft.Json</h2><p><code>Newtonsoft.Json</code> 是一个非常流行的第三方库，功能强大，支持更多的功能和灵活性。</p>
<p>通过 NuGet 包管理器安装 <code>Newtonsoft.Json</code></p>
<h3 id="序列化（对象转-JSON）-1"><a href="#序列化（对象转-JSON）-1" class="headerlink" title="序列化（对象转 JSON）"></a>序列化（对象转 JSON）</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Newtonsoft.Json;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person &#123; Name = <span class="string">&quot;张三&quot;</span>, Age = <span class="number">30</span> &#125;;</span><br><span class="line">        <span class="built_in">string</span> jsonString = JsonConvert.SerializeObject(person);</span><br><span class="line">        Console.WriteLine(jsonString); <span class="comment">// 输出: &#123;&quot;Name&quot;:&quot;张三&quot;,&quot;Age&quot;:30&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="反序列化（JSON-转对象）-1"><a href="#反序列化（JSON-转对象）-1" class="headerlink" title="反序列化（JSON 转对象）"></a>反序列化（JSON 转对象）</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Newtonsoft.Json;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> jsonString = <span class="string">&quot;&#123;\&quot;Name\&quot;:\&quot;张三\&quot;,\&quot;Age\&quot;:30&#125;&quot;</span>;</span><br><span class="line">        Person person = JsonConvert.DeserializeObject&lt;Person&gt;(jsonString);</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Name: <span class="subst">&#123;person.Name&#125;</span>, Age: <span class="subst">&#123;person.Age&#125;</span>&quot;</span>); <span class="comment">// 输出: Name: 张三, Age: 30</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="处理复杂类型-1"><a href="#处理复杂类型-1" class="headerlink" title="处理复杂类型"></a>处理复杂类型</h3><p>与 <code>System.Text.Json</code> 类似，<code>Newtonsoft.Json</code> 也支持复杂类型的序列化和反序列化。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Company</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Person&gt; Employees &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Company company = <span class="keyword">new</span> Company</span><br><span class="line">        &#123;</span><br><span class="line">            Name = <span class="string">&quot;ABC公司&quot;</span>,</span><br><span class="line">            Employees = <span class="keyword">new</span> List&lt;Person&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">new</span> Person &#123; Name = <span class="string">&quot;张三&quot;</span>, Age = <span class="number">30</span> &#125;,</span><br><span class="line">                <span class="keyword">new</span> Person &#123; Name = <span class="string">&quot;李四&quot;</span>, Age = <span class="number">25</span> &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> jsonString = JsonConvert.SerializeObject(company);</span><br><span class="line">        Console.WriteLine(jsonString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置JsonSerializerSettings</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Newtonsoft.Json;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DateTime BirthDate &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于演示的属性，设置为忽略</span></span><br><span class="line">    [<span class="meta">JsonIgnore</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Secret &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> person = <span class="keyword">new</span> Person</span><br><span class="line">        &#123;</span><br><span class="line">            Name = <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">            Age = <span class="number">30</span>,</span><br><span class="line">            BirthDate = <span class="keyword">new</span> DateTime(<span class="number">1993</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">            Secret = <span class="string">&quot;这是一个秘密&quot;</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 JsonSerializerSettings 实例</span></span><br><span class="line">        <span class="keyword">var</span> settings = <span class="keyword">new</span> JsonSerializerSettings</span><br><span class="line">        &#123;</span><br><span class="line">            Formatting = Formatting.Indented, <span class="comment">// 设置缩进格式</span></span><br><span class="line">            DateFormatString = <span class="string">&quot;yyyy-MM-dd&quot;</span>, <span class="comment">// 设置日期格式</span></span><br><span class="line">            NullValueHandling = NullValueHandling.Ignore, <span class="comment">// 忽略 null 值</span></span><br><span class="line">            DefaultValueHandling = DefaultValueHandling.Ignore <span class="comment">// 忽略默认值</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 序列化</span></span><br><span class="line">        <span class="built_in">string</span> jsonString = JsonConvert.SerializeObject(person, settings);</span><br><span class="line">        Console.WriteLine(jsonString);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        <span class="keyword">var</span> deserializedPerson = JsonConvert.DeserializeObject&lt;Person&gt;(jsonString);</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Name: <span class="subst">&#123;deserializedPerson.Name&#125;</span>, Age: <span class="subst">&#123;deserializedPerson.Age&#125;</span>, BirthDate: <span class="subst">&#123;deserializedPerson.BirthDate.ToString(<span class="string">&quot;yyyy-MM-dd&quot;</span>)&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>Formatting</strong>:</p>
<p><code>Formatting.Indented</code> 设置 JSON 字符串的格式为缩进格式，更易于阅读。</p>
</li>
<li><p><strong>DateFormatString</strong>:</p>
<p><code>DateFormatString</code> 用于指定日期的格式。在这个例子中，日期格式设置为 <code>&quot;yyyy-MM-dd&quot;</code>，这样序列化后的日期将以这种格式输出。</p>
</li>
<li><p><strong>NullValueHandling</strong>:</p>
<p><code>NullValueHandling.Ignore</code> 表示在序列化时忽略值为 <code>null</code> 的属性。如果 <code>Secret</code> 属性为 <code>null</code>，它将不会出现在序列化后的 JSON 中。</p>
</li>
<li><p><strong>DefaultValueHandling</strong>:</p>
<p><code>DefaultValueHandling.Ignore</code> 表示在序列化时忽略默认值的属性（如整数的默认值为 0，布尔值的默认值为 false）。</p>
</li>
<li><p><strong>JsonIgnore</strong>:</p>
<p><code>JsonIgnore</code> 特性用于标记在序列化和反序列化过程中应被忽略的属性。在这个例子中，<code>Secret</code> 属性不会出现在序列化的 JSON 中。</p>
</li>
</ol>
<h3 id="LINQ-to-JSON"><a href="#LINQ-to-JSON" class="headerlink" title="LINQ to JSON"></a>LINQ to JSON</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Newtonsoft.Json;</span><br><span class="line"><span class="keyword">using</span> Newtonsoft.Json.Linq;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 示例 JSON 字符串</span></span><br><span class="line">        <span class="built_in">string</span> jsonString = <span class="string">@&quot;</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            &#x27;Name&#x27;: &#x27;张三&#x27;,</span></span><br><span class="line"><span class="string">            &#x27;Age&#x27;: 30,</span></span><br><span class="line"><span class="string">            &#x27;BirthDate&#x27;: &#x27;1993-01-01&#x27;,</span></span><br><span class="line"><span class="string">            &#x27;Hobbies&#x27;: [&#x27;阅读&#x27;, &#x27;旅行&#x27;, &#x27;游泳&#x27;],</span></span><br><span class="line"><span class="string">            &#x27;Address&#x27;: &#123;</span></span><br><span class="line"><span class="string">                &#x27;City&#x27;: &#x27;北京&#x27;,</span></span><br><span class="line"><span class="string">                &#x27;ZipCode&#x27;: &#x27;100000&#x27;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析 JSON 字符串为 JObject</span></span><br><span class="line">        JObject person = JObject.Parse(jsonString);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查询属性</span></span><br><span class="line">        <span class="built_in">string</span> name = (<span class="built_in">string</span>)person[<span class="string">&quot;Name&quot;</span>];</span><br><span class="line">        <span class="built_in">int</span> age = (<span class="built_in">int</span>)person[<span class="string">&quot;Age&quot;</span>];</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Name: <span class="subst">&#123;name&#125;</span>, Age: <span class="subst">&#123;age&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查询数组</span></span><br><span class="line">        JArray hobbies = (JArray)person[<span class="string">&quot;Hobbies&quot;</span>];</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Hobbies:&quot;</span>);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> hobby <span class="keyword">in</span> hobbies)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;- <span class="subst">&#123;hobby&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查询嵌套对象</span></span><br><span class="line">        JObject address = (JObject)person[<span class="string">&quot;Address&quot;</span>];</span><br><span class="line">        <span class="built_in">string</span> city = (<span class="built_in">string</span>)address[<span class="string">&quot;City&quot;</span>];</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;City: <span class="subst">&#123;city&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改属性</span></span><br><span class="line">        person[<span class="string">&quot;Age&quot;</span>] = <span class="number">31</span>; <span class="comment">// 更新年龄</span></span><br><span class="line">        person[<span class="string">&quot;Hobbies&quot;</span>].Add(<span class="string">&quot;跑步&quot;</span>); <span class="comment">// 添加新的爱好</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出修改后的 JSON</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;修改后的 JSON:&quot;</span>);</span><br><span class="line">        Console.WriteLine(person.ToString(Formatting.Indented)); <span class="comment">// 格式化输出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="属性盘点-1"><a href="#属性盘点-1" class="headerlink" title="属性盘点"></a>属性盘点</h3><p>Newtonsoft.Json（也称为 Json.NET）是 .NET 生态中最常用的 JSON 处理库之一。它提供了一系列属性（Attributes）来控制序列化和反序列化的行为。以下是 Newtonsoft.Json 中常用的属性：</p>
<h4 id="JsonProperty"><a href="#JsonProperty" class="headerlink" title="JsonProperty"></a>JsonProperty</h4><p>用于修改JSON序列化和反序列化时的属性名称,默认值等</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">JsonProperty(<span class="string">&quot;full_name&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">		</span><br><span class="line">  	<span class="comment">//这个选项表示如果属性的值是其默认值，则在序列化时会忽略该属性</span></span><br><span class="line">    [<span class="meta">JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作用:</p>
<ul>
<li>设定JSON对应的键名(如full_name)</li>
<li>控制默认值的处理(DefaultValueHandling)</li>
</ul>
<h4 id="JsonIgnore"><a href="#JsonIgnore" class="headerlink" title="JsonIgnore"></a>JsonIgnore</h4><p>用于忽略某个属性，使其不被序列化或反序列化</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">User</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Username &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">		</span><br><span class="line">  	<span class="comment">//Password 不会出现在序列化后的 JSON 中</span></span><br><span class="line">    [<span class="meta">JsonIgnore</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Password &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JsonConverter"><a href="#JsonConverter" class="headerlink" title="JsonConverter"></a>JsonConverter</h4><p>指定某个属性的自定义 JSON 转换器</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Product</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">		</span><br><span class="line">  	<span class="comment">//允许枚举值序列化为字符串，而不是默认的整数</span></span><br><span class="line">    [<span class="meta">JsonConverter(typeof(StringEnumConverter))</span>]</span><br><span class="line">    <span class="keyword">public</span> ProductType Type &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> ProductType</span><br><span class="line">&#123;</span><br><span class="line">    Physical,</span><br><span class="line">    Digital</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JsonObject"><a href="#JsonObject" class="headerlink" title="JsonObject"></a>JsonObject</h4><p>用于控制类的序列化方式</p>
<p>如: OptIn 模式下，只有标记 [JsonProperty] 的属性才会被序列化。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">JsonObject(MemberSerialization.OptIn)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">JsonProperty</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Salary &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;  <span class="comment">// 该字段不会被序列化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul>
<li>JsonArray,用于控制数组或集合的序列化行为,如指定数组的元素是否为必选项</li>
<li>JsonDictionary,用于自定义字典类型的JSON序列化行为,如允许自定义字典类型的序列化方式</li>
<li>JsonExtensionData,用于接收额外的未映射 JSON 数据,如将JSON中不匹配的额外数据存入ExtraData字典</li>
<li>JsonRequired,用于强制要求某个属性在JSON数据中存在,否则弹出异常,如:如果MustHave在JSON中缺失,则反序列化时会抛出异常</li>
<li>JsonConstructor,用于指定某个构造函数供JSON反序列化时使用,如:指定反序列化时调用的构造函数</li>
</ul>
<h3 id="复杂案例"><a href="#复杂案例" class="headerlink" title="复杂案例"></a>复杂案例</h3><p>结构如图:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202502270935035.png" alt="image-20250227093423523"></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DateTime BirthDate &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新增的喜爱物品属性（使用基类类型）</span></span><br><span class="line">    <span class="keyword">public</span> Item FavoriteItem &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">JsonIgnore</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Secret &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 物品基类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Item</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">enum</span> ItemType</span><br><span class="line">    &#123;</span><br><span class="line">        Clothing,</span><br><span class="line">        Digital,</span><br><span class="line">        Food</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ItemType Type &#123; <span class="keyword">get</span>; <span class="keyword">protected</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 衣服类物品</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ClothingItem</span> : <span class="title">Item</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClothingItem</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Type = ItemType.Clothing;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Size &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;  <span class="comment">// 例如：&quot;XL&quot;, &quot;M&quot;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Color &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">// 例如：&quot;红色&quot;, &quot;深蓝&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数码类物品</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DigitalItem</span> : <span class="title">Item</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DigitalItem</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Type = ItemType.Digital;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">decimal</span> Price &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;       <span class="comment">// 价格</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> UseBattery &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;     <span class="comment">// 是否使用电池</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 食品类物品</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FoodItem</span> : <span class="title">Item</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FoodItem</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Type = ItemType.Food;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> NeedHeating &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;    <span class="comment">// 是否需要加热</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> WeightGrams &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">// 重量（克）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//序列化并保存代码:</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person</span><br><span class="line">&#123;</span><br><span class="line">    Name = <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">    Age = <span class="number">30</span>,</span><br><span class="line">    BirthDate = <span class="keyword">new</span> DateTime(<span class="number">1993</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">    Secret = <span class="string">&quot;这是一个秘密&quot;</span>,</span><br><span class="line">    FavoriteItem = <span class="keyword">new</span> ClothingItem</span><br><span class="line">    &#123;</span><br><span class="line">        Size = <span class="string">&quot;L&quot;</span>,</span><br><span class="line">        Color = <span class="string">&quot;白色&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Console.WriteLine((person.FavoriteItem <span class="keyword">as</span> ClothingItem)?.Size);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 JsonSerializerSettings 实例</span></span><br><span class="line"><span class="keyword">var</span> settings = <span class="keyword">new</span> JsonSerializerSettings</span><br><span class="line">&#123;</span><br><span class="line">    Formatting = Newtonsoft.Json.Formatting.Indented, <span class="comment">// 设置缩进格式</span></span><br><span class="line">    DateFormatString = <span class="string">&quot;yyyy-MM-dd&quot;</span>, <span class="comment">// 设置日期格式</span></span><br><span class="line">    NullValueHandling = NullValueHandling.Ignore, <span class="comment">// 忽略 null 值</span></span><br><span class="line">    DefaultValueHandling = DefaultValueHandling.Ignore <span class="comment">// 忽略默认值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化</span></span><br><span class="line"><span class="built_in">string</span> jsonString = JsonConvert.SerializeObject(person, settings);</span><br><span class="line">Console.WriteLine(jsonString);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存到当前目录</span></span><br><span class="line"><span class="built_in">string</span> filePath = Path.Combine(Directory.GetCurrentDirectory(), <span class="string">&quot;person.json&quot;</span>);</span><br><span class="line">File.WriteAllText(filePath, jsonString);</span><br></pre></td></tr></table></figure>

<p>最终产出的json</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Age&quot;</span><span class="punctuation">:</span> <span class="number">30</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;BirthDate&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1993-01-01&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;FavoriteItem&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Size&quot;</span><span class="punctuation">:</span> <span class="string">&quot;L&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Color&quot;</span><span class="punctuation">:</span> <span class="string">&quot;白色&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>下面的复杂案例可以与System.Text.Json中的复杂案例对比看</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Newtonsoft.Json;</span><br><span class="line"><span class="keyword">using</span> Newtonsoft.Json.Linq;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DeviceConfigs</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Dictionary&lt;<span class="built_in">string</span>, DeviceConfig&gt; model &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="keyword">new</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DeviceConfig</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">JsonConverter(typeof(PortConverter))</span>]</span><br><span class="line">    <span class="keyword">public</span> DevicePort port &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">DevicePort</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">string</span> Type &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SwitchPort</span> : <span class="title">DevicePort</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> Type =&gt; <span class="string">&quot;SwitchMatch&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> firstCtl &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> secondCtl &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> firstFbk &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> secondFbk &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AnalogMonitorPort</span> : <span class="title">DevicePort</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> Type =&gt; <span class="string">&quot;AnalogMonitorMatch&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> port &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ControllerPort</span> : <span class="title">DevicePort</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> Type =&gt; <span class="string">&quot;ControllerMatch&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> controlSet &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> controlFdbk &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DigitalPort</span> : <span class="title">DevicePort</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> Type =&gt; <span class="string">&quot;DigitalMatch&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> port &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PowerPort</span> : <span class="title">DevicePort</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> Type =&gt; <span class="string">&quot;PowerMatch&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> openSet &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> openFdbk &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> closeSet &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> closeFdbk &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> enableSet &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> enableFdbk &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> alarmFdbk &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> controlSet &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> controlFdbk &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> loadSet &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> loadFdbk &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TurboPumpPort</span> : <span class="title">DevicePort</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> Type =&gt; <span class="string">&quot;TurboPumpMatch&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> openSet &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> normal &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> alarm &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FaradayCupPort</span> : <span class="title">DevicePort</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> Type =&gt; <span class="string">&quot;FaradayCupMatch&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> range1 &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> range2 &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> range3 &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> current &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PortConverter</span> : <span class="title">JsonConverter</span>&lt;<span class="title">DevicePort</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> CanWrite =&gt; <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">WriteJson</span>(<span class="params">JsonWriter writer, DevicePort <span class="keyword">value</span>, JsonSerializer serializer</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> jo = <span class="keyword">new</span> JObject();</span><br><span class="line">        <span class="comment">// jo.Add(&quot;$type&quot;, value.GetType().Name);</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> <span class="keyword">value</span>.GetType().GetProperties())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (prop.CanRead)</span><br><span class="line">            &#123;</span><br><span class="line">                jo.Add(prop.Name, JToken.FromObject(prop.GetValue(<span class="keyword">value</span>), serializer));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        jo.WriteTo(writer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> DevicePort <span class="title">ReadJson</span>(<span class="params">JsonReader reader, Type objectType, DevicePort existingValue, <span class="built_in">bool</span> hasExistingValue, JsonSerializer serializer</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        JObject jo = JObject.Load(reader);</span><br><span class="line">        <span class="built_in">string</span> typeName = jo[<span class="string">&quot;Type&quot;</span>]?.Value&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line"></span><br><span class="line">        DevicePort port = typeName <span class="keyword">switch</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;SwitchMatch&quot;</span> =&gt; <span class="keyword">new</span> SwitchPort(),</span><br><span class="line">            <span class="string">&quot;AnalogMonitorMatch&quot;</span> =&gt; <span class="keyword">new</span> AnalogMonitorPort(),</span><br><span class="line">            <span class="string">&quot;ControllerMatch&quot;</span> =&gt; <span class="keyword">new</span> ControllerPort(),</span><br><span class="line">            <span class="string">&quot;DigitalMatch&quot;</span> =&gt; <span class="keyword">new</span> DigitalPort(),</span><br><span class="line">            <span class="string">&quot;PowerMatch&quot;</span> =&gt; <span class="keyword">new</span> PowerPort(),</span><br><span class="line">            <span class="string">&quot;TurboPumpMatch&quot;</span> =&gt; <span class="keyword">new</span> TurboPumpPort(),</span><br><span class="line">            <span class="string">&quot;FaradayCupMatch&quot;</span> =&gt; <span class="keyword">new</span> FaradayCupPort(),</span><br><span class="line">            _ =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> JsonSerializationException(<span class="string">&quot;Unknown device port type: &quot;</span> + typeName)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        serializer.Populate(jo.CreateReader(), port);</span><br><span class="line">        <span class="keyword">return</span> port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// public override bool CanConvert(Type objectType)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     return typeof(DevicePort).IsAssignableFrom(objectType);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        DeviceConfigs deviceConfigs = <span class="keyword">new</span>();</span><br><span class="line">        deviceConfigs.model.Add(<span class="string">&quot;device1&quot;</span>, <span class="keyword">new</span> DeviceConfig</span><br><span class="line">        &#123;</span><br><span class="line">            port = <span class="keyword">new</span> SwitchPort</span><br><span class="line">            &#123;</span><br><span class="line">                firstCtl = <span class="string">&quot;xxxx.yyyy.zzz&quot;</span>,</span><br><span class="line">                secondCtl = <span class="string">&quot;&quot;</span>,</span><br><span class="line">                firstFbk = <span class="string">&quot;&quot;</span>,</span><br><span class="line">                secondFbk = <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        deviceConfigs.model.Add(<span class="string">&quot;device2&quot;</span>, <span class="keyword">new</span> DeviceConfig</span><br><span class="line">        &#123;</span><br><span class="line">            port = <span class="keyword">new</span> AnalogMonitorPort</span><br><span class="line">            &#123;</span><br><span class="line">                port = <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        deviceConfigs.model.Add(<span class="string">&quot;device3&quot;</span>, <span class="keyword">new</span> DeviceConfig</span><br><span class="line">        &#123;</span><br><span class="line">            port = <span class="keyword">new</span> PowerPort</span><br><span class="line">            &#123;</span><br><span class="line">                openSet = <span class="string">&quot;&quot;</span>,</span><br><span class="line">                openFdbk = <span class="string">&quot;&quot;</span>,</span><br><span class="line">                closeSet = <span class="string">&quot;&quot;</span>,</span><br><span class="line">                closeFdbk = <span class="string">&quot;&quot;</span>,</span><br><span class="line">                enableSet = <span class="string">&quot;&quot;</span>,</span><br><span class="line">                enableFdbk = <span class="string">&quot;&quot;</span>,</span><br><span class="line">                alarmFdbk = <span class="string">&quot;&quot;</span>,</span><br><span class="line">                controlSet = <span class="string">&quot;&quot;</span>,</span><br><span class="line">                controlFdbk = <span class="string">&quot;&quot;</span>,</span><br><span class="line">                loadSet = <span class="string">&quot;&quot;</span>,</span><br><span class="line">                loadFdbk = <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> settings = <span class="keyword">new</span> JsonSerializerSettings</span><br><span class="line">        &#123;</span><br><span class="line">            Formatting = Formatting.Indented,</span><br><span class="line">            NullValueHandling = NullValueHandling.Ignore,</span><br><span class="line">            TypeNameHandling = TypeNameHandling.None</span><br><span class="line">        &#125;;</span><br><span class="line">				<span class="comment">//序列化</span></span><br><span class="line">        <span class="built_in">string</span> json = JsonConvert.SerializeObject(deviceConfigs, settings);</span><br><span class="line">        Console.WriteLine(json);</span><br><span class="line">				<span class="comment">//反序列化</span></span><br><span class="line">        <span class="keyword">var</span> deserializedConfigs = JsonConvert.DeserializeObject&lt;DeviceConfigs&gt;(json, settings);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;\nDeserialized Configs:&quot;</span>);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> device <span class="keyword">in</span> deserializedConfigs.model)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;Device: <span class="subst">&#123;device.Key&#125;</span>, Port Type: <span class="subst">&#123;device.Value.port.Type&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="CSharp-Entity-Framework"><a href="#CSharp-Entity-Framework" class="headerlink" title="CSharp Entity Framework"></a>CSharp Entity Framework</h1><blockquote>
<p>EF 和 EF Core的区别:</p>
<ul>
<li><p><strong>Entity Framework</strong>：是一个较早的 ORM 框架，主要用于 .NET Framework，提供了一种简单的方法来与数据库交互。它支持多种数据库，但在性能和灵活性方面有一些限制。</p>
</li>
<li><p><strong>Entity Framework Core</strong>：是一个跨平台的 ORM 框架，旨在支持 .NET Core 和 .NET 5&#x2F;6 及更高版本。EF Core 进行了重写，提供了更好的性能、更灵活的 API 和对新功能的支持（如异步编程）。</p>
</li>
</ul>
<p>下面主要都是介绍EF Core</p>
</blockquote>
<table>
<thead>
<tr>
<th>特性</th>
<th>Entity Framework (EF 6)</th>
<th>Entity Framework Core (EF Core)</th>
</tr>
</thead>
<tbody><tr>
<td>平台</td>
<td>仅支持 .NET Framework</td>
<td>支持 .NET Core、.NET Framework、Xamarin、UWP 等跨平台开发</td>
</tr>
<tr>
<td>轻量化</td>
<td>体积较大，依赖较多</td>
<td>轻量化、模块化设计，性能更高</td>
</tr>
<tr>
<td>跨平台支持</td>
<td>仅支持 Windows</td>
<td>支持跨平台（Windows、Linux、macOS）</td>
</tr>
<tr>
<td>性能</td>
<td>相对较慢，特别是批量操作性能低</td>
<td>性能显著提高，批量操作性能优化</td>
</tr>
<tr>
<td>支持的数据库</td>
<td>主要支持 SQL Server</td>
<td>支持 SQL Server、MySQL、PostgreSQL、SQLite、Oracle 等多种数据库</td>
</tr>
<tr>
<td>LINQ 支持</td>
<td>支持 LINQ，但有一些局限性</td>
<td>LINQ 支持更广泛，包含一些新操作符</td>
</tr>
<tr>
<td>离线开发</td>
<td>支持 EDMX 文件的可视化设计器</td>
<td>不支持 EDMX 文件，基于 Code-First 和 Fluent API 设计</td>
</tr>
<tr>
<td>迁移</td>
<td>支持数据迁移（Migrations）</td>
<td>支持数据迁移（更灵活，支持自定义脚本）</td>
</tr>
<tr>
<td>注重模块化</td>
<td>较为笨重，依赖于 System.Data</td>
<td>模块化设计，独立的包，如 Microsoft.EntityFrameworkCore.SqlServer</td>
</tr>
<tr>
<td>未来支持</td>
<td>停止新功能开发，仅维护</td>
<td>持续迭代和更新，主力框架</td>
</tr>
</tbody></table>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Entity Framework (EF) Core 是轻量化、可扩展、开源和跨平台版数据库访问技术</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202406201502825.png" alt="image-20240620150200167" style="zoom: 18%;" />

<p>选择EntityFrameworkCore的原因</p>
<ul>
<li>微软的亲儿子,对接了微软的众多其他需要数据访问的框架,例如ASP.NET Identity,ASPNET WebApi</li>
<li>全面支持[LINQ查询](#CSharp LINQ)</li>
<li>EFCore性能提升,已非常接近原生的ADO.NET框架了</li>
<li>数据库迁移功能,可以动态创建数据库或修改数据库</li>
</ul>
<p>优势:</p>
<ol>
<li><p>能够使用 .NET 对象处理数据库（数据迁移，正式环境慎用）</p>
<p>备注：不建议使用数据迁移，需要学习处理数据库字段、长度、生成值（不生成、默认、添加或更新时生成）、键、索引等一定量内容，并且需要对数据库很熟悉，既然熟悉了数据库为什么还要在EF中处理呢，专业的任务还是专业的工具去做。<br><code>官方建议：部署到生产数据库的建议方法是生成 SQL 脚本</code></p>
</li>
<li><p>无需编写大部分数据访问代码（sql）</p>
</li>
</ol>
<p>三种功能</p>
<ul>
<li>已经有数据表了,程序中没有对应的类</li>
<li>程序中有类了,的设计了,但是没有数据库和程序中的类</li>
<li>已经有数据模型的设计了,但是没有数据库和程序中的类</li>
</ul>
<p>Entity Framework从4.1版本开始由NuGet发布,从5版本开始开源,<a target="_blank" rel="noopener" href="https://github.com/dotnet/efcore">开源地址</a></p>
<table>
<thead>
<tr>
<th>版本</th>
<th>发行情况</th>
<th>主要特性</th>
</tr>
</thead>
<tbody><tr>
<td>EF 3.5</td>
<td>.NET 3.5 SP1</td>
<td>基本ORM, Database First workflow</td>
</tr>
<tr>
<td>EF 4.0</td>
<td>.NET 4.0</td>
<td>POCO, Lazy Loading, testability, custom code generation, Model First workflow</td>
</tr>
<tr>
<td>EF 4.1+</td>
<td>NuGet</td>
<td>DBContext API, Code First workflow</td>
</tr>
<tr>
<td>EF 5</td>
<td>NuGet</td>
<td>Open Source, Enum support, table-valued functions, spatial data types, multiple-diagrams per model, etc</td>
</tr>
<tr>
<td>EF 6+</td>
<td>NuGet</td>
<td>It includes many new features related to Code First &amp; EF designer like asynchronous query &amp; save, etc</td>
</tr>
</tbody></table>
<h3 id="开发模式"><a href="#开发模式" class="headerlink" title="开发模式"></a>开发模式</h3><p>三种模式</p>
<p>对于EF Core,使用模型执行数据访问,模型由实体类和表示数据库会话的上下文对象构成.上下文对象允许查询并保存数据,EFCore支持以下开发模式</p>
<ul>
<li><p>DBFirst  数据库优先</p>
<p>从现有数据库生成类和属性</p>
</li>
<li><p>ModelFirst  模型优先  (基本不使用)</p>
</li>
<li><p>CodeFirst  <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/ef/ef6/modeling/code-first/migrations/?redirectedfrom=MSDN">代码优先</a>  (最常用)</p>
<p>现有类和属性,从类和属性生成数据库对应的表和字段</p>
<p>创建模型后,使用EF迁移从模型创建数据库.模型发生变化时,迁移可让数据库不断演进</p>
</li>
</ul>
<p>基本框架</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202406201509668.png" alt="image-20240620150915472" style="zoom: 25%;" />

<h2 id="EF注意事项"><a href="#EF注意事项" class="headerlink" title="EF注意事项"></a>EF注意事项</h2><ul>
<li>若要在高性能生产应用中构建、调试、分析和迁移数据，必须具备基础数据库服务器的中级知识或更高级别的知识。例如，有关主键和外键、约束、索引、标准化、DML 和 DDL 语句、数据类型、分析等方面的知识。</li>
<li>功能和集成测试：请务必尽可能严密地复制生产环境，以便：<ul>
<li>查找仅在使用特定版本的数据库服务器时应用才出现的问题。</li>
<li>在升级 EF Core 和其他依赖项时捕获中断性变更。例如，添加或升级 ASP.NET Core、OData 或 AutoMapper等框架。这些依赖项可能以多种意外方式影响 EF Core。</li>
</ul>
</li>
<li>通过代表性负载进行性能和压力测试。某些功能的不成熟用法缩放性不佳。例如，多项集合包含内容、大量使用延迟加载、对未编制索引的列执行条件查询、对存储生成的值进行大规模更新和插入、缺乏并发处理、大型模型、缓存策略不充分。</li>
<li>安全评审：例如，连接字符串和其他机密处理、非部署操作的数据库权限、原始 SQL 的输入验证、敏感数据加密。</li>
<li>确保日志记录和诊断充足目可用。例如，适当的日志记录配置、查询标记和 Application Insights。</li>
<li>错误恢复。为常见故障场景（如版本回退、回退服务器、横向扩展和负载平衡、DoS 缓解和数据备份）准备应急计划。</li>
<li>生成的迁移的详细检查和测试。将迁移应用于生产数据前，应对其进行全面测试。若表中包含生产数据，架构的形状和列类型就不能轻易更改。例如，在 SQL Server 上，对于映射到字符串和十进制属性的列，nvarchar（max）和 decima1（18， 2）极少成为最佳类型，但这些是 EF 使用的默认值，因为 EF 不了解你的具体情况。</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Nuget安装Microsoft.EntityFrameworkCore</p>
<p>请务必安装Microsoft提供的所有EF Core包的同一版本.例如,如果安装5.0.3版本的<code>Microsoft.EntityFrameworkCore.SqlServer</code>,则所有其他<code>Microsoft.EntityFrameworkCore.*</code>包也必须为5.0.3版本</p>
<h3 id="数据库提供程序"><a href="#数据库提供程序" class="headerlink" title="数据库提供程序"></a>数据库提供程序</h3><p>EF Core 通过使用“数据库提供程序“支持不同的数据库系统。每个系统都有自己的数据库提供程序，而提供程序以 NuGet 包的形式提供。应用程序应安装其中一个或多个提供程序包<br>下表列出了常贝的数据库提供程序。有关可用提供程序的更全面列表，请参阅官方网址</p>
<table>
<thead>
<tr>
<th>数据库系统</th>
<th>配置示例</th>
<th>NuGet 程序包</th>
</tr>
</thead>
<tbody><tr>
<td>SQL Server 或 Azure SQL</td>
<td><code>UseSqlServer(connectionString)</code></td>
<td><a target="_blank" rel="noopener" href="https://www.nuget.org/packages/Microsoft.EntityFrameworkCore.SqlServer">Microsoft.EntityFrameworkCore.SqlServer</a></td>
</tr>
<tr>
<td>Azure Cosmos DB</td>
<td><code>UseCosmos(connectionString, databaseName)</code></td>
<td><a target="_blank" rel="noopener" href="https://www.nuget.org/packages/Microsoft.EntityFrameworkCore.Cosmos">Microsoft.EntityFrameworkCore.Cosmos</a></td>
</tr>
<tr>
<td>SQLite</td>
<td><code>UseSqlite(connectionString)</code></td>
<td><a target="_blank" rel="noopener" href="https://www.nuget.org/packages/Microsoft.EntityFrameworkCore.Sqlite">Microsoft.EntityFrameworkCore.Sqlite</a></td>
</tr>
<tr>
<td>EF Core 内存中数据库</td>
<td><code>UseInMemoryDatabase(databaseName)</code></td>
<td><a target="_blank" rel="noopener" href="https://www.nuget.org/packages/Microsoft.EntityFrameworkCore.InMemory">Microsoft.EntityFrameworkCore.InMemory</a></td>
</tr>
<tr>
<td>PostgreSQL*</td>
<td><code>UseNpgsql(connectionString)</code></td>
<td><a target="_blank" rel="noopener" href="https://www.nuget.org/packages/Npgsql.EntityFrameworkCore.PostgreSQL">Npgsql.EntityFrameworkCore.PostgreSQL</a></td>
</tr>
<tr>
<td>MySQL&#x2F;MariaDB*</td>
<td><code>UseMySql(connectionString)</code></td>
<td><a target="_blank" rel="noopener" href="https://www.nuget.org/packages/Pomelo.EntityFrameworkCore.MySql">Pomelo.EntityFrameworkCore.MySql</a></td>
</tr>
<tr>
<td>Oracle* PLSQL</td>
<td><code>UseOracle(connectionString)</code></td>
<td>Oracle.EntityFrameworkCore</td>
</tr>
</tbody></table>
<p>如执行:<code>dotnet add package Microsoft.EntityFrameworkCore.Sqlite</code></p>
<p>将会自动安装EntityFrameworkCore的本体等一切依赖</p>
<p>如果需要支持sqlite的数据迁移,还需要安装包: <code>dotnet add package Microsoft.EntityFrameworkCore.Design</code></p>
<h3 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h3><blockquote>
<p>不安装也可以,可以通过vs自带的程序包管理器控制台,来执行数据迁移</p>
<p>像rider和vscode等ide没有程序包管理器控制台就只可以通过下面工具来执行数据迁移</p>
</blockquote>
<p>使用用于EF Core迁移的工具需要安装相应的工具包</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet tool install -g --version 8.0.203 dotnet-ef</span><br></pre></td></tr></table></figure>

<p>版本与<code>dotnet --version</code>运行时的版本一致最稳妥</p>
<p>可以使用<code>dotnet ef</code>来判断是否安装成功</p>
<p><code>dotnet ef</code>等同于<code>dotnet-ef</code></p>
<p>可以使用<code>dotnet ef --help</code>来查看帮助文档</p>
<h2 id="数据库上下文"><a href="#数据库上下文" class="headerlink" title="数据库上下文"></a>数据库上下文</h2><p>Dbcontext的生命周期从创建实例时开始，并在释放实例时结束。Dbcontext 实例旨在用于单个工作单元。这意味着 Dbcontext实例的生命周期通常很短。</p>
<blockquote>
<p>引用Martin Fowler 的话，“工作单元将持续跟踪在可能影响数据库的业务事务中执行的所有操作。当你完成操作后，它将找出更改数据库作为工作结果时需要执行的所有操作。”</p>
</blockquote>
<ul>
<li>创建<code>DbContext</code>实例</li>
<li>根据上下文跟踪实体实例.实体将在一下情况下被跟踪<ul>
<li>正在从查询返回</li>
<li>正在添加或附加到上下文</li>
</ul>
</li>
<li>根据需要对所跟踪的实体已进行更改以实现业务规则</li>
<li>调用<code>SaveChanges</code>或<code>SaveChangesAsync</code>.EF Core检测所做的更改,并将这些更改写入数据库</li>
<li>释放<code>DbContext</code>实例</li>
</ul>
<p>重要的部分</p>
<blockquote>
<ul>
<li><p>使用后释放 DbContext 非常重要。这可确保释放所有非托管资源，并注销任何事件或其他挂钩，以防止在实例保持引用时出现内存泄漏。 </p>
</li>
<li><p><strong>DbContext 不是线程安全的。不要在线程之间共享上下文。请确保在继续使用上下文实例之前，等待所有异步调用。</strong></p>
<p>最简单的解决方式就是使用<code>await context.SaveChangesAsync();</code>,可以避免线程安全问题</p>
</li>
<li><p>EF Core 代码引发的 InvalidOperationException 可以使上下文进入不可恢复的状态。此类异常指示程序错误，并且不旨在从其中恢复。</p>
</li>
</ul>
</blockquote>
<h2 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h2><p>EF Core提供两种主要方法来保持EF Core模型和数据库架构同步.至于我们应该选用哪个方法,请确定你是希望以EF Core模型为准还是以数据库为准</p>
<ol>
<li>如果希望以EF Core模型为准,请使用<a href="#%E8%BF%81%E7%A7%BB">迁移</a>.对于EF Core模型进行更改时,此方法会以增量方式将相应架构更改应用到数据库,以使数据库保持与EF Core模型兼容(CodeFirst,小项目用这种)</li>
<li>如果希望以数据库架构为准,请使用<a href="#%E5%8F%8D%E5%90%91%E5%B7%A5%E7%A8%8B">反向工程</a>.使用此方法,可通过将数据库架构反向工程到EF Core模型来生成相应的Dbcontext和实体类型(DbFirst,中大型模型建议使用)</li>
</ol>
<h3 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h3><p>EF与EF Core的差异</p>
<table>
<thead>
<tr>
<th>对比项</th>
<th>EF 6</th>
<th>EF Core</th>
</tr>
</thead>
<tbody><tr>
<td>是否需要设计包</td>
<td>内置于Entityframework本身❌</td>
<td>需要 Microsoft.EntityFrameworkCore.Design ✅</td>
</tr>
<tr>
<td>迁移工具</td>
<td>Visual Studio 包管理器控制台</td>
<td>dotnet CLI (dotnet ef)&#x2F;Visual Studio 包管理器控制台</td>
</tr>
<tr>
<td>迁移命令</td>
<td>Enable-Migrations, Add-Migration, Update-Database</td>
<td>dotnet ef migrations add, dotnet ef database update</td>
</tr>
<tr>
<td>操作平台</td>
<td>仅支持 .NET Framework</td>
<td>支持 .NET Core &#x2F; .NET 5+</td>
</tr>
<tr>
<td>依赖项</td>
<td>EntityFramework 包已集成所有功能</td>
<td>需要安装 Microsoft.EntityFrameworkCore，Microsoft.EntityFrameworkCore.Design 和 Microsoft.EntityFrameworkCore.Tools</td>
</tr>
<tr>
<td>历史记录存储</td>
<td>__MigrationHistory 表</td>
<td>__EFMigrationsHistory 表</td>
</tr>
</tbody></table>
<p>迁移的常见操作及数据保留情况</p>
<table>
<thead>
<tr>
<th>操作类型</th>
<th>对表数据的影响</th>
<th>详细说明</th>
</tr>
</thead>
<tbody><tr>
<td>新增表</td>
<td>✅</td>
<td>创建新表，不会影响现有表中的数据。</td>
</tr>
<tr>
<td>新增列</td>
<td>✅</td>
<td>新增的列会为所有现有行赋默认值（null 或默认值）。</td>
</tr>
<tr>
<td>删除列</td>
<td>❌</td>
<td>删除列后，列中的数据无法恢复，需小心操作。</td>
</tr>
<tr>
<td>修改列类型</td>
<td>⚠️</td>
<td>可能会删除或截断数据，视更改的类型而定（如 int -&gt; string 不丢数据，但 int -&gt; bool 可能出错）。</td>
</tr>
<tr>
<td>重命名列</td>
<td>✅</td>
<td>使用 RenameColumn，数据会保留。</td>
</tr>
<tr>
<td>新增索引</td>
<td>✅</td>
<td>索引的增加不会丢失数据。</td>
</tr>
<tr>
<td>删除索引</td>
<td>✅</td>
<td>删除索引不会删除表中的数据。</td>
</tr>
<tr>
<td>重命名表</td>
<td>✅</td>
<td>使用 RenameTable，数据不会丢失。</td>
</tr>
<tr>
<td>删除表</td>
<td>❌</td>
<td>删除表会丢失所有数据，无法恢复。</td>
</tr>
<tr>
<td>更改主键</td>
<td>❌</td>
<td>视操作而定，有时需要删除并重建表，数据可能丢失。</td>
</tr>
<tr>
<td>外键变更</td>
<td>⚠️</td>
<td>视操作而定，如果外键约束被删除，可能会导致约束不满足。</td>
</tr>
</tbody></table>
<p>因此,使用重命名列迁移后再删除列再迁移等方式替代直接删除列迁移导致的数据丢失</p>
<h4 id="使用dotnet-ef"><a href="#使用dotnet-ef" class="headerlink" title="使用dotnet-ef"></a>使用dotnet-ef</h4><p><code>dotnet ef migrations add 数据迁移的名字</code> 添加数据迁移</p>
<p>执行语句</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">添加数据迁移,数据迁移名为Init</span></span><br><span class="line">dotnet ef migrations add Init</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">返回Build succeeded表示成功,如下</span></span><br><span class="line">Build started...</span><br><span class="line">Build succeeded.</span><br><span class="line">The Entity Framework tools version &#x27;8.0.2&#x27; is older than that of the runtime &#x27;9.0.0&#x27;. Update the tools for the latest features and bug fixes. See https://aka.ms/AAc1fbw for more information.</span><br><span class="line">Done. To undo this action, use &#x27;ef migrations remove&#x27;</span><br></pre></td></tr></table></figure>

<p>然后执行<code>dotnet ef database update</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">返回如下:</span></span><br><span class="line">Build started...</span><br><span class="line">Build succeeded.</span><br><span class="line">The Entity Framework tools version &#x27;8.0.2&#x27; is older than that of the runtime &#x27;9.0.0&#x27;. Update the tools for the latest features and bug fixes. See https://aka.ms/AAc1fbw for more information.</span><br><span class="line">Acquiring an exclusive lock for migration application. See https://aka.ms/efcore-docs-migrations-lock for more information if this takes too long.</span><br><span class="line">Applying migration &#x27;20241216083634_Init&#x27;.</span><br><span class="line">Done.</span><br></pre></td></tr></table></figure>

<p>删除迁移可以使用<code>dotnet ef migrations remove</code>,但如果迁移已被应用(database update),则无法使用remove</p>
<p>列出所有迁移: <code>dotnet ef migrations list</code></p>
<p>列出更新数据库的脚本: <code>dotnet ef migrations script</code>,可以使用<code>-o</code>重定向到一个sql文件中</p>
<blockquote>
<p>在 SQL Server Management Studio 中执行 SQL 文件</p>
<ol>
<li>**打开 SQL Server Management Studio (SSMS)**。</li>
<li><strong>连接到您的 SQL Server 实例</strong>。</li>
<li><strong>打开 SQL 文件</strong>：<ul>
<li>在 SSMS 中，选择菜单中的 <code>文件</code> -&gt; <code>打开</code> -&gt; <code>文件</code>，然后选择您刚刚生成的 <code>migration_script.sql</code> 文件。</li>
</ul>
</li>
<li><strong>执行 SQL 脚本</strong>：<ul>
<li>打开文件后，您可以查看生成的 SQL 脚本。点击工具栏上的 <code>执行</code> 按钮（或者按 F5），以执行 SQL 脚本。</li>
</ul>
</li>
</ol>
</blockquote>
<h4 id="使用vs自带的程序包管理器控制台"><a href="#使用vs自带的程序包管理器控制台" class="headerlink" title="使用vs自带的程序包管理器控制台"></a>使用vs自带的程序包管理器控制台</h4><p>上面两个语句分别对应如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">EntityFramework才需要执行这句,即EF Core不需要执行此命令</span></span><br><span class="line">Enable-Migrations #用于启用迁移功能并为数据库创建迁移文件。该命令会在项目中生成一个 Migrations 文件夹以及一个 Configuration.cs 文件。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">新建迁移</span></span><br><span class="line">Add-Migration Init</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">更新数据库</span></span><br><span class="line">Update-Database</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除迁移</span></span><br><span class="line">Remove-Migration</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">列出所有迁移</span></span><br><span class="line">Get-Migrations</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">数据库更新脚本(默认生成整个数据库的sql语句)</span></span><br><span class="line">Update-Database -Script</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">生成增量sql修改文件</span></span><br><span class="line">Update-Database -Script -From &lt;源迁移名称&gt; -To &lt;目标迁移名称&gt;</span><br></pre></td></tr></table></figure>

<h3 id="EntityFramework的自动迁移"><a href="#EntityFramework的自动迁移" class="headerlink" title="EntityFramework的自动迁移"></a>EntityFramework的自动迁移</h3><p>注意,不是EntityFrameworkCore的自动迁移</p>
<p>自动迁移示例:</p>
<ol>
<li><p>创建DbContext</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Data.Entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">YourDbContext</span> : <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> DbSet&lt;User&gt; Users &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">YourDbContext</span>() : <span class="title">base</span>(<span class="params"><span class="string">&quot;name=DefaultConnection&quot;</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">User</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置自动迁移</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Data.Entity.Migrations;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Configuration</span> : <span class="title">DbMigrationsConfiguration</span>&lt;<span class="title">YourDbContext</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Configuration</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        AutomaticMigrationsEnabled = <span class="literal">true</span>; <span class="comment">// 启用自动迁移</span></span><br><span class="line">        AutomaticMigrationDataLossAllowed = <span class="literal">false</span>; <span class="comment">// 不允许数据丢失,自动迁移过程中,EF会阻止删除列等危险操作</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Seed</span>(<span class="params">MyContextEntity context</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">//  This method will be called after migrating to the latest version.</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//  You can use the DbSet&lt;T&gt;.AddOrUpdate() helper extension method</span></span><br><span class="line">       <span class="comment">//  to avoid creating duplicate seed data.</span></span><br><span class="line">     	<span class="comment">//该方法可以用于在迁移完成后填充数据库，常用于初始化数据库的种子数据（例如，添加一些默认记录）。</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在代码中调用迁移</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Data.Entity.Migrations;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">        <span class="keyword">var</span> migrator = <span class="keyword">new</span> DbMigrator(configuration);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 运行所有未应用的迁移</span></span><br><span class="line">        migrator.Update();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 继续执行其他程序逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="重置所有迁移"><a href="#重置所有迁移" class="headerlink" title="重置所有迁移"></a>重置所有迁移</h3><p>在某些极端情况下,可能需要删除所有迁移并重新开始,这可以通过删除Migration文件夹并删除数据库来轻松完成;此时,你可以创建一个新的初始迁移,其中将包含当前整个架构</p>
<p>你还可以重置所有迁移并创建单个迁移,而<strong>不会丢失数据</strong>.此操作有时称为”更正”,涉及一些手动操作</p>
<ul>
<li>删除Migrations文件夹</li>
<li>创建新迁移并为其生成SQL脚本 <code>dotnet ef migrations script</code>  或 <code>Update-Database -Script</code></li>
<li>在数据库中,删除迁移历史记录表(<code>_EFMigrationsHistory</code>)中的所有行</li>
<li>执行<code>dotnet ef migrations add xxx</code>后,手动在迁移历史记录中插入一行,以记录第一个迁移已经应用,因为表已经存在.(注意,不执行database update)</li>
</ul>
<h3 id="反向工程"><a href="#反向工程" class="headerlink" title="反向工程"></a>反向工程</h3><h2 id="EF-Core使用方法"><a href="#EF-Core使用方法" class="headerlink" title="EF Core使用方法"></a>EF Core使用方法</h2><h3 id="案例参考"><a href="#案例参考" class="headerlink" title="案例参考"></a>案例参考</h3><p>BlogContext.cs</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.EntityFrameworkCore;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span>  <span class="title">testChart</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//必须继承DbContext</span></span><br><span class="line">    <span class="comment">//数据库上下文:C#中的类与数据库中的表进行一个映射关系</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BlogContext</span>:<span class="title">DbContext</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="meta">#<span class="keyword">region</span> 声明表</span></span><br><span class="line">        <span class="keyword">public</span> DbSet&lt;Blog&gt; Blogs &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> DbSet&lt;Post&gt; Posts &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//连接字符串:.db文件的完整路径</span></span><br><span class="line">        <span class="comment">//配置一些连接字符串,日志的输出方式 等等</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnConfiguring</span>(<span class="params">DbContextOptionsBuilder optionsBuilder</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//使用 Entity Framework Core 配置一个 SQLite 数据库连接</span></span><br><span class="line">            <span class="comment">//AppDomain.CurrentDomain.BaseDirectory表示始终放在启动目录中,而不是当前工作目录</span></span><br><span class="line">            <span class="comment">//此处使用Directory.GetCurrentDirectory()的话是不对的</span></span><br><span class="line">            <span class="built_in">string</span> databasePath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, <span class="string">&quot;test.db&quot;</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;Database Path: <span class="subst">&#123;databasePath&#125;</span>&quot;</span>);</span><br><span class="line">            optionsBuilder.UseSqlite(<span class="string">$&quot;Data Source=<span class="subst">&#123;databasePath&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Blog</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//自增主键</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span>? Url &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="comment">//一个文章有多个帖子  (外键)</span></span><br><span class="line">        <span class="keyword">public</span> List&lt;Post&gt; Posts &#123; <span class="keyword">get</span>;  &#125; = <span class="keyword">new</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Post</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> PostId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span>? Title &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span>? Content &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> BlogId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> Blog? Blog &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>数据库操作</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Entity Framework Core测试</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;Entity Framework Core测试&quot;</span>);</span><br><span class="line">BlogContext context = <span class="keyword">new</span>();</span><br><span class="line"><span class="comment">//添加一条数据:</span></span><br><span class="line">Blog blog = <span class="keyword">new</span>()&#123;Url=<span class="string">&quot;https://www.hello.com&quot;</span>&#125;;</span><br><span class="line">context.Blogs.Add(blog);<span class="comment">//insert into</span></span><br><span class="line">context.SaveChanges();<span class="comment">//执行,提交</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查询:select * from Blogs offset limit 1</span></span><br><span class="line"><span class="keyword">var</span> first = context.Blogs.FirstOrDefault();</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除:delete from Blogs Where Id=1</span></span><br><span class="line">context.Blogs.Remove(first);</span><br><span class="line">context.SaveChanges();<span class="comment">//执行,提交</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//查询:select * from Blogs offset limit 1</span></span><br><span class="line">first = context.Blogs.FirstOrDefault();</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新: update blog set url=&quot;https://www.baidu.com/test&quot; where id = first.id</span></span><br><span class="line"><span class="keyword">if</span> (first!=<span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    first.Url = <span class="string">&quot;https://www.hello.com/test&quot;</span>;</span><br><span class="line">    context.SaveChanges();<span class="comment">//执行,提交</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//查询:select * from Blogs</span></span><br><span class="line"><span class="keyword">var</span> list = context.Blogs.ToList();</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> list)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(item.Url);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 释放上下文</span></span><br><span class="line"> context.Dispose();</span><br></pre></td></tr></table></figure>

<p>上述连接数据库是通过写死连接字符串在代码中实现的,但也可以将连接字符串写成如下形式:</p>
<h3 id="连接字符串配置"><a href="#连接字符串配置" class="headerlink" title="连接字符串配置"></a>连接字符串配置</h3><p>EF Core 连接数据库的最常见方式是通过 <strong>连接字符串</strong> 配置，这些字符串通常存储在 appsettings.json 或 app.config(用于桌面程序)&#x2F;web.config(用于web程序) 文件中。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">connectionStrings</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">add</span> <span class="attr">name</span>=<span class="string">&quot;MyDbContext&quot;</span> </span></span><br><span class="line"><span class="tag">             <span class="attr">connectionString</span>=<span class="string">&quot;Data Source=.;Initial Catalog=MyDatabase;Integrated Security=True;&quot;</span> </span></span><br><span class="line"><span class="tag">             <span class="attr">providerName</span>=<span class="string">&quot;System.Data.SqlClient&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">connectionStrings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>或json格式文件演示:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;ConnectionStrings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;DefaultConnection&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Server=localhost;Database=MyDatabase;User Id=myuser;Password=mypassword;&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>开发者需要根据实际情况手动编辑这些配置文件，确保数据库连接字符串正确无误，通常配置项包括：</p>
<ul>
<li><p><strong>服务器地址</strong>（例如，Data Source&#x3D;.; 表示使用本地数据库服务器）</p>
</li>
<li><p><strong>数据库名称</strong>（例如，Initial Catalog&#x3D;MyDatabase;）</p>
</li>
<li><p><strong>身份验证信息</strong>（例如，使用 Windows 身份验证 Integrated Security&#x3D;SSPI; 或 SQL Server 身份验证 User ID&#x3D;admin;Password&#x3D;123;）</p>
</li>
</ul>
<h2 id="EF使用方法"><a href="#EF使用方法" class="headerlink" title="EF使用方法"></a>EF使用方法</h2><p><strong>这里对EF的各种增删改查方法做一次系统的总结和巩固</strong></p>
<p>EF上下文对象</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JXC_SJKEntities entities = <span class="keyword">new</span> JXC_SJKEntities();<span class="comment">//实例化EF上下文对象</span></span><br></pre></td></tr></table></figure>

<p>以此表为例:</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202406210954082.png" alt="img" style="zoom: 67%;" />

<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>下面的变量名详解:</p>
<ul>
<li><code>entities</code>：这是<code>DbContext</code>的一个实例。<code>DbContext</code>是EF中用于与数据库交互的主要类。它管理实体对象的生命周期，包括对象的查询、保存、删除等。</li>
<li><code>T_Spb</code>：这里指的是<code>DbContext</code>中的一个DbSet属性。<code>DbSet&lt;T&gt;</code>代表了数据库中的一个集合，用于操作指定类型的实体。</li>
</ul>
<blockquote>
<p>在Entity Framework中，<strong>DbSet</strong>是表示数据库中表的集合的类。DbSet是Entity Framework中的一种泛型集合类，用于表示数据库上下文中的实体集合。每个DbSet对应数据库中的一个表，可以用于查询、插入、更新和删除表中的数据。</p>
</blockquote>
<h4 id="查询全表数据"><a href="#查询全表数据" class="headerlink" title="查询全表数据"></a>查询全表数据</h4><p>这里为了查看结果方便,都使用<code>ToList()</code>结束了延迟加载</p>
<blockquote>
<p><strong>延迟加载（Lazy Loading）</strong>是Entity Framework（EF）中的一个特性，指的是在实体属性被访问时才加载相关联的实体数据。这意味着，当你查询并获取一个实体对象时，并不会立即加载它的导航属性指向的关联实体。只有在你访问这些导航属性时，EF才会执行必要的查询操作，从数据库中加载这些关联实体的数据。</p>
</blockquote>
<p>三种方式</p>
<ul>
<li><p>Linq语句</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = entities.T_Spb.Select(s=&gt;s).ToList();</span><br><span class="line"><span class="keyword">var</span> list = entities.T_Spb.ToList();</span><br></pre></td></tr></table></figure>
</li>
<li><p>Linq方法</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = (<span class="keyword">from</span> item <span class="keyword">in</span> entities.T_Spb</span><br><span class="line">             <span class="keyword">select</span> item).ToList();</span><br></pre></td></tr></table></figure>
</li>
<li><p>SQL语句</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = entities.T_Spb.SqlQuery(<span class="string">&quot;select * from T_Spb&quot;</span>).ToList();</span><br><span class="line"><span class="keyword">var</span> list = entities.Database.SqlQuery(<span class="string">&quot;select * from T_Spb&quot;</span>).ToList();</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>三者种方法结果相同,但是<code>ToList()</code>之前的返回值类型是不一样的。方法一、方法二(使用Linq)返回值类型为<code>IQueryable&lt;T&gt;</code>，方法三中<code>DbSet.SqlQuery()</code>返回值类型为<code>DbSqlQuery&lt;T&gt;</code>，<code>database.SqlQuery()</code>返回值类型为<code>DbRawSqlQuery&lt;T&gt;</code>。</strong></p>
<h4 id="查询单个数据"><a href="#查询单个数据" class="headerlink" title="查询单个数据"></a>查询单个数据</h4><p>Find方法根据要查找的实体的<strong>主键值</strong>查对象。若通过主键查，用Find()比较方便</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> model = entities.T_Spb.Find(<span class="number">30</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Linq语句</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> model = entities.T_Spb.Where(s =&gt; s.SpID == <span class="number">30</span>).FirstOrDefault();</span><br><span class="line"><span class="keyword">var</span> model = entities.T_Spb.FirstOrDefault(s =&gt; s.SpID == <span class="number">30</span>);<span class="comment">//上面的简写形式</span></span><br></pre></td></tr></table></figure>

<p>查询单个数据时，可以使用<code>First()</code>、<code>FirstOrDefault()</code>、<code>Single()</code>、<code>SingleOrDefault()</code></p>
<ul>
<li><code>First</code> 返回第一条数据 结果为空时出异常 </li>
<li><code>FirstOrDefault</code> 返回序列第一条数据 数据为空返回null</li>
<li><code>Single/SingleOrDefault</code> 返回序列第一条数据 多条结果时出异常 (SingleOrDefault若序列为空返回默认值)</li>
</ul>
</li>
<li><p>Linq方法</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> model = (<span class="keyword">from</span> s <span class="keyword">in</span> entities.T_Spb</span><br><span class="line">                 <span class="keyword">where</span> s.SpID == <span class="number">30</span></span><br><span class="line">                 <span class="keyword">select</span> s).FirstOrDefault();</span><br></pre></td></tr></table></figure>
</li>
<li><p>SQL语句</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> model = entities.T_Spb.SqlQuery(<span class="string">&quot;select * from T_Spb where spid=30&quot;</span>).FirstOrDefault();</span><br><span class="line"><span class="keyword">var</span> model = entities.Database.SqlQuery&lt;T_Spb&gt;(<span class="string">&quot;select * from T_Spb where spid=30&quot;</span>).FirstOrDefault();</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="查询部分字段"><a href="#查询部分字段" class="headerlink" title="查询部分字段"></a>查询部分字段</h4><ul>
<li><p>Linq语句</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = entities.T_Spb.Select(s =&gt; <span class="keyword">new</span> &#123; id = s.SpID, name = s.Spmc&#125;).ToList();</span><br></pre></td></tr></table></figure>
</li>
<li><p>Linq方法</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list1 = (<span class="keyword">from</span> s <span class="keyword">in</span> entities.T_Spb</span><br><span class="line">                        <span class="keyword">select</span> <span class="keyword">new</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            id = s.SpID,</span><br><span class="line">                            name = s.Spmc</span><br><span class="line">                        &#125;).ToList();</span><br></pre></td></tr></table></figure>
</li>
<li><p>SQL语句</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//因为查询部分字段要返回一个匿名类对象,调用SQL语句要指明类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SpbModel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后使用这样的代码执行SQL查询并返回结果</span></span><br><span class="line"><span class="keyword">var</span> list = context.Database.SqlQuery&lt;SpbModel&gt;(<span class="string">&quot;SELECT SpID AS Id, Spmc AS Name FROM T_Spb&quot;</span>).ToList();</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h3><p>主要是三种方法</p>
<ul>
<li><p>Add()</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> model = <span class="keyword">new</span> T_Spb() &#123; Spmc = <span class="string">&quot;防脱发神器&quot;</span>, Spgg = <span class="string">&quot;ml&quot;</span>, Spdw = <span class="string">&quot;瓶&quot;</span>, Splb = <span class="number">2</span>, Sptxm = <span class="string">&quot;0000000000&quot;</span>, Spbz = <span class="string">&quot;程序员必备&quot;</span> &#125;;<span class="comment">//此处定义的model是T_Spb表中一行数据的实例</span></span><br><span class="line">entities.T_Spb.Add(model);</span><br><span class="line">entities.SaveChanges();<span class="comment">//通知上下文将实体的变化保存到数据库中</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改State状态</p>
<blockquote>
<p><strong>EF中的实体的状态值有Detached、Unchanged、Added、Deleted、Modified五种，可以通过修改上下文中实体的State值来实现   相应增删改操作</strong></p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> model= <span class="keyword">new</span> T_Spb() &#123; Spmc = <span class="string">&quot;防脱发神器1&quot;</span>, Spgg = <span class="string">&quot;ml&quot;</span>, Spdw = <span class="string">&quot;瓶&quot;</span>, Splb = <span class="number">2</span>, Sptxm = <span class="string">&quot;0000000001&quot;</span>, Spbz = <span class="string">&quot;程序员必备&quot;</span> &#125;;</span><br><span class="line">entities.Entry(model).State = System.Data.Entity.EntityState.Added;</span><br><span class="line">entities.SaveChanges();</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行SQL语句</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">entities.Database.ExecuteSqlCommand(<span class="string">&quot;具体sql语句&quot;</span>);<span class="comment">//返回受影响行数</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ul>
<li><p>Remove()【先查找再删除，操作数据库两次】</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> model = entities.T_Spb.Find(<span class="number">50</span>);</span><br><span class="line">entities.T_Spb.Remove(model);</span><br><span class="line">entities.SaveChanges();</span><br></pre></td></tr></table></figure>

<p><strong>若直接实例化一个实体对象【不是查出来的】,直接使用Remove(）方法，则会引发异常。</strong></p>
<p>解释:Remove()操作的对象必须在EF上下文中，直接new的实体对象是不在上下文中的。</p>
<p>解决办法:通过Attach()方法 将实例化的model添加到EF上下文对象即可</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> model1 = <span class="keyword">new</span> T_Spb() &#123; SpID = <span class="number">59</span> &#125;;</span><br><span class="line">entities.T_Spb.Attach(model1); <span class="comment">//将model添加到EF上下文对象中</span></span><br><span class="line">entities.T_Spb.Remove(model1);</span><br><span class="line">entities.SaveChanges();</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改State状态【直接删除操作数据库一次】</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> model = <span class="keyword">new</span> T_Spb() &#123; SpID = <span class="number">50</span> &#125;;</span><br><span class="line">entities.Entry(model1).State = System.Data.Entity.EntityState.Deleted;</span><br><span class="line">entities.SaveChanges();</span><br></pre></td></tr></table></figure>

<p><strong>若不指定主键值，直接修改State值去删除也会引发异常</strong></p>
<p>解释:EF上下文中通过主键对实体对象进行跟踪，因此修改State值删除时要指明主键。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//var model1 = new T_Spb() &#123;  Spmc = &quot;aaa&quot; &#125;;//❌异常</span></span><br><span class="line"><span class="keyword">var</span> model1 = <span class="keyword">new</span> T_Spb() &#123; SpID = <span class="number">1</span>, Spmc = <span class="string">&quot;aaa&quot;</span> &#125;;<span class="comment">//✅正确</span></span><br><span class="line">entities.Entry(model1).State = System.Data.Entity.EntityState.Deleted;</span><br><span class="line">entities.SaveChanges();</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行SQL语句:略(同<a href="#%E5%A2%9E%E5%8A%A0">增加</a>)</p>
</li>
</ul>
<h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><ul>
<li><p>修改部分字段 (先查再修改) </p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> model = entities.T_Spb.FirstOrDefault(x=&gt;x.SpID==<span class="number">30</span>);</span><br><span class="line">model.Sptxm = <span class="string">&quot;10241024&quot;</span>;</span><br><span class="line">entities.SaveChanges();</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改全部字段【设置State状态跟删除一样，要指明主键】</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> model2 = <span class="keyword">new</span> T_Spb &#123; SpID = <span class="number">42</span>,Sptxm=<span class="string">&quot;10241024&quot;</span> &#125;;</span><br><span class="line">entities.Entry(model2).State = System.Data.Entity.EntityState.Modified;<span class="comment">//全部更新</span></span><br><span class="line">entities.SaveChanges();</span><br></pre></td></tr></table></figure>

<p>注意:这种更新会将实例化的新对象中的值全部更新到数据库中，未赋值的字段为更新为null值</p>
<p>解决方法:可以先将实例化model添加到上下文中，设定某一字段的IsModified属性来实现只修改部分字段</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> model2 = <span class="keyword">new</span> T_Spb &#123; SpID = <span class="number">45</span>,Sptxm=<span class="string">&quot;10241024&quot;</span> &#125;;</span><br><span class="line">entities.T_Spb.Attach(model2);<span class="comment">//将model2对象添加到EF管理容器(EF上下文对象)</span></span><br><span class="line">entities.Entry(model2).Property(<span class="string">&quot;Sptxm&quot;</span>).IsModified = <span class="literal">true</span>;</span><br><span class="line">entities.SaveChanges()</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行SQL语句:略(同<a href="#%E5%A2%9E%E5%8A%A0">增加</a>)</p>
</li>
</ul>
<h1 id="延迟实例化"><a href="#延迟实例化" class="headerlink" title="延迟实例化"></a>延迟实例化</h1><p><code>延迟实例化</code> 是一种将对象的创建延迟到第一次需要用时的技术</p>
<p>在 C# 中，<code>lazy</code> 相关的功能是通过 <code>Lazy&lt;T&gt;</code> 类引入的。<code>Lazy&lt;T&gt;</code> 是在 .NET Framework4.0 中引入的，这个类用于实现<strong>延迟加载（lazy loading）</strong>，即在需要时才创建对象的实例，从而提高性能和资源利用率。并且<code>lazy&lt;T&gt;</code>是线程安全的</p>
<p><code>Lazy&lt;T&gt;</code> 可以用于在访问对象的属性或方法时延迟实例化,也称为懒加载（Lazy Initialization）</p>
<p>当使用 <code>Lazy&lt;T&gt;</code> 的时候，这里的 T 就是你要延迟的集合，那如何做到按需加载呢？调用 <code>Lazy&lt;T&gt;.Value</code> 即可，下面的代码片段展示了如何使用 <code>Lazy&lt;T&gt;</code></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Example</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Lazy&lt;SomeClass&gt; _lazyInstance = <span class="keyword">new</span> Lazy&lt;SomeClass&gt;(() =&gt; <span class="keyword">new</span> SomeClass());</span><br><span class="line">    <span class="keyword">public</span> SomeClass Instance =&gt; _lazyInstance.Value;<span class="comment">//即访问Instance的时候才真正初始化实例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用lazy配合static实现单例类</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Lazy&lt;SharedDispatcher&gt; _instance = <span class="keyword">new</span> Lazy&lt;SharedDispatcher&gt;(() =&gt; <span class="keyword">new</span> SharedDispatcher());</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SharedDispatcher Instance =&gt; _instance.Value;</span><br></pre></td></tr></table></figure>

<p>只有将 Lazy<T> 的实例声明为 static，才能确保在整个应用程序中只有一个 <code>Lazy&lt;T&gt;</code> 实例，从而实现单例模式.如果去掉static,每次创建 SharedDispatcher 实例时都会创建一个新的 <code>Lazy&lt;T&gt;</code> 实例,无法实现单例的效果</p>
<h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p><strong>具体原理</strong>是，<code>Lazy&lt;T&gt;</code> 内部使用了一个委托，该委托负责创建目标对象。当你第一次访问<code>Lazy&lt;T&gt;</code>的<code>Value</code>属性时，该委托会执行，实例化目标对象，并将其保存下来。随后的访问会直接返回已经创建好的对象，而不会再次执行委托。</p>
<p><code>Lazy&lt;T&gt;</code> 类提供了内建的线程安全机制，确保在多线程环境下也能正常工作。通过<code>Lazy&lt;T&gt;</code>，你可以实现延迟加载，而且无需担心线程安全性。<code>Lazy&lt;T&gt;</code> 内部使用了一种<strong>双重检查锁（Double-Check Locking）的机制</strong>，确保在多线程环境下只有一个线程会执行被延迟加载的对象的初始化操作。这意味着，<code>Lazy&lt;T&gt;</code> 会保证在多线程环境下只有一个线程会调用目标对象的构造函数，避免了竞态条件（Race Condition）的发生。</p>
<blockquote>
<p>具体来说，<code>Lazy&lt;T&gt;</code> 使用了双重检查锁机制来保证线程安全：</p>
<ol>
<li><strong>第一次检查（Without Lock）：</strong> 在没有锁的情况下，检查是否已经初始化了对象。如果对象已经初始化，直接返回它，否则进入第二个步骤。</li>
<li><strong>加锁（Locking）：</strong> 确保只有一个线程能够进入临界区域。在进入临界区域后，再次检查对象是否已经初始化。如果没有初始化，进行初始化操作。</li>
</ol>
<p>这种双重检查锁机制在<code>Lazy&lt;T&gt;</code> 类内部实现，确保了延迟加载的对象在多线程环境下的线程安全性。</p>
</blockquote>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol>
<li><strong>性能开销：</strong> 在第一次访问<code>Lazy&lt;T&gt;</code>对象时，需要进行初始化操作，这可能会引入一定的性能开销，特别是在初始化逻辑较复杂或耗时的情况下。</li>
<li><strong>线程安全性：</strong> 默认情况下，<code>Lazy&lt;T&gt;</code>是线程安全的，但如果需要在多线程环境下共享实例，可能需要额外的线程同步措施，这会增加复杂性。</li>
<li><strong>内存占用：</strong> 虽然<code>Lazy&lt;T&gt;</code>可以延迟对象的创建，但在对象创建后，它将一直占用内存，即使后续不再需要该对象。</li>
<li><strong>不适用于某些场景：</strong><code>Lazy&lt;T&gt;</code>适用于需要延迟初始化的场景，但并不适用于所有情况。在某些情况下，可能需要即时创建对象或使用其他设计模式。</li>
<li><strong>引入额外复杂性：</strong> 在某些情况下，使用<code>Lazy&lt;T&gt;</code>可能会引入额外的复杂性，使代码变得难以理解和维护。</li>
</ol>
<h2 id="Lazy的线程安全模式"><a href="#Lazy的线程安全模式" class="headerlink" title="Lazy的线程安全模式"></a>Lazy的线程安全模式</h2><p><code>Lazy&lt;T&gt;</code>类提供了一些线程安全的模式，例如<code>LazyThreadSafetyMode.PublicationOnly</code>和<code>LazyThreadSafetyMode.ExecutionAndPublication</code>。你可以根据需求选择适当的模式，确保在多线程环境下实例的安全共享。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lazy&lt;T&gt; lazyInstance = <span class="keyword">new</span> Lazy&lt;T&gt;(() =&gt; CreateInstance(), LazyThreadSafetyMode.None);</span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong><code>None</code></strong>:</p>
<ul>
<li><strong>描述</strong>: 不进行任何线程安全保护。</li>
<li><strong>适用场景</strong>: 只有单线程访问时使用，或者你负责在多线程环境中确保线程安全。</li>
<li><strong>注意</strong>: 如果多个线程同时访问 <code>Value</code> 属性，可能会导致多个实例的创建。</li>
</ul>
</li>
<li><p><strong><code>PublicationOnly</code></strong>:</p>
<ul>
<li><strong>描述</strong>: 允许多个线程同时初始化实例，但只会有一个线程的初始化结果被保留。其他线程在访问 <code>Value</code> 时会返回已经初始化的实例。</li>
<li><strong>适用场景</strong>: 当你希望提高性能并允许并行初始化，但不关心哪个线程的初始化结果被保留时使用。</li>
<li><strong>注意</strong>: 这种模式下，如果多个线程同时访问，可能会导致多个实例的创建，但最终只会有一个实例被保留。</li>
</ul>
</li>
<li><p><strong><code>ExecutionAndPublication</code></strong>: (默认情况)</p>
<ul>
<li><strong>描述</strong>: 这是最安全的模式。只有一个线程能够初始化实例，其他线程在访问 <code>Value</code> 时会等待初始化完成，并共享同一个实例。</li>
<li><strong>适用场景</strong>: 当你需要确保在多线程环境中只创建一个实例，并且希望其他线程在访问时能够安全地共享该实例时使用。</li>
<li><strong>注意</strong>: 这种模式下，性能可能会受到影响，因为它需要确保线程安全。</li>
</ul>
</li>
</ol>
<h2 id="C-中的实现"><a href="#C-中的实现" class="headerlink" title="C++中的实现"></a>C++中的实现</h2><p>C++ 中可以通过 <code>std::mutex</code> 或 C++11 的 <code>std::call_once</code> 实现线程安全的延迟初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lazy</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数接受一个创建对象的工厂函数</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Lazy</span><span class="params">(std::function&lt;T()&gt; factory)</span></span></span><br><span class="line"><span class="function">        : valueFactory(std::move(factory)), isValueCreated(false) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取实例化的对象，延迟创建</span></span><br><span class="line">    <span class="function">T&amp; <span class="title">Value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::<span class="built_in">call_once</span>(initFlag, [&amp;]() &#123;</span><br><span class="line">            value = std::<span class="built_in">make_unique</span>&lt;T&gt;(<span class="built_in">valueFactory</span>());</span><br><span class="line">            isValueCreated = <span class="literal">true</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> *value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查值是否已经初始化</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsValueCreated</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isValueCreated;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::function&lt;T()&gt; valueFactory; <span class="comment">// 工厂函数，用于创建对象</span></span><br><span class="line">    std::unique_ptr&lt;T&gt; value;       <span class="comment">// 存储延迟实例化的对象</span></span><br><span class="line">    std::once_flag initFlag;        <span class="comment">// 保证线程安全的单次初始化</span></span><br><span class="line">    <span class="type">bool</span> isValueCreated;            <span class="comment">// 记录是否已经初始化</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExpensiveObject</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ExpensiveObject</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ExpensiveObject created!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DoWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Working...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Lazy&lt;ExpensiveObject&gt; <span class="title">lazyObject</span><span class="params">([] &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">return</span> ExpensiveObject();</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Lazy object created, but not initialized yet.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首次访问触发初始化</span></span><br><span class="line">    lazyObject.<span class="built_in">Value</span>().<span class="built_in">DoWork</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次访问，不会重新初始化</span></span><br><span class="line">    lazyObject.<span class="built_in">Value</span>().<span class="built_in">DoWork</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;IsValueCreated: &quot;</span> &lt;&lt; lazyObject.<span class="built_in">IsValueCreated</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="CSharp-命名规范"><a href="#CSharp-命名规范" class="headerlink" title="CSharp 命名规范"></a>CSharp 命名规范</h1><p>$$<br>不要给别人和将来的自己添麻烦<br>$$</p>
<p>遵守相同的习惯与风格,可以提高效率,避免误会</p>
<h2 id="变量命名规范"><a href="#变量命名规范" class="headerlink" title="变量命名规范"></a>变量命名规范</h2><p>camelCase 私有字段,局部变量,入参</p>
<ul>
<li>_camelCase _CamelCase 使用依赖注入时更为推荐</li>
<li>s_camelCase,m_camelCase 一般不推荐</li>
<li>@bool,@object 使用关键字作为名称</li>
</ul>
<p>PascalCase: 命名空间,类名,方法名</p>
<ul>
<li>IPascalCase 接口名</li>
<li>TPascalCase 泛型类型名</li>
<li>PascalCaseAttribute 特性</li>
<li>PascalCaseProperty 依赖属性</li>
</ul>
<h3 id="特殊情形"><a href="#特殊情形" class="headerlink" title="特殊情形"></a>特殊情形</h3><ul>
<li><p>XAML中的<code>x:Key</code>名及<code>x:Name</code>名</p>
<ul>
<li>camelCase或PascalCase均可</li>
<li><code>&lt;Button Name=&quot;btn&quot;/&gt;</code></li>
<li><code>&lt;Style Key=&quot;Button.Common.Light&quot;&gt;</code></li>
</ul>
</li>
<li><p>XAML中的xmlns命名空间名: lowercase 尽量简单</p>
<p>b:Interaction,cv:BoolConverter</p>
</li>
<li><p>预编译器指令#define UPPER_CASE</p>
<p>DEBUG,NET_472</p>
</li>
<li><p>控件的事件注册 允许下划线 Button_Click</p>
</li>
</ul>
<h2 id="方法命名规范"><a href="#方法命名规范" class="headerlink" title="方法命名规范"></a>方法命名规范</h2><p>名称遵守PascalCase命名规范</p>
<ul>
<li>无论是否为公共方法,均首字母大写</li>
<li>选择合适的动词(+名词)</li>
<li>非公共方法可为名称添加Internal,Impl等字眼</li>
</ul>
<p>例外方法</p>
<ul>
<li>局部方法  可以小写开头</li>
<li>用于注册事件的方法 Window_Loaded</li>
</ul>
<h3 id="异步方法"><a href="#异步方法" class="headerlink" title="异步方法"></a>异步方法</h3><p>异步方法以Async结尾</p>
<ul>
<li>与同名的同步方法进行区分</li>
<li>便于快速判断调用的方法是否需要等待</li>
</ul>
<p>例外情况</p>
<ul>
<li><p>人尽皆知的方法(Task.Delay,Task.WhenAll)</p>
</li>
<li><p>控制器(Controller)中的方法(ASP.NET中才有)</p>
<p>虽然是异步的,但是不添加async,因为不会被开发者直接调用,而是框架调用</p>
</li>
</ul>
<h2 id="合理选择单词"><a href="#合理选择单词" class="headerlink" title="合理选择单词"></a>合理选择单词</h2><p> 选择最合适且被广泛接受的单词描述某个意思</p>
<ul>
<li>Order应该用于排序(orderby),而不是用于命令</li>
<li>Apply用于表达应用,而不是申请(Request)</li>
<li>Command常用于名词而非动词</li>
</ul>
<p><strong>避免使用过于宽泛或与标准库重名的词汇</strong></p>
<p>Core,Main,Action,Math</p>
<p><strong>布尔类型的成员一般以Is,Has,Can开头</strong></p>
<p>IsValid,IsActive,HasErrors,CanExecute</p>
<p><strong>使用偏正式的单词,而非偏口语化的单词</strong></p>
<p>Visibility✅  Seen❌</p>
<p>Selection✅  Option✅  Choose❌</p>
<h2 id="语法与时态"><a href="#语法与时态" class="headerlink" title="语法与时态"></a>语法与时态</h2><p><strong>一般使用第三人称单数(可以考虑使用复数形式)</strong></p>
<p>Equals,IsEqual,AreEqual,DependsOn</p>
<p><strong>尽量不要使用单复数不符合常见形式(可适当未被词汇或语法)</strong></p>
<p>Persons✅ PersonList✅  People❌(使用orm会很痛苦,需要加一些新的特性)</p>
<p>Infos ✅(不符合语法但可以)  </p>
<p>Datas ✅(不符合语法但可以)  </p>
<p><strong>考虑时态习惯</strong></p>
<p>OnPropertyChanged  对于事件可以以On开头</p>
<p>Closing 正在关闭    Closed 已经关闭</p>
<h2 id="更多细节"><a href="#更多细节" class="headerlink" title="更多细节"></a>更多细节</h2><p><strong>名称写清晰且完整(例外情形遵守普通习惯)</strong></p>
<p>CancellationTokenSource,OperationCanceledException</p>
<p>IsCompletedSuccessfully</p>
<p>SendCaches &lt; SendAllCachedUserData(&lt;指语义上)</p>
<p><strong>拓展方法尽量简洁且清晰</strong></p>
<p>this byte[]: BytesToInt &#x3D;&#x3D;&gt; ToInt32  由于调用的时候已经知道转换的主体了,因此后者在保持语义清晰的同时更简洁</p>
<p><strong>杜绝C&#x2F;C++,MATLAB,JAVA等命名习惯</strong></p>
<p>itoa❌,num2str❌,get_value❌</p>
<h1 id="nuget包盘点"><a href="#nuget包盘点" class="headerlink" title="nuget包盘点"></a>nuget包盘点</h1><h2 id="SkiaSharp绘图"><a href="#SkiaSharp绘图" class="headerlink" title="SkiaSharp绘图"></a>SkiaSharp绘图</h2><p>下载SkiaSharp包: <code>dotnet add package SkiaSharp</code></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> SkiaSharp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;<span class="built_in">double</span>&gt; data = <span class="keyword">new</span> List&lt;<span class="built_in">double</span>&gt; &#123; <span class="number">10</span>, <span class="number">50</span>, <span class="number">30</span>, <span class="number">80</span>, <span class="number">60</span>, <span class="number">90</span>, <span class="number">40</span> &#125;;</span><br><span class="line">        DrawLineChart(data, <span class="string">&quot;line_chart.png&quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Line chart saved as line_chart.png&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DrawLineChart</span>(<span class="params">List&lt;<span class="built_in">double</span>&gt; data, <span class="built_in">string</span> filename</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> width = <span class="number">800</span>;</span><br><span class="line">        <span class="built_in">int</span> height = <span class="number">600</span>;</span><br><span class="line">        <span class="built_in">int</span> padding = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> bitmap = <span class="keyword">new</span> SKBitmap(width, height))</span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> canvas = <span class="keyword">new</span> SKCanvas(bitmap))</span><br><span class="line">        &#123;</span><br><span class="line">            canvas.Clear(SKColors.White);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">double</span> maxData = data.Max();</span><br><span class="line">            <span class="built_in">double</span> minData = data.Min();</span><br><span class="line">            <span class="built_in">double</span> range = maxData - minData;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 避免除以零的情况</span></span><br><span class="line">            <span class="keyword">if</span> (range == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                range = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">float</span> scaleX = (width - <span class="number">2</span> * padding) / (<span class="built_in">float</span>)data.Count;</span><br><span class="line">            <span class="built_in">float</span> scaleY = (height - <span class="number">2</span> * padding) / (<span class="built_in">float</span>)range;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">float</span> zeroY = height - padding - (<span class="built_in">float</span>)(<span class="number">0</span> - minData) * scaleY;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 绘制 x 轴和 y 轴</span></span><br><span class="line">            <span class="keyword">using</span> (<span class="keyword">var</span> paint = <span class="keyword">new</span> SKPaint())</span><br><span class="line">            &#123;</span><br><span class="line">                paint.IsAntialias = <span class="literal">true</span>;</span><br><span class="line">                paint.StrokeWidth = <span class="number">2</span>;</span><br><span class="line">                paint.Color = SKColors.Black;</span><br><span class="line">                paint.Style = SKPaintStyle.Stroke;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 绘制 y 轴</span></span><br><span class="line">                canvas.DrawLine(padding, padding, padding, height - padding, paint);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 绘制 x 轴在零的位置</span></span><br><span class="line">                canvas.DrawLine(padding, zeroY, width - padding, zeroY, paint);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> path = <span class="keyword">new</span> SKPath();</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; data.Count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">float</span> x = padding + i * scaleX;</span><br><span class="line">                <span class="built_in">float</span> y = height - padding - (<span class="built_in">float</span>)(data[i] - minData) * scaleY;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    path.MoveTo(x, y);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    path.LineTo(x, y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">using</span> (<span class="keyword">var</span> paint = <span class="keyword">new</span> SKPaint())</span><br><span class="line">            &#123;</span><br><span class="line">                paint.IsAntialias = <span class="literal">true</span>;</span><br><span class="line">                paint.StrokeWidth = <span class="number">2</span>;</span><br><span class="line">                paint.Color = SKColors.Blue; <span class="comment">// 改变折线颜色以区别于轴线</span></span><br><span class="line">                paint.Style = SKPaintStyle.Stroke;</span><br><span class="line"></span><br><span class="line">                canvas.DrawPath(path, paint);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            SaveBitmap(bitmap, filename);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SaveBitmap</span>(<span class="params">SKBitmap bitmap, <span class="built_in">string</span> filename</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> image = SKImage.FromBitmap(bitmap))</span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> data = image.Encode(SKEncodedImageFormat.Png, <span class="number">100</span>))</span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> stream = System.IO.File.OpenWrite(filename))</span><br><span class="line">        &#123;</span><br><span class="line">            data.SaveTo(stream);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="绘制多条曲线图"><a href="#绘制多条曲线图" class="headerlink" title="绘制多条曲线图"></a>绘制多条曲线图</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DrawMultiLineChart</span>(<span class="params">List&lt;List&lt;<span class="built_in">double</span>&gt;&gt; dataSets, List&lt;<span class="built_in">string</span>&gt; labels, <span class="built_in">string</span> filename</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">int</span> width = <span class="number">1920</span>;</span><br><span class="line">  <span class="built_in">int</span> height = <span class="number">1080</span>;</span><br><span class="line">  <span class="built_in">int</span> padding = <span class="number">50</span>;</span><br><span class="line">  <span class="built_in">int</span> legendWidth = <span class="number">200</span>;</span><br><span class="line">  <span class="built_in">int</span> legendHeight = <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">float</span> pointRadius = <span class="number">4.0f</span>; <span class="comment">// 圆点半径</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">using</span> (<span class="keyword">var</span> bitmap = <span class="keyword">new</span> SKBitmap(width, height))</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> canvas = <span class="keyword">new</span> SKCanvas(bitmap))</span><br><span class="line">  &#123;</span><br><span class="line">    canvas.Clear(SKColors.White);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find the global max and min values</span></span><br><span class="line">    <span class="built_in">double</span> maxData = dataSets.SelectMany(data =&gt; data).Max();</span><br><span class="line">    <span class="built_in">double</span> minData = dataSets.SelectMany(data =&gt; data).Min();</span><br><span class="line">    <span class="built_in">double</span> range = maxData - minData;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (range == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      range = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">float</span> scaleX = (width - padding - legendWidth) / (<span class="built_in">float</span>)dataSets.Max(data =&gt; data.Count);</span><br><span class="line">    <span class="built_in">float</span> scaleY = (height - <span class="number">2</span> * padding) / (<span class="built_in">float</span>)range;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">float</span> zeroY = height - padding - (<span class="built_in">float</span>)(<span class="number">0</span> - minData) * scaleY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Draw x and y axes</span></span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> paint = <span class="keyword">new</span> SKPaint())</span><br><span class="line">    &#123;</span><br><span class="line">      paint.IsAntialias = <span class="literal">true</span>;</span><br><span class="line">      paint.StrokeWidth = <span class="number">2</span>;</span><br><span class="line">      paint.Color = SKColors.Black;</span><br><span class="line">      paint.Style = SKPaintStyle.Stroke;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Draw y axis</span></span><br><span class="line">      canvas.DrawLine(padding, padding, padding, height - padding, paint);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Draw x axis at zero position</span></span><br><span class="line">      canvas.DrawLine(padding, zeroY, width - padding - legendWidth, zeroY, paint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Define colors for different lines</span></span><br><span class="line">    <span class="keyword">var</span> colors = <span class="keyword">new</span> SKColor[] &#123; SKColors.Red, SKColors.Blue, SKColors.Green, SKColors.Purple, SKColors.Orange &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Draw each line and legend</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; dataSets.Count; j++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">var</span> data = dataSets[j];</span><br><span class="line">      <span class="keyword">var</span> path = <span class="keyword">new</span> SKPath();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; data.Count; i++)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">float</span> x = padding + i * scaleX;</span><br><span class="line">        <span class="built_in">float</span> y = height - padding - (<span class="built_in">float</span>)(data[i] - minData) * scaleY;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Draw circle at data point</span></span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> pointPaint = <span class="keyword">new</span> SKPaint())</span><br><span class="line">        &#123;</span><br><span class="line">          pointPaint.IsAntialias = <span class="literal">true</span>;</span><br><span class="line">          pointPaint.Color = colors[j % colors.Length];</span><br><span class="line">          canvas.DrawCircle(x, y, pointRadius, pointPaint);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          path.MoveTo(x, y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          path.LineTo(x, y);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// //虚线绘制不全,还未修正</span></span><br><span class="line">        <span class="comment">// // Draw dashed line to x axis</span></span><br><span class="line">        <span class="comment">// using (var dashPaint = new SKPaint())</span></span><br><span class="line">        <span class="comment">// &#123;</span></span><br><span class="line">        <span class="comment">//     dashPaint.Style = SKPaintStyle.Stroke;</span></span><br><span class="line">        <span class="comment">//     dashPaint.Color = colors[j % colors.Length];</span></span><br><span class="line">        <span class="comment">//     dashPaint.StrokeWidth = 0.1f;</span></span><br><span class="line">        <span class="comment">//     dashPaint.PathEffect = SKPathEffect.CreateDash(new float[] &#123; 3, 10 &#125;, 0);</span></span><br><span class="line">        <span class="comment">//     var dashPath = new SKPath();</span></span><br><span class="line">        <span class="comment">//     dashPath.MoveTo(x, y);</span></span><br><span class="line">        <span class="comment">//     dashPath.LineTo(x, zeroY);</span></span><br><span class="line">        <span class="comment">//     canvas.DrawPath(dashPath, dashPaint);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// // Draw dashed line to y axis</span></span><br><span class="line">        <span class="comment">// if (data[i] != 0) // Avoid drawing line at y = 0 (x axis)</span></span><br><span class="line">        <span class="comment">// &#123;</span></span><br><span class="line">        <span class="comment">//     using (var dashPaint = new SKPaint())</span></span><br><span class="line">        <span class="comment">//     &#123;</span></span><br><span class="line">        <span class="comment">//         dashPaint.Style = SKPaintStyle.Stroke;</span></span><br><span class="line">        <span class="comment">//         dashPaint.Color = colors[j % colors.Length];</span></span><br><span class="line">        <span class="comment">//         dashPaint.StrokeWidth = 0.1f;</span></span><br><span class="line">        <span class="comment">//         dashPaint.PathEffect = SKPathEffect.CreateDash(new float[] &#123; 3, 10 &#125;, 0);</span></span><br><span class="line">        <span class="comment">//         var dashPath = new SKPath();</span></span><br><span class="line">        <span class="comment">//         dashPath.MoveTo(x, y);</span></span><br><span class="line">        <span class="comment">//         dashPath.LineTo(padding, y); // Draw line to y axis</span></span><br><span class="line">        <span class="comment">//         canvas.DrawPath(dashPath, dashPaint);</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Draw legend for each line</span></span><br><span class="line">      <span class="keyword">using</span> (<span class="keyword">var</span> legendPaint = <span class="keyword">new</span> SKPaint())</span><br><span class="line">      &#123;</span><br><span class="line">        legendPaint.Style = SKPaintStyle.Stroke;</span><br><span class="line">        legendPaint.Color = colors[j % colors.Length];</span><br><span class="line">        legendPaint.StrokeWidth = <span class="number">1</span>;</span><br><span class="line">        legendPaint.IsAntialias = <span class="literal">true</span>;</span><br><span class="line">        canvas.DrawLine(width - padding - legendWidth, padding + j * legendHeight, width - padding, padding + j * legendHeight, legendPaint);</span><br><span class="line">        canvas.DrawText(labels[j], width - padding - legendWidth + <span class="number">10</span>, padding + j * legendHeight + <span class="number">15</span>, legendPaint);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Draw lines</span></span><br><span class="line">      <span class="keyword">using</span> (<span class="keyword">var</span> paint = <span class="keyword">new</span> SKPaint())</span><br><span class="line">      &#123;</span><br><span class="line">        paint.IsAntialias = <span class="literal">true</span>;</span><br><span class="line">        paint.StrokeWidth = <span class="number">2</span>;</span><br><span class="line">        paint.Color = colors[j % colors.Length];</span><br><span class="line">        paint.Style = SKPaintStyle.Stroke;</span><br><span class="line"></span><br><span class="line">        canvas.DrawPath(path, paint);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save bitmap</span></span><br><span class="line">    SaveBitmap(bitmap, filename);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Dynamic-Expresso"><a href="#Dynamic-Expresso" class="headerlink" title="Dynamic Expresso"></a>Dynamic Expresso</h2><p>Dynamic Expresso 是一个用于动态解析和执行表达式的库，主要用于将字符串形式的表达式解析为可执行的 lambda 表达式。它的主要功能包括：</p>
<p>MIT开源   <a target="_blank" rel="noopener" href="https://github.com/dynamicexpresso/DynamicExpresso?tab=readme-ov-file">开源地址</a></p>
<ol>
<li><strong>动态计算</strong>：可以在运行时动态地解析和计算表达式，而不需要在编译时确定所有的逻辑。这在某些场景下非常有用，比如需要根据用户输入或配置文件动态生成逻辑的情况。</li>
<li><strong>简化代码</strong>：通过将复杂的逻辑表达式以字符串形式表示，可以简化代码的编写和维护。例如，可以将业务规则或条件逻辑存储为字符串，然后在需要时解析并执行。</li>
<li><strong>灵活性</strong>：允许开发者在运行时创建和调整表达式，使得应用程序能够更灵活地响应变化。例如，在规则引擎或查询语言中，用户可以输入自定义的查询条件，系统则可以解析并执行这些条件</li>
</ol>
<p>可以评估数学表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var interpreter = new Interpreter();</span><br><span class="line">var result = interpreter.Eval(&quot;8 / 2 + 2&quot;);</span><br></pre></td></tr></table></figure>

<p>或者解析带有多个变量或参数的表达式并多次调用它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var interpreter = new Interpreter().SetVariable(&quot;service&quot;, new ServiceExample());</span><br><span class="line">string expression = &quot;x &gt; 4 ? service.OneMethod() : service.AnotherMethod()&quot;;</span><br><span class="line">Lambda parsedExpression = interpreter.Parse(expression, new Parameter(&quot;x&quot;, typeof(int)));</span><br><span class="line">var result = parsedExpression.Invoke(5);</span><br></pre></td></tr></table></figure>

<p>或者为 LINQ 查询生成委托和 lambda 表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var prices = new [] &#123; 5, 8, 6, 2 &#125;;</span><br><span class="line">var whereFunction = new Interpreter().ParseAsDelegate&lt;Func&lt;int, bool&gt;&gt;(&quot;arg &gt; 5&quot;);</span><br><span class="line">var count = prices.Where(whereFunction).Count();</span><br></pre></td></tr></table></figure>

<h2 id="CsvHelper"><a href="#CsvHelper" class="headerlink" title="CsvHelper"></a>CsvHelper</h2><p><code>CsvWriter</code> 是一个用于在 C# 中生成和读取 CSV（Comma-Separated Values）文件的库。它通常用于将数据导出到 CSV 格式，或者从 CSV 文件中读取数据。<code>CsvWriter</code> 库提供了简单易用的 API，使得处理 CSV 文件变得更加方便。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/JoshClose/CsvHelper?tab=License-1-ov-file#readme">开源地址</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet add package CsvHelper</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://joshclose.github.io/CsvHelper/getting-started/">详细使用介绍</a></p>
<p>简单记录使用方式:</p>
<p>定义一个可以和csv文件格式对应的类</p>
<h3 id="读取方式"><a href="#读取方式" class="headerlink" title="读取方式"></a>读取方式</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> reader = <span class="keyword">new</span> StreamReader(<span class="string">&quot;path\\to\\file.csv&quot;</span>))</span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> csv = <span class="keyword">new</span> CsvReader(reader, CultureInfo.InvariantCulture))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> records = csv.GetRecords&lt;Foo&gt;();<span class="comment">//读取自定义的Foo类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该<code>GetRecords&lt;T&gt;</code>方法将返回一个<code>IEnumerable&lt;T&gt;</code>记录<code>yield</code>。这意味着在迭代记录时一次只返回一条记录。这也意味着只有一小部分文件被读入内存。但要小心。如果您执行任何执行 LINQ 投影的操作（例如调用），则<code>.ToList()</code>整个文件将被读入内存。<code>CsvReader</code>是仅向前的，因此如果您想针对数据运行任何 LINQ 查询，则必须将整个文件拉入内存。只要知道这就是你在做的事情。</p>
<p>如果csv文件中没有标题记录,或者想要改属性名的对应大小写格式都可以参考<a target="_blank" rel="noopener" href="https://joshclose.github.io/CsvHelper/getting-started/">详细使用介绍</a></p>
<h3 id="写入方式"><a href="#写入方式" class="headerlink" title="写入方式"></a>写入方式</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> writer = <span class="keyword">new</span> StreamWriter(<span class="string">&quot;path\\to\\file.csv&quot;</span>))</span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> csv = <span class="keyword">new</span> CsvWriter(writer, CultureInfo.InvariantCulture))</span><br><span class="line">&#123;</span><br><span class="line">    csv.WriteRecords(records);<span class="comment">//将records对象写入csv文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第三方数据结构库"><a href="#第三方数据结构库" class="headerlink" title="第三方数据结构库"></a>第三方数据结构库</h2><h3 id="C5"><a href="#C5" class="headerlink" title="C5"></a>C5</h3><p>用于C#&#x2F;.NET的通用集合库</p>
<p>MIT开源  <a target="_blank" rel="noopener" href="https://github.com/sestoft/C5">开源地址</a></p>
<p>安装方式 <code>dotnet add package C5</code></p>
<p><strong>线性数据结构</strong></p>
<ul>
<li><strong>ArrayList:</strong> 底层使用动态数组实现，支持快速随机访问，但插入和删除操作在中间位置可能比较慢。</li>
<li><strong>DoublyLinkedList:</strong> 底层使用双向链表实现，支持快速插入和删除操作，但随机访问比较慢。</li>
<li><strong>HashIndexedArrayList:</strong> 底层使用动态数组和哈希表实现，支持快速随机访问和插入，但删除操作可能比较慢。</li>
<li><strong>HashIndexedLinkedList:</strong> 底层使用双向链表和哈希表实现，支持快速插入和删除操作，但随机访问比较慢。</li>
</ul>
<p><strong>集合</strong></p>
<ul>
<li><strong>HashSet:</strong> 底层使用哈希表实现，不包含重复元素，支持快速查找、插入和删除操作。</li>
<li><strong>HashBag:</strong> 底层使用哈希表实现，允许重复元素，支持快速查找、插入和删除操作。</li>
<li><strong>SortedArray:</strong> 底层使用有序数组实现，支持快速查找、插入和删除操作，但插入和删除操作在中间位置可能比较慢。</li>
<li><strong>WrappedArray:</strong> 底层使用数组实现，提供对数组的只读访问。</li>
<li><strong>TreeSet:</strong> 底层使用平衡二叉树 (红黑树) 实现，有序集合，不包含重复元素，支持快速查找、插入和删除操作，并保持元素的排序。</li>
<li><strong>TreeBag:</strong> 底层使用平衡二叉树 (红黑树) 实现，有序集合，允许重复元素，支持快速查找、插入和删除操作，并保持元素的排序。</li>
</ul>
<p><strong>栈和队列</strong></p>
<ul>
<li><strong>Stack:</strong> 底层使用数组或链表实现，后进先出 (LIFO) 的栈，支持快速入栈和出栈操作。</li>
<li><strong>DoubleEndedQueue:</strong> 底层使用双向链表实现，支持从两端进行入队和出队操作。</li>
<li><strong>CircularQueue:</strong> 底层使用数组实现，支持快速入队和出队操作，但容量有限。</li>
<li><strong>PriorityQueue:</strong> 底层使用间隔堆 (interval heap) 实现，支持快速插入和删除操作，并根据优先级排序元素。</li>
</ul>
<p><strong>字典</strong></p>
<ul>
<li><strong>HashDictionary:</strong> 底层使用哈希表实现，支持快速查找、插入和删除操作。</li>
<li><strong>TreeDictionary:</strong> 底层使用平衡二叉树 (红黑树) 实现，支持快速查找、插入和删除操作，并保持键的排序。</li>
</ul>
<blockquote>
<p>即使是这样,也没找到一个类似于C++ STL中的MultiMap这样的数据结构</p>
</blockquote>
<h2 id="控制反转容器库"><a href="#控制反转容器库" class="headerlink" title="控制反转容器库"></a>控制反转容器库</h2><p><a target="_blank" rel="noopener" href="https://github.com/autofac/Autofac">Autofac</a></p>
<p>可以提供自动注入构造函数参数的功能</p>
<p>也可以提供面向切片编程的实现</p>
<h2 id="状态机库"><a href="#状态机库" class="headerlink" title="状态机库"></a>状态机库</h2><h3 id="stateless"><a href="#stateless" class="headerlink" title="stateless"></a>stateless</h3><p><a target="_blank" rel="noopener" href="https://github.com/dotnet-state-machine/stateless">开源地址</a></p>
<p>Stateless 是一个轻量级的状态机库，用于在.NET 应用程序中实现状态机模式。它允许你以简单直观的方式定义状态、转换和触发器。</p>
<p>安装方式 <code>Install-Package Stateless</code></p>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul>
<li>State(状态): 对象在某一时刻的条件或情况</li>
<li>Trigger(触发器): 导致状态改变的事件或动作</li>
<li>Transition(转换): 从一个状态到另一个状态的转变</li>
</ul>
<h4 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h4><ol>
<li><p>定义状态和触发器</p>
<p>开始使用之前，你需要定义状态机的状态和触发器。状态表示对象当前所处的阶段，而触发器是导致状态改变的事件</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> State</span><br><span class="line">&#123;</span><br><span class="line">    Off,</span><br><span class="line">    On</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> Trigger</span><br><span class="line">&#123;</span><br><span class="line">    TurnOn,</span><br><span class="line">    TurnOff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建状态机</p>
<p>使用 <code>StateMachine</code> 类创建一个状态机实例。你需要指定初始状态。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> machine = <span class="keyword">new</span> Stateless.StateMachine&lt;State, Trigger&gt;(State.Off);</span><br></pre></td></tr></table></figure></li>
<li><p>配置状态转换</p>
<p>定义状态和触发器之间的转换关系。你可以使用 <code>Configure</code> 方法为每个状态设置可以接受的触发器。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//允许状态机在off状态下被turnOn,变化到On状态</span></span><br><span class="line">machine.Configure(State.Off)</span><br><span class="line">    .Permit(Trigger.TurnOn, State.On);</span><br><span class="line"></span><br><span class="line"><span class="comment">//允许状态机在on状态下被turnOff,变化到O状态</span></span><br><span class="line">machine.Configure(State.On)</span><br><span class="line">    .Permit(Trigger.TurnOff, State.Off);</span><br></pre></td></tr></table></figure>
</li>
<li><p>触发转换</p>
<p>通过触发器改变状态机的状态。调用 <code>Fire</code> 方法来执行状态转换</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">machine.Fire(Trigger.TurnOn);</span><br><span class="line">Console.WriteLine(machine.State);  <span class="comment">// 输出: On</span></span><br><span class="line"></span><br><span class="line">machine.Fire(Trigger.TurnOff);</span><br><span class="line">Console.WriteLine(machine.State);  <span class="comment">// 输出: Off</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>添加进入和退出动作</p>
<p>你可以在状态进入或退出时执行特定的动作。使用 <code>OnEntry</code> 和 <code>OnExit</code> 方法</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">machine.Configure(State.On)</span><br><span class="line">    .OnEntry(() =&gt; Console.WriteLine(<span class="string">&quot;Entering On state&quot;</span>))</span><br><span class="line">    .OnExit(() =&gt; Console.WriteLine(<span class="string">&quot;Exiting On state&quot;</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用条件限制转换</p>
<p>可以使用条件来限制某些状态转换。例如，你可以在某个条件下允许转换。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> canTurnOn = <span class="literal">true</span>;</span><br><span class="line">machine.Configure(State.Off)</span><br><span class="line">    .PermitIf(Trigger.TurnOn, State.On, () =&gt; canTurnOn);</span><br></pre></td></tr></table></figure>
</li>
<li><p>异步支持</p>
<p>Stateless 也支持异步状态转换。你可以使用异步方法来配置和触发状态机</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> machine.FireAsync(Trigger.TurnOn);</span><br></pre></td></tr></table></figure>
</li>
<li><p>还支持子状态,动态触发器参数等,略</p>
</li>
</ol>
<p>其他:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取可用触发器</span></span><br><span class="line"><span class="keyword">var</span> permitted = machine.GetPermittedTriggers();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否可以触发特定转换</span></span><br><span class="line"><span class="built_in">bool</span> canFire = machine.CanFire(Trigger.CallDialed);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前状态信息</span></span><br><span class="line"><span class="keyword">var</span> state = machine.State;</span><br></pre></td></tr></table></figure>

<h4 id="完整案例"><a href="#完整案例" class="headerlink" title="完整案例"></a>完整案例</h4><p>下面是一个订单处理系统的示例</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> OrderState</span><br><span class="line">&#123;</span><br><span class="line">    New,</span><br><span class="line">    Pending,</span><br><span class="line">    Confirmed,</span><br><span class="line">    Processing,</span><br><span class="line">    Shipped,</span><br><span class="line">    Delivered,</span><br><span class="line">    Cancelled</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> OrderTrigger</span><br><span class="line">&#123;</span><br><span class="line">    Confirm,</span><br><span class="line">    Process,</span><br><span class="line">    Ship,</span><br><span class="line">    Deliver,</span><br><span class="line">    Cancel</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Order</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> StateMachine&lt;OrderState, OrderTrigger&gt; _machine;</span><br><span class="line">    <span class="keyword">public</span> OrderState State &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Order</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _machine = <span class="keyword">new</span> StateMachine&lt;OrderState, OrderTrigger&gt;(OrderState.New);</span><br><span class="line">        ConfigureStateMachine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ConfigureStateMachine</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _machine.Configure(OrderState.New)</span><br><span class="line">            .Permit(OrderTrigger.Confirm, OrderState.Confirmed)</span><br><span class="line">            .Permit(OrderTrigger.Cancel, OrderState.Cancelled)</span><br><span class="line">            .OnEntry(() =&gt; SendNotification(<span class="string">&quot;New order created&quot;</span>));</span><br><span class="line"></span><br><span class="line">        _machine.Configure(OrderState.Confirmed)</span><br><span class="line">            .Permit(OrderTrigger.Process, OrderState.Processing)</span><br><span class="line">            .Permit(OrderTrigger.Cancel, OrderState.Cancelled)</span><br><span class="line">            .OnEntry(() =&gt; SendNotification(<span class="string">&quot;Order confirmed&quot;</span>));</span><br><span class="line"></span><br><span class="line">        _machine.Configure(OrderState.Processing)</span><br><span class="line">            .Permit(OrderTrigger.Ship, OrderState.Shipped)</span><br><span class="line">            .OnEntry(() =&gt; StartProcessing());</span><br><span class="line"></span><br><span class="line">        _machine.Configure(OrderState.Shipped)</span><br><span class="line">            .Permit(OrderTrigger.Deliver, OrderState.Delivered)</span><br><span class="line">            .OnEntry(() =&gt; UpdateShippingStatus());</span><br><span class="line"></span><br><span class="line">        _machine.Configure(OrderState.Delivered)</span><br><span class="line">            .OnEntry(() =&gt; CompleteOrder());</span><br><span class="line"></span><br><span class="line">        _machine.Configure(OrderState.Cancelled)</span><br><span class="line">            .OnEntry(() =&gt; HandleCancellation());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Confirm</span>()</span> =&gt; _machine.Fire(OrderTrigger.Confirm);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Process</span>()</span> =&gt; _machine.Fire(OrderTrigger.Process);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Ship</span>()</span> =&gt; _machine.Fire(OrderTrigger.Ship);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Deliver</span>()</span> =&gt; _machine.Fire(OrderTrigger.Deliver);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Cancel</span>()</span> =&gt; _machine.Fire(OrderTrigger.Cancel);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SendNotification</span>(<span class="params"><span class="built_in">string</span> message</span>)</span> </span><br><span class="line">        =&gt; Console.WriteLine(message);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">StartProcessing</span>()</span> </span><br><span class="line">        =&gt; Console.WriteLine(<span class="string">&quot;Processing order...&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">UpdateShippingStatus</span>()</span> </span><br><span class="line">        =&gt; Console.WriteLine(<span class="string">&quot;Updating shipping status...&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CompleteOrder</span>()</span> </span><br><span class="line">        =&gt; Console.WriteLine(<span class="string">&quot;Order completed&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">HandleCancellation</span>()</span> </span><br><span class="line">        =&gt; Console.WriteLine(<span class="string">&quot;Order cancelled&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用方式</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> order = <span class="keyword">new</span> Order();</span><br><span class="line">order.Confirm();</span><br><span class="line">order.Process();</span><br><span class="line">order.Ship();</span><br><span class="line">order.Deliver();</span><br></pre></td></tr></table></figure>

<h2 id="自动映射库"><a href="#自动映射库" class="headerlink" title="自动映射库"></a>自动映射库</h2><p>AutoMappper,Mapster等</p>
<p>但自动映射使用起来要注意,查找所有引用或查找哪里使用了这种操作,无法找到自动映射的使用.这样当清除某些属性的时候,就不好判断是否有别处用了,有可能是在自动映射中使用了.这个问题也有解决方案,有辅助的插件可以生成映射代码</p>
<h1 id="CSharp-一些好用的控件盘点"><a href="#CSharp-一些好用的控件盘点" class="headerlink" title="CSharp 一些好用的控件盘点"></a>CSharp 一些好用的控件盘点</h1><p>Infragistics.Win.UltraWinGrid</p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4" title="头像" alt="头像"></a><div class="post-copyright__author_name">ZEROKO14</div><div class="post-copyright__author_desc">zeroko14's blog</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://che77a38.github.io/posts/CSharp%E5%85%A5%E9%97%A8/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://che77a38.github.io/posts/CSharp%E5%85%A5%E9%97%A8/')">CSharp入门</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://che77a38.github.io/posts/CSharp%E5%85%A5%E9%97%A8/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=CSharp入门&amp;url=https://che77a38.github.io/posts/CSharp%E5%85%A5%E9%97%A8/&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://che77a38.github.io" target="_blank">ZEROKO14的个人博客</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/CSharp/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>CSharp<span class="tagsPageCount">1</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/C++%E5%9F%BA%E7%A1%80/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C++基础</div></div></a></div><div class="next-post pull-right"><a href="/posts/git/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">git详解</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description">欢迎来到ZEROKO14的个人博客</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">ZEROKO14</h1><div class="author-info__desc">zeroko14's blog</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/che77a38" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#NET-Framework"><span class="toc-number">1.</span> <span class="toc-text">.NET Framework</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CLR%EF%BC%9A%E5%85%AC%E5%85%B1%E8%AF%AD%E8%A8%80%E8%BF%90%E8%A1%8C%E5%BA%93"><span class="toc-number">1.1.</span> <span class="toc-text">CLR：公共语言运行库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FCL%EF%BC%9A%E6%A1%86%E6%9E%B6%E7%B1%BB%E5%BA%93"><span class="toc-number">1.2.</span> <span class="toc-text">FCL：框架类库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WinForms"><span class="toc-number">1.3.</span> <span class="toc-text">WinForms</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ASP-NET"><span class="toc-number">1.4.</span> <span class="toc-text">ASP.NET</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ADO-NET"><span class="toc-number">1.5.</span> <span class="toc-text">ADO.NET</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WPF"><span class="toc-number">1.6.</span> <span class="toc-text">WPF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WCF"><span class="toc-number">1.7.</span> <span class="toc-text">WCF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WF"><span class="toc-number">1.8.</span> <span class="toc-text">WF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LINQ"><span class="toc-number">1.9.</span> <span class="toc-text">LINQ</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Parallel-LINQ"><span class="toc-number">1.10.</span> <span class="toc-text">Parallel LINQ</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-number">2.</span> <span class="toc-text">开发环境搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#mac%E7%89%88"><span class="toc-number">2.1.</span> <span class="toc-text">mac版</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vscode-Nuget-Package-Manager%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6"><span class="toc-number">2.1.1.</span> <span class="toc-text">vscode Nuget Package Manager扩展插件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#nuget%E5%8C%85%E7%9B%B8%E5%85%B3"><span class="toc-number">3.</span> <span class="toc-text">nuget包相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#nuget%E5%8C%85%E7%9A%84%E6%89%93%E5%8C%85%E4%B8%8E%E5%8F%91%E5%B8%83"><span class="toc-number">3.1.</span> <span class="toc-text">nuget包的打包与发布</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0"><span class="toc-number">3.1.1.</span> <span class="toc-text">更新</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSharp%E6%A6%82%E8%BF%B0"><span class="toc-number">4.</span> <span class="toc-text">CSharp概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.1.</span> <span class="toc-text">值类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.2.</span> <span class="toc-text">引用类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%EF%BC%88Object%EF%BC%89"><span class="toc-number">5.2.1.</span> <span class="toc-text">对象类型（Object）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%EF%BC%88Dynamic%EF%BC%89"><span class="toc-number">5.2.2.</span> <span class="toc-text">动态类型（Dynamic）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%EF%BC%88String%EF%BC%89"><span class="toc-number">5.2.3.</span> <span class="toc-text">字符串类型（String）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.3.</span> <span class="toc-text">指针类型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">6.</span> <span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CSharp%E5%8F%AF%E7%A9%BA%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.1.</span> <span class="toc-text">CSharp可空类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Null-%E5%90%88%E5%B9%B6%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88-%EF%BC%89"><span class="toc-number">6.2.</span> <span class="toc-text">Null 合并运算符（??）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">7.</span> <span class="toc-text">类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">7.1.</span> <span class="toc-text">隐式类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">7.2.</span> <span class="toc-text">显示类型转换</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">8.</span> <span class="toc-text">运算符优先级</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSharp-foreach%E5%BE%AA%E7%8E%AF"><span class="toc-number">9.</span> <span class="toc-text">CSharp foreach循环</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSharp%E5%87%BD%E6%95%B0-%E6%96%B9%E6%B3%95"><span class="toc-number">10.</span> <span class="toc-text">CSharp函数&#x2F;方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0"><span class="toc-number">10.1.</span> <span class="toc-text">静态函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSharp%E5%B0%81%E8%A3%85"><span class="toc-number">11.</span> <span class="toc-text">CSharp封装</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSharp%E5%80%BC%E4%BC%A0%E9%80%92-%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92-%E8%BE%93%E5%87%BA%E4%BC%A0%E9%80%92"><span class="toc-number">12.</span> <span class="toc-text">CSharp值传递,引用传递,输出传递</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="toc-number">12.1.</span> <span class="toc-text">引用传递</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E4%BC%A0%E9%80%92"><span class="toc-number">12.2.</span> <span class="toc-text">输出传递</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSharp-Array%E6%95%B0%E7%BB%84"><span class="toc-number">13.</span> <span class="toc-text">CSharp Array数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">13.1.</span> <span class="toc-text">二维数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A4%E9%94%99%E6%95%B0%E7%BB%84"><span class="toc-number">13.2.</span> <span class="toc-text">交错数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A4%E9%94%99%E6%95%B0%E7%BB%84%E5%92%8C%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">13.3.</span> <span class="toc-text">交错数组和多维数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E6%95%B0%E7%BB%84"><span class="toc-number">13.4.</span> <span class="toc-text">参数数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSharp-Array%E7%B1%BB"><span class="toc-number">13.5.</span> <span class="toc-text">CSharp Array类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7"><span class="toc-number">13.5.1.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">13.5.2.</span> <span class="toc-text">方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSharp-String%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">14.</span> <span class="toc-text">CSharp String字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7-1"><span class="toc-number">14.1.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95-1"><span class="toc-number">14.2.</span> <span class="toc-text">方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSharp-struct%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">15.</span> <span class="toc-text">CSharp struct结构体</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSharp-enum%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">16.</span> <span class="toc-text">CSharp enum枚举类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSharp-class%E7%B1%BB"><span class="toc-number">17.</span> <span class="toc-text">CSharp class类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1"><span class="toc-number">17.1.</span> <span class="toc-text">对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">17.2.</span> <span class="toc-text">构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">17.2.1.</span> <span class="toc-text">实例构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">17.2.2.</span> <span class="toc-text">静态构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%81%E6%9C%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">17.2.3.</span> <span class="toc-text">私有构造函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">17.3.</span> <span class="toc-text">析构函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSharp-this%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">17.4.</span> <span class="toc-text">CSharp this关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSharp-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">17.5.</span> <span class="toc-text">CSharp 静态成员</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7"><span class="toc-number">17.5.1.</span> <span class="toc-text">静态属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0-1"><span class="toc-number">17.5.2.</span> <span class="toc-text">静态函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSharp-%E9%9D%99%E6%80%81%E7%B1%BB"><span class="toc-number">17.5.3.</span> <span class="toc-text">CSharp 静态类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSharp-%E7%BB%A7%E6%89%BF"><span class="toc-number">17.6.</span> <span class="toc-text">CSharp 继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CSharp-%E6%8E%A5%E5%8F%A3"><span class="toc-number">17.6.1.</span> <span class="toc-text">CSharp 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-number">17.6.2.</span> <span class="toc-text">接口实现的多重继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%B3%9B%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E4%BE%8B"><span class="toc-number">17.6.3.</span> <span class="toc-text">接口实现的泛型数据结构实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSharp-%E5%A4%9A%E6%80%81"><span class="toc-number">17.7.</span> <span class="toc-text">CSharp 多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%97%B6%E5%A4%9A%E6%80%81"><span class="toc-number">17.7.1.</span> <span class="toc-text">编译时多态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">17.7.1.1.</span> <span class="toc-text">函数重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">17.7.1.2.</span> <span class="toc-text">运算符重载</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E8%BD%BD%E4%B8%8E%E4%B8%8D%E5%8F%AF%E9%87%8D%E8%BD%BD%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">17.7.1.2.1.</span> <span class="toc-text">可重载与不可重载的运算符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%A4%9A%E6%80%81"><span class="toc-number">17.7.2.</span> <span class="toc-text">运行时多态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#abstract"><span class="toc-number">17.7.2.1.</span> <span class="toc-text">abstract</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#virtual"><span class="toc-number">17.7.2.2.</span> <span class="toc-text">virtual</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#virtual%E4%B8%8Eabstract%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">17.7.2.3.</span> <span class="toc-text">virtual与abstract的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#virtual%E5%9C%A8%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%AD"><span class="toc-number">17.7.2.4.</span> <span class="toc-text">virtual在接口和抽象类中</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSharp%E4%B8%8EC-%E5%A4%9A%E6%80%81%E5%AF%B9%E6%AF%94"><span class="toc-number">17.7.3.</span> <span class="toc-text">CSharp与C++多态对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">17.7.4.</span> <span class="toc-text">对接口和抽象类的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3%E8%80%8C%E4%B8%8D%E7%94%A8%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">17.7.4.1.</span> <span class="toc-text">什么情况下应该使用接口而不用抽象类</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSharp-namespace%EF%BC%9A%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">18.</span> <span class="toc-text">CSharp namespace：命名空间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#using%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">18.0.1.</span> <span class="toc-text">using关键字</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSharp-%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">19.</span> <span class="toc-text">CSharp 预处理器指令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CSharp-%E4%B8%AD%E7%9A%84%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">19.1.</span> <span class="toc-text">CSharp 中的预处理器指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#define-%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">19.2.</span> <span class="toc-text">#define 预处理器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E6%8C%87%E4%BB%A4"><span class="toc-number">19.3.</span> <span class="toc-text">条件指令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSharp-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">20.</span> <span class="toc-text">CSharp 正则表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Regex%E7%B1%BB"><span class="toc-number">20.1.</span> <span class="toc-text">Regex类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSharp-%E5%BC%82%E5%B8%B8"><span class="toc-number">21.</span> <span class="toc-text">CSharp 异常</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CSharp%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E7%B1%BB"><span class="toc-number">21.1.</span> <span class="toc-text">CSharp中的异常类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E7%B1%BB"><span class="toc-number">21.2.</span> <span class="toc-text">自定义异常类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-number">21.3.</span> <span class="toc-text">抛出异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88%E7%90%86%E8%A7%A3"><span class="toc-number">21.4.</span> <span class="toc-text">异常调用堆栈理解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSharp-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99"><span class="toc-number">22.</span> <span class="toc-text">CSharp 文件读写</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CSharp-%E4%B8%AD%E7%9A%84-I-O-%E7%B1%BB"><span class="toc-number">22.1.</span> <span class="toc-text">CSharp 中的 I&#x2F;O 类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FileStream-%E7%B1%BB"><span class="toc-number">22.2.</span> <span class="toc-text">FileStream 类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FileStream-%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">22.2.1.</span> <span class="toc-text">FileStream 类中的常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99"><span class="toc-number">22.2.1.1.</span> <span class="toc-text">二进制文件读写</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#BinaryReader"><span class="toc-number">22.2.1.1.1.</span> <span class="toc-text">BinaryReader</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#BinaryWriter"><span class="toc-number">22.2.1.1.2.</span> <span class="toc-text">BinaryWriter</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99"><span class="toc-number">22.2.1.2.</span> <span class="toc-text">文本文件的读写</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#StreamReader"><span class="toc-number">22.2.1.2.1.</span> <span class="toc-text">StreamReader</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#StreamWriter"><span class="toc-number">22.2.1.2.2.</span> <span class="toc-text">StreamWriter</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSharp-%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C"><span class="toc-number">23.</span> <span class="toc-text">CSharp 目录操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#DirectoryInfo"><span class="toc-number">23.1.</span> <span class="toc-text">DirectoryInfo</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSharp-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">24.</span> <span class="toc-text">CSharp 文件操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#FileInfo"><span class="toc-number">24.1.</span> <span class="toc-text">FileInfo</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSharp-%E7%89%B9%E6%80%A7"><span class="toc-number">25.</span> <span class="toc-text">CSharp 特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E5%AE%9A%E4%B9%89%E7%89%B9%E6%80%A7"><span class="toc-number">25.1.</span> <span class="toc-text">预定义特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AttributeUsage"><span class="toc-number">25.1.1.</span> <span class="toc-text">AttributeUsage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Conditional"><span class="toc-number">25.1.2.</span> <span class="toc-text">Conditional</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Obsolete"><span class="toc-number">25.1.3.</span> <span class="toc-text">Obsolete</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%89%B9%E6%80%A7"><span class="toc-number">25.2.</span> <span class="toc-text">自定义特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7"><span class="toc-number">25.2.1.</span> <span class="toc-text">声明自定义属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%89%B9%E6%80%A7"><span class="toc-number">25.2.2.</span> <span class="toc-text">构建自定义特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%89%B9%E6%80%A7"><span class="toc-number">25.2.3.</span> <span class="toc-text">应用自定义特性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSharp-%E5%B1%9E%E6%80%A7"><span class="toc-number">26.</span> <span class="toc-text">CSharp 属性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%99%A8"><span class="toc-number">26.1.</span> <span class="toc-text">访问器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%B1%9E%E6%80%A7"><span class="toc-number">26.2.</span> <span class="toc-text">抽象属性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSharp-%E7%B4%A2%E5%BC%95%E5%99%A8"><span class="toc-number">27.</span> <span class="toc-text">CSharp 索引器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%99%A8%E9%87%8D%E8%BD%BD"><span class="toc-number">27.1.</span> <span class="toc-text">索引器重载</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSharp-%E5%A7%94%E6%89%98"><span class="toc-number">28.</span> <span class="toc-text">CSharp 委托</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%A7%94%E6%89%98"><span class="toc-number">28.1.</span> <span class="toc-text">声明委托</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%A7%94%E6%89%98"><span class="toc-number">28.2.</span> <span class="toc-text">实例化委托</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E5%A7%94%E6%89%98%E7%B1%BB%E5%9E%8B"><span class="toc-number">28.3.</span> <span class="toc-text">常用的委托类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%92%AD%E5%A7%94%E6%89%98%EF%BC%88%E5%90%88%E5%B9%B6%E5%A7%94%E6%89%98%EF%BC%89"><span class="toc-number">28.4.</span> <span class="toc-text">多播委托（合并委托）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSharp-%E4%BA%8B%E4%BB%B6"><span class="toc-number">29.</span> <span class="toc-text">CSharp 事件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">29.1.</span> <span class="toc-text">注意点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSharp-%E9%9B%86%E5%90%88"><span class="toc-number">30.</span> <span class="toc-text">CSharp 集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayList%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84"><span class="toc-number">30.1.</span> <span class="toc-text">ArrayList动态数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hashtable%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">30.2.</span> <span class="toc-text">Hashtable哈希表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SortedList%E6%8E%92%E5%BA%8F%E5%88%97%E8%A1%A8"><span class="toc-number">30.3.</span> <span class="toc-text">SortedList排序列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Stack%E5%A0%86%E6%A0%88"><span class="toc-number">30.4.</span> <span class="toc-text">Stack堆栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Queue%E9%98%9F%E5%88%97"><span class="toc-number">30.5.</span> <span class="toc-text">Queue队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BitArray%E7%82%B9%E9%98%B5%E5%88%97"><span class="toc-number">30.6.</span> <span class="toc-text">BitArray点阵列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConcurrentQueue%E5%B9%B6%E5%8F%91%E9%98%9F%E5%88%97"><span class="toc-number">30.7.</span> <span class="toc-text">ConcurrentQueue并发队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E7%9B%98%E7%82%B9"><span class="toc-number">30.7.1.</span> <span class="toc-text">属性盘点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9B%98%E7%82%B9"><span class="toc-number">30.7.2.</span> <span class="toc-text">方法盘点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E9%9B%86%E5%90%88BlockingCollection"><span class="toc-number">30.8.</span> <span class="toc-text">阻塞集合BlockingCollection</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95"><span class="toc-number">30.8.1.</span> <span class="toc-text">主要方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="toc-number">30.8.1.1.</span> <span class="toc-text">添加元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%96%E5%87%BA%E5%85%83%E7%B4%A0"><span class="toc-number">30.8.1.2.</span> <span class="toc-text">取出元素</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#GetConsumingEnumerable"><span class="toc-number">30.8.1.2.1.</span> <span class="toc-text">GetConsumingEnumerable</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%9D%E8%AF%95%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="toc-number">30.8.1.3.</span> <span class="toc-text">尝试添加元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%9D%E8%AF%95%E5%8F%96%E5%87%BA%E5%85%83%E7%B4%A0"><span class="toc-number">30.8.1.4.</span> <span class="toc-text">尝试取出元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E6%88%90%E6%B7%BB%E5%8A%A0"><span class="toc-number">30.8.1.5.</span> <span class="toc-text">完成添加</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E5%B7%B2%E5%AE%8C%E6%88%90"><span class="toc-number">30.8.1.6.</span> <span class="toc-text">检查是否已完成</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSharp%E6%89%80%E6%9C%89%E5%AE%B9%E5%99%A8%E6%80%BB%E7%BB%93"><span class="toc-number">31.</span> <span class="toc-text">CSharp所有容器总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#IEnumerable%E6%8E%A5%E5%8F%A3"><span class="toc-number">31.1.</span> <span class="toc-text">IEnumerable接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="toc-number">31.1.1.</span> <span class="toc-text">遍历方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSharp-%E6%B3%9B%E5%9E%8B"><span class="toc-number">32.</span> <span class="toc-text">CSharp 泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-number">32.1.</span> <span class="toc-text">泛型类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">32.2.</span> <span class="toc-text">泛型方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E5%A7%94%E6%89%98"><span class="toc-number">32.3.</span> <span class="toc-text">泛型委托</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSharp-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0-%E6%96%B9%E6%B3%95"><span class="toc-number">33.</span> <span class="toc-text">CSharp 匿名函数&#x2F;方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CSharp-new-Action%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%9A%E4%B9%89%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="toc-number">33.0.1.</span> <span class="toc-text">CSharp new Action的方式定义匿名函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSharp-%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E4%B8%8Eunsafe"><span class="toc-number">34.</span> <span class="toc-text">CSharp 指针变量与unsafe</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F"><span class="toc-number">34.1.</span> <span class="toc-text">指针变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E4%B8%8D%E5%AE%89%E5%85%A8%E4%BB%A3%E7%A0%81"><span class="toc-number">34.2.</span> <span class="toc-text">编译不安全代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSharp-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">35.</span> <span class="toc-text">CSharp 多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">35.1.</span> <span class="toc-text">线程生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E7%BA%BF%E7%A8%8B"><span class="toc-number">35.2.</span> <span class="toc-text">主线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Thread-%E7%B1%BB"><span class="toc-number">35.3.</span> <span class="toc-text">Thread 类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">35.4.</span> <span class="toc-text">创建线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSharp-BackgroundWorker"><span class="toc-number">35.5.</span> <span class="toc-text">CSharp BackgroundWorker</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSharp-%E8%8E%B7%E5%8F%96%E7%BA%BF%E7%A8%8Bid"><span class="toc-number">35.6.</span> <span class="toc-text">CSharp 获取线程id</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSharp-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">35.7.</span> <span class="toc-text">CSharp 异步编程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E6%97%B6%E6%9C%BA"><span class="toc-number">35.7.1.</span> <span class="toc-text">线程切换时机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">35.7.2.</span> <span class="toc-text">同步上下文的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ConfigureAwait"><span class="toc-number">35.7.2.1.</span> <span class="toc-text">ConfigureAwait</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%90%8C%E6%AD%A5%E4%B8%8A%E4%B8%8B%E6%96%87%E5%AF%BC%E8%87%B4%E7%9A%84%E6%AD%BB%E9%94%81"><span class="toc-number">35.7.2.2.</span> <span class="toc-text">关于同步上下文导致的死锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TaskScheduler"><span class="toc-number">35.7.2.3.</span> <span class="toc-text">TaskScheduler</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8async%E6%96%B9%E6%B3%95"><span class="toc-number">35.7.3.</span> <span class="toc-text">直接调用async方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9B%B8%E5%85%B3"><span class="toc-number">35.7.4.</span> <span class="toc-text">返回值相关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%E7%9B%B8%E5%85%B3"><span class="toc-number">35.7.5.</span> <span class="toc-text">原理相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#async-void%E7%90%86%E8%A7%A3"><span class="toc-number">35.7.5.1.</span> <span class="toc-text">async void理解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%AE%8C%E6%88%90%E5%90%8E%E6%89%A7%E8%A1%8C%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">35.7.6.</span> <span class="toc-text">异步完成后执行的另一种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E6%9F%93%E6%80%A7"><span class="toc-number">35.7.7.</span> <span class="toc-text">传染性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E6%8A%80%E5%B7%A7"><span class="toc-number">35.7.8.</span> <span class="toc-text">同步异步技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1"><span class="toc-number">35.7.8.1.</span> <span class="toc-text">如何创建异步任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%90%8C%E6%97%B6%E5%BC%80%E5%90%AF%E5%A4%9A%E4%B8%AA%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1"><span class="toc-number">35.7.8.2.</span> <span class="toc-text">如何同时开启多个异步任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%8F%96%E6%B6%88%E4%BB%BB%E5%8A%A1"><span class="toc-number">35.7.8.3.</span> <span class="toc-text">如何取消任务</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#CancellationToken-CancellationTokenSource"><span class="toc-number">35.7.8.3.1.</span> <span class="toc-text">CancellationToken&#x2F;CancellationTokenSource</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E8%B6%85%E6%97%B6%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">35.7.8.4.</span> <span class="toc-text">任务超时如何实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Channel%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-number">35.7.8.5.</span> <span class="toc-text">使用Channel实现异步任务之间的通信</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Chanel"><span class="toc-number">35.7.8.5.1.</span> <span class="toc-text">Chanel</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA"><span class="toc-number">35.7.8.5.1.1.</span> <span class="toc-text">创建</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C"><span class="toc-number">35.7.8.5.1.2.</span> <span class="toc-text">读写操作</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E5%AE%8C%E6%88%90%E9%80%9A%E7%9F%A5"><span class="toc-number">35.7.8.5.1.3.</span> <span class="toc-text">生产完成通知</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-number">35.7.8.5.1.4.</span> <span class="toc-text">案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E4%B8%AD%E6%B1%87%E6%8A%A5%E8%BF%9B%E5%BA%A6"><span class="toc-number">35.7.8.6.</span> <span class="toc-text">在异步任务中汇报进度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E4%B8%AD%E8%B0%83%E7%94%A8%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="toc-number">35.7.8.7.</span> <span class="toc-text">如何在同步方法中调用异步方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%BB%88%E6%AD%A2%E4%B8%80%E4%B8%AA%E5%90%8C%E6%AD%A5%E4%BB%BB%E5%8A%A1"><span class="toc-number">35.7.8.7.1.</span> <span class="toc-text">如何终止一个同步任务</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Task-Run%E5%92%8Casync%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">35.7.9.</span> <span class="toc-text">Task.Run和async方法的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TaskCompletionSource%E9%AB%98%E7%BA%A7%E5%BC%82%E6%AD%A5"><span class="toc-number">35.7.10.</span> <span class="toc-text">TaskCompletionSource高级异步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wpf%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D"><span class="toc-number">35.7.11.</span> <span class="toc-text">wpf异步编程的死锁避免</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E8%BF%9B%E5%BA%A6%E9%80%9A%E7%9F%A5"><span class="toc-number">35.8.</span> <span class="toc-text">多线程环境下的进度通知</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Invoke%E4%B8%8EBeginInvoke"><span class="toc-number">35.9.</span> <span class="toc-text">Invoke与BeginInvoke</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Delegate-Invoke"><span class="toc-number">35.9.1.</span> <span class="toc-text">Delegate.Invoke</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Delegate-BeginInvoke"><span class="toc-number">35.9.2.</span> <span class="toc-text">Delegate.BeginInvoke</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSharp-Task"><span class="toc-number">35.10.</span> <span class="toc-text">CSharp Task</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Task%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95%E7%9B%98%E7%82%B9"><span class="toc-number">35.10.1.</span> <span class="toc-text">Task相关方法盘点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E6%9B%B4%E7%BB%86%E7%B2%92%E5%BA%A6%E7%9A%84%E6%8E%A7%E5%88%B6"><span class="toc-number">35.10.2.</span> <span class="toc-text">需要更细粒度的控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Task-Delay"><span class="toc-number">35.10.3.</span> <span class="toc-text">Task.Delay</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Parallel-For"><span class="toc-number">35.11.</span> <span class="toc-text">Parallel.For</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSharp-%E5%BC%82%E6%AD%A5%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">35.12.</span> <span class="toc-text">CSharp 异步定时器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">35.13.</span> <span class="toc-text">线程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AutoResetEvent"><span class="toc-number">35.13.1.</span> <span class="toc-text">AutoResetEvent</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSharp%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">36.</span> <span class="toc-text">CSharp线程同步机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CSharp%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-number">36.1.</span> <span class="toc-text">CSharp读写锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ReaderWriterLockSlim"><span class="toc-number">36.1.1.</span> <span class="toc-text">ReaderWriterLockSlim</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReaderWriterLock"><span class="toc-number">36.1.2.</span> <span class="toc-text">ReaderWriterLock</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSharp%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">36.2.</span> <span class="toc-text">CSharp信号量</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSharp-%E6%89%8B%E5%8A%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">37.</span> <span class="toc-text">CSharp 手动垃圾回收</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSharp%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">38.</span> <span class="toc-text">CSharp中的代码块</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#visual-studio%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9B%B8%E5%85%B3"><span class="toc-number">39.</span> <span class="toc-text">visual studio开发环境相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%98%E6%96%B9%E7%BB%84%E4%BB%B6"><span class="toc-number">39.1.</span> <span class="toc-text">官方组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E6%9E%84%E6%8A%80%E5%B7%A7%E7%9B%98%E7%82%B9"><span class="toc-number">39.2.</span> <span class="toc-text">重构技巧盘点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="toc-number">39.2.1.</span> <span class="toc-text">快捷键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E8%8F%9C%E5%8D%95%E5%A6%99%E7%94%A8"><span class="toc-number">39.2.2.</span> <span class="toc-text">上下文菜单妙用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-number">39.2.2.1.</span> <span class="toc-text">数值进制转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E5%85%A5%E5%B8%B8%E9%87%8F-%E5%BC%95%E5%85%A5%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F-%E5%BC%95%E5%85%A5%E5%8F%82%E6%95%B0"><span class="toc-number">39.2.2.2.</span> <span class="toc-text">引入常量&#x2F;引入局部变量&#x2F;引入参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%90%E5%8F%96%E6%8E%A5%E5%8F%A3-%E5%9F%BA%E7%B1%BB"><span class="toc-number">39.2.2.3.</span> <span class="toc-text">提取接口&#x2F;基类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%80%A7%E9%BB%8F%E8%B4%B4"><span class="toc-number">39.2.3.</span> <span class="toc-text">选择性黏贴</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E7%BB%93%E6%9E%84"><span class="toc-number">39.2.4.</span> <span class="toc-text">显示结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%BB%BA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%99%A8%E8%A7%86%E5%9B%BE"><span class="toc-number">39.2.5.</span> <span class="toc-text">新建解决方案资源管理器视图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E4%BB%B6%E7%9B%B8%E5%85%B3"><span class="toc-number">39.3.</span> <span class="toc-text">插件相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E6%98%93%E6%8F%92%E4%BB%B6"><span class="toc-number">39.3.1.</span> <span class="toc-text">简易插件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CodeRush"><span class="toc-number">39.3.2.</span> <span class="toc-text">CodeRush</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CodeGeeX"><span class="toc-number">39.3.3.</span> <span class="toc-text">CodeGeeX</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E5%AD%98%E7%9A%84%E6%97%B6%E5%80%99%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-number">39.3.4.</span> <span class="toc-text">保存的时候格式化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E9%94%AE%E5%B1%95%E5%BC%80%E6%8E%92%E5%88%97%E4%BB%A3%E7%A0%81"><span class="toc-number">39.3.5.</span> <span class="toc-text">一键展开排列代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#xaml%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-number">39.3.6.</span> <span class="toc-text">xaml代码格式化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BF%BB%E8%AF%91%E6%8F%92%E4%BB%B6"><span class="toc-number">39.3.7.</span> <span class="toc-text">翻译插件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#windows%E4%B8%8Bvs%E7%9A%84NuGet%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">39.4.</span> <span class="toc-text">windows下vs的NuGet包管理器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#windows%E4%B8%8B%E7%9A%84winget"><span class="toc-number">39.5.</span> <span class="toc-text">windows下的winget</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#win%E5%95%86%E5%BA%97%E4%B8%8B%E8%BD%BD%E6%96%B9%E5%BC%8F"><span class="toc-number">39.5.1.</span> <span class="toc-text">win商店下载方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GitHub%E4%B8%8B%E8%BD%BD%E6%96%B9%E5%BC%8F"><span class="toc-number">39.5.2.</span> <span class="toc-text">GitHub下载方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vs%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE"><span class="toc-number">39.6.</span> <span class="toc-text">vs相关设置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vs%E7%94%9F%E6%88%90%E6%B3%A8%E9%87%8A"><span class="toc-number">39.6.1.</span> <span class="toc-text">vs生成注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vs%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%98%BE%E7%A4%BA"><span class="toc-number">39.6.2.</span> <span class="toc-text">vs函数参数数据类型显示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vs%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95%E7%9A%84%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="toc-number">39.6.3.</span> <span class="toc-text">vs添加方法的引用计数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="toc-number">39.7.</span> <span class="toc-text">重要的快捷键</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84"><span class="toc-number">40.</span> <span class="toc-text">项目结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#winForm%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84"><span class="toc-number">40.1.</span> <span class="toc-text">winForm项目结构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSharp%E8%AF%AD%E6%B3%95%E4%B8%BB%E8%A6%81%E7%89%88%E6%9C%AC%E8%BF%AD%E4%BB%A3"><span class="toc-number">41.</span> <span class="toc-text">CSharp语法主要版本迭代</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%8EC-%E7%9A%84%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB"><span class="toc-number">42.</span> <span class="toc-text">与C++的相互调用关系</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E6%89%98%E7%AE%A1%E6%96%B9%E5%BC%8F%E8%B0%83%E7%94%A8%EF%BC%88P-Invoke%EF%BC%89"><span class="toc-number">42.1.</span> <span class="toc-text">非托管方式调用（P&#x2F;Invoke）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">42.1.1.</span> <span class="toc-text">数据类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">42.1.1.1.</span> <span class="toc-text">基本类型转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E6%9E%9A%E4%B8%BE"><span class="toc-number">42.1.1.2.</span> <span class="toc-text">结构体与枚举</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8B"><span class="toc-number">42.1.1.3.</span> <span class="toc-text">特殊类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E5%AE%B9%E5%99%A8"><span class="toc-number">42.1.1.4.</span> <span class="toc-text">传递容器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E6%95%B0%E7%BB%84%E4%BC%A0%E9%80%92%E5%AE%B9%E5%99%A8%E5%86%85%E5%AE%B9"><span class="toc-number">42.1.1.4.1.</span> <span class="toc-text">通过数组传递容器内容</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%9D%97%E4%BC%A0%E9%80%92%E5%86%85%E5%AE%B9"><span class="toc-number">42.1.1.4.2.</span> <span class="toc-text">通过连续内存块传递内容</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">42.1.1.4.3.</span> <span class="toc-text">使用自定义数据结构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">42.1.2.</span> <span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E7%AE%A1%E7%90%86"><span class="toc-number">42.1.2.1.</span> <span class="toc-text">手动管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E7%AE%A1%E7%90%86"><span class="toc-number">42.1.2.2.</span> <span class="toc-text">自动管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#COM%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">42.1.2.3.</span> <span class="toc-text">COM接口与智能指针</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">42.1.3.</span> <span class="toc-text">最佳实践</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">42.1.4.</span> <span class="toc-text">原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7%E7%94%9F%E6%88%90P-Invoke%E4%BB%A3%E7%A0%81"><span class="toc-number">42.2.</span> <span class="toc-text">使用自动化工具生成P&#x2F;Invoke代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SWIG"><span class="toc-number">42.2.1.</span> <span class="toc-text">SWIG</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ClangSharp-PInvokeGenerator"><span class="toc-number">42.2.2.</span> <span class="toc-text">ClangSharp.PInvokeGenerator</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%98%E7%AE%A1%E6%96%B9%E5%BC%8F%E8%B0%83%E7%94%A8%EF%BC%88CLR-C-CLI%EF%BC%89"><span class="toc-number">42.3.</span> <span class="toc-text">托管方式调用（CLR&#x2F;C++&#x2F;CLI）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSharp-winform"><span class="toc-number">43.</span> <span class="toc-text">CSharp winform</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E6%8E%A7%E4%BB%B6Panel"><span class="toc-number">43.1.</span> <span class="toc-text">容器控件Panel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E6%A0%87%E7%AD%BE%E6%8E%A7%E4%BB%B6%EF%BC%88Lable%EF%BC%89"><span class="toc-number">43.2.</span> <span class="toc-text">文本标签控件（Lable）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8B%E6%8B%89%E7%BB%84%E5%90%88%E6%A1%86%E6%8E%A7%E4%BB%B6%EF%BC%88ComboBox%EF%BC%89"><span class="toc-number">43.3.</span> <span class="toc-text">下拉组合框控件（ComboBox）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%89%E9%92%AE%E6%8E%A7%E4%BB%B6%EF%BC%88Button%EF%BC%89"><span class="toc-number">43.4.</span> <span class="toc-text">按钮控件（Button）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E6%A1%86%E6%8E%A7%E4%BB%B6%EF%BC%88TextBox%EF%BC%89"><span class="toc-number">43.5.</span> <span class="toc-text">文本框控件（TextBox）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSharp%E4%B8%AD%E7%9A%84%E7%AA%97%E4%BD%93%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8"><span class="toc-number">43.6.</span> <span class="toc-text">CSharp中的窗体事件驱动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSharp%E7%AA%97%E5%8F%A3ui%E7%BA%BF%E7%A8%8B%E9%98%B2%E5%A0%B5%E5%A1%9E"><span class="toc-number">43.7.</span> <span class="toc-text">CSharp窗口ui线程防堵塞</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Invoke-BeginInvoke"><span class="toc-number">43.7.1.</span> <span class="toc-text">Invoke&#x2F;BeginInvoke</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Control-Invoke"><span class="toc-number">43.7.1.1.</span> <span class="toc-text">Control.Invoke</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E6%8E%A7%E4%BB%B6"><span class="toc-number">43.8.</span> <span class="toc-text">隐式控件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E7%BB%84%E4%BB%B6%EF%BC%88SerialPort%EF%BC%89"><span class="toc-number">43.8.1.</span> <span class="toc-text">串口组件（SerialPort）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%BE%91%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1%E9%80%BB%E8%BE%91"><span class="toc-number">43.8.1.1.</span> <span class="toc-text">编辑串口通信逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%80%E5%85%B3%E4%B8%B2%E5%8F%A3"><span class="toc-number">43.8.1.1.1.</span> <span class="toc-text">开关串口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%E4%B8%B2%E5%8F%A3"><span class="toc-number">43.8.1.1.2.</span> <span class="toc-text">发送和接收串口</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E5%8F%91%E9%80%81"><span class="toc-number">43.8.1.1.2.1.</span> <span class="toc-text">串口发送</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E6%8E%A5%E5%8F%97"><span class="toc-number">43.8.1.1.2.2.</span> <span class="toc-text">串口接受</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSharp-%E7%BB%98%E5%9B%BE"><span class="toc-number">43.9.</span> <span class="toc-text">CSharp 绘图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96Graphics%E5%AF%B9%E8%B1%A1"><span class="toc-number">43.9.0.1.</span> <span class="toc-text">获取Graphics对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8%E7%8E%B0%E6%9C%89%E6%8E%A7%E4%BB%B6%E4%B8%8A%E8%BF%9B%E8%A1%8C%E7%BB%98%E5%9B%BE"><span class="toc-number">43.9.1.</span> <span class="toc-text">如何在现有控件上进行绘图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSharp-%E7%AA%97%E4%BD%93%E7%9B%B8%E5%85%B3%E7%9A%84%E4%BA%8B%E4%BB%B6"><span class="toc-number">43.9.2.</span> <span class="toc-text">CSharp 窗体相关的事件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSharp-DLL%E5%BC%80%E5%8F%91"><span class="toc-number">44.</span> <span class="toc-text">CSharp DLL开发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BADLL"><span class="toc-number">44.1.</span> <span class="toc-text">创建DLL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSharp%E4%B8%AD%E8%B0%83%E7%94%A8%E8%AF%A5DLL"><span class="toc-number">44.2.</span> <span class="toc-text">CSharp中调用该DLL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DLL%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AA%97%E5%8F%A3"><span class="toc-number">44.3.</span> <span class="toc-text">DLL中自定义窗口</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#NuGet%E7%A8%8B%E5%BA%8F%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">45.</span> <span class="toc-text">NuGet程序包管理器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#NuGet%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">45.1.</span> <span class="toc-text">NuGet使用方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#NuGet-CLI"><span class="toc-number">45.1.1.</span> <span class="toc-text">NuGet CLI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VS%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2"><span class="toc-number">45.1.2.</span> <span class="toc-text">VS图形界面</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSharp-%E5%90%88%E5%B9%B6%E7%A8%8B%E5%BA%8F%E9%9B%86"><span class="toc-number">46.</span> <span class="toc-text">CSharp 合并程序集</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ILRepack"><span class="toc-number">46.1.</span> <span class="toc-text">ILRepack</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSharp-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">47.</span> <span class="toc-text">CSharp 单元测试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%9F"><span class="toc-number">47.1.</span> <span class="toc-text">为什么要使用单元测试？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mock%E6%8A%80%E6%9C%AF"><span class="toc-number">47.2.</span> <span class="toc-text">mock技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">47.3.</span> <span class="toc-text">自动生成单元测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8C%85%E5%92%8C%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">47.3.1.</span> <span class="toc-text">1. 包和命名空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%94%AF%E6%8C%81"><span class="toc-number">47.3.2.</span> <span class="toc-text">2. 跨平台支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%8E-NET-Core-%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-number">47.3.3.</span> <span class="toc-text">3. 与 .NET Core 的兼容性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-NuGet-%E5%8C%85%E7%AE%A1%E7%90%86"><span class="toc-number">47.3.4.</span> <span class="toc-text">4. NuGet 包管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%89%B9%E6%80%A7-Attributes"><span class="toc-number">47.3.5.</span> <span class="toc-text">5. 特性 (Attributes)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%94%B9%E8%BF%9B%E7%9A%84-TestContext"><span class="toc-number">47.3.6.</span> <span class="toc-text">6. 改进的 TestContext</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E9%85%8D%E7%BD%AE%E5%92%8C%E8%BF%90%E8%A1%8C%E8%AE%BE%E7%BD%AE"><span class="toc-number">47.3.7.</span> <span class="toc-text">7. 配置和运行设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E9%9B%86%E6%88%90%E5%92%8C%E6%89%A9%E5%B1%95"><span class="toc-number">47.3.8.</span> <span class="toc-text">8. 集成和扩展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">47.3.9.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9B%B8%E5%85%B3"><span class="toc-number">47.3.10.</span> <span class="toc-text">异常相关</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSharp-XML%E6%93%8D%E4%BD%9C"><span class="toc-number">48.</span> <span class="toc-text">CSharp XML操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#XmlSerializer"><span class="toc-number">48.1.</span> <span class="toc-text">XmlSerializer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSharp-%E5%8F%8D%E5%B0%84"><span class="toc-number">49.</span> <span class="toc-text">CSharp 反射</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8F%8D%E5%B0%84"><span class="toc-number">49.1.</span> <span class="toc-text">类反射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%8D%E5%B0%84"><span class="toc-number">49.2.</span> <span class="toc-text">函数反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0"><span class="toc-number">49.2.1.</span> <span class="toc-text">普通函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-1"><span class="toc-number">49.2.2.</span> <span class="toc-text">构造函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E5%8F%8D%E5%B0%84"><span class="toc-number">49.3.</span> <span class="toc-text">属性反射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E4%B8%8E%E7%89%B9%E6%80%A7%E7%BB%93%E5%90%88"><span class="toc-number">49.4.</span> <span class="toc-text">反射与特性结合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-1"><span class="toc-number">49.5.</span> <span class="toc-text">案例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%BD%AE%E7%A9%BA%E6%A1%88%E4%BE%8B"><span class="toc-number">49.6.</span> <span class="toc-text">反射置空案例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E7%94%9F%E6%88%90"><span class="toc-number">49.7.</span> <span class="toc-text">动态类型生成</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSharp-%E5%85%83%E7%BB%84"><span class="toc-number">50.</span> <span class="toc-text">CSharp 元组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">50.1.</span> <span class="toc-text">使用场景</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSharp-dump"><span class="toc-number">51.</span> <span class="toc-text">CSharp dump</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E5%85%B6%E4%BB%96-MiniDump-%E9%80%89%E9%A1%B9"><span class="toc-number">51.1.</span> <span class="toc-text">常用的其他 MiniDump 选项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E7%9B%98%E7%82%B9"><span class="toc-number">51.1.1.</span> <span class="toc-text">组合盘点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E6%96%B9%E5%BC%8F"><span class="toc-number">51.2.</span> <span class="toc-text">分析方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#visual-studio"><span class="toc-number">51.2.1.</span> <span class="toc-text">visual studio</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dotnet-dump"><span class="toc-number">51.2.2.</span> <span class="toc-text">dotnet-dump</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E6%8E%92%E6%9F%A5"><span class="toc-number">51.3.</span> <span class="toc-text">死锁排查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU%E5%8D%A0%E7%94%A8%E7%8E%87%E6%8E%92%E6%9F%A5"><span class="toc-number">51.4.</span> <span class="toc-text">CPU占用率排查</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSharp-%E6%8B%93%E5%B1%95%E6%96%B9%E6%B3%95"><span class="toc-number">52.</span> <span class="toc-text">CSharp 拓展方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95%E7%9A%84%E5%85%B3%E9%94%AE%E7%82%B9"><span class="toc-number">52.1.</span> <span class="toc-text">实现扩展方法的关键点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-2"><span class="toc-number">52.2.</span> <span class="toc-text">案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">52.2.1.</span> <span class="toc-text">工作原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSharp-LINQ"><span class="toc-number">53.</span> <span class="toc-text">CSharp LINQ</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">53.1.</span> <span class="toc-text">查询表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-number">53.2.</span> <span class="toc-text">链式编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E4%BE%9B%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E7%9B%98%E7%82%B9"><span class="toc-number">53.3.</span> <span class="toc-text">提供的高阶函数盘点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSharp-%E6%96%AD%E8%A8%80"><span class="toc-number">54.</span> <span class="toc-text">CSharp 断言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSharp-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1"><span class="toc-number">55.</span> <span class="toc-text">CSharp 网络通信</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSharp-%E8%AE%A1%E6%97%B6"><span class="toc-number">56.</span> <span class="toc-text">CSharp 计时</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Stopwatch"><span class="toc-number">56.1.</span> <span class="toc-text">Stopwatch</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">56.1.1.</span> <span class="toc-text">基本用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%AB%98%E6%95%88%E7%9A%84Stopwatch%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">56.1.2.</span> <span class="toc-text">最高效的Stopwatch使用方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSharp-%E8%BD%AC%E6%8D%A2%E5%99%A8"><span class="toc-number">57.</span> <span class="toc-text">CSharp 转换器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Converter"><span class="toc-number">57.1.</span> <span class="toc-text">Converter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BitConverter"><span class="toc-number">57.2.</span> <span class="toc-text">BitConverter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Encoding"><span class="toc-number">57.3.</span> <span class="toc-text">Encoding</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSharp-Json%E5%A4%84%E7%90%86"><span class="toc-number">58.</span> <span class="toc-text">CSharp Json处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#System-Text-Json"><span class="toc-number">58.1.</span> <span class="toc-text">System.Text.Json</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E5%AF%B9%E8%B1%A1%E8%BD%AC-JSON%EF%BC%89"><span class="toc-number">58.1.1.</span> <span class="toc-text">序列化（对象转 JSON）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88JSON-%E8%BD%AC%E5%AF%B9%E8%B1%A1%EF%BC%89"><span class="toc-number">58.1.2.</span> <span class="toc-text">反序列化（JSON 转对象）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B"><span class="toc-number">58.1.3.</span> <span class="toc-text">处理复杂类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%87json%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">58.1.4.</span> <span class="toc-text">中文json序列化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Newtonsoft-Json"><span class="toc-number">58.2.</span> <span class="toc-text">Newtonsoft.Json</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E5%AF%B9%E8%B1%A1%E8%BD%AC-JSON%EF%BC%89-1"><span class="toc-number">58.2.1.</span> <span class="toc-text">序列化（对象转 JSON）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88JSON-%E8%BD%AC%E5%AF%B9%E8%B1%A1%EF%BC%89-1"><span class="toc-number">58.2.2.</span> <span class="toc-text">反序列化（JSON 转对象）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B-1"><span class="toc-number">58.2.3.</span> <span class="toc-text">处理复杂类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LINQ-to-JSON"><span class="toc-number">58.2.4.</span> <span class="toc-text">LINQ to JSON</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E7%9B%98%E7%82%B9-1"><span class="toc-number">58.2.5.</span> <span class="toc-text">属性盘点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JsonProperty"><span class="toc-number">58.2.5.1.</span> <span class="toc-text">JsonProperty</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JsonIgnore"><span class="toc-number">58.2.5.2.</span> <span class="toc-text">JsonIgnore</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JsonConverter"><span class="toc-number">58.2.5.3.</span> <span class="toc-text">JsonConverter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JsonObject"><span class="toc-number">58.2.5.4.</span> <span class="toc-text">JsonObject</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">58.2.5.5.</span> <span class="toc-text">其他</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E6%A1%88%E4%BE%8B"><span class="toc-number">58.2.6.</span> <span class="toc-text">复杂案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSharp-Entity-Framework"><span class="toc-number">59.</span> <span class="toc-text">CSharp Entity Framework</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">59.1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F"><span class="toc-number">59.1.1.</span> <span class="toc-text">开发模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EF%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">59.2.</span> <span class="toc-text">EF注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85"><span class="toc-number">59.3.</span> <span class="toc-text">安装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%90%E4%BE%9B%E7%A8%8B%E5%BA%8F"><span class="toc-number">59.3.1.</span> <span class="toc-text">数据库提供程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7"><span class="toc-number">59.3.2.</span> <span class="toc-text">命令行工具</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">59.4.</span> <span class="toc-text">数据库上下文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB"><span class="toc-number">59.5.</span> <span class="toc-text">数据迁移</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%81%E7%A7%BB"><span class="toc-number">59.5.1.</span> <span class="toc-text">迁移</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8dotnet-ef"><span class="toc-number">59.5.1.1.</span> <span class="toc-text">使用dotnet-ef</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8vs%E8%87%AA%E5%B8%A6%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E6%8E%A7%E5%88%B6%E5%8F%B0"><span class="toc-number">59.5.1.2.</span> <span class="toc-text">使用vs自带的程序包管理器控制台</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EntityFramework%E7%9A%84%E8%87%AA%E5%8A%A8%E8%BF%81%E7%A7%BB"><span class="toc-number">59.5.2.</span> <span class="toc-text">EntityFramework的自动迁移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%BD%AE%E6%89%80%E6%9C%89%E8%BF%81%E7%A7%BB"><span class="toc-number">59.5.3.</span> <span class="toc-text">重置所有迁移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%90%91%E5%B7%A5%E7%A8%8B"><span class="toc-number">59.5.4.</span> <span class="toc-text">反向工程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EF-Core%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">59.6.</span> <span class="toc-text">EF Core使用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E5%8F%82%E8%80%83"><span class="toc-number">59.6.1.</span> <span class="toc-text">案例参考</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%85%8D%E7%BD%AE"><span class="toc-number">59.6.2.</span> <span class="toc-text">连接字符串配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EF%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">59.7.</span> <span class="toc-text">EF使用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2"><span class="toc-number">59.7.1.</span> <span class="toc-text">查询</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E5%85%A8%E8%A1%A8%E6%95%B0%E6%8D%AE"><span class="toc-number">59.7.1.1.</span> <span class="toc-text">查询全表数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E5%8D%95%E4%B8%AA%E6%95%B0%E6%8D%AE"><span class="toc-number">59.7.1.2.</span> <span class="toc-text">查询单个数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E9%83%A8%E5%88%86%E5%AD%97%E6%AE%B5"><span class="toc-number">59.7.1.3.</span> <span class="toc-text">查询部分字段</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A0"><span class="toc-number">59.7.2.</span> <span class="toc-text">增加</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4"><span class="toc-number">59.7.3.</span> <span class="toc-text">删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9"><span class="toc-number">59.7.4.</span> <span class="toc-text">修改</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">60.</span> <span class="toc-text">延迟实例化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-1"><span class="toc-number">60.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">60.2.</span> <span class="toc-text">缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lazy%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">60.3.</span> <span class="toc-text">Lazy的线程安全模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">60.4.</span> <span class="toc-text">C++中的实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSharp-%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-number">61.</span> <span class="toc-text">CSharp 命名规范</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-number">61.1.</span> <span class="toc-text">变量命名规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E6%83%85%E5%BD%A2"><span class="toc-number">61.1.1.</span> <span class="toc-text">特殊情形</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-number">61.2.</span> <span class="toc-text">方法命名规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="toc-number">61.2.1.</span> <span class="toc-text">异步方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E7%90%86%E9%80%89%E6%8B%A9%E5%8D%95%E8%AF%8D"><span class="toc-number">61.3.</span> <span class="toc-text">合理选择单词</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E4%B8%8E%E6%97%B6%E6%80%81"><span class="toc-number">61.4.</span> <span class="toc-text">语法与时态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E5%A4%9A%E7%BB%86%E8%8A%82"><span class="toc-number">61.5.</span> <span class="toc-text">更多细节</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#nuget%E5%8C%85%E7%9B%98%E7%82%B9"><span class="toc-number">62.</span> <span class="toc-text">nuget包盘点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#SkiaSharp%E7%BB%98%E5%9B%BE"><span class="toc-number">62.1.</span> <span class="toc-text">SkiaSharp绘图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E5%A4%9A%E6%9D%A1%E6%9B%B2%E7%BA%BF%E5%9B%BE"><span class="toc-number">62.1.1.</span> <span class="toc-text">绘制多条曲线图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dynamic-Expresso"><span class="toc-number">62.2.</span> <span class="toc-text">Dynamic Expresso</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CsvHelper"><span class="toc-number">62.3.</span> <span class="toc-text">CsvHelper</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%96%B9%E5%BC%8F"><span class="toc-number">62.3.1.</span> <span class="toc-text">读取方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E5%85%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">62.3.2.</span> <span class="toc-text">写入方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%96%B9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%BA%93"><span class="toc-number">62.4.</span> <span class="toc-text">第三方数据结构库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C5"><span class="toc-number">62.4.1.</span> <span class="toc-text">C5</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%E5%AE%B9%E5%99%A8%E5%BA%93"><span class="toc-number">62.5.</span> <span class="toc-text">控制反转容器库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%9C%BA%E5%BA%93"><span class="toc-number">62.6.</span> <span class="toc-text">状态机库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#stateless"><span class="toc-number">62.6.1.</span> <span class="toc-text">stateless</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">62.6.1.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8"><span class="toc-number">62.6.1.2.</span> <span class="toc-text">如何使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E6%A1%88%E4%BE%8B"><span class="toc-number">62.6.1.3.</span> <span class="toc-text">完整案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%98%A0%E5%B0%84%E5%BA%93"><span class="toc-number">62.7.</span> <span class="toc-text">自动映射库</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSharp-%E4%B8%80%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84%E6%8E%A7%E4%BB%B6%E7%9B%98%E7%82%B9"><span class="toc-number">63.</span> <span class="toc-text">CSharp 一些好用的控件盘点</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/%E5%B7%A5%E4%B8%9A%E7%9B%B8%E5%85%B3/" title="工业相关">工业相关</a><time datetime="2025-02-14T03:04:40.761Z" title="发表于 2025-02-14 11:04:40">2025-02-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/%E8%AE%A1%E7%BB%84/" title="计算机组成原理">计算机组成原理</a><time datetime="2024-12-16T01:38:01.470Z" title="发表于 2024-12-16 09:38:01">2024-12-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/" title="网络架构">网络架构</a><time datetime="2024-11-18T06:17:01.282Z" title="发表于 2024-11-18 14:17:01">2024-11-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/avalonia/" title="avalonia">avalonia</a><time datetime="2024-09-11T14:51:13.000Z" title="发表于 2024-09-11 22:51:13">2024-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/%E8%A7%86%E9%A2%91%E6%95%88%E6%9E%9C/" title="PR">PR</a><time datetime="2024-07-18T07:06:08.330Z" title="发表于 2024-07-18 15:06:08">2024-07-18</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2025 By <a class="footer-bar-link" href="/" title="ZEROKO14" target="_blank">ZEROKO14</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu"></a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">60</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">50</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">6</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size: 0.88rem;">C#<sup>2</sup></a><a href="/tags/C/" style="font-size: 0.88rem;">C++<sup>5</sup></a><a href="/tags/CSS/" style="font-size: 0.88rem;">CSS<sup>1</sup></a><a href="/tags/CSharp/" style="font-size: 0.88rem;">CSharp<sup>1</sup></a><a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 0.88rem;">C语言<sup>1</sup></a><a href="/tags/FPS/" style="font-size: 0.88rem;">FPS<sup>1</sup></a><a href="/tags/HTML/" style="font-size: 0.88rem;">HTML<sup>1</sup></a><a href="/tags/JavaScript/" style="font-size: 0.88rem;">JavaScript<sup>1</sup></a><a href="/tags/MFC/" style="font-size: 0.88rem;">MFC<sup>1</sup></a><a href="/tags/PE/" style="font-size: 0.88rem;">PE<sup>1</sup></a><a href="/tags/QT/" style="font-size: 0.88rem;">QT<sup>1</sup></a><a href="/tags/WPF/" style="font-size: 0.88rem;">WPF<sup>2</sup></a><a href="/tags/ai/" style="font-size: 0.88rem;">ai<sup>1</sup></a><a href="/tags/cmake/" style="font-size: 0.88rem;">cmake<sup>1</sup></a><a href="/tags/doxygen/" style="font-size: 0.88rem;">doxygen<sup>1</sup></a><a href="/tags/git/" style="font-size: 0.88rem;">git<sup>1</sup></a><a href="/tags/json/" style="font-size: 0.88rem;">json<sup>1</sup></a><a href="/tags/linux/" style="font-size: 0.88rem;">linux<sup>1</sup></a><a href="/tags/nas/" style="font-size: 0.88rem;">nas<sup>1</sup></a><a href="/tags/next/" style="font-size: 0.88rem;">next<sup>1</sup></a><a href="/tags/ppt/" style="font-size: 0.88rem;">ppt<sup>1</sup></a><a href="/tags/slidev/" style="font-size: 0.88rem;">slidev<sup>1</sup></a><a href="/tags/vue/" style="font-size: 0.88rem;">vue<sup>1</sup></a><a href="/tags/xml/" style="font-size: 0.88rem;">xml<sup>1</sup></a><a href="/tags/yaml/" style="font-size: 0.88rem;">yaml<sup>1</sup></a><a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 0.88rem;">代码规范<sup>1</sup></a><a href="/tags/%E5%86%85%E6%A0%B8/" style="font-size: 0.88rem;">内核<sup>2</sup></a><a href="/tags/%E5%86%85%E6%A0%B8%E7%9B%B8%E5%85%B3/" style="font-size: 0.88rem;">内核相关<sup>5</sup></a><a href="/tags/%E5%8A%A0%E8%A7%A3%E5%AF%86/" style="font-size: 0.88rem;">加解密<sup>1</sup></a><a href="/tags/%E5%9F%BA%E7%A1%80/" style="font-size: 0.88rem;">基础<sup>2</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 0.88rem;">多线程<sup>1</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F/" style="font-size: 0.88rem;">并发模式<sup>1</sup></a><a href="/tags/%E5%BC%80%E5%8F%91/" style="font-size: 0.88rem;">开发<sup>4</sup></a><a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 0.88rem;">数学<sup>1</sup></a><a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 0.88rem;">正则表达式<sup>1</sup></a><a href="/tags/%E7%9B%91%E6%8E%A7/" style="font-size: 0.88rem;">监控<sup>1</sup></a><a href="/tags/%E7%A1%AC%E7%BC%96%E7%A0%81/" style="font-size: 0.88rem;">硬编码<sup>1</sup></a><a href="/tags/%E7%AE%A1%E7%90%86/" style="font-size: 0.88rem;">管理<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 0.88rem;">网络<sup>3</sup></a><a href="/tags/%E9%80%86%E5%90%91/" style="font-size: 0.88rem;">逆向<sup>2</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.cbd.int/mathjax@3.2.2/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.cbd.int/mermaid@10.2.4/dist/mermaid.min.js').then(runMermaid)
  }

  anzhiyu.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>