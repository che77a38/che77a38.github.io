<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>开发项目管理 | ZEROKO14的个人博客</title><meta name="keywords" content="管理"><meta name="author" content="ZEROKO14"><meta name="copyright" content="ZEROKO14"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#18171d"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="开发项目管理"><meta name="application-name" content="开发项目管理"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#18171d"><meta property="og:type" content="article"><meta property="og:title" content="开发项目管理"><meta property="og:url" content="https://che77a38.github.io/posts/%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/index.html"><meta property="og:site_name" content="ZEROKO14的个人博客"><meta property="og:description" content="此处记录开发思想,项目管理,组织架构,流程标准等等   项目开发的一般流程提出需求–&amp;gt;需求分析–&amp;gt;概要设计–&amp;gt;详细设计–&amp;gt;编码–&amp;gt;测试(内部自己测试和专门人员测试)–&amp;gt;项目验收(提供相关上线材料)–&amp;gt;上线(投入运营)–&amp;gt;日常维护–&amp;gt;版本更新(发现"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4"><meta property="article:author" content="ZEROKO14"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4"><meta name="description" content="此处记录开发思想,项目管理,组织架构,流程标准等等   项目开发的一般流程提出需求–&amp;gt;需求分析–&amp;gt;概要设计–&amp;gt;详细设计–&amp;gt;编码–&amp;gt;测试(内部自己测试和专门人员测试)–&amp;gt;项目验收(提供相关上线材料)–&amp;gt;上线(投入运营)–&amp;gt;日常维护–&amp;gt;版本更新(发现"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://che77a38.github.io/posts/%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2024/07/27/125766904/ba62475f396df9de3316a08ed9e65d86_5680958632268053399..png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":true,"limitCount":50,"languages":{"author":"作者: ZEROKO14","link":"链接: ","source":"来源: ZEROKO14的个人博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'ZEROKO14的个人博客',
  title: '开发项目管理',
  postAI: '',
  pageFillDescription: '项目开发的一般流程, 案例, web企业开发架构, 编程思想, 什么时候需要抽象, 命名建议, 糟糕的命名模式, 去除3层缩进, 表驱动法, 提早返回, 面向对象, 优秀的程序设计思想, 分离逻辑层和表示层, 代码清晰化表达, 公共接口与发布接口, 强代码所有权和弱代码所有权, 计划型设计和进化型设计, 重构, 重构是如何改进设计的呢？, 重构与重写, 灵活性与复杂性, 重构实例参考, 测试, 测试与接口, 单元测试, 性能与调优, 可维护性与效率, 优化, 敏捷宣言, 代码设计原则, 开闭原则, 依赖倒置原则, 接口隔离原则, 软件开发方式, 测试驱动开发 (TDD), 行为驱动开发 (BDD), 制造业相关流程标准, FA功能开发流程, SEMI标准, 表现模式x2F设计模式x2F架构模式, 架构模式, 三层架构, 概述, 三层架构的优势, 数据操作层, 表现模式, MVC, 概述, 优点, MVC与三层架构的关系, MVVM, 概述, 优点, MVC与MVVM的区别, 驱动方式, 事件驱动, 数据驱动, 函数式编程, 控制反转, 面向切片编程, 动态代理, 软件工程, 软件的生存周期, 软件过程, CMM模型, CMMI模型, 阶段式模型 5级模型, 连续式模型 6级模型, 例题, 软件开发方法, 结构化方法, 原型法, 面向对象的方法, 面向服务的方法, 例题, 软件开发模型, 瀑布模型与V模型, 瀑布模型, V模型, 例题, 演化模型, 原型模型, 例题, 螺旋模型, 例题, 增量模型, 例题, 喷泉模型, 例题, 统一过程UP, 敏捷方法, 极限编程XP, 例题, 需求分析, 需求的分类, 需求分析的工具, 数据流图(DFD), 解题技巧, 数据平衡原则, 数据字典, 结构化语言, 判定表, 判定树, 系统设计x2F软件设计, 使用到的工具, 模块设计, 模块设计原则, 内聚性, 耦合性, 人机界面设计, 架构设计, 架构风格, 数据流风格, 批处理序列, 管道-过滤器, 调用x2F返回风格, 主程序x2F子程序, 面向对象, 层次结构, 层次结构中的MVC架构风格, 独立构件风格, 进程通信, 事件驱动系统(隐式调用), 虚拟机风格, 解释器, 基于规则的系统, 仓库风格, 数据库系统, 黑板系统, 超文本系统, 软件测试, 软件测试的分类, 黑盒测试法, 等价类划分, 边界值分析, 白盒测试法, 系统测试, 软件维护, 软件维护类型, 可维护性因素决定, 例题, 软件文档, 软件质量保证模型, 项目管理, 进度管理, Gantt图, PERT图, 关键路径法, 前导图法, 箭线图法, 风险管理, 沟通管理, 成本管理此处记录开发思想项目管理组织架构流程标准等等项目开发的一般流程提出需求需求分析概要设计详细设计编码测试内部自己测试和专门人员测试项目验收提供相关上线材料上线投入运营日常维护版本更新发现并解决下线弃用需求提炼项目的子系统划分每个子系统的模块分解项目的开发经历经验积累开发流程项目调试第三方框架开源库的积累锻炼快读阅读代码的能力锻炼对封装好的的快速上手能力锻炼处理问题的逻辑思维能力案例涉及的知识网络通信结合的多线程或多进程第三方库报文编解码进程间通信套接字管道命名管道共享内存数据库操作相关的库守护进程创建信号相关等等编程相关加密算法相关多线程开发子系统划分秘钥协商客户端子系统秘钥协商服务端子系统客户端信息注册报备图形化界面系统模块划分报文编解码模块网络通信模块共享内存操作模块数据库操作模块外联接口企业开发架构架构讲解编程思想什么时候需要抽象抽象可以减少重复代码但也会带来耦合代码耦合是指代码之间的依赖关系和相互影响程度代码耦合越高不同部分之间的依赖性越强修改一个部分可能会影响其他部分导致代码难以维护和扩展为了降低代码耦合可以采取一些措施比如模块化设计接口隔离依赖注入等这样可以使代码更加灵活可维护和可扩展抽象和耦合如影随形只有下面两种情况才真正有价值有不同的处理方式特别是不同的处理方式需要的参数也不相同该统一操作需要自动执行调度程序不应该关注具体处理程序的种类和细节总的来说只有当抽象化带来的价值超过耦合时才适合应用抽象化一点重复代码带来的痛苦总是比过度耦合要小相对于过耦合重复代码的技术债也总是最廉价的命名建议计算机科学中只有两个难题缓存失效和命名糟糕的命名模式不要以或命名一个类如果你发现自己无法给父类起个好名字那很可能意味着应该重新命名子类当很多代码都放在中时请考虑重构另有一条建议除非类型已经包含单位信息否则请在变量中添加单位去除层缩进代码指南中提到如果你需要超过层的缩进说明你的程序已经开始混乱应该修复你的程序下面罗列了一些去除层缩进的方法表驱动法凡是可以通过逻辑语句来选择的事物都可以通过查表法来解决对于简单的语句逻辑语句更加简单直白但随着选项越来越多表驱动法就更有优势了优势逻辑数据分离易维护使用实现的表驱动法提早返回防御性编程子程序应该不因传入错误数据而破坏哪怕是由其他子程序产生的逻辑错误此时通过早退出或早返回可以简化复杂的参数验证使用断言的话甚至能省去参数验证的语句甚至还可以将参数验证提取出来作为一个独立的函数也是不错的选择面向对象多态调用其实类似分支如图多态能把分支逻辑隐藏起来所以利用面向对象的多态加上工厂模式可以将分支逻辑分离并独立出来让主逻辑更加清晰优秀的程序设计思想分离逻辑层和表示层由于表示层和业务逻辑相互独立在程序维护阶段所需要做出的变化将变得相当容易分离了表示层和业务逻辑的程序也很容易被测试代码清晰化表达在字典和创建新类传达数据的情况下选择创建新类因为字典很不明确你根本就无法得知字典里关键字的真实意思字典不能确定称买东西的人是顾客还是客户即使是拼写错误也无法检查出来更重要的是即使你看完代码还是不能回答这样的问题访问这些数据的接口是什么通过这些数据我能得到什么所以说字典是很不明确的而使用类的话即使你不得不重写所有成员变量及其访问函数一切就变得明确起来这时只需要查看源代码就知道这些数据是什么了公共接口与发布接口作为一个从头开发大型系统且人数众多的团队的管理者首要任务是将系统分成几个主要的子系统然后定义这些子系统的接口这些接口在某种程度上就是对外发布的接口接口并不是不能被改变相反最初要经常改变接口随着时间的推移需要改动的地方越来越少原因很简单接口随着时间的推移而成熟除此以外随着时间的推移越来越多的代码绑定在这些接口上并且开发者对接口越来越熟悉当到达某个点的时候你就会说好吧这就是接口我们往下走吧强代码所有权和弱代码所有权马丁我把代码所有权分为三类在极限编程中用到的代码所有权有时称为集体代码所有权有时也可以说无代码所有权在这种所有权中团队中任何人都不具有对代码的所有权也就是说任何成员可以在任意时间内改动系统中的任何代码这就是极限编程采取的方式和这种所有权相对立的是强代码所有权在强代码所有权中严格区分我的代码和你的代码我不能改动你的代码当我想改动我的某个方法的名字时如果这个方法被你的代码所调用那么我就必须先通知你让你先把所有调用代码改过来然后我才可以改动这个方法的名字另一种办法就是我得将这个方法过期化然后完成后面一系列的步骤实际上在这种情况下因为我绝对不能碰你的代码因而你所用过的我的任何接口都是发布的弱代码所有权则介于两者之间弱代码所有权中还是会区分代码的所有者不同的是它允许开发者改动其他人的代码开发者对自己的代码质量仍然负有责任如果我想要改变我的代码中某个方法的名称改就好了不过假如我想将某个类的功能转赋到另一个类上而这些代码的所有权属于你那么至少在这么做之前我应该让你知道这一点是和集体代码所有权不同的不论是在弱代码所有权下还是集体代码所有权下都可以进行代码的重构但是在强代码所有权下进行重构是个问题因为你想做的许多重构根本就无法进行比如你不能去改动别人的调用代码这就是强代码所有权下不适合做重构而弱代码所有权下可以做重构的原因计划型设计和进化型设计设计强调的是构造将程序划分为若干分割清晰的部分马丁我将设计区分为计划型设计和进化型设计当开发者着手实施一个软件时他首先需要做设计然后再按照这个设计进行编码实现软件这就是我所说的计划型设计计划型设计可能借助或者把整个系统分为若干子系统定义这些子系统间的接口在计划型设计中在设计和代码实现这二者之间存在明确的切换而这二者又往往由不同的人来完成架构师构思设计开发者编码实现做好的设计并不是说一点都不能改变但基本上是固定的你可能会说设计做得越好在编码的时候就会越少对设计做出改动而在进化型设计中开发者在编程实践的过程中逐渐完善设计刚开始的时候并没有设计而是先实现一些小的功能随着实现的功能越来越多设计才逐渐成型我在设计是否已死一文中想要强调的是很多人在尝试进化型设计时往往是在一种无约束无原则的环境里最终的设计必然很蹩脚这是人们之所以倾向于计划型设计的原因之一但是在我看来极限编程实践中通过持续不断的集成测试和重构进化型设计能够做到比计划型设计更有效计划型设计的弱点就是要想做出一个好的设计非常难有趣的是很多进化型设计的倡导者比如肯特贝克和沃德坎宁安都是非常出色的设计师但正是他们最后认识到自己所做的预先设计往往不够好他们容易把一些事情过于工程化在不需要灵活性的地方设计灵活性而在需要灵活性的地方又未予以考虑因此他们最终采用了进化型设计并通过运用一套规则保证了设计效果其结果是不但最终的设计更加出色并且速度也加快了拿我自己来说左右的时间里进化型设计会得到不错的结果而不客气地说一句我认为我的设计水平要比一般人高因此我认为进化型设计应该可以适用于更广泛的人群重构改变了预先设计的地位其正是进化型设计的关键重构下面相关内容摘自对话软件大师重构就是对代码本身做出修改以改善它的内部结构但又不改变它的外部表现优势重构改善了设计而一个良好的设计其商业目的何在我认为它使你能在未来更容易地对软件作出改动重构实际上是在说来吧让我们把系统结构重新调整一下好让将来的任何改动都更容易些其潜台词是如果你不会改动你的系统那么也就没有必要做重构因为不会有任何回报但如果你将要对你的系统作出改动不管是消除漏洞也好还是添加新功能也好那么一个好的或更好的系统结构会使你在做修改时有所受益重构是如何帮助你提高编程速度的呢马丁因为一个设计良好的程序修改起来会更容易程序的设计越好修改起来就越容易从而提高了效率马丁对程序进行改动是主要的动因我们不得不经常对软件作出一些改动只要这个软件还在使用重构是用来改善设计的我们需要一个好的设计以使任何改动都更容易些重构跟性能优化有些类似都是在行为不变性前提下的改进不过性能优化的步骤有异于重构整个过程也有所不同因为性能优化的驱动要素是性能分析重构使得事情一瞬间清晰起来因而你能够一眼就看出漏洞所在人们不注重设计的一个原因是由于工作的流动性程序员因为自己的糟糕设计而自食其果的情况很少发生因此他们没有足够的动因去注重设计此外即便他们注重但设计毕竟是一项费力不讨好的工作好的设计需要时间而开发中的时间压力往往很大但保持代码的良好构造以及编写测试反而能加快工作速度人们把改进设计所花的时间看作是失去的时间但却没有看到将来对代码的改动会容易得多往往只需要几分钟的时间否则可能要花上两三个小时人们往往还低估了在调试上所花的时间低估了他们用来追踪一个潜伏很久的漏洞所花的时间我在写代码的时候可以立即察觉产生的漏洞这使得我能在它潜伏下来之前就解决它没有几件事比调试更花时间和更令人沮丧的了重构是如何改进设计的呢比如提取方法通过把一个很长的令人费解的方法拆分成一些小方法来改进设计改进后的方法读起来就像是一份文档一张调用那些小方法的列表每种重构方法都会对针对某些特定的设计元素做出改进应用的时候要具体情况具体分析很多重构方法都能找到相对立的另一个重构方法比如如果一个方法除了方法本身的代码所表达的意义之外没有任何附加的含义那么你可能会内联它内联方法与提取方法就是对立的很多时候到底应用哪种方法取决于具体情况提取出一个函数内联就是直接用原本的代码不用函数封装简单系统的四个条件通过所有的测试揭示所有的意图没有重复代码使用最少的类和方法重构与重写如果你有一堆乱七八糟的代码且又没有测试那么你最好是扔掉它们从头开始否则你就得重新做所有的测试反之如果你有一堆乱七八糟的代码同时还有很多测试的话情况就不一样了假如代码中满是漏洞那么在行为不变性下不管怎么变换那些漏洞都会被保留下来这时是否重构就是一个值得争论的问题我想这个问题的答案也会随着你对重构熟悉程度的深入而改变随着对重构越来越有信心你可能会对以前想要重写的一些东西改用重构因为你有更强的重构能力了在某些时刻如果代码完全没有结构那么重写是比重构更有效的一种方法因此在决定重写代码之前也许值得花些时间在重构上来看看能做多少改进重构一书里有句话如果打算重构那么最基本的前提是有完善的测试测试对于重构来说是非常重要的支撑灵活性与复杂性比尔在重构一书中你写道在学会重构之前我总是力图找到灵活的方案因为设计变动的代价非常高因而我希望我的设计能够胜任我所能预知的变化但问题是灵活性是有代价的那么灵活性的代价是什么有什么解决之道么马丁灵活性的代价就是复杂性每次当你往代码中加入一些额外的东西以提高灵活性时通常也使你的代码变得更加复杂假如你的预期是对的未来确实需要这种灵活性那么你的超前工作得到了回报但如果你的预期是错的那么你所引入的复杂性将使软件变得更加难以改动因而该灵活性是毫无意义的而这种预期是很容易出错的比如当需求发生变化时你所以为的对灵活性的需求可能随之变化甚至有可能不复存在再比如你添加了一些额外的代码指望它们能提高灵活性但这些代码本身就有问题结果是既增加了复杂性又未能实现灵活性真是赔了夫人又折兵而解决之道就是极限编程事实上你根本就不需要考虑灵活性极限编程理论认为既然我们的预期在大多数情况下都是错的那么就把灵活性放在一边好了那种冒进式的提升设计的办法是拔苗助长平稳地改进设计才是可取之道事实上设计的改进是一个自我强化的过程如果你能够使设计尽可能简洁避免那些无谓的灵活性那么你所要面对的复杂性就会小很多也就越容易对代码做出改动代码会更容易被读懂和被改动你也能够更快地对软件做出调整不要试图一开始就定义一个可重用的框架然后在此基础上开发应用相反应该是在开发过程的过程中逐渐形成和完善框架重构实例参考在写企业应用架构模式这本书的时候曾碰到过这样一个增量式设计的例子当时我需要构建一个关联表映射的模式实例假如在内存中你有一个多对多的关系并且需要把它持久化到一个关系型数据库中这时你需要一个额外的连接表因此一共有三张表有很多种方法可以将数据从数据库中读入到内存里有一种比较简单的办法但是需要执行多个语句也有一种比较快的方法可以只用一个语句但是当需要把返回的数据提取出来并拆分到不同的对象中时就会很别扭我用增量式设计构建了这个模式实例起先我针对三张具体的表和两个具体的类编写了一段写死的代码根本就没有考虑通用化的问题我只是让这个非常特定具体的例子能够运行起来在通过测试之后我着手重构这个例子以使它的应用范围更广一些花了一点时间之后我就得到了一个通用的机制我所要做的一切就是写一个很小的映射类就能够让这个例子对任意的表和类都适用我发现从具体的实例入手然后再把它重构成一个抽象的例子是非常容易的反之如果从抽象的例子入手而把它应用到具体的案例中则要困难得多我还发现前者会给人一种更平静和从容的感觉而实际的进展又非常之快我能够始终清楚目前我在哪里又在做什么我对进度的把握也更加得心应手再也不会有那种何时才能让这段代码运转起来的无力感上面有个很重要的概念单一思考单一是指在任一时刻都只使用一种逻辑一种思考模式当我构建前面提到的那个例子时我只考虑如何使那个很具体的例子运行起来而当我进入到重构阶段时我只考虑如何抽象化那个具体的例子我不会同时去考虑两件事情一次只做一件事情我发现这样做的体验非常宁静而愉快测试马丁没有测试支撑的重构就如同不系安全带走钢丝如果你很擅长走钢丝而且钢丝又不是悬得很高的话那不妨试试但如果你从没走过钢丝而钢丝又是悬在尼亚加拉瀑布上空那你最好还是有个保靠的安全带类似的测试的最大好处就是让你能通过运行它们看看是否有什么东西被破坏了如果你不打算碰你的代码那当然平安无事但只要你加新的功能或是修补漏洞那么你就有可能破坏某些东西你的测试越完善你对能做的改动就越有信心最终你能实现比较高的可靠度以测试为基础的可靠性是极限编程中不大被人们注意的要点之一测试能提高鲁棒性质量和可靠性鲁棒性是指系统在面对不同环境输入或干扰时能够保持稳定和可靠的性能在计算机科学中鲁棒性通常用来描述算法或系统对于错误异常情况或变化的处理能力一个鲁棒性强的系统能够有效地处理各种情况而不会崩溃或产生不可预测的行为花在写测试上的时间可以因为不用修补漏洞而补回来因为花在跟踪调试上的时间大大减少了花在测试上的成本很快就能收回随之而来的还有其它好处通过添加一些测试你能很快获得回报因为你开始发现问题了如果你把测试集中在你需要做改动的代码部分那么当你犯错误的时候测试会告知你这些错误显然全面综合的测试会使你受益最大但是就算只写几个测试你也会从中受益针对包含漏洞的代码段编写单元测试是一种很好的调试技术其带来的好处不仅仅是让你对代码的理解更深刻还让你建立起测试库从而意味着将来不会有问题发生测试优先设计会使你体会到一种难以言传的从容不迫之感你的进展其实非常快但却不会让你感到很紧张因为你为自己设定的都是一些微目标在每个时间点上你知道自己是在实现某一个微目标一旦测试通过该目标就实现了这是一种很平和的过程它缩小了你的关注范围你不需要去考虑每一件事情只需要专注于某一小块功能你实现了这个功能然后重构它使得其中每个环节的设计都近于完美然后再进行下一步我以前用的是你所描述的方法我不得不常常问自己这个东西的接口是什么而现在我转向了增量式设计并且觉得这种方式要大大优于之前的方法测试与接口这是一个潜移默化的过程你的的确确是在构思接口而且是以一种渐进的方式你不会对自己说啊我需要构造这个类让我们来把这个类的所有接口都搞清楚然后再实现之吧相反你会说嗯这个类需要实现这么一小块功能来为此写个测试吧在编写测试的时候接口就随之浮现出来单元测试单元是什么意思马丁哦这很难最粗略地讲它是一个类但随着你与之打交道越多你就会意识到你是在测试功能的一小块区域而这一小块区域有可能是一个类的一部分也有可能是几个类合起来的作用我这里只是粗略地一说不过如果你想开始试试的话可以把单元测试看成是为每个类编写个测试案例性能与调优可维护性与效率比尔记得当时你曾对我说过应该以程序员能读懂的字符格式来序列化对象而不是以二进制代码格式当我提到字符格式要比二进制码格式慢时你说从效率的角度来看二进制代码格式使得软件更加难以维护那么能否请你谈谈关于序列化方式的具体案例一般地说你如何在可维护性与效率之间寻找平衡点马丁效率永远是第一位的前提是你能正确理解它很多时候问题在于人们以为做某些事情是为了效率着想但他们却从不使用性能分析器如果你出于效率的考虑而做某件事但却不使用性能分析器那么你所宣称的根本就不着调序列化所牵扯的问题要多一些使用二进制代码做序列化的问题之一就是你无法去查看结果当你需要存储序列化的对象时这个问题就更加突出的一个典型问题就是如果你改变了一个类那么就无法读取以前所序列化的对象类似的如果一个客户端和一台服务器正通过序列化的对象进行通讯假如一端的数据结构进行了更新而另一端没有那么整个通讯就彻底失效了有一个小窍门可以让你绕开这个问题不要序列化对象本身而是把数据从对象中提取出来放到一个字典里然后再序列化那个字典这么做会使你能够应对一些变化比尔但是字典是不明确的我们之前刚刚说起过这点马丁的确字典不是明确的不过如果你往类里添加一个字段并把这个多出来的值放到字典里的话不会有什么问题因此这是一个比较强壮的机制一般也比较强壮因为你可以对你所不了解的数据视而不见二进制序列化的主要问题就是它的脆弱性在我的书企业应用架构模式中更多地提到了序列化的方式例如在数据库中传输和存储数据时就需要考虑介于字符和二进制之间的序列化格式编写可性能调优的软件实际上就是编写结构合理的软件优化马丁还有一件事需要牢记性能优化与版本和具体的实现是密切相关的当你拿到的一个新版本时一定要把以前所做的优化都撤消然后重走一遍优化过程以确保那些优化手段仍然奏效通常你会发现你为上一个版本的虚拟机或优化型编译器所做的性能优化往往使当前的版本变慢也即之前的优化手段如今往往起到适得其反的作用比尔要记住以前为了提升性能都做了哪些改动可不是件容易的事情马丁你必须这么做先撤销再重新应用我知道这不容易这就要求你对优化过程中所做的每个改动都要有详细的记录要知道旧的优化所造成的一些微不足道的性能损失在新的版本下有时候可能会变得非常显著拉曼曾经讲过一个故事我到现在都还很喜欢这个故事有一次在的大会上做性能优化的讲座他提到了两个广为人知的技术对象池和线程池对象池就是重用已有的对象而不是每次都创建新的对象线程池的原理基本类似讲座结束后有两个人来到跟前这两个人都是设计高性能虚拟机的其中一个虚拟机是另一个好像是一个人告诉线程池的效果不错但对象池则使得虚拟机的运行变慢而另一个人告诉的恰恰相反对象池是一种设计模式用于管理和重复利用对象实例以提高性能和减少资源消耗在对象池中对象实例被预先创建并存储在一个池中当需要时可以从池中获取对象实例使用完毕后再放回池中而不是频繁地创建和销毁对象实例这样可以减少内存分配和垃圾回收的开销提高系统的性能和效率对象池常用于需要频繁创建和销毁对象实例的场景例如线程池数据库连接池等所以你有可能在一种虚拟机上优化了性能但拿到另一种虚拟机上却减慢了其运行速度对此你要特别小心对象池就是一个很好的例子很多人热衷于对象池但起码有一半的情况下人们并不去测量对象池的效果到底是好是坏在的早期日子里对象池非常重要因为垃圾回收功能还不是很完善但在垃圾回收技术更新换代之后对象池的效果就大大降低了因为那些生存周期很短的对象可以被低成本地回收只有那些生存周期很长的对象才适合使用对象池技术因为对它们进行垃圾回收的成本很高从这里可以看出规则也是在不断变化的这就是为什么要对性能调优很仔细的原因所在不要妄想根据源代码就能预测机器会做什么当你与虚拟机或优化型编译器打交道时性能调优是唯一的手段因为编译器和虚拟机所做的事情远远超出你的想象记住不要预测要实测敏捷宣言敏捷宣言中的四条核心价值观个体和互动重于流程和工具这条原则大意是说与其借重过程和工具来加强对软件开发的管理不如更多地关注于团队及其成员关注于每个个体以及他们之间在个人层面上的交互它包括了提升技能它还包括要竭尽全力使程序员们身心愉悦从而得以留住人才它还意味着更认真地对待个性冲突注重人与人的相处而不是试图找出某个完美的软件开发过程然后要求大家都来遵守这个过程我对这条原则的理解是应该是团队选择适合其的软件开发过程而不是让团队来适应指定的开发过程可工作的软件重于详尽的文档客户合作重于合同谈判响应变化重于遵循计划这四条原则指导着敏捷团队在软件开发过程中注重人与沟通可交付的软件产品与客户合作和适应变化马丁尽管在那次聚会上我们中的许多人都津津乐道于自己所采用的开发过程并且我们当中的几个人还是软件工具销售商但我们一致同意对于一个项目的成功来说软件开发过程和工具只是次要的因素最主要的因素还是团队是团队中的成员是他们人性化的合作与努力代码设计原则设计模式面向对象设计原则完整的个设计原则开闭原则开闭原则规定软件实体如类或模块应该开放扩展可以在不修改源代码的情况下添加新功能封闭修改实体不应该被修改以影响其现有功能换言之开闭原则规定软件实体应该被设计为允许添加新功能而不需要修改其底层结构的优点提高灵活性新功能可以被添加而不需要修改现有代码减少耦合实体被解耦合使得维护和演进变得更容易提高可扩展性实体可以被扩展以满足新要求而不影响其现有功能依赖倒置原则依赖倒置原则规定高级模块不应该依赖低级模块而应该依赖抽象抽象不应该依赖细节细节应该依赖抽象换言之规定高级模块不应该依赖低级模块而应该依赖抽象这个抽象可以是一个接口或抽象类的优点减少耦合高级模块被解耦合使得维护和演进变得更容易提高灵活性系统变得更加模块化和易于扩展提高可扩展性系统可以更容易地扩展以满足新要求接口隔离原则接口隔离原则规定客户端不应该被迫依赖它不使用的接口相反接口应该被设计以满足特定客户端的需求换言之规定接口应该被设计以满足特定客户端的需求而不是强迫客户端依赖一个大型的通用接口的优点减少耦合客户端被解耦合使得维护和演进变得更容易提高灵活性接口被设计以满足特定客户端的需求使得添加新功能变得更容易提高可扩展性系统变得更加模块化和易于扩展软件开发方式测试驱动开发测试驱动开发是一种软件开发方法它强调在编写代码之前先编写测试用例这个过程可以分为三个步骤编写测试用例首先开发者编写测试用例以确保代码满足要求运行测试用例然后开发者运行测试用例以确保代码通过测试编写代码最后开发者编写代码以使其通过测试用例的优点包括提高代码质量确保代码满足要求减少的可能性提高开发速度帮助开发者快速编写代码减少时间提高代码可维护性使得代码更易于维护和更新行为驱动开发行为驱动开发是一种软件开发方法它强调在编写代码之前先定义软件的行为这个过程可以分为三个步骤定义行为首先开发者定义软件的行为以确保软件满足要求编写测试用例然后开发者编写测试用例以确保软件行为正确编写代码最后开发者编写代码以使其满足软件行为的优点包括提高软件质量确保软件满足要求减少的可能性提高开发速度帮助开发者快速编写代码减少时间提高软件可维护性使得软件更易于维护和更新制造业相关流程标准功能开发流程客户需求调研分析理解客户的业务需求评估现有的工厂流程并确定自动化系统需要实现的功能和目标设备与客户环境的对接按照等标准开发接口和通讯协议使工厂设备能够与客户的自动化环境进行无缝集成软件需求分析和方案设计根据客户需求制定详细的功能需求文档和技术方案设计软件架构和模块代码编写和单元测试根据设计方案编写软件代码并进行单元测试以确保各个模块的功能正确性和稳定性现场测试在客户现场进行系统集成测试验证软件在实际操作环境中的性能并解决出现的问题文档编写编写相关的技术文档和用户手册详细记录系统功能操作指南维护步骤等其他任务根据公司需求完成其他相关的开发或支持工作功能开发的目标是通过软件和自动化技术来优化生产过程提高生产效率降低成本并确保产品的一致性和质量这在现代制造业尤其是半导体汽车制造电子装配等行业中显得尤为重要标准定义了半导体制造设备与工厂计算机系统之间的通信协议标准包括和其中是基于的通信协议则定义了数据内容和格式基于标准的扩展定义了通用设备模型提供了标准化的设备控制和状态报告接口标准使工厂管理系统能够更容易地控制和监控不同制造设备包括等标准专注于设备的健康管理提供了一套用于监控和报告设备状态的方法以提高设备的可用性和可靠性标准涉及太阳能电池和光伏组件制造涵盖从材料制造过程到最终产品的标准化提供了一种标准化的方法用于在不同供应商的设备和工厂管理系统之间交换过程数据以实现更好的数据分析和制造优化其他领域标准还包括材料处理设备设计环境健康和安全技术文档测试方法等各个方面这些标准的主要目标是促进半导体制造过程中的兼容性和互操作性减少因不同设备和系统之间不兼容带来的问题从而提高整体生产效率和产品质量标准通过详细的技术规范和操作指南为半导体和相关行业提供了一个共同的基础确保了全球制造和供应链的协同运作表现模式设计模式架构模式表现模式通过分离关注点来改进代码的组织方式表现模式侧重于解决代码组织往往使用了多种设计模式因此其也称作复合设计模式属于这种设计模式为了解决一类问题而总结出来的抽象方法架构模式描述软件系统里的基本的结构组织或纲要架构模式提供一些呈现定义好的子系统指定它们的责任并给出把它们组织在一起的法则和指南三层架构属于这种架构模式和表现模式是可以共存的架构模式三层架构概述三层架构以高内聚低耦合的思想把程序的各个功能模块划分为三层架构分别是表示层业务逻辑层数据访问层三层架构的分层模式是典型的上下关系并且是上层依赖于下层在三层架构的隔层模块之间通过对象模型的实体类作为数据传递的载体不同的对象模型的实体类一般对应于数据库的不同表实体类的属性与数据库表的字段名一致三层架构的优势高内聚低耦合可以降低层与层之间的依赖各层互相独立完成自己该完成的任务项目可以多人同时开发开发人员可以只关注整个结构中的其中某一层容易移植维护如转转添加修改删除等有利于标准化和各层逻辑的复用安全性高用户端只能通过业务逻辑层来调用数据访问层减少了入口点三层架构模式是一种基于业务逻辑来分的软件架构模式是一种整体的软件架构等表现模式是基于页面划分的一种复合设计模式是一种页面框架设计作用于三层架构中的层也就是说将三层架构中的层再度进行了分化数据操作层有一个额外的层单独拿出来可以称为数据操作层数据操作层包含公共数据访问代码是用于操作和交互数据库中数据的逻辑代码将数据操作层划分在业务逻辑层还是数据层是当下项目设计的两种常见模式将数据操作的逻辑代码置于业务逻辑层时数据访问成为一种业务逻辑表示层对于数据的访问与业务逻辑层对于数据的操作调用的是相同的方法将所有的数据读取操作存放在数据层时只需要在业务层再定义一个方法供表示层调用在架构设计中根据高内聚低耦合的原则上层的模块不必关心下层模块尽可能独立因此更标准的做法是将数据操作层置于数据层中数据操作层置于数据层后我们一般把这个称为数据访问层以为例除了表示层还可以采用其他表示层技术桌面应用程序动态页网络交互程序跨平台应用程序对于同一逻辑功能层的项目无论使用何种技术来进行表示层的开发其逻辑层和数据层都是相同的表现模式概述和是我们在进行应用程序开发中最常用的两种表现模式模式是界面开发的指导模式它基于表现层功能划分的思想把程序分为三大部分呈三角形结构是数据模型是用户界面是控制器的设计目的是实现功能结构的规划通过使得的数据和的呈现同步模型数据模型处理程序逻辑获取和存放数据的代码包括业务逻辑及具体的实现以及状态管理等视图显示数据提供用户交互界面程序中界面相关的部分是用户看到并与之交互的界面通常实现数据相对于用户的输入与输出功能控制器处理用户交互从读取数据用户输入向发送数据根据用户的交互操作控制用户界面数据的显示与更新的对象状态起到控制整个业务流程的作用实现层与层的协同工作他有关可见在模式中是这个模式的核心和的数据需要经由进行传递的通信核心就在于控制器以控制器为核心划分了视图和数据但并非完全分离的和之间是有联系的之间的通信是单向进行的和也是单向引用但在实际当中和其实也是有数据交互的虽然这并不违背模式的基本原则只要这种交互是在控制器的协调下进行的并且遵循了各组件之间的职责划分就仍然可以保持代码的结构清晰和可维护性为什么说和之间并不是完全分离的呢拿的举例当我们给一个视图上的控件去命名的时候我们就可以通用逻辑页面去通过它的名字调用到他但是一旦你的这个改变了它的名字就会导致也需要修改所以在模式当中和之间多多少少都会存在一些依赖和捆绑的关系用户请求被路由到控制器后者负责使用模型来执行用户操作或检索查询结果控制器选择要显示给用户的视图并为其提供所需的任何模型数据优点有利于软件工程化管理由于不同的层各司其职每一层不同的应用具有某些特性有利于通过工程化工程化管理程序代码可以使用控制器来连接不同的模型和视图去完成客户的需求与三层架构的关系是表现模式三层架构是典型的架构模式三层架构的分层模式是典型的上下关系上层依赖于下层但作为表现模式是不存在上下关系的而是相互协作关系和三层架构基本没有可比性是应用于不同领域的技术概述是一种基于前端开发的表现模式其核心是提供对和的双向数据绑定使得和的数据状态可以自动变更在中应用到是非常常见的全称为代表窗体控件等可视化资源代表的业务处理类将获取到的数据处理好与进行关联绑定通常代表数据模型用于定义和管理应用程序的数据它将支持中用到的一些字段还有一种用法就是在里完成业务逻辑的编写只需要处理视图和模型之间的关联和交互其中是模式的核心他是连接和的桥梁他有两个方向将转化为即将后端传递的数据转化成所看到的页面数据绑定将转化为即将所看到的页面转化成后端的数据事件监听这两个方向共同称之为数据的双向绑定在概念上是真正将页面与数据逻辑分离的模式和彻底分离通常会需要实现一个的观察者在实际开发中如何在和中分配业务逻辑的实现可以根据项目的具体需求和特点来决定毕竞只是一个规范我们尽量遵守即可优点低耦合视图可以独立于变化和修改一个可以绑定到不同的上当变化的时候可以不变当变化的时候也可以不变可重用性可以把一些视图逻辑放在里面让很多重用这段视图逻辑独立开发开发人员可以专注业务逻辑和数据的开发设计人员可以专注页面设计可测试界面向来比较难预测时测试可针对来写最有可能与平台紧密耦合即使对其进行编码也难以进行单元测试与的区别模型关注的是页面功能的划分将层面上的代码和数据逻辑相关的代码分开但并不是完全分离且在于强调控制器的作用在概念上是真正将页面与数据逻辑分离的模式和彻底分离核心在于提供对和的双向数据绑定使得和数据状态的改变可以自动变更和不知道彼此的存在通过来进行绑定即可以直接获取到的信息直接访问模型上的属性和方法但要注意的是和不能直接获取的信息驱动方式事件驱动事件驱动通过事件一订阅一事件处理的关系组织应用程序事件驱动下用户进行每一个操作会激发程序发生的一个事件事件发生后用于响应事件的事件处理器就会执行事件驱动对应的表示模式正是数据驱动数据驱动对应的表示模式是函数式编程参考视频大部分编程范式的区别都在于如何管理状态函数式编程的核心是状态不存在输入会转换为输出控制反转控制反转控制反转是一种设计原则其核心思想是将对象之间的依赖关系控制权从对象本身转移到外部环境通过一个对象不再直接创建依赖对象或管理依赖的生命周期而是将这种责任交给容器或框架处理这种控制权的转移让代码更加灵活易于测试且更具可维护性依赖注入是实现的一种方式依赖注入是一种具体实现的设计模式通过一个对象的依赖项或称依赖对象由外部传入而不是由对象内部自行创建是实现最常用的手段主要有以下几种方式构造函数注入通过构造函数将依赖对象传入属性注入通过属性设置依赖对象方法注入通过方法参数传递依赖对象面向切片编程面向切面编程是一种编程范式专注于将横切关注点如日志事务管理异常处理从业务逻辑中分离框架可以通过拦截方法调用的方式在特定代码执行前后自动执行一些通用逻辑常见的框架有等框架的核心机制是动态代理通过切面实现方法执行前后或异常发生时的特定操作通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术是对的一种补充在不修改原始类的情况下给程序动态添加统一功能的一种技术面向切片编程框架在减少重复代码实现一致的全局处理方面非常有帮助通过动态插入功能的方式便于管理跨业务的代码逻辑的关键概念切面关注特定任务如日志异常处理的模块连接点程序中的一个执行点如方法调用或异常抛出切入点定义在哪些连接点插入切面的规则通知在连接点实际执行的操作如方法前后的日志记录异常拦截等使用场景日志记录在方法执行前后记录日志无需在每个方法内手动添加事务管理在数据库操作前后自动开启和提交事务全局异常处理集中捕获和处理异常并记录在日志中性能监控自动测量方法的执行时间以便优化权限控制强制执行安全策略确保只有授权的用户能够执行特定操作实现有两种方式静态代理实现所谓静态代理就是我们自己来写代理对象动态代理实现所谓动态代理就是在程序运行时去生成一个代理对象实现静态代理需要使用到两种设计模式设计模式装饰器模式和设计模式代理模式的是靠设计模式代理模式实现的动态代理两种实现方式通过代码织入的方式例如第三方插件我们知道程序最终会编译成中间语言在编译程序的时候会动态的去修改在里面添加代码这就是代码织入的方式通过反射的方式实现通过反射实现的方法非常多也有很多实现了的框架例如过滤器等软件工程软件的生存周期通俗理解概要设计大框架方面的设计包括将一个系统划分为子系统或模块等分配过程都叫概要设计还要设计划开的部分之间通信的过程详细设计子系统或子模块之间的具体设计具体的数据结构算法等东西编码实现开发阶段测试验证功能是否正常维护也叫做运维将系统交付给用户后在用户环境下运行包括更新换代打补丁等很多工作概要设计文档的内容不包括体系结构设计数据库设计需要全局的数据库设计模块内算法设计逻辑数据结构设计需要全局的逻辑数据结构设计结构化开发方法中主要包含对数据结构和算法的设计体系结构设计概要设计数据设计图接口设计人机交互过程设计在采用结构化开发方法进行软件开发时设计阶段接口设计主要依据需求分析阶段的接口设计的任务主要是数据流图图状态迁移图加工规格说明定义软件的主要结构元素及其之间的关系体系结构设计确定软件涉及的文件系统的结构及数据库的表结构数据设计描述软件与外部环境之间的交互关系软件内模块之间的调用关系这就是接口设计确定软件各个模块内部的算法和数据结构过程设计阶段软件过程软件过程改进的几种模型软考中主要考察的点就是这几种模型模型软件过程能力成熟度模型很多公司会评定等级初始级杂乱无章甚至混乱几乎没有明确定义的步骤项目的成功完全依赖个人的努力和英雄式核心人物的作用可重复级建立了基本的项目管理过程和实践来跟踪项目费用进度和功能特性有必要的过程准则来重复以前在同类项目中成功已定义级管理和工程两方面的软件过程已经文档化标准化并综合整个软件开发组织的标准过程已管理级指定了软件过程和产品质量的详细度量标准优化级加强了定量分析通过来自过程质量反馈和来自新观念新技术的反馈使过程能不断持续地改进初始级是级优化级是级除了模型后续还有一个进阶版叫阶段式模型以下关于的叙述中不正确的是是指软件过程能力成熟度模型根据软件过程的不同成熟度划分了个等级其中级被认为成熱度最高级被认为成熟度最低的任务是将已有的几个模型结合在一起使之构成集成模型采用更成熟的模型一般来说可以提高最终产品的质量模型阶段式模型级模型连续式模型级模型只需要完成等级和关键字的匹配即可满足软考要求等级说明关键字未完成的过程域未执行或未得到中定义的所有目标未执行或未得到已执行的其共性目标是过程将可标识的输入工作产品转换成可标识的输出工作产品以实现支持过程域的特定目标可标识的输入工作产品转换成可标识的输出工作产品已管理的其共性目标是集中于已管理的过程的制度化根据组织级政策规定过程的运作将使用哪个过程项目遵循已文档化的计划和过程描述所有正在工作的人都有权使用足够的资源所有工作任务和工作产品都被监控控制和评审已管理的过程的制度化已定义级的其共性目标集中于已定义的过程的制度化过程是按照组织的裁剪指南从组织的标准过程中裁剪得到的还必须收集过程资产和过程的度量并用于将来对过程的改进已定义的过程的制度化定量管理的其共性目标集中于可定量管理的过程的制度化使用测量和质量保证来控制和改进过程域建立和使用关于质量和过程执行的质量目标作为管理准则可定量管理的过程的制度化优化的使用量化统计学手段改变和优化过程域以满足客户的改变和持续改进计划中的过程域的功效量化统计学手段改变和优化过程域的量化统计学是用来优化自身的别理解错成了例题能力成熟度模型集成是若干过程模型的综合和改进连续式模型和阶段式模型是提供的两种表示方法而连续式模型包括个过程域能力等级其中使用量化统计学手段改变和优化过程域以应对客户要求的改变和持续改进计划中的过程域的功效已管理的已定义级的定量管理的优化的软件开发方法结构化方法非常严谨是一种面向过程的开发适用于需求明确的项目一般认为做二次开发或已有行业经验被称为需求明确特点用户至上严格区分工作阶段每阶段有任务和结果强调系统开发过程的整体性和全局性系统开发过程工程化文档资料标准化自顶向下逐步分解求精需求本身是有渐进明晰性的当需求改进时很多时候要推导重来原型法使用于需求不明确的项目使用了一种演化迭代的思想主要是帮助用户明确需求的比如提供界面原型给用户来提需求面向对象的方法适用于复杂大项目结构化方法不适用于复杂项目因为复杂项目变数太多了特点更好的复用性关键在于建立一个全面合理统一的模型分析设计实现三个阶段界限不明确整个过程是迭代无间隙的相互之间可以有一些交叠的过程面向服务的方法软考中目前仅在高级中出现过服务可以理解为更高级别的抽象抽象级别操作服务业务流程例题若用户需求不清晰且经常发生变化但系统规模不太大且不太复杂则最适宜采用开发方法对于数据处理领域的问题若系统规模不太大且不太复杂需求变化也不大则最适宜采用开发方法结构化原型化面向对象结构化原型化面向对象这种方法是面向数据结构的软件开发模型软考必考知识点主要是给定一种情形让考生判断适合什么开发模型瀑布模型与模型适用于需求明确文档驱动演化模型适用于需求不明确增量模型尽可能早提供可用版本然后在这个版本基础上增加新的功能模块喷泉模型用户需求驱动迭代无间隙统一过程以架构为中心用例驱动敏捷方法瀑布模型与模型这个考点出现特别频繁瀑布模型适合于需求明确的情况由文档驱动的模型属于瀑布模型的一个变种强调的是测试贯穿始终单元测试模块测试模块功能性能接口等一般只有单元测试是自己测试自己集成测试模块间的接口打桩桩模块只用来测试的模块系统测试真实环境下验证完整的软件配置项能否和系统正确连接确认测试验证软件与需求的一致性内部确认测试测试测试验收测试回归测试测试软件变更之后变更部分的正确性对变更需求的符合性例题某开发小组欲为一公司开发一个产品控制软件监控产品的生产和销售过程从购买各种材料开始到产品的加工和销售进行全程跟踪购买材料的流程产品的加工过程以及销售过程可能会发生变化该软件的开发最不适宜采用模型主要是因为这种模型瀑布原型增量喷泉不能解決风险不能快速提交软件难以适应变化的需求不能理解用户的需求演化模型演化模型演化模型是迭代的过程模型使得软件开发人员能够逐步开发出更完整的软件版本演化模型特别适用于对软件需求缺乏准确认识的情况其中原型模型螺旋模型原型模型原型模型强调的是明确需求而不是长期投入使用的迭代过程第一个维度区分抛弃型原型前一个迭代会被抛弃掉演化型原型最初的迭代会被保留第二个维度区分探索型原型主要用于需求分析阶段探索多种可能的设计方案的可行性实验型原型针对特技术方案或架构进行验证评估实现方案的可行性和性能表现演化型原型贯穿开发全过程从核心功能出发逐步迭代最终演化为完整的软件系统例题以下关于系统原型的叙述中不正确的是可以帮助导出系统需求并验证需求的有效性可以用来探索特殊的软件解決方案可以用来指导代码优化可以用来支持用户界面设计是探索型原型是实验性原型是最初的原型一般会保留在系统中所以是演化型原型螺旋模型螺旋模型是由瀑布模型和演化模型结合加入风险分析特别适用于庞大复杂并且具有高风险的系统他是唯一适用于高风险的系统开发模型例题以下关于螺旋模型的叙述中不正确的是它是风险驱动的要求开发人员必须具有丰富的风险评估知识和经验它可以降低过多测试或测试不足带来的风险它包含维护周期因此维护和开发之间没有本质区别它不适用于大型软件开发某企业拟开发一个企业信息管理系统系统功能与多个部门的业务相关现希望该系统能够尽快投入使用系统功能可以在使用过程中不断改善则最适宜采用的软件过程模型为瀑布模型题干提到了不断改善即需求不明确原型模型原型模型强调的是需求明确而不是长期迭代使用演化迭代模型最符合的是演化模型螺旋模型强调风险管理但是题干没有提到原型模型和螺旋模型都是演化模型的一种但是当这些选项都出现的时候应该选择最合适的选项增量模型第个增量往往是核心产品将需求分段为一系列增量产品每一增量可以分别开发用户用的最多的功能其实只有所有功能中的每一轮都能将核心增量进行测试以此保证核心功能的最稳定和最优这种模型对用户体验会更好每一个增量都会提供一个用户可使用的版本但缺点是判定哪些功能属于核心增量对于开发者来说比较困难例题以下关于增量开发模型的叙述中不正确的是不必等到整个系统开发完成就可以使用可以使用较早的增量构件作为原型从而获得稍后的增量构件需求优先级最高的服务先交付这样最重要的服务接受最多的测试有利于进行好的模块划分增量模型中最难做的就是模块划分喷泉模型以用户需求为动力以对象作为驱动的模型适合于面向对象的开发方法特点迭代无间隙例题喷泉模型是一种适合于面向开发方法的软件过程模型该过程模型的特点不包括对象数据数据流事件以用户需求为动力支持软件重用具有选代性开发活动之间存在明显的界限统一过程和都表示统一过程每一轮迭代为初始初启细化精化构建交付构建中的测试叫做测试交付阶段的测试叫测试面向架构很大的优势在于复用构件组件敏捷方法考得比较多总体目标是通过尽可能早的持续的对有价值的软件的交付使客户满意适用于小步快跑的思想适合小项目小团队结对编程让至少两个人作为一对来进行编程一个人进行写的同时另一个人来看另一个维度是防止人员流失具体的敏捷开发涉及到一些模型敏捷方法特点极限编程大价值观个原则个最佳实践水晶法认为每一个不同的项目都需要一套不同的策略约定和方法论认为人对软件质量有重要的影响以人为本因此随着项目质量和开发人员素质的提高项目和过程的质量也随之提高通过更好地交流和经常性交付软件生产力得到提高开放式源码程序开发人员在地域上分布很广并列争球法把每天一次的迭代称为一个冲刺并按需求的优先级来实现产品多个自组织和自治的小组并行地递增实现产品协调是通过简短的日常情况会议来进行就像橄榄球中的并列争球功用驱动开发方法首席程序员和类程序员自适应软件开发核心是三个非线性的重叠的开发阶段猜测合作与学习有个基本的原则有一个使命作为指导特征被视为客户价值的关键点过程中的等待是很重要的因此量做与做同样关键变化不被视为改正而是被视为对软件开发实际情况的调整确定的交付时间迫使开发人员认真考虑每一个生产版本的关键需求风险也包含其中极限编程常考经常是选择题的形式大价值观沟通简单反馈勇气勇于面对变化大原则快速反馈简单性假设逐步修改提倡更改优质工作大最大实践计划游戏快速制定计划随着细节的不断变化而完善小型发布系统的设计要能够尽可能早的交付隐喻找到合适的比喻传达信息简单设计只处理当前需求是设计保持简单测试先行先写测试代码然后再编写程序重构重新审视需求和设计重新明确的描述他们以符合新的现有的需求结对编程集体代码所有制持续集成可以按日甚至按小时为客户提供可运行的版本每周工作小时现场顾客系统最终用户代表应该全程配合团队编码标准例题在敏捷过程的开发方法中使用了迭代的方法其中把每段时间天一次的选代称为一个冲刺并按需求的优先级别来实现产品多个自组织和自治的小组并行地递增实现产品极限编程水晶法并列争球法自适应软件开发以下关于极限编程的最佳实践的叙述中不正确的是只处理当前的需求使设计保持简单编写完程序之后编写测试代码可以按日甚至按小时为客户提供可运行的版本系统最终用户代表应该全程配合团队需求分析问题识别分析与综合编制需求分析文档文档产物一般是需求规格说明书需求分析与评审让需求的提出方评审签字确认结构化分析的结果一套分层的数据流图一本数据词典对数据流图来加以说明一组小说明也称加工逻辑说明补充材料软件开发过程中需求分析阶段的输出不包括数据流图实体联系图图是数据库设计阶段的概念设计阶段的产物数据字典软件体系结构图在需求分析阶段是得不到的是架构设计即概要分析的产物需求的分类两种维度的分类上图一些名词解释非功能需求或者叫性能需求一般包含性能响应并发存储容量速度等需求设计约束一般是对操作系统数据库的要求还有对法律法规的要求在考试中主要是考察系统需求的分类某企业财务系统的需求中属于功能需求的是每个月特定的时间发放员工工资系统的响应时间不超过秒系统的计算精度符合财务规则的要求系统可以允许个用户同时查询自己的工资需求分析的工具数据流图数据字典判定表判定树数据流图这一道题有分主要考察的点是补充实体名补充存储名补充加工名数据流例子经常扣掉一些字让用户填空数据流图自顶向下逐步求精其中父子层图的关系如下图顶层数据流图上下文数据流图数据流图建模应遵循的原则自顶向下从具体到抽象自顶向下从抽象到具体自底向上从具体到抽象自底向上从抽象到具体在结构化分析中用数据流图描述当采用数据流图对一个图书馆管理系统进行分析时是一个外部实体数据对象之间的关系用于对数据建模不对对象的关系是静态的而数据流图是描述一种动态关系的数据在系统中如何被传送或变换以及如何对数据流进行变换的功能或子功能用于对功能建模系统对外部事件如何响应如何动作用于对行为建模并没有对外部事件进行考虑只是对系统内部进行考虑数据流图中的各个组成部分比较接近数据词典的定义读者图书借书证借阅数据字典是结构化分析的一个重要输出数据字典的条目不包括外部实体数据流数据项基本加工解题技巧补充实体补充存储补充数据流数据平衡原则顶层图与层图对比是否有顶层图有但层图无得数据流或反之检查图中每个加工是否存在只有入没有出或只有出没有入或根据输入的数据无法产生对应的输出的情况按题目说明与图进行匹配说明中的每一句话都能与图中有对应关系当把说明中的实体与数据流标识出来之后容易缩小对应范围找出纰漏补充加工名加工是用于处理数据流的所以要补充加工名可以把该加工涉及到的数据流在说明中标识出来再在数据流名称所在的句子中找动词名词的结构分析是否可作为加工动词名词如生成报告发出通知批改作业记录分数当然这只是普遍情况也有例外如物流跟踪用户管理例题阅读以下说明和数据流图回答问题至问题将解答填入答题纸的对应栏内说明现准备为某银行开发一个信用卡管理系统该系统的基本功能为信用卡申请非信用卡客户填写信用卡申请表说明所要申请的信用卡类型及申请者的基本信息提交如果信用卡申请被银行接受将记录该客户的基本信息并发送确认函给该客户告知客户信用卡的有效期及信贷限额否则该客户将会收到一封拒绝函非信用卡客户收到确认函后成为信用卡客户信用卡激活信用卡客户提交激活请求用信用卡号和密码激活该信用卡激活操作结束后将激活通知发送给客户告知客户其信用卡是否被成功激活信用卡客户信息管理信用卡客户的个人信息可以在中进行在线管理每位信用卡客户可以在线查询和修改个人信息交易信息查询信用卡客户使用信用卡进行的每一笔交易都会记录在中信用卡客户可以通过查询并核实其交易信息包括信用卡交易记录及交易额图和图分别给出了该系统的顶层数据流图和层数据流图的初稿问题分根据说明将图中的填充完整问题分图中缺少三条数据流根据说明分别指出这三条数据流的起点和终点注数据流的起点和终点均采用图中的符号和描述问题分图中有两条数据流是错误的请指出这两条数据流的名称并改正注数据流的起点和终点均采用图中的符号和描述问题分根据说明将图中的处理名称填充完整一般实体较少从实体先分析从题干中提取出三个实体非信用卡客户银行信用卡客户用于填充到四个加工流程分别是信用卡申请信用卡激活信用卡客户信息管理交易信息查询用于填充到根据数据平衡原则可分析出缺失的三条数据流交易信息在顶层数据流图中是缺失的信用卡申请表在顶层数据流图中是缺失的激活请求在顶层数据流图中缺失题干中可知信用卡申请表应该是从非信用卡客户指向的数据流图中的箭头是反了题干中可知激活请求应该是信用卡客户发送给的而不是图示中的指向交易信息查询客户信息管理信用卡激活信用卡申请还有另外两道例题暂略数据平衡原则查找缺失数据流的过程中一个可以快速查找的依据但是只能查找一些缺失数据而非全部最终的解决方案还是要落到题目分析的过程中包含两个维度父图与子图之间的平衡父图与子图之间平衡是指任何一张子图边界上的输入输出数据流必须与其父图对应加工的输入输出数据了保持一致如果父图中某个加工的一条数据流对应于子图中的几条数据流而子图中组成这些数据流的数据项全体正好等于父图中的这条数据流那么它们仍然是平衡的子图内的平衡数据流图常见的种错误加工只有输入没有输出称之为黑洞加工只有输出没有输入称之为奇迹加工中输入不足以产生输出称之为灰洞分析上图的是否存在数据缺失以前端应用为例分析顶层数据流图前端应用相接的数据流有非法用户信息用户信息操作请求处理后的操作结果对比可知缺失了这项权限不足信息格式错误信息而在层数据流图中前端应用相接的数据流有非法用户信息用户信息操作请求权限不足信息格式错误信息前端应用在层数据流图中缺失了处理后的操作结果后端数据库顶层数据流图验证后的操作请求连接请求操作结果对比可知缺失了这项层数据流图验证后的连接请求就是操作请求吧连接请求数据字典数据字典有类条目数据流数据项数据存储和基本加工源点和终点不在系统之内不在字典中说明机票姓名日期航班号起点终点费用航班号终点长沙上海北京西安结构化语言常用的加工逻辑描述方法有结构化语言判定表和判定树种结构化语言是一种介于自然语言和形式化语言之间的半形式化语言是自然语言的一个受限子集外层用来描述控制结构采用顺序选择和重复种基本结构顺序结构一组祈使语句选择语句重复语句的顺序排列选择结构一般用等关键词重复结构一般用等关键词内层一般采用祈使语句的自然语言短语使用数据字典中的名词和游戏的自定义词其动词含义要具体尽量不用形容词和副词来修饰还可使用一些简单的算法运算和逻辑运算符号判定表某些情况下数据流图中某个加工的一组动作依赖于多个逻辑条件的取值此时用判定表能够清晰的表示复杂的条件组合与应做的动作之间的关系判定表由个部分组成分割成如下的个区域条件定义条件取值的组合动作定义在各种取值的组合下应执行的动作判定树判定树是判定表的变形一般情况下笔判定表更直观且易于理解和适用系统设计软件设计大致可以分为两个阶段概要设计详细设计特点抽象化自顶向下逐步求精信息隐蔽模块独立高内聚低耦合包含下面的设计环节体系结构设计架构设计定义软件系统各主要部件之间的关系数据设计基于图确定软件涉及的文件系统的结构及数据库的表结构接口设计人机界面设计软件内部软件和操作系统间以及软件和人之间如何通信过程设计系统结构部件转换成软件的过程描述确定软件各个组成部分内的算法及内部数据结构并选定某种过程的表达形式来描述各种算法使用到的工具下面的工具在考试中实际上并没有用到图图图程序流程图盒图模块设计考得很多基本设计要点保持模块的大小适中尽可能减少调用的深度多扇入少扇出某个模块被调用叫扇入模块调用别的模块叫扇出单入口单出口模块的作用域应该在模块之内作用域指模块内定义的变量函数或逻辑的可见范围即哪些代码区域可以访问该模块的内容控制域指模块在运行时能直接或间接调用控制的其他模块集合即该模块的执行影响范围功能应该是可预测的良好的启发式设计原则上不包括提高模块独立性内聚性模块规模越小越好应该是大小适中模块作用域在其控制域之内内聚性降低模块接口复杂性耦合性模块设计原则高内聚低耦合内聚性内聚类型描述功能内聚完成一个单一功能各个部分协同工作缺一不可顺序内聚处理元素相关而且必须顺序执行通信内聚所有处理元素集中在一个数据结构的区域上过程内聚处理元素相关而且必须按特定的次序执行注意可以不顺序瞬时内聚时间内聚所包含的任务必须在同一时间间隔内执行逻辑内聚完成逻辑上相关的一组任务偶然内聚巧合内聚完成一组没有关系或松散关系的任务考点注意顺序内聚和过程内聚的区别注意区分最高是功能内聚最低是偶然内聚某模块中各个处理元素都密切相关于同一功能且必须顺序执行前一处理元素的输出就是下一处理元素的输入则该模块的内聚类型为内聚过程时间顺序逻辑耦合性耦合类型描述非直接耦合两个模块之间没有直接关系它们之间的联系完全是通过主模块的控制和调用来实现的数据耦合一组模块借助参数表传递简单数据标记耦合一组模块通过参数表传递记录信息数据结构控制耦合模块之间传递的信息中包含用于控制模块内部逻辑的信息外部耦合一组模块都访问同一全局简单变量而且不是通过参数表传递该全局变量的信息公共耦合多个模块都访问同一个公共数据环境内容耦合一个模块直接访问另一个模块的内部数据一个模块不通过正常入口转到另一个模块的内部两个模块有一部分程序代码重叠一个模块有多个入口模块将学生信息即学生姓名学号手机号等放到一个结构体中传递给模块模块和之间的耦合类型为耦合数据标记控制内容人机界面设计黄金三原则置于用户控制之下以不强迫用户进入不必要的或不希望的动作的方式来定义交互方式提供灵活的交互允许用户交互可以被中断或撤销当技能级别增加时可以使交互流水化并允许定制交互使用户隔离内部技术细节设计应允许用户和出现在屏幕上的对象直接交互减少用户的记忆负担减少对短期记忆的要求建立有意义的缺省定义直觉性的捷径界面的视觉布局应该基于真实世界的隐喻以不断进展的方式提示信息保持界面的一致性允许用户将当前任务放入有意义的语境在应用系列内保持一致性如过去的交互模型已建立起了用户期望除非有迫不得已的理由不要改变它在其关于界面设计所提出的三条黄金准则中不包括用户操纵控制界面美观整洁减轻用户的记忆负担保持界面一致架构设计架构设计的一个核心问题是能否达到架构级的软件复用架构风格架构风格是对架构设计的归类架构风格反映了领域中众多系统所共有的结构和语义特性并知道如何将各个构件有效地组织成一个完整的系统架构风格定义了用于描述系统的术语表和一组指导构件系统的规则有下面的一些架构风格数据流风格批处理序列管道过滤器调用返回风格主程序子程序面向对象层次结构独立构件风格进程通信事件驱动系统隐式调用虚拟机风格解释器基于规则的系统仓库风格数据库系统超文本系统黑板系统数据流风格批处理序列构件为一系列固定顺序的计算单元构件之间只通过数据传递交互每个处理步骤是一个独立的程序每一步必须在其前一步结束后才能开始数据必须是完整的以整体的方式传递管道过滤器每个构件都有一组输入和输出构件读输入的数据流经过内部处理然后产生输出数据流这个过程通常是通过对输入数据流的变换或计算来完成的包括通过计算和增加信息以丰富数据通过浓缩和删除以精简数据通过改变记录方式以转化数据和递增地转化数据等这里的构件称为过滤器连接件就是数据流传输的管道将一个过滤器的输出传到另一个过滤器的输入早期编译器就是采用的这种架构要一步一步处理的均可考虑采用此架构风格调用返回风格主程序子程序单线程控制把问题划分为若干个处理步骤构件即为主程序和子程序子程序通常可合成为模块过程调用作为交互机制即充当连接件的角色调用关系具有层次性其语义逻辑表现为主程序的正确性取决于它调用的子程序的正确性面向对象构件是对象对象是抽象数据类型的实例在抽象数据类型中数据的表示和它们的相应操作被封装起来对象的行为体现在其接受和请求的动作连接件即是对象间交互的方式对象是通过函数和过程的调用来交互的面向对象是显示调用而事件是隐式调用的层次结构构件组织成一个层次结构连接件通过决定层间如何交互的协议来定义每层为上一层提供服务使用下一层的服务只能见到与自己邻接的层通过层次结构可以将大的问题分解为若干个渐进的小问题逐步解决可以隐藏问题的复杂度修改某一层最多影响其相邻的两层通常只能影响上层优点这种风格支持基于可增加抽象层的设计允许将一个复杂问题分解成一个增量步骤序列的实现不同层次处于不同的抽象级别越接近底层抽象级别越高越接近顶层抽象级别越低由于每一层最多只影响两层同时只要给相邻层提供相同的接口允许每层用不同的方法实现同样为软件复用提供了强大的支持缺点并不是每个系统都可以很容易地划分为分层的模式很难找到一个合适的正确的层次抽象方法层次风格的拓展性非常强以下关于客户机服务器体系结构的优点的叙述中不正确的是允许合理地划分三层的功能使之在逻辑上保持相对独立性允许各层灵活地选用平台和软件各层可以选择不同的开发语言进行并行开发系统安装修改和维护均只在服务器端进行客户端也要更新层次结构中的架构风格架构是层次结构中一种经典的架构模型是应用程序中用于处理应用程序数据逻辑的部分通常模型对象负责在数据库中存取数据视图是应用程序中处理数据显示的部分通常视图是依据模型数据创建的控制器是应用程序中处理用户交互的部分通常控制器负责从视图读取数据控制用户输入并向模型发送数据组件实现职责说明与传统的对比文件如和部分代码隐藏负责界面渲染和用户交互通过数据绑定显示数据但的通常不直接操作数据逻辑类似但通过数据绑定实现动态更新而非直接嵌入业务逻辑路由逻辑或事件处理类如自定义的类处理用户输入事件如按钮点击协调和的交互但在中的职责常被替代类似但的更轻量级且不强制要求独立层可能与代码耦合数据实体类如和业务逻辑层如服务类管理数据和业务规则与数据库或交互与的功能一致直接对应的层但中通常不直接暴露给而是通过封装后传递独立构件风格进程通信构件是独立的过程连接件是消息传递构件通常是命名过程消息传递的方式可以是点对点异步或同步方式以及远程过程方法调用等事件驱动系统隐式调用构件不直接调用一个过程而是触发或广播一个或多个事件构件中的过程在一个或多个事件中注册当某个事件被触发时系统自动调用在这个事件中注册的所有过程一个事件的触发就导致了另一个模块中的过程调用这种风格中的构件是匿名的过程它们之间交互的连接件往往是以过程之间的隐式调用来实现的主要优点是为软件复用提供了强大的支持为构件的维护和演化带来了方便其缺点是构件放弃了对系统计算的控制虚拟机风格解释器解释器通常包括一个完成解释工作的解释引擎一个包含将被解释的代码的存储区一个记录解释引擎当前工作状态的数据结构以及一个记录源代码被解释执行的进度的数据结构具有解释器风格的软件中含有一个虚拟机可以仿真硬件的执行过程和一些关键应用其确定是执行效率比较低基于规则的系统基于规则的系统包括规则集规则解释器规则数据选择器和工作内存一般用在人工智能领域和中仓库风格是一种以数据为中心的规则数据库系统构件主要有两大类一类是中央共享数据源保存当前系统的数据状态另一类是多个独立处理单元处理单元对数据元素进行操作黑板系统包括知识源黑板和控制三部分知识源包括若干独立计算的不同单元提供解决问题的知识知识源响应黑板的变化也只修改黑板黑板是一个全局数据库包含问题域解空间的全部状态是知识源相互作用的唯一媒介知识源响应是通过黑板状态的变化来控制的黑板系统通常应用在对于解决问题没有确定性算法的软件中信号处理问题规划和编译器优化等超文本系统构件以网状链接方式相互连接用户可以在构件之间进行按照人类的联想思维方式任意跳转到相关构件超文本是一种非线性的网状信息组织方法它以结点为基本单位链作为结点之间的联想式关联超文本系统通常应用在互联网领域现代集成编译环境一般采用这种架构风格数据仓库位于该体系结构的中心其他构件访问该数据仓库并对其中的数据进行增删改等操作以下关于该风格的叙述中不正确的是不属于仓库风格支持可更改性和可维护性具有可复用的知识源支持容错性和健壮性测试简单很难测试数据库数据库系统超文本系统黑板系统编译器软件测试测试的基本概念及分类尽早不断的进行测试程序员避免测试自己设计的程序既要选择有效合理的数据也要选择无效不合理的数据修改后应进行回归测试尚未发现的错误数量与该程序已发现错误数成正比测试用例的格式一般是输入数据以及他的结果最后验证是否相符一个测试用例最多只覆盖一个测试错误点软件测试的分类根据是否人工测试来划分动态测试机器运行黑盒测试法不关心内部细节只考虑输入输出是否有问题白盒测试法具体输入是如何到达输出的是否有问题灰盒测试法结合黑盒与白盒静态测试纯人工桌前检查程序员自己检查代码审查其他人检查代码走查预想代码执行过程这个过程中判断其中是否存在问题以下关于软件测试的叙述中不正确的是在设计测试用例时应考虑输入数据和预期输出结果软件测试的目的是证明软件的正确性无法验证一个软件是百分百正确的在设计测试用例时应该包括合理的输入条件在设计测试用例时应该包括不合理的输入条件招聘系统要求求职的人年龄在岁到岁之间含学历为本科硕士或者博士专业为计算机科学与技术通信工程或者电子工程其中不是好的测试用例本科电子工程合法本科通信工程一个错误点大专电子工程两个错误点硕士生物学一个错误点一个测试用例最多只覆盖一个测试错误点黑盒测试法有下面几种等价类划分边界值分析错误推测依据经验来进行推测因果图通过各个错误结果反推原因等价类划分确定无效与有效等价类设计用例尽可能多的覆盖有效类设计用例只覆盖一个无效类边界值分析处理边界情况时最容易出错选取的测试数据应该恰好等于稍小于或稍大于边界值白盒测试法重点内容考察频率高有以下几种基本路径测试循环覆盖测试逻辑覆盖测试重点覆盖类型定义特点语句覆盖被测试程序中的每条语句至少执行一次对执行逻辑覆盖很低一般认为是很弱的逻辑覆盖判定覆盖分支覆盖被测程序每个判定表达式至少获得一次真值和假值或者程序中每一个判定取真分支和取假分支至少通过一次判定覆盖比语句覆盖更强一些判定可以是个条件也可以是多个条件的组合条件覆盖每一个判定语句中每个逻辑条件的各种可能的值至少满足一次条件覆盖和判断覆盖没有包含关系判断条件覆盖判定中每个条件的所有可能取值真假至少出现一次并使每个判定本身的判定结果真假也至少出现一次同时满足判定覆盖和条件覆盖条件组合覆盖每个判定中的各种可能值的组合都至少出现一次同时满足判定覆盖条件覆盖判断条件覆盖路径覆盖覆盖被测试程序中所有可能的路径基本路径测试每一条独立路径都执行过即程序中可执行语句至少执行一次测试用例个数与环路复杂度一致判定为关键控制结点必须出现在基本路径中循环覆盖循环中每个条件都得到验证注意数组参数可循环验证例题语句覆盖测试用例任意一个都满足判定覆盖测试用例测试用例组合就可以满足条件覆盖测试用例测试用例与测试用例测试用例这两种组合都可以判定条件覆盖测试用例测试用例路径覆盖测试用例测试用例组合就可以满足例题观察顺序发现首次测试的同时还测试了因此是三明治测试策略选项的说法不正确自顶向下的话测试还是要做桩模块而测试的时候还是要做驱动模块系统测试经常出现的考点复杂度的计算环路复杂度是环的个数这里的是顺序流程本身算一个环路如果上面的方式不好确定也可以将图片转换为节点图即每个交叉点视为一个节点如下图的转换过程计算有向图的环路复杂度公式为其中是有向图中的环路个数是中的有向弧数是中的节点数上图中右图中环路复杂度为上题的图注意结束点不要遗漏了虽然代码中看似没有结束点但其实是应该有的要有始有终软件维护整个软件生存周期中时间最长耗资最多的阶段软件维护类型改正性维护针对已经出现错误的修改错误已经出现用户已经发现的适应性维护指使应用软件适应信息技术变化和管理需求变化而进行的修改企业的外部市场环境和管理需求的不断变化也使得各级管理人员不断提出新信息需求预防性维护针对可能出现错误的修改错误还未发生用户还未发现的完善性维护改善性维护扩充功能和改善性能而进行的修改对已有的软件系统增加一些在系统分析和设计阶段中没有规定的功能与性能特征可维护性因素决定可理解性可测试性可修改性例题系统交付用户使用了一段时间后发现系统的某个功能响应非常慢修改了某模块的一个算法使其运行速度得到了提升则该行为属于维护改正性适应性改善性预防性软件维护工具不包括工具版本控制配置管理文档分析逆向工程理解版本控制明确属于维护工具用于代码版本跟踪如文档分析用于分析需求文档以指导维护活动逆向工程用于恢复代码设计信息以辅助理解配置管理是更广泛的管理流程需通过策略基线审计等实现其工具如更多服务于变更控制和过程管理而非直接参与代码维护软件维护工具的主要功能是辅助开发人员对代码和文档进行维护活动其核心工具包括版本控制工具如用于管理代码版本和协作开发文档分析工具分析需求设计等文档以提供维护信息如影响范围分析逆向工程工具将低抽象层次的代码转换为更高层次的设计信息如恢复程序结构再工程工具重构代码或系统以提升性能或可维护性软件文档简单了解即可按照交付目标来划分开发文档交付给项目团队内部成员可行性研究和项目任务书需求规格说明功能规格说明设计规格说明包括程序和数据规格说明开发计划软件集成和测试计划质量保证计划标准进度安全和测试信息产品文档交付给客户的培训手册参考手册和用户指南软件支持手册产品手册和信息广告管理文档交付给管理人员的文档开发过程的每个阶段的进度和进度变更的记录软件变更情况的记录相对于开发的判定记录职责定义以下关于各类文档撰写阶段的叙述中不正确的是软件需求规格说明书在需求分析阶段撰写概要设计规格说明书在设计阶段撰写测试设计必须在测试阶段撰写需求分析阶段就可以撰写测试设计测试分析报告在测试阶段撰写软件质量保证模型考试只需要能正确进行分类即可经常会考的情况是给你一个子特性让你判断它属于哪个类型的特性软件质量保证在软件质量模型中易使用性的子特性不包括易理解性易学性易操作性易分析性易分析属于维护性的子特性项目管理进度管理软考中最重要图图必考风险管理成本管理沟通管理其他配置管理人员管理进度管理只考到工具的使用图了解即可优点图能够清晰地描述每个任务从何时开始到何时结束任务的进程情况以及各个任务之间的并行关系缺点图不能清晰地反映出任务之间的依赖关系难以确定整个项目的关键所在也不能反映计划中有潜力的部分图必考关键路径分析法优点图不仅给出了每个任务的开始时间结束时间和完成该任务所需的时间还给出了任务之间的关系即哪些任务完成之后才能开始另外的一些任务以及如期完成整个工程的关键路径图中的松弛时间则反映了某些任务是可以推迟其开始时间或延长其所需完成的时间缺点图不能反映任务之间的并行关系主要有两种前导图法箭线图法关键路径法关键路径法是在制订进度计划时使用的一种进度网络分析技术参数理解关键路径从开始到结束需要时间最长的路径项目工期完成项目的最少时间注意由关键路径即最长路径决定总时差松弛时间在不延误总工期的前提下该活动的机动事件活动的总时差等于该活动最迟完成时间与最早完成时间之差或该活动最迟开始时间与最早开始时间之差关键路线法沿着项目进度网络路线进行正向与反向分析从而计算出所有计划活动理论上最早开始与完成日期最迟开始与完成日期注不考虑任何资源限制前导图法单代号网络图节点表示活动箭头表示依赖最早开始时间最早完成时间最迟开始时间最迟完成时间最早开始时间由前趋最早完成决定最大值后推最晚结束时间由后续推动最小值前推总时差最晚开始时间最早开始时间所有总时差为的路径就是关键路径例题箭线图法双代号网络图箭头表示活动圆圈数字表示状态箭头上的数字是持续时间虚线表示的虚活动持续时间为只是为了表示前驱关系例题上面的情况如果需要同一个开发人员完成和则完成该项目的最少时间为天需要考虑两种情况先再天先再天应该选择先再即天风险管理风险分类项目风险项目内部的风险技术风险技术选择过高或过于落后商业风险经济收益相关的这类包括市场接收方面的还包括社会人文道德政治等风险评估风险大小风险曝光度风险出现的概率风险可能造成的损失假设正在开发的软件项目可能存在一个未被发现的错误而这个错误出现的概率是给公司造成的损失将是元那么这个错误的风险曝光度就应为元以下叙述中不是一个风险由另一个小组开发的子系统可能推迟交付导致系统不能按时交付客户项目风险客户不清楚想要开发什么样的软件因此开发小组开发原型帮助其确定需求客户不清楚想要开发什么样的软件是已经发生的事情不是风险开发团队可能没有正确理解客户的需求项目风险开发团队核心成员可能在系统开发过程中离职项目风险以下不属于软件项目风险的是团队成员可以进行良好沟通团队成员离职团队成员缺乏某方面培训招不到符合项目技术要求的团队成员沟通管理软考只涉及到沟通路径的计算个程序员的沟通数计算无主程序员的沟通数个主程序员的沟通数在进行软件开发时采用无主程序员的开发小组成员之间相互平等而主程序员负责制的开发小组由一个主程序员和若干成员组成成员之间没有沟通在一个由名开发人员构成的小组中无主程序员组和主程序员组的沟通路径分别是和和和和成本管理主要考点是模型该模型主要用于成本估量的工作量估算模型的层次结构中估算选择不包括对象点功能点用例数源代码行',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-05-23 17:43:08',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://th.bing.com/th/id/OIP.wtmjepfWPBvn26uz7s18dgHaHa?rs=1&amp;pid=ImgDetMain"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">ZEROKO14的个人博客</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AI/" style="font-size: 1.05rem;">AI<sup>1</sup></a><a href="/tags/C/" style="font-size: 1.05rem;">C#<sup>3</sup></a><a href="/tags/C/" style="font-size: 1.05rem;">C++<sup>5</sup></a><a href="/tags/CSS/" style="font-size: 1.05rem;">CSS<sup>1</sup></a><a href="/tags/CSharp/" style="font-size: 1.05rem;">CSharp<sup>1</sup></a><a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 1.05rem;">C语言<sup>1</sup></a><a href="/tags/FPS/" style="font-size: 1.05rem;">FPS<sup>1</sup></a><a href="/tags/HTML/" style="font-size: 1.05rem;">HTML<sup>1</sup></a><a href="/tags/JavaScript/" style="font-size: 1.05rem;">JavaScript<sup>1</sup></a><a href="/tags/MFC/" style="font-size: 1.05rem;">MFC<sup>1</sup></a><a href="/tags/PE/" style="font-size: 1.05rem;">PE<sup>1</sup></a><a href="/tags/QT/" style="font-size: 1.05rem;">QT<sup>1</sup></a><a href="/tags/WPF/" style="font-size: 1.05rem;">WPF<sup>3</sup></a><a href="/tags/ai/" style="font-size: 1.05rem;">ai<sup>1</sup></a><a href="/tags/cmake/" style="font-size: 1.05rem;">cmake<sup>1</sup></a><a href="/tags/doxygen/" style="font-size: 1.05rem;">doxygen<sup>1</sup></a><a href="/tags/git/" style="font-size: 1.05rem;">git<sup>1</sup></a><a href="/tags/linux/" style="font-size: 1.05rem;">linux<sup>1</sup></a><a href="/tags/nas/" style="font-size: 1.05rem;">nas<sup>1</sup></a><a href="/tags/next/" style="font-size: 1.05rem;">next<sup>1</sup></a><a href="/tags/ppt/" style="font-size: 1.05rem;">ppt<sup>1</sup></a><a href="/tags/python/" style="font-size: 1.05rem;">python<sup>1</sup></a><a href="/tags/slidev/" style="font-size: 1.05rem;">slidev<sup>1</sup></a><a href="/tags/vue/" style="font-size: 1.05rem;">vue<sup>1</sup></a><a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 1.05rem;">代码规范<sup>1</sup></a><a href="/tags/%E5%86%85%E6%A0%B8/" style="font-size: 1.05rem;">内核<sup>2</sup></a><a href="/tags/%E5%86%85%E6%A0%B8%E7%9B%B8%E5%85%B3/" style="font-size: 1.05rem;">内核相关<sup>5</sup></a><a href="/tags/%E5%8A%A0%E8%A7%A3%E5%AF%86/" style="font-size: 1.05rem;">加解密<sup>1</sup></a><a href="/tags/%E5%9F%BA%E7%A1%80/" style="font-size: 1.05rem;">基础<sup>6</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 1.05rem;">多线程<sup>1</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F/" style="font-size: 1.05rem;">并发模式<sup>1</sup></a><a href="/tags/%E5%BC%80%E5%8F%91/" style="font-size: 1.05rem;">开发<sup>4</sup></a><a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 1.05rem;">数学<sup>1</sup></a><a href="/tags/%E6%9D%82%E9%A1%B9/" style="font-size: 1.05rem;">杂项<sup>1</sup></a><a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 1.05rem;">正则表达式<sup>1</sup></a><a href="/tags/%E7%89%A9%E7%90%86/" style="font-size: 1.05rem;">物理<sup>1</sup></a><a href="/tags/%E7%9B%91%E6%8E%A7/" style="font-size: 1.05rem;">监控<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 1.05rem;">网络<sup>3</sup></a><a href="/tags/%E9%80%86%E5%90%91/" style="font-size: 1.05rem;">逆向<sup>5</sup></a><a href="/tags/%E9%AD%94%E6%B3%95/" style="font-size: 1.05rem;">魔法<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/09/"><span class="card-archive-list-date">九月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/02/"><span class="card-archive-list-date">二月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/12/"><span class="card-archive-list-date">十二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/11/"><span class="card-archive-list-date">十一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/09/"><span class="card-archive-list-date">九月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">七月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">14</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/06/"><span class="card-archive-list-date">六月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/04/"><span class="card-archive-list-date">四月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%A1%E7%90%86/" itemprop="url">管理</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E7%AE%A1%E7%90%86/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>管理</span></a></span></div></div><h1 class="post-title" itemprop="name headline">开发项目管理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-07-16T04:06:28.965Z" title="发表于 2024-07-16 12:06:28">2024-07-16</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-05-23T09:43:08.499Z" title="更新于 2025-05-23 17:43:08">2025-05-23</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="开发项目管理"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为新加坡"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>新加坡</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://che77a38.github.io/posts/%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"><header><a class="post-meta-categories" href="/categories/%E7%AE%A1%E7%90%86/" itemprop="url">管理</a><a href="/tags/%E7%AE%A1%E7%90%86/" tabindex="-1" itemprop="url">管理</a><h1 id="CrawlerTitle" itemprop="name headline">开发项目管理</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">ZEROKO14</span><time itemprop="dateCreated datePublished" datetime="2024-07-16T04:06:28.965Z" title="发表于 2024-07-16 12:06:28">2024-07-16</time><time itemprop="dateCreated datePublished" datetime="2025-05-23T09:43:08.499Z" title="更新于 2025-05-23 17:43:08">2025-05-23</time></header><p>此处记录开发思想,项目管理,组织架构,流程标准等等</p>
<span id="more"></span>

<h1 id="项目开发的一般流程"><a href="#项目开发的一般流程" class="headerlink" title="项目开发的一般流程"></a>项目开发的一般流程</h1><p>提出需求–&gt;需求分析–&gt;概要设计–&gt;详细设计–&gt;编码–&gt;测试(内部自己测试和专门人员测试)–&gt;项目验收(提供相关上线材料)–&gt;上线(投入运营)–&gt;日常维护–&gt;版本更新(发现bug并解决bug)–&gt;下线(弃用)</p>
<ul>
<li>需求提炼</li>
<li>项目的子系统划分，每个子系统的模块分解</li>
<li>项目的开发经历、经验积累<ul>
<li>开发流程</li>
<li>项目调试</li>
</ul>
</li>
<li>第三方框架&#x2F;开源库的积累</li>
<li>锻炼快读阅读代码的能力</li>
<li>锻炼对封装好的API的快速上手能力</li>
<li>锻炼处理问题的逻辑思维能力</li>
</ul>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202212241509470.png" alt="image-20221224150907746"></p>
<p>涉及的知识</p>
<ol>
<li>网络通信  select,poll,epoll结合的多线程或多进程第三方库:libevent</li>
<li>报文编解码</li>
<li>进程间通信   socket,pipe,fifo,mmap    套接字,管道,命名管道,共享内存</li>
<li>数据库操作相关    oracle 的 occi 库   </li>
<li>QT,守护进程创建,信号相关等等</li>
<li>shell编程相关</li>
<li>加密算法相关</li>
<li>多线程开发</li>
</ol>
<p>子系统划分:</p>
<ol>
<li>秘钥协商客户端子系统</li>
<li>秘钥协商服务端子系统</li>
<li>客户端信息注册报备图形化界面系统</li>
</ol>
<p>模块划分</p>
<ol>
<li>报文编解码模块</li>
<li>网络通信模块</li>
<li>共享内存操作模块</li>
<li>数据库操作模块</li>
<li>外联接口</li>
</ol>
<h1 id="web企业开发架构"><a href="#web企业开发架构" class="headerlink" title="web企业开发架构"></a>web企业开发架构</h1><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://www.youtube.com/watch?v=Dl-BdxNRUqs" alt="教程|720x360"></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1xC411n7mL">架构讲解</a></p>
<h1 id="编程思想"><a href="#编程思想" class="headerlink" title="编程思想"></a>编程思想</h1><h2 id="什么时候需要抽象"><a href="#什么时候需要抽象" class="headerlink" title="什么时候需要抽象"></a>什么时候需要抽象</h2><p>抽象可以减少重复代码,但也会带来耦合</p>
<blockquote>
<p>**代码耦合(COUPLING)**是指代码之间的依赖关系和相互影响程度。代码耦合越高，不同部分之间的依赖性越强，修改一个部分可能会影响其他部分，导致代码难以维护和扩展。为了降低代码耦合，可以采取一些措施，比如模块化设计、接口隔离、依赖注入等。这样可以使代码更加灵活、可维护和可扩展。</p>
</blockquote>
<p>抽象和耦合如影随形</p>
<p>只有下面两种情况才真正有价值</p>
<ul>
<li>有不同的处理方式,特别是不同的处理方式需要的参数也不相同</li>
<li>该统一操作需要自动执行(调度程序不应该关注具体处理程序的种类和细节)</li>
</ul>
<blockquote>
<p>总的来说:只有当抽象化带来的价值超过耦合时,才适合应用抽象化</p>
<p>一点重复代码带来的痛苦总是比过度耦合要小</p>
<p>相对于过耦合,重复代码的技术债也总是最廉价的</p>
</blockquote>
<h2 id="命名建议"><a href="#命名建议" class="headerlink" title="命名建议"></a>命名建议</h2><p>计算机科学中只有两个难题</p>
<p><strong>缓存失效和命名</strong></p>
<h3 id="糟糕的命名模式"><a href="#糟糕的命名模式" class="headerlink" title="糟糕的命名模式"></a>糟糕的命名模式</h3><ul>
<li><p>不要以Base或Abstract命名一个类</p>
<p>如果你发现自己无法给父类起个好名字,那很可能意味着应该重新命名子类</p>
</li>
<li><p>当很多代码都放在Utils中时,请考虑重构</p>
</li>
</ul>
<p>另有一条建议:除非类型已经包含单位信息,否则请在变量中添加单位</p>
<h2 id="去除3层缩进"><a href="#去除3层缩进" class="headerlink" title="去除3层缩进"></a>去除3层缩进</h2><p>Linux代码指南中提到:如果你需要超过3层的缩进,说明你的程序已经开始混乱,应该修复你的程序</p>
<p>下面罗列了一些去除3层缩进的方法</p>
<h3 id="表驱动法"><a href="#表驱动法" class="headerlink" title="表驱动法"></a>表驱动法</h3><p>凡是可以通过逻辑语句来选择的事物,都可以通过查表法来解决</p>
<p>对于简单的语句,逻辑语句更加简单直白,但随着选项越来越多,表驱动法就更有优势了</p>
<p>优势:</p>
<ul>
<li>逻辑数据分离</li>
<li>易维护</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202405102038634.png" alt="image-20240510203824077" style="zoom: 25%;" />

<p>使用c++实现的表驱动法:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">case1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Case 1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">case2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Case 2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">case3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Case 3&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, <span class="type">void</span>(*)()&gt; cases = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, case1&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>, case2&#125;,</span><br><span class="line">        &#123;<span class="number">3</span>, case3&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> input;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter a case number (1-3): &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; input;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cases.<span class="built_in">find</span>(input) != cases.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        cases[input]();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Invalid case number&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="提早返回"><a href="#提早返回" class="headerlink" title="提早返回"></a>提早返回</h3><blockquote>
<p>防御性编程:子程序应该不因传入错误数据而破坏,哪怕是由其他子程序产生的逻辑错误</p>
<p>此时通过早退出或早返回可以简化复杂的参数验证</p>
</blockquote>
<p>使用断言的话,甚至能省去参数验证的if语句</p>
<p>甚至还可以将参数验证提取出来作为一个独立的函数也是不错的选择</p>
<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>多态调用其实类似switch分支(如图)  </p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202405102045524.png" alt="image-20240510204522433" style="zoom:25%;" />

<p>多态能把分支逻辑隐藏起来,所以利用面向对象的多态加上<a href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F">工厂模式</a>,可以将分支逻辑分离并独立出来,让主逻辑更加清晰</p>
<h2 id="优秀的程序设计思想"><a href="#优秀的程序设计思想" class="headerlink" title="优秀的程序设计思想"></a>优秀的程序设计思想</h2><h3 id="分离逻辑层和表示层"><a href="#分离逻辑层和表示层" class="headerlink" title="分离逻辑层和表示层"></a>分离逻辑层和表示层</h3><p>由于表示层和业务逻辑相互独立，在程序维护阶段所需要做出的变化将变得相当容易。分离了表示层和业务逻辑的程序也很容易被测试</p>
<h3 id="代码清晰化表达"><a href="#代码清晰化表达" class="headerlink" title="代码清晰化表达"></a>代码清晰化表达</h3><p>在字典和创建新类传达数据的情况下,选择创建新类</p>
<p>因为字典很不明确。你根本就无法得知字典里关键字的真实意思。字典不能确定称买东西的人是顾客还是客户？即使是拼写错误也无法检查出来。更重要的是，即使你看完代码还是不能回答这样的问题：“访问这些数据的接口是什么？通过这些数据我能得到什么?”所以说，字典是很不明确的。而使用类的话——即使你不得不重写所有成员变量及其访问函数——一切就变得明确起来。这时只需要查看源代码就知道这些数据是什么了。</p>
<h3 id="公共接口与发布接口"><a href="#公共接口与发布接口" class="headerlink" title="公共接口与发布接口"></a>公共接口与发布接口</h3><p>作为一个从头开发大型系统且人数众多的团队的管理者，首要任务是将系统分成几个主要的子系统，然后定义这些子系统的接口。这些接口在某种程度上就是对外发布的接口。</p>
<p>接口并不是不能被改变。相反，最初要经常改变接口，随着时间的推移，需要改动的地方越来越少。原因很简单，接口随着时间的推移而成熟。除此以外，随着时间的推移，越来越多的代码绑定在这些接口上，并且开发者对接口越来越熟悉。当到达某个点的时候，你就会说，“好吧，这就是接口。我们往下走吧。”</p>
<h3 id="强代码所有权和弱代码所有权"><a href="#强代码所有权和弱代码所有权" class="headerlink" title="强代码所有权和弱代码所有权"></a>强代码所有权和弱代码所有权</h3><blockquote>
<p><strong>马丁：</strong>我把代码所有权分为三类。在极限编程中用到的代码所有权有时称为集体代码所有权，有时也可以说“无代码所有权”。在这种所有权中，团队中任何人都不具有对代码的所有权。也就是说，任何成员可以在任意时间内改动系统中的任何代码。这就是极限编程采取的方式。</p>
</blockquote>
<p>和这种所有权相对立的是强代码所有权。在强代码所有权中，严格区分我的代码和你的代码，我不能改动你的代码。当我想改动我的某个方法的名字时，如果这个方法被你的代码所调用，那么我就必须先通知你，让你先把所有调用代码改过来，然后我才可以改动这个方法的名字。另一种办法就是，我得将这个方法“过期化”（deprecation），然后完成后面一系列的步骤。实际上，在这种情况下，因为我绝对不能碰你的代码，因而你所用过的我的任何接口都是发布的。</p>
<p>弱代码所有权则介于两者之间。弱代码所有权中，还是会区分代码的所有者，不同的是它允许开发者改动其他人的代码。开发者对自己的代码质量仍然负有责任。如果我想要改变我的代码中某个方法的名称，改就好了。不过，假如我想将某个类的功能转赋到另一个类上，而这些代码的所有权属于你，那么至少 在这么做之前我应该让你知道。这一点是和集体代码所有权不同的。</p>
<p>不论是在弱代码所有权下，还是集体代码所有权下，都可以进行代码的重构。但是在强代码所有权下进行重构是个问题，因为你想做的许多重构根本就无法进行，比如，你不能去改动别人的调用代码。这就是<strong>强代码所有权下不适合做重构而弱代码所有权下可以做重构</strong>的原因。</p>
<h1 id="计划型设计和进化型设计"><a href="#计划型设计和进化型设计" class="headerlink" title="计划型设计和进化型设计"></a>计划型设计和进化型设计</h1><blockquote>
<p>设计强调的是构造——将程序划分为若干分割清晰的部分</p>
</blockquote>
<p><strong>马丁：</strong>我将设计区分为计划型设计和进化型设计。当开发者着手实施一个软件时，他首先需要做设计，然后再按照这个设计进行编码实现软件，这就是我所说的计划型设计。计划型设计可能借助UML；或者把整个系统分为若干子系统，定义这些子系统间的接口。在计划型设计中，在设计和代码实现这二者之间存在明确的切换。而这二者又往往由不同的人来完成。架构师构思设计，开发者编码实现。做好的设计并不是说一点都不能改变，但基本上是固定的。你可能会说，设计做得越好，在编码的时候，就会越少对设计做出改动。</p>
<p>而在进化型设计中，开发者在编程实践的过程中逐渐完善设计。刚开始的时候并没有设计，而是先实现一些小的功能。随着实现的功能越来越多，设计才逐渐成型。</p>
<p>我在《设计是否已死》一文中想要强调的是，很多人在尝试进化型设计时，往往是在一种无约束无原则的环境里，最终的设计必然很蹩脚。这是人们之所以倾向于计划型设计的原因之一。</p>
<p>但是，在我看来，极限编程实践中，通过持续不断的集成、测试和重构，进化型设计能够做到比计划型设计更有效。计划型设计的弱点就是，要想做出一个好的设计非常难。</p>
<p>有趣的是，很多进化型设计的倡导者，比如肯特·贝克和沃德·坎宁安，都是非常出色的设计师。但正是他们，最后认识到自己所做的预先设计往往不够好。他们容易把一些事情过于工程化，在不需要灵活性的地方设计灵活性，而在需要灵活性的地方又未予以考虑。因此，他们最终采用了进化型设计，并通过运用一套规则，保证了设计效果。其结果是，不但最终的设计更加出色，并且速度也加快了。拿我自己来说，80％左右的时间里，进化型设计会得到不错的结果。 而不客气地说一句，我认为我的设计水平要比一般人高。因此，我认为进化型设计应该可以适用于更广泛的人群。</p>
<p><a href="#%E9%87%8D%E6%9E%84">重构</a>改变了预先设计的地位,其正是进化型设计的关键</p>
<h1 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h1><p>下面相关内容摘自&lt;&lt;对话软件大师_-_Martin_Fowler&gt;&gt;</p>
<p>重构就是对代码本身做出修改，以改善它的内部结构，但又不改变它的外部表现</p>
<blockquote>
<p>优势:</p>
<p>重构改善了设计。而一个良好的设计，其商业目的何在？我认为，它使你能在<strong>未来更容易地对软件作出改动</strong>。</p>
<p>重构实际上是在说，“来吧，让我们把系统结构重新调整一下，好让将来的任何改动都更容易些。”其潜台词是，如果你不会改动你的系统，那么也就没有必要做重构，因为不会有任何回报。但如果你将要对你的系统作出改动;不管是消除漏洞也好，还是添加新功能也好;那么，一个好的或更好的系统结构，会使你在做修改时有所受益。</p>
<p>Q: 重构是如何帮助你提高编程速度的呢？</p>
<p><strong>马丁：</strong>因为一个设计良好的程序，修改起来会更容易。程序的设计越好，修改起来就越容易，从而提高了效率。</p>
</blockquote>
<p><strong>马丁：</strong>对程序进行改动是主要的动因。我们不得不经常对软件作出一些改动;只要这个软件还在使用。重构是用来改善设计的。 我们需要一个好的设计以使任何改动都更容易些。重构跟性能优化有些类似，都是在行为不变性（behavior-preserving）前提下的改进。不过，性能优化的步骤有异于重构，整个过程也有所不同，因为性能优化的驱动要素是性能分析（profiling）</p>
<p>重构使得事情一瞬间清晰起来，因而你能够一眼就看出漏洞所在。</p>
<blockquote>
<p>人们不注重设计的一个原因是由于工作的流动性。程序员因为自己的糟糕设计而自食其果的情况很少发生，因此他们没有足够的动因去注重设计。此外，即便他们注重，但设计毕竟是一项费力不讨好的工作，好的设计需要时间，而开发中的时间压力往往很大。</p>
<p>但保持代码的良好构造以及编写测试反而能加快工作速度,人们把改进设计所花的时间看作是“失去”的时间，但却没有看到将来对代码的改动会容易得多，往往只需要几分钟的时间，否则可能要花上两三个小时</p>
<p>人们往往还低估了在调试上所花的时间，低估了他们用来追踪一个“潜伏”很久的漏洞所花的时间。我在写代码的时候可以立即察觉产生的漏洞， 这使得我能在它潜伏下来之前就解决它。没有几件事比调试更花时间和更令人沮丧的了</p>
</blockquote>
<h2 id="重构是如何改进设计的呢？"><a href="#重构是如何改进设计的呢？" class="headerlink" title="重构是如何改进设计的呢？"></a>重构是如何改进设计的呢？</h2><p>比如，提取方法（Extract Method）通过把一个很长的、令人费解的方法拆分成一些小方法来改进设计。改进后的方法读起来就像是一份文档;一张调用那些小方法的列表。</p>
<p>每种重构方法都会对针对某些特定的设计元素做出改进。应用的时候要具体情况具体分析。很多重构方法都能找到相对立的另一个重构方法。比如，如果一个方法，除了方法本身的代码所表达的意义之外，没有任何附加的含义，那么你可能会内联它。内联方法（Inline Method）与提取方法就是对立的。很多时候，到底应用哪种方法取决于具体情况。</p>
<ul>
<li>提取出一个函数</li>
<li>内联就是直接用原本的代码,不用函数封装</li>
</ul>
<p>简单系统的四个条件</p>
<ol>
<li>通过所有的测试</li>
<li>揭示所有的意图</li>
<li>没有重复代码</li>
<li>使用最少的类和方法</li>
</ol>
<h2 id="重构与重写"><a href="#重构与重写" class="headerlink" title="重构与重写"></a>重构与重写</h2><p>如果你有一堆乱七八糟的代码且又没有测试，那么你最好是扔掉它们从头开始，否则你就得重新做所有的测试。反之，如果你有一堆乱七八糟的代码同时还有很多测试的话，情况就不一样了。假如代码中满是漏洞，那么在行为不变性下，不管怎么变换，那些漏洞 都会被保留下来。这时，是否重构就是一个值得争论的问题。我想，这个问题的答案也会随着你对重构熟悉程度的深入而改变。随着对重构越来越有信心，你可能会对以前想要重写的一些东西改用重构，因为你有更强的重构能力了</p>
<p>在某些时刻，如果代码完全没有结构，那么重写是比重构更有效的一种方法。</p>
<p>因此在决定重写代码之前，也许值得花些时间在重构上，来看看能做多少改进</p>
<p>&lt;&lt;重构&gt;&gt;一书里有句话: 如果打算重构，那么最基本的前提是有完善的<a href="#%E6%B5%8B%E8%AF%95">测试</a> (<strong>测试对于重构来说，是非常重要的支撑</strong>)</p>
<h2 id="灵活性与复杂性"><a href="#灵活性与复杂性" class="headerlink" title="灵活性与复杂性"></a>灵活性与复杂性</h2><p><strong>比尔：</strong>在《重构》一书中你写道：“在学会重构之前，我总是力图找到灵活的方案。因为设计变动的代价非常高，因而我希望我的设计能够胜任我所能预知的变化。但问题是，灵活性是有代价的。”那么，灵活性的代价是什么？有什么解决之道么？</p>
<p><strong>马丁：</strong>灵活性的代价就是复杂性。每次当你往代码中加入一些额外的东西以提高灵活性时，通常也使你的代码变得更加复杂。假如你的预期是对的，未来确实需要这种灵活性，那么你的超前工作得到了回报。但如果你的预期是错的，那么你所引入的复杂性将使软件变得更加难以改动，因而该灵活性是毫无意义的。</p>
<p>而这种预期是很容易出错的。比如，当需求发生变化时，你所以为的对灵活性的需求可能随之变化甚至有可能不复存在。再比如，你添加了一些额外的代码，指望它们能提高灵活性，但这些代码本身就有问题。结果是既增加了复杂性，又未能实现灵活性，真是“赔了夫人又折兵”。</p>
<p>而解决之道就是极限编程。事实上，你<strong>根本就不需要考虑灵活性</strong>。极限编程理论认为，既然我们的预期在大多数情况下都是错的，那么就把灵活性放在一边好了。那种冒进式的提升设计的办法是拔苗助长；平稳地改进设计才是可取之道。事实上，设计的改进是一个自我强化（self-reinforcing）的过程。如果你能够使设计尽可能简洁，避免那些无谓的灵活性，那么你所要面对的复杂性就会小很多，也就越容易对代码做出改动。代码会更容易被读懂和被改动，你也能够更快地对软件做出调整。</p>
<blockquote>
<p>不要试图一开始就定义一个可重用的框架然后在此基础上开发应用，相反，应该是在开发过程的过程中，逐渐形成和完善框架。</p>
</blockquote>
<h2 id="重构实例参考"><a href="#重构实例参考" class="headerlink" title="重构实例参考"></a>重构实例参考</h2><p>在写《企业应用架构模式》（Patterns of Enterprise Applications Architecture Design）这本书的时候，曾碰到过这样一个增量式设计的例子。当时，我需要构建一个关联表映射（associative table mappings）的模式实例。假如在内存中你有一个多对多的关系，并且需要把它持久化到一个关系型数据库中。这时，你需要一个额外的连接表。因此一共有三张表。有很多种方法可以将数据从数据库中读入到内存里：有一种比较简单的办法，但是需要执行多个 select 语句；也有一种比较快的方法，可以只用一个 select 语句，但是当需要把返回的数据提取出来并拆分到不同的对象中时，就会很别扭。</p>
<p>我用增量式设计构建了这个模式实例。起先，我针对三张具体的表和两个具体的类编写了一段写死的代码，根本就没有考虑通用化的问题。我只是让这个非常特定、具体的例子能够运行起来。在通过测试之后，我着手重构这个例子以使它的应用范围更广一些。花了一点时间之后，我就得到了一个通用的机制。 我所要做的一切，就是写一个很小的映射类，就能够让这个例子对任意的表和类都适用。</p>
<p>我发现，从具体的实例入手然后再把它重构成一个抽象的例子是非常容易的；反之，如果从抽象的例子入手而把它应用到具体的案例中，则要困难得多。我还发现，前者会给人一种更平静和从容的感觉，而实际的进展又非常之快。我能够始终清楚目前我在哪里，又在做什么。我对进度的把握也更加得心应手， 再也不会有那种“何时才能让这段代码运转起来”的无力感。</p>
<p>上面有个很重要的概念</p>
<p><strong>单一思考</strong></p>
<p>“单一”是指在任一时刻，都只使用一种逻辑，一种思考模式。当我构建前面提到的那个例子时，我只考虑如何使那个很具体的例子运行起来；而当我进入到重构阶段时，我只考虑如何抽象化那个具体的例子。我不会同时去考虑两件事情；一次只做一件事情。我发现这样做的体验非常宁静而愉快</p>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><blockquote>
<p><strong>马丁：</strong>没有测试支撑的重构，就如同不系安全带走钢丝。如果你很擅长走钢丝，而且钢丝又不是悬得很高的话，那不妨试试。但如果你从没走过钢丝，而钢丝又是悬在尼亚加拉瀑布上空，那你最好还是有个保靠的安全带</p>
</blockquote>
<p>类似 JUnit 的测试的最大好处就是让你能通过运行它们看看是否有什么东西被破坏了。如果你不打算碰你的代码，那当然平安无事；但只要你加新的功能或是修补漏洞，那么你就有可能破坏某些东西。你的测试越完善，你对能做的改动就越有信心。最终，你能实现比较高的可靠度</p>
<p><strong>以测试为基础的可靠性是极限编程中不大被人们注意的要点之一</strong></p>
<p>测试能提高鲁棒性、质量和可靠性</p>
<blockquote>
<p><strong>鲁棒性</strong>是指系统在面对不同环境、输入或干扰时能够保持稳定和可靠的性能。在计算机科学中，鲁棒性通常用来描述算法或系统对于错误、异常情况或变化的处理能力。一个鲁棒性强的系统能够有效地处理各种情况而不会崩溃或产生不可预测的行为。</p>
</blockquote>
<p>花在写测试上的时间，可以因为不用修补漏洞而补回来,因为花在跟踪调试上的时间大大减少了。花在测试上的成本很快就能收回。随之而来的还有其它好处</p>
<p>通过添加一些测试，你能很快获得回报，因为你开始发现问题了。如果你把测试集中在你需要做改动的代码部分，那么当你犯错误的时候，测试会告知你这些错误。显然，全面综合的测试会使你受益最大；但是，就算只写几个测试，你也会从中受益。</p>
<p><strong>针对包含漏洞的代码段编写单元测试，是一种很好的调试技术。其带来的好处，不仅仅是让你对代码的理解更深刻，还让你建立起测试库，从而意味着将来不会有问题发生。</strong></p>
<p><strong>测试优先设计</strong>会使你体会到一种难以言传的从容不迫之感。你的进展其实非常快，但却不会让你感到很紧张，因为你为自己设定的都是一些<strong>微目标</strong>（micro-goals）。在每个时间点上，你知道自己是在实现某一个微目标。一旦测试通过，该目标就实现了。这是一种很平和的过程。它缩小了你的关注范围。你不需要去考虑每一件事情，只需要专注于某一小块功能。你实现了这个功能，然后重构它，使得其中每个环节的设计都近于完美。然后再进行下一步。我以前用的是你所描述的方法，我不得不常常问自己，“这个东西的接口是什么？”而现在，我转向了<strong>增量式设计</strong> （incremental design），并且觉得这种方式要大大优于之前的方法。</p>
<h2 id="测试与接口"><a href="#测试与接口" class="headerlink" title="测试与接口"></a>测试与接口</h2><p>这是一个潜移默化的过程——你的的确确是在构思接口，而且是以一种渐进的方式。你不会对自己说，“啊，我需要构造这个类，让我们来把这个类的所有接口都搞清楚，然后再实现之吧！”相反，你会说，“嗯，这个类需要实现这么一小块功能。来为此写个测试吧！”在编写测试的时候，接口就随之浮现出来。</p>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>Q: 单元是什么意思</p>
<p><strong>马丁：</strong>哦，这很难。最粗略地讲，它是一个类。但随着你与之打交道越多，你就会意识到你是在测试功能 的一小块区域，而这一小块区域有可能是一个类的一部分，也有可能是几个类合起来的作用。我这里只是粗略地一说，不过，如果你想开始试试的话，可以把单元测试看成是为每个类编写个测试案例。</p>
<h1 id="性能与调优"><a href="#性能与调优" class="headerlink" title="性能与调优"></a>性能与调优</h1><h2 id="可维护性与效率"><a href="#可维护性与效率" class="headerlink" title="可维护性与效率"></a>可维护性与效率</h2><p>比尔:记得当时你曾对我说过，应该以程序员能读懂的字符格式来序列化对象，而不是以二进制代码格式。当我提到字符格式要比二进制码格式慢时，你说，从效率的角度来看，二进制代码格式使得软件更加难以维护。那么，能否请你谈谈关于序列化方式的具体案例？一般地说，你如何在可维护性与效率之间寻找平衡点？</p>
<p><strong>马丁：</strong>效率永远是第一位的，前提是你能正确理解它。很多时候问题在于，人们以为做某些事情是为了效率着想，但他们却从不使用<strong>性能分析器（profiler）</strong>。如果你出于效率的考虑而做某件事，但却不使用性能分析器，那么你所宣称的根本就不着调。</p>
<p>序列化所牵扯的问题要多一些。使用二进制代码做序列化的问题之一就是你无法去查看结果。当你需要存储序列化的对象时，这个问题就更加突出。Java的一个典型问题就是如果你改变了一个类，那么就无法读取以前所序列化的对象。类似的，如果一个客户端和一台服务器正通过序列化的对象进行通讯，假如一端的数据结构进行了更新而另一端没有，那么整个通讯就彻底失效了。</p>
<p>有一个小窍门可以让你绕开这个问题。不要序列化对象本身，而是把数据从对象中提取出来，放到一个字典里，然后再序列化那个字典。这么做会使你能够应对一些变化。</p>
<p><strong>比尔：</strong>但是，字典是“不明确的”。我们之前刚刚说起过这点。</p>
<p><strong>马丁：</strong>的确，字典不是“明确的”。不过，如果你往类里添加一个字段，并把这个多出来的值放到字典里的话，不会有什么问题。因此，这是一个比较强壮的机制。XML一般也比较强壮，因为你可以对你所不了解的数据视而不见。二进制序列化的主要问题就是它的脆弱性。在我的书《企业应用架构模式》中，更多地提到了序列化的方式。例如，在数据库中传输和存储数据时，就需要考虑介于字符和二进制之间的序列化格式。</p>
<p><strong>编写可性能调优的软件</strong>实际上就是编写结构合理的软件</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p><strong>马丁：</strong>还有一件事需要牢记：<strong>性能优化与版本和具体的实现是密切相关的</strong>。当你拿到Java 的一个新版本时，一定要把以前所做的优化都撤消，然后重走一遍优化过程，以确保那些优化手段仍然奏效。通常你会发现，你为上一个版本的虚拟机 （virtual machine）或优化型编译器（optimizing compiler）所做的性能优化往往使当前的版本变慢，也即，之前的优化手段如今往往起到适得其反的作用。</p>
<p><strong>比尔：</strong>要记住以前为了提升性能都做了哪些改动可不是件容易的事情。</p>
<p><strong>马丁：</strong>你必须这么做——先撤销，再重新应用。我知道这不容易。这就要求你对优化过程中所做的每个改动都要有详细的记录。要知道，旧的优化所造成的一些微不足道的性能损失，在新的版本下有时候可能会变得非常显著。</p>
<p>Craig Larman（拉曼 C [3]） 曾经讲过一个故事，我到现在都还很喜欢这个故事。Craig 有一次在JavaOne的大会上做性能优化的讲座。他提到了两个广为人知的技术：对象池（object pooling）和线程池（thread pooling），对象池就是重用已有的对象，而不是每次都创建新的对象，线程池的原理基本类似。讲座结束后，有两个人来到Craig跟前。这两个人都是设计高性能虚拟机的。其中一个虚拟机是Hotspot，另一个好像是 JRocket。一个人告诉 Craig，线程池的效果不错，但对象池则使得虚拟机的运行变慢；而另一个人告诉Craig 的恰恰相反。</p>
<blockquote>
<p>对象池是一种设计模式，用于管理和重复利用对象实例，以提高性能和减少资源消耗。在对象池中，对象实例被预先创建并存储在一个池中，当需要时可以从池中获取对象实例，使用完毕后再放回池中，而不是频繁地创建和销毁对象实例。这样可以减少内存分配和垃圾回收的开销，提高系统的性能和效率。对象池常用于需要频繁创建和销毁对象实例的场景，例如线程池、数据库连接池等。</p>
</blockquote>
<p>所以，你有可能在一种虚拟机上优化了性能，但拿到另一种虚拟机上，却减慢了其运行速度。对此，你要特别小心。对象池就是一个很好的例子。 很多人热衷于对象池，但起码有一半的情况下，人们并不去测量对象池的效果到底是好是坏。在Java的早期日子里，对象池非常重要，因为垃圾回收（garbage collection）功能还不是很完善。但在垃圾回收技术更新换代之后，对象池的效果就大大降低了，因为那些生存周期很短的对象可以被低成本地回收。只有那些生存周期很长的对象，才适合使用对象池技术，因为对它们进行垃圾回收的成本很高。</p>
<p>从这里可以看出，规则也是在不断变化的。这就是为什么要对性能调优很仔细的原因所在。不要妄想根据源代码就能预测机器会做什么。当你与虚拟机或优化型编译器打交道时，性能调优是唯一的手段，因为编译器和虚拟机所做的事情，远远超出你的想象。<strong>记住，不要预测，要实测。</strong></p>
<h1 id="敏捷宣言"><a href="#敏捷宣言" class="headerlink" title="敏捷宣言"></a>敏捷宣言</h1><p>敏捷宣言中的<strong>四条核心价值观</strong></p>
<ol>
<li><p>个体和互动重于流程和工具 </p>
<p>这条原则大意是说，与其借重过程和工具来加强对软件开发的管理，不如更多地关注于团队及其成员，关注于每个个体以及他们之间在个人层面上的交互。它包括了提升技能；它还包括要竭尽全力使程序员们身心愉悦，从而得以留住人才；它还意味着更认真地对待个性冲突，注重人与人的相处，而不是试图找出某个完美的软件开发过程，然后要求大家都来遵守这个过程。我对这条原则的理解是，应该是团队选择适合其的软件开发过程，而不是让团队来适应指定的开发过程</p>
</li>
<li><p>可工作的软件重于详尽的文档 </p>
</li>
<li><p>客户合作重于合同谈判 </p>
</li>
<li><p>响应变化重于遵循计划 这四条原则指导着敏捷团队在软件开发过程中注重人与沟通、可交付的软件产品、与客户合作和适应变化。</p>
</li>
</ol>
<blockquote>
<p>马丁:尽管在那次聚会上，我们中的许多人都津津乐道于自己所采用的开发过程，并且我们当中的几个人还是软件工具销售商，但我们一致同意，<strong>对于一个项目的成功来说，软件开发过程和工具只是次要的因素，最主要的因素还是团队，是团队中的成员，是他们人性化的合作与努力</strong>。 </p>
</blockquote>
<h1 id="代码设计原则"><a href="#代码设计原则" class="headerlink" title="代码设计原则"></a>代码设计原则</h1><p>[[设计模式#面向对象设计原则|完整的6个设计原则]]</p>
<h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p>OCP</p>
<p>开闭原则规定，软件实体（如类或模块）应该：</p>
<ul>
<li><strong>开放</strong> 扩展：可以在不修改源代码的情况下添加新功能。</li>
<li><strong>封闭</strong> 修改：实体不应该被修改以影响其现有功能。</li>
</ul>
<p>换言之，开闭原则规定，软件实体应该被设计为允许添加新功能，而不需要修改其底层结构。</p>
<p><strong>OCP 的优点：</strong></p>
<ul>
<li>提高灵活性：新功能可以被添加，而不需要修改现有代码。</li>
<li>减少耦合：实体被解耦合，使得维护和演进变得更容易。</li>
<li>提高可扩展性：实体可以被扩展以满足新要求，而不影响其现有功能。</li>
</ul>
<h2 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h2><p>DIP</p>
<p>依赖倒置原则规定：</p>
<ul>
<li>高级模块不应该依赖低级模块，而应该依赖抽象。</li>
<li>抽象不应该依赖细节，细节应该依赖抽象。</li>
</ul>
<p>换言之，DIP 规定，高级模块不应该依赖低级模块，而应该依赖抽象。这个抽象可以是一个接口或抽象类。</p>
<p><strong>DIP 的优点：</strong></p>
<ul>
<li>减少耦合：高级模块被解耦合，使得维护和演进变得更容易。</li>
<li>提高灵活性：系统变得更加模块化和易于扩展。</li>
<li>提高可扩展性：系统可以更容易地扩展，以满足新要求。</li>
</ul>
<h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p>ISP</p>
<p>接口隔离原则规定：</p>
<ul>
<li>客户端不应该被迫依赖它不使用的接口。</li>
<li>相反，接口应该被设计以满足特定客户端的需求。</li>
</ul>
<p>换言之，ISP 规定，接口应该被设计以满足特定客户端的需求，而不是强迫客户端依赖一个大型的通用接口。</p>
<p><strong>ISP 的优点：</strong></p>
<ul>
<li>减少耦合：客户端被解耦合，使得维护和演进变得更容易。</li>
<li>提高灵活性：接口被设计以满足特定客户端的需求，使得添加新功能变得更容易。</li>
<li>提高可扩展性：系统变得更加模块化和易于扩展。</li>
</ul>
<h1 id="软件开发方式"><a href="#软件开发方式" class="headerlink" title="软件开发方式"></a>软件开发方式</h1><h2 id="测试驱动开发-TDD"><a href="#测试驱动开发-TDD" class="headerlink" title="测试驱动开发 (TDD)"></a>测试驱动开发 (TDD)</h2><p>测试驱动开发是一种软件开发方法，它强调在编写代码之前先编写测试用例。这个过程可以分为三个步骤：</p>
<ol>
<li>编写测试用例：首先，开发者编写测试用例，以确保代码满足要求。</li>
<li>运行测试用例：然后，开发者运行测试用例，以确保代码通过测试。</li>
<li>编写代码：最后，开发者编写代码，以使其通过测试用例。</li>
</ol>
<p>TDD 的优点包括：</p>
<ul>
<li>提高代码质量：TDD 确保代码满足要求，减少 bug 的可能性。</li>
<li>提高开发速度：TDD 帮助开发者快速编写代码，减少 debug 时间。</li>
<li>提高代码可维护性：TDD 使得代码更易于维护和更新。</li>
</ul>
<h2 id="行为驱动开发-BDD"><a href="#行为驱动开发-BDD" class="headerlink" title="行为驱动开发 (BDD)"></a>行为驱动开发 (BDD)</h2><p>行为驱动开发是一种软件开发方法，它强调在编写代码之前先定义软件的行为。这个过程可以分为三个步骤：</p>
<ol>
<li>定义行为：首先，开发者定义软件的行为，以确保软件满足要求。</li>
<li>编写测试用例：然后，开发者编写测试用例，以确保软件行为正确。</li>
<li>编写代码：最后，开发者编写代码，以使其满足软件行为。</li>
</ol>
<p>BDD 的优点包括：</p>
<ul>
<li>提高软件质量：BDD 确保软件满足要求，减少 bug 的可能性。</li>
<li>提高开发速度：BDD 帮助开发者快速编写代码，减少 debug 时间。</li>
<li>提高软件可维护性：BDD 使得软件更易于维护和更新。</li>
</ul>
<h1 id="制造业相关流程标准"><a href="#制造业相关流程标准" class="headerlink" title="制造业相关流程标准"></a>制造业相关流程标准</h1><h2 id="FA功能开发流程"><a href="#FA功能开发流程" class="headerlink" title="FA功能开发流程"></a>FA功能开发流程</h2><p>​	1.	<strong>客户需求调研分析</strong>：理解客户的业务需求，评估现有的工厂流程，并确定自动化系统需要实现的功能和目标。</p>
<p>​	2.	<strong>设备与客户环境的对接</strong>：按照 SECS&#x2F;GEM 等 SEMI（Semiconductor Equipment and Materials International）标准，开发接口和通讯协议，使工厂设备能够与客户的自动化环境进行无缝集成。</p>
<p>​	3.	<strong>软件需求分析和方案设计</strong>：根据客户需求，制定详细的功能需求文档和技术方案，设计软件架构和模块。</p>
<p>​	4.	<strong>代码编写和单元测试</strong>：根据设计方案编写软件代码，并进行单元测试，以确保各个模块的功能正确性和稳定性。</p>
<p>​	5.	<strong>现场测试</strong>：在客户现场进行系统集成测试，验证软件在实际操作环境中的性能，并解决出现的问题。</p>
<p>​	6.	<strong>文档编写</strong>：编写相关的技术文档和用户手册，详细记录系统功能、操作指南、维护步骤等。</p>
<p>​	7.	<strong>其他任务</strong>：根据公司需求，完成其他相关的开发或支持工作。</p>
<p>FA 功能开发的目标是通过软件和自动化技术来优化生产过程，提高生产效率，降低成本，并确保产品的一致性和质量。这在现代制造业，尤其是半导体、汽车制造、电子装配等行业中显得尤为重要。</p>
<h2 id="SEMI标准"><a href="#SEMI标准" class="headerlink" title="SEMI标准"></a>SEMI标准</h2><ol>
<li><strong>SECS&#x2F;GEM</strong>：<ul>
<li>**SECS (SEMI Equipment Communications Standard)**：定义了半导体制造设备与工厂计算机系统之间的通信协议。SECS 标准包括 SECS-I 和 SECS-II，其中 SECS-I 是基于 RS-232 的通信协议，SECS-II 则定义了数据内容和格式。</li>
<li>**GEM (Generic Equipment Model)**：基于 SECS 标准的扩展，定义了通用设备模型，提供了标准化的设备控制和状态报告接口。GEM 标准使工厂管理系统能够更容易地控制和监控不同制造设备。</li>
</ul>
</li>
<li>**EHS (Equipment Health Standards)**：包括 E10、E58 等标准，专注于设备的健康管理，提供了一套用于监控和报告设备状态的方法，以提高设备的可用性和可靠性。</li>
<li><strong>PV（Photovoltaic）标准</strong>：涉及太阳能电池和光伏组件制造，涵盖从材料、制造过程到最终产品的标准化。</li>
<li><strong>Interface A</strong>：提供了一种标准化的方法，用于在不同供应商的设备和工厂管理系统之间交换过程数据，以实现更好的数据分析和制造优化。</li>
<li><strong>其他领域</strong>：SEMI标准还包括材料处理、设备设计、环境、健康和安全（EHS）、技术文档、测试方法等各个方面。</li>
</ol>
<p>这些标准的主要目标是促进半导体制造过程中的兼容性和互操作性，减少因不同设备和系统之间不兼容带来的问题，从而提高整体生产效率和产品质量。SEMI 标准通过详细的技术规范和操作指南，为半导体和相关行业提供了一个共同的基础，确保了全球制造和供应链的协同运作。</p>
<h1 id="表现模式-设计模式-架构模式"><a href="#表现模式-设计模式-架构模式" class="headerlink" title="表现模式&#x2F;设计模式&#x2F;架构模式"></a>表现模式&#x2F;设计模式&#x2F;架构模式</h1><ul>
<li><p><strong><a href="#%E8%A1%A8%E7%8E%B0%E6%A8%A1%E5%BC%8F">表现模式</a>（Presentation Pattern）</strong></p>
<p>通过分离关注点来改进代码的组织方式。表现模式侧重于解决代码组织，往往使用了多种设计模式，因此其也称作复合设计模式。</p>
<p><a href="#MVC">MVC&#x2F;MVVM</a>属于这种</p>
</li>
<li><p><strong>设计模式（Design Pattern）</strong></p>
<p>为了解决一类问题而总结出来的抽象方法。</p>
</li>
<li><p><strong><a href="#%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F">架构模式</a>（Architecture Pattern）</strong></p>
<p>描述软件系统里的基本的结构组织或纲要。架构模式提供一些呈现定义好的子系统，指定它们的责任，并给出把它们组织在一起的法则和指南。</p>
<p><a href="#%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84">三层架构</a>属于这种</p>
</li>
</ul>
<p>架构模式和表现模式是可以共存的</p>
<h1 id="架构模式"><a href="#架构模式" class="headerlink" title="架构模式"></a>架构模式</h1><h2 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>三层架构以高内聚、低耦合的思想，把程序的各个功能模块划分为<strong>三层架构</strong>,分别是</p>
<ul>
<li><strong>表示层（UI）</strong></li>
<li><strong>业务逻辑层（BLL）</strong></li>
<li><strong>数据访问层（DAL）</strong></li>
</ul>
<p>三层架构的分层模式是典型的<strong>上下关系</strong>,并且是上层依赖于下层.在三层架构的隔层模块之间,通过对象模型的实体类(Model)作为数据传递的载体,不同的对象模型的实体类一般对应于数据库的不同表,实体类的属性与数据库表的字段名一致</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202406121744784.png" alt="image-20240612174421140" style="zoom:25%;" />

<h3 id="三层架构的优势"><a href="#三层架构的优势" class="headerlink" title="三层架构的优势"></a>三层架构的优势</h3><ul>
<li><strong>高内聚、低耦合</strong>，可以降低层与层之间的依赖。</li>
<li>各层互相独立，完成自己该完成的任务，项目可以多人同时开发，开发人员可以<strong>只关注</strong>整个结构中的其中某一层。</li>
<li><strong>容易移植、维护</strong>，如B&#x2F;S转C&#x2F;S、SQL Server 转 Oracle、添加、修改、删除等。</li>
<li><strong>有利于标准化和各层逻辑的复用</strong>。</li>
<li><strong>安全性高</strong>。用户端只能通过业务逻辑层来调用数据访问层，减少了入口点。</li>
</ul>
<p>三层架构模式是一种<strong>基于业务逻辑来分的软件架构模式</strong>,是一种<strong>整体的软件架构</strong></p>
<p>MVC&#x2F;MVVM等表现模式是<strong>基于页面划分的一种复合设计模式</strong>,是一种<strong>页面框架设计</strong></p>
<p>MVC&#x2F;MVVM作用于三层架构中的UI层,也就是说将三层架构中的UI层再度进行了分化</p>
<h3 id="数据操作层"><a href="#数据操作层" class="headerlink" title="数据操作层"></a>数据操作层</h3><p>有一个额外的层单独拿出来可以称为<strong>数据操作层</strong></p>
<p>数据操作层包含公共数据访问代码，是用于操作和交互数据库中数据的逻辑代码。</p>
<p>将数据操作层划分在业务逻辑层还是数据层是当下项目设计的两种常见模式</p>
<ul>
<li><p>将数据操作的逻辑代码置于业务逻辑层时，数据访问成为一种业务逻辑。表示层对于数据的访问与业务逻辑层对于数据的操作调用的是相同的方法。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202406130955327.png" alt="iShot_2024-06-13_08.38.47" style="zoom: 25%;" />
</li>
<li><p><strong>将所有的数据读取操作存放在数据层时，只需要在业务层再定义一个方法供表示层调用</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202406130955854.png" alt="iShot_2024-06-13_08.38.31" style="zoom:25%;" /></li>
</ul>
<p>在架构设计中,根据高内聚低耦合的原则,上层的模块不必关心下层模块,尽可能独立.因此更标准的做法是将<strong>数据操作层置于数据层</strong>中(数据操作层置于数据层后,我们一般把这个称为<strong>数据访问层</strong>)</p>
<p>以C#为例,除了WPF,表示层还可以采用其他表示层技术</p>
<ul>
<li>WinForm  桌面应用程序</li>
<li>ASP.NET  动态web页</li>
<li>Silverlight  网络交互程序</li>
<li>Avalonia  跨平台应用程序</li>
</ul>
<p>对于同一逻辑功能层的项目,无论使用何种技术来进行表示层的开发,其逻辑层和数据层都是相同的</p>
<h1 id="表现模式"><a href="#表现模式" class="headerlink" title="表现模式"></a>表现模式</h1><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>MVC和MVVM是我们在进行应用程序开发中最常用的两种表现模式</p>
<p>MVC模式是GUI界面开发的指导模式。它基于表现层功能划分的思想把程序分为三大部分：<strong>Model-View-Controller</strong>呈三角形结构。Model是数据模型，View是用户界面，Controller是控制器。MVC的设计目的是实现功能结构的规划</p>
<p>通过Controller使得Model的数据和View的呈现同步</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202406130954461.png" alt="iShot_2024-06-13_09.07.49" style="zoom:33%;" />

<ul>
<li><p><strong>模型（Model）</strong>：<strong>数据模型</strong>,处理程序逻辑；获取和存放数据。</p>
<p>Model的代码包括业务逻辑及具体的实现以及状态管理等</p>
</li>
<li><p><strong>视图（View）</strong>：显示数据；提供用户交互界面。</p>
<p>程序中界面相关的部分,是用户看到并与之交互的界面,通常实现数据相对于用户的输入与输出功能</p>
</li>
<li><p><strong>控制器（Controller）</strong>：处理用户交互；从View读取数据(用户输入)；向Model发送数据。</p>
<p>根据用户的交互操作,控制用户界面数据的显示与更新,.model的对象状态,起到控制整个业务流程的作用,实现View层与Model层的协同工作他有关</p>
</li>
</ul>
<p>可见在MVC模式中,controler是这个模式的核心,view和model的数据需要经由controller进行传递.MVC的通信核心就在于控制器.以控制器为核心划分了视图和数据,但并非完全分离的,view和model之间是有联系的,mvc之间的通信是单向进行的,view和controller也是单向引用.但在实际当中,view和controller其实也是有数据交互的.虽然这并不违背 MVC 模式的基本原则。只要这种交互是在控制器的协调下进行的，并且遵循了各组件之间的职责划分，就仍然可以保持代码的结构清晰和可维护性</p>
<p>为什么说view和controller之间并不是完全分离的呢?</p>
<p>拿c#的winform举例:当我们给一个视图上的控件去命名的时候,我们就可以通用逻辑页面去通过它的名字调用到他.但是一旦你的这个view改变了它的名字,就会导致model也需要修改.所以在MVC模式当中,view和model之间多多少少都会存在一些依赖和捆绑的关系</p>
<p>用户请求被路由到控制器，后者负责使用模型来执行用户操作或检索查询结果。控制器选择要显示给用户的视图，并为其提供所需的任何模型数据。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>有利于软件工程化管理，由于不同的层各司其职，每一层不同的应用具有某些特性，有利于通过工程化、工程化管理程序代码，可以使用控制器来连接不同的模型和视图去完成客户的需求。</p>
<h3 id="MVC与三层架构的关系"><a href="#MVC与三层架构的关系" class="headerlink" title="MVC与三层架构的关系"></a>MVC与三层架构的关系</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202406130954486.png" alt="iShot_2024-06-13_09.18.27" style="zoom:25%;" />

<p>MVC是表现模式（Presentation Pattern），三层架构是典型的架构模式（Architecture Pattern），三层架构的分层模式是典型的上下关系，上层依赖于下层。但MVC作为表现模式是不存在上下关系的，而是<strong>相互协作关系</strong>。MVC和三层架构基本没有可比性，是应用于不同领域的技术。</p>
<h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p><strong>MVVM（Model-View-ViewModel）</strong>是一种基于前端开发的表现模式,其<strong>核心是提供对View和ViewModel的双向数据绑定</strong>,使得model和view的数据状态可以自动变更.在WPF中应用到MVVM是非常常见的，MVVM全称为Model、View、ViewModel</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202406130953309.png" alt="iShot_2024-06-13_09.27.01" style="zoom:25%;" />

<ul>
<li>View：代表窗体、控件等可视化资源。</li>
<li>ViewModel：代表View的业务处理类，将获取到的数据处理好与View进行关联绑定。</li>
<li>Model：通常代表数据模型,用于定义和管理应用程序的数据。它将支持ViewModel中用到的一些字段。还有一种用法就是<strong>在Model里完成业务逻辑的编写</strong>;<strong>ViewModel只需要处理视图和模型之间的关联和交互</strong>，</li>
</ul>
<p>其中ViewModel是MVVM模式的核心,他是连接View和Model的桥梁,他有两个方向:</p>
<ul>
<li>将Model转化为View,即将后端传递的数据转化成所看到的页面: <strong>数据绑定</strong></li>
<li>将View转化为Model,即将所看到的页面转化成后端的数据: <strong>事件监听</strong></li>
</ul>
<p>这两个方向共同称之为<strong>数据的双向绑定</strong>.</p>
<p>MVVM在概念上是真正将页面与数据逻辑分离的模式,View和Model彻底分离.</p>
<p>ViewModel通常会需要实现一个observer的观察者</p>
<p>在实际开发中，如何在 Model 和 ViewModel 中分配业务逻辑的实现，可以根据项目的具体需求和特点来决定。毕竞MVVM只是一个规范我们尽量遵守即可。</p>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul>
<li><p>低耦合：视图View可以独立于Model变化和修改，一个ViewModel可以绑定到不同的View上，当View变化的时候Mode可以不变，当Model变化的时候View也可以不变。</p>
</li>
<li><p>可重用性：可以把一些视图逻辑放在ViewModel里面，让很多view重用这段视图逻辑。</p>
</li>
<li><p>独立开发：开发人员可以专注业务逻辑和数据的开发，设计人员可以专注页面设计。</p>
</li>
<li><p>可测试：界面向来比较难预测时，测试可针对ViewModel来写。</p>
<p>View最有可能与平台紧密耦合,即使对其进行编码也难以进行单元测试</p>
</li>
</ul>
<h3 id="MVC与MVVM的区别"><a href="#MVC与MVVM的区别" class="headerlink" title="MVC与MVVM的区别"></a>MVC与MVVM的区别</h3><ul>
<li><p>MVC模型关注的是<strong>页面功能的划分</strong>，将UI层面上的代码和数据逻辑相关的代码分开，但并不是完全分离，且在于<strong>强调控制器的作用</strong>。</p>
</li>
<li><p>MVVM在概念上是真正将页面与数据逻辑分离的模式，View和Model彻底分离，<strong>核心在于提供对View 和 ViewModel 的双向数据绑定，使得Model和View数据状态的改变可以自动变更</strong>。</p>
<p>view和model不知道彼此的存在,通过viewModel来进行绑定,即ViewModel可以直接获取到Model的信息,直接访问模型上的属性和方法;但要注意的是,Model和ViewModel不能直接获取ViewModel的信息</p>
</li>
</ul>
<h1 id="驱动方式"><a href="#驱动方式" class="headerlink" title="驱动方式"></a>驱动方式</h1><h2 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h2><p>事件驱动通过“事件一订阅一事件处理”的关系组织应用程序。事件驱动下，用户进行每一个操作会激发程序发生的一个事件，事件发生后，用于响应事件的事件处理器就会执行。</p>
<p>事件驱动对应的表示模式正是<a href="#MVC">MVC</a></p>
<h2 id="数据驱动"><a href="#数据驱动" class="headerlink" title="数据驱动"></a>数据驱动</h2><p>数据驱动对应的表示模式是<a href="#MVVM">MVVM</a></p>
<h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1rC4y1C7z2/">参考视频</a></p>
<p>大部分编程范式的区别都在于如何管理状态</p>
<p>函数式编程的核心是<strong>状态不存在</strong></p>
<p>输入会转换为输出</p>
<h1 id="控制反转"><a href="#控制反转" class="headerlink" title="控制反转"></a>控制反转</h1><p>控制反转IOC</p>
<p><strong>控制反转</strong>是一种设计原则，其核心思想是将对象之间的依赖关系控制权从对象本身转移到外部环境。通过 IoC，一个对象不再直接创建依赖对象或管理依赖的生命周期，而是将这种责任交给容器或框架处理。这种控制权的转移让代码更加灵活、易于测试且更具可维护性。</p>
<p><strong>依赖注入（DI）是实现 IoC 的一种方式</strong></p>
<p>依赖注入是一种具体实现 IoC 的设计模式。通过 DI，一个对象的依赖项（或称依赖对象）由外部传入，而不是由对象内部自行创建。DI 是实现 IoC 最常用的手段，主要有以下几种方式：</p>
<ul>
<li><strong>构造函数注入</strong>：通过构造函数将依赖对象传入。</li>
<li><strong>属性注入</strong>：通过属性设置依赖对象。</li>
<li><strong>方法注入</strong>：通过方法参数传递依赖对象。</li>
</ul>
<h1 id="面向切片编程"><a href="#面向切片编程" class="headerlink" title="面向切片编程"></a>面向切片编程</h1><blockquote>
<p><strong>AOP</strong>（Aspect-Oriented Programming，面向切面编程）是一种编程范式，专注于将横切关注点（如日志、事务管理、异常处理）从业务逻辑中分离。AOP 框架可以通过拦截方法调用的方式，在特定代码执行前后自动执行一些通用逻辑，常见的 AOP 框架有 <strong>PostSharp</strong>、<strong>Castle DynamicProxy</strong> 等。<strong>AOP 框架的核心机制是动态代理，通过“切面”实现方法执行前后或异常发生时的特定操作</strong>。</p>
<p><strong>通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术</strong></p>
<p>是对OOP的一种补充，在不修改原始类的情况下，给程序动态添加统一功能的一种技术。</p>
</blockquote>
<p>面向切片编程AOP</p>
<p><strong>AOP 框架在减少重复代码、实现一致的全局处理方面非常有帮助，通过动态插入功能的方式，便于管理跨业务的代码逻辑</strong></p>
<p><strong>AOP 的关键概念</strong></p>
<ul>
<li><strong>切面（Aspect）</strong>：关注特定任务（如日志、异常处理）的模块。</li>
<li><strong>连接点（Join Point）</strong>：程序中的一个执行点（如方法调用或异常抛出）。</li>
<li><strong>切入点（Pointcut）</strong>：定义在哪些连接点插入切面的规则。</li>
<li><strong>通知（Advice）</strong>：在连接点实际执行的操作，如方法前后的日志记录、异常拦截等。</li>
</ul>
<p><strong>使用场景</strong></p>
<ul>
<li><strong>日志记录</strong>：在方法执行前后记录日志，无需在每个方法内手动添加。</li>
<li><strong>事务管理</strong>：在数据库操作前后自动开启和提交事务。</li>
<li><strong>全局异常处理</strong>：集中捕获和处理异常，并记录在日志中。</li>
<li><strong>性能监控</strong>：自动测量方法的执行时间以便优化。</li>
<li><strong>权限控制</strong>：强制执行安全策略，确保只有授权的用户能够执行特定操作。</li>
</ul>
<p>实现AOP有两种方式：</p>
<ol>
<li>静态代理实现。所谓静态代理，就是我们自己来写代理对象。</li>
<li>动态代理实现。所谓动态代理，就是在程序运行时，去生成一个代理对象。</li>
</ol>
<p>实现静态代理需要使用到两种设计模式：[[设计模式#装饰器模式]]和[[设计模式#代理模式]]。</p>
<p>Spring的aop是靠[[设计模式#代理模式]]实现的</p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>两种实现方式</p>
<ul>
<li>通过代码织入的方式。例如PostSharp第三方插件。我们知道.NET程序最终会编译成IL中间语言，在编译程序的时候，PostSharp会动态的去修改IL，在IL里面添加代码，这就是代码织入的方式。</li>
<li>通过反射的方式实现。通过反射实现的方法非常多，也有很多实现了AOP的框架，例如Unity、MVC过滤器、Autofac等。</li>
</ul>
<h1 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h1><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202505221113012.png" alt="image-20250522111344191" style="zoom: 67%;" />

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202505221114577.png" alt="image-20250522111401718" style="zoom: 67%;" />

<h2 id="软件的生存周期"><a href="#软件的生存周期" class="headerlink" title="软件的生存周期"></a>软件的生存周期</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202505201104723.png" alt="image-20250520110453135"></p>
<p>通俗理解:</p>
<ul>
<li><strong>概要设计</strong>: 大框架方面的设计,包括将一个系统划分为子系统或模块等分配过程都叫概要设计,还要设计划开的部分之间通信的过程.</li>
<li><strong>详细设计</strong>: 子系统或子模块之间的具体设计,具体的数据结构算法等东西</li>
<li><strong>编码</strong>: 实现,开发阶段</li>
<li><strong>测试</strong>: 验证功能是否正常</li>
<li><strong>维护</strong>: 也叫做运维,将系统交付给用户后,在用户环境下运行,包括更新换代,打补丁等很多工作</li>
</ul>
<blockquote>
<p>概要设计文档的内容不包括（<code>C</code>）<br>A. 体系结构设计<br>B. 数据库设计 ✅: 需要全局的数据库设计<br>C. 模块内算法设计<br>D. 逻辑数据结构设计 ✅: 需要全局的逻辑数据结构设计</p>
<p>结构化开发方法中，（<code>D</code>）主要包含对数据结构和算法的设计。<br>A. 体系结构设计  ❌: 概要设计<br>B. 数据设计  ❌: E-R图<br>C. 接口设计  ❌: 人机交互<br>D. 过程设计  ✅</p>
<p>在采用结构化开发方法进行软件开发时，设计阶段接口设计主要依据需<br>求分析阶段的（<code>A</code>）。接口设计的任务主要是（<code>C</code>）。<br>A. 数据流图 B. ER图 C. 状态-迁移图 D. 加工规格说明<br>A. 定义软件的主要结构元素及其之间的关系 ❌: 体系结构设计<br>B. 确定软件涉及的文件系统的结构及数据库的表结构 ❌: 数据设计<br>C. 描述软件与外部环境之间的交互关系，软件内模块之间的调用关系 ✅: 这就是接口设计<br>D. 确定软件各个模块内部的算法和数据结构 ❌: 过程设计阶段</p>
</blockquote>
<h2 id="软件过程"><a href="#软件过程" class="headerlink" title="软件过程"></a>软件过程</h2><p>软件过程改进的几种模型(软考中主要考察的点就是这几种模型)</p>
<h3 id="CMM模型"><a href="#CMM模型" class="headerlink" title="CMM模型"></a>CMM模型</h3><p><strong>软件过程能力成熟度模型CMM</strong></p>
<p>(很多公司会评定CMM等级)</p>
<ul>
<li><strong>初始级</strong>: <strong>杂乱无章,甚至混乱</strong>,几乎没有明确定义的步骤,项目的成功完全依赖个人的努力和英雄式核心人物的作用</li>
<li><strong>可重复级</strong>: 建立了<strong>基本的项目管理过程和实践</strong>来跟踪项目费用,进度和功能特性,有必要的过程准则来重复以前在同类项目中成功</li>
<li><strong>已定义级</strong>: 管理和工程两方面的软件过程已经<strong>文档化,标准化</strong>,并综合整个软件开发组织的<strong>标准过程</strong></li>
<li><strong>已管理级</strong>: 指定了软件过程和产品质量的<strong>详细度量标准</strong></li>
<li><strong>优化级</strong>: 加强了定量分析,通过来自过程质量反馈和来自新观念,新技术的反馈使过程能<strong>不断持续地改进</strong></li>
</ul>
<p>初始级是1级,优化级是5级</p>
<p>除了CMM模型,后续还有一个进阶版,叫CMMI,阶段式模型</p>
<blockquote>
<p>以下关于CMM的叙述中，不正确的是（<code>C</code>）<br>A. CMM是指软件过程能力成熟度模型<br>B. CMM根据软件过程的不同成熟度划分了5个等级，其中，1级被认为<br>成熱度最高，5级被认为成熟度最低<br>C. CMMI的任务是将已有的几个CMM模型结合在一起，使之构成“集成<br>模型”<br>D. 采用更成熟的CMM模型，一般来说可以提高最终产品的质量</p>
</blockquote>
<h3 id="CMMI模型"><a href="#CMMI模型" class="headerlink" title="CMMI模型"></a>CMMI模型</h3><h4 id="阶段式模型-5级模型"><a href="#阶段式模型-5级模型" class="headerlink" title="阶段式模型 5级模型"></a>阶段式模型 5级模型</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202505201117465.png" alt="image-20250520111737895"></p>
<h4 id="连续式模型-6级模型"><a href="#连续式模型-6级模型" class="headerlink" title="连续式模型 6级模型"></a>连续式模型 6级模型</h4><p>只需要完成等级和关键字的匹配,即可满足软考要求</p>
<table>
<thead>
<tr>
<th>等级CL</th>
<th>说明</th>
<th>关键字</th>
</tr>
</thead>
<tbody><tr>
<td>CL0（未完成的）</td>
<td>过程域未执行或未得到CL1中定义的所有目标。</td>
<td>未执行或未得到</td>
</tr>
<tr>
<td>CL1（已执行的）</td>
<td>其共性目标是过程将可标识的输入工作产品转换成可标识<br/>的输出工作产品，以实现支持过程域的特定目标。</td>
<td>可标识的输入工作产品转换成可标识的输出工作产品</td>
</tr>
<tr>
<td>CL2（已管理的）</td>
<td>其共性目标是集中于已管理的过程的制度化。根据组织级<br/>政策规定过程的运作将使用哪个过程，项目遵循已文档化<br/>的计划和过程描述，所有正在工作的人都有权使用足够的<br/>资源，所有工作任务和工作产品都被监控、控制、和评审。</td>
<td>已管理的过程的制度化</td>
</tr>
<tr>
<td>CL3（已定义级的）</td>
<td>其共性目标集中于已定义的过程的制度化。过程是按照组<br/>织的裁剪指南从组织的标准过程中裁剪得到的，还必须收<br/>集过程资产和过程的度量，并用于将来对过程的改进。</td>
<td>已定义的过程的制度化</td>
</tr>
<tr>
<td>CL4（定量管理的）</td>
<td>其共性目标集中于可定量管理的过程的制度化。使用测量<br/>和质量保证来控制和改进过程域，建立和使用关于质量和<br/>过程执行的质量目标作为管理准则。</td>
<td>可定量管理的过程的制度化</td>
</tr>
<tr>
<td>CL5（优化的）</td>
<td>使用量化（统计学）手段改变和优化过程域，以满足客户<br/>的改变和持续改进计划中的过程域的功效。</td>
<td>量化（统计学）手段改变和优化过程域</td>
</tr>
</tbody></table>
<p>CL5的量化(统计学)是用来优化自身的,别理解错成CL4了</p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><blockquote>
<p>能力成熟度模型集成（CMMI）是若干过程模型的综合和改进。连续式<br>模型和阶段式模型是CMMI提供的两种表示方法，而连续式模型包括6<br>个过程域能力等级，其中（<code>D</code>）使用量化（统计学）手段改变和优化过<br>程域，以应对客户要求的改变和持续改进计划中的过程域的功效。<br>A. CL2（已管理的） B. CL3（已定义级的）<br>C. CL4（定量管理的） D. CL5（优化的）</p>
</blockquote>
<h2 id="软件开发方法"><a href="#软件开发方法" class="headerlink" title="软件开发方法"></a>软件开发方法</h2><h3 id="结构化方法"><a href="#结构化方法" class="headerlink" title="结构化方法"></a>结构化方法</h3><p>非常严谨,是一种面向过程的开发,适用于<strong>需求明确</strong>的项目(一般认为做二次开发或已有行业经验被称为需求明确)</p>
<p>特点:</p>
<ul>
<li>用户至上</li>
<li>严格区分工作阶段,每阶段有任务和结果</li>
<li>强调系统开发过程的整体性和全局性</li>
<li>系统开发过程工程化,文档资料标准化</li>
<li>自顶向下,逐步分解(求精)</li>
</ul>
<p>需求本身是有渐进明晰性的,当需求改进时,很多时候要推导重来</p>
<h3 id="原型法"><a href="#原型法" class="headerlink" title="原型法"></a>原型法</h3><p>使用于<strong>需求不明确</strong>的项目</p>
<p>使用了一种演化迭代的思想,主要是帮助用户明确需求的</p>
<p>比如提供界面原型给用户来提需求</p>
<h3 id="面向对象的方法"><a href="#面向对象的方法" class="headerlink" title="面向对象的方法"></a>面向对象的方法</h3><p>适用于复杂大项目(p.s.结构化方法不适用于复杂项目,因为复杂项目变数太多了)</p>
<p>特点:</p>
<ul>
<li>更好的复用性</li>
<li>关键在于建立一个全面,合理,统一的模型</li>
<li>分析,设计,实现三个阶段,界限不明确</li>
</ul>
<p>整个过程是迭代无间隙的,相互之间可以有一些交叠的过程</p>
<h3 id="面向服务的方法"><a href="#面向服务的方法" class="headerlink" title="面向服务的方法"></a>面向服务的方法</h3><p>软考中目前仅在高级中出现过</p>
<p>服务可以理解为更高级别的抽象</p>
<p>抽象级别: 操作,服务,业务流程</p>
<h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><blockquote>
<p>若用户需求不清晰且经常发生变化，但系统规模不太大且不太复杂，则<br>最适宜采用（<code>C</code>）开发方法，对于数据处理领域的问题，若系统规模不<br>太大且不太复杂，需求变化也不大，则最适宜采用（<code>A</code>）开发方法。<br>A. 结构化 B. Jackson C. 原型化 D. 面向对象<br>A. 结构化 B. Jackson C. 原型化 D. 面向对象</p>
<p>p.s. Jackson这种方法是面向数据结构的</p>
</blockquote>
<h2 id="软件开发模型"><a href="#软件开发模型" class="headerlink" title="软件开发模型"></a>软件开发模型</h2><p>软考必考知识点,主要是给定一种情形,让考生判断适合什么开发模型</p>
<ul>
<li><p><a href="#%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B%E4%B8%8EV%E6%A8%A1%E5%9E%8B">瀑布模型与V模型</a></p>
<p>适用于<strong>需求明确</strong>,<strong>文档驱动</strong></p>
</li>
<li><p><a href="#%E6%BC%94%E5%8C%96%E6%A8%A1%E5%9E%8B">演化模型</a></p>
<p>适用于需求不明确</p>
</li>
<li><p><a href="#%E5%A2%9E%E9%87%8F%E6%A8%A1%E5%9E%8B">增量模型</a></p>
<p>尽可能早提供可用版本,然后在这个版本基础上增加新的功能模块</p>
</li>
<li><p><a href="#%E5%96%B7%E6%B3%89%E6%A8%A1%E5%9E%8B">喷泉模型</a></p>
<p><strong>用户需求驱动</strong>迭代无间隙</p>
</li>
<li><p><a href="#%E7%BB%9F%E4%B8%80%E8%BF%87%E7%A8%8BUP">统一过程UP</a></p>
<p>以架构为中心,<strong>用例驱动</strong></p>
</li>
<li><p><a href="#%E6%95%8F%E6%8D%B7%E6%96%B9%E6%B3%95">敏捷方法</a></p>
</li>
</ul>
<h3 id="瀑布模型与V模型"><a href="#瀑布模型与V模型" class="headerlink" title="瀑布模型与V模型"></a>瀑布模型与V模型</h3><p>这个考点出现特别频繁</p>
<h4 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h4><p>适合于需求明确的情况</p>
<p>由<strong>文档驱动</strong>的</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202505201400986.png" alt="image-20250520140042348" style="zoom:33%;" />

<h4 id="V模型"><a href="#V模型" class="headerlink" title="V模型"></a>V模型</h4><p>属于瀑布模型的一个变种</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202505201402710.png" alt="image-20250520140213255" style="zoom: 33%;" />

<p>强调的是<strong>测试贯穿始终</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202505211735702.png" alt="image-20250521173547022" style="zoom:50%;" />

<ul>
<li><p><strong>单元测试</strong>: 模块测试,模块功能,性能,接口等</p>
<p>一般只有单元测试是自己测试自己</p>
</li>
<li><p><strong>集成测试</strong>: 模块间的接口</p>
<p>打桩,桩模块,只用来测试的模块</p>
</li>
<li><p><strong>系统测试</strong>: 真实环境下,验证完整的软件配置项能否和系统正确连接</p>
</li>
<li><p><strong>确认测试</strong>: 验证软件与需求的一致性.内部确认测试,Alpha测试,Beta测试,验收测试</p>
</li>
<li><p><strong>回归测试</strong>: 测试软件变更之后,变更部分的正确性对变更需求的符合性</p>
</li>
</ul>
<h4 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h4><blockquote>
<p>某开发小组欲为一公司开发一个产品控制软件，监控产品的生产和销售过程，从购买各种材料开始，到产品的加工和销售进行全程跟踪。购买材料的流程、产品的加工过程以及销售过程可能会发生变化。该软件的开发最不适宜采用（<code>A</code>）模型，主要是因为这种模型（<code>C</code>）。<br>A. 瀑布 B. 原型 C. 增量 D. 喷泉<br>A. 不能解決风险 B. 不能快速提交软件<br>C. 难以适应变化的需求 D. 不能理解用户的需求</p>
</blockquote>
<h3 id="演化模型"><a href="#演化模型" class="headerlink" title="演化模型"></a>演化模型</h3><p>演化模型：演化模型是迭代的过程模型，使得软件开发人员能够逐步开发出更完整的软件版本。演化模型特别适用于对软件需求缺乏准确认识的情况。</p>
<p>其中</p>
<ul>
<li><a href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%9E%8B">原型模型</a></li>
<li><a href="#%E8%9E%BA%E6%97%8B%E6%A8%A1%E5%9E%8B">螺旋模型</a></li>
</ul>
<h4 id="原型模型"><a href="#原型模型" class="headerlink" title="原型模型"></a>原型模型</h4><p>原型模型强调的是明确需求,而不是长期投入使用的迭代过程</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202505201414233.png" alt="image-20250520141404815" style="zoom:67%;" />

<p>第一个维度区分</p>
<ul>
<li><p>抛弃型原型</p>
<p>前一个迭代会被抛弃掉</p>
</li>
<li><p>演化型原型</p>
<p>最初的迭代会被保留</p>
</li>
</ul>
<p>第二个维度区分</p>
<ul>
<li><p>探索型原型</p>
<p>主要用于需求分析阶段,探索多种可能的设计方案的可行性</p>
</li>
<li><p>实验型原型</p>
<p>针对特技术方案或架构进行验证,评估实现方案的可行性和性能表现</p>
</li>
<li><p>演化型原型</p>
<p>贯穿 <strong>开发全过程</strong>，从核心功能出发逐步迭代，最终演化为完整的软件系统</p>
</li>
</ul>
<h5 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h5><blockquote>
<p>以下关于系统原型的叙述中，不正确的是（<code>C</code>）<br>A. 可以帮助导出系统需求并验证需求的有效性<br>B. 可以用来探索特殊的软件解決方案<br>C. 可以用来指导代码优化<br>D. 可以用来支持用户界面设计</p>
<p>A是探索型原型,B是实验性原型,D是最初的原型,一般会保留在系统中,所以是演化型原型</p>
</blockquote>
<h4 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h4><p>螺旋模型是由瀑布模型和演化模型结合,加入<strong>风险分析</strong>,<strong>特别适用于庞大,复杂并且具有高风险</strong>的系统</p>
<p>他是唯一适用于高风险的系统开发模型</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202505201417799.png" alt="image-20250520141739227" style="zoom:67%;" />

<h5 id="例题-4"><a href="#例题-4" class="headerlink" title="例题"></a>例题</h5><blockquote>
<p>以下关于螺旋模型的叙述中，不正确的是（<code>D</code>）<br>A. 它是风险驱动的，要求开发人员必须具有丰富的风险评估知识和经验<br>B. 它可以降低过多测试或测试不足带来的风险<br>C. 它包含维护周期，因此维护和开发之间没有本质区别✅<br>D. 它不适用于大型软件开发</p>
<p>某企业拟开发一个企业信息管理系统，系统功能与多个部门的业务相关。现希望该系统能够尽快投入使用，系统功能可以在使用过程中不断改善。则最适宜采用的软件过程模型为（&#96;&#96;）<br>A. 瀑布模型   ❌: 题干提到了不断改善,即需求不明确<br>B. 原型模型   ❌: 原型模型强调的是需求明确,而不是长期迭代使用<br>C. 演化（迭代）模型   ✅: 最符合的是演化模型<br>D. 螺旋模型   ❌: 强调风险管理,但是题干没有提到</p>
<p>原型模型和螺旋模型都是演化模型的一种,但是当这些选项都出现的时候,应该选择最合适的选项</p>
</blockquote>
<h3 id="增量模型"><a href="#增量模型" class="headerlink" title="增量模型"></a>增量模型</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202505201430873.png" alt="image-20250520143023300"></p>
<p>第1个增量往往是核心产品,将需求分段为一系列增量产品,每一增量可以分别开发</p>
<p>用户用的最多的功能其实只有所有功能中的20%,每一轮都能将核心增量进行测试,以此保证核心功能的最稳定和最优</p>
<p>这种模型对用户体验会更好,每一个增量都会提供一个用户可使用的版本</p>
<p>但缺点是判定哪些功能属于核心增量,对于开发者来说比较困难</p>
<h4 id="例题-5"><a href="#例题-5" class="headerlink" title="例题"></a>例题</h4><blockquote>
<p>以下关于增量开发模型的叙述中，不正确的是（<code>D</code>）。<br>A. 不必等到整个系统开发完成就可以使用<br>B. 可以使用较早的增量构件作为原型，从而获得稍后的增量构件需求<br>C. 优先级最高的服务先交付，这样最重要的服务接受最多的测试<br>D. 有利于进行好的模块划分  ❌:增量模型中最难做的就是模块划分</p>
</blockquote>
<h3 id="喷泉模型"><a href="#喷泉模型" class="headerlink" title="喷泉模型"></a>喷泉模型</h3><p><strong>以用户需求为动力,以对象作为驱动</strong>的模型,<strong>适合于面向对象的开发方法</strong></p>
<p>特点: <strong>迭代无间隙</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202505201433047.png" alt="image-20250520143351425" style="zoom:33%;" />

<h4 id="例题-6"><a href="#例题-6" class="headerlink" title="例题"></a>例题</h4><blockquote>
<p>喷泉模型是一种适合于面向（<code>A</code>）开发方法的软件过程模型。该过程模型的特点不包括（<code>D</code>）。<br>A. 对象 B. 数据 C. 数据流 D. 事件<br>A. 以用户需求为动力 B. 支持软件重用<br>C. 具有选代性 D. 开发活动之间存在明显的界限</p>
</blockquote>
<h3 id="统一过程UP"><a href="#统一过程UP" class="headerlink" title="统一过程UP"></a>统一过程UP</h3><p>UP和RUP都表示统一过程</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202505201436653.png" alt="image-20250520143625103" style="zoom:67%;" />

<p>每一轮迭代为: 初始&#x2F;初启 -&gt; 细化&#x2F;精化 -&gt; 构建 -&gt; 交付</p>
<p>构建中的测试叫做α测试,交付阶段的测试叫β测试</p>
<p>面向架构,很大的优势在于复用构件&#x2F;组件</p>
<h3 id="敏捷方法"><a href="#敏捷方法" class="headerlink" title="敏捷方法"></a>敏捷方法</h3><p>考得比较多</p>
<p>总体目标是通过”尽可能早的,持续的对有价值的软件的交付”,使客户满意,适用于:”小步快跑”的思想,适合小项目小团队</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202505201444473.png" alt="image-20250520144429101" style="zoom:50%;" />

<p><strong>结对编程</strong>: 让至少两个人作为一对来进行编程,一个人进行写的同时,另一个人来看,另一个维度是<strong>防止人员流失</strong></p>
<p>具体的敏捷开发涉及到一些模型</p>
<table>
<thead>
<tr>
<th>敏捷方法</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td><a href="#%E6%9E%81%E9%99%90%E7%BC%96%E7%A8%8BXP">极限编程XP</a></td>
<td>4大价值观、5个原则、12个最佳实践</td>
</tr>
<tr>
<td>水晶法（Crystal）</td>
<td>认为每一个不同的项目都需要一套不同的策略、约定和方法论，认为<strong>人对软件质量有重要的影响（以人为本</strong>），因此随着项目质量和开发人员素质的提高，项目和过程的质量也随之提高。通过更好地交流和经常性交付，软件生产力得到提高。</td>
</tr>
<tr>
<td>开放式源码</td>
<td><strong>程序开发人员在地域上分布很广</strong></td>
</tr>
<tr>
<td><strong>并列争球法（SCRUM）</strong></td>
<td><strong>把每30天一次的迭代称为一个“冲刺”</strong>，并<strong>按需求的优先级来实现产品</strong>。多个自组织和自治的小组<strong>并行地递增实现产品</strong>。协调是通过简短的<strong>日常情况会议</strong>来进行，就像橄榄球中的“并列争球”。</td>
</tr>
<tr>
<td>功用驱动开发方法FDD</td>
<td><strong>首席程序员和“类”程序员</strong></td>
</tr>
<tr>
<td>自适应软件开发ASD</td>
<td>核心是三个非线性的、重叠的开发阶段：<strong>猜测、合作与学习</strong>。ASD有6个基本的原则：有一个使命作为指导；特征被视为客户价值的关键点；过程中的等待是很重要的，因此“量做”与“做”同样关键；变化不被视为改正，而是被视为对软件开发实际情况的调整；确定的交付时间迫使开发人员认真考虑每一个生产版本的关键需求；风险也包含其中。</td>
</tr>
</tbody></table>
<h4 id="极限编程XP"><a href="#极限编程XP" class="headerlink" title="极限编程XP"></a>极限编程XP</h4><p>常考,经常是选择题的形式</p>
<p><strong>4大价值观</strong></p>
<ul>
<li>沟通</li>
<li>简单</li>
<li>反馈</li>
<li>勇气: 勇于面对变化</li>
</ul>
<p><strong>5大原则</strong></p>
<ul>
<li>快速反馈</li>
<li>简单性假设</li>
<li>逐步修改</li>
<li>提倡更改</li>
<li><strong>优质工作</strong></li>
</ul>
<p><strong>12大最大实践</strong></p>
<ul>
<li><strong>计划游戏</strong>: 快速制定计划,随着细节的不断变化而完善</li>
<li><strong>小型发布</strong>: 系统的设计要能够尽可能早的交付</li>
<li><strong>隐喻</strong>: 找到合适的比喻传达信息</li>
<li><strong>简单设计</strong>: 只处理当前需求,是设计保持简单</li>
<li><strong>测试先行</strong>: 先写测试代码,然后再编写程序</li>
<li><strong>重构</strong>: 重新审视需求和设计,重新明确的描述他们以符合新的现有的需求</li>
<li><strong>结对编程</strong></li>
<li><strong>集体代码所有制</strong></li>
<li><strong>持续集成</strong>: 可以按日甚至按小时为客户提供可运行的版本</li>
<li><strong>每周工作40小时</strong></li>
<li><strong>现场顾客</strong>: 系统最终用户代表应该全程配合XP团队</li>
<li><strong>编码标准</strong></li>
</ul>
<h4 id="例题-7"><a href="#例题-7" class="headerlink" title="例题"></a>例题</h4><blockquote>
<p>在敏捷过程的开发方法中，（<code>C</code>）使用了迭代的方法，其中，把每段时间（30天）一次的选代称为一个“冲刺”，并按需求的优先级别来实现产品，多个自组织和自治的小组并行地递增实现产品。<br>A. 极限编程XP<br>B. 水晶法<br>C. 并列争球法<br>D. 自适应软件开发</p>
<p>以下关于极限编程 （XP）的最佳实践的叙述中，不正确的是（<code>B</code>）<br>A. 只处理当前的需求，使设计保持简单<br>B. 编写完程序之后编写测试代码<br>C. 可以按日甚至按小时为客户提供可运行的版本<br>D. 系统最终用户代表应该全程配合XP团队</p>
</blockquote>
<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ul>
<li><p>问题识别</p>
</li>
<li><p>分析与综合</p>
</li>
<li><p>编制需求分析文档 </p>
<p>文档产物一般是: 需求规格说明书SRS</p>
</li>
<li><p>需求分析与评审</p>
<p>让需求的提出方评审,签字确认12*9</p>
</li>
</ul>
<p>结构化分析的结果: 一套分层的数据流图,一本数据词典(对数据流图来加以说明),一组小说明(也称加工逻辑说明),补充材料</p>
<blockquote>
<p>软件开发过程中，需求分析阶段的输出不包括（<code>D</code>）。<br>A. 数据流图<br>B. 实体联系图 ✅: E-R图是数据库设计阶段的概念设计阶段的产物<br>C. 数据字典<br>D. 软件体系结构图 ❌: 在需求分析阶段是得不到的,是架构设计即概要分析的产物</p>
</blockquote>
<h3 id="需求的分类"><a href="#需求的分类" class="headerlink" title="需求的分类"></a>需求的分类</h3><p>两种维度的分类:</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202505201606887.png" alt="image-20250520160638305" style="zoom: 33%;" />

<p>上图一些名词解释:</p>
<ul>
<li>非功能需求或者叫性能需求: 一般包含性能,响应,并发,存储容量,速度等需求</li>
<li>设计约束: 一般是对操作系统,数据库的要求,还有对法律法规的要求</li>
</ul>
<p>在考试中,主要是考察<strong>系统需求</strong>的分类</p>
<blockquote>
<p>某企业财务系统的需求中，属于功能需求的是（<code>A</code>）。<br>A. 每个月特定的时间发放员工工资<br>B. 系统的响应时间不超过3秒<br>C. 系统的计算精度符合财务规则的要求<br>D. 系统可以允许100个用户同时查询自己的工资</p>
</blockquote>
<h3 id="需求分析的工具"><a href="#需求分析的工具" class="headerlink" title="需求分析的工具"></a>需求分析的工具</h3><ul>
<li><a href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE(DFD)">数据流图(DFD)</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8(DD)">数据字典(DD)</a></li>
<li><a href="#%E5%88%A4%E5%AE%9A%E8%A1%A8">判定表</a></li>
<li><a href="#%E5%88%A4%E5%AE%9A%E6%A0%91">判定树</a></li>
</ul>
<h3 id="数据流图-DFD"><a href="#数据流图-DFD" class="headerlink" title="数据流图(DFD)"></a>数据流图(DFD)</h3><p>这一道题有15分</p>
<p>主要考察的点是: 1.补充实体名 2.补充存储名 3.补充加工名 4.数据流</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202505201610601.png" alt="image-20250520161016033" style="zoom: 33%;" />

<p>例子:</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202505201616592.png" alt="image-20250520161649241" style="zoom: 67%;" />

<p>经常扣掉一些字,让用户填空</p>
<p>数据流图自顶向下,逐步求精,其中父子层图的关系如下图:</p>
<p>顶层数据流图 &#x3D; 上下文数据流图</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202505201619306.png" alt="image-20250520161934622" style="zoom: 33%;" />

<blockquote>
<p>数据流图建模应遵循（<code>B</code>）的原则。<br>A. 自顶向下、从具体到抽象<br>B. 自顶向下、从抽象到具体<br>C. 自底向上、从具体到抽象<br>D. 自底向上、从抽象到具体</p>
<p>在结构化分析中，用数据流图描述（<code>B</code>）。当采用数据流图对一个图书馆管理系统进行分析时，（<code>A</code>）是一个外部实体。<br>A. 数据对象之间的关系，用于对数据建模 ❌: 不对,对象的关系是静态的,而数据流图是描述一种动态关系的<br>B. 数据在系统中如何被传送或变换，以及如何对数据流进行变换的功能或子功能，用于对功能建模 ✅<br>C. 系统对外部事件如何响应，如何动作，用于对行为建模 ❌: 并没有对外部事件进行考虑,只是对系统内部进行考虑<br>D. 数据流图中的各个组成部分 ❌: 比较接近数据词典的定义<br>A. 读者 B. 图书 C. 借书证 D. 借阅</p>
<p>数据字典是结构化分析的一个重要输出。数据字典的条目不包括（<code>A</code>）。<br>A. 外部实体 ❌<br>B. 数据流<br>C. 数据项<br>D. 基本加工</p>
</blockquote>
<h4 id="解题技巧"><a href="#解题技巧" class="headerlink" title="解题技巧"></a>解题技巧</h4><ul>
<li><p>补充实体</p>
</li>
<li><p>补充存储</p>
</li>
<li><p>补充数据流</p>
<p><a href="#%E6%95%B0%E6%8D%AE%E5%B9%B3%E8%A1%A1%E5%8E%9F%E5%88%99">数据平衡原则</a></p>
<ol>
<li>顶层图与0层图对比,是否有顶层图有,但0层图无得数据流,或反之</li>
<li>检查图中每个加工,是否存在只有入没有出,或只有出没有入,或根据输入的数据无法产生对应的输出的情况</li>
</ol>
<p><strong>按题目说明与图进行匹配</strong>: 说明中的每一句话,都能与图中有对应关系,当把说明中的实体与数据流标识出来之后,容易缩小对应范围,找出纰漏</p>
</li>
<li><p>补充加工名</p>
<p>加工是用于处理数据流的,所以要补充加工名,可以把该加工涉及到的数据流,在说明中标识出来,再在数据流名称所在的句子中,找”动词+名词”的结构,分析是否可作为加工</p>
<p>“动词+名词”如: 生成报告,发出通知,批改作业,记录分数,当然这只是普遍情况,也有例外,如物流跟踪,用户管理</p>
</li>
</ul>
<blockquote>
<p><strong>例题</strong></p>
<p>阅读以下说明和数据流图，回答问题1至问题4，将解答填入答题纸的对应栏内。<br>【说明<br>现准备为某银行开发一个信用卡管理系统CCMS，该系统的基本功能为：</p>
<ol>
<li><strong>信用卡申请</strong>。<strong>非信用卡客户</strong>填写<em>信用卡申请表</em>，说明所要申请的信用卡类型及申请者的基本信息，提交CCMS。如果信用卡申请被<strong>银行</strong>接受，CCMS将记录该客户的基本信息，并发送确认函给该客户，告知客户信用卡的有效期及信贷限额；否则该客户将会收到一封拒绝函。非信用卡客户收到确认函后成为信用卡客户。</li>
<li><strong>信用卡激活</strong>。<strong>信用卡客户</strong>CCMS提交<strong>激活请求</strong>，用信用卡号和密码激活该信用卡。激活操作结束后，CCMS将激活通知发送给客户，告知客户其信用卡是否被成功激活。</li>
<li><strong>信用卡客户信息管理</strong>。信用卡客户的个人信息可以在CCMS中进行在线管理。每位信用卡客户可以在线查询和修改个人信息。</li>
<li><strong>交易信息查询</strong>。信用卡客户使用信用卡进行的每一笔交易都会记录在CCMS中。信用卡客户可以通过CCMS查询并核实其<strong>交易信息</strong>（包括信用卡交易记录及交易额）。图11-3和图11-4分别给出了该系统的顶层数据流图和0层数据流图的初稿。</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202505231002150.png" alt="image-20250523100255616" style="zoom:50%;" />

<p>【问题1】（3分）<br>根据【说明】，将图11-3中的E1～E3填充完整。<br>【问题2】（3分）<br>图11-3中缺少三条数据流，根据【说明】，分别指出这三条数据流的起点和<br>终点。（注：数据流的起点和终点均采用图中的符号和描述）<br>【问题3】（5分）<br>图11-4中有两条数据流是错误的，请指出这两条数据流的名称，并改正。<br>（注：数据流的起点和终点均采用图中的符号和描述）<br>【问题4】（4分）<br>根据【说明】，将图11-4中P1~P4的处理名称填充完整。</p>
<p>一般实体较少,从实体先分析</p>
<p>从题干中提取出三个实体: <strong>非信用卡客户,银行,信用卡客户</strong>(用于填充到E1~E3)</p>
<p>四个加工流程分别是<strong>信用卡申请,信用卡激活,信用卡客户信息管理,交易信息查询</strong>(用于填充到P1~P4)</p>
<p>根据数据平衡原则可分析出缺失的三条数据流: </p>
<ul>
<li><strong>交易信息</strong>在顶层数据流图中是缺失的</li>
<li><strong>信用卡申请表</strong>在顶层数据流图中是缺失的</li>
<li><strong>激活请求</strong>在顶层数据流图中缺失</li>
</ul>
<p>题干中可知,<strong>信用卡申请表</strong>应该是从非信用卡客户指向CCMS的,数据流图中的箭头是反了</p>
<p>题干中可知,<strong>激活请求</strong>应该是信用卡客户发送给P0的,而不是图示中的P4指向P3</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202505231013318.png" alt="image-20250523101303733"></p>
<ul>
<li>P1: 交易信息查询</li>
<li>P2: 客户信息管理</li>
<li>P3: 信用卡激活</li>
<li>P4: 信用卡申请</li>
</ul>
<p>还有另外两道例题,暂略</p>
</blockquote>
<h5 id="数据平衡原则"><a href="#数据平衡原则" class="headerlink" title="数据平衡原则"></a>数据平衡原则</h5><p>查找缺失数据流的过程中,一个可以快速查找的依据,但是只能查找一些缺失数据而非全部,最终的解决方案还是要落到题目分析的过程中</p>
<p>包含两个维度</p>
<ul>
<li><p>父图与子图之间的平衡</p>
<p>父图与子图之间平衡是指任何一张DFD子图边界上的输入&#x2F;输出数据流必须与其父图对应加工的输入&#x2F;输出数据了保持一致。如果父图中某个加工的一条数据流对应于子图中的几条数据流，而子图中组成这些数据流的数据项全体正好等于父图中的这条数据流，那么它们仍然是平衡的。</p>
</li>
<li><p>子图内的平衡</p>
<p>数据流图常见的3种错误：</p>
<ol>
<li>加工<strong>只有输入没有输出</strong>，称之为“<strong>黑洞</strong>”</li>
<li>加工<strong>只有输出没有输入</strong>，称之为“<strong>奇迹</strong>”；</li>
<li>加工中<strong>输入不足以产生输出</strong>，称之为“<strong>灰洞</strong>”</li>
</ol>
</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202505230902990.png" alt="image-20250523090253558" style="zoom: 33%;" />

<blockquote>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202505230906185.png" alt="image-20250523090610128" style="zoom:50%;" />

<p>分析上图的是否存在数据缺失</p>
<p>以前端应用为例,分析顶层数据流图</p>
<p>前端应用相接的数据流有:</p>
<ul>
<li>非法用户信息</li>
<li>用户信息</li>
<li>操作请求</li>
<li>处理后的操作结果 ❌: 对比可知缺失了这项</li>
<li>权限不足信息</li>
<li>格式错误信息</li>
</ul>
<p>而在0层数据流图中</p>
<p>前端应用相接的数据流有:</p>
<ul>
<li>非法用户信息</li>
<li>用户信息</li>
<li>操作请求</li>
<li>权限不足信息</li>
<li>格式错误信息</li>
</ul>
<p><strong>前端应用在0层数据流图中缺失了<code>处理后的操作结果</code></strong></p>
<p>后端数据库:</p>
<p>顶层数据流图:</p>
<ul>
<li>验证后的操作请求</li>
<li>连接请求</li>
<li>操作结果 ❌: 对比可知缺失了这项</li>
</ul>
<p>0层数据流图</p>
<ul>
<li>验证后的连接请求(就是操作请求吧)</li>
<li>连接请求</li>
</ul>
</blockquote>
<h3 id="数据字典"><a href="#数据字典" class="headerlink" title="数据字典"></a>数据字典</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202505201620501.png" alt="image-20250520162046893" style="zoom: 33%;" />

<p>数据字典有4类条目: 数据流,数据项,数据存储和基本加工.(源点和终点不在系统之内,不在字典中说明)</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">机票=姓名＋日期+航班号+起点+终点+费用</span><br><span class="line">航班号=“Y7100&quot; •• “Y8100&quot;</span><br><span class="line">终点=［长沙|上海|北京|西安］</span><br></pre></td></tr></table></figure>

<h3 id="结构化语言"><a href="#结构化语言" class="headerlink" title="结构化语言"></a>结构化语言</h3><p>常用的加工逻辑描述方法有结构化语言,判定表和判定树3种</p>
<p><strong>结构化语言</strong>: 是一种介于自然语言和形式化语言之间的半形式化语言,是自然语言的一个受限子集</p>
<ol>
<li>外层: 用来描述控制结构,采用顺序,选择和重复3种基本结构<ol>
<li>顺序结构,一组祈使语句,选择语句,重复语句的顺序排列</li>
<li>选择结构,一般用IF-THEN-ELSE-ENDIF,CASE-OF-ENDCASE等关键词</li>
<li>重复结构,一般用DO-WHILE-ENDDO,REPEAT-UNTIL等关键词</li>
</ol>
</li>
<li>内层: 一般采用祈使语句的自然语言短语,使用数据字典中的名词和游戏的自定义词,其动词含义要具体,尽量不用形容词和副词来修饰,还可使用一些简单的算法运算和逻辑运算符号</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202505201647270.png" alt="image-20250520164751543" style="zoom:30%;" />

<h3 id="判定表"><a href="#判定表" class="headerlink" title="判定表"></a>判定表</h3><p>某些情况下,数据流图中某个加工的一组动作依赖于多个逻辑条件的取值,此时用判定表能够清晰的表示复杂的条件组合与应做的动作之间的关系.</p>
<p>判定表由4个部分组成,分割成如下的4个区域:</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>条件定义</td>
<td>条件取值的组合</td>
</tr>
<tr>
<td>动作定义</td>
<td>在各种取值的组合下应执行的动作</td>
</tr>
</tbody></table>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202505201648778.png" alt="image-20250520164821109" style="zoom:33%;" />

<h3 id="判定树"><a href="#判定树" class="headerlink" title="判定树"></a>判定树</h3><p>判定树是<a href="#%E5%88%A4%E5%AE%9A%E8%A1%A8">判定表</a>的变形,一般情况下笔判定表更直观,且易于理解和适用</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202505201649033.png" alt="image-20250520164940224" style="zoom:33%;" />

<h2 id="系统设计-软件设计"><a href="#系统设计-软件设计" class="headerlink" title="系统设计&#x2F;软件设计"></a>系统设计&#x2F;软件设计</h2><p>大致可以分为两个阶段</p>
<ul>
<li>概要设计</li>
<li>详细设计</li>
</ul>
<p>特点:</p>
<ul>
<li>抽象化</li>
<li>自顶向下,逐步求精</li>
<li>信息隐蔽</li>
<li>模块独立(高内聚,低耦合)</li>
</ul>
<p>包含下面的设计环节</p>
<ul>
<li><strong>体系结构设计&#x2F;架构设计</strong>: 定义软件系统各主要部件之间的关系</li>
<li><strong>数据设计</strong>: 基于E-R图确定软件涉及的文件系统的结构及数据库的表结构</li>
<li><a href="#%E4%BA%BA%E6%9C%BA%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1">接口设计(人机界面设计)</a>: 软件内部,软件和操作系统间以及软件和人之间如何通信</li>
<li><strong>过程设计</strong>: 系统结构部件转换成软件的过程描述.确定软件各个组成部分内的算法及内部数据结构,并选定某种过程的表达形式来描述各种算法</li>
</ul>
<h3 id="使用到的工具"><a href="#使用到的工具" class="headerlink" title="使用到的工具"></a>使用到的工具</h3><p>下面的工具在考试中实际上并没有用到</p>
<ul>
<li>IPO图</li>
<li>PDL图</li>
<li>PAD图</li>
<li>程序流程图</li>
<li>N&#x2F;S盒图</li>
</ul>
<h3 id="模块设计"><a href="#模块设计" class="headerlink" title="模块设计"></a>模块设计</h3><p>考得很多</p>
<p><strong>基本设计要点</strong></p>
<ul>
<li><p>保持模块的大小适中</p>
</li>
<li><p>尽可能减少调用的深度</p>
</li>
<li><p><strong>多扇入,少扇出</strong></p>
<p>某个模块被调用叫<strong>扇入</strong></p>
<p>模块调用别的模块叫<strong>扇出</strong></p>
</li>
<li><p>单入口,单出口</p>
</li>
<li><p>模块的作用域应该在模块之内</p>
<p>作用域: 指模块内定义的变量、函数或逻辑的可见范围，即<strong>哪些代码区域可以访问该模块的内容</strong></p>
<p>控制域: 指模块在运行时能直接或间接<strong>调用&#x2F;控制的其他模块集合</strong>，即该模块的执行影响范围</p>
</li>
<li><p>功能应该是可预测的</p>
</li>
</ul>
<blockquote>
<p>良好的启发式设计原则上不包括（<code>B</code>）<br>A. 提高模块独立性  ✅: 内聚性<br>B. 模块规模越小越好  ❌: 应该是大小适中<br>C. 模块作用域在其控制域之内 ✅:内聚性<br>D. 降低模块接口复杂性  ✅: 耦合性</p>
</blockquote>
<h4 id="模块设计原则"><a href="#模块设计原则" class="headerlink" title="模块设计原则"></a>模块设计原则</h4><p>高<a href="#%E5%86%85%E8%81%9A%E6%80%A7">内聚</a>低<a href="#%E8%80%A6%E5%90%88%E5%BD%A2">耦合</a></p>
<h5 id="内聚性"><a href="#内聚性" class="headerlink" title="内聚性"></a>内聚性</h5><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202505211014532.png" alt="image-20250521101443055" style="zoom:33%;" />

<table>
<thead>
<tr>
<th>内聚类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>功能内聚</td>
<td>完成一个<strong>单一功能</strong>，各个部分协同工作，缺一不可</td>
</tr>
<tr>
<td>顺序内聚</td>
<td>处理元素相关，而且<strong>必须顺序执行</strong></td>
</tr>
<tr>
<td>通信内聚</td>
<td>所有处理元素集中在一个数据结构的区域上</td>
</tr>
<tr>
<td>过程内聚</td>
<td>处理元素相关，而且<strong>必须按特定的次序执行</strong>(注意可以不顺序)</td>
</tr>
<tr>
<td>瞬时内聚（时间内聚）</td>
<td>所包含的任务必须在<strong>同一时间间隔内执行</strong></td>
</tr>
<tr>
<td>逻辑内聚</td>
<td>完成<strong>逻辑上相关</strong>的一组任务</td>
</tr>
<tr>
<td>偶然内聚（巧合内聚）</td>
<td>完成一组<strong>没有关系或松散关系</strong>的任务</td>
</tr>
</tbody></table>
<p>考点注意: 顺序内聚和过程内聚的区别注意区分,最高是功能内聚,最低是偶然内聚</p>
<blockquote>
<p>某模块中各个处理元素都密切相关于同一功能且必须顺序执行，前一处理元素的输出就是下一处理元素的输入，则该模块的内聚类型为（<code>C</code>）内聚<br>A. 过程<br>B. 时间<br>C. 顺序<br>D. 逻辑</p>
</blockquote>
<h5 id="耦合性"><a href="#耦合性" class="headerlink" title="耦合性"></a>耦合性</h5><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202505211020895.png" alt="image-20250521102016440" style="zoom:33%;" />

<table>
<thead>
<tr>
<th>耦合类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>非直接耦合</td>
<td>两个模块之间<strong>没有直接关系</strong>，<strong>它们之间的联系完全是通过主模块的控制和调用来实现的</strong></td>
</tr>
<tr>
<td>数据耦合</td>
<td>一组模块借助参数表<strong>传递简单数据</strong></td>
</tr>
<tr>
<td>标记耦合</td>
<td>一组模块通过参数表<strong>传递记录信息（数据结构）</strong></td>
</tr>
<tr>
<td>控制耦合</td>
<td>模块之间传递的信息中包含用于<strong>控制模块内部逻辑的信息</strong></td>
</tr>
<tr>
<td>外部耦合</td>
<td>一组模块都<strong>访问同一全局简单变量</strong>，而且不是通过参数表传递该全局变量的信息</td>
</tr>
<tr>
<td>公共耦合</td>
<td>多个模块都访问<strong>同一个公共数据环境</strong></td>
</tr>
<tr>
<td>内容耦合</td>
<td>一个模块<strong>直接访问另一个模块的内部数据</strong>；一个模块<strong>不通过正常入口转到另一个模块</strong>的内部；两个模块有<strong>一部分程序代码重叠</strong>；一个模块<strong>有多个入口</strong></td>
</tr>
</tbody></table>
<blockquote>
<p>模块A将学生信息，即学生姓名、学号、手机号等放到一个结构体中，传递给模块B。模块A和B之间的耦合类型为（<code>B</code>）耦合。<br>A. 数据<br>B. 标记<br>C. 控制<br>D. 内容</p>
</blockquote>
<h3 id="人机界面设计"><a href="#人机界面设计" class="headerlink" title="人机界面设计"></a>人机界面设计</h3><p>黄金三原则</p>
<ul>
<li><strong>置于用户控制之下</strong><ul>
<li>以不强迫用户进入不必要的或不希望的动作的方式来定义交互方式</li>
<li>提供灵活的交互</li>
<li>允许用户交互可以被中断或撤销</li>
<li>当技能级别增加时可以使交互流水化并允许定制交互</li>
<li>使用户隔离内部技术细节</li>
<li>设计应允许用户和出现在屏幕上的对象直接交互</li>
</ul>
</li>
<li><strong>减少用户的记忆负担</strong><ul>
<li>减少对短期记忆的要求</li>
<li>建立有意义的缺省</li>
<li>定义直觉性的捷径</li>
<li>界面的视觉布局应该基于真实世界的隐喻</li>
<li>以不断进展的方式提示信息</li>
</ul>
</li>
<li><strong>保持界面的一致性</strong><ul>
<li>允许用户将当前任务放入有意义的语境</li>
<li>在应用系列内保持一致性</li>
<li>如过去的交互模型已建立起了用户期望,除非有迫不得已的理由,不要改变它</li>
</ul>
</li>
</ul>
<blockquote>
<p>Theo Mandel在其关于界面设计所提出的三条“黄金准则”中，不包括(<code>B</code>)<br>A. 用户操纵控制<br>B. 界面美观整洁<br>C. 减轻用户的记忆负担<br>D. 保持界面一致 </p>
</blockquote>
<h3 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h3><p>架构设计的一个核心问题是<strong>能否达到架构级的软件复用</strong></p>
<h4 id="架构风格"><a href="#架构风格" class="headerlink" title="架构风格"></a>架构风格</h4><p>架构风格是对架构设计的归类</p>
<ul>
<li>架构风格反映了领域中众多系统所共有的结构和语义特性,并知道如何将各个构件有效地组织成一个完整的系统</li>
<li>架构风格定义了用于描述系统的术语表和一组指导构件系统的规则</li>
</ul>
<p>有下面的一些架构风格</p>
<ul>
<li><a href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E9%A3%8E%E6%A0%BC">数据流风格</a>：批处理序列、管道-过滤器</li>
<li><a href="#%E8%B0%83%E7%94%A8/%E8%BF%94%E5%9B%9E%E9%A3%8E%E6%A0%BC">调用&#x2F;返回风格</a>：主程序&#x2F;子程序、面向对象、层次结构（MVC、C&#x2F;S、B&#x2F;S）</li>
<li><a href="#%E7%8B%AC%E7%AB%8B%E6%9E%84%E4%BB%B6%E9%A3%8E%E6%A0%BC">独立构件风格</a>：进程通信、事件驱动系统（隐式调用）</li>
<li><a href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%A3%8E%E6%A0%BC">虚拟机风格</a>：解释器、基于规则的系统</li>
<li><a href="#%E4%BB%93%E5%BA%93%E9%A3%8E%E6%A0%BC">仓库风格</a>：数据库系统、超文本系统、黑板系统</li>
</ul>
<h5 id="数据流风格"><a href="#数据流风格" class="headerlink" title="数据流风格"></a>数据流风格</h5><h6 id="批处理序列"><a href="#批处理序列" class="headerlink" title="批处理序列"></a>批处理序列</h6><p>构件为一系列固定顺序的计算单元，构件之间只通过数据传递交互。每个处理步骤是一个独立的程序，每一步必须在其前一步结束后才能开始，<br><strong>数据必须是完整的，以整体的方式传递</strong></p>
<h6 id="管道-过滤器"><a href="#管道-过滤器" class="headerlink" title="管道-过滤器"></a>管道-过滤器</h6><p>每个构件都有一组输入和输出，构件读输入的数据流，经过内部处理，然后产生输出数据流。这个过程通常是通过对输入数据流的变换或计算来完成的，包括通过计算和增加信息以丰富数据、通过浓缩和删除以精简数据、通过改变记录方式以转化数据和递增地转化数据等。这里的构件称为过滤器，连接件就是数据流传输的管道，将一个过滤器的输出传到另一个过滤器的输入。</p>
<p><strong>早期编译器就是采用的这种架构。要一步一步处理的，均可考虑采用此架构风格</strong></p>
<h5 id="调用-返回风格"><a href="#调用-返回风格" class="headerlink" title="调用&#x2F;返回风格"></a>调用&#x2F;返回风格</h5><h6 id="主程序-子程序"><a href="#主程序-子程序" class="headerlink" title="主程序&#x2F;子程序"></a>主程序&#x2F;子程序</h6><p><strong>单线程控制</strong>，把问题划分为若干个处理步骤，构件即为主程序和子程序，子程序通常可合成为模块。过程调用作为交互机制，即充当连接件的角色。调用关系具有层次性，其语义逻辑表现为主程序的正确性取决于它调用的子程序的正确性</p>
<h6 id="面向对象-1"><a href="#面向对象-1" class="headerlink" title="面向对象"></a>面向对象</h6><p>构件是对象，对象是抽象数据类型的实例。在抽象数据类型中，数据的表示和它们的相应操作被封装起来，对象的行为体现在其接受和请求的动作。连接件即是对象间交互的方式，对象是通过函数和过程的调用来交互的</p>
<p>p.s.面向对象是显示调用,而事件是隐式调用的</p>
<h6 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h6><p>构件组织成一个层次结构，连接件通过决定层间如何交互的协议来定义。每层为上一层提供服务，使用下一层的服务，只能见到与自己邻接的层。通过层次结构，可以将大的问题分解为若干个渐进的小问题逐步解决，可以隐藏问题的复杂度。修改某一层，最多影响其相邻的两层（通常只能影响上层）</p>
<p><strong>优点</strong></p>
<ul>
<li><p>这种风格支持基于可增加抽象层的设计,允许将一个复杂问题分解成一个增量步骤序列的实现</p>
</li>
<li><p>不同层次处于不同的抽象级别</p>
<p>越接近底层,抽象级别越高</p>
<p>越接近顶层,抽象级别越低</p>
</li>
<li><p>由于每一层最多只影响两层,同时只要给相邻层提供相同的接口,允许每层用不同的方法</p>
<p>实现,同样为<strong>软件复用</strong>提供了强大的支持</p>
</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>并不是每个系统都可以很容易地划分为分层的模式</li>
<li>很难找到一个合适的,正确的层次抽象方法</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202505211107279.png" alt="image-20250521110712768" style="zoom:25%;" />

<p>层次风格的拓展性非常强</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202505211127152.png" alt="image-20250521112744757" style="zoom:30%;" />

<blockquote>
<p>以下关于C&#x2F;S（客户机&#x2F;服务器）体系结构的优点的叙述中，不正确的是(<code>D</code>)<br>A. 允许合理地划分三层的功能，使之在逻辑上保持相对独立性✅<br>B. 允许各层灵活地选用平台和软件✅<br>C. 各层可以选择不同的开发语言进行并行开发✅<br>D. 系统安装、修改和维护均只在服务器端进行❌: C&#x2F;S客户端也要更新</p>
</blockquote>
<h6 id="层次结构中的MVC架构风格"><a href="#层次结构中的MVC架构风格" class="headerlink" title="层次结构中的MVC架构风格"></a>层次结构中的MVC架构风格</h6><p>MVC架构是层次结构中一种经典的架构</p>
<ul>
<li>Model(模型)是应用程序中用于 <strong>处理应用程序数据逻辑的部分</strong>.通常模型对象负责在数据库中存取数据</li>
<li>View(视图)是应用程序中<strong>处理数据显示的部分</strong>.通常视图是依据模型数据创建的</li>
<li>Controller(控制器)是应用程序中 <strong>处理用户交互的部分</strong>,通常控制器负责从视图读取数据,控制用户输入,并向模型发送数据</li>
</ul>
<table>
<thead>
<tr>
<th align="center"><strong>MVC 组件</strong></th>
<th align="center"><strong>WPF 实现</strong></th>
<th align="center"><strong>职责说明</strong></th>
<th align="center">与传统 J2EE 的对比</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>View</strong></td>
<td align="center">XAML 文件（如 <code>MainWindow.xaml</code>）和部分代码隐藏（Code-Behind）</td>
<td align="center">负责界面渲染和用户交互，通过数据绑定显示数据。但 WPF 的 View 通常不直接操作数据逻辑。</td>
<td align="center">类似 JSP，但通过数据绑定实现动态更新，而非直接嵌入业务逻辑。</td>
</tr>
<tr>
<td align="center"><strong>Controller</strong></td>
<td align="center">路由逻辑或事件处理类（如自定义的 <code>Controller</code> 类）</td>
<td align="center">处理用户输入事件（如按钮点击），协调 Model 和 View 的交互。但在 WPF 中，Controller 的职责常被 ViewModel 替代。</td>
<td align="center">类似 Servlet，但 WPF 的 Controller 更轻量级，且不强制要求独立层（可能与 View 代码耦合）。</td>
</tr>
<tr>
<td align="center"><strong>Model</strong></td>
<td align="center">数据实体类（如 <code>User</code>、<code>Order</code>）和业务逻辑层（如服务类）</td>
<td align="center">管理数据和业务规则，与数据库或 API 交互。与 J2EE 的 Entity Bean&#x2F;Session Bean 功能一致。</td>
<td align="center">直接对应 J2EE 的 Model 层，但 WPF 中 Model 通常不直接暴露给 View，而是通过 ViewModel 封装后传递。</td>
</tr>
</tbody></table>
<h5 id="独立构件风格"><a href="#独立构件风格" class="headerlink" title="独立构件风格"></a>独立构件风格</h5><h6 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h6><p>构件是独立的过程，连接件是消息传递。构件通常是命名过程，消息传递的方式可以是点对点、异步或同步方式，以及远程过程（方法）调用等。</p>
<h6 id="事件驱动系统-隐式调用"><a href="#事件驱动系统-隐式调用" class="headerlink" title="事件驱动系统(隐式调用)"></a>事件驱动系统(隐式调用)</h6><p>构件不直接调用一个过程，而是触发或广播一个或多个事件。构件中的过程在一个或多个事件中注册，当某个事件被触发时，系统自动调用在这个事件中注册的所有过程。一个事件的触发就导致了另一个模块中的过程调用。这种风格中的构件是匿名的过程，它们之间交互的连接件往往是以过程之间的隐式调用来实现的。主要优点是为软件复用提供了强大的支持，为构件的维护和演化带来了方便；其缺点是构件放弃了对系统计算的控制。</p>
<h5 id="虚拟机风格"><a href="#虚拟机风格" class="headerlink" title="虚拟机风格"></a>虚拟机风格</h5><h6 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h6><p>解释器通常包括一个完成解释工作的解释引擎,一个包含将被解释的代码的存储区,一个记录解释引擎当前工作状态的数据结构,以及一个记录源代码被解释执行的进度的数据结构.具有解释器风格的软件中含有一个虚拟机,可以仿真硬件的执行过程和一些关键应用,其确定是执行效率比较低</p>
<h6 id="基于规则的系统"><a href="#基于规则的系统" class="headerlink" title="基于规则的系统"></a>基于规则的系统</h6><p>基于规则的系统包括规则集,规则解释器,规则&#x2F;数据选择器和工作内存,一般用在人工智能领域和DSS中</p>
<h5 id="仓库风格"><a href="#仓库风格" class="headerlink" title="仓库风格"></a>仓库风格</h5><p>是一种以<strong>数据为中心</strong>的规则</p>
<h6 id="数据库系统"><a href="#数据库系统" class="headerlink" title="数据库系统"></a>数据库系统</h6><p>构件主要有两大类，一类是中央共享数据源，保存当前系统的数据状态；另一类是多个独立处理单元，处理单元对数据元素进行操作。</p>
<h6 id="黑板系统"><a href="#黑板系统" class="headerlink" title="黑板系统"></a>黑板系统</h6><p>包括知识源、黑板和控制三部分。知识源包括若干独立计算的不同单元，提供解决问题的知识。知识源响应黑板的变化，也只修改黑板；黑板是一个全局数据库，包含问题域解空间的全部状态，是知识源相互作用的唯一媒介；知识源响应是通过黑板状态的变化来控制的。黑板系统<strong>通常应用在对于解决问题没有确定性算法的软件中</strong>（信号处理、问题规划和编译器优化等）。</p>
<h6 id="超文本系统"><a href="#超文本系统" class="headerlink" title="超文本系统"></a>超文本系统</h6><p>构件以网状链接方式相互连接，用户可以在构件之间进行按照人类的联想思维方式任意跳转到相关构件。超文本是一种非线性的网状信息组织方法，它以结点为基本单位，链作为结点之间的联想式关联。超文本系统通常应用在互联网领域。</p>
<p>现代集成编译环境一般采用这种架构风格</p>
<blockquote>
<p>数据仓库位于该体系结构的中心，其他构件访问该数据仓库并对其中的数据进行增、删、改等操作。以下关于该风格的叙述中，不正确的是（<code>D</code>）。（<code>D</code>）不属于仓库风格。<br>A. 支持可更改性和可维护性 B. 具有可复用的知识源<br>C. 支持容错性和健壮性 D. 测试简单 ❌: 很难测试数据库<br>A. 数据库系统 B. 超文本系统 C. 黑板系统 D. 编译器</p>
</blockquote>
<h2 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h2><p>测试的基本概念及分类</p>
<ul>
<li>尽早,不断的进行测试</li>
<li>程序员避免测试自己设计的程序</li>
<li>既要选择有效,合理的数据,也要选择无效,不合理的数据</li>
<li>修改后应进行回归测试</li>
<li>尚未发现的错误数量与该程序已发现错误数成正比</li>
</ul>
<p><strong>测试用例</strong>的格式一般是输入数据以及他的结果,最后验证是否相符.<strong>一个测试用例,最多只覆盖一个测试错误点</strong></p>
<h3 id="软件测试的分类"><a href="#软件测试的分类" class="headerlink" title="软件测试的分类"></a>软件测试的分类</h3><p>根据是否人工测试来划分</p>
<ul>
<li><p>动态测试(机器运行)</p>
<ul>
<li><p><a href="#%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95%E6%B3%95">黑盒测试法</a></p>
<p>不关心内部细节,只考虑输入输出是否有问题</p>
</li>
<li><p><a href="#%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95%E6%B3%95">白盒测试法</a></p>
<p>具体输入是如何到达输出的,是否有问题</p>
</li>
<li><p>灰盒测试法</p>
<p>结合黑盒与白盒</p>
</li>
</ul>
</li>
<li><p>静态测试(纯人工)</p>
<ul>
<li><p>桌前检查</p>
<p>程序员自己检查</p>
</li>
<li><p>代码审查</p>
<p>其他人检查</p>
</li>
<li><p>代码走查</p>
<p>预想代码执行过程,这个过程中判断其中是否存在问题</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>以下关于软件测试的叙述中， 不正确的是（<code>B</code>）。<br>A. 在设计测试用例时应考虑输入数据和预期输出结果<br>B. 软件测试的目的是证明软件的正确性 ❌: 无法验证一个软件是百分百正确的<br>C. 在设计测试用例时，应该包括合理的输入条件<br>D. 在设计测试用例时，应该包括不合理的输入条件</p>
<p>招聘系统要求求职的人年龄在20岁到60岁之间（含），学历为本科、硕士或者博士，专业为计算机科学与技术、通信工程或者电子工程。其中（<code>C</code>）不是好的测试用例。<br>A.（20，本科，电子工程）✅: 合法<br>B.（18，本科，通信工程）❌: 一个错误点<br>C.（18，大专，电子工程）❌: 两个错误点<br>D.（25，硕士，生物学）❌: 一个错误点</p>
<p><strong>一个测试用例,最多只覆盖一个测试错误点</strong></p>
</blockquote>
<h3 id="黑盒测试法"><a href="#黑盒测试法" class="headerlink" title="黑盒测试法"></a>黑盒测试法</h3><p>有下面几种</p>
<ul>
<li><p><a href="#%E7%AD%89%E4%BB%B7%E7%B1%BB%E5%88%92%E5%88%86">等价类划分</a></p>
</li>
<li><p><a href="#%E8%BE%B9%E7%95%8C%E5%80%BC%E5%88%86%E6%9E%90">边界值分析</a></p>
</li>
<li><p>错误推测</p>
<p>依据经验来进行推测</p>
</li>
<li><p>因果图</p>
<p>通过各个错误结果反推原因</p>
</li>
</ul>
<h4 id="等价类划分"><a href="#等价类划分" class="headerlink" title="等价类划分"></a>等价类划分</h4><p>确定无效与有效等价类,设计用例尽可能多的覆盖有效类,设计用例只覆盖一个无效类</p>
<h4 id="边界值分析"><a href="#边界值分析" class="headerlink" title="边界值分析"></a>边界值分析</h4><p>处理边界情况时最容易出错,选取的测试数据应该恰好等于,稍小于或稍大于边界值</p>
<h3 id="白盒测试法"><a href="#白盒测试法" class="headerlink" title="白盒测试法"></a>白盒测试法</h3><p>重点内容,考察频率高</p>
<p>有以下几种</p>
<ul>
<li>基本路径测试</li>
<li>循环覆盖测试</li>
<li>逻辑覆盖测试(重点)</li>
</ul>
<table>
<thead>
<tr>
<th>覆盖类型</th>
<th>定义</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>语句覆盖</td>
<td>被测试程序中的每条语句至少执行一次。</td>
<td>对执行逻辑覆盖很低，一般认为是很弱的逻辑覆盖。</td>
</tr>
<tr>
<td>判定覆盖（分支覆盖）</td>
<td>被测程序每个判定表达式至少获得一次“真”值和“假”值（或者程序中每一个判定取“真”分支和取“假”分支至少通过一次）。</td>
<td>判定覆盖比语句覆盖更强一些。判定可以是 1 个条件，也可以是多个条件的组合。</td>
</tr>
<tr>
<td>条件覆盖</td>
<td>每一个判定语句中每个逻辑条件的各种可能的值至少满足一次。</td>
<td>条件覆盖和判断覆盖没有包含关系。</td>
</tr>
<tr>
<td>判断&#x2F;条件覆盖</td>
<td>判定中每个条件的所有可能取值（真&#x2F;假）至少出现一次，并使每个判定本身的判定结果（真&#x2F;假）也至少出现一次。</td>
<td>同时满足判定覆盖和条件覆盖。</td>
</tr>
<tr>
<td>条件组合覆盖</td>
<td>每个判定中的各种可能值的组合都至少出现一次。</td>
<td>同时满足判定覆盖、条件覆盖、判断&#x2F;条件覆盖。</td>
</tr>
<tr>
<td>路径覆盖</td>
<td>覆盖被测试程序中所有可能的路径。</td>
<td></td>
</tr>
<tr>
<td>基本路径测试</td>
<td>每一条独立路径都执行过（即程序中可执行语句至少执行一次）。</td>
<td>测试用例个数与环路复杂度一致。判定为关键控制结点，必须出现在基本路径中。</td>
</tr>
<tr>
<td>循环覆盖</td>
<td>循环中每个条件都得到验证。</td>
<td>注意数组参数可循环验证。</td>
</tr>
</tbody></table>
<p><strong>例题</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202505211500613.png" alt="image-20250521150050000" style="zoom: 67%;" />

<ul>
<li>语句覆盖: <code>测试用例2/3/4</code>任意一个都满足</li>
<li>判定覆盖: <code>测试用例1 + 测试用例2/3/4</code> 组合就可以满足</li>
<li>条件覆盖: <code>测试用例1 + 测试用例4</code> 与 <code>测试用例2 + 测试用例3</code> 这两种组合都可以</li>
<li>判定&#x2F;条件覆盖: <code>测试用例1 + 测试用例4</code></li>
<li>路径覆盖: <code>测试用例1 + 测试用例2/3/4</code> 组合就可以满足</li>
</ul>
<p><strong>例题👇🏻</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202505211524240.png" alt="image-20250521152408660" style="zoom: 67%;" />

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202505220918169.png" alt="image-20250522091846468" style="zoom: 33%;" />

<p>观察顺序,发现首次测试A的同时,还测试了EFG,因此是三明治测试策略</p>
<p>D选项的说法不正确,自顶向下的话,测试A还是要做BCD桩模块,而测试E&#x2F;F的时候,还是要做B驱动模块</p>
<h3 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h3><p>经常出现的考点</p>
<p>McCabe复杂度的计算</p>
<p>环路复杂度是环的个数+1(这里的1是顺序流程本身算一个环路)</p>
<p>如果上面的方式不好确定,也可以将图片转换为节点图,即每个交叉点视为一个节点,如下图的转换过程</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202505221033586.png" alt="image-20250522103333011" style="zoom:33%;" />
$$
计算有向图G的环路复杂度公式为:   V(G) = m-n+2
$$
其中V(G)是有向图G中的环路个数,m是G中的有向弧数,n是G中的节点数

<p>上图中右图中环路复杂度为: 15-12+2 &#x3D; 5</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202505221041933.png" alt="image-20250522104132185" style="zoom: 33%;" />

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202505221047375.png" alt="image-20250522104746610" style="zoom: 33%;" />

<p>上题的图:</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202505221048640.png" alt="image-20250522104809784" style="zoom: 33%;" />

<p>注意结束点不要遗漏了,虽然代码中看似没有结束点,但其实是应该有的,要<strong>有始有终</strong></p>
<h2 id="软件维护"><a href="#软件维护" class="headerlink" title="软件维护"></a>软件维护</h2><p>整个软件生存周期中时间最长,耗资最多的阶段</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202505201139924.png" alt="image-20250520113925453" style="zoom: 33%;" />

<h3 id="软件维护类型"><a href="#软件维护类型" class="headerlink" title="软件维护类型"></a>软件维护类型</h3><ul>
<li><strong>改正性维护</strong>: 针对已经出现错误的修改(<strong>错误已经出现</strong>&#x2F;<strong>用户已经发现的</strong>)</li>
<li><strong>适应性维护</strong>: 指使应用软件适应信息技术变化和管理需求变化而进行的修改。企业的外部市场环境和管理需求的不断变化也使得各级管理人员不断提出新信息需求。</li>
<li><strong>预防性维护</strong>: 针对可能出现错误的修改(<strong>错误还未发生</strong>&#x2F;<strong>用户还未发现的</strong>)</li>
<li><strong>完善性维护&#x2F;改善性维护</strong>: 扩充功能和改善性能而进行的修改。对已有的软件系统增加一些在系统分析和设计阶段中没有规定的功能与性能特征。</li>
</ul>
<h3 id="可维护性因素决定"><a href="#可维护性因素决定" class="headerlink" title="可维护性因素决定"></a>可维护性因素决定</h3><ul>
<li>可理解性</li>
<li>可测试性</li>
<li>可修改性</li>
</ul>
<h3 id="例题-8"><a href="#例题-8" class="headerlink" title="例题"></a>例题</h3><blockquote>
<p>系统交付用户使用了一段时间后发现，系统的某个功能响应非常慢。修改了某模块的一个算法使其运行速度得到了提升，则该行为属于（<code>C</code>）维护。<br>A. 改正性<br>B. 适应性<br>C. 改善性<br>D. 预防性</p>
<p>软件维护工具不包括（<code>B</code>）工具。<br>A. 版本控制<br>B. 配置管理<br>C. 文档分析<br>D. 逆向工程</p>
<p>理解: </p>
<ul>
<li>版本控制（A）：明确属于维护工具，用于代码版本跟踪（如Git）</li>
<li>文档分析（C）：用于分析需求文档以指导维护活动</li>
<li>逆向工程（D）：用于恢复代码设计信息以辅助理解</li>
<li>配置管理（B）：是更广泛的管理流程，需通过策略、基线、审计等实现，其工具（如Jira）更多服务于变更控制和过程管理，而非直接参与代码维护</li>
</ul>
<p><strong>软件维护工具</strong>的主要功能是辅助开发人员对代码和文档进行维护活动，其核心工具包括：</p>
<ul>
<li><strong>版本控制工具</strong>（如Git、SVN）：用于管理代码版本和协作开发</li>
<li><strong>文档分析工具</strong>：分析需求、设计等文档以提供维护信息（如影响范围分析）</li>
<li><strong>逆向工程工具</strong>：将低抽象层次的代码转换为更高层次的设计信息（如恢复程序结构）</li>
<li><strong>再工程工具</strong>：重构代码或系统以提升性能或可维护性</li>
</ul>
</blockquote>
<h2 id="软件文档"><a href="#软件文档" class="headerlink" title="软件文档"></a>软件文档</h2><p>简单了解即可</p>
<p>按照交付目标来划分</p>
<ul>
<li><strong>开发文档</strong>  (交付给<strong>项目团队内部成员</strong>)<ul>
<li>可行性研究和项目任务书</li>
<li>需求规格说明</li>
<li>功能规格说明</li>
<li>设计规格说明(包括程序和数据规格说明)</li>
<li>开发计划</li>
<li>软件集成和测试计划</li>
<li>质量保证计划,标准,进度</li>
<li>安全和测试信息</li>
</ul>
</li>
<li><strong>产品文档</strong>  (交付给<strong>客户</strong>的)<ul>
<li>培训手册</li>
<li>参考手册和用户指南</li>
<li>软件支持手册</li>
<li>产品手册和信息广告</li>
</ul>
</li>
<li><strong>管理文档</strong>  (交付给<strong>管理人员</strong>的文档)<ul>
<li>开发过程的每个阶段的进度和进度变更的记录</li>
<li>软件变更情况的记录</li>
<li>相对于开发的判定记录</li>
<li>职责定义</li>
</ul>
</li>
</ul>
<blockquote>
<p>以下关于各类文档撰写阶段的叙述中，不正确的是（<code>C</code>）。<br>A. 软件需求规格说明书在需求分析阶段撰写<br>B. 概要设计规格说明书在设计阶段撰写<br>C. 测试设计必须在测试阶段撰写 ❌: 需求分析阶段就可以撰写测试设计<br>D. 测试分析报告在测试阶段撰写</p>
</blockquote>
<h2 id="软件质量保证模型"><a href="#软件质量保证模型" class="headerlink" title="软件质量保证模型"></a>软件质量保证模型</h2><p>考试只需要能正确进行分类即可</p>
<p>经常会考的情况是给你一个子特性,让你判断它属于哪个类型的特性</p>
<p><strong>软件质量保证ISO&#x2F;IEC9126</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202505221108924.png" alt="image-20250522110805322"></p>
<blockquote>
<p>在ISO&#x2F;IEC软件质量模型中，易使用性的子特性不包括（<code>D</code>）。<br>A. 易理解性<br>B. 易学性<br>C. 易操作性<br>D. 易分析性  ❌: 易分析属于维护性的子特性</p>
</blockquote>
<h1 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h1><ul>
<li><a href="#%E8%BF%9B%E5%BA%A6%E7%AE%A1%E7%90%86">进度管理</a>  (软考中最重要)<ul>
<li><a href="#Gantt%E5%9B%BE">Gantt图</a></li>
<li><a href="#PERT%E5%9B%BE">PERT图</a> 必考</li>
</ul>
</li>
<li>风险管理</li>
<li>成本管理</li>
<li>沟通管理</li>
<li>其他<ul>
<li>配置管理</li>
<li>人员管理</li>
</ul>
</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202505221123581.png" alt="image-20250522112319097" style="zoom: 50%;" />

<h2 id="进度管理"><a href="#进度管理" class="headerlink" title="进度管理"></a>进度管理</h2><p>只考到工具的使用</p>
<h3 id="Gantt图"><a href="#Gantt图" class="headerlink" title="Gantt图"></a>Gantt图</h3><p>了解即可</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202505221128569.png" alt="image-20250522112818171" style="zoom: 50%;" />

<ul>
<li><strong>优点</strong>: Gantt图能够清晰地描述每个任务从何时开始，到何时结束，任务的进程情况以及各个任务之间的<strong>并行关系</strong>。</li>
<li><strong>缺点</strong>: Gantt图不能清晰地反映出任务之间的<strong>依赖关系</strong>，难以确定整个项目的关键所在，也不能反映计划中有潜力的部分。</li>
</ul>
<h3 id="PERT图"><a href="#PERT图" class="headerlink" title="PERT图"></a>PERT图</h3><p>必考</p>
<p>PERT &#x3D; <a href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E6%B3%95">关键路径分析法</a></p>
<ul>
<li><strong>优点</strong>: PERT图不仅给出了每个任务的开始时间、结束时间和完成该任务所需的时间，还给出了<strong>任务之间的关系</strong>，即哪些任务完成之后才能开始另外的一些任务，以及如期完成整个工程的<strong>关键路径</strong>。图中的松弛时间则反映了某些任务是可以推迟其开始时间或延长其所需完成的时间。</li>
<li><strong>缺点</strong>: PERT图不能反映任务之间的<strong>并行关系</strong></li>
</ul>
<p>主要有两种</p>
<ul>
<li><a href="#%E5%89%8D%E5%AF%BC%E5%9B%BE%E6%B3%95">前导图法</a></li>
<li><a href="#%E7%AE%AD%E7%BA%BF%E5%9B%BE%E6%B3%95">箭线图法</a></li>
</ul>
<h4 id="关键路径法"><a href="#关键路径法" class="headerlink" title="关键路径法"></a>关键路径法</h4><p><strong>关键路径法</strong>是在制订进度计划时使用的一种进度网络分析技术</p>
<blockquote>
<p><strong>参数理解</strong></p>
<ul>
<li><strong>关键路径</strong>: 从开始到结束,需要<strong>时间最长</strong>的路径</li>
<li><strong>项目工期</strong>: <strong>完成项目的最少时间</strong>,注意由关键路径即<strong>最长路径决定</strong></li>
<li><strong>总时差(松弛时间)</strong>: 在<strong>不延误总工期</strong>的前提下,该活动的机动事件.活动的总时差等于该活动<strong>最迟完成时间与最早完成时间之差</strong>,或该活动<strong>最迟开始时间与最早开始时间之差</strong></li>
</ul>
</blockquote>
<p>关键路线法沿着项目进度网络路线进行正向与反向分析，从而计算出<br>所有计划活动理论上：</p>
<ul>
<li>最早开始与完成日期</li>
<li>最迟开始与完成日期</li>
</ul>
<p>注：不考虑任何资源限制</p>
<h4 id="前导图法"><a href="#前导图法" class="headerlink" title="前导图法"></a>前导图法</h4><p>单代号网络图,PDM</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202505221353411.png" alt="image-20250522135348885" style="zoom:50%;" />

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202505221354389.png" alt="image-20250522135401008"></p>
<p><strong>节点表示活动,箭头表示依赖</strong></p>
<ul>
<li><code>ES</code>: 最早开始时间</li>
<li><code>EF</code>: 最早完成时间</li>
<li><code>LS</code>: 最迟开始时间</li>
<li><code>LF</code>: 最迟完成时间</li>
</ul>
<p>最早开始时间由前趋最早完成决定(最大值后推)</p>
<p>最晚结束时间由后续推动(最小值前推)<br>$$<br>总时差 &#x3D; 最晚开始时间 - 最早开始时间<br>$$<br>所有总时差为0的路径就是关键路径</p>
<blockquote>
<p><strong>例题</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202505221541264.png" alt="image-20250522154141556" style="zoom: 33%;" />

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202505221541621.png" alt="image-20250522154137823" style="zoom:33%;" />
</blockquote>
<h4 id="箭线图法"><a href="#箭线图法" class="headerlink" title="箭线图法"></a>箭线图法</h4><p>双代号网络图,ADM</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202505221530700.png" alt="image-20250522153007876" style="zoom:33%;" />

<p>箭头表示活动,圆圈数字表示状态,箭头上的数字是持续时间</p>
<p>虚线表示的虚活动,持续时间为0,只是为了表示前驱关系</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202505221530103.png" alt="image-20250522153025722" style="zoom: 33%;" />

<blockquote>
<p><strong>例题</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202505221551401.png" alt="image-20250522155025007" style="zoom: 33%;" />

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202505221551637.png" alt="image-20250522155132664" style="zoom: 25%;" />

<p>上面的情况如果需要同一个开发人员完成BC和BD,则完成该项目的最少时间为(<code>20</code>)天</p>
<p>需要考虑两种情况</p>
<ul>
<li><p>先BC再BD   21天</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202505221557739.png" alt="image-20250522155748043" style="zoom:25%;" />
</li>
<li><p>先BD再BC   20天</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202505221557344.png" alt="image-20250522155728511" style="zoom:25%;" /></li>
</ul>
<p>应该选择先BD再BC,即20天</p>
</blockquote>
<h2 id="风险管理"><a href="#风险管理" class="headerlink" title="风险管理"></a>风险管理</h2><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202505221606762.png" alt="image-20250522160611426" style="zoom:25%;" />

<p><strong>风险分类</strong></p>
<ul>
<li><p>项目风险</p>
<p>项目内部的风险</p>
</li>
<li><p>技术风险</p>
<p>技术选择过高或过于落后</p>
</li>
<li><p>商业风险</p>
<p>经济收益相关的这类,包括市场接收方面的,还包括社会人文道德政治等风险</p>
</li>
</ul>
<p><strong>评估风险大小</strong><br>$$<br>风险曝光度(Risk\ Exposure) &#x3D; 风险出现的概率 \times 风险可能造成的损失<br>$$<br>假设正在开发的软件项目可能存在一个未被发现的错误，而这个错误出现的概率是0.5%，给公司造成的损失将是1000000元，那么这个错误的风险曝光度就应为<code>1000000×0.5%=5000元</code>。</p>
<blockquote>
<p>以下叙述中，（<code>B</code>）不是一个风险。<br>A. 由另一个小组开发的子系统可能推迟交付，导致系统不能按时交付客户 ✅: 项目风险<br>B. 客户不清楚想要开发什么样的软件，因此开发小组开发原型帮助其确定需求 ❌: <code>客户不清楚想要开发什么样的软件</code>是已经发生的事情,不是风险<br>C. 开发团队可能没有正确理解客户的需求 ✅: 项目风险<br>D. 开发团队核心成员可能在系统开发过程中离职 ✅: 项目风险</p>
<p>以下不属于软件项目风险的是（<code>A</code>）。<br>A. 团队成员可以进行良好沟通<br>B. 团队成员离职<br>C. 团队成员缺乏某方面培训<br>D. 招不到符合项目技术要求的团队成员</p>
</blockquote>
<h2 id="沟通管理"><a href="#沟通管理" class="headerlink" title="沟通管理"></a>沟通管理</h2><p>软考只涉及到沟通路径的计算</p>
<p>n个程序员的沟通数计算</p>
<ul>
<li><p>无主程序员的沟通数<br>$$<br>1+2+3+…+(n-3)+(n-2)+(n-1) &#x3D; (1+n-1)*(n-1)&#x2F;2<br>$$</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202505221706640.png" alt="image-20250522170647125" style="zoom: 25%;" />
</li>
<li><p>1个主程序员的沟通数<br>$$<br>n-1<br>$$</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202505221707501.png" alt="image-20250522170747000" style="zoom:25%;" /></li>
</ul>
<blockquote>
<p>在进行软件开发时，采用无主程序员的开发小组，成员之间相互平等；而主程序员负责制的开发小组，由一个主程序员和若干成员组成，成员之间没有沟通。在一个由8名开发人员构成的小组中，无主程序员组和主程序员组的沟通路径分别是（<code>D</code>）。<br>A. 32和8 B. 32和7 C. 28和8 D. 28和7</p>
</blockquote>
<h2 id="成本管理"><a href="#成本管理" class="headerlink" title="成本管理"></a>成本管理</h2><p>主要考点是<strong>COCOMO II模型</strong></p>
<p>该模型主要用于成本估量的  </p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202505221714181.png" alt="image-20250522171443742" style="zoom:30%;" />

<blockquote>
<p>工作量估算模型COCOMO II的层次结构中，估算选择不包括（<code>C</code>）。<br>A. 对象点<br>B. 功能点<br>C. 用例数<br>D. 源代码行</p>
</blockquote>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4" title="头像" alt="头像"></a><div class="post-copyright__author_name">ZEROKO14</div><div class="post-copyright__author_desc">zeroko14's blog</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://che77a38.github.io/posts/%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://che77a38.github.io/posts/%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/')">开发项目管理</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://che77a38.github.io/posts/%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=开发项目管理&amp;url=https://che77a38.github.io/posts/%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://che77a38.github.io" target="_blank">ZEROKO14的个人博客</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E7%AE%A1%E7%90%86/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>管理<span class="tagsPageCount">1</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/mac%E5%8F%8Alinux_C++%E7%8E%AF%E5%A2%83/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">mac及linux C++环境配置</div></div></a></div><div class="next-post pull-right"><a href="/posts/%E6%95%B0%E5%AD%A6/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">数学</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description">欢迎来到ZEROKO14的个人博客</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">ZEROKO14</h1><div class="author-info__desc">zeroko14's blog</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/che77a38" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E7%9A%84%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">项目开发的一般流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-number">1.1.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#web%E4%BC%81%E4%B8%9A%E5%BC%80%E5%8F%91%E6%9E%B6%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">web企业开发架构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3"><span class="toc-number">3.</span> <span class="toc-text">编程思想</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E6%8A%BD%E8%B1%A1"><span class="toc-number">3.1.</span> <span class="toc-text">什么时候需要抽象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E5%BB%BA%E8%AE%AE"><span class="toc-number">3.2.</span> <span class="toc-text">命名建议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%9F%E7%B3%95%E7%9A%84%E5%91%BD%E5%90%8D%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.2.1.</span> <span class="toc-text">糟糕的命名模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%BB%E9%99%A43%E5%B1%82%E7%BC%A9%E8%BF%9B"><span class="toc-number">3.3.</span> <span class="toc-text">去除3层缩进</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E9%A9%B1%E5%8A%A8%E6%B3%95"><span class="toc-number">3.3.1.</span> <span class="toc-text">表驱动法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E6%97%A9%E8%BF%94%E5%9B%9E"><span class="toc-number">3.3.2.</span> <span class="toc-text">提早返回</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.3.3.</span> <span class="toc-text">面向对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E7%A7%80%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3"><span class="toc-number">3.4.</span> <span class="toc-text">优秀的程序设计思想</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%A6%BB%E9%80%BB%E8%BE%91%E5%B1%82%E5%92%8C%E8%A1%A8%E7%A4%BA%E5%B1%82"><span class="toc-number">3.4.1.</span> <span class="toc-text">分离逻辑层和表示层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%B8%85%E6%99%B0%E5%8C%96%E8%A1%A8%E8%BE%BE"><span class="toc-number">3.4.2.</span> <span class="toc-text">代码清晰化表达</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E5%85%B1%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%8F%91%E5%B8%83%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.4.3.</span> <span class="toc-text">公共接口与发布接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E4%BB%A3%E7%A0%81%E6%89%80%E6%9C%89%E6%9D%83%E5%92%8C%E5%BC%B1%E4%BB%A3%E7%A0%81%E6%89%80%E6%9C%89%E6%9D%83"><span class="toc-number">3.4.4.</span> <span class="toc-text">强代码所有权和弱代码所有权</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E5%88%92%E5%9E%8B%E8%AE%BE%E8%AE%A1%E5%92%8C%E8%BF%9B%E5%8C%96%E5%9E%8B%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.</span> <span class="toc-text">计划型设计和进化型设计</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%87%8D%E6%9E%84"><span class="toc-number">5.</span> <span class="toc-text">重构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E6%9E%84%E6%98%AF%E5%A6%82%E4%BD%95%E6%94%B9%E8%BF%9B%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-number">5.1.</span> <span class="toc-text">重构是如何改进设计的呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E6%9E%84%E4%B8%8E%E9%87%8D%E5%86%99"><span class="toc-number">5.2.</span> <span class="toc-text">重构与重写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%81%B5%E6%B4%BB%E6%80%A7%E4%B8%8E%E5%A4%8D%E6%9D%82%E6%80%A7"><span class="toc-number">5.3.</span> <span class="toc-text">灵活性与复杂性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E6%9E%84%E5%AE%9E%E4%BE%8B%E5%8F%82%E8%80%83"><span class="toc-number">5.4.</span> <span class="toc-text">重构实例参考</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-number">6.</span> <span class="toc-text">测试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%8E%A5%E5%8F%A3"><span class="toc-number">6.1.</span> <span class="toc-text">测试与接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">6.2.</span> <span class="toc-text">单元测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%B8%8E%E8%B0%83%E4%BC%98"><span class="toc-number">7.</span> <span class="toc-text">性能与调优</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7%E4%B8%8E%E6%95%88%E7%8E%87"><span class="toc-number">7.1.</span> <span class="toc-text">可维护性与效率</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8C%96"><span class="toc-number">7.2.</span> <span class="toc-text">优化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%8F%E6%8D%B7%E5%AE%A3%E8%A8%80"><span class="toc-number">8.</span> <span class="toc-text">敏捷宣言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">9.</span> <span class="toc-text">代码设计原则</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99"><span class="toc-number">9.1.</span> <span class="toc-text">开闭原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99"><span class="toc-number">9.2.</span> <span class="toc-text">依赖倒置原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99"><span class="toc-number">9.3.</span> <span class="toc-text">接口隔离原则</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%96%B9%E5%BC%8F"><span class="toc-number">10.</span> <span class="toc-text">软件开发方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91-TDD"><span class="toc-number">10.1.</span> <span class="toc-text">测试驱动开发 (TDD)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%8C%E4%B8%BA%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91-BDD"><span class="toc-number">10.2.</span> <span class="toc-text">行为驱动开发 (BDD)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%B6%E9%80%A0%E4%B8%9A%E7%9B%B8%E5%85%B3%E6%B5%81%E7%A8%8B%E6%A0%87%E5%87%86"><span class="toc-number">11.</span> <span class="toc-text">制造业相关流程标准</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#FA%E5%8A%9F%E8%83%BD%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B"><span class="toc-number">11.1.</span> <span class="toc-text">FA功能开发流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SEMI%E6%A0%87%E5%87%86"><span class="toc-number">11.2.</span> <span class="toc-text">SEMI标准</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A1%A8%E7%8E%B0%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F"><span class="toc-number">12.</span> <span class="toc-text">表现模式&#x2F;设计模式&#x2F;架构模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F"><span class="toc-number">13.</span> <span class="toc-text">架构模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84"><span class="toc-number">13.1.</span> <span class="toc-text">三层架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">13.1.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">13.1.2.</span> <span class="toc-text">三层架构的优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E5%B1%82"><span class="toc-number">13.1.3.</span> <span class="toc-text">数据操作层</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A1%A8%E7%8E%B0%E6%A8%A1%E5%BC%8F"><span class="toc-number">14.</span> <span class="toc-text">表现模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MVC"><span class="toc-number">14.1.</span> <span class="toc-text">MVC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">14.1.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">14.1.2.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVC%E4%B8%8E%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">14.1.3.</span> <span class="toc-text">MVC与三层架构的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MVVM"><span class="toc-number">14.2.</span> <span class="toc-text">MVVM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="toc-number">14.2.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-1"><span class="toc-number">14.2.2.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVC%E4%B8%8EMVVM%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">14.2.3.</span> <span class="toc-text">MVC与MVVM的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">15.</span> <span class="toc-text">驱动方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8"><span class="toc-number">15.1.</span> <span class="toc-text">事件驱动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8"><span class="toc-number">15.2.</span> <span class="toc-text">数据驱动</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-number">16.</span> <span class="toc-text">函数式编程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC"><span class="toc-number">17.</span> <span class="toc-text">控制反转</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%88%87%E7%89%87%E7%BC%96%E7%A8%8B"><span class="toc-number">18.</span> <span class="toc-text">面向切片编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">18.1.</span> <span class="toc-text">动态代理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B"><span class="toc-number">19.</span> <span class="toc-text">软件工程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%9A%84%E7%94%9F%E5%AD%98%E5%91%A8%E6%9C%9F"><span class="toc-number">19.1.</span> <span class="toc-text">软件的生存周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B"><span class="toc-number">19.2.</span> <span class="toc-text">软件过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CMM%E6%A8%A1%E5%9E%8B"><span class="toc-number">19.2.1.</span> <span class="toc-text">CMM模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMMI%E6%A8%A1%E5%9E%8B"><span class="toc-number">19.2.2.</span> <span class="toc-text">CMMI模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5%E5%BC%8F%E6%A8%A1%E5%9E%8B-5%E7%BA%A7%E6%A8%A1%E5%9E%8B"><span class="toc-number">19.2.2.1.</span> <span class="toc-text">阶段式模型 5级模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E5%BC%8F%E6%A8%A1%E5%9E%8B-6%E7%BA%A7%E6%A8%A1%E5%9E%8B"><span class="toc-number">19.2.2.2.</span> <span class="toc-text">连续式模型 6级模型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-number">19.2.3.</span> <span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95"><span class="toc-number">19.3.</span> <span class="toc-text">软件开发方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E6%96%B9%E6%B3%95"><span class="toc-number">19.3.1.</span> <span class="toc-text">结构化方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E6%B3%95"><span class="toc-number">19.3.2.</span> <span class="toc-text">原型法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">19.3.3.</span> <span class="toc-text">面向对象的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">19.3.4.</span> <span class="toc-text">面向服务的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-1"><span class="toc-number">19.3.5.</span> <span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B"><span class="toc-number">19.4.</span> <span class="toc-text">软件开发模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B%E4%B8%8EV%E6%A8%A1%E5%9E%8B"><span class="toc-number">19.4.1.</span> <span class="toc-text">瀑布模型与V模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B"><span class="toc-number">19.4.1.1.</span> <span class="toc-text">瀑布模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#V%E6%A8%A1%E5%9E%8B"><span class="toc-number">19.4.1.2.</span> <span class="toc-text">V模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-2"><span class="toc-number">19.4.1.3.</span> <span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%94%E5%8C%96%E6%A8%A1%E5%9E%8B"><span class="toc-number">19.4.2.</span> <span class="toc-text">演化模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">19.4.2.1.</span> <span class="toc-text">原型模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-3"><span class="toc-number">19.4.2.1.1.</span> <span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%9E%BA%E6%97%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">19.4.2.2.</span> <span class="toc-text">螺旋模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-4"><span class="toc-number">19.4.2.2.1.</span> <span class="toc-text">例题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E6%A8%A1%E5%9E%8B"><span class="toc-number">19.4.3.</span> <span class="toc-text">增量模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-5"><span class="toc-number">19.4.3.1.</span> <span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%96%B7%E6%B3%89%E6%A8%A1%E5%9E%8B"><span class="toc-number">19.4.4.</span> <span class="toc-text">喷泉模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-6"><span class="toc-number">19.4.4.1.</span> <span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E4%B8%80%E8%BF%87%E7%A8%8BUP"><span class="toc-number">19.4.5.</span> <span class="toc-text">统一过程UP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%8F%E6%8D%B7%E6%96%B9%E6%B3%95"><span class="toc-number">19.4.6.</span> <span class="toc-text">敏捷方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%81%E9%99%90%E7%BC%96%E7%A8%8BXP"><span class="toc-number">19.4.6.1.</span> <span class="toc-text">极限编程XP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-7"><span class="toc-number">19.4.6.2.</span> <span class="toc-text">例题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90"><span class="toc-number">19.5.</span> <span class="toc-text">需求分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">19.5.1.</span> <span class="toc-text">需求的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="toc-number">19.5.2.</span> <span class="toc-text">需求分析的工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE-DFD"><span class="toc-number">19.5.3.</span> <span class="toc-text">数据流图(DFD)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7"><span class="toc-number">19.5.3.1.</span> <span class="toc-text">解题技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%B9%B3%E8%A1%A1%E5%8E%9F%E5%88%99"><span class="toc-number">19.5.3.1.1.</span> <span class="toc-text">数据平衡原则</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8"><span class="toc-number">19.5.4.</span> <span class="toc-text">数据字典</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E8%AF%AD%E8%A8%80"><span class="toc-number">19.5.5.</span> <span class="toc-text">结构化语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E5%AE%9A%E8%A1%A8"><span class="toc-number">19.5.6.</span> <span class="toc-text">判定表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E5%AE%9A%E6%A0%91"><span class="toc-number">19.5.7.</span> <span class="toc-text">判定树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1"><span class="toc-number">19.6.</span> <span class="toc-text">系统设计&#x2F;软件设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%88%B0%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="toc-number">19.6.1.</span> <span class="toc-text">使用到的工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1"><span class="toc-number">19.6.2.</span> <span class="toc-text">模块设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">19.6.2.1.</span> <span class="toc-text">模块设计原则</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E8%81%9A%E6%80%A7"><span class="toc-number">19.6.2.1.1.</span> <span class="toc-text">内聚性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%80%A6%E5%90%88%E6%80%A7"><span class="toc-number">19.6.2.1.2.</span> <span class="toc-text">耦合性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%BA%E6%9C%BA%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1"><span class="toc-number">19.6.3.</span> <span class="toc-text">人机界面设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">19.6.4.</span> <span class="toc-text">架构设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC"><span class="toc-number">19.6.4.1.</span> <span class="toc-text">架构风格</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E9%A3%8E%E6%A0%BC"><span class="toc-number">19.6.4.1.1.</span> <span class="toc-text">数据流风格</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%89%B9%E5%A4%84%E7%90%86%E5%BA%8F%E5%88%97"><span class="toc-number">19.6.4.1.1.1.</span> <span class="toc-text">批处理序列</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AE%A1%E9%81%93-%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">19.6.4.1.1.2.</span> <span class="toc-text">管道-过滤器</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B0%83%E7%94%A8-%E8%BF%94%E5%9B%9E%E9%A3%8E%E6%A0%BC"><span class="toc-number">19.6.4.1.2.</span> <span class="toc-text">调用&#x2F;返回风格</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%BB%E7%A8%8B%E5%BA%8F-%E5%AD%90%E7%A8%8B%E5%BA%8F"><span class="toc-number">19.6.4.1.2.1.</span> <span class="toc-text">主程序&#x2F;子程序</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-1"><span class="toc-number">19.6.4.1.2.2.</span> <span class="toc-text">面向对象</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">19.6.4.1.2.3.</span> <span class="toc-text">层次结构</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84MVC%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC"><span class="toc-number">19.6.4.1.2.4.</span> <span class="toc-text">层次结构中的MVC架构风格</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%8B%AC%E7%AB%8B%E6%9E%84%E4%BB%B6%E9%A3%8E%E6%A0%BC"><span class="toc-number">19.6.4.1.3.</span> <span class="toc-text">独立构件风格</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-number">19.6.4.1.3.1.</span> <span class="toc-text">进程通信</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%B3%BB%E7%BB%9F-%E9%9A%90%E5%BC%8F%E8%B0%83%E7%94%A8"><span class="toc-number">19.6.4.1.3.2.</span> <span class="toc-text">事件驱动系统(隐式调用)</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%A3%8E%E6%A0%BC"><span class="toc-number">19.6.4.1.4.</span> <span class="toc-text">虚拟机风格</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E5%99%A8"><span class="toc-number">19.6.4.1.4.1.</span> <span class="toc-text">解释器</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E8%A7%84%E5%88%99%E7%9A%84%E7%B3%BB%E7%BB%9F"><span class="toc-number">19.6.4.1.4.2.</span> <span class="toc-text">基于规则的系统</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%93%E5%BA%93%E9%A3%8E%E6%A0%BC"><span class="toc-number">19.6.4.1.5.</span> <span class="toc-text">仓库风格</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F"><span class="toc-number">19.6.4.1.5.1.</span> <span class="toc-text">数据库系统</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%BB%91%E6%9D%BF%E7%B3%BB%E7%BB%9F"><span class="toc-number">19.6.4.1.5.2.</span> <span class="toc-text">黑板系统</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%B6%85%E6%96%87%E6%9C%AC%E7%B3%BB%E7%BB%9F"><span class="toc-number">19.6.4.1.5.3.</span> <span class="toc-text">超文本系统</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95"><span class="toc-number">19.7.</span> <span class="toc-text">软件测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">19.7.1.</span> <span class="toc-text">软件测试的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95%E6%B3%95"><span class="toc-number">19.7.2.</span> <span class="toc-text">黑盒测试法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%89%E4%BB%B7%E7%B1%BB%E5%88%92%E5%88%86"><span class="toc-number">19.7.2.1.</span> <span class="toc-text">等价类划分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%B9%E7%95%8C%E5%80%BC%E5%88%86%E6%9E%90"><span class="toc-number">19.7.2.2.</span> <span class="toc-text">边界值分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95%E6%B3%95"><span class="toc-number">19.7.3.</span> <span class="toc-text">白盒测试法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%B5%8B%E8%AF%95"><span class="toc-number">19.7.4.</span> <span class="toc-text">系统测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4"><span class="toc-number">19.8.</span> <span class="toc-text">软件维护</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4%E7%B1%BB%E5%9E%8B"><span class="toc-number">19.8.1.</span> <span class="toc-text">软件维护类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7%E5%9B%A0%E7%B4%A0%E5%86%B3%E5%AE%9A"><span class="toc-number">19.8.2.</span> <span class="toc-text">可维护性因素决定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-8"><span class="toc-number">19.8.3.</span> <span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%96%87%E6%A1%A3"><span class="toc-number">19.9.</span> <span class="toc-text">软件文档</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81%E6%A8%A1%E5%9E%8B"><span class="toc-number">19.10.</span> <span class="toc-text">软件质量保证模型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86"><span class="toc-number">20.</span> <span class="toc-text">项目管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E5%BA%A6%E7%AE%A1%E7%90%86"><span class="toc-number">20.1.</span> <span class="toc-text">进度管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Gantt%E5%9B%BE"><span class="toc-number">20.1.1.</span> <span class="toc-text">Gantt图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PERT%E5%9B%BE"><span class="toc-number">20.1.2.</span> <span class="toc-text">PERT图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E6%B3%95"><span class="toc-number">20.1.2.1.</span> <span class="toc-text">关键路径法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E5%AF%BC%E5%9B%BE%E6%B3%95"><span class="toc-number">20.1.2.2.</span> <span class="toc-text">前导图法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%AD%E7%BA%BF%E5%9B%BE%E6%B3%95"><span class="toc-number">20.1.2.3.</span> <span class="toc-text">箭线图法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A3%8E%E9%99%A9%E7%AE%A1%E7%90%86"><span class="toc-number">20.2.</span> <span class="toc-text">风险管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B2%9F%E9%80%9A%E7%AE%A1%E7%90%86"><span class="toc-number">20.3.</span> <span class="toc-text">沟通管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E6%9C%AC%E7%AE%A1%E7%90%86"><span class="toc-number">20.4.</span> <span class="toc-text">成本管理</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/%E7%89%A9%E7%90%86/" title="物理">物理</a><time datetime="2025-09-29T01:48:42.561Z" title="发表于 2025-09-29 09:48:42">2025-09-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/%E5%B7%A5%E4%B8%9A%E7%9B%B8%E5%85%B3/" title="工业相关">工业相关</a><time datetime="2025-02-14T03:04:40.761Z" title="发表于 2025-02-14 11:04:40">2025-02-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3/" title="嵌入式相关">嵌入式相关</a><time datetime="2025-02-14T03:04:40.761Z" title="发表于 2025-02-14 11:04:40">2025-02-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/" title="操作系统">操作系统</a><time datetime="2024-12-16T01:38:01.470Z" title="发表于 2024-12-16 09:38:01">2024-12-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/%E8%AE%A1%E7%BB%84/" title="计算机组成原理">计算机组成原理</a><time datetime="2024-12-16T01:38:01.470Z" title="发表于 2024-12-16 09:38:01">2024-12-16</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2025 By <a class="footer-bar-link" href="/" title="ZEROKO14" target="_blank">ZEROKO14</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu"></a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">74</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">57</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">6</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AI/" style="font-size: 0.88rem;">AI<sup>1</sup></a><a href="/tags/C/" style="font-size: 0.88rem;">C#<sup>3</sup></a><a href="/tags/C/" style="font-size: 0.88rem;">C++<sup>5</sup></a><a href="/tags/CSS/" style="font-size: 0.88rem;">CSS<sup>1</sup></a><a href="/tags/CSharp/" style="font-size: 0.88rem;">CSharp<sup>1</sup></a><a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 0.88rem;">C语言<sup>1</sup></a><a href="/tags/FPS/" style="font-size: 0.88rem;">FPS<sup>1</sup></a><a href="/tags/HTML/" style="font-size: 0.88rem;">HTML<sup>1</sup></a><a href="/tags/JavaScript/" style="font-size: 0.88rem;">JavaScript<sup>1</sup></a><a href="/tags/MFC/" style="font-size: 0.88rem;">MFC<sup>1</sup></a><a href="/tags/PE/" style="font-size: 0.88rem;">PE<sup>1</sup></a><a href="/tags/QT/" style="font-size: 0.88rem;">QT<sup>1</sup></a><a href="/tags/WPF/" style="font-size: 0.88rem;">WPF<sup>3</sup></a><a href="/tags/ai/" style="font-size: 0.88rem;">ai<sup>1</sup></a><a href="/tags/cmake/" style="font-size: 0.88rem;">cmake<sup>1</sup></a><a href="/tags/doxygen/" style="font-size: 0.88rem;">doxygen<sup>1</sup></a><a href="/tags/git/" style="font-size: 0.88rem;">git<sup>1</sup></a><a href="/tags/linux/" style="font-size: 0.88rem;">linux<sup>1</sup></a><a href="/tags/nas/" style="font-size: 0.88rem;">nas<sup>1</sup></a><a href="/tags/next/" style="font-size: 0.88rem;">next<sup>1</sup></a><a href="/tags/ppt/" style="font-size: 0.88rem;">ppt<sup>1</sup></a><a href="/tags/python/" style="font-size: 0.88rem;">python<sup>1</sup></a><a href="/tags/slidev/" style="font-size: 0.88rem;">slidev<sup>1</sup></a><a href="/tags/vue/" style="font-size: 0.88rem;">vue<sup>1</sup></a><a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 0.88rem;">代码规范<sup>1</sup></a><a href="/tags/%E5%86%85%E6%A0%B8/" style="font-size: 0.88rem;">内核<sup>2</sup></a><a href="/tags/%E5%86%85%E6%A0%B8%E7%9B%B8%E5%85%B3/" style="font-size: 0.88rem;">内核相关<sup>5</sup></a><a href="/tags/%E5%8A%A0%E8%A7%A3%E5%AF%86/" style="font-size: 0.88rem;">加解密<sup>1</sup></a><a href="/tags/%E5%9F%BA%E7%A1%80/" style="font-size: 0.88rem;">基础<sup>6</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 0.88rem;">多线程<sup>1</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F/" style="font-size: 0.88rem;">并发模式<sup>1</sup></a><a href="/tags/%E5%BC%80%E5%8F%91/" style="font-size: 0.88rem;">开发<sup>4</sup></a><a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 0.88rem;">数学<sup>1</sup></a><a href="/tags/%E6%9D%82%E9%A1%B9/" style="font-size: 0.88rem;">杂项<sup>1</sup></a><a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 0.88rem;">正则表达式<sup>1</sup></a><a href="/tags/%E7%89%A9%E7%90%86/" style="font-size: 0.88rem;">物理<sup>1</sup></a><a href="/tags/%E7%9B%91%E6%8E%A7/" style="font-size: 0.88rem;">监控<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 0.88rem;">网络<sup>3</sup></a><a href="/tags/%E9%80%86%E5%90%91/" style="font-size: 0.88rem;">逆向<sup>5</sup></a><a href="/tags/%E9%AD%94%E6%B3%95/" style="font-size: 0.88rem;">魔法<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.cbd.int/mathjax@3.2.2/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.cbd.int/mermaid@10.2.4/dist/mermaid.min.js').then(runMermaid)
  }

  anzhiyu.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>