<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>开发项目管理 | ZEROKO14的个人博客</title><meta name="keywords" content="管理"><meta name="author" content="ZEROKO14"><meta name="copyright" content="ZEROKO14"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#18171d"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="开发项目管理"><meta name="application-name" content="开发项目管理"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#18171d"><meta property="og:type" content="article"><meta property="og:title" content="开发项目管理"><meta property="og:url" content="https://che77a38.github.io/posts/%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/index.html"><meta property="og:site_name" content="ZEROKO14的个人博客"><meta property="og:description" content="此处记录开发思想,项目管理,组织架构,流程标准等等   项目开发的一般流程提出需求–&amp;gt;需求分析–&amp;gt;概要设计–&amp;gt;详细设计–&amp;gt;编码–&amp;gt;测试(内部自己测试和专门人员测试)–&amp;gt;项目验收(提供相关上线材料)–&amp;gt;上线(投入运营)–&amp;gt;日常维护–&amp;gt;版本更新(发现"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4"><meta property="article:author" content="ZEROKO14"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4"><meta name="description" content="此处记录开发思想,项目管理,组织架构,流程标准等等   项目开发的一般流程提出需求–&amp;gt;需求分析–&amp;gt;概要设计–&amp;gt;详细设计–&amp;gt;编码–&amp;gt;测试(内部自己测试和专门人员测试)–&amp;gt;项目验收(提供相关上线材料)–&amp;gt;上线(投入运营)–&amp;gt;日常维护–&amp;gt;版本更新(发现"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://che77a38.github.io/posts/%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2024/07/27/125766904/ba62475f396df9de3316a08ed9e65d86_5680958632268053399..png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":true,"limitCount":50,"languages":{"author":"作者: ZEROKO14","link":"链接: ","source":"来源: ZEROKO14的个人博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'ZEROKO14的个人博客',
  title: '开发项目管理',
  postAI: '',
  pageFillDescription: '项目开发的一般流程, 案例, web企业开发架构, 编程思想, 什么时候需要抽象, 命名建议, 糟糕的命名模式, 去除3层缩进, 表驱动法, 提早返回, 面向对象, 优秀的程序设计思想, 分离逻辑层和表示层, 代码清晰化表达, 公共接口与发布接口, 强代码所有权和弱代码所有权, 计划型设计和进化型设计, 重构, 重构是如何改进设计的呢？, 重构与重写, 灵活性与复杂性, 重构实例参考, 测试, 测试与接口, 单元测试, 性能与调优, 可维护性与效率, 优化, 敏捷宣言, 代码设计原则, 开闭原则, 依赖倒置原则, 接口隔离原则, 软件开发方式, 测试驱动开发 (TDD), 行为驱动开发 (BDD), 制造业相关流程标准, FA功能开发流程, SEMI标准, 表现模式x2F设计模式x2F架构模式, 架构模式, 三层架构, 概述, 三层架构的优势, 数据操作层, 表现模式, MVC, 概述, 优点, MVC与三层架构的关系, MVVM, 概述, 优点, MVC与MVVM的区别, 驱动方式, 事件驱动, 数据驱动, 函数式编程, 控制反转, 面向切片编程, 动态代理此处记录开发思想项目管理组织架构流程标准等等项目开发的一般流程提出需求需求分析概要设计详细设计编码测试内部自己测试和专门人员测试项目验收提供相关上线材料上线投入运营日常维护版本更新发现并解决下线弃用需求提炼项目的子系统划分每个子系统的模块分解项目的开发经历经验积累开发流程项目调试第三方框架开源库的积累锻炼快读阅读代码的能力锻炼对封装好的的快速上手能力锻炼处理问题的逻辑思维能力案例涉及的知识网络通信结合的多线程或多进程第三方库报文编解码进程间通信套接字管道命名管道共享内存数据库操作相关的库守护进程创建信号相关等等编程相关加密算法相关多线程开发子系统划分秘钥协商客户端子系统秘钥协商服务端子系统客户端信息注册报备图形化界面系统模块划分报文编解码模块网络通信模块共享内存操作模块数据库操作模块外联接口企业开发架构架构讲解编程思想什么时候需要抽象抽象可以减少重复代码但也会带来耦合代码耦合是指代码之间的依赖关系和相互影响程度代码耦合越高不同部分之间的依赖性越强修改一个部分可能会影响其他部分导致代码难以维护和扩展为了降低代码耦合可以采取一些措施比如模块化设计接口隔离依赖注入等这样可以使代码更加灵活可维护和可扩展抽象和耦合如影随形只有下面两种情况才真正有价值有不同的处理方式特别是不同的处理方式需要的参数也不相同该统一操作需要自动执行调度程序不应该关注具体处理程序的种类和细节总的来说只有当抽象化带来的价值超过耦合时才适合应用抽象化一点重复代码带来的痛苦总是比过度耦合要小相对于过耦合重复代码的技术债也总是最廉价的命名建议计算机科学中只有两个难题缓存失效和命名糟糕的命名模式不要以或命名一个类如果你发现自己无法给父类起个好名字那很可能意味着应该重新命名子类当很多代码都放在中时请考虑重构另有一条建议除非类型已经包含单位信息否则请在变量中添加单位去除层缩进代码指南中提到如果你需要超过层的缩进说明你的程序已经开始混乱应该修复你的程序下面罗列了一些去除层缩进的方法表驱动法凡是可以通过逻辑语句来选择的事物都可以通过查表法来解决对于简单的语句逻辑语句更加简单直白但随着选项越来越多表驱动法就更有优势了优势逻辑数据分离易维护使用实现的表驱动法提早返回防御性编程子程序应该不因传入错误数据而破坏哪怕是由其他子程序产生的逻辑错误此时通过早退出或早返回可以简化复杂的参数验证使用断言的话甚至能省去参数验证的语句甚至还可以将参数验证提取出来作为一个独立的函数也是不错的选择面向对象多态调用其实类似分支如图多态能把分支逻辑隐藏起来所以利用面向对象的多态加上工厂模式可以将分支逻辑分离并独立出来让主逻辑更加清晰优秀的程序设计思想分离逻辑层和表示层由于表示层和业务逻辑相互独立在程序维护阶段所需要做出的变化将变得相当容易分离了表示层和业务逻辑的程序也很容易被测试代码清晰化表达在字典和创建新类传达数据的情况下选择创建新类因为字典很不明确你根本就无法得知字典里关键字的真实意思字典不能确定称买东西的人是顾客还是客户即使是拼写错误也无法检查出来更重要的是即使你看完代码还是不能回答这样的问题访问这些数据的接口是什么通过这些数据我能得到什么所以说字典是很不明确的而使用类的话即使你不得不重写所有成员变量及其访问函数一切就变得明确起来这时只需要查看源代码就知道这些数据是什么了公共接口与发布接口作为一个从头开发大型系统且人数众多的团队的管理者首要任务是将系统分成几个主要的子系统然后定义这些子系统的接口这些接口在某种程度上就是对外发布的接口接口并不是不能被改变相反最初要经常改变接口随着时间的推移需要改动的地方越来越少原因很简单接口随着时间的推移而成熟除此以外随着时间的推移越来越多的代码绑定在这些接口上并且开发者对接口越来越熟悉当到达某个点的时候你就会说好吧这就是接口我们往下走吧强代码所有权和弱代码所有权马丁我把代码所有权分为三类在极限编程中用到的代码所有权有时称为集体代码所有权有时也可以说无代码所有权在这种所有权中团队中任何人都不具有对代码的所有权也就是说任何成员可以在任意时间内改动系统中的任何代码这就是极限编程采取的方式和这种所有权相对立的是强代码所有权在强代码所有权中严格区分我的代码和你的代码我不能改动你的代码当我想改动我的某个方法的名字时如果这个方法被你的代码所调用那么我就必须先通知你让你先把所有调用代码改过来然后我才可以改动这个方法的名字另一种办法就是我得将这个方法过期化然后完成后面一系列的步骤实际上在这种情况下因为我绝对不能碰你的代码因而你所用过的我的任何接口都是发布的弱代码所有权则介于两者之间弱代码所有权中还是会区分代码的所有者不同的是它允许开发者改动其他人的代码开发者对自己的代码质量仍然负有责任如果我想要改变我的代码中某个方法的名称改就好了不过假如我想将某个类的功能转赋到另一个类上而这些代码的所有权属于你那么至少在这么做之前我应该让你知道这一点是和集体代码所有权不同的不论是在弱代码所有权下还是集体代码所有权下都可以进行代码的重构但是在强代码所有权下进行重构是个问题因为你想做的许多重构根本就无法进行比如你不能去改动别人的调用代码这就是强代码所有权下不适合做重构而弱代码所有权下可以做重构的原因计划型设计和进化型设计设计强调的是构造将程序划分为若干分割清晰的部分马丁我将设计区分为计划型设计和进化型设计当开发者着手实施一个软件时他首先需要做设计然后再按照这个设计进行编码实现软件这就是我所说的计划型设计计划型设计可能借助或者把整个系统分为若干子系统定义这些子系统间的接口在计划型设计中在设计和代码实现这二者之间存在明确的切换而这二者又往往由不同的人来完成架构师构思设计开发者编码实现做好的设计并不是说一点都不能改变但基本上是固定的你可能会说设计做得越好在编码的时候就会越少对设计做出改动而在进化型设计中开发者在编程实践的过程中逐渐完善设计刚开始的时候并没有设计而是先实现一些小的功能随着实现的功能越来越多设计才逐渐成型我在设计是否已死一文中想要强调的是很多人在尝试进化型设计时往往是在一种无约束无原则的环境里最终的设计必然很蹩脚这是人们之所以倾向于计划型设计的原因之一但是在我看来极限编程实践中通过持续不断的集成测试和重构进化型设计能够做到比计划型设计更有效计划型设计的弱点就是要想做出一个好的设计非常难有趣的是很多进化型设计的倡导者比如肯特贝克和沃德坎宁安都是非常出色的设计师但正是他们最后认识到自己所做的预先设计往往不够好他们容易把一些事情过于工程化在不需要灵活性的地方设计灵活性而在需要灵活性的地方又未予以考虑因此他们最终采用了进化型设计并通过运用一套规则保证了设计效果其结果是不但最终的设计更加出色并且速度也加快了拿我自己来说左右的时间里进化型设计会得到不错的结果而不客气地说一句我认为我的设计水平要比一般人高因此我认为进化型设计应该可以适用于更广泛的人群重构改变了预先设计的地位其正是进化型设计的关键重构下面相关内容摘自对话软件大师重构就是对代码本身做出修改以改善它的内部结构但又不改变它的外部表现优势重构改善了设计而一个良好的设计其商业目的何在我认为它使你能在未来更容易地对软件作出改动重构实际上是在说来吧让我们把系统结构重新调整一下好让将来的任何改动都更容易些其潜台词是如果你不会改动你的系统那么也就没有必要做重构因为不会有任何回报但如果你将要对你的系统作出改动不管是消除漏洞也好还是添加新功能也好那么一个好的或更好的系统结构会使你在做修改时有所受益重构是如何帮助你提高编程速度的呢马丁因为一个设计良好的程序修改起来会更容易程序的设计越好修改起来就越容易从而提高了效率马丁对程序进行改动是主要的动因我们不得不经常对软件作出一些改动只要这个软件还在使用重构是用来改善设计的我们需要一个好的设计以使任何改动都更容易些重构跟性能优化有些类似都是在行为不变性前提下的改进不过性能优化的步骤有异于重构整个过程也有所不同因为性能优化的驱动要素是性能分析重构使得事情一瞬间清晰起来因而你能够一眼就看出漏洞所在人们不注重设计的一个原因是由于工作的流动性程序员因为自己的糟糕设计而自食其果的情况很少发生因此他们没有足够的动因去注重设计此外即便他们注重但设计毕竟是一项费力不讨好的工作好的设计需要时间而开发中的时间压力往往很大但保持代码的良好构造以及编写测试反而能加快工作速度人们把改进设计所花的时间看作是失去的时间但却没有看到将来对代码的改动会容易得多往往只需要几分钟的时间否则可能要花上两三个小时人们往往还低估了在调试上所花的时间低估了他们用来追踪一个潜伏很久的漏洞所花的时间我在写代码的时候可以立即察觉产生的漏洞这使得我能在它潜伏下来之前就解决它没有几件事比调试更花时间和更令人沮丧的了重构是如何改进设计的呢比如提取方法通过把一个很长的令人费解的方法拆分成一些小方法来改进设计改进后的方法读起来就像是一份文档一张调用那些小方法的列表每种重构方法都会对针对某些特定的设计元素做出改进应用的时候要具体情况具体分析很多重构方法都能找到相对立的另一个重构方法比如如果一个方法除了方法本身的代码所表达的意义之外没有任何附加的含义那么你可能会内联它内联方法与提取方法就是对立的很多时候到底应用哪种方法取决于具体情况提取出一个函数内联就是直接用原本的代码不用函数封装简单系统的四个条件通过所有的测试揭示所有的意图没有重复代码使用最少的类和方法重构与重写如果你有一堆乱七八糟的代码且又没有测试那么你最好是扔掉它们从头开始否则你就得重新做所有的测试反之如果你有一堆乱七八糟的代码同时还有很多测试的话情况就不一样了假如代码中满是漏洞那么在行为不变性下不管怎么变换那些漏洞都会被保留下来这时是否重构就是一个值得争论的问题我想这个问题的答案也会随着你对重构熟悉程度的深入而改变随着对重构越来越有信心你可能会对以前想要重写的一些东西改用重构因为你有更强的重构能力了在某些时刻如果代码完全没有结构那么重写是比重构更有效的一种方法因此在决定重写代码之前也许值得花些时间在重构上来看看能做多少改进重构一书里有句话如果打算重构那么最基本的前提是有完善的测试测试对于重构来说是非常重要的支撑灵活性与复杂性比尔在重构一书中你写道在学会重构之前我总是力图找到灵活的方案因为设计变动的代价非常高因而我希望我的设计能够胜任我所能预知的变化但问题是灵活性是有代价的那么灵活性的代价是什么有什么解决之道么马丁灵活性的代价就是复杂性每次当你往代码中加入一些额外的东西以提高灵活性时通常也使你的代码变得更加复杂假如你的预期是对的未来确实需要这种灵活性那么你的超前工作得到了回报但如果你的预期是错的那么你所引入的复杂性将使软件变得更加难以改动因而该灵活性是毫无意义的而这种预期是很容易出错的比如当需求发生变化时你所以为的对灵活性的需求可能随之变化甚至有可能不复存在再比如你添加了一些额外的代码指望它们能提高灵活性但这些代码本身就有问题结果是既增加了复杂性又未能实现灵活性真是赔了夫人又折兵而解决之道就是极限编程事实上你根本就不需要考虑灵活性极限编程理论认为既然我们的预期在大多数情况下都是错的那么就把灵活性放在一边好了那种冒进式的提升设计的办法是拔苗助长平稳地改进设计才是可取之道事实上设计的改进是一个自我强化的过程如果你能够使设计尽可能简洁避免那些无谓的灵活性那么你所要面对的复杂性就会小很多也就越容易对代码做出改动代码会更容易被读懂和被改动你也能够更快地对软件做出调整不要试图一开始就定义一个可重用的框架然后在此基础上开发应用相反应该是在开发过程的过程中逐渐形成和完善框架重构实例参考在写企业应用架构模式这本书的时候曾碰到过这样一个增量式设计的例子当时我需要构建一个关联表映射的模式实例假如在内存中你有一个多对多的关系并且需要把它持久化到一个关系型数据库中这时你需要一个额外的连接表因此一共有三张表有很多种方法可以将数据从数据库中读入到内存里有一种比较简单的办法但是需要执行多个语句也有一种比较快的方法可以只用一个语句但是当需要把返回的数据提取出来并拆分到不同的对象中时就会很别扭我用增量式设计构建了这个模式实例起先我针对三张具体的表和两个具体的类编写了一段写死的代码根本就没有考虑通用化的问题我只是让这个非常特定具体的例子能够运行起来在通过测试之后我着手重构这个例子以使它的应用范围更广一些花了一点时间之后我就得到了一个通用的机制我所要做的一切就是写一个很小的映射类就能够让这个例子对任意的表和类都适用我发现从具体的实例入手然后再把它重构成一个抽象的例子是非常容易的反之如果从抽象的例子入手而把它应用到具体的案例中则要困难得多我还发现前者会给人一种更平静和从容的感觉而实际的进展又非常之快我能够始终清楚目前我在哪里又在做什么我对进度的把握也更加得心应手再也不会有那种何时才能让这段代码运转起来的无力感上面有个很重要的概念单一思考单一是指在任一时刻都只使用一种逻辑一种思考模式当我构建前面提到的那个例子时我只考虑如何使那个很具体的例子运行起来而当我进入到重构阶段时我只考虑如何抽象化那个具体的例子我不会同时去考虑两件事情一次只做一件事情我发现这样做的体验非常宁静而愉快测试马丁没有测试支撑的重构就如同不系安全带走钢丝如果你很擅长走钢丝而且钢丝又不是悬得很高的话那不妨试试但如果你从没走过钢丝而钢丝又是悬在尼亚加拉瀑布上空那你最好还是有个保靠的安全带类似的测试的最大好处就是让你能通过运行它们看看是否有什么东西被破坏了如果你不打算碰你的代码那当然平安无事但只要你加新的功能或是修补漏洞那么你就有可能破坏某些东西你的测试越完善你对能做的改动就越有信心最终你能实现比较高的可靠度以测试为基础的可靠性是极限编程中不大被人们注意的要点之一测试能提高鲁棒性质量和可靠性鲁棒性是指系统在面对不同环境输入或干扰时能够保持稳定和可靠的性能在计算机科学中鲁棒性通常用来描述算法或系统对于错误异常情况或变化的处理能力一个鲁棒性强的系统能够有效地处理各种情况而不会崩溃或产生不可预测的行为花在写测试上的时间可以因为不用修补漏洞而补回来因为花在跟踪调试上的时间大大减少了花在测试上的成本很快就能收回随之而来的还有其它好处通过添加一些测试你能很快获得回报因为你开始发现问题了如果你把测试集中在你需要做改动的代码部分那么当你犯错误的时候测试会告知你这些错误显然全面综合的测试会使你受益最大但是就算只写几个测试你也会从中受益针对包含漏洞的代码段编写单元测试是一种很好的调试技术其带来的好处不仅仅是让你对代码的理解更深刻还让你建立起测试库从而意味着将来不会有问题发生测试优先设计会使你体会到一种难以言传的从容不迫之感你的进展其实非常快但却不会让你感到很紧张因为你为自己设定的都是一些微目标在每个时间点上你知道自己是在实现某一个微目标一旦测试通过该目标就实现了这是一种很平和的过程它缩小了你的关注范围你不需要去考虑每一件事情只需要专注于某一小块功能你实现了这个功能然后重构它使得其中每个环节的设计都近于完美然后再进行下一步我以前用的是你所描述的方法我不得不常常问自己这个东西的接口是什么而现在我转向了增量式设计并且觉得这种方式要大大优于之前的方法测试与接口这是一个潜移默化的过程你的的确确是在构思接口而且是以一种渐进的方式你不会对自己说啊我需要构造这个类让我们来把这个类的所有接口都搞清楚然后再实现之吧相反你会说嗯这个类需要实现这么一小块功能来为此写个测试吧在编写测试的时候接口就随之浮现出来单元测试单元是什么意思马丁哦这很难最粗略地讲它是一个类但随着你与之打交道越多你就会意识到你是在测试功能的一小块区域而这一小块区域有可能是一个类的一部分也有可能是几个类合起来的作用我这里只是粗略地一说不过如果你想开始试试的话可以把单元测试看成是为每个类编写个测试案例性能与调优可维护性与效率比尔记得当时你曾对我说过应该以程序员能读懂的字符格式来序列化对象而不是以二进制代码格式当我提到字符格式要比二进制码格式慢时你说从效率的角度来看二进制代码格式使得软件更加难以维护那么能否请你谈谈关于序列化方式的具体案例一般地说你如何在可维护性与效率之间寻找平衡点马丁效率永远是第一位的前提是你能正确理解它很多时候问题在于人们以为做某些事情是为了效率着想但他们却从不使用性能分析器如果你出于效率的考虑而做某件事但却不使用性能分析器那么你所宣称的根本就不着调序列化所牵扯的问题要多一些使用二进制代码做序列化的问题之一就是你无法去查看结果当你需要存储序列化的对象时这个问题就更加突出的一个典型问题就是如果你改变了一个类那么就无法读取以前所序列化的对象类似的如果一个客户端和一台服务器正通过序列化的对象进行通讯假如一端的数据结构进行了更新而另一端没有那么整个通讯就彻底失效了有一个小窍门可以让你绕开这个问题不要序列化对象本身而是把数据从对象中提取出来放到一个字典里然后再序列化那个字典这么做会使你能够应对一些变化比尔但是字典是不明确的我们之前刚刚说起过这点马丁的确字典不是明确的不过如果你往类里添加一个字段并把这个多出来的值放到字典里的话不会有什么问题因此这是一个比较强壮的机制一般也比较强壮因为你可以对你所不了解的数据视而不见二进制序列化的主要问题就是它的脆弱性在我的书企业应用架构模式中更多地提到了序列化的方式例如在数据库中传输和存储数据时就需要考虑介于字符和二进制之间的序列化格式编写可性能调优的软件实际上就是编写结构合理的软件优化马丁还有一件事需要牢记性能优化与版本和具体的实现是密切相关的当你拿到的一个新版本时一定要把以前所做的优化都撤消然后重走一遍优化过程以确保那些优化手段仍然奏效通常你会发现你为上一个版本的虚拟机或优化型编译器所做的性能优化往往使当前的版本变慢也即之前的优化手段如今往往起到适得其反的作用比尔要记住以前为了提升性能都做了哪些改动可不是件容易的事情马丁你必须这么做先撤销再重新应用我知道这不容易这就要求你对优化过程中所做的每个改动都要有详细的记录要知道旧的优化所造成的一些微不足道的性能损失在新的版本下有时候可能会变得非常显著拉曼曾经讲过一个故事我到现在都还很喜欢这个故事有一次在的大会上做性能优化的讲座他提到了两个广为人知的技术对象池和线程池对象池就是重用已有的对象而不是每次都创建新的对象线程池的原理基本类似讲座结束后有两个人来到跟前这两个人都是设计高性能虚拟机的其中一个虚拟机是另一个好像是一个人告诉线程池的效果不错但对象池则使得虚拟机的运行变慢而另一个人告诉的恰恰相反对象池是一种设计模式用于管理和重复利用对象实例以提高性能和减少资源消耗在对象池中对象实例被预先创建并存储在一个池中当需要时可以从池中获取对象实例使用完毕后再放回池中而不是频繁地创建和销毁对象实例这样可以减少内存分配和垃圾回收的开销提高系统的性能和效率对象池常用于需要频繁创建和销毁对象实例的场景例如线程池数据库连接池等所以你有可能在一种虚拟机上优化了性能但拿到另一种虚拟机上却减慢了其运行速度对此你要特别小心对象池就是一个很好的例子很多人热衷于对象池但起码有一半的情况下人们并不去测量对象池的效果到底是好是坏在的早期日子里对象池非常重要因为垃圾回收功能还不是很完善但在垃圾回收技术更新换代之后对象池的效果就大大降低了因为那些生存周期很短的对象可以被低成本地回收只有那些生存周期很长的对象才适合使用对象池技术因为对它们进行垃圾回收的成本很高从这里可以看出规则也是在不断变化的这就是为什么要对性能调优很仔细的原因所在不要妄想根据源代码就能预测机器会做什么当你与虚拟机或优化型编译器打交道时性能调优是唯一的手段因为编译器和虚拟机所做的事情远远超出你的想象记住不要预测要实测敏捷宣言敏捷宣言中的四条核心价值观个体和互动重于流程和工具这条原则大意是说与其借重过程和工具来加强对软件开发的管理不如更多地关注于团队及其成员关注于每个个体以及他们之间在个人层面上的交互它包括了提升技能它还包括要竭尽全力使程序员们身心愉悦从而得以留住人才它还意味着更认真地对待个性冲突注重人与人的相处而不是试图找出某个完美的软件开发过程然后要求大家都来遵守这个过程我对这条原则的理解是应该是团队选择适合其的软件开发过程而不是让团队来适应指定的开发过程可工作的软件重于详尽的文档客户合作重于合同谈判响应变化重于遵循计划这四条原则指导着敏捷团队在软件开发过程中注重人与沟通可交付的软件产品与客户合作和适应变化马丁尽管在那次聚会上我们中的许多人都津津乐道于自己所采用的开发过程并且我们当中的几个人还是软件工具销售商但我们一致同意对于一个项目的成功来说软件开发过程和工具只是次要的因素最主要的因素还是团队是团队中的成员是他们人性化的合作与努力代码设计原则设计模式面向对象设计原则完整的个设计原则开闭原则开闭原则规定软件实体如类或模块应该开放扩展可以在不修改源代码的情况下添加新功能封闭修改实体不应该被修改以影响其现有功能换言之开闭原则规定软件实体应该被设计为允许添加新功能而不需要修改其底层结构的优点提高灵活性新功能可以被添加而不需要修改现有代码减少耦合实体被解耦合使得维护和演进变得更容易提高可扩展性实体可以被扩展以满足新要求而不影响其现有功能依赖倒置原则依赖倒置原则规定高级模块不应该依赖低级模块而应该依赖抽象抽象不应该依赖细节细节应该依赖抽象换言之规定高级模块不应该依赖低级模块而应该依赖抽象这个抽象可以是一个接口或抽象类的优点减少耦合高级模块被解耦合使得维护和演进变得更容易提高灵活性系统变得更加模块化和易于扩展提高可扩展性系统可以更容易地扩展以满足新要求接口隔离原则接口隔离原则规定客户端不应该被迫依赖它不使用的接口相反接口应该被设计以满足特定客户端的需求换言之规定接口应该被设计以满足特定客户端的需求而不是强迫客户端依赖一个大型的通用接口的优点减少耦合客户端被解耦合使得维护和演进变得更容易提高灵活性接口被设计以满足特定客户端的需求使得添加新功能变得更容易提高可扩展性系统变得更加模块化和易于扩展软件开发方式测试驱动开发测试驱动开发是一种软件开发方法它强调在编写代码之前先编写测试用例这个过程可以分为三个步骤编写测试用例首先开发者编写测试用例以确保代码满足要求运行测试用例然后开发者运行测试用例以确保代码通过测试编写代码最后开发者编写代码以使其通过测试用例的优点包括提高代码质量确保代码满足要求减少的可能性提高开发速度帮助开发者快速编写代码减少时间提高代码可维护性使得代码更易于维护和更新行为驱动开发行为驱动开发是一种软件开发方法它强调在编写代码之前先定义软件的行为这个过程可以分为三个步骤定义行为首先开发者定义软件的行为以确保软件满足要求编写测试用例然后开发者编写测试用例以确保软件行为正确编写代码最后开发者编写代码以使其满足软件行为的优点包括提高软件质量确保软件满足要求减少的可能性提高开发速度帮助开发者快速编写代码减少时间提高软件可维护性使得软件更易于维护和更新制造业相关流程标准功能开发流程客户需求调研分析理解客户的业务需求评估现有的工厂流程并确定自动化系统需要实现的功能和目标设备与客户环境的对接按照等标准开发接口和通讯协议使工厂设备能够与客户的自动化环境进行无缝集成软件需求分析和方案设计根据客户需求制定详细的功能需求文档和技术方案设计软件架构和模块代码编写和单元测试根据设计方案编写软件代码并进行单元测试以确保各个模块的功能正确性和稳定性现场测试在客户现场进行系统集成测试验证软件在实际操作环境中的性能并解决出现的问题文档编写编写相关的技术文档和用户手册详细记录系统功能操作指南维护步骤等其他任务根据公司需求完成其他相关的开发或支持工作功能开发的目标是通过软件和自动化技术来优化生产过程提高生产效率降低成本并确保产品的一致性和质量这在现代制造业尤其是半导体汽车制造电子装配等行业中显得尤为重要标准定义了半导体制造设备与工厂计算机系统之间的通信协议标准包括和其中是基于的通信协议则定义了数据内容和格式基于标准的扩展定义了通用设备模型提供了标准化的设备控制和状态报告接口标准使工厂管理系统能够更容易地控制和监控不同制造设备包括等标准专注于设备的健康管理提供了一套用于监控和报告设备状态的方法以提高设备的可用性和可靠性标准涉及太阳能电池和光伏组件制造涵盖从材料制造过程到最终产品的标准化提供了一种标准化的方法用于在不同供应商的设备和工厂管理系统之间交换过程数据以实现更好的数据分析和制造优化其他领域标准还包括材料处理设备设计环境健康和安全技术文档测试方法等各个方面这些标准的主要目标是促进半导体制造过程中的兼容性和互操作性减少因不同设备和系统之间不兼容带来的问题从而提高整体生产效率和产品质量标准通过详细的技术规范和操作指南为半导体和相关行业提供了一个共同的基础确保了全球制造和供应链的协同运作表现模式设计模式架构模式表现模式通过分离关注点来改进代码的组织方式表现模式侧重于解决代码组织往往使用了多种设计模式因此其也称作复合设计模式属于这种设计模式为了解决一类问题而总结出来的抽象方法架构模式描述软件系统里的基本的结构组织或纲要架构模式提供一些呈现定义好的子系统指定它们的责任并给出把它们组织在一起的法则和指南三层架构属于这种架构模式和表现模式是可以共存的架构模式三层架构概述三层架构以高内聚低耦合的思想把程序的各个功能模块划分为三层架构分别是表示层业务逻辑层数据访问层三层架构的分层模式是典型的上下关系并且是上层依赖于下层在三层架构的隔层模块之间通过对象模型的实体类作为数据传递的载体不同的对象模型的实体类一般对应于数据库的不同表实体类的属性与数据库表的字段名一致三层架构的优势高内聚低耦合可以降低层与层之间的依赖各层互相独立完成自己该完成的任务项目可以多人同时开发开发人员可以只关注整个结构中的其中某一层容易移植维护如转转添加修改删除等有利于标准化和各层逻辑的复用安全性高用户端只能通过业务逻辑层来调用数据访问层减少了入口点三层架构模式是一种基于业务逻辑来分的软件架构模式是一种整体的软件架构等表现模式是基于页面划分的一种复合设计模式是一种页面框架设计作用于三层架构中的层也就是说将三层架构中的层再度进行了分化数据操作层有一个额外的层单独拿出来可以称为数据操作层数据操作层包含公共数据访问代码是用于操作和交互数据库中数据的逻辑代码将数据操作层划分在业务逻辑层还是数据层是当下项目设计的两种常见模式将数据操作的逻辑代码置于业务逻辑层时数据访问成为一种业务逻辑表示层对于数据的访问与业务逻辑层对于数据的操作调用的是相同的方法将所有的数据读取操作存放在数据层时只需要在业务层再定义一个方法供表示层调用在架构设计中根据高内聚低耦合的原则上层的模块不必关心下层模块尽可能独立因此更标准的做法是将数据操作层置于数据层中数据操作层置于数据层后我们一般把这个称为数据访问层以为例除了表示层还可以采用其他表示层技术桌面应用程序动态页网络交互程序跨平台应用程序对于同一逻辑功能层的项目无论使用何种技术来进行表示层的开发其逻辑层和数据层都是相同的表现模式概述和是我们在进行应用程序开发中最常用的两种表现模式模式是界面开发的指导模式它基于表现层功能划分的思想把程序分为三大部分呈三角形结构是数据模型是用户界面是控制器的设计目的是实现功能结构的规划通过使得的数据和的呈现同步模型数据模型处理程序逻辑获取和存放数据的代码包括业务逻辑及具体的实现以及状态管理等视图显示数据提供用户交互界面程序中界面相关的部分是用户看到并与之交互的界面通常实现数据相对于用户的输入与输出功能控制器处理用户交互从读取数据用户输入向发送数据根据用户的交互操作控制用户界面数据的显示与更新的对象状态起到控制整个业务流程的作用实现层与层的协同工作他有关可见在模式中是这个模式的核心和的数据需要经由进行传递的通信核心就在于控制器以控制器为核心划分了视图和数据但并非完全分离的和之间是有联系的之间的通信是单向进行的和也是单向引用但在实际当中和其实也是有数据交互的虽然这并不违背模式的基本原则只要这种交互是在控制器的协调下进行的并且遵循了各组件之间的职责划分就仍然可以保持代码的结构清晰和可维护性为什么说和之间并不是完全分离的呢拿的举例当我们给一个视图上的控件去命名的时候我们就可以通用逻辑页面去通过它的名字调用到他但是一旦你的这个改变了它的名字就会导致也需要修改所以在模式当中和之间多多少少都会存在一些依赖和捆绑的关系用户请求被路由到控制器后者负责使用模型来执行用户操作或检索查询结果控制器选择要显示给用户的视图并为其提供所需的任何模型数据优点有利于软件工程化管理由于不同的层各司其职每一层不同的应用具有某些特性有利于通过工程化工程化管理程序代码可以使用控制器来连接不同的模型和视图去完成客户的需求与三层架构的关系是表现模式三层架构是典型的架构模式三层架构的分层模式是典型的上下关系上层依赖于下层但作为表现模式是不存在上下关系的而是相互协作关系和三层架构基本没有可比性是应用于不同领域的技术概述是一种基于前端开发的表现模式其核心是提供对和的双向数据绑定使得和的数据状态可以自动变更在中应用到是非常常见的全称为代表窗体控件等可视化资源代表的业务处理类将获取到的数据处理好与进行关联绑定通常代表数据模型用于定义和管理应用程序的数据它将支持中用到的一些字段还有一种用法就是在里完成业务逻辑的编写只需要处理视图和模型之间的关联和交互其中是模式的核心他是连接和的桥梁他有两个方向将转化为即将后端传递的数据转化成所看到的页面数据绑定将转化为即将所看到的页面转化成后端的数据事件监听这两个方向共同称之为数据的双向绑定在概念上是真正将页面与数据逻辑分离的模式和彻底分离通常会需要实现一个的观察者在实际开发中如何在和中分配业务逻辑的实现可以根据项目的具体需求和特点来决定毕竞只是一个规范我们尽量遵守即可优点低耦合视图可以独立于变化和修改一个可以绑定到不同的上当变化的时候可以不变当变化的时候也可以不变可重用性可以把一些视图逻辑放在里面让很多重用这段视图逻辑独立开发开发人员可以专注业务逻辑和数据的开发设计人员可以专注页面设计可测试界面向来比较难预测时测试可针对来写最有可能与平台紧密耦合即使对其进行编码也难以进行单元测试与的区别模型关注的是页面功能的划分将层面上的代码和数据逻辑相关的代码分开但并不是完全分离且在于强调控制器的作用在概念上是真正将页面与数据逻辑分离的模式和彻底分离核心在于提供对和的双向数据绑定使得和数据状态的改变可以自动变更和不知道彼此的存在通过来进行绑定即可以直接获取到的信息直接访问模型上的属性和方法但要注意的是和不能直接获取的信息驱动方式事件驱动事件驱动通过事件一订阅一事件处理的关系组织应用程序事件驱动下用户进行每一个操作会激发程序发生的一个事件事件发生后用于响应事件的事件处理器就会执行事件驱动对应的表示模式正是数据驱动数据驱动对应的表示模式是函数式编程大部分编程范式的区别都在于如何管理状态函数式编程的核心是状态不存在输入会转换为输出控制反转控制反转控制反转是一种设计原则其核心思想是将对象之间的依赖关系控制权从对象本身转移到外部环境通过一个对象不再直接创建依赖对象或管理依赖的生命周期而是将这种责任交给容器或框架处理这种控制权的转移让代码更加灵活易于测试且更具可维护性依赖注入是实现的一种方式依赖注入是一种具体实现的设计模式通过一个对象的依赖项或称依赖对象由外部传入而不是由对象内部自行创建是实现最常用的手段主要有以下几种方式构造函数注入通过构造函数将依赖对象传入属性注入通过属性设置依赖对象方法注入通过方法参数传递依赖对象面向切片编程面向切面编程是一种编程范式专注于将横切关注点如日志事务管理异常处理从业务逻辑中分离框架可以通过拦截方法调用的方式在特定代码执行前后自动执行一些通用逻辑常见的框架有等框架的核心机制是动态代理通过切面实现方法执行前后或异常发生时的特定操作通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术是对的一种补充在不修改原始类的情况下给程序动态添加统一功能的一种技术面向切片编程框架在减少重复代码实现一致的全局处理方面非常有帮助通过动态插入功能的方式便于管理跨业务的代码逻辑的关键概念切面关注特定任务如日志异常处理的模块连接点程序中的一个执行点如方法调用或异常抛出切入点定义在哪些连接点插入切面的规则通知在连接点实际执行的操作如方法前后的日志记录异常拦截等使用场景日志记录在方法执行前后记录日志无需在每个方法内手动添加事务管理在数据库操作前后自动开启和提交事务全局异常处理集中捕获和处理异常并记录在日志中性能监控自动测量方法的执行时间以便优化权限控制强制执行安全策略确保只有授权的用户能够执行特定操作实现有两种方式静态代理实现所谓静态代理就是我们自己来写代理对象动态代理实现所谓动态代理就是在程序运行时去生成一个代理对象实现静态代理需要使用到两种设计模式设计模式装饰器模式和设计模式代理模式的是靠设计模式代理模式实现的动态代理两种实现方式通过代码织入的方式例如第三方插件我们知道程序最终会编译成中间语言在编译程序的时候会动态的去修改在里面添加代码这就是代码织入的方式通过反射的方式实现通过反射实现的方法非常多也有很多实现了的框架例如过滤器等',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-27 20:54:09',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://th.bing.com/th/id/OIP.wtmjepfWPBvn26uz7s18dgHaHa?rs=1&amp;pid=ImgDetMain"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">ZEROKO14的个人博客</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size: 1.05rem;">C#<sup>3</sup></a><a href="/tags/C/" style="font-size: 1.05rem;">C++<sup>5</sup></a><a href="/tags/CSS/" style="font-size: 1.05rem;">CSS<sup>1</sup></a><a href="/tags/CSharp/" style="font-size: 1.05rem;">CSharp<sup>1</sup></a><a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 1.05rem;">C语言<sup>1</sup></a><a href="/tags/FPS/" style="font-size: 1.05rem;">FPS<sup>1</sup></a><a href="/tags/HTML/" style="font-size: 1.05rem;">HTML<sup>1</sup></a><a href="/tags/JavaScript/" style="font-size: 1.05rem;">JavaScript<sup>1</sup></a><a href="/tags/MFC/" style="font-size: 1.05rem;">MFC<sup>1</sup></a><a href="/tags/PE/" style="font-size: 1.05rem;">PE<sup>1</sup></a><a href="/tags/QT/" style="font-size: 1.05rem;">QT<sup>1</sup></a><a href="/tags/WPF/" style="font-size: 1.05rem;">WPF<sup>3</sup></a><a href="/tags/ai/" style="font-size: 1.05rem;">ai<sup>1</sup></a><a href="/tags/cmake/" style="font-size: 1.05rem;">cmake<sup>1</sup></a><a href="/tags/doxygen/" style="font-size: 1.05rem;">doxygen<sup>1</sup></a><a href="/tags/git/" style="font-size: 1.05rem;">git<sup>1</sup></a><a href="/tags/json/" style="font-size: 1.05rem;">json<sup>1</sup></a><a href="/tags/linux/" style="font-size: 1.05rem;">linux<sup>1</sup></a><a href="/tags/next/" style="font-size: 1.05rem;">next<sup>1</sup></a><a href="/tags/ppt/" style="font-size: 1.05rem;">ppt<sup>1</sup></a><a href="/tags/slidev/" style="font-size: 1.05rem;">slidev<sup>1</sup></a><a href="/tags/vue/" style="font-size: 1.05rem;">vue<sup>1</sup></a><a href="/tags/xml/" style="font-size: 1.05rem;">xml<sup>1</sup></a><a href="/tags/yaml/" style="font-size: 1.05rem;">yaml<sup>1</sup></a><a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 1.05rem;">代码规范<sup>1</sup></a><a href="/tags/%E5%86%85%E6%A0%B8/" style="font-size: 1.05rem;">内核<sup>2</sup></a><a href="/tags/%E5%86%85%E6%A0%B8%E7%9B%B8%E5%85%B3/" style="font-size: 1.05rem;">内核相关<sup>5</sup></a><a href="/tags/%E5%8A%A0%E8%A7%A3%E5%AF%86/" style="font-size: 1.05rem;">加解密<sup>1</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 1.05rem;">多线程<sup>1</sup></a><a href="/tags/%E5%BC%80%E5%8F%91/" style="font-size: 1.05rem;">开发<sup>4</sup></a><a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 1.05rem;">数学<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 1.05rem;">数据库<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 1.05rem;">数据结构<sup>1</sup></a><a href="/tags/%E6%9E%B6%E6%9E%84/" style="font-size: 1.05rem;">架构<sup>1</sup></a><a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 1.05rem;">正则表达式<sup>1</sup></a><a href="/tags/%E7%9B%91%E6%8E%A7/" style="font-size: 1.05rem;">监控<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 1.05rem;">算法<sup>1</sup></a><a href="/tags/%E7%AE%A1%E7%90%86/" style="font-size: 1.05rem;">管理<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 1.05rem;">网络<sup>2</sup></a><a href="/tags/%E9%80%86%E5%90%91/" style="font-size: 1.05rem;">逆向<sup>2</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/09/"><span class="card-archive-list-date">九月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">七月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">13</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/06/"><span class="card-archive-list-date">六月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/04/"><span class="card-archive-list-date">四月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">十一月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">27</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/12/"><span class="card-archive-list-date">十二月 2022</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/10/"><span class="card-archive-list-date">十月 2021</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2020/12/"><span class="card-archive-list-date">十二月 2020</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%A1%E7%90%86/" itemprop="url">管理</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E7%AE%A1%E7%90%86/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>管理</span></a></span></div></div><h1 class="post-title" itemprop="name headline">开发项目管理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-07-16T04:06:28.965Z" title="发表于 2024-07-16 12:06:28">2024-07-16</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-10-27T12:54:09.773Z" title="更新于 2024-10-27 20:54:09">2024-10-27</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="开发项目管理"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为新加坡"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>新加坡</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://che77a38.github.io/posts/%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"><header><a class="post-meta-categories" href="/categories/%E7%AE%A1%E7%90%86/" itemprop="url">管理</a><a href="/tags/%E7%AE%A1%E7%90%86/" tabindex="-1" itemprop="url">管理</a><h1 id="CrawlerTitle" itemprop="name headline">开发项目管理</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">ZEROKO14</span><time itemprop="dateCreated datePublished" datetime="2024-07-16T04:06:28.965Z" title="发表于 2024-07-16 12:06:28">2024-07-16</time><time itemprop="dateCreated datePublished" datetime="2024-10-27T12:54:09.773Z" title="更新于 2024-10-27 20:54:09">2024-10-27</time></header><p>此处记录开发思想,项目管理,组织架构,流程标准等等</p>
<span id="more"></span>

<h1 id="项目开发的一般流程"><a href="#项目开发的一般流程" class="headerlink" title="项目开发的一般流程"></a>项目开发的一般流程</h1><p>提出需求–&gt;需求分析–&gt;概要设计–&gt;详细设计–&gt;编码–&gt;测试(内部自己测试和专门人员测试)–&gt;项目验收(提供相关上线材料)–&gt;上线(投入运营)–&gt;日常维护–&gt;版本更新(发现bug并解决bug)–&gt;下线(弃用)</p>
<ul>
<li>需求提炼</li>
<li>项目的子系统划分，每个子系统的模块分解</li>
<li>项目的开发经历、经验积累<ul>
<li>开发流程</li>
<li>项目调试</li>
</ul>
</li>
<li>第三方框架&#x2F;开源库的积累</li>
<li>锻炼快读阅读代码的能力</li>
<li>锻炼对封装好的API的快速上手能力</li>
<li>锻炼处理问题的逻辑思维能力</li>
</ul>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202212241509470.png" alt="image-20221224150907746"></p>
<p>涉及的知识</p>
<ol>
<li>网络通信  select,poll,epoll结合的多线程或多进程第三方库:libevent</li>
<li>报文编解码</li>
<li>进程间通信   socket,pipe,fifo,mmap    套接字,管道,命名管道,共享内存</li>
<li>数据库操作相关    oracle 的 occi 库   </li>
<li>QT,守护进程创建,信号相关等等</li>
<li>shell编程相关</li>
<li>加密算法相关</li>
<li>多线程开发</li>
</ol>
<p>子系统划分:</p>
<ol>
<li>秘钥协商客户端子系统</li>
<li>秘钥协商服务端子系统</li>
<li>客户端信息注册报备图形化界面系统</li>
</ol>
<p>模块划分</p>
<ol>
<li>报文编解码模块</li>
<li>网络通信模块</li>
<li>共享内存操作模块</li>
<li>数据库操作模块</li>
<li>外联接口</li>
</ol>
<h1 id="web企业开发架构"><a href="#web企业开发架构" class="headerlink" title="web企业开发架构"></a>web企业开发架构</h1><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://www.youtube.com/watch?v=Dl-BdxNRUqs" alt="教程|720x360"></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1xC411n7mL">架构讲解</a></p>
<h1 id="编程思想"><a href="#编程思想" class="headerlink" title="编程思想"></a>编程思想</h1><h2 id="什么时候需要抽象"><a href="#什么时候需要抽象" class="headerlink" title="什么时候需要抽象"></a>什么时候需要抽象</h2><p>抽象可以减少重复代码,但也会带来耦合</p>
<blockquote>
<p>**代码耦合(COUPLING)**是指代码之间的依赖关系和相互影响程度。代码耦合越高，不同部分之间的依赖性越强，修改一个部分可能会影响其他部分，导致代码难以维护和扩展。为了降低代码耦合，可以采取一些措施，比如模块化设计、接口隔离、依赖注入等。这样可以使代码更加灵活、可维护和可扩展。</p>
</blockquote>
<p>抽象和耦合如影随形</p>
<p>只有下面两种情况才真正有价值</p>
<ul>
<li>有不同的处理方式,特别是不同的处理方式需要的参数也不相同</li>
<li>该统一操作需要自动执行(调度程序不应该关注具体处理程序的种类和细节)</li>
</ul>
<blockquote>
<p>总的来说:只有当抽象化带来的价值超过耦合时,才适合应用抽象化</p>
<p>一点重复代码带来的痛苦总是比过度耦合要小</p>
<p>相对于过耦合,重复代码的技术债也总是最廉价的</p>
</blockquote>
<h2 id="命名建议"><a href="#命名建议" class="headerlink" title="命名建议"></a>命名建议</h2><p>计算机科学中只有两个难题</p>
<p><strong>缓存失效和命名</strong></p>
<h3 id="糟糕的命名模式"><a href="#糟糕的命名模式" class="headerlink" title="糟糕的命名模式"></a>糟糕的命名模式</h3><ul>
<li><p>不要以Base或Abstract命名一个类</p>
<p>如果你发现自己无法给父类起个好名字,那很可能意味着应该重新命名子类</p>
</li>
<li><p>当很多代码都放在Utils中时,请考虑重构</p>
</li>
</ul>
<p>另有一条建议:除非类型已经包含单位信息,否则请在变量中添加单位</p>
<h2 id="去除3层缩进"><a href="#去除3层缩进" class="headerlink" title="去除3层缩进"></a>去除3层缩进</h2><p>Linux代码指南中提到:如果你需要超过3层的缩进,说明你的程序已经开始混乱,应该修复你的程序</p>
<p>下面罗列了一些去除3层缩进的方法</p>
<h3 id="表驱动法"><a href="#表驱动法" class="headerlink" title="表驱动法"></a>表驱动法</h3><p>凡是可以通过逻辑语句来选择的事物,都可以通过查表法来解决</p>
<p>对于简单的语句,逻辑语句更加简单直白,但随着选项越来越多,表驱动法就更有优势了</p>
<p>优势:</p>
<ul>
<li>逻辑数据分离</li>
<li>易维护</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202405102038634.png" alt="image-20240510203824077" style="zoom: 25%;" />

<p>使用c++实现的表驱动法:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">case1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Case 1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">case2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Case 2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">case3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Case 3&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, <span class="type">void</span>(*)()&gt; cases = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, case1&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>, case2&#125;,</span><br><span class="line">        &#123;<span class="number">3</span>, case3&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> input;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter a case number (1-3): &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; input;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cases.<span class="built_in">find</span>(input) != cases.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        cases[input]();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Invalid case number&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="提早返回"><a href="#提早返回" class="headerlink" title="提早返回"></a>提早返回</h3><blockquote>
<p>防御性编程:子程序应该不因传入错误数据而破坏,哪怕是由其他子程序产生的逻辑错误</p>
<p>此时通过早退出或早返回可以简化复杂的参数验证</p>
</blockquote>
<p>使用断言的话,甚至能省去参数验证的if语句</p>
<p>甚至还可以将参数验证提取出来作为一个独立的函数也是不错的选择</p>
<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>多态调用其实类似switch分支(如图)  </p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202405102045524.png" alt="image-20240510204522433" style="zoom:25%;" />

<p>多态能把分支逻辑隐藏起来,所以利用面向对象的多态加上<a href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F">工厂模式</a>,可以将分支逻辑分离并独立出来,让主逻辑更加清晰</p>
<h2 id="优秀的程序设计思想"><a href="#优秀的程序设计思想" class="headerlink" title="优秀的程序设计思想"></a>优秀的程序设计思想</h2><h3 id="分离逻辑层和表示层"><a href="#分离逻辑层和表示层" class="headerlink" title="分离逻辑层和表示层"></a>分离逻辑层和表示层</h3><p>由于表示层和业务逻辑相互独立，在程序维护阶段所需要做出的变化将变得相当容易。分离了表示层和业务逻辑的程序也很容易被测试</p>
<h3 id="代码清晰化表达"><a href="#代码清晰化表达" class="headerlink" title="代码清晰化表达"></a>代码清晰化表达</h3><p>在字典和创建新类传达数据的情况下,选择创建新类</p>
<p>因为字典很不明确。你根本就无法得知字典里关键字的真实意思。字典不能确定称买东西的人是顾客还是客户？即使是拼写错误也无法检查出来。更重要的是，即使你看完代码还是不能回答这样的问题：“访问这些数据的接口是什么？通过这些数据我能得到什么?”所以说，字典是很不明确的。而使用类的话——即使你不得不重写所有成员变量及其访问函数——一切就变得明确起来。这时只需要查看源代码就知道这些数据是什么了。</p>
<h3 id="公共接口与发布接口"><a href="#公共接口与发布接口" class="headerlink" title="公共接口与发布接口"></a>公共接口与发布接口</h3><p>作为一个从头开发大型系统且人数众多的团队的管理者，首要任务是将系统分成几个主要的子系统，然后定义这些子系统的接口。这些接口在某种程度上就是对外发布的接口。</p>
<p>接口并不是不能被改变。相反，最初要经常改变接口，随着时间的推移，需要改动的地方越来越少。原因很简单，接口随着时间的推移而成熟。除此以外，随着时间的推移，越来越多的代码绑定在这些接口上，并且开发者对接口越来越熟悉。当到达某个点的时候，你就会说，“好吧，这就是接口。我们往下走吧。”</p>
<h3 id="强代码所有权和弱代码所有权"><a href="#强代码所有权和弱代码所有权" class="headerlink" title="强代码所有权和弱代码所有权"></a>强代码所有权和弱代码所有权</h3><blockquote>
<p><strong>马丁：</strong>我把代码所有权分为三类。在极限编程中用到的代码所有权有时称为集体代码所有权，有时也可以说“无代码所有权”。在这种所有权中，团队中任何人都不具有对代码的所有权。也就是说，任何成员可以在任意时间内改动系统中的任何代码。这就是极限编程采取的方式。</p>
</blockquote>
<p>和这种所有权相对立的是强代码所有权。在强代码所有权中，严格区分我的代码和你的代码，我不能改动你的代码。当我想改动我的某个方法的名字时，如果这个方法被你的代码所调用，那么我就必须先通知你，让你先把所有调用代码改过来，然后我才可以改动这个方法的名字。另一种办法就是，我得将这个方法“过期化”（deprecation），然后完成后面一系列的步骤。实际上，在这种情况下，因为我绝对不能碰你的代码，因而你所用过的我的任何接口都是发布的。</p>
<p>弱代码所有权则介于两者之间。弱代码所有权中，还是会区分代码的所有者，不同的是它允许开发者改动其他人的代码。开发者对自己的代码质量仍然负有责任。如果我想要改变我的代码中某个方法的名称，改就好了。不过，假如我想将某个类的功能转赋到另一个类上，而这些代码的所有权属于你，那么至少 在这么做之前我应该让你知道。这一点是和集体代码所有权不同的。</p>
<p>不论是在弱代码所有权下，还是集体代码所有权下，都可以进行代码的重构。但是在强代码所有权下进行重构是个问题，因为你想做的许多重构根本就无法进行，比如，你不能去改动别人的调用代码。这就是<strong>强代码所有权下不适合做重构而弱代码所有权下可以做重构</strong>的原因。</p>
<h1 id="计划型设计和进化型设计"><a href="#计划型设计和进化型设计" class="headerlink" title="计划型设计和进化型设计"></a>计划型设计和进化型设计</h1><blockquote>
<p>设计强调的是构造——将程序划分为若干分割清晰的部分</p>
</blockquote>
<p><strong>马丁：</strong>我将设计区分为计划型设计和进化型设计。当开发者着手实施一个软件时，他首先需要做设计，然后再按照这个设计进行编码实现软件，这就是我所说的计划型设计。计划型设计可能借助UML；或者把整个系统分为若干子系统，定义这些子系统间的接口。在计划型设计中，在设计和代码实现这二者之间存在明确的切换。而这二者又往往由不同的人来完成。架构师构思设计，开发者编码实现。做好的设计并不是说一点都不能改变，但基本上是固定的。你可能会说，设计做得越好，在编码的时候，就会越少对设计做出改动。</p>
<p>而在进化型设计中，开发者在编程实践的过程中逐渐完善设计。刚开始的时候并没有设计，而是先实现一些小的功能。随着实现的功能越来越多，设计才逐渐成型。</p>
<p>我在《设计是否已死》一文中想要强调的是，很多人在尝试进化型设计时，往往是在一种无约束无原则的环境里，最终的设计必然很蹩脚。这是人们之所以倾向于计划型设计的原因之一。</p>
<p>但是，在我看来，极限编程实践中，通过持续不断的集成、测试和重构，进化型设计能够做到比计划型设计更有效。计划型设计的弱点就是，要想做出一个好的设计非常难。</p>
<p>有趣的是，很多进化型设计的倡导者，比如肯特·贝克和沃德·坎宁安，都是非常出色的设计师。但正是他们，最后认识到自己所做的预先设计往往不够好。他们容易把一些事情过于工程化，在不需要灵活性的地方设计灵活性，而在需要灵活性的地方又未予以考虑。因此，他们最终采用了进化型设计，并通过运用一套规则，保证了设计效果。其结果是，不但最终的设计更加出色，并且速度也加快了。拿我自己来说，80％左右的时间里，进化型设计会得到不错的结果。 而不客气地说一句，我认为我的设计水平要比一般人高。因此，我认为进化型设计应该可以适用于更广泛的人群。</p>
<p><a href="#%E9%87%8D%E6%9E%84">重构</a>改变了预先设计的地位,其正是进化型设计的关键</p>
<h1 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h1><p>下面相关内容摘自&lt;&lt;对话软件大师_-_Martin_Fowler&gt;&gt;</p>
<p>重构就是对代码本身做出修改，以改善它的内部结构，但又不改变它的外部表现</p>
<blockquote>
<p>优势:</p>
<p>重构改善了设计。而一个良好的设计，其商业目的何在？我认为，它使你能在<strong>未来更容易地对软件作出改动</strong>。</p>
<p>重构实际上是在说，“来吧，让我们把系统结构重新调整一下，好让将来的任何改动都更容易些。”其潜台词是，如果你不会改动你的系统，那么也就没有必要做重构，因为不会有任何回报。但如果你将要对你的系统作出改动;不管是消除漏洞也好，还是添加新功能也好;那么，一个好的或更好的系统结构，会使你在做修改时有所受益。</p>
<p>Q: 重构是如何帮助你提高编程速度的呢？</p>
<p><strong>马丁：</strong>因为一个设计良好的程序，修改起来会更容易。程序的设计越好，修改起来就越容易，从而提高了效率。</p>
</blockquote>
<p><strong>马丁：</strong>对程序进行改动是主要的动因。我们不得不经常对软件作出一些改动;只要这个软件还在使用。重构是用来改善设计的。 我们需要一个好的设计以使任何改动都更容易些。重构跟性能优化有些类似，都是在行为不变性（behavior-preserving）前提下的改进。不过，性能优化的步骤有异于重构，整个过程也有所不同，因为性能优化的驱动要素是性能分析（profiling）</p>
<p>重构使得事情一瞬间清晰起来，因而你能够一眼就看出漏洞所在。</p>
<blockquote>
<p>人们不注重设计的一个原因是由于工作的流动性。程序员因为自己的糟糕设计而自食其果的情况很少发生，因此他们没有足够的动因去注重设计。此外，即便他们注重，但设计毕竟是一项费力不讨好的工作，好的设计需要时间，而开发中的时间压力往往很大。</p>
<p>但保持代码的良好构造以及编写测试反而能加快工作速度,人们把改进设计所花的时间看作是“失去”的时间，但却没有看到将来对代码的改动会容易得多，往往只需要几分钟的时间，否则可能要花上两三个小时</p>
<p>人们往往还低估了在调试上所花的时间，低估了他们用来追踪一个“潜伏”很久的漏洞所花的时间。我在写代码的时候可以立即察觉产生的漏洞， 这使得我能在它潜伏下来之前就解决它。没有几件事比调试更花时间和更令人沮丧的了</p>
</blockquote>
<h2 id="重构是如何改进设计的呢？"><a href="#重构是如何改进设计的呢？" class="headerlink" title="重构是如何改进设计的呢？"></a>重构是如何改进设计的呢？</h2><p>比如，提取方法（Extract Method）通过把一个很长的、令人费解的方法拆分成一些小方法来改进设计。改进后的方法读起来就像是一份文档;一张调用那些小方法的列表。</p>
<p>每种重构方法都会对针对某些特定的设计元素做出改进。应用的时候要具体情况具体分析。很多重构方法都能找到相对立的另一个重构方法。比如，如果一个方法，除了方法本身的代码所表达的意义之外，没有任何附加的含义，那么你可能会内联它。内联方法（Inline Method）与提取方法就是对立的。很多时候，到底应用哪种方法取决于具体情况。</p>
<ul>
<li>提取出一个函数</li>
<li>内联就是直接用原本的代码,不用函数封装</li>
</ul>
<p>简单系统的四个条件</p>
<ol>
<li>通过所有的测试</li>
<li>揭示所有的意图</li>
<li>没有重复代码</li>
<li>使用最少的类和方法</li>
</ol>
<h2 id="重构与重写"><a href="#重构与重写" class="headerlink" title="重构与重写"></a>重构与重写</h2><p>如果你有一堆乱七八糟的代码且又没有测试，那么你最好是扔掉它们从头开始，否则你就得重新做所有的测试。反之，如果你有一堆乱七八糟的代码同时还有很多测试的话，情况就不一样了。假如代码中满是漏洞，那么在行为不变性下，不管怎么变换，那些漏洞 都会被保留下来。这时，是否重构就是一个值得争论的问题。我想，这个问题的答案也会随着你对重构熟悉程度的深入而改变。随着对重构越来越有信心，你可能会对以前想要重写的一些东西改用重构，因为你有更强的重构能力了</p>
<p>在某些时刻，如果代码完全没有结构，那么重写是比重构更有效的一种方法。</p>
<p>因此在决定重写代码之前，也许值得花些时间在重构上，来看看能做多少改进</p>
<p>&lt;&lt;重构&gt;&gt;一书里有句话: 如果打算重构，那么最基本的前提是有完善的<a href="#%E6%B5%8B%E8%AF%95">测试</a> (<strong>测试对于重构来说，是非常重要的支撑</strong>)</p>
<h2 id="灵活性与复杂性"><a href="#灵活性与复杂性" class="headerlink" title="灵活性与复杂性"></a>灵活性与复杂性</h2><p><strong>比尔：</strong>在《重构》一书中你写道：“在学会重构之前，我总是力图找到灵活的方案。因为设计变动的代价非常高，因而我希望我的设计能够胜任我所能预知的变化。但问题是，灵活性是有代价的。”那么，灵活性的代价是什么？有什么解决之道么？</p>
<p><strong>马丁：</strong>灵活性的代价就是复杂性。每次当你往代码中加入一些额外的东西以提高灵活性时，通常也使你的代码变得更加复杂。假如你的预期是对的，未来确实需要这种灵活性，那么你的超前工作得到了回报。但如果你的预期是错的，那么你所引入的复杂性将使软件变得更加难以改动，因而该灵活性是毫无意义的。</p>
<p>而这种预期是很容易出错的。比如，当需求发生变化时，你所以为的对灵活性的需求可能随之变化甚至有可能不复存在。再比如，你添加了一些额外的代码，指望它们能提高灵活性，但这些代码本身就有问题。结果是既增加了复杂性，又未能实现灵活性，真是“赔了夫人又折兵”。</p>
<p>而解决之道就是极限编程。事实上，你<strong>根本就不需要考虑灵活性</strong>。极限编程理论认为，既然我们的预期在大多数情况下都是错的，那么就把灵活性放在一边好了。那种冒进式的提升设计的办法是拔苗助长；平稳地改进设计才是可取之道。事实上，设计的改进是一个自我强化（self-reinforcing）的过程。如果你能够使设计尽可能简洁，避免那些无谓的灵活性，那么你所要面对的复杂性就会小很多，也就越容易对代码做出改动。代码会更容易被读懂和被改动，你也能够更快地对软件做出调整。</p>
<blockquote>
<p>不要试图一开始就定义一个可重用的框架然后在此基础上开发应用，相反，应该是在开发过程的过程中，逐渐形成和完善框架。</p>
</blockquote>
<h2 id="重构实例参考"><a href="#重构实例参考" class="headerlink" title="重构实例参考"></a>重构实例参考</h2><p>在写《企业应用架构模式》（Patterns of Enterprise Applications Architecture Design）这本书的时候，曾碰到过这样一个增量式设计的例子。当时，我需要构建一个关联表映射（associative table mappings）的模式实例。假如在内存中你有一个多对多的关系，并且需要把它持久化到一个关系型数据库中。这时，你需要一个额外的连接表。因此一共有三张表。有很多种方法可以将数据从数据库中读入到内存里：有一种比较简单的办法，但是需要执行多个 select 语句；也有一种比较快的方法，可以只用一个 select 语句，但是当需要把返回的数据提取出来并拆分到不同的对象中时，就会很别扭。</p>
<p>我用增量式设计构建了这个模式实例。起先，我针对三张具体的表和两个具体的类编写了一段写死的代码，根本就没有考虑通用化的问题。我只是让这个非常特定、具体的例子能够运行起来。在通过测试之后，我着手重构这个例子以使它的应用范围更广一些。花了一点时间之后，我就得到了一个通用的机制。 我所要做的一切，就是写一个很小的映射类，就能够让这个例子对任意的表和类都适用。</p>
<p>我发现，从具体的实例入手然后再把它重构成一个抽象的例子是非常容易的；反之，如果从抽象的例子入手而把它应用到具体的案例中，则要困难得多。我还发现，前者会给人一种更平静和从容的感觉，而实际的进展又非常之快。我能够始终清楚目前我在哪里，又在做什么。我对进度的把握也更加得心应手， 再也不会有那种“何时才能让这段代码运转起来”的无力感。</p>
<p>上面有个很重要的概念</p>
<p><strong>单一思考</strong></p>
<p>“单一”是指在任一时刻，都只使用一种逻辑，一种思考模式。当我构建前面提到的那个例子时，我只考虑如何使那个很具体的例子运行起来；而当我进入到重构阶段时，我只考虑如何抽象化那个具体的例子。我不会同时去考虑两件事情；一次只做一件事情。我发现这样做的体验非常宁静而愉快</p>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><blockquote>
<p><strong>马丁：</strong>没有测试支撑的重构，就如同不系安全带走钢丝。如果你很擅长走钢丝，而且钢丝又不是悬得很高的话，那不妨试试。但如果你从没走过钢丝，而钢丝又是悬在尼亚加拉瀑布上空，那你最好还是有个保靠的安全带</p>
</blockquote>
<p>类似 JUnit 的测试的最大好处就是让你能通过运行它们看看是否有什么东西被破坏了。如果你不打算碰你的代码，那当然平安无事；但只要你加新的功能或是修补漏洞，那么你就有可能破坏某些东西。你的测试越完善，你对能做的改动就越有信心。最终，你能实现比较高的可靠度</p>
<p><strong>以测试为基础的可靠性是极限编程中不大被人们注意的要点之一</strong></p>
<p>测试能提高鲁棒性、质量和可靠性</p>
<blockquote>
<p><strong>鲁棒性</strong>是指系统在面对不同环境、输入或干扰时能够保持稳定和可靠的性能。在计算机科学中，鲁棒性通常用来描述算法或系统对于错误、异常情况或变化的处理能力。一个鲁棒性强的系统能够有效地处理各种情况而不会崩溃或产生不可预测的行为。</p>
</blockquote>
<p>花在写测试上的时间，可以因为不用修补漏洞而补回来,因为花在跟踪调试上的时间大大减少了。花在测试上的成本很快就能收回。随之而来的还有其它好处</p>
<p>通过添加一些测试，你能很快获得回报，因为你开始发现问题了。如果你把测试集中在你需要做改动的代码部分，那么当你犯错误的时候，测试会告知你这些错误。显然，全面综合的测试会使你受益最大；但是，就算只写几个测试，你也会从中受益。</p>
<p><strong>针对包含漏洞的代码段编写单元测试，是一种很好的调试技术。其带来的好处，不仅仅是让你对代码的理解更深刻，还让你建立起测试库，从而意味着将来不会有问题发生。</strong></p>
<p><strong>测试优先设计</strong>会使你体会到一种难以言传的从容不迫之感。你的进展其实非常快，但却不会让你感到很紧张，因为你为自己设定的都是一些<strong>微目标</strong>（micro-goals）。在每个时间点上，你知道自己是在实现某一个微目标。一旦测试通过，该目标就实现了。这是一种很平和的过程。它缩小了你的关注范围。你不需要去考虑每一件事情，只需要专注于某一小块功能。你实现了这个功能，然后重构它，使得其中每个环节的设计都近于完美。然后再进行下一步。我以前用的是你所描述的方法，我不得不常常问自己，“这个东西的接口是什么？”而现在，我转向了<strong>增量式设计</strong> （incremental design），并且觉得这种方式要大大优于之前的方法。</p>
<h2 id="测试与接口"><a href="#测试与接口" class="headerlink" title="测试与接口"></a>测试与接口</h2><p>这是一个潜移默化的过程——你的的确确是在构思接口，而且是以一种渐进的方式。你不会对自己说，“啊，我需要构造这个类，让我们来把这个类的所有接口都搞清楚，然后再实现之吧！”相反，你会说，“嗯，这个类需要实现这么一小块功能。来为此写个测试吧！”在编写测试的时候，接口就随之浮现出来。</p>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>Q: 单元是什么意思</p>
<p><strong>马丁：</strong>哦，这很难。最粗略地讲，它是一个类。但随着你与之打交道越多，你就会意识到你是在测试功能 的一小块区域，而这一小块区域有可能是一个类的一部分，也有可能是几个类合起来的作用。我这里只是粗略地一说，不过，如果你想开始试试的话，可以把单元测试看成是为每个类编写个测试案例。</p>
<h1 id="性能与调优"><a href="#性能与调优" class="headerlink" title="性能与调优"></a>性能与调优</h1><h2 id="可维护性与效率"><a href="#可维护性与效率" class="headerlink" title="可维护性与效率"></a>可维护性与效率</h2><p>比尔:记得当时你曾对我说过，应该以程序员能读懂的字符格式来序列化对象，而不是以二进制代码格式。当我提到字符格式要比二进制码格式慢时，你说，从效率的角度来看，二进制代码格式使得软件更加难以维护。那么，能否请你谈谈关于序列化方式的具体案例？一般地说，你如何在可维护性与效率之间寻找平衡点？</p>
<p><strong>马丁：</strong>效率永远是第一位的，前提是你能正确理解它。很多时候问题在于，人们以为做某些事情是为了效率着想，但他们却从不使用<strong>性能分析器（profiler）</strong>。如果你出于效率的考虑而做某件事，但却不使用性能分析器，那么你所宣称的根本就不着调。</p>
<p>序列化所牵扯的问题要多一些。使用二进制代码做序列化的问题之一就是你无法去查看结果。当你需要存储序列化的对象时，这个问题就更加突出。Java的一个典型问题就是如果你改变了一个类，那么就无法读取以前所序列化的对象。类似的，如果一个客户端和一台服务器正通过序列化的对象进行通讯，假如一端的数据结构进行了更新而另一端没有，那么整个通讯就彻底失效了。</p>
<p>有一个小窍门可以让你绕开这个问题。不要序列化对象本身，而是把数据从对象中提取出来，放到一个字典里，然后再序列化那个字典。这么做会使你能够应对一些变化。</p>
<p><strong>比尔：</strong>但是，字典是“不明确的”。我们之前刚刚说起过这点。</p>
<p><strong>马丁：</strong>的确，字典不是“明确的”。不过，如果你往类里添加一个字段，并把这个多出来的值放到字典里的话，不会有什么问题。因此，这是一个比较强壮的机制。XML一般也比较强壮，因为你可以对你所不了解的数据视而不见。二进制序列化的主要问题就是它的脆弱性。在我的书《企业应用架构模式》中，更多地提到了序列化的方式。例如，在数据库中传输和存储数据时，就需要考虑介于字符和二进制之间的序列化格式。</p>
<p><strong>编写可性能调优的软件</strong>实际上就是编写结构合理的软件</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p><strong>马丁：</strong>还有一件事需要牢记：<strong>性能优化与版本和具体的实现是密切相关的</strong>。当你拿到Java 的一个新版本时，一定要把以前所做的优化都撤消，然后重走一遍优化过程，以确保那些优化手段仍然奏效。通常你会发现，你为上一个版本的虚拟机 （virtual machine）或优化型编译器（optimizing compiler）所做的性能优化往往使当前的版本变慢，也即，之前的优化手段如今往往起到适得其反的作用。</p>
<p><strong>比尔：</strong>要记住以前为了提升性能都做了哪些改动可不是件容易的事情。</p>
<p><strong>马丁：</strong>你必须这么做——先撤销，再重新应用。我知道这不容易。这就要求你对优化过程中所做的每个改动都要有详细的记录。要知道，旧的优化所造成的一些微不足道的性能损失，在新的版本下有时候可能会变得非常显著。</p>
<p>Craig Larman（拉曼 C [3]） 曾经讲过一个故事，我到现在都还很喜欢这个故事。Craig 有一次在JavaOne的大会上做性能优化的讲座。他提到了两个广为人知的技术：对象池（object pooling）和线程池（thread pooling），对象池就是重用已有的对象，而不是每次都创建新的对象，线程池的原理基本类似。讲座结束后，有两个人来到Craig跟前。这两个人都是设计高性能虚拟机的。其中一个虚拟机是Hotspot，另一个好像是 JRocket。一个人告诉 Craig，线程池的效果不错，但对象池则使得虚拟机的运行变慢；而另一个人告诉Craig 的恰恰相反。</p>
<blockquote>
<p>对象池是一种设计模式，用于管理和重复利用对象实例，以提高性能和减少资源消耗。在对象池中，对象实例被预先创建并存储在一个池中，当需要时可以从池中获取对象实例，使用完毕后再放回池中，而不是频繁地创建和销毁对象实例。这样可以减少内存分配和垃圾回收的开销，提高系统的性能和效率。对象池常用于需要频繁创建和销毁对象实例的场景，例如线程池、数据库连接池等。</p>
</blockquote>
<p>所以，你有可能在一种虚拟机上优化了性能，但拿到另一种虚拟机上，却减慢了其运行速度。对此，你要特别小心。对象池就是一个很好的例子。 很多人热衷于对象池，但起码有一半的情况下，人们并不去测量对象池的效果到底是好是坏。在Java的早期日子里，对象池非常重要，因为垃圾回收（garbage collection）功能还不是很完善。但在垃圾回收技术更新换代之后，对象池的效果就大大降低了，因为那些生存周期很短的对象可以被低成本地回收。只有那些生存周期很长的对象，才适合使用对象池技术，因为对它们进行垃圾回收的成本很高。</p>
<p>从这里可以看出，规则也是在不断变化的。这就是为什么要对性能调优很仔细的原因所在。不要妄想根据源代码就能预测机器会做什么。当你与虚拟机或优化型编译器打交道时，性能调优是唯一的手段，因为编译器和虚拟机所做的事情，远远超出你的想象。<strong>记住，不要预测，要实测。</strong></p>
<h1 id="敏捷宣言"><a href="#敏捷宣言" class="headerlink" title="敏捷宣言"></a>敏捷宣言</h1><p>敏捷宣言中的<strong>四条核心价值观</strong></p>
<ol>
<li><p>个体和互动重于流程和工具 </p>
<p>这条原则大意是说，与其借重过程和工具来加强对软件开发的管理，不如更多地关注于团队及其成员，关注于每个个体以及他们之间在个人层面上的交互。它包括了提升技能；它还包括要竭尽全力使程序员们身心愉悦，从而得以留住人才；它还意味着更认真地对待个性冲突，注重人与人的相处，而不是试图找出某个完美的软件开发过程，然后要求大家都来遵守这个过程。我对这条原则的理解是，应该是团队选择适合其的软件开发过程，而不是让团队来适应指定的开发过程</p>
</li>
<li><p>可工作的软件重于详尽的文档 </p>
</li>
<li><p>客户合作重于合同谈判 </p>
</li>
<li><p>响应变化重于遵循计划 这四条原则指导着敏捷团队在软件开发过程中注重人与沟通、可交付的软件产品、与客户合作和适应变化。</p>
</li>
</ol>
<blockquote>
<p>马丁:尽管在那次聚会上，我们中的许多人都津津乐道于自己所采用的开发过程，并且我们当中的几个人还是软件工具销售商，但我们一致同意，<strong>对于一个项目的成功来说，软件开发过程和工具只是次要的因素，最主要的因素还是团队，是团队中的成员，是他们人性化的合作与努力</strong>。 </p>
</blockquote>
<h1 id="代码设计原则"><a href="#代码设计原则" class="headerlink" title="代码设计原则"></a>代码设计原则</h1><p>[[设计模式#面向对象设计原则|完整的6个设计原则]]</p>
<h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p>OCP</p>
<p>开闭原则规定，软件实体（如类或模块）应该：</p>
<ul>
<li><strong>开放</strong> 扩展：可以在不修改源代码的情况下添加新功能。</li>
<li><strong>封闭</strong> 修改：实体不应该被修改以影响其现有功能。</li>
</ul>
<p>换言之，开闭原则规定，软件实体应该被设计为允许添加新功能，而不需要修改其底层结构。</p>
<p><strong>OCP 的优点：</strong></p>
<ul>
<li>提高灵活性：新功能可以被添加，而不需要修改现有代码。</li>
<li>减少耦合：实体被解耦合，使得维护和演进变得更容易。</li>
<li>提高可扩展性：实体可以被扩展以满足新要求，而不影响其现有功能。</li>
</ul>
<h2 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h2><p>DIP</p>
<p>依赖倒置原则规定：</p>
<ul>
<li>高级模块不应该依赖低级模块，而应该依赖抽象。</li>
<li>抽象不应该依赖细节，细节应该依赖抽象。</li>
</ul>
<p>换言之，DIP 规定，高级模块不应该依赖低级模块，而应该依赖抽象。这个抽象可以是一个接口或抽象类。</p>
<p><strong>DIP 的优点：</strong></p>
<ul>
<li>减少耦合：高级模块被解耦合，使得维护和演进变得更容易。</li>
<li>提高灵活性：系统变得更加模块化和易于扩展。</li>
<li>提高可扩展性：系统可以更容易地扩展，以满足新要求。</li>
</ul>
<h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p>ISP</p>
<p>接口隔离原则规定：</p>
<ul>
<li>客户端不应该被迫依赖它不使用的接口。</li>
<li>相反，接口应该被设计以满足特定客户端的需求。</li>
</ul>
<p>换言之，ISP 规定，接口应该被设计以满足特定客户端的需求，而不是强迫客户端依赖一个大型的通用接口。</p>
<p><strong>ISP 的优点：</strong></p>
<ul>
<li>减少耦合：客户端被解耦合，使得维护和演进变得更容易。</li>
<li>提高灵活性：接口被设计以满足特定客户端的需求，使得添加新功能变得更容易。</li>
<li>提高可扩展性：系统变得更加模块化和易于扩展。</li>
</ul>
<h1 id="软件开发方式"><a href="#软件开发方式" class="headerlink" title="软件开发方式"></a>软件开发方式</h1><h2 id="测试驱动开发-TDD"><a href="#测试驱动开发-TDD" class="headerlink" title="测试驱动开发 (TDD)"></a>测试驱动开发 (TDD)</h2><p>测试驱动开发是一种软件开发方法，它强调在编写代码之前先编写测试用例。这个过程可以分为三个步骤：</p>
<ol>
<li>编写测试用例：首先，开发者编写测试用例，以确保代码满足要求。</li>
<li>运行测试用例：然后，开发者运行测试用例，以确保代码通过测试。</li>
<li>编写代码：最后，开发者编写代码，以使其通过测试用例。</li>
</ol>
<p>TDD 的优点包括：</p>
<ul>
<li>提高代码质量：TDD 确保代码满足要求，减少 bug 的可能性。</li>
<li>提高开发速度：TDD 帮助开发者快速编写代码，减少 debug 时间。</li>
<li>提高代码可维护性：TDD 使得代码更易于维护和更新。</li>
</ul>
<h2 id="行为驱动开发-BDD"><a href="#行为驱动开发-BDD" class="headerlink" title="行为驱动开发 (BDD)"></a>行为驱动开发 (BDD)</h2><p>行为驱动开发是一种软件开发方法，它强调在编写代码之前先定义软件的行为。这个过程可以分为三个步骤：</p>
<ol>
<li>定义行为：首先，开发者定义软件的行为，以确保软件满足要求。</li>
<li>编写测试用例：然后，开发者编写测试用例，以确保软件行为正确。</li>
<li>编写代码：最后，开发者编写代码，以使其满足软件行为。</li>
</ol>
<p>BDD 的优点包括：</p>
<ul>
<li>提高软件质量：BDD 确保软件满足要求，减少 bug 的可能性。</li>
<li>提高开发速度：BDD 帮助开发者快速编写代码，减少 debug 时间。</li>
<li>提高软件可维护性：BDD 使得软件更易于维护和更新。</li>
</ul>
<h1 id="制造业相关流程标准"><a href="#制造业相关流程标准" class="headerlink" title="制造业相关流程标准"></a>制造业相关流程标准</h1><h2 id="FA功能开发流程"><a href="#FA功能开发流程" class="headerlink" title="FA功能开发流程"></a>FA功能开发流程</h2><p>​	1.	<strong>客户需求调研分析</strong>：理解客户的业务需求，评估现有的工厂流程，并确定自动化系统需要实现的功能和目标。</p>
<p>​	2.	<strong>设备与客户环境的对接</strong>：按照 SECS&#x2F;GEM 等 SEMI（Semiconductor Equipment and Materials International）标准，开发接口和通讯协议，使工厂设备能够与客户的自动化环境进行无缝集成。</p>
<p>​	3.	<strong>软件需求分析和方案设计</strong>：根据客户需求，制定详细的功能需求文档和技术方案，设计软件架构和模块。</p>
<p>​	4.	<strong>代码编写和单元测试</strong>：根据设计方案编写软件代码，并进行单元测试，以确保各个模块的功能正确性和稳定性。</p>
<p>​	5.	<strong>现场测试</strong>：在客户现场进行系统集成测试，验证软件在实际操作环境中的性能，并解决出现的问题。</p>
<p>​	6.	<strong>文档编写</strong>：编写相关的技术文档和用户手册，详细记录系统功能、操作指南、维护步骤等。</p>
<p>​	7.	<strong>其他任务</strong>：根据公司需求，完成其他相关的开发或支持工作。</p>
<p>FA 功能开发的目标是通过软件和自动化技术来优化生产过程，提高生产效率，降低成本，并确保产品的一致性和质量。这在现代制造业，尤其是半导体、汽车制造、电子装配等行业中显得尤为重要。</p>
<h2 id="SEMI标准"><a href="#SEMI标准" class="headerlink" title="SEMI标准"></a>SEMI标准</h2><ol>
<li><strong>SECS&#x2F;GEM</strong>：<ul>
<li>**SECS (SEMI Equipment Communications Standard)**：定义了半导体制造设备与工厂计算机系统之间的通信协议。SECS 标准包括 SECS-I 和 SECS-II，其中 SECS-I 是基于 RS-232 的通信协议，SECS-II 则定义了数据内容和格式。</li>
<li>**GEM (Generic Equipment Model)**：基于 SECS 标准的扩展，定义了通用设备模型，提供了标准化的设备控制和状态报告接口。GEM 标准使工厂管理系统能够更容易地控制和监控不同制造设备。</li>
</ul>
</li>
<li>**EHS (Equipment Health Standards)**：包括 E10、E58 等标准，专注于设备的健康管理，提供了一套用于监控和报告设备状态的方法，以提高设备的可用性和可靠性。</li>
<li><strong>PV（Photovoltaic）标准</strong>：涉及太阳能电池和光伏组件制造，涵盖从材料、制造过程到最终产品的标准化。</li>
<li><strong>Interface A</strong>：提供了一种标准化的方法，用于在不同供应商的设备和工厂管理系统之间交换过程数据，以实现更好的数据分析和制造优化。</li>
<li><strong>其他领域</strong>：SEMI标准还包括材料处理、设备设计、环境、健康和安全（EHS）、技术文档、测试方法等各个方面。</li>
</ol>
<p>这些标准的主要目标是促进半导体制造过程中的兼容性和互操作性，减少因不同设备和系统之间不兼容带来的问题，从而提高整体生产效率和产品质量。SEMI 标准通过详细的技术规范和操作指南，为半导体和相关行业提供了一个共同的基础，确保了全球制造和供应链的协同运作。</p>
<h1 id="表现模式-设计模式-架构模式"><a href="#表现模式-设计模式-架构模式" class="headerlink" title="表现模式&#x2F;设计模式&#x2F;架构模式"></a>表现模式&#x2F;设计模式&#x2F;架构模式</h1><ul>
<li><p><strong><a href="#%E8%A1%A8%E7%8E%B0%E6%A8%A1%E5%BC%8F">表现模式</a>（Presentation Pattern）</strong></p>
<p>通过分离关注点来改进代码的组织方式。表现模式侧重于解决代码组织，往往使用了多种设计模式，因此其也称作复合设计模式。</p>
<p><a href="#MVC">MVC&#x2F;MVVM</a>属于这种</p>
</li>
<li><p><strong>设计模式（Design Pattern）</strong></p>
<p>为了解决一类问题而总结出来的抽象方法。</p>
</li>
<li><p><strong><a href="#%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F">架构模式</a>（Architecture Pattern）</strong></p>
<p>描述软件系统里的基本的结构组织或纲要。架构模式提供一些呈现定义好的子系统，指定它们的责任，并给出把它们组织在一起的法则和指南。</p>
<p><a href="#%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84">三层架构</a>属于这种</p>
</li>
</ul>
<p>架构模式和表现模式是可以共存的</p>
<h1 id="架构模式"><a href="#架构模式" class="headerlink" title="架构模式"></a>架构模式</h1><h2 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>三层架构以高内聚、低耦合的思想，把程序的各个功能模块划分为<strong>三层架构</strong>,分别是</p>
<ul>
<li><strong>表示层（UI）</strong></li>
<li><strong>业务逻辑层（BLL）</strong></li>
<li><strong>数据访问层（DAL）</strong></li>
</ul>
<p>三层架构的分层模式是典型的<strong>上下关系</strong>,并且是上层依赖于下层.在三层架构的隔层模块之间,通过对象模型的实体类(Model)作为数据传递的载体,不同的对象模型的实体类一般对应于数据库的不同表,实体类的属性与数据库表的字段名一致</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202406121744784.png" alt="image-20240612174421140" style="zoom:25%;" />

<h3 id="三层架构的优势"><a href="#三层架构的优势" class="headerlink" title="三层架构的优势"></a>三层架构的优势</h3><ul>
<li><strong>高内聚、低耦合</strong>，可以降低层与层之间的依赖。</li>
<li>各层互相独立，完成自己该完成的任务，项目可以多人同时开发，开发人员可以<strong>只关注</strong>整个结构中的其中某一层。</li>
<li><strong>容易移植、维护</strong>，如B&#x2F;S转C&#x2F;S、SQL Server 转 Oracle、添加、修改、删除等。</li>
<li><strong>有利于标准化和各层逻辑的复用</strong>。</li>
<li><strong>安全性高</strong>。用户端只能通过业务逻辑层来调用数据访问层，减少了入口点。</li>
</ul>
<p>三层架构模式是一种<strong>基于业务逻辑来分的软件架构模式</strong>,是一种<strong>整体的软件架构</strong></p>
<p>MVC&#x2F;MVVM等表现模式是<strong>基于页面划分的一种复合设计模式</strong>,是一种<strong>页面框架设计</strong></p>
<p>MVC&#x2F;MVVM作用于三层架构中的UI层,也就是说将三层架构中的UI层再度进行了分化</p>
<h3 id="数据操作层"><a href="#数据操作层" class="headerlink" title="数据操作层"></a>数据操作层</h3><p>有一个额外的层单独拿出来可以称为<strong>数据操作层</strong></p>
<p>数据操作层包含公共数据访问代码，是用于操作和交互数据库中数据的逻辑代码。</p>
<p>将数据操作层划分在业务逻辑层还是数据层是当下项目设计的两种常见模式</p>
<ul>
<li><p>将数据操作的逻辑代码置于业务逻辑层时，数据访问成为一种业务逻辑。表示层对于数据的访问与业务逻辑层对于数据的操作调用的是相同的方法。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202406130955327.png" alt="iShot_2024-06-13_08.38.47" style="zoom: 25%;" />
</li>
<li><p><strong>将所有的数据读取操作存放在数据层时，只需要在业务层再定义一个方法供表示层调用</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202406130955854.png" alt="iShot_2024-06-13_08.38.31" style="zoom:25%;" /></li>
</ul>
<p>在架构设计中,根据高内聚低耦合的原则,上层的模块不必关心下层模块,尽可能独立.因此更标准的做法是将<strong>数据操作层置于数据层</strong>中(数据操作层置于数据层后,我们一般把这个称为<strong>数据访问层</strong>)</p>
<p>以C#为例,除了WPF,表示层还可以采用其他表示层技术</p>
<ul>
<li>WinForm  桌面应用程序</li>
<li>ASP.NET  动态web页</li>
<li>Silverlight  网络交互程序</li>
<li>Avalonia  跨平台应用程序</li>
</ul>
<p>对于同一逻辑功能层的项目,无论使用何种技术来进行表示层的开发,其逻辑层和数据层都是相同的</p>
<h1 id="表现模式"><a href="#表现模式" class="headerlink" title="表现模式"></a>表现模式</h1><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>MVC和MVVM是我们在进行应用程序开发中最常用的两种表现模式</p>
<p>MVC模式是GUI界面开发的指导模式。它基于表现层功能划分的思想把程序分为三大部分：<strong>Model-View-Controller</strong>呈三角形结构。Model是数据模型，View是用户界面，Controller是控制器。MVC的设计目的是实现功能结构的规划</p>
<p>通过Controller使得Model的数据和View的呈现同步</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202406130954461.png" alt="iShot_2024-06-13_09.07.49" style="zoom:33%;" />

<ul>
<li><p><strong>模型（Model）</strong>：<strong>数据模型</strong>,处理程序逻辑；获取和存放数据。</p>
<p>Model的代码包括业务逻辑及具体的实现以及状态管理等</p>
</li>
<li><p><strong>视图（View）</strong>：显示数据；提供用户交互界面。</p>
<p>程序中界面相关的部分,是用户看到并与之交互的界面,通常实现数据相对于用户的输入与输出功能</p>
</li>
<li><p><strong>控制器（Controller）</strong>：处理用户交互；从View读取数据(用户输入)；向Model发送数据。</p>
<p>根据用户的交互操作,控制用户界面数据的显示与更新,.model的对象状态,起到控制整个业务流程的作用,实现View层与Model层的协同工作他有关</p>
</li>
</ul>
<p>可见在MVC模式中,controler是这个模式的核心,view和model的数据需要经由controller进行传递.MVC的通信核心就在于控制器.以控制器为核心划分了视图和数据,但并非完全分离的,view和model之间是有联系的,mvc之间的通信是单向进行的,view和controller也是单向引用.但在实际当中,view和controller其实也是有数据交互的.虽然这并不违背 MVC 模式的基本原则。只要这种交互是在控制器的协调下进行的，并且遵循了各组件之间的职责划分，就仍然可以保持代码的结构清晰和可维护性</p>
<p>为什么说view和controller之间并不是完全分离的呢?</p>
<p>拿c#的winform举例:当我们给一个视图上的控件去命名的时候,我们就可以通用逻辑页面去通过它的名字调用到他.但是一旦你的这个view改变了它的名字,就会导致model也需要修改.所以在MVC模式当中,view和model之间多多少少都会存在一些依赖和捆绑的关系</p>
<p>用户请求被路由到控制器，后者负责使用模型来执行用户操作或检索查询结果。控制器选择要显示给用户的视图，并为其提供所需的任何模型数据。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>有利于软件工程化管理，由于不同的层各司其职，每一层不同的应用具有某些特性，有利于通过工程化、工程化管理程序代码，可以使用控制器来连接不同的模型和视图去完成客户的需求。</p>
<h3 id="MVC与三层架构的关系"><a href="#MVC与三层架构的关系" class="headerlink" title="MVC与三层架构的关系"></a>MVC与三层架构的关系</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202406130954486.png" alt="iShot_2024-06-13_09.18.27" style="zoom:25%;" />

<p>MVC是表现模式（Presentation Pattern），三层架构是典型的架构模式（Architecture Pattern），三层架构的分层模式是典型的上下关系，上层依赖于下层。但MVC作为表现模式是不存在上下关系的，而是<strong>相互协作关系</strong>。MVC和三层架构基本没有可比性，是应用于不同领域的技术。</p>
<h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p><strong>MVVM（Model-View-ViewModel）</strong>是一种基于前端开发的表现模式,其<strong>核心是提供对View和ViewModel的双向数据绑定</strong>,使得model和view的数据状态可以自动变更.在WPF中应用到MVVM是非常常见的，MVVM全称为Model、View、ViewModel</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202406130953309.png" alt="iShot_2024-06-13_09.27.01" style="zoom:25%;" />

<ul>
<li>View：代表窗体、控件等可视化资源。</li>
<li>ViewModel：代表View的业务处理类，将获取到的数据处理好与View进行关联绑定。</li>
<li>Model：通常代表数据模型,用于定义和管理应用程序的数据。它将支持ViewModel中用到的一些字段。还有一种用法就是<strong>在Model里完成业务逻辑的编写</strong>;<strong>ViewModel只需要处理视图和模型之间的关联和交互</strong>，</li>
</ul>
<p>其中ViewModel是MVVM模式的核心,他是连接View和Model的桥梁,他有两个方向:</p>
<ul>
<li>将Model转化为View,即将后端传递的数据转化成所看到的页面: <strong>数据绑定</strong></li>
<li>将View转化为Model,即将所看到的页面转化成后端的数据: <strong>事件监听</strong></li>
</ul>
<p>这两个方向共同称之为<strong>数据的双向绑定</strong>.</p>
<p>MVVM在概念上是真正将页面与数据逻辑分离的模式,View和Model彻底分离.</p>
<p>ViewModel通常会需要实现一个observer的观察者</p>
<p>在实际开发中，如何在 Model 和 ViewModel 中分配业务逻辑的实现，可以根据项目的具体需求和特点来决定。毕竞MVVM只是一个规范我们尽量遵守即可。</p>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul>
<li><p>低耦合：视图View可以独立于Model变化和修改，一个ViewModel可以绑定到不同的View上，当View变化的时候Mode可以不变，当Model变化的时候View也可以不变。</p>
</li>
<li><p>可重用性：可以把一些视图逻辑放在ViewModel里面，让很多view重用这段视图逻辑。</p>
</li>
<li><p>独立开发：开发人员可以专注业务逻辑和数据的开发，设计人员可以专注页面设计。</p>
</li>
<li><p>可测试：界面向来比较难预测时，测试可针对ViewModel来写。</p>
<p>View最有可能与平台紧密耦合,即使对其进行编码也难以进行单元测试</p>
</li>
</ul>
<h3 id="MVC与MVVM的区别"><a href="#MVC与MVVM的区别" class="headerlink" title="MVC与MVVM的区别"></a>MVC与MVVM的区别</h3><ul>
<li><p>MVC模型关注的是<strong>页面功能的划分</strong>，将UI层面上的代码和数据逻辑相关的代码分开，但并不是完全分离，且在于<strong>强调控制器的作用</strong>。</p>
</li>
<li><p>MVVM在概念上是真正将页面与数据逻辑分离的模式，View和Model彻底分离，<strong>核心在于提供对View 和 ViewModel 的双向数据绑定，使得Model和View数据状态的改变可以自动变更</strong>。</p>
<p>view和model不知道彼此的存在,通过viewModel来进行绑定,即ViewModel可以直接获取到Model的信息,直接访问模型上的属性和方法;但要注意的是,Model和ViewModel不能直接获取ViewModel的信息</p>
</li>
</ul>
<h1 id="驱动方式"><a href="#驱动方式" class="headerlink" title="驱动方式"></a>驱动方式</h1><h2 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h2><p>事件驱动通过“事件一订阅一事件处理”的关系组织应用程序。事件驱动下，用户进行每一个操作会激发程序发生的一个事件，事件发生后，用于响应事件的事件处理器就会执行。</p>
<p>事件驱动对应的表示模式正是<a href="#MVC">MVC</a></p>
<h2 id="数据驱动"><a href="#数据驱动" class="headerlink" title="数据驱动"></a>数据驱动</h2><p>数据驱动对应的表示模式是<a href="#MVVM">MVVM</a></p>
<h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><p>大部分编程范式的区别都在于如何管理状态</p>
<p>函数式编程的核心是<strong>状态不存在</strong></p>
<p>输入会转换为输出</p>
<h1 id="控制反转"><a href="#控制反转" class="headerlink" title="控制反转"></a>控制反转</h1><p>控制反转IOC</p>
<p><strong>控制反转</strong>是一种设计原则，其核心思想是将对象之间的依赖关系控制权从对象本身转移到外部环境。通过 IoC，一个对象不再直接创建依赖对象或管理依赖的生命周期，而是将这种责任交给容器或框架处理。这种控制权的转移让代码更加灵活、易于测试且更具可维护性。</p>
<p><strong>依赖注入（DI）是实现 IoC 的一种方式</strong></p>
<p>依赖注入是一种具体实现 IoC 的设计模式。通过 DI，一个对象的依赖项（或称依赖对象）由外部传入，而不是由对象内部自行创建。DI 是实现 IoC 最常用的手段，主要有以下几种方式：</p>
<ul>
<li><strong>构造函数注入</strong>：通过构造函数将依赖对象传入。</li>
<li><strong>属性注入</strong>：通过属性设置依赖对象。</li>
<li><strong>方法注入</strong>：通过方法参数传递依赖对象。</li>
</ul>
<h1 id="面向切片编程"><a href="#面向切片编程" class="headerlink" title="面向切片编程"></a>面向切片编程</h1><blockquote>
<p><strong>AOP</strong>（Aspect-Oriented Programming，面向切面编程）是一种编程范式，专注于将横切关注点（如日志、事务管理、异常处理）从业务逻辑中分离。AOP 框架可以通过拦截方法调用的方式，在特定代码执行前后自动执行一些通用逻辑，常见的 AOP 框架有 <strong>PostSharp</strong>、<strong>Castle DynamicProxy</strong> 等。<strong>AOP 框架的核心机制是动态代理，通过“切面”实现方法执行前后或异常发生时的特定操作</strong>。</p>
<p><strong>通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术</strong></p>
<p>是对OOP的一种补充，在不修改原始类的情况下，给程序动态添加统一功能的一种技术。</p>
</blockquote>
<p>面向切片编程AOP</p>
<p><strong>AOP 框架在减少重复代码、实现一致的全局处理方面非常有帮助，通过动态插入功能的方式，便于管理跨业务的代码逻辑</strong></p>
<p><strong>AOP 的关键概念</strong></p>
<ul>
<li><strong>切面（Aspect）</strong>：关注特定任务（如日志、异常处理）的模块。</li>
<li><strong>连接点（Join Point）</strong>：程序中的一个执行点（如方法调用或异常抛出）。</li>
<li><strong>切入点（Pointcut）</strong>：定义在哪些连接点插入切面的规则。</li>
<li><strong>通知（Advice）</strong>：在连接点实际执行的操作，如方法前后的日志记录、异常拦截等。</li>
</ul>
<p><strong>使用场景</strong></p>
<ul>
<li><strong>日志记录</strong>：在方法执行前后记录日志，无需在每个方法内手动添加。</li>
<li><strong>事务管理</strong>：在数据库操作前后自动开启和提交事务。</li>
<li><strong>全局异常处理</strong>：集中捕获和处理异常，并记录在日志中。</li>
<li><strong>性能监控</strong>：自动测量方法的执行时间以便优化。</li>
<li><strong>权限控制</strong>：强制执行安全策略，确保只有授权的用户能够执行特定操作。</li>
</ul>
<p>实现AOP有两种方式：</p>
<ol>
<li>静态代理实现。所谓静态代理，就是我们自己来写代理对象。</li>
<li>动态代理实现。所谓动态代理，就是在程序运行时，去生成一个代理对象。</li>
</ol>
<p>实现静态代理需要使用到两种设计模式：[[设计模式#装饰器模式]]和[[设计模式#代理模式]]。</p>
<p>Spring的aop是靠[[设计模式#代理模式]]实现的</p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>两种实现方式</p>
<ul>
<li>通过代码织入的方式。例如PostSharp第三方插件。我们知道.NET程序最终会编译成IL中间语言，在编译程序的时候，PostSharp会动态的去修改IL，在IL里面添加代码，这就是代码织入的方式。</li>
<li>通过反射的方式实现。通过反射实现的方法非常多，也有很多实现了AOP的框架，例如Unity、MVC过滤器、Autofac等。</li>
</ul>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4" title="头像" alt="头像"></a><div class="post-copyright__author_name">ZEROKO14</div><div class="post-copyright__author_desc">zeroko14's blog</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://che77a38.github.io/posts/%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://che77a38.github.io/posts/%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/')">开发项目管理</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://che77a38.github.io/posts/%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=开发项目管理&amp;url=https://che77a38.github.io/posts/%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://che77a38.github.io" target="_blank">ZEROKO14的个人博客</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E7%AE%A1%E7%90%86/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>管理<span class="tagsPageCount">1</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/mac%E5%8F%8Alinux_C++%E7%8E%AF%E5%A2%83/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">mac及linux C++环境配置</div></div></a></div><div class="next-post pull-right"><a href="/posts/%E6%95%B0%E5%AD%A6/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">数学</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description">欢迎来到ZEROKO14的个人博客</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">ZEROKO14</h1><div class="author-info__desc">zeroko14's blog</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/che77a38" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E7%9A%84%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">项目开发的一般流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-number">1.1.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#web%E4%BC%81%E4%B8%9A%E5%BC%80%E5%8F%91%E6%9E%B6%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">web企业开发架构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3"><span class="toc-number">3.</span> <span class="toc-text">编程思想</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E6%8A%BD%E8%B1%A1"><span class="toc-number">3.1.</span> <span class="toc-text">什么时候需要抽象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E5%BB%BA%E8%AE%AE"><span class="toc-number">3.2.</span> <span class="toc-text">命名建议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%9F%E7%B3%95%E7%9A%84%E5%91%BD%E5%90%8D%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.2.1.</span> <span class="toc-text">糟糕的命名模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%BB%E9%99%A43%E5%B1%82%E7%BC%A9%E8%BF%9B"><span class="toc-number">3.3.</span> <span class="toc-text">去除3层缩进</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E9%A9%B1%E5%8A%A8%E6%B3%95"><span class="toc-number">3.3.1.</span> <span class="toc-text">表驱动法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E6%97%A9%E8%BF%94%E5%9B%9E"><span class="toc-number">3.3.2.</span> <span class="toc-text">提早返回</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.3.3.</span> <span class="toc-text">面向对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E7%A7%80%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3"><span class="toc-number">3.4.</span> <span class="toc-text">优秀的程序设计思想</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%A6%BB%E9%80%BB%E8%BE%91%E5%B1%82%E5%92%8C%E8%A1%A8%E7%A4%BA%E5%B1%82"><span class="toc-number">3.4.1.</span> <span class="toc-text">分离逻辑层和表示层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%B8%85%E6%99%B0%E5%8C%96%E8%A1%A8%E8%BE%BE"><span class="toc-number">3.4.2.</span> <span class="toc-text">代码清晰化表达</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E5%85%B1%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%8F%91%E5%B8%83%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.4.3.</span> <span class="toc-text">公共接口与发布接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E4%BB%A3%E7%A0%81%E6%89%80%E6%9C%89%E6%9D%83%E5%92%8C%E5%BC%B1%E4%BB%A3%E7%A0%81%E6%89%80%E6%9C%89%E6%9D%83"><span class="toc-number">3.4.4.</span> <span class="toc-text">强代码所有权和弱代码所有权</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E5%88%92%E5%9E%8B%E8%AE%BE%E8%AE%A1%E5%92%8C%E8%BF%9B%E5%8C%96%E5%9E%8B%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.</span> <span class="toc-text">计划型设计和进化型设计</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%87%8D%E6%9E%84"><span class="toc-number">5.</span> <span class="toc-text">重构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E6%9E%84%E6%98%AF%E5%A6%82%E4%BD%95%E6%94%B9%E8%BF%9B%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-number">5.1.</span> <span class="toc-text">重构是如何改进设计的呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E6%9E%84%E4%B8%8E%E9%87%8D%E5%86%99"><span class="toc-number">5.2.</span> <span class="toc-text">重构与重写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%81%B5%E6%B4%BB%E6%80%A7%E4%B8%8E%E5%A4%8D%E6%9D%82%E6%80%A7"><span class="toc-number">5.3.</span> <span class="toc-text">灵活性与复杂性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E6%9E%84%E5%AE%9E%E4%BE%8B%E5%8F%82%E8%80%83"><span class="toc-number">5.4.</span> <span class="toc-text">重构实例参考</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-number">6.</span> <span class="toc-text">测试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%8E%A5%E5%8F%A3"><span class="toc-number">6.1.</span> <span class="toc-text">测试与接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">6.2.</span> <span class="toc-text">单元测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%B8%8E%E8%B0%83%E4%BC%98"><span class="toc-number">7.</span> <span class="toc-text">性能与调优</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7%E4%B8%8E%E6%95%88%E7%8E%87"><span class="toc-number">7.1.</span> <span class="toc-text">可维护性与效率</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8C%96"><span class="toc-number">7.2.</span> <span class="toc-text">优化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%8F%E6%8D%B7%E5%AE%A3%E8%A8%80"><span class="toc-number">8.</span> <span class="toc-text">敏捷宣言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">9.</span> <span class="toc-text">代码设计原则</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99"><span class="toc-number">9.1.</span> <span class="toc-text">开闭原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99"><span class="toc-number">9.2.</span> <span class="toc-text">依赖倒置原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99"><span class="toc-number">9.3.</span> <span class="toc-text">接口隔离原则</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%96%B9%E5%BC%8F"><span class="toc-number">10.</span> <span class="toc-text">软件开发方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91-TDD"><span class="toc-number">10.1.</span> <span class="toc-text">测试驱动开发 (TDD)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%8C%E4%B8%BA%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91-BDD"><span class="toc-number">10.2.</span> <span class="toc-text">行为驱动开发 (BDD)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%B6%E9%80%A0%E4%B8%9A%E7%9B%B8%E5%85%B3%E6%B5%81%E7%A8%8B%E6%A0%87%E5%87%86"><span class="toc-number">11.</span> <span class="toc-text">制造业相关流程标准</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#FA%E5%8A%9F%E8%83%BD%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B"><span class="toc-number">11.1.</span> <span class="toc-text">FA功能开发流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SEMI%E6%A0%87%E5%87%86"><span class="toc-number">11.2.</span> <span class="toc-text">SEMI标准</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A1%A8%E7%8E%B0%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F"><span class="toc-number">12.</span> <span class="toc-text">表现模式&#x2F;设计模式&#x2F;架构模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F"><span class="toc-number">13.</span> <span class="toc-text">架构模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84"><span class="toc-number">13.1.</span> <span class="toc-text">三层架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">13.1.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">13.1.2.</span> <span class="toc-text">三层架构的优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E5%B1%82"><span class="toc-number">13.1.3.</span> <span class="toc-text">数据操作层</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A1%A8%E7%8E%B0%E6%A8%A1%E5%BC%8F"><span class="toc-number">14.</span> <span class="toc-text">表现模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MVC"><span class="toc-number">14.1.</span> <span class="toc-text">MVC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">14.1.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">14.1.2.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVC%E4%B8%8E%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">14.1.3.</span> <span class="toc-text">MVC与三层架构的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MVVM"><span class="toc-number">14.2.</span> <span class="toc-text">MVVM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="toc-number">14.2.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-1"><span class="toc-number">14.2.2.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVC%E4%B8%8EMVVM%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">14.2.3.</span> <span class="toc-text">MVC与MVVM的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">15.</span> <span class="toc-text">驱动方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8"><span class="toc-number">15.1.</span> <span class="toc-text">事件驱动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8"><span class="toc-number">15.2.</span> <span class="toc-text">数据驱动</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-number">16.</span> <span class="toc-text">函数式编程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC"><span class="toc-number">17.</span> <span class="toc-text">控制反转</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%88%87%E7%89%87%E7%BC%96%E7%A8%8B"><span class="toc-number">18.</span> <span class="toc-text">面向切片编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">18.1.</span> <span class="toc-text">动态代理</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/avalonia/" title="avalonia">avalonia</a><time datetime="2024-09-11T14:51:13.000Z" title="发表于 2024-09-11 22:51:13">2024-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/%E8%A7%86%E9%A2%91%E6%95%88%E6%9E%9C/" title="PR">PR</a><time datetime="2024-07-18T07:06:08.330Z" title="发表于 2024-07-18 15:06:08">2024-07-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/%E5%89%8D%E7%AB%AF/" title="WEB前端">WEB前端</a><time datetime="2024-07-18T07:06:08.323Z" title="发表于 2024-07-18 15:06:08">2024-07-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/slidev/" title="slidev">slidev</a><time datetime="2024-07-18T07:06:08.319Z" title="发表于 2024-07-18 15:06:08">2024-07-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="C++多线程">C++多线程</a><time datetime="2024-07-18T07:05:59.794Z" title="发表于 2024-07-18 15:05:59">2024-07-18</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2024 By <a class="footer-bar-link" href="/" title="ZEROKO14" target="_blank">ZEROKO14</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu"></a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">57</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">48</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">6</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size: 0.88rem;">C#<sup>3</sup></a><a href="/tags/C/" style="font-size: 0.88rem;">C++<sup>5</sup></a><a href="/tags/CSS/" style="font-size: 0.88rem;">CSS<sup>1</sup></a><a href="/tags/CSharp/" style="font-size: 0.88rem;">CSharp<sup>1</sup></a><a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 0.88rem;">C语言<sup>1</sup></a><a href="/tags/FPS/" style="font-size: 0.88rem;">FPS<sup>1</sup></a><a href="/tags/HTML/" style="font-size: 0.88rem;">HTML<sup>1</sup></a><a href="/tags/JavaScript/" style="font-size: 0.88rem;">JavaScript<sup>1</sup></a><a href="/tags/MFC/" style="font-size: 0.88rem;">MFC<sup>1</sup></a><a href="/tags/PE/" style="font-size: 0.88rem;">PE<sup>1</sup></a><a href="/tags/QT/" style="font-size: 0.88rem;">QT<sup>1</sup></a><a href="/tags/WPF/" style="font-size: 0.88rem;">WPF<sup>3</sup></a><a href="/tags/ai/" style="font-size: 0.88rem;">ai<sup>1</sup></a><a href="/tags/cmake/" style="font-size: 0.88rem;">cmake<sup>1</sup></a><a href="/tags/doxygen/" style="font-size: 0.88rem;">doxygen<sup>1</sup></a><a href="/tags/git/" style="font-size: 0.88rem;">git<sup>1</sup></a><a href="/tags/json/" style="font-size: 0.88rem;">json<sup>1</sup></a><a href="/tags/linux/" style="font-size: 0.88rem;">linux<sup>1</sup></a><a href="/tags/next/" style="font-size: 0.88rem;">next<sup>1</sup></a><a href="/tags/ppt/" style="font-size: 0.88rem;">ppt<sup>1</sup></a><a href="/tags/slidev/" style="font-size: 0.88rem;">slidev<sup>1</sup></a><a href="/tags/vue/" style="font-size: 0.88rem;">vue<sup>1</sup></a><a href="/tags/xml/" style="font-size: 0.88rem;">xml<sup>1</sup></a><a href="/tags/yaml/" style="font-size: 0.88rem;">yaml<sup>1</sup></a><a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 0.88rem;">代码规范<sup>1</sup></a><a href="/tags/%E5%86%85%E6%A0%B8/" style="font-size: 0.88rem;">内核<sup>2</sup></a><a href="/tags/%E5%86%85%E6%A0%B8%E7%9B%B8%E5%85%B3/" style="font-size: 0.88rem;">内核相关<sup>5</sup></a><a href="/tags/%E5%8A%A0%E8%A7%A3%E5%AF%86/" style="font-size: 0.88rem;">加解密<sup>1</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 0.88rem;">多线程<sup>1</sup></a><a href="/tags/%E5%BC%80%E5%8F%91/" style="font-size: 0.88rem;">开发<sup>4</sup></a><a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 0.88rem;">数学<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 0.88rem;">数据库<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 0.88rem;">数据结构<sup>1</sup></a><a href="/tags/%E6%9E%B6%E6%9E%84/" style="font-size: 0.88rem;">架构<sup>1</sup></a><a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 0.88rem;">正则表达式<sup>1</sup></a><a href="/tags/%E7%9B%91%E6%8E%A7/" style="font-size: 0.88rem;">监控<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 0.88rem;">算法<sup>1</sup></a><a href="/tags/%E7%AE%A1%E7%90%86/" style="font-size: 0.88rem;">管理<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 0.88rem;">网络<sup>2</sup></a><a href="/tags/%E9%80%86%E5%90%91/" style="font-size: 0.88rem;">逆向<sup>2</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.cbd.int/mathjax@3.2.2/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.cbd.int/mermaid@10.2.4/dist/mermaid.min.js').then(runMermaid)
  }

  anzhiyu.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>