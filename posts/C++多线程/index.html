<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>C++多线程 | ZEROKO14的个人博客</title><meta name="keywords" content="C++,多线程"><meta name="author" content="ZEROKO14"><meta name="copyright" content="ZEROKO14"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#18171d"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="C++多线程"><meta name="application-name" content="C++多线程"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#18171d"><meta property="og:type" content="article"><meta property="og:title" content="C++多线程"><meta property="og:url" content="https://che77a38.github.io/posts/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B/index.html"><meta property="og:site_name" content="ZEROKO14的个人博客"><meta property="og:description" content="C++语言级线程支持详解 标准库提供了五个头文件以支持多线程：atomic（提供原子操作功能）、thread（线程模型封装）、mutex（互斥量）、condition_variable（条件变量）、future   可参考进阶文章 概述参考 cppreference并发支持参考 为什么要用多线程"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4"><meta property="article:author" content="ZEROKO14"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4"><meta name="description" content="C++语言级线程支持详解 标准库提供了五个头文件以支持多线程：atomic（提供原子操作功能）、thread（线程模型封装）、mutex（互斥量）、condition_variable（条件变量）、future   可参考进阶文章 概述参考 cppreference并发支持参考 为什么要用多线程"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://che77a38.github.io/posts/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2024/07/27/125766904/ba62475f396df9de3316a08ed9e65d86_5680958632268053399..png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":true,"limitCount":50,"languages":{"author":"作者: ZEROKO14","link":"链接: ","source":"来源: ZEROKO14的个人博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'ZEROKO14的个人博客',
  title: 'C++多线程',
  postAI: '',
  pageFillDescription: '概述, 多线程概念区分, 并发与并行, 同步与异步, 多线程编程 vs 单线程异步编程, 异步一定是多线程吗, 协程和异步编程的关系, Thread类型, 何时执行, 线程函数参数, 函数作为线程函数, 成员函数作为线程函数, 函数对象作为线程函数, lambda表达式作为线程函数, 线程参数传引用, stdref, stdcref, Thread的成员函数, joinx2Fdetach, swap, native_handle, 硬件线程并发数, this_thread, 通用互斥体管理器, lock_guard, 第二个参数adopt_lock, unique_lock, 第二个参数, unique_lock成员函数, unique_lock所有权转移, shared_lock, scoped_lock, mutex系列, lockx2Funlock, 单次调用, 条件变量, condition_variable, 成员函数, 简单测试, 仅使用互斥体, 使用条件变量, notify_all_at_thread_exit函数, promise\future模型, future, future成员函数, future的源码实现, future构造源码, get函数源码, future析构源码, promise, 成员函数, promise的源码实现, promise默认构造函数, get_future的源码实现, set_value的源码实现, promise析构源码, 内部状态源码, 关联状态对象的代码实现, __assoc_state, set_value源码, move函数源码, __on_zero_shared源码, __assoc_sub_state, async, 不使用async实现类似效果案例, 回调参数, 函数作为回调参数案例, 成员函数作为回调参数案例, 函数对象作为回调参数案例, Lambda表达式作为回调参数案例, async的右值析构问题, future和promise之间的并发安全和线程同步, future和promise之间的异常安全, packaged_task, 与CSharp异步编程模型的区别, 原子库, 原子变量, 原子类型, 哪些类型适用于原子操作, 原子类型函数, 使用示例, 特殊的atomic_flag, memory_order的枚举值, 顺序一致性的核心概念, 获取和释放语义, 性能与安全性, 无锁编程, 为什么要无锁, 如何无锁, 工作原理, 无锁编程技术, 内存保序, 无锁编程如何控制对一个很大的对象的访问, 无锁队列, 开源无锁队列, 软件事务内存和协程, 如何排查并发编程死锁问题, 使用gdb等调试工具来排查, Valgrind, Linux Perf Tools语言级线程支持详解标准库提供了五个头文件以支持多线程提供原子操作功能线程模型封装互斥量条件变量可参考进阶文章概述参考并发支持参考为什么要用多线程任务分解耗时的操作任务分解实时响应数据分解充分利用多核处理数据数据流分解读写分离解耦合设计先了解操作系统提供的线程基础以及系统编程线程相关函数提供的线程操作用法详解开发线程提供的线程操作用法详解多进程使用多进程并发是将一个应用程序划分为多个独立的进程每个进程只有一个线程这些独立的进程间可以互相通信共同完成任务由于操作系统对进程提供了大量的保护机制以避免一个进程修改了另一个进程的数据使用多进程比使用多线程更容易写出相对安全的代码但是这也造就了多进程并发的两个缺点在进程间的通信无论是使用信号套接字还是文件管道等方式其使用要么比较复杂要么就是速度较慢或者两者兼而有之运行多个进程的开销很大操作系统要分配很多的资源来对这些进程进行管理因此就有了多线程多线程并发指的是在同一个进程中执行多个线程优点有操作系统相关知识的应该知道线程是轻量级的进程每个线程可以独立的运行不同的指令序列但是线程不独立的拥有资源依赖于创建它的进程而存在也就是说同一进程中的多个线程共享相同的地址空间可以访问进程中的大部分数据指针和引用可以在线程间进行传递这样同一进程内的多个线程能够很方便的进行数据共享以及通信也就比进程更适用于并发操作缺点由于缺少操作系统提供的保护机制在多线程共享数据及通信时就需要程序员做更多的工作以保证对共享数据段的操作是以预想的操作顺序进行的并且要极力的避免死锁引入了语言级线程支持使用头文件同时上额外需要编译选项提供了语言层面上的多线程包含在头文件中它解决了跨平台的问题提供了管理线程保护共享数据线程间同步操作原子操作等类新标准中引入了个头文件来支持多线程编程多线程概念区分并发与并行并发并发是指在同一时间段内处理多个任务的能力并发并不一定意味着同时执行多个任务而是指多个任务在同一时间段内交替进行任务交替执行在一个处理器上任务可能会交替执行而不是同时进行操作系统通过时间片轮转等方式来实现这一点资源共享并发程序通常需要处理共享资源的问题如数据竞争和死锁适用场景适合于密集型任务比如网络请求文件读写等因为这些任务在等待操作时可以让出并行并行是指在同一时刻同时执行多个任务的能力并行通常依赖于多核处理器的硬件支持任务同时执行在多核处理器上多个任务可以真正地同时运行提高性能通过将任务分解成多个子任务并同时执行可以显著提高处理速度适用场景适合于密集型任务比如大规模计算数据处理等同步与异步同步与异步是两种不同的编程模型同步编程模型指一个任务完成才执行另一个任务因此在同步中没有并发或并行的概念异步编程模型指的是不同任务之间不会相互等待无论是并发还是并行都属于异步本身没有多线程概念但通过他的函数回调机制依然能够实现单线程的并发很多语言都提供了原生的异步编程方式比如中的中的等等等等多线程编程单线程异步编程对于密集的程序更应该使用单线程异步编程因为如果使用多线程编程每个线程的绝大多数时间都是在等待这些操作如网络请求文件读写等而线程自身也会占用额外的内存线程的切换也会有额外的开销更不用说线程之间的资源竞争问题总之就是的计算能力并没有被充分利用因为大部分时间都在等待外部设备的响应对于密集型任务单线程异步编程模型如使用和非常有效它允许程序在等待操作完成时不阻塞主线程而是继续执行其他操作这种方式可以显著提高应用程序的响应性和性能因为它减少了线程上下文切换的开销多线程编程则非常适合于密集也叫计算量密集的应用如视频图像处理科学计算等等这里介绍一下多路复用技术复用是一种技术允许一个或多个线程在同一时间处理多个操作而不是为每个操作创建一个新的线程复用的常见实现方式包括选择器如和在中等系统调用它们允许单个线程监视多个文件描述符以便在其中之一变为可读或可写时进行处理事件驱动模型如使用的事件循环允许在单线程中处理多个并发操作异步一定是多线程吗异步编程不必须要多线程来实现时间片轮转调度单个线程上可以使用异步或事件驱动的编程模型从理解来说单线程异步自己定好计时器到时间之前先去做别的事情多线程异步将任务交给不同的线程并由自己来进行指挥调度中的异步编程模型就是典型的单线程异步主要基于事件循环机制协程和异步编程的关系区别盘点以的异步编程模型为例使用和关键字通过编译器生成的状态机来管理异步操作的状态和上下文恢复而不是传统的协程机制协程是一种更底层的异步机制允许直接暂停和恢复执行的协程的都是基于协程的实现协程线程都可以是实现异步的一种底层的方式但单线程也可以通过算法实现异步类型何时执行线程在构造关联的线程对象时立即开始执行从提供给类的线程函数开始有几点需要注意线程函数的返回值将被忽略而且若它以抛异常终止则调用在需要获取返回值时线程函数可以通过或者修改共享变量可能需要锁机制进行线程同步当使用不带参数的默认构造函数构造对象时该对象不表示任何线程也不会有新线程产生对象不可复制复制构造函数已被删除没有两个对象会表示同一执行线程可以使用移动构造函数迁移原对象所关联的执行线程的所有权到新对象线程函数参数常用的构造函数如下其中为任意可调用对象为任意数目的作为可调用对象的参数可调用对象是的一个具名要求常见的函数成员函数仿函数函数对象都属于可调用对象线程函数可以是以下几种方式函数成员函数函数对象使用表达式函数作为线程函数比较简单仅需将函数名与函数参数分别传入即可传参给线程函数堵塞等待子线程退出分离注意传参给线程函数的过程默认是值传递除非用把他包起来使用创建的线程是没有返回值的所以如果你想从线程中返回些什么请使用引用将你想返回的值作为一个传入参数成员函数作为线程函数需要以类名成员函数名类实例的格式传入新线程在对象引用传递上运行在对象值传递上运行函数对象作为线程函数仿函数或称函数对象便是传入类的第二种情况此时该类的工作比较简单单一并非指实际工作难度例如标准库中的等又例如第一篇文章中的类成为仿函数的类一般来说需要重载函数调用运算符在对象构建新线程后会自动进行操作执行传入的可调用对象操作执行对象为仿函数时会自动调用仿函数重载的函数调用运算符例如按值传递的方式输出按引用传递的方式输出需要注意的是新线程运行的仿函数实际上是传入时指定的仿函数的副本这同时也就要求该仿函数是可拷贝的可以将返回值作为伪函数对象的一个成员变量来储存这里的例子就是表达式作为线程函数输出作为传参的替代方式我们可以使用表达式的捕获方式来处理参数传递线程参数传引用对象构造新线程时会移动或按值复制线程函数的参数若需要传递引用参数给线程函数则必须包装它例如用或例如用途用于创建一个对象该对象封装了一个非引用允许通过这个包装器修改原始变量的值语法特性通过包装的引用可以用来代替原始变量参与运算包括赋值读取和修改通过调用方法或者直接使用转换到引用的隐式转换可以访问到封装的原始变量使用包装的引用传递给函数时函数内可以通过包装器修改原始变量的值用途同样用于创建一个对象但封装的是一个引用保证封装的对象不能被修改语法特性通过包装的引用只能用来读取原始变量的值不能对其进行修改尽管封装的是引用创建的包装器对象本身不是意味着可以复制和赋值这样的包装器但无论如何都不能通过包装器改变底层变量的值同样可以通过方法或隐式转换访问底层的变量但在函数体内只能以方式访问应用场景举例函数式编程当你需要将某个变量作为参数传递给一个高阶函数如或者表达式并且希望在目标函数体内能修改原始变量时使用反之如果希望保持原始变量不可变使用容器和算法某些容器如的比较函数可能要求传入引用如果你需要基于用户定义类型的非实例进行排序或查找可以使用包装这些实例回调机制在注册事件处理器或设置回调函数时若需要访问可能修改外部作用域内的变量可以用提供可修改的引用如果仅需观察而不改变变量则使用的成员函数下的两个成员函数用于主线程与子线程之间的交互等待线程结束并阻塞当前线程直到被等待的线程执行完毕可以在整个程序析构的时候调用来等待子线程退出将线程设置为分离状态使得线程结束时资源可以自动释放不需要显式调用来等待线程结束等待一秒由引入需要使用命名空间并且需要包含和头文件精度更高可移植性更强函数通常在系统中使用需要包含头文件常用线程交换两个线程对象所代表的底层句柄返回由于的实现和操作系统相关因此该函数返回与具体实现相关的线程句柄例如在符合标准的平台下如是库硬件线程并发数是类型的静态函数表示硬件支持的最大并发量核输出的是对于核线程的返回的是是一个命名空间它有个功能函数具体如下函数使用说明获取线程放弃线程执行回到就绪状态操作系统调度另一线程继续执行线程休眠某个指定的时间片该线程才被重新唤醒不过由于线程调度等原因实际休眠时间可能比所表示的时间片更长如下线程休眠至某个指定的时刻该线程才被重新唤醒加一分钟秒数设置为暂停执行到下一整分执行函数盘点功能让出时间片功能让出时间片允许其他线程执行暂停当前线程指定的持续时间配合使用等待指定线程结束其执行或线程间互斥锁的获取与释放结合或使用线程等待特定条件满足操作等函数系列函数原子操作以实现线程安全的数据访问通用互斥体管理器下面所有通用互斥体管理器都是严格基于作用域的互斥体所有权包装器即封装器下面所有互斥体管理器均不可复制严格基于作用域的互斥体所有权包装器是中的一种机制实现用于自动管理互斥量的锁定和解锁过程确保即使在发生异常或提前返回的情况下也能正确释放互斥量避免资源泄露它通常与结合使用以简化同步代码的编写提高程序的健壮性通过理解思想第二个参数帮助解锁通常情况下在构造时会自动锁定其关联的互斥锁然而这里使用了额外的构造参数它的作用是告诉它所关联的互斥锁已经被外部机制此处为锁定不再尝试再次锁定互斥锁而是直接接管现有的锁定状态当和的生命周期结束例如所在作用域结束时它们各自的析构函数将自动调用方法释放之前被锁定的互斥锁帮前面的解锁没有其他成员函数实现可移动的互斥体所有权包装器比灵活性更高但是执行效率差一点内存占用的也稍微多一些可以完全取代相对于而言多了下面的功能延迟锁定不必构造的时候马上锁定条件解锁与重新锁定支持超时锁定提供了带超时的锁定尝试转移所有权与条件变量配合实现等待与通知第二个参数免去了加锁流程仅保留只能解锁功能同的参数尝试用的去锁定这个但没锁成功会立即返回并不会阻塞在那里前提程序员不能自己先去这个把收到的消息放入容器执行插入一个元素如果条件成立拿到了这个锁自动加锁解锁没拿到锁执行但没拿到锁只能干点别的事初始化但没有给加锁目的是为了实现延迟锁定成员函数上锁解锁尝试上锁返回表示拿到了锁返回它所管理的对象指针并释放所有权解除两者的关联关系意味着此后不能再通过该对互斥量进行任何锁定或解锁操作调用不会改变锁的状态本来上锁了释放了还是上锁状态结合时间间隔以及时间节点的尝试上锁交换返回指向关联的互斥体的指针测试是否占有其关联的互斥体所有权转移两种情况移动语义返回类型从函数返回一个局部对象是可以的返回这种局部对象会调用的移动构造函数实现可移动的共享互斥体所有权封装器功能与完全一致只是后者针对的是非共享互斥体成员函数与成员函数一致才引入简化多锁同步特别适用于同时管理多个互斥量的场景如实现复杂的多资源同步逻辑它可以一次性安全地锁定多个互斥量确保了锁的获取顺序一致性和避免死锁开发者无需手动编写繁琐的锁获取和释放代码降低了编程复杂度和出错的可能性这对于涉及多个相关数据结构或资源的并发操作至关重要有助于保证程序的线程安全性等价代码用和等价代码若需要例如对于条件变量没有其他成员函数系列基本的互斥量有超时机制的互斥量超时机制提供了带超时限制的锁定尝试方法如和可重入的互斥量可重入指一个线程在已经持有某个互斥体的情况下能够再次成功获取该互斥体而不会阻塞自己结合和特点的互斥量具有超时机制的可共享互斥量可共享支持两种锁定模式独占模式和共享模式多个线程可以同时以共享模式锁定互斥量但任何时候只有一个线程可以以独占模式锁定共享模式下提供和方法用于尝试在指定时间内获取共享锁注意释放共享锁需要使用共享的互斥量干活共享锁机制的意义允许多个读取事务同时访问同一数据具备了更高效的并发读取同时保证了数据一致性虽然多个读取线程可以同时持有共享锁但写入线程必须先获取到的独占锁即排他锁这样写入操作期间所有试图获取共享锁的读取线程都会被阻塞直到写入完成这种方式确保了读取线程始终能看到一个完整且一致的计数器值不会出现因写入操作中途而读取到部分更新的数据即避免脏读超时锁机制的意义获取锁的过程变为限时等待主动错误处理预防死锁可重入锁机制的意义递归锁定支持这对于设计复杂可能存在嵌套锁需求的代码尤为关键简化编程模型程序员无需关注锁的递归使用情况可以直接在需要同步的代码块中重复调用锁定操作无需手动管理锁的层次结构和释放顺序下面提供一个的使用案例锁定共享锁读锁锁定独占锁写锁创建多个读取线程创建一个写入线程等待所有读取线程完成等待写入线程完成一次性允许锁住多把锁但需要自己解锁函数接受两个或更多互斥锁作为参数会以以一种无死锁的方式同时锁定它们这意味着它会采用一种自旋等待策略如循环尝试算法确保无论线程调度情况如何都不会导致两个线程互相等待对方释放已锁定的互斥锁而形成死锁一旦成功锁定两个互斥锁程序继续执行下一行代码单次调用头文件避免在多线程环境下多次执行同一个函数的快捷实现代码中引入的用于确保某个函数只被调用一次的线程安全的函数和类型一个类型用于标记一段代码是否已经被执行过它必须通过引用传递给函数以确保在多线程环境下仅仅执行一次接受两个参数一个可调用对象可以是函数表达式等和一个对象的引用该函数会检查对象是否被设置过如果没有就调用可调用对象并设置对象为已设置状态中的表达式只执行一次如果需要传递参数直接接在函数名参数后面如下为参数下面使用函数来保证单例模式在多线程环境中的正确性使用了函数因此在多个线程同时调用时只有一个线程会创建单例对象即只有一个线程执行函数其他线程会直接返回之前创建的单例对象从而保证单例对象只被创建一次在类的定义中一个静态成员变量必须由该类声明为并且通常还需要在类外初始化这意味着在类的定义中仅指定其类型和名称在外初始化成员变量调用函数来获取单例对象的引用将函数作为线程函数创建多个线程并启动它们条件变量条件变量是允许多个线程相互交流的同步原语它允许一定量的线程等待可以定时另一线程的提醒然后再继续条件变量始终关联到一个互斥体引入了两种条件变量支持更多的锁但在一些平台上性能更差略头文件在中我们可以使用条件变量实现多个线程间的同步操作当条件不满足时相关线程被一直阻塞直到某种条件出现这些线程才会被唤醒条件变量是利用线程间共享的全局变量进行同步的一种机制主要包括两个动作一个线程因等待条件变量的条件成立而挂起另外一个线程使条件成立给出信号从而唤醒被等待的线程为了防止竞争条件变量的使用总是和一个互斥锁结合在一起通常情况下这个锁是使用管理锁成员函数通知通知一个等待的线程通知所有等待的线程等待释放互斥锁阻塞当前线程直到条件变量被唤醒获取互斥锁后线程应立即检查等待的条件是否确实满足这是因为唤醒并不意味着条件一定已经变为真可能存在虚假唤醒的情况标准并未规定何时发生虚假唤醒但实现中可能会出于效率等原因导致这种情况出现因此通常会将嵌套在一个循环中循环体内检查条件是否满足如果不满足则再次调用继续等待阻塞当前线程直到条件变量被唤醒或到指定时限时长后必须已经由调用线程锁定的锁可以等待的最长时长阻塞当前线程直到条件变量被唤醒或直到抵达指定时间点必须已经由调用线程锁定的锁等待截止的时间点原生句柄返回原生句柄上面的和两个函数返回的类型如下条件变量因或被唤醒条件变量因时限耗尽被唤醒函数返回一个枚举值用来指示线程是由于何种原因被唤醒的如果计数器值达到或超过了阈值即谓词返回会立即返回返回值为表示线程是由于条件满足而非超时被唤醒的如果在指定时间内计数器值仍未达到阈值则到达了最大等待时间返回表示线程是由于超时被唤醒的生产者消费者案例必须包含这个头文件否则报错如果发生变化后如果条件合适则将直接获得锁任务就是打印自己线程号使用括号减少锁的利用范围释放信号量通知消费者线程相当于休眠一秒创建个消费者线程创建个生产者线程回收线程简单测试仅使用互斥体生产者消费者执行任务等待秒平均完成任务数为如果只使用互斥量而不引入条件变量消费者线程可能会陷入忙等待状态当任务列表为空时每个消费者线程都会反复尝试锁定互斥锁检查任务列表是否已非空这种做法会导致资源的浪费尤其是在任务生成速度远低于消费者线程消费速度的情况下使用条件变量生产者每秒生产两个货品通知消费者消费消费者执行任务等待秒平均完成任务数为测试差别不是很大精确唤醒生产者在添加新任务时通过或唤醒等待的消费者线程这种精确唤醒机制使得唤醒的线程可以直接进行有效的工作消费任务而不是像忙等待那样可能连续多次检查后仍无任务可做函数在执行一组异步任务的线程中当所有任务完成后该线程可以使用向等待的任务协调者线程发送信号表示所有任务已完成无需再轮询或检查任务状态重点是可以简化线程清理逻辑通知其他线程给定的线程已完全完成包括销毁所有对象它操作如下将先前获得的锁的所有权转移到内部存储修改执行环境以令当前线程退出时如同以通知条件变量隐含的按顺序晚于与当前线程关联的所有拥有线程局域存储期的对象析构此部分代码零碎地描绘能如何用于避免在线程局域对象处于被析构过程时访问依赖于它们的数据因为将会在析构掉对象后才解锁互斥体不会看到析构到一半的变量某种任意类型用数据赋值给销毁对象解锁互斥体通知做其他工作等待脱附的线程已就绪且析构函数已完成无模型除了我们还可以使用模型头文件在并发编程中我们通常会用到一组非阻塞的模型在中都提供是现代语言常用的非阻塞编程模型与的主要区别主要关注异步任务的提交结果的获取以及跨线程通信侧重于任务的异步执行与结果同步提供了高层级的抽象和便利接口适用于需要等待异步结果的场景则专注于线程的创建管理和同步提供了底层的线程控制机制适合直接操作线程以及解决多线程间的同步和通信问题的优势如下异步任务结果的封装与传递和为异步任务的结果提供了一种标准化类型安全的封装通过它们可以方便地在不同线程之间传递和访问异步任务的最终输出而无需自行设计和实现复杂的通信机制这种方式有利于代码的组织和复用降低了异步编程的复杂度任务执行策略的灵活性函数允许指定任务的执行策略例如可以选择立即在新的线程上执行推迟至某个适当时机执行如当前线程空闲时或者放入线程池中执行这种灵活性使得程序员可以根据应用需求和系统资源状况调整任务的调度方式提高程序的整体效率异步编程的高级抽象为异步任务提供了更高级别的抽象它可以保存一个可调用对象并生成一个相应的简化了异步任务的创建和管理此外还支持任务的多次执行和重置为复杂异步逻辑提供了便利优雅的异步控制流提供了多种等待机制如阻塞等待限时等待定时等待使得主线程可以灵活地控制等待异步结果的行为避免无谓的阻塞同时通过方法可以安全地获取并清除异步任务的结果确保了结果的一次性使用和内存的有效管理更好的异常处理当异步任务执行过程中抛出异常时异常会被存储在对应的对象中通过调用可以在适当的位置捕获并处理这些异常使得异步编程中的异常处理更加可控和统一表示一个可能还没有实际完成的异步任务的结果针对这个结果可以添加回调函数以便在任务执行成功或失败后做出对应的操作回调就是自己写了却不调用给别人调用的函数交由任务执行者任务执行者通过可以标记任务完成或者失败异步调用创建的时候会返回一个对象实例给异步调用创建方异步调用执行方持有对象实例双方持有的对象实例和对象实例分别连接一个共享对象这个共享对象在异步调用创建方和异步调用执行方之间构建了一个信息同步的通道双方通过这个通道进行异步调用执行情况的信息交互如图编程模型本质上还是任务线程与主线程消息传递在模型中阻塞和非阻塞都有拉起一个新线程非阻塞在主线程阻塞整个流程见下图的编程范式先来思考一下有哪几种编写方法利用条件变量在任务线程完成时调用在主函数中调用利用原子类型在任务完成时修改在主线程中阻塞不断轮询直到成功上面第一种上锁会带来一定开销好处是适合长时间阻塞第二种适合短时间阻塞那么采用哪一种呢答案是第二种内定义了一个原子对象主线程通过自旋锁不断轮询此外会进行系统调用是非常经典的同步机制锁冲突时在用户态利用自旋锁而需要挂起等待时到内核态进行睡眠与唤醒实用案例输出使用创建的返回值是一个叫的类型别被他的名字唬到他的意思是和的值会在未来被真正的赋值我们通过调用来获得他的真正的返回值如果的返回值还没有准备好任务还没有计算完成那么调用的主线程会被卡住直到准备好了返回值和的行为一样注意我们传递给的函数实际上是表达式是有返回值的这个返回值用过一个叫做的类型来传递大多数情况下你不需要了解任何的细节在幕后可以处理好这些事情默认的情况下也会在创建之后立刻运行有办法来修改这个行为但是本文没有涉及也同样可以使用函数指针伪函数表达式类不支持拷贝构造支持移动语义提供的另一个类支持拷贝他可用于同时向多个线程发信允许多个线程等候同一共享状态提供了一个重要方法就是这将阻塞主线程直到就绪注意方法只能调用一次可以通过下面三个方式来获得的函数的函数函数成员函数返回回调函数返回的结果等待结果变得可用等待结果如果在指定的超时间隔后仍然无法得到结果则返回状态此成员函数如果超时时间间隔设置为相当于非阻塞直接取状态等待结果如果在已经到达指定的时间点时仍然无法得到结果则返回状态检查是否拥有共享状态非堵塞从转移共享状态给并返回它非堵塞状态返回有如下异步操作已经完成异步操作超时异步操作还没有开始的源码实现只截取上半段的数据成员只有一个该指针指向的是一个状态该状态对象对应的是和之间的通道为一步操作返回值的类型泛型即该状态对象内部保存并传递异步调用的返回值构造源码该构造函数接受一个关联状态对象的地址信息然后使用该地址信息来初始化内部的变量完成当前到关联状态对象的链接调用关联状态对象的成员函数完成和关联状态对象的链接函数源码创建一个名为的的临时对象并且将托管给该对象该对象是一个临时对象将会在函数运行结束的时候进行释放当该对象释放的时候将会对通过函数来对指向的关联状态对象进行相关的处理将当前的值赋值给临时变量将进行置空完成对状态对象的链接的断开通过调用来完成对关联状态中异步调用结果的获取获取完成之后将该值作为函数的返回值进行返回同时函数不仅仅是单纯的获取异步调用结果同时还会判断是否有异步调用的值如果异步调用没有完成则会阻塞在函数中等待异步调用完成的源码参考此处上面我们看到在调用方法之后断开了和关联状态对象的链接这说明对象只能调用一次方法来获取如果多次调用其内部将为空指针则会因为对空指针调用方法造成未定义行为析构源码如果当前有链接状态关联对象则调用其成员函数从而对其内部引用计数进行递减当其内部引用计数递减至的时候将完成自身占用资源的释放成员函数返回与承诺的结果关联的设置结果为指定值设置结果为指定值同时仅在线程退出时销毁所有拥有线程区域存储期的变量后分发提醒设置结果为指示异常设置结果为指示异常同时仅在线程退出时销毁所有拥有线程区域存储期的变量后分发提醒的源码实现只截取了上半部分与一致的数据成员只有一个该指针指向的是一个状态该状态对象对应的是和之间的通道为一步操作返回值的类型泛型即该状态对象内部保存并传递异步调用的返回值默认构造函数只做了通过操作符构建了一个关联状态对象用这个关联对象的地址信息初始化内部的指针变量的源码实现抛出异常如果关联了关联状态对象则通过该关联对象的地址信息来构建对象返回一个链接该关联状态对象的对象实例的源码实现两个版本只是分别针对左值和右值左值版本右值版本如果关联了关联对象实例则调用关联对象实例的成员方法将实参传入完成将异步调用结果写入关联状态对象中即所链接的通道中析构源码用来判断当前关联状态对象中是否存有异步调用结果信息即是否被设置值或者异常信息异常信息后面讨论用来判断当前关联状态对象中是否有被其他对象关联在此处为是否有其他对象关联此处内的整体条件判断是用来判断当前关联状态对象中在是否被其他对象所关联的情况下没有被设定异步调用的结果的相关信息如果条件成立执行代码行的代码这两行代码是抛出一个的异常用来表征当前是一个坏的对象没有兑现承诺调用来释放对关联状态对象的链接其背后的逻辑类似于中的引用计数当所有链接关联状态对象的对象都释放链接的时候该关联状态对象会进行自身资源的释放占用内存的归还这部分我们会在后面进行展开讨论内部状态源码关联状态对象的代码实现版本的关联对象的实现是通过层继承来实现的每层继承都对应了一个功能实现的职责按照继承树的层级从上至下这层继承分别如下引用计数类该类用来保存引用计数信息通过该类内部的引用计数信息来实现自身对象生命周期的管理用来跟踪链接到自身的和对象的数量当没有任何对象链接自身的时候进行自身资源的释放负责保存管理当前关联状态对象的状态随后展开讨论进行线程之间的同步负责保存异步操作返回值并且做最终的封装提供最终的接口给和来使用只有一个成员用于存取异步操作返回值截取上半通过返回值类型构建了一个对应的内存对齐的数据类型理解上可以认为的类型就相当于是异步操作返回值的类型源码该函数的形参是用来接受待设置到关联状态对象内部的异步调用结果的值该函数是一个万能引用从而根据传入的实参来自动的进行判断传入的实参是以左值引用的方式传入的还是以右值的方式传入的从而通过进行完美转发从而决定是以移动的方式还是拷贝的方式进行实参的接收实例化一个局部的类型临时对象通过技术来持有内部的互斥锁当该临时对象离开作用域的时候即函数结束的时候会在析构的时候对互斥锁进行释放该锁是用来保存内部数据在并发操作的时的多线程并发安全性的比如异步操作创建线程和异步操作执行线程同时分别通过和来从通道中读取和写入值的时候通过调用成员函数来判断当前关联状态对象是否已经被设定值了即设定了异步调用结果信息如果已经设定了此时执行代码抛出异常用来告诉调用方该早已经被兑现了通过操作符在上以函数形参的值构建异步调用返回值对象这里之所以采用是因为用来保存返回值的内存早就已经存在即内部的成员变量这行代码要做的只是在这个内存上进行对象的构建而不需要通过那样先申请内存然后在申请的内存上进行对象的构建设置当前关联对象的状态为表征当前关联状态对象内部已经构建了异步调用的结果的值以及设置当前关联对象的状态为用来表征当前关联状态对象已经处于就绪状态对象可以通过立刻获取到异步调用的结果信息调用内部的条件变量用来通知因为在关联状态对象没有的时候因为调用对象的方法而阻塞的线程唤醒这些线程继续获取异步调用的结果信息函数源码声明一个类型的临时对象来对内部的互斥量进行上锁从而对关联状态对象内部的数据进行并发保护通过调用成员函数该成员函数是从基类继承来的该成员函数内部对关联状态对象的值的状态进行判断如果处于就绪状态即已经可以允许来获取值的状态则会接着向下执行如果没有处于就绪状态则会在此处阻塞知道状态就绪这就是的含义判断关联状态内部是否保存异步调用执行过程中抛出的异常信息进行该异常的重新抛出完成异常从异步调用线程到异步调用创建方线程的传递此处为异常安全的设计需求后续展开讨论以移动的方式返回关联状态对象内部的异步调用结果该函数在中被引用源码该关联对象还有一个函数该函数是对其基类的同名虚函数的实现重写该函数在内部引用计数递减至的时候即没有任何或者对象链接该关联状态对象的时候调用该函数完成对自身资源的释放判断当前关联对象内部是否构建了保存异步调用对象返回值的变量如果构建了调用其析构函数注意这里是调用析构函数并没有释放内存因为该值是保存在关联状态对象内部成员变量中会随着状态对象自身的释放而释放对自身占用的资源进行释放只截取上半截用来保存异步调用时抛出的异常信息该异常信息会在异步操作创建方线程调用方法的时候重新在该线程抛出从而完成异常信息在异步调用线程和其创建线程之间传递互斥量用来实现关联状态对象内部数据的线程安全保证并发安全条件变量用来实现异步调用线程和异步调用创建方线程之间的同步用来记录关联状态对象当前的状态下面我们先展开说一下这个状态是用来被记录当前关联状态对象的状态的其是按照位来存储的初始状态下初始值为代表所有状态位都为对应是用来表示内部已经构建保存了异步调用操作的结果值对应是用来表示当前关联状态对象已经被对象所链接用来表示当前关联状态对象处于就绪状态链接该对象的对象可以通过调用方法来立刻获取到该异步调用的结果相关信息获取到异步调用的返回值或者异步调用时发生的异常用来表示这是一个推迟执行的异步调用这块后边章节会单独介绍这种推迟调用是当前不即可求值也不会在其他线程进行并发求值而是在使用进行的时候在的时候在调用的线程进行同步求值上述源码转载于此更多详解参考此处是一个模板函数接收一个回调回调函数或可调用对象作为参数并异步执行其控制的异步行为有三种可选保证行为是异步的强制这个异步任务在新线程上执行在调用函数的时候就开始创建线程行为是非异步的会在其他线程调用的时被调用传入的回调函数如果和没有调用则不会创建新线程也不执行函数程序会根据系统情况自动决定是同步还是异步开发者无法手动控制不指定的情况下默认这种回调函数可以是函数指针函数对象和表达式回调函数的参数比更安全当创建太多线程时会导致创建失败进而程序崩溃会做下面三件事自动创建一个新线程或者是从其内部的线程池中拿一个线程和一个对象向新线程中的函数传入对象并返回与之关联的对象在函数运行结束后设置对象的值我们即可通过获取返回值的函数会返回回调函数中的值缺点局限性挺大对服务器开发来说用得到的机会并不多结果单一不使用实现类似效果案例创建一个对象实例从对象实例中获取对应的对象实例建立通道构建测试对象创建一个任务该任务为对容器内的所有元素进行求和求和完成之后通过来返回结果休眠毫秒兑现承诺将结果写入通道中将这个任务交给一个线程进行异步执行将这个任务交给一个线程进行异步操作通过的方法来获取异步调用执行结果等待退出销毁完成上述创建了一个对象并且从该对象实例中获取到了用于获取承诺兑现的值的对象实例这样就构建了一个异步调用创建方发起方和异步调用执行方之间用于传递异步调用结果的数据通道在异步调用任务中完成计算之后通过来进行承诺兑现将异步调用的结果写入通道中异步调用创建方通过中的方法来获取异步调用的结果由此可见可以理解为是和的高级封装回调参数与定义支持的回调参数是一模一样的函数作为回调参数成员函数作为回调参数函数对象作为回调参数表达式作为回调参数函数作为回调参数案例模拟耗时的数据库查询操作让该函数运行五秒模拟耗时的本地数据读取操作让该函数运行五秒获取开始时间从本地文件获取数据从数据库获取数据代码会在此处阻塞直到对象中的数据就绪获取结束时间总耗时秒混合数据打印混合数据输出为总耗时秒两个秒操作使用并发后只需秒解决成员函数作为回调参数案例前面是否带或者包裹决定了是否会以引用传递的对象在此案例中决定了是否可以真正被改变输出函数对象作为回调参数案例函数对象模拟耗时操作需要运行五秒做一些获取数据相关的操作使用函数对象调用表达式作为回调参数案例使用表达式作为回调函数调用做一些数据库查询相关的操作的右值析构问题当函数的返回值不被任何变量接收时返回值将会被临时对象接收这个临时对象在当前语句结束时会被销毁如果该返回值是一个异步任务比如或在其析构时可能会导致阻塞这是因为异步任务通常会在析构时等待其关联的任务完成以确保资源的正确释放因此如果不及时处理异步任务的返回值可能会导致程序出现阻塞现象为避免这种情况建议在函数调用后立即将返回值赋给一个变量以确保异步任务能够正常执行并完成这一步没有阻塞因为的返回的对象用于构造了没有析构这一步阻塞了因为返回对象是右值将要析构而析构会阻塞输出和之间的并发安全和线程同步其的内部是通过互斥量对内部状态进行保护从而实现了线程安全通过条件变量来实现的线程同步并且一个关联状态对象在一个时刻只能被一个和一个所链接如果被多个链接则会抛出异常并且异步操作创建方只能调用一次来获取异步调用的结果信息这是因为函数内部会断开对象与关联状态对象之间的链接值得一提的是对象析构时如果没有调用接口通常不会阻塞当前进程仅当满足以下所有条件时才会阻塞这个共享状态是通过调用创建的共享状态目前没有处于就绪状态因此在等待他就绪才能释放当前对象是最后一个引用该共享状态对象的对象上面说的实际上就是这里的情况的右值析构问题和之间的异常安全在中每个线程都有自己的调用栈这意味着当一个线程抛出一个异常时这个异常只能在该线程的调用栈中传播它不能跨线程传播或被其他线程捕获这也意味着如果一个线程抛出了一个异常但没有捕获它那么只有这个线程会被终止其他线程会继续执行引入了和这两个类提供了一种在多线程中传递数据和异常的机制当我们使用或在一个线程中执行一个任务并返回一个时如果这个任务抛出了一个异常这个异常会被捕获并存储在中然后当我们在另一个线程中调用时这个异常会被重新抛出这提供了一种在多线程中传递异常的机制而不是直接终止线程和进行异步调用结果信息同步的这个机制从代码上的设计就是异常安全的这里面的异常安全设计主要在两个方向首先相关的接口和函数实现需要是异常安全的即软件内部如果出现异常的时候函数异常返回的时候不能出现内存泄漏资源未正确释放等异常情况其次异步调用的时候如果产生异常可以通过和以及关联状态对象将异常从异步操作执行线程传递到异步操作创建方所在线程中原因参考此当一个函数抛出异常的时候该异常会沿着调用链逐级向上返回当异常返回到调用链的最高层级这个逐级向上返回的过程中没有对异常进行捕捉处理此时会导致程序终止这里面异常是沿着调用链逐级向上传递的这也就说明异常只能在产生异常的线程内部进行逐级向上传递因为函数调用链的各个层级必然属于一个线程而这里构建一个和传递异常的通道的原因是由于异步调用是在另外一个线程执行异步操作但是在另外一个线程进行异步调用结果信息获取如果异步调用执行过程中出现异常那么此时这个异常信息也是异步调用执行结果的一种表现形式那么此时如果不捕获这异常通过构建的通道传递给异步调用结果信息使用线程这个异常将会在异步调用线程被传递在异步调用结果使用线程中无法捕捉这一异常信息因为不会传递到该线程那么该线程就无法了解异步调用操作异常返回这一信息为了实现这两点针对第一点为了保证在函数异常返回的时候不能出现资源泄露通常为了实现这点有一个有效的途径就是在函数内使用计数来管理资源针对第二点实现的流程在创建一个对象实例从对象实例中获取对应的对象实例创建一个会产生异常的异步任务将这个任务交给一个线程进行异步执行输出在上述代码中我们在中抛出了一个异常然后将这个异常传递给了对象当我们试图从对象中获取值时这个异常被重新抛出然后我们在函数中捕获了这个异常这就是如何在两个线程之间传递异常在中起到的作用是包装一个可调用目标如函数表达式表达式或函数对象使其成为一个可以异步执行的任务并且能够通过来获取其执行结果或捕获抛出的异常具体来说的主要作用包括提供了下面的功能结果同步与访问任务重用与重置线程退出时设置结果统一接口与封装封装可调用对象模板接受一个可调用对象作为模板参数如表示包装一个接收一个参数并返回一个值的可调用对象通过构造函数或赋值操作符将实际的可调用对象传入实例如结果同步与访问与关联的执行结果可以通过调用其成员函数获得一个对象这个对象提供了接口来查询任务是否已完成阻塞等待结果准备就绪非阻塞尝试获取结果获取结果阻塞直到结果可用以及捕获可能抛出的异常例如阻塞直到任务执行完毕并获取结果任务重用与重置如果需要重新使用同一个实例包装不同的可调用对象或再次执行相同的任务可以调用成员函数这将清除之前任务的状态允许重新设置新的可调用对象并再次执行注意会丢弃之前任务的执行结果或未处理的异常线程退出时设置结果在某些情况下可能希望在当前线程即将退出时才令的结果就绪这时可以使用成员函数它会在当前线程结束时且所有线程局部对象被销毁后使与关联的对象准备就绪类似于可以绑定一个可调用对象并执行但是它的返回类型是获取它的返回值必须用如何给它传入固定参数而不必在调用时指定使用函数获取返回值它和的不同之处在于把一个可调用对象链接到了未来用于多线程执行与异步编程模型的区别与入门异步编程模型中的的区别的修饰符没有直接对应的关键词使用函数启动异步操作但它更接近于的或者直接启动一个的方式的关键字对应于中的方法都是用来等待异步操作的完成并获取结果但是非阻塞的而会阻塞调用线程中的异步结果获取可以通过结合和轮询实现参考如下代码模拟耗时操作可以在这里做一些其他的事情而不是阻塞等待获取结果原子库类型位于头文件中是一种特殊的模板类型旨在提供对单个变量的无锁原子访问在多线程环境中当多个线程需要访问同一个变量时如果该变量被声明为类型那么对该变量的所有操作都将自动成为原子操作独特的优势盘点细粒度同步允许对基本数据类型和用户定义类型进行原子更新无锁编程使用原子库可以编写出更高效无阻塞的并发代码减少上下文切换和锁争抢带来的性能损失内存模型支持支持定义内存顺序约束如等低级别构建块原子库提供的是并发编程的基础构建块可以用来构建更复杂的同步原语和数据结构硬件级别的原子性原子库通常利用底层硬件提供的原子指令来实现其功能这些指令在硬件层面确保了操作的不可分割性对于某些关键的需要绝对一致性的操作如引用计数状态标志更新等使用原子库提供的操作比单纯依靠操作系统或语言级别的同步机制更能确保操作的正确完成避免死锁局限性主要适用于简单的数据共享场景如单一变量的读写对于更复杂的同步需求比如需要保持多个变量之间的一致性无锁编程无法有效应对需要回到更传统的同步机制如互斥锁或条件变量在原子性操作库中每个原子变量都有以下几个特点原子变量的读写操作是原子的即不会被其他线程中断原子变量的值可以被多个线程同时访问和修改原子变量的修改操作是按照一定顺序进行的保证了多个线程对同一个变量进行操作时的正确性原子性操作库中提供了一系列的原子操作函数包括等函数用于读取原子变量的值函数用于设置原子变量的值函数用于交换原子变量的值而函数用于比较并交换原子变量的值原子变量原子性操作库提供了多种类型的原子变量包括等基本数据类型以及等扩展类型每个原子变量都有对应的原子类型比如等在使用时我们需要根据实际的需求选择合适的原子类型和原子变量原子类型下面是原子性操作库中支持的一些原子类型原子类型描述原子布尔型只能存储或原子字符型相当于类型原子无符号字符型相当于类型原子有符号字符型相当于类型原子短整型相当于类型原子无符号短整型相当于类型原子整型相当于类型原子无符号整型相当于类型原子长整型相当于类型原子无符号长整型相当于类型原子长长整型相当于类型原子无符号长长整型相当于类型原子宽字符型相当于类型原子位字符型相当于类型原子位字符型相当于类型原子最大宽度整数类型对应中的类型原子最大宽度无符号整数类型对应中的类型原子指针宽度整数类型对应中的类型原子指针宽度无符号整数类型对应中的类型原子类型用于表示对象的大小原子类型用于表示两个指针之间的距离当我们去看这些类型的定义时会发现起始它们都是用模板来定义的例如就是用来定义的的原子标准不保证其在每个平台上的实现都是无锁的因此最好要清楚你的平台和工具链的能力你可以调用来确认一下相当于但是本身就拥有原子性意味着多个线程访问时有且仅有一个线程能对进行操作不是线程安全的如果定义为类型输出的结果将是输出哪些类型适用于原子操作并非所有数据类型都适用于原子操作要成为原子类型数据类型必须满足以下条件可拷贝性类型必须是可拷贝的意味着它可以通过简单的内存复制来复制或移动没有复杂的内部状态固定大小类型的大小必须是固定的且足够小以便硬件能够保证其操作的原子性对齐要求正确的内存对齐是必要的以确保原子操作的正确性和效率整数类型和指针类型通常适用于原子操作而大型结构体或类实例可能不适合原子类型函数注意原子类型和原子操作函数需要包含头文件才能使用中将原子操作定义为模板类的成员函数包括了大多数类型的操作比如读写交换等对于内置类型主要通过重载全局操作符来实现下面列出所有类型及其支持的相关操作列表下面是常用的原子类型函数函数描述原子读取操作用于获取原子变量的当前值原子写入操作用于设置原子变量的值原子交换操作用于交换原子变量的值并返回原始值条件性原子地替换原子对象的值条件性原子地替换原子对象的值原子加法操作用于增加原子变量的值并返回原始值原子减法操作用于减少原子变量的值并返回原始值原子按位与操作用于按位与原子变量的值并返回原始值原子按位或操作用于按位或原子变量的值并返回原始值原子按位异或操作用于按位异或原子变量的值并返回原始值原子最小值操作将原子变量与给定值比较并将较小的值存储在原子变量中返回原始值原子最大值操作将原子变量与给定值比较并将较大的值存储在原子变量中返回原始值原子乘法操作将原子变量与给定值相乘并将结果存储在原子变量中返回原始值原子除法操作将原子变量与给定值相除并将结果存储在原子变量中返回原始值原子按位与非操作对原子变量进行按位与非运算并将结果存储在原子变量中返回原始值原子取反操作对原子变量进行取反运算并将结果存储在原子变量中返回原始值原子按位与操作将原子变量与给定值进行按位与运算并将结果存储在原子变量中返回原始值原子按位或操作将原子变量与给定值进行按位或运算并将结果存储在原子变量中返回原始值原子按位异或操作将原子变量与给定值进行按位异或运算并将结果存储在原子变量中返回原始值判断是否是无锁的注意以上函数只是原子类型库中的一部分函数还有其他函数可用于更复杂的操作具体取决于你的需求使用示例创建一个原子整型变量并初始化为相当于原子操作递增的值相当于原子操作读取的值相当于原子操作将的值设置为等价于原子操作比较并交换的值通过使用原子类型和原子操作我们可以确保多线程环境下对共享变量的安全访问和修改特殊的与其他类型不同他是无锁的只支持以及两个成员函数函数检查标志如果之前没有被设置过则设置的标志并返回先前该对象是否被设置过如果之前对象已被设置则返回否则返回函数清除标志使得下一次调用返回可以用这两个函数来实现一个自旋锁在主线程中设置为需要等待线程设置状态代码中线程调用一直返回因为在主线程中被设置过所以一直在等待而等待一段时间后当线程运行并调用了返回了退出循环等待并进行相应操作这样一来就实现了一个线程等待另一个线程的效果的枚举值在多线程程序中不同线程对内存的读写操作可能导致意想不到的结果这主要是因为现代计算机系统和编译器通常会对操作进行重排序以优化性能和资源利用率重排序的影响处理器重排序为了提高执行效率处理器可能会改变指令的执行顺序只要这种重排序不影响单线程内的程序语义编译器优化编译器同样可能为了优化而改变代码的执行顺序这种重排序在单线程程序中通常是安全的但在多线程环境下它可能导致数据竞争和不一致的内存状态内存顺序是一种规则它定义了操作的可见性和执行顺序是确保多线程程序正确性的关键在中这些规则通过原子操作的内存顺序标志来实现在中一共有种枚举值默认按照执行如下表示松散内存顺序该枚举值代表编译器可以任由编译器重新排序或者由处理器乱序处理不是所有枚举值都能被成员函数使用函数可以使用函数可以使用需要同时读写的操作例如等操作可以使用全部种原子类型提供的一些操作符都是的封装所以他们都是顺序一致性的顺序一致性的核心概念顺序一致性是并发编程中最直观最易理解的内存模型它遵循两个基本原则操作顺序在单个线程内部所有操作包括原子操作和非原子操作的执行顺序与程序代码中的顺序相符全局顺序程序中所有原子操作都存在一个全局的顺序所有线程都能观察到这一相同的顺序这意味着使用的原子操作仿佛在一个单线程环境中执行一样其执行顺序清晰且易于预测和只有在多多线程情况下无锁编程才会用到在下由于是的所以很多时候只需要考虑编译器优化保险起见可以用他会同时处理编译器优化和的虽然用不到但是在除非必要的情况下不用使用默认用的是最强限制尽管提供了最强的一致性保证但这种保证有时候是以牺牲性能为代价的在高性能并发程序中过度依赖顺序一致性可能会成为性能瓶颈因此选择正确的内存顺序需要在易用性和性能之间做出平衡获取和释放语义并发编程的艺术在于精确控制多个线程间的操作和交互在这个艺术中和扮演着重要的角色获取和释放代表了两种内存顺序语义它们用于控制原子操作在多线程环境中的执行顺序用于读取操作保证在该操作之后的内存读写不会被重排序到该操作之前它确保对共享数据的读取操作可以看到之前的写入操作的结果用于写入操作保证在该操作之前的内存读写不会被重排序到该操作之后它确保写入操作对后续的读取操作可见这两种语义通常需要配对使用以保证线程间的操作顺序和数据一致性读取操作使用写入操作使用这确保了状态变更对所有线程的可见性同时防止了潜在的内存重排序问题实际的并发编程中和常用于实现无锁数据结构和算法如无锁队列和计数器这些内存顺序标志的使用减少了对昂贵的锁操作的依赖提高了程序的性能性能测试虽然无锁编程可能提高性能但这并不是绝对的在某些情况下尤其是在低竞争环境中互斥锁可能仍然是更好的选择性能测试是必要的性能与安全性无锁编程的一个主要目标是提高性能但这不应该以牺牲安全性和正确性为代价在实际应用中需要仔细评估无锁编程带来的性能提升是否值得在安全性和易用性上做出妥协性能测试在采用无锁编程之前进行全面的性能测试是必要的以确保它确实带来了预期的性能提升错误处理原子操作不提供内建的错误处理机制因此开发者需要仔细设计代码以处理潜在的错误情况复杂性和可维护性无锁编程通常比使用互斥锁更复杂可能导致代码难以理解和维护无锁编程无锁编程即不使用锁的情况下实现多线程之间的变量同步也就是在没有线程被阻塞的情况下实现变量的同步所以也叫非阻塞同步实现非阻塞同步的方案称为无锁编程算法无锁编程主要依靠原子操作来实现原子操作是一种不可分割的操作保证在执行过程中不会被其他线程中断在中这通常通过类型和相关函数实现它们可以对基本数据类型进行无锁操作为什么要非阻塞同步使用实现线程同步有非常多缺点产生竞争时线程被阻塞等待无法做到线程实时响应死锁活锁优先级反转使用不当造成性能下降优势性能提升由于减少了线程阻塞和上下文切换无锁编程可以显著提高程序的性能特别是在高并发环境中避免死锁和饥饿传统的锁机制可能导致死锁或线程饥饿的问题无锁编程可以有效地避免这些问题实时系统中的应用在要求高响应性的实时系统中比如智能驾驶的域控制系统无锁编程由于其较低的延迟特性被广泛应用从心理学的角度来看互斥锁类似于人们在面对资源竞争时的等待策略而无锁编程则更像是持续尝试直到成功的坚持策略非同步阻塞的实现分为三个级别无等待编程最理想的模式整个操作保证每个线程在有限步骤下完毕保证系统级吞吐以及无线程饥饿无锁编程同意个别线程饥饿但保证系统级吞吐确保至少有一个线程可以继续运行的算法必然也是的在不论什么时间点一个线程被隔离为一个事务进行运行其它线程而且在有限步骤内完毕在运行过程中一旦发现数据被改动採用时间戳版本则回滚也叫做乐观锁即乐观并发控制事务的过程是读取并写时间戳准备写入版本号校验检验通过则写入检验不通过则回滚无锁算法感触最深的是复杂度的分解比如多线程对于一个双向链表的插入或删除操作如何能一步一步分解成一个一个串联的原子操作并能保证事务内存的一致性为什么要无锁首先是性能考虑通信项目一般对性能有极致的追求这是我们使用无锁的重要原因当然无锁算法如果实现的不好性能可能还不如使用锁所以我们选择比较擅长的数据结构和算法进行实现比如对于比较复杂的数据结构和算法我们通过来控制比如避免锁的使用引起的错误和问题死锁两个以上线程互相等待锁护送多个同优先级的线程反复竞争同一个锁抢占锁失败后强制上下文切换引起性能下降优先级反转低优先级线程拥有锁时被中优先级的线程抢占而高优先级的线程因为申请不到锁被阻塞锁护送锁列队和活锁的区别锁列队在计算机科学中锁列队是在使用锁进行并发控制的多线程应用程序中可能出现的性能问题当多个具有相同优先级的线程反复争用同一把锁时就会发生锁列队与死锁和活锁的情况不同锁列队中的线程确实在进展然而每次线程尝试获取锁并失败时它都会放弃其剩余的调度量子并强制进行上下文切换重复的上下文切换和调度量子的低利用率降低了整体性能锁列队通常发生在并发控制原语如锁序列化访问常用资源如内存堆或线程池的情况下它们有时可以通过使用非锁定替代方案如无锁算法或者改变争用线程的相对优先级来解决活锁活锁是指线程们都在运行并尝试执行任务但是由于某些条件始终无法满足导致线程们一直在重试但是最终无法完成任务这种情况下线程们看起来像是在不断地活动但是实际上却没有任何进展如何无锁在现代的处理器上很多操作已经被设计为原子的比如对齐读和对齐写等操作的设计让执行更复杂的事务操作变成了原子操作当有多个写入者想对相同的内存进行修改时保证一次只执行一个操作操作在不同的家族中是通过不同的方式来支持的和架构通过方式来实现和架构通过方式来实现在下进行实践的用的是操作操作是技术的基础可以用下面的代码来描述工作原理无锁编程具体使用和考虑到的技术方法包括原子操作内存栅栏内存顺序冲突指令序列一致性顺现象等等在这其中最基础最重要的是操作的原子性或说原子操作对于原子操作的实现机制在硬件层面上处理器会默认保证基本的内存操作的原子性保证从系统内存当中读取或者写入一个字节的行为肯定是原子的当一个处理器读取一个字节时其他处理器不能访问这个字节的内存地址但是对于复杂的内存操作处理器不能自动保证其原子性比如跨总线宽度或者跨多个缓存行跨页表的访问等这个时候就需要用到指令集中设计的原子操作指令现在大部分指令集都会支持一系列的原子操作而在无锁编程中经常用到的原子操作是这种类型的这其中最常用的原子操作又是几乎所有的指令集都支持的原子操作比如平台下中的是操作行为是比较某个内存地址处的内容是否和期望值一致如果一致则将该地址处的数值替换为一个新值能够操作的位数越多使用它来实现锁无关的数据结构就越容易细节可以在手册中查看操作具体的实现原理主要是两种方式总线锁定执行某条指令的时候先锁住数据总线的使用同一条数据总线的就无法访问内存了在指令执行完成后再释放锁住的数据总线锁住数据总线的方式系统开销很大限制了访问内存的效率缓存锁定用的缓存一致性的机制来防止内存区域的数据被两个以上的处理器修改可详见缓存的协议操作系统的层面系统提供了软件级的原子操作包括两大类系统调用一类是基于对整数进行操作的一类是针对单独的位进行操作的它们大部分都是基于硬件层面的的指令实现的在各种开发语言中基于操作系统提供的接口也都封装实现了对应的原子操作所以开发者完全可以直接调用各个开发语言提供的接口实现无锁程序无锁编程技术事实证明当你试图满足无锁编程的无阻塞条件时会出现一系列技术原子操作内存屏障避免问题等等从这里开始事情很快变得棘手了内存保序正如前面流程图所建议的那样任何时候做多核或者任何对称多处理器的无锁编程如果你的环境不能保证顺序一致性你都必须考虑如何来防止内存重新排序在当今的架构中增强内存保序性的工具通常分为三类它们既防止编译器重新排序又防止处理器重新排序一个轻型的同步或屏障指令一个完全的内存屏障指令提供获取或释放语义的内存操作获取语义可防止按照程序顺序对其进行操作的内存重新排序而释放语义则可防止对其进行操作前的内存重新排序这些语义尤其适用于存在生产者消费者关系的情况其中一个线程发布一些信息而另一个线程读取它无锁编程如何控制对一个很大的对象的访问如果这是一个高一致性的场景也只能使用锁了但是如果这并不是一个对一致性要求非常高的场景呢比如可以允许修改内容在内生效而不是立即生效那么就可以结合无锁编程使用一种高效的方法用指针来访问这个共享对象写线程修改对象时不直接在对象上进行修改而是新建一个对象进行赋值赋值完成后再通过将指针指向这个新的对象然后销毁旧的对象通过这种方法可以将临界区从一大段代码缩减为一句代码极大的减少了对读线程的影响修改指针这一步只有一条代码语句虽然也可以用加锁的方式来保证线程安全但是恰好无锁编程也是只能对一条语句进行操作所以无锁编程非常符合这种方式往往一想到无锁编程就想到这种方法无锁队列如果一秒只需要处理几百或者几千的数据是没有必要考虑用无锁队列的用互斥锁就能解决问题数据量相对少的时候互斥锁与无锁队列之间差别并不是很明显无锁队列是中最基本的数据结构一般应用场景是资源分配比如的分配的分配上电内存初始块数的申请等等对于多线程用户来说无锁队列的入队和出队操作是线程安全的不用再加锁控制初始化队列根据和申请内存并对内存进行初始化入队从队尾增加元素出队从队头删除元素获取队列大小返回队列中的元素数队列是否为空表示队列为空表示队列非空开源无锁队列库库提供了这是一个支持多个生产者和多个消费者线程的无锁队列此外库还提供了无锁栈和仅支持单个生产者和单个消费者线程的无锁队列是一个基于实现的工业级无锁队列方案是一个基于实现的单生产者单消费者场景的无锁队列方案是一个使用原子操作实现的高性能自旋锁队列软件事务内存和协程并发编程领域不断发展新的模式和技术持续出现无锁编程正成为一种越来越受欢迎的方法但同时新的同步原语和库也在不断涌现例如软件事务内存和协程提供了新的并发处理方式正如计算机科学家曾指出简单性是成功复杂系统设计的关键无论选择哪种并发策略始终需要在性能复杂性可维护性和未来可扩展性之间找到平衡点如何排查并发编程死锁问题基础以及系统编程如何避免死锁如何避免死锁参阅如果死锁已经发生又应该如何排查呢使用等调试工具来排查在运行时检查线程的状态找出死锁的原因的查看进程的利用率如果利用率和内存异常低可能是发生了死锁使用去查看线程情况结合线程调用栈线程编号定位到线程的代码如果刚好是在等锁的代码上就要留意这块的逻辑是否陷入了死锁使用的话命令有所不同比如说和线程编号定位到行支持不支持系统是另一个强大的工具它提供了一系列的内存调试和分析工具其中的工具专门用于检测多线程程序中的同步错误包括死锁通过分析程序的运行识别竞争条件锁顺序不一致等问题帮助开发者定位和解决死锁问题上可以使用来排查死锁是一组性能分析工具它可以用来分析程序的运行时性能包括使用情况缓存命中率上下文切换次数等这些工具对于理解程序的运行时行为包括可能导致死锁的情况非常有帮助',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-11-07 16:51:03',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://th.bing.com/th/id/OIP.wtmjepfWPBvn26uz7s18dgHaHa?rs=1&amp;pid=ImgDetMain"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">ZEROKO14的个人博客</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AI/" style="font-size: 1.05rem;">AI<sup>1</sup></a><a href="/tags/C/" style="font-size: 1.05rem;">C#<sup>3</sup></a><a href="/tags/C/" style="font-size: 1.05rem;">C++<sup>5</sup></a><a href="/tags/CSS/" style="font-size: 1.05rem;">CSS<sup>1</sup></a><a href="/tags/CSharp/" style="font-size: 1.05rem;">CSharp<sup>1</sup></a><a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 1.05rem;">C语言<sup>1</sup></a><a href="/tags/FPS/" style="font-size: 1.05rem;">FPS<sup>1</sup></a><a href="/tags/HTML/" style="font-size: 1.05rem;">HTML<sup>1</sup></a><a href="/tags/JavaScript/" style="font-size: 1.05rem;">JavaScript<sup>1</sup></a><a href="/tags/MFC/" style="font-size: 1.05rem;">MFC<sup>1</sup></a><a href="/tags/PE/" style="font-size: 1.05rem;">PE<sup>1</sup></a><a href="/tags/QT/" style="font-size: 1.05rem;">QT<sup>1</sup></a><a href="/tags/WPF/" style="font-size: 1.05rem;">WPF<sup>3</sup></a><a href="/tags/ai/" style="font-size: 1.05rem;">ai<sup>1</sup></a><a href="/tags/cmake/" style="font-size: 1.05rem;">cmake<sup>1</sup></a><a href="/tags/doxygen/" style="font-size: 1.05rem;">doxygen<sup>1</sup></a><a href="/tags/git/" style="font-size: 1.05rem;">git<sup>1</sup></a><a href="/tags/linux/" style="font-size: 1.05rem;">linux<sup>1</sup></a><a href="/tags/nas/" style="font-size: 1.05rem;">nas<sup>1</sup></a><a href="/tags/next/" style="font-size: 1.05rem;">next<sup>1</sup></a><a href="/tags/ppt/" style="font-size: 1.05rem;">ppt<sup>1</sup></a><a href="/tags/python/" style="font-size: 1.05rem;">python<sup>1</sup></a><a href="/tags/slidev/" style="font-size: 1.05rem;">slidev<sup>1</sup></a><a href="/tags/vue/" style="font-size: 1.05rem;">vue<sup>1</sup></a><a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 1.05rem;">代码规范<sup>1</sup></a><a href="/tags/%E5%86%85%E6%A0%B8/" style="font-size: 1.05rem;">内核<sup>2</sup></a><a href="/tags/%E5%86%85%E6%A0%B8%E7%9B%B8%E5%85%B3/" style="font-size: 1.05rem;">内核相关<sup>5</sup></a><a href="/tags/%E5%8A%A0%E8%A7%A3%E5%AF%86/" style="font-size: 1.05rem;">加解密<sup>1</sup></a><a href="/tags/%E5%9F%BA%E7%A1%80/" style="font-size: 1.05rem;">基础<sup>6</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 1.05rem;">多线程<sup>1</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F/" style="font-size: 1.05rem;">并发模式<sup>1</sup></a><a href="/tags/%E5%BC%80%E5%8F%91/" style="font-size: 1.05rem;">开发<sup>4</sup></a><a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 1.05rem;">数学<sup>1</sup></a><a href="/tags/%E6%9D%82%E9%A1%B9/" style="font-size: 1.05rem;">杂项<sup>1</sup></a><a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 1.05rem;">正则表达式<sup>1</sup></a><a href="/tags/%E7%89%A9%E7%90%86/" style="font-size: 1.05rem;">物理<sup>1</sup></a><a href="/tags/%E7%9B%91%E6%8E%A7/" style="font-size: 1.05rem;">监控<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 1.05rem;">网络<sup>3</sup></a><a href="/tags/%E9%80%86%E5%90%91/" style="font-size: 1.05rem;">逆向<sup>5</sup></a><a href="/tags/%E9%AD%94%E6%B3%95/" style="font-size: 1.05rem;">魔法<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/09/"><span class="card-archive-list-date">九月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/02/"><span class="card-archive-list-date">二月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/12/"><span class="card-archive-list-date">十二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/11/"><span class="card-archive-list-date">十一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/09/"><span class="card-archive-list-date">九月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">七月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">14</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/06/"><span class="card-archive-list-date">六月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/04/"><span class="card-archive-list-date">四月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url">技术</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/C/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>C++</span></a><a class="article-meta__tags" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>多线程</span></a></span></div></div><h1 class="post-title" itemprop="name headline">C++多线程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-07-18T07:05:59.794Z" title="发表于 2024-07-18 15:05:59">2024-07-18</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-11-07T08:51:03.339Z" title="更新于 2024-11-07 16:51:03">2024-11-07</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="C++多线程"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为新加坡"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>新加坡</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://che77a38.github.io/posts/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><header><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url">技术</a><a href="/tags/C/" tabindex="-1" itemprop="url">C++</a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" tabindex="-1" itemprop="url">多线程</a><h1 id="CrawlerTitle" itemprop="name headline">C++多线程</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">ZEROKO14</span><time itemprop="dateCreated datePublished" datetime="2024-07-18T07:05:59.794Z" title="发表于 2024-07-18 15:05:59">2024-07-18</time><time itemprop="dateCreated datePublished" datetime="2024-11-07T08:51:03.339Z" title="更新于 2024-11-07 16:51:03">2024-11-07</time></header><p>C++语言级线程支持详解</p>
<p>标准库提供了五个头文件以支持多线程：atomic（提供原子操作功能）、thread（线程模型封装）、mutex（互斥量）、condition_variable（条件变量）、future</p>
<span id="more"></span>

<p><a target="_blank" rel="noopener" href="https://baiy.cn/doc/cpp/advanced_topic_about_multicore_and_threading.htm">可参考进阶文章</a></p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/613630658">参考</a></p>
<p><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/thread#.E6.9D.A1.E4.BB.B6.E5.8F.98.E9.87.8F">cppreference并发支持参考</a></p>
<p>为什么要用多线程</p>
<ul>
<li><p>任务分解</p>
<p>耗时的操作,任务分解,实时响应</p>
</li>
<li><p>数据分解</p>
<p>充分利用多核cpu处理数据</p>
</li>
<li><p>数据流分解</p>
<p>读写分离,解耦合设计</p>
</li>
</ul>
<blockquote>
<p>先了解操作系统提供的线程api</p>
<ul>
<li>[[linux基础以及系统编程#线程相关函数|linux提供的线程操作用法详解]]</li>
<li>[[windows开发#线程|windows提供的线程操作用法详解]]</li>
</ul>
<p>多进程:</p>
<p>使用多进程并发是将一个应用程序划分为多个独立的进程（每个进程只有一个线程），这些独立的进程间可以互相通信，共同完成任务。由于操作系统对进程提供了大量的保护机制，以避免一个进程修改了另一个进程的数据，使用多进程比使用多线程更容易写出相对安全的代码。但是这也造就了多进程并发的两个缺点：</p>
<ul>
<li>在进程间的通信，无论是使用信号、套接字，还是文件、管道等方式，其使用要么比较复杂，要么就是速度较慢或者两者兼而有之。</li>
<li>运行多个进程的开销很大，操作系统要分配很多的资源来对这些进程进行管理。</li>
</ul>
<p>因此就有了多线程:</p>
<p>多线程并发指的是在同一个进程中执行多个线程。</p>
<p>优点：有操作系统相关知识的应该知道，线程是轻量级的进程，每个线程可以独立的运行不同的指令序列，但是线程不独立的拥有资源，依赖于创建它的进程而存在。也就是说，同一进程中的多个线程共享相同的地址空间，可以访问进程中的大部分数据，指针和引用可以在线程间进行传递。这样，同一进程内的多个线程能够很方便的进行数据共享以及通信，也就比进程更适用于并发操作。</p>
<p>缺点：由于缺少操作系统提供的保护机制，在多线程共享数据及通信时，就需要程序员做更多的工作以保证对共享数据段的操作是以预想的操作顺序进行的，并且要**极力的避免死锁(deadlock)**。</p>
</blockquote>
<p>C++11引入了语言级线程支持,使用头文件<code>#include &lt;thread&gt;</code>,同时linux上额外需要编译选项<code>-lpthread</code></p>
<p>C++11提供了语言层面上的多线程，包含在头文件<thread>中。它解决了跨平台的问题，提供了管理线程、保护共享数据、线程间同步操作、原子操作等类。C++11 新标准中引入了5个头文件来支持多线程编程</p>
<h1 id="多线程概念区分"><a href="#多线程概念区分" class="headerlink" title="多线程概念区分"></a>多线程概念区分</h1><h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><ul>
<li>并发  并发是指在同一时间段内处理多个任务的能力。并发并不一定意味着同时执行多个任务，而是指多个任务在同一时间段内交替进行。<ul>
<li><strong>任务交替执行</strong>：在一个处理器上，任务可能会交替执行，而不是同时进行。操作系统通过时间片轮转等方式来实现这一点。</li>
<li><strong>资源共享</strong>：并发程序通常需要处理共享资源的问题，如数据竞争和死锁。</li>
<li><strong>适用场景</strong>：适合于 I&#x2F;O 密集型任务，比如网络请求、文件读写等，因为这些任务在等待 I&#x2F;O 操作时可以让出 CPU。</li>
</ul>
</li>
<li>并行  并行是指在同一时刻同时执行多个任务的能力。并行通常依赖于多核处理器的硬件支持。<ul>
<li><strong>任务同时执行</strong>：在多核处理器上，多个任务可以真正地同时运行。</li>
<li><strong>提高性能</strong>：通过将任务分解成多个子任务并同时执行，可以显著提高处理速度。</li>
<li><strong>适用场景</strong>：适合于 CPU 密集型任务，比如大规模计算、数据处理等。</li>
</ul>
</li>
</ul>
<h2 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h2><p>同步与异步是两种不同的编程模型</p>
<ul>
<li>同步编程模型  指一个任务完成才执行另一个任务,因此在同步中没有并发或并行的概念</li>
<li>异步编程模型  指的是不同任务之间不会相互等待,无论是并发还是并行都属于异步</li>
</ul>
<p>javascript本身没有多线程概念,但通过他的函数回调机制,依然能够实现单线程的并发</p>
<p>很多语言都提供了原生的异步编程方式,比如 C#，Rust, C++20 中的 co_await, Python 中的 asyncio 等等等等</p>
<h2 id="多线程编程-vs-单线程异步编程"><a href="#多线程编程-vs-单线程异步编程" class="headerlink" title="多线程编程 vs 单线程异步编程"></a>多线程编程 vs 单线程异步编程</h2><ul>
<li><p>对于<strong>IO密集</strong>的程序,更应该使用单线程异步编程,因为如果使用<strong>多线程编程</strong>,每个线程的绝大多数时间都是在等待这些I&#x2F;O操作(如网络请求,文件读写等),而线程自身也会占用额外的内存,线程的切换也会有额外的开销,更不用说线程之间的资源竞争问题.总之就是CPU的计算能力并没有被充分利用,因为大部分时间都在等待外部设备的响应</p>
<blockquote>
<p>对于 I&#x2F;O 密集型任务，单线程异步编程模型（如使用 <code>async</code> 和 <code>await</code>）非常有效。它允许程序在等待 I&#x2F;O 操作完成时，不阻塞主线程，而是继续执行其他操作。这种方式可以显著提高应用程序的响应性和性能，因为它减少了线程上下文切换的开销。</p>
</blockquote>
</li>
<li><p><strong>多线程编程</strong>则非常适合于**CPU密集(也叫计算量密集)**的应用,如视频图像处理,科学计算等等</p>
</li>
</ul>
<blockquote>
<p>这里介绍一下IO多路复用技术:</p>
<p>I&#x2F;O 复用是一种技术，允许一个或多个线程在同一时间处理多个 I&#x2F;O 操作，而不是为每个 I&#x2F;O 操作创建一个新的线程。I&#x2F;O 复用的常见实现方式包括：</p>
<ul>
<li><strong>选择器（Selector）</strong>：如 <code>select</code>、<code>poll</code> 和 <code>epoll</code>（在 Linux 中）等系统调用，它们允许单个线程监视多个 I&#x2F;O 文件描述符，以便在其中之一变为可读或可写时进行处理。</li>
<li><strong>事件驱动模型</strong>：如 Node.js 使用的事件循环，允许在单线程中处理多个并发 I&#x2F;O 操作。</li>
</ul>
</blockquote>
<h2 id="异步一定是多线程吗"><a href="#异步一定是多线程吗" class="headerlink" title="异步一定是多线程吗"></a>异步一定是多线程吗</h2><p>异步编程不必须要多线程来实现</p>
<ul>
<li>时间片轮转调度</li>
<li>单个线程上可以使用异步I&#x2F;O或事件驱动的编程模型(EAP)</li>
</ul>
<blockquote>
<p>从理解来说</p>
<ul>
<li>单线程异步: 自己定好计时器,到时间之前先去做别的事情</li>
<li>多线程异步: 将任务交给不同的线程,并由自己来进行指挥调度</li>
</ul>
</blockquote>
<p>js中的异步编程模型就是典型的单线程异步: 主要基于事件循环（Event Loop）机制</p>
<h2 id="协程和异步编程的关系"><a href="#协程和异步编程的关系" class="headerlink" title="协程和异步编程的关系"></a>协程和异步编程的关系</h2><blockquote>
<p>区别盘点</p>
<ul>
<li>以<strong>C# 的异步编程模型</strong>为例 使用 <code>async</code> 和 <code>await</code> 关键字，通过编译器生成的状态机来管理异步操作的状态和上下文恢复，而不是传统的协程机制。</li>
<li><strong>协程</strong> 是一种<strong>更底层的异步机制</strong>，允许直接暂停和恢复执行。C++20 的协程、Python 的 <code>async/await</code> 都是基于协程的实现。</li>
</ul>
</blockquote>
<p>协程&#x2F;线程都可以是实现异步的一种底层的方式,但单线程也可以通过算法实现异步</p>
<h1 id="Thread类型"><a href="#Thread类型" class="headerlink" title="Thread类型"></a>Thread类型</h1><h2 id="何时执行"><a href="#何时执行" class="headerlink" title="何时执行"></a>何时执行</h2><p>线程在构造关联的线程对象时立即开始执行，从提供给Thread类的线程函数开始。</p>
<p>有几点需要注意：</p>
<ul>
<li>线程函数的<strong>返回值将被忽略</strong>，而且若它以抛异常终止，则调用<code>std::terminate</code>。在需要获取返回值时，线程函数可以通过<code>std::promise</code>或者修改共享变量（可能需要锁机制进行线程同步）。</li>
<li>当使用不带参数的默认构造函数<code>thread()</code>构造<code>std::thread</code>对象时，该对象不表示任何线程，也不会有新线程产生。</li>
<li><code>std::thread</code>对象不可复制（复制构造函数已被删除）。没有两个<code>std::thread</code>对象会表示同一执行线程。</li>
<li>可以使用移动构造函数迁移原<code>thread</code>对象所关联的执行线程的所有权到新thread对象</li>
</ul>
<h2 id="线程函数参数"><a href="#线程函数参数" class="headerlink" title="线程函数参数"></a>线程函数参数</h2><p><code>std::thread</code>常用的构造函数如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Function, <span class="keyword">class</span>... Args &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">thread</span><span class="params">( Function&amp;&amp; f, Args&amp;&amp;... args )</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中，<code>f</code>为任意可调用对象（Callable），<code>args</code>为任意数目的作为可调用对象<code>f</code>的参数。</p>
<p>可调用对象（Callable）是C++的一个具名要求，常见的函数、成员函数、仿函数（函数对象）都属于可调用对象。</p>
<p>线程函数可以是以下几种方式：</p>
<ol>
<li>函数</li>
<li>成员函数</li>
<li>函数对象</li>
<li>使用lambda表达式</li>
</ol>
<h3 id="函数作为线程函数"><a href="#函数作为线程函数" class="headerlink" title="函数作为线程函数"></a>函数作为线程函数</h3><p>比较简单,仅需将函数名与函数参数分别传入即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">testFunc</span><span class="params">(<span class="type">int</span> p1,<span class="type">float</span>&amp; p2,string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;subThread begin&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;p1&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;p2&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;subThread end&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;main begin&quot;</span>&lt;&lt;endl;</span><br><span class="line">  	<span class="type">float</span> f = <span class="number">1.1</span>;</span><br><span class="line">    <span class="function">thread <span class="title">th</span><span class="params">(testFunc,<span class="number">101</span>,ref(f),<span class="string">&quot;hello world&quot;</span>)</span></span>;<span class="comment">//传参给线程函数</span></span><br><span class="line">    th.<span class="built_in">join</span>();<span class="comment">//堵塞,等待子线程退出</span></span><br><span class="line">    <span class="comment">//th.detach();//分离</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;main end&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意:传参给线程函数的过程默认是<strong>值传递</strong>,除非用<code>std::ref</code>把他包起来</p>
<p>使用<code>std::thread</code>创建的线程是<strong>没有返回值的</strong>，所以如果你想从线程中返回些什么，请使用引用将你想返回的值作为一个传入参数</p>
<h3 id="成员函数作为线程函数"><a href="#成员函数作为线程函数" class="headerlink" title="成员函数作为线程函数"></a>成员函数作为线程函数</h3><p>需要以<code>std::thread(&amp;类名::成员函数名, &amp;类实例)</code>的格式传入新线程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(<span class="type">int</span> showNum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Thread 3 executing NO.&quot;</span>&lt;&lt;showNum&lt;&lt;endl;</span><br><span class="line">            ++n;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">10</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">foo f;</span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(&amp;foo::bar, &amp;f,<span class="number">999</span>)</span></span>; <span class="comment">// t 在对象 f (引用传递)上运行 foo::bar()</span></span><br><span class="line"><span class="comment">//std::thread t(&amp;foo::bar, f,999);// t 在对象 f (值传递)上运行 foo::bar()</span></span><br><span class="line">t.<span class="built_in">join</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="函数对象作为线程函数"><a href="#函数对象作为线程函数" class="headerlink" title="函数对象作为线程函数"></a>函数对象作为线程函数</h3><p>仿函数（或称函数对象）便是传入类的第二种情况，此时该类的工作比较简单（单一，并非指实际工作难度），例如标准库中的<code>std::function</code>, <code>std::bind</code>等，又例如第一篇文章中的<code>ThreadWorker</code>类。成为仿函数的类，一般来说需要**重载函数调用运算符()**。在<code>std::thread</code>对象构建新线程后，会自动进行INVOKE操作执行传入的可调用对象。INVOKE操作执行对象为仿函数时，会自动调用仿函数重载的函数调用运算符<code>operator()</code>。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">baz</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Thread 4 executing\n&quot;</span>;</span><br><span class="line">            ++n;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">10</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//按值传递的方式</span></span><br><span class="line"><span class="function">thread <span class="title">t</span><span class="params">(b)</span></span>;</span><br><span class="line">t.<span class="built_in">join</span>();</span><br><span class="line">cout&lt;&lt;b.n&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//输出:0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//按引用传递的方式</span></span><br><span class="line">baz b;</span><br><span class="line"><span class="function">thread <span class="title">t</span><span class="params">(ref(b))</span></span>;</span><br><span class="line">t.<span class="built_in">join</span>();</span><br><span class="line">cout&lt;&lt;b.n&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//输出:5</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，新线程运行的仿函数实际上是传入时指定的仿函数的副本，这同时也就<strong>要求该仿函数是可拷贝的</strong>。</p>
<p>可以将返回值作为伪函数对象的一个成员变量来储存,这里的例子就是n</p>
<h3 id="lambda表达式作为线程函数"><a href="#lambda表达式作为线程函数" class="headerlink" title="lambda表达式作为线程函数"></a>lambda表达式作为线程函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">v.<span class="built_in">emplace_back</span>(<span class="number">3</span>);</span><br><span class="line"><span class="type">int</span> acm1 = <span class="number">0</span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;acm1, &amp;v] &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.size() ; ++i)</span></span></span><br><span class="line"><span class="params"><span class="function">    &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        acm1 += v[i];</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line">t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">cout&lt;&lt;acm1&lt;&lt;endl;</span><br><span class="line"><span class="comment">//输出: 6</span></span><br></pre></td></tr></table></figure>

<p>作为传参的替代方式，我们可以使用lambda表达式的捕获(capture)方式来处理参数传递</p>
<h3 id="线程参数传引用"><a href="#线程参数传引用" class="headerlink" title="线程参数传引用"></a>线程参数传引用</h3><p><code>std::thread</code>对象构造新线程时，会移动或按值复制线程函数的参数。若需要传递引用参数给线程函数，则必须包装它（例如用<code>std::ref</code>或<code>std::cref</code>）。例如：</p>
<h4 id="std-ref"><a href="#std-ref" class="headerlink" title="std::ref"></a>std::ref</h4><ul>
<li><strong>用途</strong>：<code>std::ref</code> 用于创建一个 <code>std::reference_wrapper</code> 对象，该对象封装了一个非 <code>const</code> 引用，允许通过这个包装器修改原始变量的值。</li>
<li><strong>语法</strong>：<code>std::ref(var)</code></li>
<li>特性<ul>
<li>通过 <code>std::ref</code> 包装的引用可以用来代替原始变量参与运算，包括赋值、读取和修改。</li>
<li>通过调用 <code>get()</code> 方法或者直接使用转换到引用的隐式转换，可以访问到封装的原始变量。</li>
<li>使用 <code>std::ref</code> 包装的引用传递给函数时，函数内可以通过包装器修改原始变量的值。</li>
</ul>
</li>
</ul>
<h4 id="std-cref"><a href="#std-cref" class="headerlink" title="std::cref"></a>std::cref</h4><ul>
<li><strong>用途</strong>：<code>std::cref</code> 同样用于创建一个 <code>std::reference_wrapper</code> 对象，但封装的是一个 <code>const</code> 引用，保证封装的对象不能被修改。</li>
<li><strong>语法</strong>：<code>std::cref(constVar)</code></li>
<li>特性<ul>
<li>通过 <code>std::cref</code> 包装的 <code>const</code> 引用只能用来读取原始变量的值，不能对其进行修改。</li>
<li>尽管封装的是 <code>const</code> 引用，<code>std::cref</code> 创建的包装器对象本身不是 <code>const</code>，意味着可以复制和赋值这样的包装器，但无论如何都不能通过包装器改变底层 <code>const</code> 变量的值。</li>
<li>同样可以通过 <code>get()</code> 方法或隐式转换访问底层的 <code>const</code> 变量，但在函数体内只能以 <code>const</code> 方式访问。</li>
</ul>
</li>
</ul>
<p><strong>应用场景举例</strong>：</p>
<ul>
<li><strong>函数式编程</strong>：当你需要将某个变量作为参数传递给一个高阶函数（如 <code>std::bind</code> 或者 lambda 表达式），并且希望在目标函数体内能修改原始变量时，使用 <code>std::ref</code>。反之，如果希望保持原始变量不可变，使用 <code>std::cref</code>。</li>
<li><strong>容器和算法</strong>：某些容器（如 <code>std::map</code>）的比较函数可能要求传入 <code>const</code> 引用。如果你需要基于用户定义类型的非 <code>const</code> 实例进行排序或查找，可以使用 <code>std::cref</code> 包装这些实例。</li>
<li><strong>回调机制</strong>：在注册事件处理器或设置回调函数时，若需要访问（可能修改）外部作用域内的变量，可以用 <code>std::ref</code> 提供可修改的引用；如果仅需观察而不改变变量，则使用 <code>std::cref</code>。</li>
</ul>
<h2 id="Thread的成员函数"><a href="#Thread的成员函数" class="headerlink" title="Thread的成员函数"></a>Thread的成员函数</h2><ul>
<li>join&#x2F;detach</li>
<li>swap</li>
<li>native_handle</li>
<li>hardware_concurrency</li>
</ul>
<h3 id="join-detach"><a href="#join-detach" class="headerlink" title="join&#x2F;detach"></a>join&#x2F;detach</h3><p><strong>thread下的两个成员函数,用于主线程与子线程之间的交互</strong></p>
<ul>
<li><p><code>join()</code>: 等待线程结束并阻塞当前线程，直到被等待的线程执行完毕。</p>
<p>可以在整个程序析构的时候调用join,来等待子线程退出</p>
</li>
<li><p><code>detach()</code>: 将线程设置为分离状态，使得线程结束时资源可以自动释放，不需要显式调用<code>join</code>来等待线程结束。</p>
</li>
</ul>
<blockquote>
<p><code>this_thread::sleep_for(chrono::seconds(1));</code>  等待一秒</p>
<p>由C++11引入</p>
<ul>
<li><p><code>this_thread::sleep_for</code> 需要使用 <code>std::this_thread</code> 命名空间，并且需要包含 <code>&lt;thread&gt;</code> 和 <code>&lt;chrono&gt;</code> 头文件。</p>
<p>精度更高,可移植性更强</p>
</li>
<li><p><code>sleep</code> 函数通常在 POSIX 系统中使用，需要包含 <code>&lt;unistd.h&gt;</code> 头文件。</p>
</li>
</ul>
</blockquote>
<p>常用: <code>if (myThread.joinable()) foo.join();</code></p>
<h3 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h3><p>Swap 线程，交换两个线程对象所代表的底层句柄(underlying handles)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(foo)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t2</span><span class="params">(bar)</span></span>;</span><br><span class="line">t<span class="number">1.</span><span class="built_in">swap</span>(t2);</span><br><span class="line">t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">t<span class="number">2.</span><span class="built_in">join</span>();</span><br></pre></td></tr></table></figure>

<h3 id="native-handle"><a href="#native-handle" class="headerlink" title="native_handle"></a>native_handle</h3><p>返回 native handle（由于 std::thread 的实现和操作系统相关，因此该函数返回与 std::thread 具体实现相关的线程句柄，例如在符合 Posix 标准的平台下(如 Unix&#x2F;Linux)是 Pthread 库）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(foo)</span></span>;</span><br><span class="line">cout&lt;&lt;t<span class="number">1.</span><span class="built_in">native_handle</span>()&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<h3 id="硬件线程并发数"><a href="#硬件线程并发数" class="headerlink" title="硬件线程并发数"></a>硬件线程并发数</h3><blockquote>
<p><code>hardware_concurrency</code>是thread类型的静态函数,表示硬件支持的最大并发量</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> n = std::thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line">  std::cout &lt;&lt; n &lt;&lt; <span class="string">&quot; concurrent threads are supported.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//10核m1 pro输出的是: 10 concurrent threads are supported.</span></span><br><span class="line"><span class="comment">//对于4核8线程的cpu返回的是8</span></span><br></pre></td></tr></table></figure>

<h1 id="this-thread"><a href="#this-thread" class="headerlink" title="this_thread"></a>this_thread</h1><p>this_thread是一个命名空间，它有4个功能函数，具体如下：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>使用</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>get_id</td>
<td>std::this_thread::get_id()</td>
<td>获取线程id</td>
</tr>
<tr>
<td>yield</td>
<td>std::this_thread::yield()</td>
<td>放弃线程执行，回到就绪状态,操作系统调度另一线程继续执行</td>
</tr>
<tr>
<td>sleep_for</td>
<td>std::this_thread::sleep_for(std::chrono::seconds(1));</td>
<td>线程休眠某个指定的时间片(time span)，该线程才被重新唤醒，不过由于线程调度等原因，实际休眠时间可能比 sleep_duration 所表示的时间片更长。</td>
</tr>
<tr>
<td>sleep_until</td>
<td>如下</td>
<td>线程休眠至某个指定的时刻(time point)，该线程才被重新唤醒</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> std::chrono::system_clock;</span><br><span class="line">std::<span class="type">time_t</span> tt = system_clock::<span class="built_in">to_time_t</span>(system_clock::<span class="built_in">now</span>());</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">std</span>::tm * ptm = std::<span class="built_in">localtime</span>(&amp;tt);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Waiting for the next minute to begin...\n&quot;</span>;</span><br><span class="line">++ptm-&gt;tm_min; <span class="comment">//加一分钟</span></span><br><span class="line">ptm-&gt;tm_sec = <span class="number">0</span>; <span class="comment">//秒数设置为0//暂停执行，到下一整分执行</span></span><br><span class="line">this_thread::<span class="built_in">sleep_until</span>(system_clock::<span class="built_in">from_time_t</span>(<span class="built_in">mktime</span>(ptm)));</span><br></pre></td></tr></table></figure>

<p>函数盘点</p>
<table>
<thead>
<tr>
<th>C++</th>
<th>Windows</th>
<th>POSIX</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>this_thread::yield()</td>
<td>BOOL SwitchToThread()</td>
<td>int sched_yield()</td>
<td>让出cpu时间片</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">C++</th>
<th align="left">Windows</th>
<th align="left">POSIX</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>std::this_thread::yield()</code></td>
<td align="left"><code>BOOL SwitchToThread()</code></td>
<td align="left"><code>int sched_yield()</code></td>
<td align="left">让出CPU时间片，允许其他线程执行</td>
</tr>
<tr>
<td align="left"><code>std::thread::sleep_for(std::chrono::duration)</code></td>
<td align="left"><code>Sleep(DWORD milliseconds)</code></td>
<td align="left"><code>nanosleep(struct timespec *)</code></td>
<td align="left">暂停当前线程指定的持续时间</td>
</tr>
<tr>
<td align="left"><code>std::thread::join()</code></td>
<td align="left"><code>WaitForSingleObject(HANDLE, DWORD)</code>配合<code>CreateThread()</code>使用</td>
<td align="left"><code>pthread_join(pthread_t, void **)</code></td>
<td align="left">等待指定线程结束其执行</td>
</tr>
<tr>
<td align="left"><code>std::mutex::lock()</code>, <code>unlock()</code></td>
<td align="left"><code>EnterCriticalSection(CRITICAL_SECTION*)</code>,<code>LeaveCriticalSection(CRITICAL_SECTION*)</code> 或<code>LockResource(HGLOBAL)</code>, <code>UnlockResource(HGLOBAL)</code></td>
<td align="left"><code>pthread_mutex_lock(pthread_mutex_t*)</code>,<code>pthread_mutex_unlock(pthread_mutex_t*)</code></td>
<td align="left">线程间互斥锁的获取与释放</td>
</tr>
<tr>
<td align="left"><code>std::condition_variable::wait()</code></td>
<td align="left"><code>WaitForMultipleObjects()</code>,结合<code>CRITICAL_SECTION</code>或<code>SRWLOCK</code>使用</td>
<td align="left"><code>pthread_cond_wait(pthread_cond_t*, pthread_mutex_t*)</code></td>
<td align="left">线程等待特定条件满足</td>
</tr>
<tr>
<td align="left"><code>std::atomic</code>操作</td>
<td align="left"><code>InterlockedExchange*()</code>,<code>_ReadWriteBarrier</code>,<code>MemoryBarrier</code>等函数</td>
<td align="left"><code>__atomic_*</code>系列函数</td>
<td align="left">原子操作以实现线程安全的数据访问</td>
</tr>
</tbody></table>
<h1 id="通用互斥体管理器"><a href="#通用互斥体管理器" class="headerlink" title="通用互斥体管理器"></a>通用互斥体管理器</h1><p>下面所有通用互斥体管理器都是严格基于作用域的互斥体所有权包装器:即RAII封装器</p>
<p>下面所有互斥体管理器均<strong>不可复制</strong></p>
<h2 id="lock-guard"><a href="#lock-guard" class="headerlink" title="lock_guard"></a>lock_guard</h2><p>严格基于作用域的互斥体所有权包装器</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::mutex myMytex;</span><br><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(myMutex)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>std::lock_guard</code> 是 C++ 中的一种 <a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1857405">RAII</a>（Resource Acquisition Is Initialization）机制实现，用于<strong>自动管理互斥量的锁定和解锁过程</strong>，确保即使在发生异常或提前返回的情况下也能正确释放互斥量，避免资源泄露。它通常与 <code>std::mutex</code> 结合使用，以简化同步代码的编写，提高程序的健壮性。</p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1857405">通过lock_guard理解RAII思想</a></p>
<h3 id="第二个参数adopt-lock"><a href="#第二个参数adopt-lock" class="headerlink" title="第二个参数adopt_lock"></a>第二个参数adopt_lock</h3><p><strong>adopt_lock帮助std::lock解锁</strong></p>
<p>通常情况下，<code>std::lock_guard</code> 在构造时会自动锁定其关联的互斥锁。然而，这里使用了额外的构造参数 <code>std::adopt_lock</code>，它的作用是：</p>
<ul>
<li>告诉 <code>std::lock_guard</code> 它所关联的互斥锁已经被外部机制（此处为 <code>std::lock</code>）锁定。</li>
<li><code>std::lock_guard</code> 不再尝试再次锁定互斥锁，而是直接“接管”（adopt）现有的锁定状态。</li>
<li>当 <code>sbguard1</code> 和 <code>sbguard2</code> 的生命周期结束（例如所在作用域结束时），它们各自的析构函数将自动调用 <code>unlock()</code> 方法释放之前被 <code>std::lock</code> 锁定的互斥锁。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::mutex myMutex1;</span><br><span class="line">std::mutex myMutex2;</span><br><span class="line">std::<span class="built_in">lock</span>(myMutex1,myMutex2);</span><br><span class="line"></span><br><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock1</span><span class="params">(myMutex1,std::adopt_lock)</span></span>;<span class="comment">//帮前面的std::lock解锁</span></span><br><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock2</span><span class="params">(myMutex2,std::adopt_lock)</span></span>;</span><br></pre></td></tr></table></figure>

<p>没有其他成员函数</p>
<h2 id="unique-lock"><a href="#unique-lock" class="headerlink" title="unique_lock"></a>unique_lock</h2><p>实现可移动的互斥体所有权包装器</p>
<ul>
<li>unique_lock比lock_guard灵活性更高，但是执行效率差一点，内存占用的也稍微多一些</li>
<li>unique_lock可以完全取代lock_guard</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(myMutex)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>相对于<a href="#lock_guard">lock_guard</a>而言,unique_lock多了下面的功能</p>
<ol>
<li><strong>延迟锁定</strong>,不必构造的时候马上锁定</li>
<li><strong>条件解锁与重新锁定</strong></li>
<li><strong>支持超时锁定</strong>,提供了带超时的锁定尝试</li>
<li><a href="#unique_lock%E6%89%80%E6%9C%89%E6%9D%83%E8%BD%AC%E7%A7%BB"><strong>转移所有权</strong></a></li>
<li>与<a href="#condition_variable">条件变量</a>配合实现<strong>等待与通知</strong></li>
</ol>
</blockquote>
<h3 id="第二个参数"><a href="#第二个参数" class="headerlink" title="第二个参数"></a>第二个参数</h3><ul>
<li><p><code>std::adopt_lock</code>  免去了加锁流程,仅保留只能解锁,<a href="#%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%8F%82%E6%95%B0adopt_lock">功能同lock_guard的adopt_lock参数</a></p>
</li>
<li><p><code>std::try_to_lock</code>  尝试用mutex的lock去锁定这个mutex，但没锁成功会立即返回，并不会阻塞在那里（前提：程序员不能自己先去lock这个mutex）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把收到的消息放入容器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inMsgRecvQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;inMsgRecvQueue()执行，插入一个元素&quot;</span>&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">sbguard1</span><span class="params">(my_mutex,std::try_to_lock)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(sbguard<span class="number">1.</span><span class="built_in">owns_lock</span>())    <span class="comment">//如果条件成立拿到了这个锁</span></span><br><span class="line">        &#123;</span><br><span class="line">            msgRecvQueue.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;<span class="comment">//自动加锁解锁</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//没拿到锁</span></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;inMsgRecvQueue()执行，但没拿到锁，只能干点别的事&quot;</span>&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>std::defer_lock  初始化mutex,但没有给mutex加锁,目的是为了实现延迟锁定</p>
</li>
</ul>
<h3 id="unique-lock成员函数"><a href="#unique-lock成员函数" class="headerlink" title="unique_lock成员函数"></a>unique_lock成员函数</h3><ul>
<li><p>lock  上锁</p>
</li>
<li><p>unlock  解锁</p>
</li>
<li><p>try_lock  尝试上锁,返回true表示拿到了锁</p>
</li>
<li><p>release  返回它所管理的mutex对象指针，并<strong>释放所有权</strong>，解除两者的关联关系</p>
<p>意味着此后不能再通过该 <code>unique_lock</code> 对互斥量进行任何锁定或解锁操作。调用release不会改变mutex锁的状态,本来上锁了释放了还是上锁状态</p>
</li>
<li><p>try_lock_for&#x2F;try_lock_until  结合时间间隔以及时间节点的尝试上锁</p>
</li>
<li><p>swap 交换</p>
</li>
<li><p>mutex  返回指向关联的互斥体的指针</p>
</li>
<li><p>owns_lock&#x2F;operator bool  测试是否占有其关联的互斥体</p>
</li>
</ul>
<h3 id="unique-lock所有权转移"><a href="#unique-lock所有权转移" class="headerlink" title="unique_lock所有权转移"></a>unique_lock所有权转移</h3><p>两种情况</p>
<ol>
<li><p>移动语义   <code>unique_lock&lt;mutex&gt; sbguard2(move(sbguard1));</code></p>
</li>
<li><p>返回unique_lock类型  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">rtn_unique_lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">tmpguard</span><span class="params">(my_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> tmpguard;<span class="comment">//从函数返回一个局部unique_lock对象是可以的，返回这种局部对象会调用unique_lock的移动构造函数</span></span><br><span class="line">&#125;</span><br><span class="line">std::unique_lock&lt;std::mutex&gt; sbguard1 = <span class="built_in">rtn_unique_lock</span>();</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="shared-lock"><a href="#shared-lock" class="headerlink" title="shared_lock"></a>shared_lock</h2><p>实现可移动的<strong>共享</strong>互斥体所有权封装器</p>
<p>功能与<a href="#unique_lock">unique_lock</a>完全一致,只是后者针对的是非共享互斥体</p>
<p>成员函数与<a href="#unique_lock%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0">unique_lock成员函数</a>一致</p>
<h2 id="scoped-lock"><a href="#scoped-lock" class="headerlink" title="scoped_lock"></a>scoped_lock</h2><blockquote>
<p>C++17才引入</p>
<p><strong>简化多锁同步</strong>:特别适用于同时管理多个互斥量的场景，如实现复杂的多资源同步逻辑。它可以一次性安全地锁定多个互斥量，确保了锁的获取顺序一致性和<strong>避免死锁</strong>。开发者无需手动编写繁琐的锁获取和释放代码，降低了编程复杂度和出错的可能性。这对于涉及多个相关数据结构或资源的并发操作至关重要，有助于保证程序的线程安全性。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mutex m1,m2;</span><br><span class="line"><span class="function">scoped_lock <span class="title">lock</span><span class="params">(m1,m2)</span></span>;</span><br><span class="line"><span class="comment">// 等价代码 1（用 std::lock 和 std::lock_guard ）</span></span><br><span class="line"><span class="comment">// std::lock(e1.m, e2.m);</span></span><br><span class="line"><span class="comment">// std::lock_guard&lt;std::mutex&gt; lk1(e1.m, std::adopt_lock);</span></span><br><span class="line"><span class="comment">// std::lock_guard&lt;std::mutex&gt; lk2(e2.m, std::adopt_lock);</span></span><br><span class="line"><span class="comment">// 等价代码 2（若需要 unique_lock，例如对于条件变量）</span></span><br><span class="line"><span class="comment">// std::unique_lock&lt;std::mutex&gt; lk1(e1.m, std::defer_lock);</span></span><br><span class="line"><span class="comment">// std::unique_lock&lt;std::mutex&gt; lk2(e2.m, std::defer_lock);</span></span><br><span class="line"><span class="comment">// std::lock(lk1, lk2);</span></span><br></pre></td></tr></table></figure>

<p>没有其他成员函数</p>
<h1 id="mutex系列"><a href="#mutex系列" class="headerlink" title="mutex系列"></a>mutex系列</h1><ol>
<li><p><code>mutex</code> C++11 基本的互斥量</p>
</li>
<li><p><code>timed_mutex</code> C++11 有超时机制的互斥量</p>
<p>超时机制: 提供了带超时限制的锁定尝试方法，如 <code>try_lock_for()</code> 和 <code>try_lock_until()</code>。</p>
</li>
<li><p><code>recursive_mutex</code> C++11 可重入的互斥量</p>
<p>可重入: 指一个线程在已经持有某个互斥体的情况下，能够再次成功获取该互斥体而不会阻塞自己</p>
</li>
<li><p><code>recursive_timed_mutex</code> C++11 结合timed_mutex和recursize_mutex特点的互斥量</p>
</li>
<li><p><code>shared_timed_mutex</code> C++14 具有超时机制的可共享互斥量</p>
<p>可共享:支持两种锁定模式：独占（exclusive）模式和共享（shared）模式。多个线程可以同时以共享模式锁定互斥量，但任何时候只有一个线程可以以独占模式锁定。共享模式下提供<code>try_lock_shared_for()</code> 和 <code>try_lock_shared_until()</code> 方法用于尝试在指定时间内获取共享锁。注意释放共享锁需要使用<code>unlock_shared()</code> </p>
</li>
<li><p><code>shared_mutex</code> C++17 共享的互斥量</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::mutex g_num_mutex;</span><br><span class="line">g_num_mutex.<span class="built_in">lock</span>();</span><br><span class="line"><span class="comment">//干活</span></span><br><span class="line">g_num_mutex.<span class="built_in">unlock</span>();</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><strong>共享锁机制的意义</strong>:允许多个读取事务同时访问同一数据,具备了<strong>更高效的并发读取</strong>，同时保证了<strong>数据一致性</strong>:虽然多个读取线程可以同时持有共享锁，但写入线程必须先获取到 <code>std::shared_mutex</code> 的独占锁（即排他锁）。这样，写入操作期间，所有试图获取共享锁的读取线程都会被阻塞，直到写入完成。这种方式确保了读取线程始终能看到一个完整且一致的计数器值，不会出现因写入操作中途而读取到部分更新的数据（即<strong>避免“脏读”</strong>）。</li>
<li><strong>超时锁机制的意义</strong>:获取锁的过程变为<strong>限时等待</strong>,<strong>主动错误处理</strong>,<strong>预防死锁</strong></li>
<li><strong>可重入锁机制的意义</strong>:递归锁定支持,这对于设计复杂、可能存在嵌套锁需求的代码尤为关键.<strong>简化编程模型</strong>：程序员无需关注锁的递归使用情况，可以直接在需要同步的代码块中重复调用锁定操作，无需手动管理锁的层次结构和释放顺序。</li>
</ul>
</blockquote>
<p>下面提供一个share_lock的使用案例:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;shared_mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SharedCounter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_value</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="function">std::shared_lock&lt;std::shared_mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;<span class="comment">//锁定共享锁(读锁)</span></span><br><span class="line">        <span class="keyword">return</span> value_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::shared_mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;<span class="comment">//锁定独占锁(写锁)</span></span><br><span class="line">        ++value_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> std::shared_mutex mutex_;</span><br><span class="line">    <span class="type">int</span> value_ = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SharedCounter counter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建多个读取线程</span></span><br><span class="line">    std::vector&lt;std::thread&gt; reader_threads;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        reader_threads.<span class="built_in">emplace_back</span>([&amp;counter]() &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; ++j) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;: Reading counter value: &quot;</span> &lt;&lt; counter.<span class="built_in">get_value</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个写入线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">writer_thread</span><span class="params">([&amp;counter]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; <span class="string">&quot;Writer thread (&quot;</span> &lt;&lt; std::this_thread::get_id() &lt;&lt; <span class="string">&quot;): Incrementing counter...\n&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">            counter.increment();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有读取线程完成</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : reader_threads) &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待写入线程完成</span></span><br><span class="line">    writer_thread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="lock-unlock"><a href="#lock-unlock" class="headerlink" title="lock&#x2F;unlock"></a>lock&#x2F;unlock</h2><p>一次性允许锁住多把锁,但需要自己解锁</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::mutex myMutex1;</span><br><span class="line">std::mutex myMutex2;</span><br><span class="line">std::<span class="built_in">lock</span>(myMutex1,myMutex2);</span><br><span class="line"><span class="comment">//..</span></span><br><span class="line">myMutex<span class="number">1.</span><span class="built_in">unlock</span>();</span><br><span class="line">myMutex<span class="number">2.</span><span class="built_in">unlock</span>();</span><br></pre></td></tr></table></figure>

<p><code>std::lock</code> 函数接受两个或更多互斥锁作为参数，会以以一种<strong>无死锁的方式同时锁定它们</strong>。这意味着它会采用一种<strong>自旋等待策略（如“循环尝试”算法）</strong>，确保无论线程调度情况如何，都不会导致两个线程互相等待对方释放已锁定的互斥锁而形成死锁。一旦成功锁定两个互斥锁，程序继续执行下一行代码。</p>
<h1 id="单次调用"><a href="#单次调用" class="headerlink" title="单次调用"></a>单次调用</h1><p>头文件: <code>#include &lt;mutex&gt;</code></p>
<p><strong>避免在多线程环境下多次执行同一个函数</strong>的快捷实现代码</p>
<p>C++11 中引入的用于确保某个函数只被调用一次的线程安全的函数和类型</p>
<ul>
<li><p>once_flag   一个类型，用于标记一段代码是否已经被执行过。它必须通过引用传递给 <code>std::call_once</code> 函数，以确保在多线程环境下仅仅执行一次。</p>
</li>
<li><p>call_once   </p>
<p>接受两个参数：一个可调用对象（可以是函数、lambda 表达式等）和一个 <code>std::once_flag</code> 对象的引用。该函数会检查 <code>std::once_flag</code> 对象是否被设置过，如果没有，就调用可调用对象，并设置 <code>std::once_flag</code> 对象为已设置状态。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::once_flag flag;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_something</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//call_once中的 lambda 表达式只执行一次</span></span><br><span class="line">    std::<span class="built_in">call_once</span>(flag, []() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;do_something() called once&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread id&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(do_something)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(do_something)</span></span>;</span><br><span class="line"></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果需要传递参数,直接接在函数名参数后面:(如下)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::once_flag flag;</span><br><span class="line">std::<span class="built_in">call_once</span>(flag,testOutput,<span class="string">&quot;hello world!&quot;</span>);<span class="comment">//&quot;hello world!&quot;为参数</span></span><br></pre></td></tr></table></figure>

<p>下面使用<code>call_once</code> 函数来保证单例模式在多线程环境中的正确性</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//使用了 std::call_once 函数，因此在多个线程同时调用时，只有一个线程会创建单例对象 instance_，即只有一个线程执行函数init()</span></span><br><span class="line">    <span class="comment">//其他线程会直接返回之前创建的单例对象 instance_，从而保证单例对象只被创建一次</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::<span class="built_in">call_once</span>(flag_, &amp;Singleton::init);</span><br><span class="line">        <span class="keyword">return</span> *instance_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Singleton instance created.\n&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        instance_ = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在类的定义中，一个静态成员变量必须由该类声明为static</span></span><br><span class="line">    <span class="comment">//并且通常还需要在类外初始化，这意味着在类的定义中仅指定其类型和名称</span></span><br><span class="line">    <span class="type">static</span> std::once_flag flag_;</span><br><span class="line">    <span class="type">static</span> Singleton* instance_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在 class 外初始化 static 成员变量</span></span><br><span class="line">std::once_flag Singleton::flag_;</span><br><span class="line">Singleton* Singleton::instance_ = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用 Singleton::getInstance() 函数来获取单例对象的引用</span></span><br><span class="line">    Singleton&amp; singleton = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Singleton instance address: &quot;</span> &lt;&lt; &amp;singleton &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> num_threads = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_threads; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//threads将 `thread_func` 函数作为线程函数，创建多个线程并启动它们：</span></span><br><span class="line">        threads.<span class="built_in">emplace_back</span>(thread_func);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : threads)</span><br><span class="line">    &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h1><p>条件变量是允许多个线程相互交流的同步原语。它允许一定量的线程等待（可以定时）另一线程的提醒，然后再继续。条件变量始终关联到一个互斥体。</p>
<p>C++11引入了两种条件变量</p>
<ul>
<li><a href="#condition_variable">std::condition_variable</a></li>
<li>std::condition_variable_any    支持更多的锁，但在一些平台上性能更差,略</li>
</ul>
<h2 id="condition-variable"><a href="#condition-variable" class="headerlink" title="condition_variable"></a>condition_variable</h2><p>头文件: <code>#include &lt;condition_variable&gt;</code></p>
<p>在C++11中，我们可以使用条件变量（condition_variable）实现多个线程间的同步操作；当条件不满足时，相关线程被一直阻塞，直到某种条件出现，这些线程才会被唤醒。</p>
<p>条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：</p>
<ul>
<li>一个线程因等待”条件变量的条件成立”而挂起</li>
<li>另外一个线程使”条件成立”,给出信号,从而唤醒被等待的线程</li>
</ul>
<p>为了防止竞争，条件变量的使用总是和一个<a href="#mutex%E7%B3%BB%E5%88%97">互斥锁</a>结合在一起；通常情况下这个锁是<code>std::mutex</code>,使用<a href="#unique_lock">unique_lock管理锁</a></p>
<h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><ul>
<li><p>通知</p>
<ul>
<li><code>void notify_one()</code>  通知一个等待的线程</li>
<li><code>void notify_call()</code> 通知所有等待的线程</li>
</ul>
</li>
<li><p>等待</p>
<ul>
<li><p><code>void wait(std::unique_lock&lt;std::mutex&gt;&amp; lock)</code>  释放互斥锁,阻塞当前线程,直到条件变量被唤醒</p>
<p>获取互斥锁后，线程应立即检查等待的条件是否确实满足。这是因为唤醒并不意味着条件一定已经变为真，可能存在“<strong>虚假唤醒</strong>”（spurious wakeup）的情况。标准并未规定何时发生虚假唤醒，但实现中可能会出于效率等原因导致这种情况出现。因此，<strong>通常会将 <code>wait()</code> 嵌套在一个循环中，循环体内检查条件是否满足，如果不满足则再次调用 <code>wait()</code> 继续等待</strong>。</p>
</li>
<li><p>wait_for 阻塞当前线程,直到条件变量被唤醒,或到指定时限时长后</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Rep, <span class="keyword">class</span> Period &gt;</span></span><br><span class="line"><span class="function">std::cv_status <span class="title">wait_for</span><span class="params">( std::unique_lock&lt;std::mutex&gt;&amp; lock,<span class="type">const</span> std::chrono::duration&lt;Rep, Period&gt;&amp; rel_time )</span></span>;</span><br><span class="line"><span class="comment">//lock	-	必须已经由调用线程锁定的锁</span></span><br><span class="line"><span class="comment">//rel_time	-	可以等待的最长时长</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>wait_until 阻塞当前线程,直到条件变量被唤醒,或直到抵达指定时间点</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Clock, <span class="keyword">class</span> Duration &gt;</span></span><br><span class="line"><span class="function">std::cv_status <span class="title">wait_until</span><span class="params">( std::unique_lock&lt;std::mutex&gt;&amp; lock,<span class="type">const</span> std::chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time )</span></span>;</span><br><span class="line"><span class="comment">//lock	-	必须已经由调用线程锁定的锁</span></span><br><span class="line"><span class="comment">//abs_time	-	等待截止的时间点</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>原生句柄</p>
<ul>
<li>native_handle  返回原生句柄</li>
</ul>
</li>
</ul>
<blockquote>
<p>上面的wait_for和wait_until两个函数返回的cv_status类型如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">cv_status</span> &#123;</span><br><span class="line">    no_timeout,<span class="comment">//条件变量因notify_all或notify_one被唤醒</span></span><br><span class="line">    timeout  <span class="comment">//条件变量因时限耗尽被唤醒</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>wait_for</code>&#x2F;<code>wait_until</code> 函数返回一个 <code>std::cv_status</code> 枚举值，用来指示线程是由于何种原因被唤醒的：</p>
<ul>
<li>如果计数器值达到或超过了阈值（即谓词返回 <code>true</code>），<code>wait_for</code> 会立即返回，返回值为 <code>std::cv_status::no_timeout</code>，表示线程是由于条件满足而非超时被唤醒的。</li>
<li>如果在指定时间内计数器值仍未达到阈值，则到达了最大等待时间，<code>wait_for</code> 返回 <code>std::cv_status::timeout</code>，表示线程是由于超时被唤醒的。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> status = cv.<span class="built_in">wait_for</span>(lock, std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>), [threshold = <span class="number">10</span>]&#123; <span class="keyword">return</span> counter &gt;= threshold; &#125;);</span><br><span class="line"><span class="keyword">switch</span> (status) &#123;</span><br><span class="line">  <span class="keyword">case</span> std::cv_status::no_timeout:</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;: Counter reached or exceeded threshold (value: &quot;</span></span><br><span class="line">      &lt;&lt; counter &lt;&lt; <span class="string">&quot;).\n&quot;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> std::cv_status::timeout:</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;: Timed out waiting for counter to reach threshold (current value: &quot;</span></span><br><span class="line">      &lt;&lt; counter &lt;&lt; <span class="string">&quot;).\n&quot;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>生产者消费者案例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span>       <span class="comment">//必须包含这个头文件，否则报错</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Task</span>(<span class="type">int</span> taskID)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;taskID = taskID;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doTask</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;handle a task,taskID: &quot;</span>&lt;&lt;taskID&lt;&lt;<span class="string">&quot;,threadID: &quot;</span>&lt;&lt;std::this_thread::<span class="built_in">get_id</span>()&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> taskID;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::mutex                  myMutex;</span><br><span class="line">std::list&lt;Task*&gt;            tasks;</span><br><span class="line">std::condition_variable     mycv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">consumer_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Task* pTask = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(myMutex)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(tasks.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果发生变化后，如果条件合适，则pthread_cond_wait将直接获得锁</span></span><br><span class="line">            mycv.<span class="built_in">wait</span>(guard);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pTask = tasks.<span class="built_in">front</span>();</span><br><span class="line">        tasks.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pTask == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        pTask-&gt;<span class="built_in">doTask</span>();<span class="comment">//任务就是打印自己线程号</span></span><br><span class="line">        <span class="keyword">delete</span> pTask;</span><br><span class="line">        pTask = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">producer_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> taskID = <span class="number">0</span>;</span><br><span class="line">    Task* pTask = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pTask = <span class="keyword">new</span> <span class="built_in">Task</span>(taskID);</span><br><span class="line">        <span class="comment">//使用括号减少guard锁的利用范围</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">sbguard</span><span class="params">(myMutex)</span></span>;</span><br><span class="line">            tasks.<span class="built_in">push_back</span>(pTask);</span><br><span class="line">            std::cout&lt;&lt;<span class="string">&quot;produce a task,taskID: &quot;</span>&lt;&lt;taskID&lt;&lt;<span class="string">&quot;,threadID :&quot;</span>&lt;&lt;std::this_thread::<span class="built_in">get_id</span>()&lt;&lt;std::endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放信号量，通知消费者线程</span></span><br><span class="line">        mycv.<span class="built_in">notify_one</span>();<span class="comment">//相当于pthread_cond_signal</span></span><br><span class="line"></span><br><span class="line">        ++taskID;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//休眠一秒</span></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建5个消费者线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">consumer1</span><span class="params">(consumer_thread)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">consumer2</span><span class="params">(consumer_thread)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">consumer3</span><span class="params">(consumer_thread)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">consumer4</span><span class="params">(consumer_thread)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">consumer5</span><span class="params">(consumer_thread)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建1个生产者线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">producer1</span><span class="params">(producer_thread)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回收线程</span></span><br><span class="line">    producer<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    consumer<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    consumer<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    consumer<span class="number">3.</span><span class="built_in">join</span>();</span><br><span class="line">    consumer<span class="number">4.</span><span class="built_in">join</span>();</span><br><span class="line">    consumer<span class="number">5.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="简单测试"><a href="#简单测试" class="headerlink" title="简单测试"></a>简单测试</h2><h3 id="仅使用互斥体"><a href="#仅使用互斥体" class="headerlink" title="仅使用互斥体"></a>仅使用互斥体</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; taskNos;</span><br><span class="line">std::mutex theMutex;</span><br><span class="line">condition_variable cv;</span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myProducer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> seed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(theMutex)</span></span>;</span><br><span class="line">        taskNos.<span class="built_in">emplace_back</span>(seed++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myConsumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(theMutex)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(taskNos.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;this_thread::<span class="built_in">get_id</span>()&lt;&lt;<span class="string">&quot;执行No.&quot;</span>&lt;&lt;taskNos.<span class="built_in">front</span>()&lt;&lt;<span class="string">&quot;任务!&quot;</span>&lt;&lt;endl;</span><br><span class="line">            taskNos.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">ttt1</span><span class="params">(myConsumer)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">ttt2</span><span class="params">(myConsumer)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">ttt3</span><span class="params">(myConsumer)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">ttt4</span><span class="params">(myConsumer)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">ttt5</span><span class="params">(myConsumer)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">ttt6</span><span class="params">(myProducer)</span></span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>)); <span class="comment">// 等待 2 秒</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//335072</span></span><br><span class="line"><span class="comment">//368127</span></span><br><span class="line"><span class="comment">//364789</span></span><br></pre></td></tr></table></figure>

<p>平均完成任务数为355996</p>
<blockquote>
<p>如果只使用互斥量而不引入条件变量，消费者线程可能会陷入<strong>“忙等待”状态</strong>。当任务列表（<code>taskNos</code>）为空时，每个消费者线程都会反复尝试锁定互斥锁，检查任务列表是否已非空。这种做法会导致CPU资源的浪费，尤其是在任务生成速度远低于消费者线程消费速度的情况下。</p>
</blockquote>
<h3 id="使用条件变量"><a href="#使用条件变量" class="headerlink" title="使用条件变量"></a>使用条件变量</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; taskNos;</span><br><span class="line">std::mutex theMutex;</span><br><span class="line">condition_variable cv;</span><br><span class="line"><span class="comment">//生产者,每秒生产两个货品</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myProducer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> seed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(theMutex)</span></span>;</span><br><span class="line">            taskNos.<span class="built_in">emplace_back</span>(seed++);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//通知消费者消费</span></span><br><span class="line">        cv.<span class="built_in">notify_one</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myConsumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(theMutex)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(taskNos.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            cv.<span class="built_in">wait</span>(lock);</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;this_thread::<span class="built_in">get_id</span>()&lt;&lt;<span class="string">&quot;执行No.&quot;</span>&lt;&lt;taskNos.<span class="built_in">front</span>()&lt;&lt;<span class="string">&quot;任务!&quot;</span>&lt;&lt;endl;</span><br><span class="line">        taskNos.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">ttt1</span><span class="params">(myConsumer)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">ttt2</span><span class="params">(myConsumer)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">ttt3</span><span class="params">(myConsumer)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">ttt4</span><span class="params">(myConsumer)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">ttt5</span><span class="params">(myConsumer)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">ttt6</span><span class="params">(myProducer)</span></span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>)); <span class="comment">// 等待 2 秒</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>平均完成任务数为381065</p>
<p>测试差别不是很大</p>
<blockquote>
<p>精确唤醒: 生产者在添加新任务时，通过 <code>cv.notify_one()</code> 或 <code>cv.notify_all()</code> 唤醒等待的消费者线程。这种精确唤醒机制使得唤醒的线程可以直接进行有效的工作（消费任务），而不是像忙等待那样可能连续多次检查后仍无任务可做。</p>
</blockquote>
<h2 id="notify-all-at-thread-exit函数"><a href="#notify-all-at-thread-exit函数" class="headerlink" title="notify_all_at_thread_exit函数"></a>notify_all_at_thread_exit函数</h2><p>在执行一组异步任务的线程中，当所有任务完成后，该线程可以使用 <code>notify_all_at_thread_exit</code> 向等待的任务协调者线程发送信号，表示所有任务已完成，无需再轮询或检查任务状态。重点是可以<strong>简化线程清理逻辑</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">notify_all_at_thread_exit</span><span class="params">( std::condition_variable&amp; cond,</span></span></span><br><span class="line"><span class="params"><span class="function">                                std::unique_lock&lt;std::mutex&gt; lk )</span></span>;</span><br></pre></td></tr></table></figure>

<p>通知其他线程给定的线程已完全完成，包括销毁所有 <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/keyword/thread_local"><code>thread_local</code></a> 对象。它操作如下：</p>
<ol>
<li>将先前获得的锁 lk 的所有权转移到内部存储。</li>
<li>修改执行环境，以令当前线程退出时，如同以 <code>lk.unlock();</code><br><code>cond.notify_all();</code> 通知条件变量 cond。</li>
</ol>
<p>隐含的 lk.unlock 按顺序晚于与当前线程关联的所有拥有线程局域存储期的对象析构。</p>
<p>此部分代码零碎地描绘 <code>notify_all_at_thread_exit</code> 能如何用于避免在线程局域对象处于被析构过程时，访问依赖于它们的数据(因为将会在析构掉thread_local 对象后才解锁互斥体,不会看到析构到一半的thread_local变量)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"> </span><br><span class="line">std::mutex m;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"> </span><br><span class="line"><span class="type">bool</span> ready = <span class="literal">false</span>;</span><br><span class="line">ComplexType result; <span class="comment">// 某种任意类型</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">thread_local</span> std::string thread_local_data = <span class="string">&quot;42&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 用 thread_local 数据赋值给 result</span></span><br><span class="line">    result = thread_local_data;</span><br><span class="line">    ready = <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">    std::<span class="built_in">notify_all_at_thread_exit</span>(cv, std::<span class="built_in">move</span>(lk));</span><br><span class="line"> </span><br><span class="line">&#125;   <span class="comment">// 1. 销毁 thread_local 对象；</span></span><br><span class="line">    <span class="comment">// 2. 解锁互斥体；</span></span><br><span class="line">    <span class="comment">// 3. 通知 cv。</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(thread_func)</span></span>;</span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 做其他工作</span></span><br><span class="line">    <span class="comment">// .…</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 等待脱附的线程</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">    cv.<span class="built_in">wait</span>(lk, []&#123; <span class="keyword">return</span> ready; &#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// result 已就绪且 thread_local 析构函数已完成，无 UB</span></span><br><span class="line">    <span class="built_in">assert</span>(result == <span class="string">&quot;42&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="promise-future模型"><a href="#promise-future模型" class="headerlink" title="promise\future模型"></a>promise\future模型</h1><p>除了std::thread，我们还可以使用 promise\future模型.</p>
<p>头文件: <code>#include &lt;future&gt;</code></p>
<p>在并发编程中，我们通常会用到一组非阻塞的模型：<code>promise\future</code>。在python、js、java中都提供future\promise，是现代语言常用的非阻塞编程模型。</p>
<blockquote>
<p>与thread的主要区别</p>
<ul>
<li><code>#include &lt;future&gt;</code> 主要关注异步任务的提交、结果的获取以及跨线程通信，侧重于任务的异步执行与结果同步，提供了高层级的抽象和便利接口，适用于需要等待异步结果的场景。</li>
<li><code>#include &lt;thread&gt;</code> 则专注于线程的创建、管理和同步，提供了底层的线程控制机制，适合直接操作线程以及解决多线程间的同步和通信问题。</li>
</ul>
<p>future的优势如下:</p>
<ol>
<li><strong>异步任务结果的封装与传递</strong>：<ul>
<li><code>std::future</code> 和 <code>std::shared_future</code> 为异步任务的结果提供了一种标准化、类型安全的封装。通过它们，可以方便地在不同线程之间传递和访问异步任务的最终输出，而无需自行设计和实现复杂的通信机制。这种方式有利于代码的组织和复用，降低了异步编程的复杂度。</li>
</ul>
</li>
<li><strong>任务执行策略的灵活性</strong>：<ul>
<li><code>std::async</code> 函数允许指定任务的执行策略。例如，可以选择立即在新的线程上执行、推迟至某个适当时机执行（如当前线程空闲时）、或者放入线程池中执行。这种灵活性使得程序员可以根据应用需求和系统资源状况调整任务的调度方式，提高程序的整体效率。</li>
</ul>
</li>
<li><strong>异步编程的高级抽象</strong>：<ul>
<li><code>std::packaged_task</code> 为异步任务提供了更高级别的抽象。它可以保存一个可调用对象，并生成一个相应的 <code>std::future</code>，简化了异步任务的创建和管理。此外，<code>std::packaged_task</code> 还支持任务的多次执行和重置，为复杂异步逻辑提供了便利。</li>
</ul>
</li>
<li><strong>优雅的异步控制流</strong>：<ul>
<li><code>std::future</code> 提供了多种等待机制（如阻塞等待、限时等待、定时等待），使得主线程可以灵活地控制等待异步结果的行为，避免无谓的阻塞。同时，通过 <code>std::future::get</code> 方法可以安全地获取并清除异步任务的结果，确保了结果的一次性使用和内存的有效管理。</li>
</ul>
</li>
<li><strong>更好的异常处理</strong>：<ul>
<li>当异步任务执行过程中抛出异常时，异常会被存储在对应的 <code>std::future</code> 对象中。通过调用 <code>std::future::get</code>，可以在适当的位置捕获并处理这些异常，使得异步编程中的异常处理更加可控和统一。</li>
</ul>
</li>
</ol>
</blockquote>
<ul>
<li>future表示一个可能还没有实际完成的<strong>异步任务的结果</strong>，针对这个结果可以添加回调函数以便在任务执行成功或失败后做出对应的操作；（回调就是自己写了却不调用，给别人调用的函数）</li>
<li>promise交由任务执行者，任务执行者<strong>通过promise可以标记任务完成或者失败</strong>；</li>
</ul>
<p>异步调用创建的时候，会返回一个<code>std::future</code>对象实例给异步调用创建方。异步调用执行方持有<code>std::promise</code>对象实例。双方持有的<code>std::promise</code>对象实例和<code>std::future</code>对象实例分别连接一个共享对象，这个共享对象在异步调用创建方和异步调用执行方之间构建了一个信息同步的通道（<code>channel</code>)，双方通过这个通道进行异步调用执行情况的信息交互(如图)</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202404071103042.png" alt="std::future和std::promise详解(原理、应用、源码）" style="zoom:33%;" />

<p>future\promise编程模型本质上还是message pass（任务线程与主线程消息传递）。在future模型中阻塞和非阻塞都有：<strong>拉起一个新线程</strong>（非阻塞），在主线程<code>.get()</code>（阻塞）。整个流程见下图：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202404031544071.jpeg" alt="promise" style="zoom: 50%;" />

<p>message pass的编程范式，先来思考一下有哪几种编写方法：</p>
<ul>
<li>利用条件变量。在任务线程完成时调用<code>notify_one()</code>，在主函数中调用<code>wait()</code>；</li>
<li>利用flag（原子类型）。在任务完成时修改flag，在主线程中阻塞，不断轮询flag直到成功；</li>
</ul>
<p>上面第一种上锁会带来一定开销，好处是适合长时间阻塞，第二种适合短时间阻塞。</p>
<p>那么c++11 future采用哪一种呢？答案是第二种，future内定义了一个原子对象，主线程通过自旋锁不断轮询，此外会进行<code>sys_futex</code>系统调用。futex是linux非常经典的同步机制，锁冲突时在用户态利用自旋锁，而需要挂起等待时到内核态进行睡眠与唤醒。</p>
<p><strong>实用案例</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">emplace_back</span>(<span class="number">1</span>);</span><br><span class="line">v.<span class="built_in">emplace_back</span>(<span class="number">2</span>);</span><br><span class="line">v.<span class="built_in">emplace_back</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">auto</span> f1 = [](std::vector&lt;<span class="type">int</span>&gt; &amp;v,</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> left, <span class="type">unsigned</span> <span class="type">int</span> right) &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> acm = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = left; i &lt; right; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        acm += v[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> acm;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> t1 = std::<span class="built_in">async</span>(f1, std::<span class="built_in">ref</span>(v),<span class="number">0</span>, v.<span class="built_in">size</span>() );</span><br><span class="line"><span class="comment">//You can do other things here!</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> acm1 = t<span class="number">1.</span><span class="built_in">get</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;acm1: &quot;</span> &lt;&lt; acm1 &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//输出: acm1: 6</span></span><br></pre></td></tr></table></figure>

<ol>
<li>tasks使用<code>std::async</code>创建</li>
<li><code>std::async</code>的返回值是一个叫<code>std::future</code>的类型。别被他的名字唬到，他的意思是t1和t2的值会在未来被真正的赋值。我们通过调用<code>t1.get()</code>来获得他的真正的返回值。</li>
<li>如果<code>future</code>的返回值还没有准备好（任务还没有计算完成），那么调用get()的主线程会被卡住，直到准备好了返回值（和join()的行为一样）。</li>
<li>注意，我们传递给std::async的函数（实际上是lambda表达式）是有返回值的，这个返回值用过一个叫做<code>std::promise</code>的类型来传递。大多数情况下你不需要了解任何<code>promise</code>的细节，C++在幕后可以处理好这些事情。</li>
<li>默认的情况下，tasks也会在创建之后立刻运行（有办法来修改这个行为，但是本文没有涉及）。</li>
</ol>
<p>std::async也同样可以使用</p>
<ul>
<li>函数指针</li>
<li>伪函数</li>
<li>lambda表达式</li>
</ul>
<h2 id="future"><a href="#future" class="headerlink" title="future"></a>future</h2><p>future类不支持拷贝构造,支持移动语义,C++提供的另一个类<code>shared_future</code>支持拷贝,他可用于同时向多个线程发信,允许多个线程等候同一共享状态</p>
<p><code>std::future</code>提供了一个重要方法就是<code>.get()</code>，这将阻塞主线程，直到future就绪。注意：<code>.get()</code>方法<strong>只能调用一次</strong>。</p>
<p>可以通过下面三个方式来获得<code>std::future</code>。</p>
<ul>
<li><code>std::promise</code>的get_future函数</li>
<li><code>std::packaged_task</code>的get_future函数</li>
<li><code>std::async</code> 函数</li>
</ul>
<h3 id="future成员函数"><a href="#future成员函数" class="headerlink" title="future成员函数"></a>future成员函数</h3><ul>
<li><p>get  返回回调函数返回的结果</p>
</li>
<li><p>wait  等待结果变得可用</p>
</li>
<li><p>wait_for   等待结果，如果在指定的超时间隔后仍然无法得到结果，则返回状态</p>
<p>此成员函数如果超时时间间隔设置为0相当于<strong>非阻塞</strong>,直接取状态</p>
</li>
<li><p>wait_until   等待结果，如果在已经到达指定的时间点时仍然无法得到结果，则返回状态</p>
</li>
<li><p>valid 检查*this是否拥有共享状态(非堵塞)</p>
</li>
<li><p>share  从*this转移共享状态给shared_future并返回它(非堵塞)</p>
</li>
</ul>
<p>状态返回有如下:</p>
<ul>
<li>future_status::ready   异步操作已经完成；</li>
<li>future_status::timeout  异步操作超时。</li>
<li>future_status::deferred   异步操作还没有开始；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">std::future&lt;<span class="type">int</span>&gt; future = std::<span class="built_in">async</span>(std::launch::async, []()&#123;</span><br><span class="line">  std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">3</span>s);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;waiting...\n&quot;</span>;</span><br><span class="line">std::future_status status;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span>(status = future.<span class="built_in">wait_for</span>(<span class="number">1</span>s); status) &#123;</span><br><span class="line">    <span class="keyword">case</span> std::future_status::deferred: std::cout &lt;&lt; <span class="string">&quot;deferred\n&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> std::future_status::timeout: std::cout &lt;&lt; <span class="string">&quot;timeout\n&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> std::future_status::ready: std::cout &lt;&lt; <span class="string">&quot;ready!\n&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (status != std::future_status::ready);</span><br></pre></td></tr></table></figure>

<h3 id="future的源码实现"><a href="#future的源码实现" class="headerlink" title="future的源码实现"></a>future的源码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只截取上半段</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Rp</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_LIBCPP_TEMPLATE_VIS</span> _LIBCPP_AVAILABILITY_FUTURE future</span><br><span class="line">&#123;</span><br><span class="line">    __assoc_state&lt;_Rp&gt;* __state_;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">future</span><span class="params">(__assoc_state&lt;_Rp&gt;* __state)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">promise</span>;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">shared_future</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_R1</span>, <span class="keyword">class</span> <span class="title class_">_Fp</span>&gt;</span><br><span class="line">        <span class="keyword">friend</span> future&lt;_R1&gt; __make_deferred_assoc_state(_Fp&amp;&amp; __f);</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_R1</span>, <span class="keyword">class</span> <span class="title class_">_Fp</span>&gt;</span><br><span class="line">        <span class="keyword">friend</span> future&lt;_R1&gt; __make_async_assoc_state(_Fp&amp;&amp; __f);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">_LIBCPP_INLINE_VISIBILITY</span></span><br><span class="line"><span class="function">    <span class="title">future</span><span class="params">()</span> _NOEXCEPT : __state_(nullptr) &#123;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>promis的数据成员只有一个<code>__assoc_state&lt;_RP&gt;* __state_</code>,该指针指向的是一个状态,该状态对象对应的是promise和future之间的通道.<code>_Rp</code>为一步操作返回值的类型(泛型),即该状态对象内部保存并传递异步调用的返回值</p>
<h4 id="future构造源码"><a href="#future构造源码" class="headerlink" title="future构造源码"></a>future构造源码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Rp</span>&gt;</span><br><span class="line">future&lt;_Rp&gt;::<span class="built_in">future</span>(__assoc_state&lt;_Rp&gt;* __state)</span><br><span class="line">    : __state_(__state)</span><br><span class="line">&#123;</span><br><span class="line">    __state_-&gt;__attach_future();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该构造函数接受一个关联状态对象的地址信息，然后使用该地址信息来初始化内部的<code>__state_</code>变量，完成当前<code>future</code>到关联状态对象的链接,调用关联状态对象的<code>__attach_future</code>成员函数，完成<code>future</code>和关联状态对象的链接（<code>attach</code>）</p>
<h4 id="get函数源码"><a href="#get函数源码" class="headerlink" title="get函数源码"></a>get函数源码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Rp</span>&gt;</span><br><span class="line">_Rp</span><br><span class="line">future&lt;_Rp&gt;::<span class="built_in">get</span>()</span><br><span class="line">&#123;</span><br><span class="line">    unique_ptr&lt;__shared_count, __release_shared_count&gt; __(__state_);</span><br><span class="line">    __assoc_state&lt;_Rp&gt;* __s = __state_;</span><br><span class="line">    __state_ = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> __s-&gt;<span class="built_in">move</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>创建一个名为<code>__</code>的<code>unique_ptr</code>的临时对象，并且将<code>__state_</code>托管给该对象，该对象是一个临时对象，将会在<code>get</code>函数运行结束的时候进行释放，当该对象释放的时候，将会对通过<code>__release_shared_count</code>函数来对<code>__state_</code>指向的关联状态对象进行相关的处理</li>
<li>将当前<code>__state_</code>的值赋值给临时变量<code>__s</code>，将<code>__state_</code>进行置空，完成<code>future</code>对状态对象的链接的断开</li>
<li>通过调用<code>__s-&gt;move()</code>来完成对关联状态中异步调用结果的获取，获取完成之后将该值作为<code>get</code>函数的返回值进行返回。同时<code>__s-&gt;move()</code>函数不仅仅是单纯的获取异步调用结果，同时还会判断是否有异步调用的值，如果异步调用没有完成，则会阻塞在<code>move</code>函数中，等待异步调用完成  <a href="#move%E5%87%BD%E6%95%B0%E6%BA%90%E7%A0%81">move的源码参考此处</a>)</li>
</ol>
<blockquote>
<p>上面我们看到在调用<code>get</code>方法之后，<code>future</code>断开了和关联状态对象的链接，这说明**<code>future</code>对象只能调用一次<code>get</code>方法来获取**，如果多次调用，其内部<code>__state_</code>将为空指针，则会因为对空指针调用<code>move</code>方法，造成未定义行为</p>
</blockquote>
<h4 id="future析构源码"><a href="#future析构源码" class="headerlink" title="future析构源码"></a>future析构源码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Rp</span>&gt;</span><br><span class="line">future&lt;_Rp&gt;::~<span class="built_in">future</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (__state_)</span><br><span class="line">        __state_-&gt;__release_shared();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果当前<code>future</code>有链接状态关联对象，则调用其<code>__release_shared</code>成员函数，从而对其内部引用计数进行递减，当其内部引用计数递减至<code>-1</code>的时候，将完成自身占用资源的释放</p>
<h2 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h2><h3 id="成员函数-1"><a href="#成员函数-1" class="headerlink" title="成员函数"></a>成员函数</h3><ul>
<li>get_future   返回与承诺的结果关联的<a href="#future">future</a></li>
<li>set_value    设置结果为指定值</li>
<li>set_value_at_thread_exit   设置结果为指定值,同时仅在线程退出时(销毁所有拥有线程区域存储期的变量后)分发提醒</li>
<li>set_exception   设置结果为指示异常</li>
<li>set_exception_at_thread_exit  设置结果为指示异常,同时仅在线程退出时(销毁所有拥有线程区域存储期的变量后)分发提醒</li>
</ul>
<h3 id="promise的源码实现"><a href="#promise的源码实现" class="headerlink" title="promise的源码实现"></a>promise的源码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只截取了上半部分</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Rp</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_LIBCPP_TEMPLATE_VIS</span> _LIBCPP_AVAILABILITY_FUTURE promise</span><br><span class="line">&#123;</span><br><span class="line">    __assoc_state&lt;_Rp&gt;* __state_;</span><br><span class="line"></span><br><span class="line">    <span class="function">_LIBCPP_INLINE_VISIBILITY</span></span><br><span class="line"><span class="function">    <span class="keyword">explicit</span> <span class="title">promise</span><span class="params">(<span class="type">nullptr_t</span>)</span> _NOEXCEPT : __state_(nullptr) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">packaged_task</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">promise</span>();</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Alloc</span>&gt;</span><br><span class="line">        <span class="built_in">promise</span>(<span class="type">allocator_arg_t</span>, <span class="type">const</span> _Alloc&amp; __a);</span><br></pre></td></tr></table></figure>

<p>与<code>future</code>一致,promis的数据成员只有一个<code>__assoc_state&lt;_RP&gt;* __state_</code>,该指针指向的是一个状态,该状态对象对应的是promise和future之间的通道.<code>_Rp</code>为一步操作返回值的类型(泛型),即该状态对象内部保存并传递异步调用的返回值</p>
<h4 id="promise默认构造函数"><a href="#promise默认构造函数" class="headerlink" title="promise默认构造函数"></a>promise默认构造函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Rp</span>&gt;</span><br><span class="line">promise&lt;_Rp&gt;::<span class="built_in">promise</span>()</span><br><span class="line">    : __state_(<span class="keyword">new</span> __assoc_state&lt;_Rp&gt;)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只做了:通过<code>new</code>操作符构建了一个关联状态对象<code>__assoc_state&lt;_Rp&gt;</code>，用这个关联对象的地址信息初始化内部的指针变量<code>__state_</code></p>
<h4 id="get-future的源码实现"><a href="#get-future的源码实现" class="headerlink" title="get_future的源码实现"></a>get_future的源码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Rp</span>&gt;</span><br><span class="line">future&lt;_Rp&gt;</span><br><span class="line">promise&lt;_Rp&gt;::<span class="built_in">get_future</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (__state_ == <span class="literal">nullptr</span>)</span><br><span class="line">        __throw_future_error(future_errc::no_state);<span class="comment">//抛出异常</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">future</span>&lt;_Rp&gt;(__state_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果关联了关联状态对象，则通过该关联对象的地址信息来构建<code>future</code>对象，返回一个链接该关联状态对象的<code>future</code>对象实例</p>
<h4 id="set-value的源码实现"><a href="#set-value的源码实现" class="headerlink" title="set_value的源码实现"></a>set_value的源码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两个版本只是分别针对左值和右值</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Rp</span>&gt;</span><br><span class="line"><span class="type">void</span></span><br><span class="line">promise&lt;_Rp&gt;::<span class="built_in">set_value</span>(<span class="type">const</span> _Rp&amp; __r)<span class="comment">//左值版本</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (__state_ == <span class="literal">nullptr</span>)</span><br><span class="line">        __throw_future_error(future_errc::no_state);</span><br><span class="line">    __state_-&gt;<span class="built_in">set_value</span>(__r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Rp</span>&gt;</span><br><span class="line"><span class="type">void</span></span><br><span class="line">promise&lt;_Rp&gt;::<span class="built_in">set_value</span>(_Rp&amp;&amp; __r)<span class="comment">//右值版本</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (__state_ == <span class="literal">nullptr</span>)</span><br><span class="line">        __throw_future_error(future_errc::no_state);</span><br><span class="line">    __state_-&gt;<span class="built_in">set_value</span>(_VSTD::<span class="built_in">move</span>(__r));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果关联了关联对象实例，则调用关联对象实例的<code>set_value</code>成员方法，将<code>__r</code>实参传入，完成将异步调用结果写入关联状态对象中（即所链接的通道中）</p>
<h4 id="promise析构源码"><a href="#promise析构源码" class="headerlink" title="promise析构源码"></a>promise析构源码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Rp</span>&gt;</span><br><span class="line">promise&lt;_Rp&gt;::~<span class="built_in">promise</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (__state_)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!__state_-&gt;__has_value() &amp;&amp; __state_-&gt;<span class="built_in">use_count</span>() &gt; <span class="number">1</span>)</span><br><span class="line">            __state_-&gt;<span class="built_in">set_exception</span>(<span class="built_in">make_exception_ptr</span>(</span><br><span class="line">                      <span class="built_in">future_error</span>(<span class="built_in">make_error_code</span>(future_errc::broken_promise))</span><br><span class="line">                                                      ));</span><br><span class="line">        __state_-&gt;__release_shared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>__state_-&gt;has_value()</code>用来判断当前关联状态对象中是否存有异步调用结果信息（即是否被设置值或者异常信息，异常信息后面讨论）；<code>__state_-&gt;use_count()&gt;1</code>用来判断当前关联状态对象中是否有被其他对象关联（在此处为是否有其他<code>future</code>对象关联）；此处<code>if</code>内的整体条件判断是用来判断当前关联状态对象中在是否被其他<code>future</code>对象所关联的情况下，没有被设定异步调用的结果的相关信息，如果条件成立执行代码行<code>7~9</code>的代码，这两行代码是抛出一个<code>broken_promise</code>的异常，用来表征当前<code>promise</code>是一个坏的（<code>broken</code>）<code>promise</code>对象（没有兑现承诺）</li>
<li>调用<code>__state_-&gt;__release_shared()</code>来释放对关联状态对象的链接，其背后的逻辑类似于<code>shared_ptr</code>中的引用计数，当所有链接关联状态对象的对象都释放链接的时候，该关联状态对象会进行自身资源的释放，占用内存的归还，这部分我们会在后面进行展开讨论</li>
</ul>
<h2 id="内部状态源码"><a href="#内部状态源码" class="headerlink" title="内部状态源码"></a>内部状态源码</h2><h3 id="关联状态对象的代码实现"><a href="#关联状态对象的代码实现" class="headerlink" title="关联状态对象的代码实现"></a>关联状态对象的代码实现</h3><p><code>clang</code>版本的关联对象的实现是通过<code>3</code>层继承来实现的，每层继承都对应了一个功能实现的职责，按照继承树的层级从上至下，这<code>3</code>层继承分别如下：</p>
<ol>
<li><code>__shared_count</code>：引用计数类，该类用来保存引用计数信息，通过该类内部的引用计数信息来实现自身对象生命周期的管理。用来跟踪链接到自身的<code>promise</code>和<code>future</code>对象的数量，当没有任何对象链接自身的时候，进行自身资源的释放</li>
<li><code>__assoc_sub_state</code>：负责保存管理当前关联状态对象的状态（<code>constructed</code>&#x2F;<code>attached</code>&#x2F;<code>ready</code>&#x2F;<code>deferred</code>，随后展开讨论），进行线程之间的同步</li>
<li><code>__assoc_state</code>：负责保存异步操作返回值，并且做最终的封装提供最终的接口给<code>future</code>和<code>promise</code>来使用</li>
</ol>
<h4 id="assoc-state"><a href="#assoc-state" class="headerlink" title="__assoc_state"></a>__assoc_state</h4><p>只有一个成员<code>__value_</code>,用于<strong>存取异步操作返回值</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//截取上半</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Rp</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_LIBCPP_AVAILABILITY_FUTURE</span> _LIBCPP_HIDDEN __assoc_state</span><br><span class="line">    : <span class="keyword">public</span> __assoc_sub_state</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> __assoc_sub_state base;</span><br><span class="line">_LIBCPP_SUPPRESS_DEPRECATED_PUSH</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> aligned_storage&lt;<span class="built_in">sizeof</span>(_Rp), alignment_of&lt;_Rp&gt;::value&gt;::type _Up;</span><br><span class="line">_LIBCPP_SUPPRESS_DEPRECATED_POP</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    _Up __value_;</span><br></pre></td></tr></table></figure>

<p>通过返回值类型<code>_Rp</code>构建了一个对应的内存对齐的数据类型<code>_Up</code>,理解上可以认为<code>__value_</code>的类型就相当于是异步操作返回值的类型</p>
<h5 id="set-value源码"><a href="#set-value源码" class="headerlink" title="set_value源码"></a>set_value源码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Rp</span>&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Arg</span>&gt;</span><br><span class="line">_LIBCPP_AVAILABILITY_FUTURE</span><br><span class="line"><span class="type">void</span></span><br><span class="line">__assoc_state&lt;_Rp&gt;::<span class="built_in">set_value</span>(_Arg&amp;&amp; __arg)</span><br><span class="line">&#123;</span><br><span class="line">    unique_lock&lt;mutex&gt; __lk(<span class="keyword">this</span>-&gt;__mut_);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;__has_value())</span><br><span class="line">        __throw_future_error(future_errc::promise_already_satisfied);</span><br><span class="line">    ::<span class="keyword">new</span> ((<span class="type">void</span>*)&amp;__value_) _Rp(_VSTD::forward&lt;_Arg&gt;(__arg));</span><br><span class="line">    <span class="keyword">this</span>-&gt;__state_ |= base::__constructed | base::ready;</span><br><span class="line">    __cv_.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数的形参<code>__arg</code>是用来接受待设置到关联状态对象内部的异步调用结果的值，该函数是一个万能引用，从而根据传入的实参来自动的进行判断传入的实参是以左值引用的方式传入的还是以右值的方式传入的。从而通过<code>std::forward</code>进行完美转发，从而决定是以移动的方式还是拷贝的方式进行实参的接收</p>
<ul>
<li>实例化一个局部的<code>unique_lock</code>类型<code>__lk</code>临时对象，通过<code>RAII</code>技术来持有内部的<code>__mut_</code>互斥锁，当该临时对象离开作用域的时候，即函数结束的时候，会在析构的时候对互斥锁<code>__mut_</code>进行释放。该<code>__mut_</code>锁是用来保存内部数据在并发操作的时的多线程并发安全性的。比如异步操作创建线程和异步操作执行线程同时分别通过<code>future</code>和<code>promise</code>来从通道中读取和写入值的时候</li>
<li>通过调用成员函数<code>_has_value</code>来判断当前关联状态对象是否已经被设定值了，即设定了异步调用结果信息，如果已经设定了，此时执行代码，抛出<code>promise already satisfied</code>异常，用来告诉调用方该<code>promise</code>早已经被兑现了</li>
<li>通过<code>placement new</code>操作符，在<code>__value_</code>上以函数形参<code>__arg</code>的值，构建异步调用返回值对象。这里之所以采用<code>placement new</code>是因为用来保存返回值的内存早就已经存在，即内部的<code>__value_</code>成员变量，这行代码要做的只是在这个内存上进行对象的构建，而不需要通过<code>new</code>那样先申请内存，然后在申请的内存上进行对象的构建</li>
<li>设置当前关联对象的状态为<code>constructed</code>，表征当前关联状态对象内部已经构建了异步调用的结果的值；以及设置当前关联对象的状态为<code>ready</code>，用来表征当前关联状态对象已经处于就绪（<code>ready</code>）状态，<code>future</code>对象可以通过<code>get</code>立刻获取到异步调用的结果信息</li>
<li>调用内部的<code>__cv_</code>条件变量（<code>conditional variable</code>），用来通知因为在关联状态对象没有<code>ready</code>的时候因为调用<code>future</code>对象的<code>get</code>方法而阻塞的线程，唤醒这些线程继续获取异步调用的结果信息</li>
</ul>
<h5 id="move函数源码"><a href="#move函数源码" class="headerlink" title="move函数源码"></a>move函数源码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Rp</span>&gt;</span><br><span class="line">_Rp</span><br><span class="line">__assoc_state&lt;_Rp&gt;::<span class="built_in">move</span>()</span><br><span class="line">&#123;</span><br><span class="line">    unique_lock&lt;mutex&gt; __lk(<span class="keyword">this</span>-&gt;__mut_);</span><br><span class="line">    <span class="keyword">this</span>-&gt;__sub_wait(__lk);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;__exception_ != <span class="literal">nullptr</span>)</span><br><span class="line">        std::<span class="built_in">rethrow_exception</span>(<span class="keyword">this</span>-&gt;__exception_);</span><br><span class="line">    <span class="keyword">return</span> _VSTD::<span class="built_in">move</span>(*<span class="built_in">reinterpret_cast</span>&lt;_Rp*&gt;(&amp;__value_));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>声明一个<code>unique_lock</code>类型的临时对象<code>__lk</code>来对内部的<code>__mut_</code>互斥量进行上锁，从而对关联状态对象内部的数据进行并发保护</li>
<li>通过调用<code>__sub_wait</code>成员函数（该成员函数是从基类继承来的），该成员函数内部对关联状态对象的值的状态进行判断，如果处于就绪状态，即已经可以允许<code>future</code>来获取值的状态，则会接着向下执行。如果没有处于就绪状态，则会在此处阻塞知道状态就绪，这就是<code>wait</code>的含义</li>
<li>判断关联状态内部是否保存异步调用执行过程中抛出的异常信息，进行该异常的重新抛出，<strong>完成异常从异步调用线程到异步调用创建方线程的传递</strong>。此处为异常安全的设计需求，<a href="#future%E5%92%8Cpromise%E4%B9%8B%E9%97%B4%E7%9A%84%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8">后续展开讨论</a></li>
<li>以移动的方式返回关联状态对象内部的异步调用结果</li>
</ul>
<p>该函数在<a href="#get%E5%87%BD%E6%95%B0%E6%BA%90%E7%A0%81">future::get</a>中被引用</p>
<h5 id="on-zero-shared源码"><a href="#on-zero-shared源码" class="headerlink" title="__on_zero_shared源码"></a>__on_zero_shared源码</h5><p>该关联对象还有一个函数<code>__on_zero_shared</code>，该函数是对其基类<code>__shared_count</code>的同名虚函数的实现（重写）。该函数在内部引用计数递减至<code>-1</code>的时候，即没有任何<code>promise</code>或者<code>future</code>对象链接该关联状态对象的时候，调用该函数，完成对自身资源的释放</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Rp</span>&gt;</span><br><span class="line"><span class="type">void</span></span><br><span class="line">__assoc_state&lt;_Rp&gt;::__on_zero_shared() _NOEXCEPT</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;__state_ &amp; base::__constructed)</span><br><span class="line">        <span class="built_in">reinterpret_cast</span>&lt;_Rp*&gt;(&amp;__value_)-&gt;~_Rp();</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>判断当前关联对象内部是否构建了保存异步调用对象返回值的变量，如果构建了调用其析构函数。注意这里是调用析构函数，并没有释放内存，因为该值是保存在关联状态对象内部成员变量中，会随着状态对象自身的释放而释放</li>
<li>对自身占用的资源进行释放</li>
</ul>
<h3 id="assoc-sub-state"><a href="#assoc-sub-state" class="headerlink" title="__assoc_sub_state"></a>__assoc_sub_state</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只截取上半截</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_LIBCPP_TYPE_VIS</span> _LIBCPP_AVAILABILITY_FUTURE __assoc_sub_state</span><br><span class="line">    : <span class="keyword">public</span> __shared_count</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    exception_ptr __exception_;</span><br><span class="line">    <span class="keyword">mutable</span> mutex __mut_;</span><br><span class="line">    <span class="keyword">mutable</span> condition_variable __cv_;</span><br><span class="line">    <span class="type">unsigned</span> __state_;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> __on_zero_shared() _NOEXCEPT <span class="keyword">override</span>;</span><br><span class="line">    <span class="type">void</span> __sub_wait(unique_lock&lt;mutex&gt;&amp; __lk);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span></span><br><span class="line">    &#123;</span><br><span class="line">        __constructed = <span class="number">1</span>,</span><br><span class="line">        __future_attached = <span class="number">2</span>,</span><br><span class="line">        ready = <span class="number">4</span>,</span><br><span class="line">        deferred = <span class="number">8</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>__exception_</code>用来保存异步调用时抛出的异常信息，该异常信息会在异步操作创建方线程调用<a href="#get%E5%87%BD%E6%95%B0%E6%BA%90%E7%A0%81">future::get</a>方法的时候，重新在该线程抛出，从而完成异常信息在异步调用线程和其创建线程之间传递</p>
</li>
<li><p><code>__mut_</code>互斥量，用来实现关联状态对象内部数据的线程安全，保证并发安全</p>
</li>
<li><p><code>__cv_</code>条件变量，用来实现异步调用线程和异步调用创建方线程之间的同步</p>
</li>
<li><p><code>__state_</code>用来记录关联状态对象当前的状态，下面我们先展开说一下这个状态</p>
<p><code>__state_</code>是用来被记录当前关联状态对象的状态的，其是按照位来存储的，初始状态下<code>__state_</code>初始值为<code>0</code>，代表所有状态位都为&#96;false</p>
<ul>
<li><code>__constructed</code>：对应<code>bit0</code>，是用来表示内部已经<strong>构建</strong>保存了异步调用操作的结果值</li>
<li><code>__future_attached</code>：对应<code>bit1</code>，是用来表示当前关联状态对象已经被<code>future</code>对象所链接（<code>attached</code>）</li>
<li><code>ready</code>：用来表示当前关联状态对象处于就绪（<code>ready</code>）状态，链接该对象的<code>future</code>对象可以通过调用<code>get</code>方法来立刻获取到该异步调用的结果相关信息（获取到异步调用的返回值或者异步调用时发生的异常）</li>
<li><code>deferred</code>：用来表示这是一个推迟执行的“异步调用”，这块后边章节会单独介绍，这种推迟调用，是当前不即可求值也不会在其他线程进行并发求值，而是在使用<code>future</code>进行<code>get</code>的时候，在<code>get</code>的时候，在<code>get</code>调用的线程进行同步求值</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/672327290">上述源码转载于此,更多详解参考此处</a></p>
<h2 id="async"><a href="#async" class="headerlink" title="async"></a>async</h2><p> 是一个模板函数，接收一个回调（回调函数或可调用对象）作为参数，并异步执行。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Fn</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line">future&lt;<span class="keyword">typename</span> result_of&lt;<span class="built_in">Fn</span>(Args...)&gt;::type&gt; <span class="built_in">async</span> (launch policy, Fn&amp;&amp; fn, Args&amp;&amp;... args);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>launch policy</code> :其控制 <code>syd::async</code> 的异步行为。有三种 launch policy 可选：<ul>
<li><code>std::launch::async</code> ：保证行为是异步的 - 强制这个异步任务在 <strong>新线程</strong>上执行，在调用<code>std::async()</code>函数的时候就开始创建线程</li>
<li><code>std::launch::deferred</code> ：行为是非异步的 - 会在其他线程调用 future 的 <code>get()</code> 时被调用传入的回调函数.如果<code>wait()</code>和<code>get()</code><strong>没有调用</strong>，则不会创建新线程，也不执行函数</li>
<li><code>std::launch::async | std::launch::deferred</code> ：程序会根据系统情况自动决定是同步还是异步，开发者无法手动控制。(不指定的情况下默认这种)</li>
</ul>
</li>
<li><code>fn</code> :回调函数可以是函数指针、函数对象和 lambda 表达式</li>
<li><code>args</code>:回调函数的参数</li>
</ul>
<blockquote>
<p><code>std::async</code>比<code>std::thread</code>更安全！<code>std::thread</code>当创建太多线程时，会导致创建失败，进而程序崩溃。</p>
</blockquote>
<p>async会做下面三件事:</p>
<ol>
<li>自动创建一个新线程（或者是从其内部的线程池中拿一个线程）和一个 <code>promise</code> 对象</li>
<li>向新线程中的函数传入 <code>std::promise</code> 对象，并返回与之关联的 <code>std::future</code> 对象</li>
<li>在函数运行结束后，设置 <code>std::promise</code> 对象的值，我们即可通过 <code>std::future</code> 获取返回值</li>
</ol>
<blockquote>
<p><strong>async的get函数会返回回调函数中return的值</strong></p>
</blockquote>
<p><strong>缺点</strong></p>
<ol>
<li>局限性挺大,对服务器开发来说用得到的机会并不多</li>
<li>结果单一</li>
</ol>
<h3 id="不使用async实现类似效果案例"><a href="#不使用async实现类似效果案例" class="headerlink" title="不使用async实现类似效果案例"></a>不使用async实现类似效果案例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个promise对象实例</span></span><br><span class="line">promise&lt;<span class="type">int</span>&gt; thePromise;</span><br><span class="line"><span class="comment">//从promise对象实例中获取对应的future对象实例</span></span><br><span class="line">future&lt;<span class="type">int</span>&gt; theFuture = thePromise.<span class="built_in">get_future</span>();<span class="comment">//建立通道</span></span><br><span class="line"><span class="comment">//构建测试对象</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; test_data = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="comment">//创建一个任务,该任务为对容器内的所有元素进行求和,求和完成之后通过promise来返回结果</span></span><br><span class="line"><span class="keyword">auto</span> sum_of_data = [](<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; data,promise&lt;<span class="type">int</span>&gt; prom)&#123;</span><br><span class="line">  <span class="type">int</span> sum = <span class="built_in">accumulate</span>(data.<span class="built_in">cbegin</span>(),data.<span class="built_in">cend</span>(),<span class="number">0</span>);</span><br><span class="line">  this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">1000</span>));<span class="comment">//休眠1000毫秒</span></span><br><span class="line">  prom.<span class="built_in">set_value</span>(sum);<span class="comment">//兑现承诺,将结果写入通道中</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//将这个任务交给一个线程,进行异步执行</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;create thread&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="comment">//将这个任务交给一个线程,进行异步操作</span></span><br><span class="line"><span class="function">thread <span class="title">work_thread</span><span class="params">(sum_of_data,test_data,move(thePromise))</span></span>;</span><br><span class="line"><span class="comment">//通过future的get方法来获取异步调用执行结果</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;result is &quot;</span>&lt;&lt;theFuture.<span class="built_in">get</span>()&lt;&lt;endl;</span><br><span class="line"><span class="comment">//等待work_thread退出销毁完成</span></span><br><span class="line">work_thread.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure>

<p>上述创建了一个<code>promise</code>对象，并且从该对象实例中获取到了用于获取承诺兑现的值的<code>std::future</code>对象实例，这样就构建了一个异步调用创建方（发起方）和异步调用执行方之间用于传递异步调用结果的<strong>数据通道</strong></p>
<p>在异步调用任务中，完成计算之后，通过<code>std::promise::set_value</code>来进行<strong>承诺兑现</strong>，将异步调用的结果写入通道中。异步调用创建方通过<code>std::future</code>中的<code>get</code>方法来获取异步调用的结果</p>
<p><strong>由此可见,<code>async</code> 可以理解为是 future 和 thread 的高级封装</strong></p>
<h3 id="回调参数"><a href="#回调参数" class="headerlink" title="回调参数"></a>回调参数</h3><p>与<a href="#%E7%BA%BF%E7%A8%8B%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0">thread定义支持的回调参数</a>是一模一样的</p>
<ul>
<li><a href="#%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%9B%9E%E8%B0%83%E5%8F%82%E6%95%B0%E6%A1%88%E4%BE%8B">函数作为回调参数</a></li>
<li><a href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%9B%9E%E8%B0%83%E5%8F%82%E6%95%B0%E6%A1%88%E4%BE%8B">成员函数作为回调参数</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E5%9B%9E%E8%B0%83%E5%8F%82%E6%95%B0%E6%A1%88%E4%BE%8B">函数对象作为回调参数</a></li>
<li><a href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BD%9C%E4%B8%BA%E5%9B%9E%E8%B0%83%E5%8F%82%E6%95%B0%E6%A1%88%E4%BE%8B">Lambda表达式作为回调参数</a></li>
</ul>
<h4 id="函数作为回调参数案例"><a href="#函数作为回调参数案例" class="headerlink" title="函数作为回调参数案例"></a>函数作为回调参数案例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line"><span class="function">std::string <span class="title">fetchDataFromDB</span><span class="params">(std::string recvdData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 模拟耗时的数据库查询操作，让该函数运行五秒</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;DB_&quot;</span> + recvdData;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::string <span class="title">fetchDataFromFile</span><span class="params">(std::string recvdData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 模拟耗时的本地数据读取操作，让该函数运行五秒</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;File_&quot;</span> + recvdData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取开始时间</span></span><br><span class="line">    system_clock::time_point start = system_clock::<span class="built_in">now</span>();</span><br><span class="line">    std::future&lt;std::string&gt; resultFromDB = std::<span class="built_in">async</span>(std::launch::async, fetchDataFromDB, <span class="string">&quot;Data&quot;</span>);</span><br><span class="line">    <span class="comment">// 从本地文件获取数据</span></span><br><span class="line">    std::string fileData = <span class="built_in">fetchDataFromFile</span>(<span class="string">&quot;Data&quot;</span>);</span><br><span class="line">    <span class="comment">// 从数据库获取数据</span></span><br><span class="line">    <span class="comment">// 代码会在此处阻塞，直到 future&lt;std::string&gt; 对象中的数据就绪</span></span><br><span class="line">    std::string dbData = resultFromDB.<span class="built_in">get</span>();</span><br><span class="line">    <span class="comment">// 获取结束时间</span></span><br><span class="line">    <span class="keyword">auto</span> end = system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">auto</span> diff = duration_cast &lt; std::chrono::seconds &gt; (end - start).<span class="built_in">count</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;总耗时 = &quot;</span> &lt;&lt; diff &lt;&lt; <span class="string">&quot; 秒&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 混合数据</span></span><br><span class="line">    std::string data = dbData + <span class="string">&quot; :: &quot;</span> + fileData;</span><br><span class="line">    <span class="comment">// 打印混合数据</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Data = &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出为:</span></span><br><span class="line"><span class="comment">//总耗时 = 5 秒</span></span><br><span class="line"><span class="comment">//Data = DB_Data :: File_Data</span></span><br></pre></td></tr></table></figure>

<p>两个5秒操作使用并发后只需5秒解决</p>
<h4 id="成员函数作为回调参数案例"><a href="#成员函数作为回调参数案例" class="headerlink" title="成员函数作为回调参数案例"></a>成员函数作为回调参数案例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DataFetcher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">string <span class="title">test</span><span class="params">(<span class="type">int</span> no)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;succeed!&quot;</span>&lt;&lt;endl;</span><br><span class="line">        nn=<span class="number">10</span>;</span><br><span class="line">        cout&lt;&lt;no&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;succeed2&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> nn=<span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line">DataFetcher d;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;d.nn = &quot;</span>&lt;&lt;d.nn&lt;&lt;endl;</span><br><span class="line"><span class="keyword">auto</span> res = <span class="built_in">async</span>(&amp;DataFetcher::test,&amp;d,<span class="number">1000</span>);<span class="comment">//d前面是否带&amp;或者ref包裹,决定了是否会以引用传递d的对象,在此案例中决定了nn是否可以真正被改变</span></span><br><span class="line">cout&lt;&lt;res.<span class="built_in">get</span>()&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;d.nn = &quot;</span>&lt;&lt;d.nn&lt;&lt;endl;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出:</span></span><br><span class="line"><span class="comment">d.nn = 3</span></span><br><span class="line"><span class="comment">succeed!</span></span><br><span class="line"><span class="comment">1000</span></span><br><span class="line"><span class="comment">succeed2</span></span><br><span class="line"><span class="comment">d.nn = 10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="函数对象作为回调参数案例"><a href="#函数对象作为回调参数案例" class="headerlink" title="函数对象作为回调参数案例"></a>函数对象作为回调参数案例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DataFetcher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::string <span class="title">operator</span><span class="params">()</span><span class="params">(std::string recvdData)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 模拟耗时操作，需要运行五秒</span></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span> (<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">        <span class="comment">// 做一些获取数据相关的操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;File_&quot;</span> + recvdData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 使用函数对象调用 std::async</span></span><br><span class="line">std::future&lt;std::string&gt; fileResult = std::<span class="built_in">async</span>(<span class="built_in">DataFetcher</span>(), <span class="string">&quot;Data&quot;</span>);</span><br><span class="line">cout&lt;&lt;fileResult.<span class="built_in">get</span>()&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<h4 id="Lambda表达式作为回调参数案例"><a href="#Lambda表达式作为回调参数案例" class="headerlink" title="Lambda表达式作为回调参数案例"></a>Lambda表达式作为回调参数案例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Lambda 表达式作为回调函数，调用 std::async</span></span><br><span class="line">std::future&lt;std::string&gt; resultFromDB = std::<span class="built_in">async</span>([](std::string recvdData)&#123;</span><br><span class="line">                        std::this_thread::<span class="built_in">sleep_for</span> (<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">                        <span class="comment">// 做一些数据库查询相关的操作</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="string">&quot;DB_&quot;</span> + recvdData;</span><br><span class="line">                    &#125;, <span class="string">&quot;Data&quot;</span>);</span><br><span class="line">cout&lt;&lt;resultFromDB.<span class="built_in">get</span>()&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<h3 id="async的右值析构问题"><a href="#async的右值析构问题" class="headerlink" title="async的右值析构问题"></a>async的右值析构问题</h3><blockquote>
<p>当async函数的返回值不被任何变量接收时，返回值将会被临时对象接收，这个临时对象在当前语句结束时会被销毁。如果该返回值是一个异步任务（比如future或promise），在其析构时可能会导致阻塞。这是因为异步任务通常会在析构时等待其关联的任务完成，以确保资源的正确释放。因此，如果<strong>不及时处理异步任务的返回值，可能会导致程序出现阻塞现象</strong>。为避免这种情况，建议在async函数调用后立即将返回值赋给一个变量，以确保异步任务能够正常执行并完成</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;Test 1 start&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">auto</span> fut1 = std::<span class="built_in">async</span>(std::launch::async, [] &#123; std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">5000</span>)); std::cout &lt;&lt; <span class="string">&quot;work done 1!\n&quot;</span>; </span><br><span class="line">                                               <span class="keyword">return</span> <span class="number">1</span>;&#125;); <span class="comment">// 这一步没有阻塞，因为async的返回的future对象用于move构造了fut1，没有析构</span></span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Work done - implicit join on fut1 associated thread just ended\n\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Test 2 start&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">std::<span class="built_in">async</span>(std::launch::async, [] &#123; std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">5000</span>)); std::cout &lt;&lt; <span class="string">&quot;work done 2!&quot;</span> &lt;&lt; std::endl; &#125;);<span class="comment">// 这一步阻塞了！因为async返回future对象是右值，将要析构，而析构会阻塞</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;This shold show before work done 2!?&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出:</span></span><br><span class="line"><span class="comment">Test 1 start</span></span><br><span class="line"><span class="comment">Work done - implicit join on fut1 associated thread just ended</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Test 2 start</span></span><br><span class="line"><span class="comment">work done 2!</span></span><br><span class="line"><span class="comment">work done 1!</span></span><br><span class="line"><span class="comment">This shold show before work done 2!?</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="future和promise之间的并发安全和线程同步"><a href="#future和promise之间的并发安全和线程同步" class="headerlink" title="future和promise之间的并发安全和线程同步"></a>future和promise之间的并发安全和线程同步</h2><p>其<code>API</code>的内部是通过互斥量对内部状态进行保护，从而实现了线程安全。通过条件变量来实现的线程同步。并且<strong>一个关联状态对象在一个时刻只能被一个<code>future</code>和一个<code>promise</code>所链接</strong>，如果被多个链接则会抛出异常</p>
<p>并且,异步操作创建方只能调用一次<code>future::get</code>来获取异步调用的结果信息，这是因为<a href="#get%E5%87%BD%E6%95%B0%E6%BA%90%E7%A0%81">future::get函数内部</a>，会断开<code>future</code>对象与关联状态对象之间的链接</p>
<blockquote>
<p>值得一提的是,future对象析构时如果没有调用get接口,通常不会阻塞当前进程</p>
<p>仅当满足以下所有条件时,才会阻塞:</p>
<ol>
<li>这个共享状态是通过调用<code>async</code>创建的</li>
<li>共享状态目前没有处于就绪状态(因此在等待他就绪才能释放)</li>
<li>当前对象是最后一个引用该共享状态对象的对象</li>
</ol>
<p>上面说的实际上就是<a href="#async%E7%9A%84%E5%8F%B3%E5%80%BC%E6%9E%90%E6%9E%84%E9%97%AE%E9%A2%98">这里的情况:async的右值析构问题</a></p>
</blockquote>
<h2 id="future和promise之间的异常安全"><a href="#future和promise之间的异常安全" class="headerlink" title="future和promise之间的异常安全"></a>future和promise之间的异常安全</h2><blockquote>
<p>在C++中，每个线程都有自己的调用栈。这意味着，当一个线程抛出一个异常时，这个异常只能在该线程的调用栈中传播。它不能跨线程传播或被其他线程捕获。这也意味着，如果一个线程抛出了一个异常，但没有捕获它，那么只有这个线程会被终止，其他线程会继续执行。</p>
<p>C++11引入了<code>std::future</code>和<code>std::promise</code>，这两个类提供了一种在多线程中传递数据和异常的机制。</p>
<p>当我们使用<code>std::async</code>或<code>std::promise</code>在一个线程中执行一个任务，并返回一个<code>std::future</code>时，如果这个任务抛出了一个异常，这个异常会被捕获并存储在<code>std::future</code>中。然后，当我们在另一个线程中调用<code>std::future::get()</code>时，这个异常会被重新抛出。</p>
<p>这提供了一种在多线程中传递异常的机制，而不是直接终止线程。</p>
</blockquote>
<p><code>promise</code>和<code>future</code>进行异步调用结果信息同步的这个机制，从代码上的设计就是异常安全的。这里面的异常安全设计主要在两个方向：</p>
<ol>
<li>首先相关的<code>API</code>接口和函数实现需要是异常安全的，即软件内部如果出现异常的时候，<strong>函数异常返回的时候不能出现内存泄漏，资源未正确释放等异常情况</strong></li>
<li>其次异步调用的时候，如果产生异常可以通过<code>promise</code>和<code>future</code>以及关联状态对象，<strong>将异常从异步操作执行线程传递到异步操作创建方所在线程中</strong>  原因参考此: <a href="#get%E5%87%BD%E6%95%B0%E6%BA%90%E7%A0%81">future::get</a>  -&gt;  <a href="#move%E5%87%BD%E6%95%B0%E6%BA%90%E7%A0%81">__assoc_state::move</a></li>
</ol>
<blockquote>
<p>当一个函数抛出异常的时候，该异常会沿着调用链逐级向上返回，当异常返回到调用链的最高层级这个逐级向上返回的过程中，没有对异常进行捕捉处理，此时会导致程序终止。这里面异常是沿着调用链逐级向上传递的，这也就说明异常只能在产生异常的线程内部进行逐级向上传递（因为函数调用链的各个层级必然属于一个线程）</p>
<p>而这里，构建一个<code>future</code>和<code>promise</code>传递异常的通道的原因是由于异步调用是在另外一个线程执行异步操作，但是在另外一个线程进行异步调用结果信息获取，如果异步调用执行过程中出现异常，那么此时这个异常信息也是异步调用执行结果的一种表现形式，那么此时如果不捕获这异常通过构建的通道传递给异步调用结果信息使用线程，这个异常将会在异步调用线程被传递，在异步调用结果使用线程中无法捕捉这一异常信息（因为不会传递到该线程）。那么该线程就无法了解异步调用操作异常返回这一信息</p>
</blockquote>
<p>为了实现这两点:</p>
<ul>
<li>针对第一点:为了保证在函数异常返回的时候，不能出现资源泄露。通常为了实现这点有一个有效的途径就是在函数内使用<code>RAII</code>计数来管理资源</li>
<li>针对第二点:实现的流程在<a href="#get%E5%87%BD%E6%95%B0%E6%BA%90%E7%A0%81">future::get</a>  -&gt;  <a href="#move%E5%87%BD%E6%95%B0%E6%BA%90%E7%A0%81">__assoc_state::move</a> ,</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个promise对象实例</span></span><br><span class="line">    promise&lt;<span class="type">int</span>&gt; thePromise;</span><br><span class="line">    <span class="comment">//从promise对象实例中获取对应的future对象实例</span></span><br><span class="line">    future&lt;<span class="type">int</span>&gt; theFuture = thePromise.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="comment">//创建一个会产生异常的异步任务</span></span><br><span class="line">    <span class="keyword">auto</span> throw_exp_task = [](promise&lt;<span class="type">int</span>&gt; prom)&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;this is a test exception&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span>(...)</span><br><span class="line">        &#123;</span><br><span class="line">            prom.<span class="built_in">set_exception</span>(std::<span class="built_in">current_exception</span>());</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//将这个任务交给一个线程,进行异步执行</span></span><br><span class="line">    <span class="function">thread <span class="title">work_thread</span><span class="params">(throw_exp_task,move(thePromise))</span></span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        theFuture.<span class="built_in">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(<span class="type">const</span> std::exception&amp; e)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr&lt;&lt;e.<span class="built_in">what</span>()&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    work_thread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出:this is a test exception</span></span><br></pre></td></tr></table></figure>

<p>在上述代码中，我们在<code>throw_exp_task</code>中抛出了一个异常，然后将这个异常传递给了<code>std::promise</code>对象。当我们试图从<code>std::future</code>对象中获取值时，这个异常被重新抛出，然后我们在<code>main</code>函数中捕获了这个异常。这就是如何在两个线程之间传递异常。</p>
<h2 id="packaged-task"><a href="#packaged-task" class="headerlink" title="packaged_task"></a>packaged_task</h2><p><code>std::packaged_task</code>在C++中起到的作用是包装一个可调用目标（如函数、lambda表达式、bind表达式或函数对象），使其成为一个可以异步执行的任务，并且能够通过<code>std::future</code>来获取其执行结果或捕获抛出的异常。具体来说，<code>std::packaged_task</code>的主要作用包括：</p>
<blockquote>
<p>提供了下面的功能:</p>
<ul>
<li>结果同步与访问</li>
<li>任务重用与重置</li>
<li>线程退出时设置结果</li>
<li>统一接口与封装</li>
</ul>
</blockquote>
<p><strong>封装可调用对象</strong>： <code>std::packaged_task</code>模板接受一个可调用对象作为模板参数，如<code>std::packaged_task&lt;int(double)&gt;</code>表示包装一个接收一个<code>double</code>参数并返回一个<code>int</code>值的可调用对象。通过构造函数或赋值操作符将实际的可调用对象传入<code>packaged_task</code>实例，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="type">double</span>)</span>&gt; <span class="title">task</span><span class="params">([](<span class="type">double</span> x) &#123; <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="type">int</span>&gt;(x * <span class="number">2</span>); &#125;)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>结果同步与访问</strong>： 与<code>packaged_task</code>关联的执行结果可以通过调用其<code>get_future()</code>成员函数获得一个<code>std::future</code>对象。这个<code>future</code>对象提供了接口来查询任务是否已完成、阻塞等待结果准备就绪、非阻塞尝试获取结果、获取结果（阻塞直到结果可用）以及捕获可能抛出的异常。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::future&lt;<span class="type">int</span>&gt; result_future = task.<span class="built_in">get_future</span>();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="type">int</span> result = result_future.<span class="built_in">get</span>();  <span class="comment">// 阻塞，直到任务执行完毕并获取结果</span></span><br></pre></td></tr></table></figure>

<p><strong>任务重用与重置</strong>： 如果需要重新使用同一个<code>packaged_task</code>实例包装不同的可调用对象或再次执行相同的任务，可以调用<code>reset()</code>成员函数。这将清除之前任务的状态，允许重新设置新的可调用对象并再次执行。注意，<code>reset()</code>会丢弃之前任务的执行结果或未处理的异常。</p>
<p><strong>线程退出时设置结果</strong>： 在某些情况下，可能希望在当前线程即将退出时才令<code>packaged_task</code>的结果就绪。这时可以使用<code>make_ready_at_thread_exit()</code>成员函数，它会在当前线程结束时，且所有线程局部对象被销毁后，使与<code>packaged_task</code>关联的<code>future</code>对象准备就绪。</p>
<p>类似于<code>funciton</code>, <code>packaged_task</code>可以绑定一个可调用对象并执行,但是它的返回类型是<code>void</code>，获取它的返回值必须用<code>future</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如何给它传入固定参数, 而不必在调用时指定:使用bind函数</span></span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="type">int</span>)</span>&gt; <span class="title">t</span><span class="params">(factorial)</span></span>;</span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">()</span>&gt; <span class="title">t</span><span class="params">(std::bind(factorial, <span class="number">6</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do something else</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">t</span>(); <span class="comment">// in a different context， always return void</span></span><br><span class="line">    <span class="type">int</span> x = t.<span class="built_in">get_future</span>().<span class="built_in">get</span>();<span class="comment">//获取返回值</span></span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它和<code>function</code>的不同之处在于<code>packaged_task</code>把一个可调用对象链接到了未来，用于多线程执行</p>
<h2 id="与CSharp异步编程模型的区别"><a href="#与CSharp异步编程模型的区别" class="headerlink" title="与CSharp异步编程模型的区别"></a>与CSharp异步编程模型的区别</h2><p>与[[CSharp入门#CSharp 异步编程模型|CSharp中的await&#x2F;async]]的区别</p>
<ul>
<li>C#的<code>async</code>修饰符没有直接对应的C++关键词。C++使用<code>std::async</code>函数启动异步操作，但它更接近于C#的<code>Task.Run</code>或者直接启动一个<code>Task</code>的方式。</li>
<li>C#的<code>await</code>关键字对应于C++中<code>std::future</code>的<code>get()</code>方法，都是用来等待异步操作的完成并获取结果。但<code>await</code>是非阻塞的，而<code>get()</code>会阻塞调用线程。</li>
</ul>
<p>C++中的异步结果获取可以通过结合<code>std::future</code>和轮询实现,参考如下代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fetchData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 模拟耗时操作</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> future = std::<span class="built_in">async</span>(std::launch::async, fetchData);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(future.<span class="built_in">wait_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">0</span>)) != std::future_status::ready) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Waiting for result...\n&quot;</span>;</span><br><span class="line">        <span class="comment">// 可以在这里做一些其他的事情，而不是阻塞等待</span></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">200</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Data: &quot;</span> &lt;&lt; future.<span class="built_in">get</span>() &lt;&lt; std::endl; <span class="comment">// 获取结果</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="原子库"><a href="#原子库" class="headerlink" title="原子库"></a>原子库</h1><blockquote>
<p><code>std::atomic</code>类型位于<code>&lt;atomic&gt;</code>头文件中，是一种特殊的模板类型，旨在提供对单个变量的无锁原子访问。在多线程环境中，当多个线程需要访问同一个变量时，如果该变量被声明为<code>std::atomic</code>类型，那么对该变量的所有操作都将自动成为原子操作。</p>
<p>独特的优势盘点:</p>
<ol>
<li><strong>细粒度同步</strong>:允许对基本数据类型和用户定义类型进行原子更新</li>
<li><strong>无锁编程</strong>:使用原子库可以编写出更高效、无阻塞的并发代码，减少上下文切换和锁争抢带来的性能损失</li>
<li>**内存模型支持:**支持定义内存顺序约束，如 <code>std::memory_order_acquire</code>、<code>std::memory_order_release</code> 等</li>
<li><strong>低级别构建块</strong>：原子库提供的是并发编程的基础构建块，可以用来构建更复杂的同步原语和数据结构</li>
<li><strong>硬件级别的原子性</strong>:原子库通常利用底层硬件提供的原子指令来实现其功能，这些指令在硬件层面确保了操作的不可分割性。对于某些关键的、需要绝对一致性的操作（如引用计数、状态标志更新等），使用原子库提供的操作比单纯依靠操作系统或语言级别的同步机制更能确保操作的正确完成。</li>
<li><strong>避免死锁</strong></li>
</ol>
<p>局限性:</p>
<p>主要适用于简单的数据共享场景，如单一变量的读写。对于更复杂的同步需求，比如需要保持多个变量之间的一致性，无锁编程无法有效应对,需要回到更传统的同步机制，如<a href="#mutex%E7%B3%BB%E5%88%97">互斥锁</a>或<a href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F">条件变量</a></p>
</blockquote>
<p>在原子性操作库中，每个原子变量都有以下几个特点：</p>
<ol>
<li>原子变量的读写操作是原子的，即不会被其他线程中断。</li>
<li>原子变量的值可以被多个线程同时访问和修改。</li>
<li>原子变量的修改操作是按照一定顺序进行的，保证了多个线程对同一个变量进行操作时的正确性。</li>
</ol>
<p>原子性操作库中提供了一系列的原子操作函数，包括load、store、exchange、compare_exchange等。load函数用于读取原子变量的值，store函数用于设置原子变量的值，exchange函数用于交换原子变量的值，而compare_exchange函数用于比较并交换原子变量的值</p>
<h2 id="原子变量"><a href="#原子变量" class="headerlink" title="原子变量"></a>原子变量</h2><p>原子性操作库(atomic)提供了多种类型的原子变量，包括<code>bool</code> 、<code>char</code>、<code>short</code>、<code>int</code>、<code>long</code>、<code>long long</code>等基本数据类型，以及<code>intmax_t</code>、<code>uintmax_t</code>、<code>intptr_t</code>等扩展类型。每个原子变量都有对应的原子类型，比如<code>atomic_bool</code>、<code>atomic_char</code>、<code>atomic_int</code>等。在使用时，我们需要根据实际的需求选择合适的原子类型和原子变量。</p>
<h3 id="原子类型"><a href="#原子类型" class="headerlink" title="原子类型"></a>原子类型</h3><p>下面是原子性操作库中支持的一些原子类型：</p>
<table>
<thead>
<tr>
<th>原子类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>atomic_bool</td>
<td>原子布尔型，只能存储true或false。</td>
</tr>
<tr>
<td>atomic_char</td>
<td>原子字符型，相当于char类型。</td>
</tr>
<tr>
<td>atomic_uchar</td>
<td>原子无符号字符型，相当于unsigned char类型。</td>
</tr>
<tr>
<td>atomic_schar</td>
<td>原子有符号字符型，相当于signed char类型。</td>
</tr>
<tr>
<td>atomic_short</td>
<td>原子短整型，相当于short类型。</td>
</tr>
<tr>
<td>atomic_ushort</td>
<td>原子无符号短整型，相当于unsigned short类型。</td>
</tr>
<tr>
<td>atomic_int</td>
<td>原子整型，相当于int类型。</td>
</tr>
<tr>
<td>atomic_uint</td>
<td>原子无符号整型，相当于unsigned int类型。</td>
</tr>
<tr>
<td>atomic_long</td>
<td>原子长整型，相当于long类型。</td>
</tr>
<tr>
<td>atomic_ulong</td>
<td>原子无符号长整型，相当于unsigned long类型。</td>
</tr>
<tr>
<td>atomic_llong</td>
<td>原子长长整型，相当于long long类型。</td>
</tr>
<tr>
<td>atomic_ullong</td>
<td>原子无符号长长整型，相当于unsigned long long类型。</td>
</tr>
<tr>
<td>atomic_wchar_t</td>
<td>原子宽字符型，相当于wchar_t类型。</td>
</tr>
<tr>
<td>atomic_char16_t</td>
<td>原子16位字符型，相当于char16_t类型。</td>
</tr>
<tr>
<td>atomic_char32_t</td>
<td>原子32位字符型，相当于char32_t类型。</td>
</tr>
<tr>
<td>atomic_intmax_t</td>
<td>原子最大宽度整数类型，对应&lt;inttypes.h&gt;中的intmax_t类型。</td>
</tr>
<tr>
<td>atomic_uintmax_t</td>
<td>原子最大宽度无符号整数类型，对应&lt;inttypes.h&gt;中的uintmax_t类型。</td>
</tr>
<tr>
<td>atomic_intptr_t</td>
<td>原子指针宽度整数类型，对应&lt;stddef.h&gt;中的intptr_t类型。</td>
</tr>
<tr>
<td>atomic_uintptr_t</td>
<td>原子指针宽度无符号整数类型，对应&lt;stddef.h&gt;中的uintptr_t类型。</td>
</tr>
<tr>
<td>atomic_size_t</td>
<td>原子size_t类型，用于表示对象的大小。</td>
</tr>
<tr>
<td>atomic_ptrdiff_t</td>
<td>原子ptrdiff_t类型，用于表示两个指针之间的距离。</td>
</tr>
</tbody></table>
<p>当我们去看这些类型的定义时会发现，起始它们都是用<code>atomic&lt;T&gt;</code>模板来定义的。例如<code>std::atomic_llong</code>就是用<code>std::atomic&lt;long long&gt;</code>来定义的。</p>
<p>C++11 的原子标准不保证其在每个平台上的实现都是无锁的，因此最好要清楚你的平台和工具链的能力。你可以调用 <code>std::atomic&lt;&gt;::is_lock_free</code> 来确认一下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line">std::atomic_llong total = <span class="number">0</span>;            <span class="comment">// atomic_llong相当于long long，但是本身就拥有原子性,意味着多个线程访问total时，有且仅有一个线程能对total进行操作</span></span><br><span class="line"><span class="comment">//long long total = 0;				//不是线程安全的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="type">long</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000LL</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        total += i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(func)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(func)</span></span>;</span><br><span class="line"></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; total &lt;&lt; std::endl;     <span class="comment">// 9999999900000000</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//total如果定义为long long类型,输出的结果将是:5035590076049140</span></span><br><span class="line"><span class="comment">//输出:9999999900000000</span></span><br></pre></td></tr></table></figure>

<h3 id="哪些类型适用于原子操作"><a href="#哪些类型适用于原子操作" class="headerlink" title="哪些类型适用于原子操作"></a>哪些类型适用于原子操作</h3><p>并非所有数据类型都适用于原子操作,要成为原子类型,数据类型必须满足以下条件:</p>
<ul>
<li><strong>可拷贝性</strong>：<strong>类型必须是可拷贝的</strong>，意味着它可以通过简单的内存复制来复制或移动，没有复杂的内部状态。</li>
<li><strong>固定大小</strong>：<strong>类型的大小必须是固定的且足够小</strong>，以便硬件能够保证其操作的原子性。</li>
<li><strong>对齐要求</strong>：<strong>正确的内存对齐是必要的</strong>，以确保原子操作的正确性和效率。</li>
</ul>
<blockquote>
<p>整数类型和指针类型通常适用于原子操作，而大型结构体或类实例可能不适合</p>
</blockquote>
<h2 id="原子类型函数"><a href="#原子类型函数" class="headerlink" title="原子类型函数"></a>原子类型函数</h2><p><strong>注意</strong>：<strong>原子类型和原子操作函数需要包含 <code>&lt;atomic&gt;</code> 头文件才能使用</strong>。</p>
<p>C++11中将原子操作定义为atomic模板类的成员函数，包括了大多数类型的操作，比如读写、交换等。对于内置类型，主要通过重载全局操作符来实现。下面列出所有atomic类型及其支持的相关操作列表：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202404080916307.png" alt="img" style="zoom: 67%;" />

<p>下面是常用的原子类型函数：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>load()</td>
<td>原子读取操作，用于获取原子变量的当前值。</td>
</tr>
<tr>
<td>store()</td>
<td>原子写入操作，用于设置原子变量的值。</td>
</tr>
<tr>
<td>exchange()</td>
<td>原子交换操作，用于交换原子变量的值，并返回原始值。</td>
</tr>
<tr>
<td>compare_exchange_weak()</td>
<td>条件性原子地替换原子对象的值</td>
</tr>
<tr>
<td>compare_exchange_strong()</td>
<td>条件性原子地替换原子对象的值</td>
</tr>
<tr>
<td>fetch_add()</td>
<td>原子加法操作，用于增加原子变量的值，并返回原始值。</td>
</tr>
<tr>
<td>fetch_sub()</td>
<td>原子减法操作，用于减少原子变量的值，并返回原始值。</td>
</tr>
<tr>
<td>fetch_and()</td>
<td>原子按位与操作，用于按位与原子变量的值，并返回原始值。</td>
</tr>
<tr>
<td>fetch_or()</td>
<td>原子按位或操作，用于按位或原子变量的值，并返回原始值。</td>
</tr>
<tr>
<td>fetch_xor()</td>
<td>原子按位异或操作，用于按位异或原子变量的值，并返回原始值。</td>
</tr>
<tr>
<td>fetch_min()</td>
<td>原子最小值操作，将原子变量与给定值比较，并将较小的值存储在原子变量中。返回原始值。</td>
</tr>
<tr>
<td>fetch_max()</td>
<td>原子最大值操作，将原子变量与给定值比较，并将较大的值存储在原子变量中。返回原始值。</td>
</tr>
<tr>
<td>fetch_mul()</td>
<td>原子乘法操作，将原子变量与给定值相乘，并将结果存储在原子变量中。返回原始值。</td>
</tr>
<tr>
<td>fetch_div()</td>
<td>原子除法操作，将原子变量与给定值相除，并将结果存储在原子变量中。返回原始值。</td>
</tr>
<tr>
<td>fetch_and_not()</td>
<td>原子按位与非操作，对原子变量进行按位与非运算，并将结果存储在原子变量中。返回原始值。</td>
</tr>
<tr>
<td>fetch_negate()</td>
<td>原子取反操作，对原子变量进行取反运算，并将结果存储在原子变量中。返回原始值。</td>
</tr>
<tr>
<td>fetch_bitwise_and()</td>
<td>原子按位与操作，将原子变量与给定值进行按位与运算，并将结果存储在原子变量中。返回原始值。</td>
</tr>
<tr>
<td>fetch_bitwise_or()</td>
<td>原子按位或操作，将原子变量与给定值进行按位或运算，并将结果存储在原子变量中。返回原始值。</td>
</tr>
<tr>
<td>fetch_bitwise_xor()</td>
<td>原子按位异或操作，将原子变量与给定值进行按位异或运算，并将结果存储在原子变量中。返回原始值。</td>
</tr>
<tr>
<td>is_lock_free()</td>
<td>判断是否是无锁的</td>
</tr>
</tbody></table>
<p><strong>注意</strong>：<strong>以上函数只是原子类型库中的一部分函数</strong>，还有其他函数可用于更复杂的操作，具体取决于你的需求。</p>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::atomic_int <span class="title">counter</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">// 创建一个原子整型变量并初始化为0,相当于atomic&lt;int&gt; counter=0;</span></span><br><span class="line">    counter++; <span class="comment">// 原子操作：递增counter的值,相当于counter.fetch_add(1);</span></span><br><span class="line">    <span class="type">int</span> value = counter.<span class="built_in">load</span>(); <span class="comment">// 原子操作：读取counter的值,相当于int value = counter;</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Counter value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    counter.<span class="built_in">store</span>(<span class="number">10</span>); <span class="comment">// 原子操作：将counter的值设置为10,等价于counter = 10;</span></span><br><span class="line">    <span class="type">bool</span> exchanged = counter.<span class="built_in">compare_exchange_weak</span>(value, <span class="number">5</span>); <span class="comment">// 原子操作：比较并交换counter的值</span></span><br><span class="line">    <span class="keyword">if</span> (exchanged) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value exchanged successfully!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value exchange failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通过使用原子类型和原子操作，我们可以确保多线程环境下对共享变量的安全访问和修改</strong>。</p>
<h3 id="特殊的atomic-flag"><a href="#特殊的atomic-flag" class="headerlink" title="特殊的atomic_flag"></a>特殊的atomic_flag</h3><p><strong>atomic_flag</strong> 与其他类型不同,他是<strong>无锁</strong>的(lock_free)</p>
<p>atomic_flag只支持test_and_set以及clear两个成员函数</p>
<ul>
<li><code>test_and_set函数</code>   检查 std::atomic_flag 标志，如果 std::atomic_flag 之前没有被设置过，则设置 std::atomic_flag 的标志，并返回先前该 std::atomic_flag 对象是否被设置过，如果之前 std::atomic_flag 对象已被设置，则返回 true，否则返回 false；</li>
<li><code>clear函数</code>   清除 std::atomic_flag 标志使得下一次调用 std::atomic_flag::test_and_set 返回 false。</li>
</ul>
<p>可以用这两个函数来实现一个自旋锁：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">atomic_flag flag;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (flag.<span class="built_in">test_and_set</span>(std::memory_order_acquire))    <span class="comment">// 在主线程中设置为true，需要等待t2线程clear</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;wait&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;do something&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;start&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    flag.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    flag.<span class="built_in">test_and_set</span>();             <span class="comment">// 设置状态</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(func1)</span></span>;</span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(func2)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中，线程t1调用test_and_set一直返回true(因为在主线程中被设置过)，所以一直在等待，而等待一段时间后当线程t2运行并调用了clear，test_and_set返回了false退出循环等待并进行相应操作。这样一来，就实现了一个线程等待另一个线程的效果。</p>
<h2 id="memory-order的枚举值"><a href="#memory-order的枚举值" class="headerlink" title="memory_order的枚举值"></a>memory_order的枚举值</h2><blockquote>
<p>在多线程程序中，不同线程对内存的读写操作可能导致意想不到的结果，这主要是因为<strong>现代计算机系统和编译器通常会对操作进行重排序，以优化性能和资源利用率</strong>。</p>
<p>重排序的影响:</p>
<ol>
<li><strong>处理器重排序</strong>：为了提高执行效率，处理器可能会改变指令的执行顺序，只要这种重排序不影响单线程内的程序语义。</li>
<li><strong>编译器优化</strong>：编译器同样可能为了优化而改变代码的执行顺序。</li>
</ol>
<p>这种重排序在单线程程序中通常是安全的，但在多线程环境下，它可能导致数据竞争和不一致的内存状态。</p>
<p><strong>内存顺序（Memory Ordering），是一种规则，它定义了操作的可见性和执行顺序，是确保多线程程序正确性的关键</strong>。在C++中，这些规则通过原子操作的内存顺序标志来实现。</p>
</blockquote>
<p>在C++11中一共有6种memory_order枚举值，<strong>默认按照memory_order_seq_cst执行</strong>:</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202404081028074.png" alt="memory" style="zoom:67%;" />

<p>如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="built_in">store</span>(<span class="number">1</span>, std::memory_order_relaxed);<span class="comment">//std::memory_order_relaxed表示松散内存顺序，该枚举值代表编译器可以任由编译器重新排序或者由处理器乱序处理</span></span><br></pre></td></tr></table></figure>

<p>不是所有memory_order枚举值都能被atomic成员函数使用:</p>
<ul>
<li>store函数可以使用memory_order_seq_cst、memory_order_release、memory_order_relaxed。</li>
<li>load函数可以使用memory_order_seq_cst、memory_order_acquire、memory_order_consume、memory_order_relaxed。</li>
<li>需要同时读写的操作，例如test_and_flag、exchange等操作。可以使用全部6种:memory_order_seq_cst、memory_order_rel、memory_order_release、memory_order_acquire、memory_order_consume、memory_order_relaxed。</li>
</ul>
<p>原子类型提供的一些操作符都是<code>memory_order_seq_cst</code>的封装，所以他们都是<a href="#%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5">顺序一致性</a>的。</p>
<h3 id="顺序一致性的核心概念"><a href="#顺序一致性的核心概念" class="headerlink" title="顺序一致性的核心概念"></a>顺序一致性的核心概念</h3><p>顺序一致性是并发编程中最直观、最易理解的内存模型。它遵循两个基本原则：</p>
<ol>
<li><strong>操作顺序</strong>：在单个线程内部，所有操作（包括原子操作和非原子操作）的执行顺序与程序代码中的顺序相符。</li>
<li><strong>全局顺序</strong>：程序中所有原子操作都存在一个全局的顺序，所有线程都能观察到这一相同的顺序。</li>
</ol>
<p>这意味着，使用 <code>std::memory_order_seq_cst</code> 的原子操作仿佛在一个单线程环境中执行一样，其执行顺序清晰且易于预测。</p>
<blockquote>
<p>std::atomic和<strong>std::memory_order只有在多cpu多线程情况下，无锁编程才会用到</strong>。在x86下，由于是strong memory order的，所以很多时候只需要考虑编译器优化；保险起见，可以用std::atomic，他会同时处理编译器优化和cpu的memory order（虽然x86用不到）。但是在除非必要的情况下，不用使用std::memory_order，std::atmoic默认用的是最强限制。</p>
</blockquote>
<p>尽管 <code>std::memory_order_seq_cst</code> 提供了最强的一致性保证，但这种保证有时候是以牺牲性能为代价的。在高性能并发程序中，过度依赖顺序一致性可能会成为性能瓶颈。因此，选择正确的内存顺序需要在易用性和性能之间做出平衡。</p>
<h3 id="获取和释放语义"><a href="#获取和释放语义" class="headerlink" title="获取和释放语义"></a>获取和释放语义</h3><p>并发编程的艺术在于精确控制多个线程间的操作和交互。在这个艺术中，<code>std::memory_order_acquire</code> 和 <code>std::memory_order_release</code> 扮演着重要的角色</p>
<p><code>std::memory_order_acquire</code>（获取）和 <code>std::memory_order_release</code>（释放）代表了两种内存顺序语义，它们用于控制原子操作在多线程环境中的执行顺序。</p>
<ol>
<li><strong><code>std::memory_order_acquire</code><strong>：用于读取操作，</strong>保证在该操作之后的内存读写不会被重排序到该操作之前</strong>。它<strong>确保对共享数据的读取操作可以看到之前的写入操作的结果</strong>。</li>
<li><strong><code>std::memory_order_release</code><strong>：用于写入操作，</strong>保证在该操作之前的内存读写不会被重排序到该操作之后</strong>。它<strong>确保写入操作对后续的读取操作可见</strong>。</li>
</ol>
<p>这两种语义通常需要配对使用，以保证线程间的操作顺序和数据一致性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xxx.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">xxx.<span class="built_in">store</span>(status,memory_order_release);</span><br><span class="line"><span class="comment">//读取操作使用 std::memory_order_acquire</span></span><br><span class="line"><span class="comment">//写入操作使用 std::memory_order_release</span></span><br><span class="line"><span class="comment">//这确保了状态变更对所有线程的可见性，同时防止了潜在的内存重排序问题。</span></span><br></pre></td></tr></table></figure>

<p>实际的并发编程中，<code>std::memory_order_acquire</code> 和 <code>std::memory_order_release</code> 常用于实现无锁数据结构和算法，如无锁队列和计数器。这些内存顺序标志的使用减少了对昂贵的锁操作的依赖，提高了程序的性能。</p>
<p><strong>性能测试</strong>：虽然无锁编程可能提高性能，但这并不是绝对的。在某些情况下，尤其是在低竞争环境中，互斥锁可能仍然是更好的选择。性能测试是必要的。</p>
<h2 id="性能与安全性"><a href="#性能与安全性" class="headerlink" title="性能与安全性"></a>性能与安全性</h2><p>无锁编程的一个主要目标是提高性能，但这不应该以牺牲安全性和正确性为代价。在实际应用中，需要仔细评估无锁编程带来的性能提升是否值得在安全性和易用性上做出妥协。</p>
<ul>
<li><strong>性能测试</strong>：在采用无锁编程之前，进行全面的性能测试是必要的，以确保它确实带来了预期的性能提升。</li>
<li><strong>错误处理</strong>：原子操作不提供内建的错误处理机制。因此，开发者需要仔细设计代码以处理潜在的错误情况。</li>
<li><strong>复杂性和可维护性</strong>：无锁编程通常比使用互斥锁更复杂，可能导致代码难以理解和维护。</li>
</ul>
<h2 id="无锁编程"><a href="#无锁编程" class="headerlink" title="无锁编程"></a>无锁编程</h2><p>无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization），实现非阻塞同步的方案称为“无锁编程算法”。</p>
<p>无锁编程主要依靠原子操作（Atomic Operations）来实现。原子操作是一种不可分割的操作，保证在执行过程中不会被其他线程中断。在C++中，这通常通过 <code>std::atomic</code> 类型和相关函数实现，它们可以对基本数据类型进行无锁操作。</p>
<p>为什么要非阻塞同步，使用lock实现线程同步有非常多缺点：</p>
<ul>
<li>产生竞争时，线程被阻塞等待，<strong>无法做到线程实时响应</strong></li>
<li>dead lock 死锁</li>
<li>live lock 活锁</li>
<li>优先级反转</li>
<li>使用不当，造成性能下降</li>
</ul>
<p>优势:</p>
<ul>
<li><strong>性能提升</strong>：由于减少了线程阻塞和上下文切换，无锁编程可以显著提高程序的性能，特别是在高并发环境中。</li>
<li><strong>避免死锁和饥饿</strong>：传统的锁机制可能导致死锁或线程饥饿的问题，无锁编程可以有效地避免这些问题。</li>
<li><strong>实时系统中的应用</strong>：在要求高响应性的实时系统中，比如智能驾驶的域控制系统，无锁编程由于其较低的延迟特性，被广泛应用。</li>
</ul>
<p>从心理学的角度来看，互斥锁类似于人们在面对资源竞争时的等待策略，而无锁编程则更像是持续尝试直到成功的坚持策略</p>
<p>非同步阻塞的实现分为三个级别：wait-free&#x2F;lock-free&#x2F;obstruction-free</p>
<ol>
<li><p>wait-free  无等待编程</p>
<p>最理想的模式,整个操作保证每个线程在有限步骤下完毕</p>
<p>保证系统级吞吐（system-wide throughput）以及无线程饥饿</p>
</li>
<li><p>lock-free  无锁编程</p>
<p>同意个别线程饥饿，但保证系统级吞吐。</p>
<p>确保至少有一个线程可以继续运行。</p>
<p>wait-free的算法必然也是lock-free的。</p>
</li>
<li><p>obstruction-free</p>
<p>在不论什么时间点，一个线程被隔离为一个事务进行运行（其它线程suspended），而且在有限步骤内完毕。在运行过程中，一旦发现数据被改动（採用时间戳、版本），则回滚，也叫做乐观锁，即乐观并发控制(OOC)。</p>
</li>
</ol>
<p>事务的过程是：</p>
<ul>
<li>读取，并写时间戳</li>
<li>准备写入，版本号校验</li>
<li>检验通过则写入，检验不通过，则回滚</li>
</ul>
<p><strong>无锁算法感触最深的是复杂度的分解，比如多线程对于一个双向链表的插入或删除操作，如何能一步一步分解成一个一个串联的原子操作，并能保证事务内存的一致性。</strong></p>
<h3 id="为什么要无锁"><a href="#为什么要无锁" class="headerlink" title="为什么要无锁"></a>为什么要无锁</h3><ol>
<li>首先是性能考虑。通信项目一般对性能有极致的追求，这是我们使用无锁的重要原因。当然，无锁算法如果实现的不好，性能可能还不如使用锁，所以我们选择比较擅长的数据结构和算法进行lock-free实现，比如Queue，对于比较复杂的数据结构和算法我们通过lock来控制，比如Map</li>
<li>避免锁的使用引起的错误和问题<ul>
<li>死锁:两个以上线程互相等待</li>
<li>锁护送(lock convoy):多个同优先级的线程反复竞争同一个锁,抢占锁失败后强制上下文切换,引起性能下降</li>
<li>优先级反转(priority inversion):低优先级线程拥有锁时被中优先级的线程抢占,而高优先级的线程因为申请不到锁被阻塞</li>
</ul>
</li>
</ol>
<blockquote>
<p>锁护送(锁列队)和活锁的区别:</p>
<p><strong>Lock Convoy（锁列队）</strong>： 在计算机科学中，锁列队是在使用锁进行并发控制的多线程应用程序中可能出现的性能问题。当多个具有相同优先级的线程反复争用同一把锁时，就会发生锁列队。与死锁和活锁的情况不同，锁列队中的线程确实在进展；然而，每次线程尝试获取锁并失败时，它都会放弃其剩余的调度量子，并强制进行上下文切换。重复的上下文切换和调度量子的低利用率降低了整体性能。锁列队通常发生在并发控制原语（如锁）序列化访问常用资源（如内存堆或线程池）的情况下。它们有时可以通过使用非锁定替代方案（如无锁算法）或者改变争用线程的相对优先级来解决。</p>
<p><strong>活锁（Live Lock）</strong>： 活锁是指线程们都在运行并尝试执行任务，但是由于某些条件始终无法满足，导致线程们一直在重试，但是最终无法完成任务。这种情况下，线程们看起来像是在不断地活动，但是实际上却没有任何进展。</p>
</blockquote>
<h3 id="如何无锁"><a href="#如何无锁" class="headerlink" title="如何无锁"></a>如何无锁</h3><p>在现代的 CPU 处理器上，很多操作已经被设计为原子的，比如对齐读（Aligned Read）和对齐写（Aligned Write）等。Read-Modify-Write（RMW）操作的设计让执行更复杂的事务操作变成了原子操作，当有多个写入者想对相同的内存进行修改时，保证一次只执行一个操作。</p>
<p>RMW 操作在不同的 CPU 家族中是通过不同的方式来支持的：</p>
<ul>
<li>x86&#x2F;64 和 Itanium 架构通过 Compare-And-Swap (CAS) 方式来实现</li>
<li>PowerPC、MIPS 和 ARM 架构通过 Load-Link&#x2F;Store-Conditional (LL&#x2F;SC) 方式来实现</li>
</ul>
<p>在x64下进行实践的，用的是CAS操作，CAS操作是lock-free技术的基础,CAS可以用下面的代码来描述:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CAS</span><span class="params">(T* addr, T expected, T value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (*addr == expected)</span><br><span class="line">  &#123;</span><br><span class="line">     *addr = value;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>无锁编程具体使用和考虑到的技术方法包括：</p>
<ul>
<li>原子操作（atomic operations）</li>
<li>内存栅栏（memory barriers）</li>
<li>内存顺序冲突（memory order）</li>
<li>指令序列一致性（sequential consistency）</li>
<li>顺ABA现象</li>
<li>等等</li>
</ul>
<p>在这其中最基础最重要的是操作的原子性或说原子操作</p>
<p>对于原子操作的实现机制，在<strong>硬件层面上CPU处理器会默认保证基本的内存操作的原子性</strong>，CPU保证从系统内存当中读取或者写入一个字节的行为肯定是原子的，当一个处理器读取一个字节时，其他CPU处理器不能访问这个字节的内存地址。</p>
<p>但是对于<strong>复杂的内存操作</strong>CPU处理器不能自动保证其原子性，比如跨总线宽度或者跨多个缓存行（Cache Line），跨页表的访问等。这个时候就需要用到<strong>CPU指令集中设计的原子操作指令</strong>，现在大部分CPU指令集都会支持一系列的原子操作。而在无锁编程中经常用到的原子操作是Read-Modify-Write （RMW）这种类型的，这其中最常用的原子操作又是 COMPARE AND SWAP（CAS），几乎所有的CPU指令集都支持CAS的原子操作，比如X86平台下中的是 CMPXCHG</p>
<p><strong>CAS操作</strong>行为是比较某个内存地址处的内容是否和期望值一致，如果一致则将该地址处的数值替换为一个新值。CAS能够操作的位数越多，使用它来实现锁无关的数据结构就越容易（细节可以在intel手册中查看）。CAS操作具体的实现原理主要是两种方式：</p>
<ul>
<li><p>总线锁定</p>
<p>CPU执行某条指令的时候先锁住数据总线的， 使用同一条数据总线的CPU就无法访问内存了，在指令执行完成后再释放锁住的数据总线。锁住数据总线的方式系统开销很大，限制了访问内存的效率</p>
</li>
<li><p>缓存锁定</p>
<p>用CPU的缓存一致性的机制来防止内存区域的数据被两个以上的处理器修改（可详见CPU缓存的MESI协议）</p>
</li>
</ul>
<p><strong>操作系统的层面</strong>，Linux系统提供了软件级的原子操作，包括两大类系统调用，一类是基于对整数进行操作的atomic_set&#x2F;and&#x2F;inc，一类是针对单独的位进行操作的set&#x2F;clear&#x2F;change_bit，它们大部分都是基于硬件层面的CAS的指令实现的。</p>
<p>在各种<strong>开发语言中</strong>（c,c++,java）基于操作系统提供的接口也都封装实现了对应的原子操作api，所以开发者完全可以直接调用各个开发语言提供的接口实现无锁程序。</p>
<h3 id="无锁编程技术"><a href="#无锁编程技术" class="headerlink" title="无锁编程技术"></a>无锁编程技术</h3><p>事实证明，当你试图满足无锁编程的无阻塞条件时，会出现一系列技术：原子操作、内存屏障、避免ABA问题，等等。从这里开始，事情很快变得棘手了。</p>
<h4 id="内存保序"><a href="#内存保序" class="headerlink" title="内存保序"></a>内存保序</h4><p>正如前面流程图所建议的那样，任何时候做多核（或者任何对称多处理器）的无锁编程，如果你的环境不能保证顺序一致性，你都必须考虑如何来防止 内存重新排序。</p>
<p>在当今的架构中，增强内存保序性的工具通常分为三类，它们既防止 编译器重新排序 又防止 处理器重新排序：</p>
<ul>
<li>一个轻型的同步或屏障指令</li>
<li>一个完全的内存屏障指令</li>
<li><a href="#%E8%8E%B7%E5%8F%96%E5%92%8C%E9%87%8A%E6%94%BE%E8%AF%AD%E4%B9%89">提供获取或释放语义的内存操作</a></li>
</ul>
<p>获取语义可防止按照程序顺序对其进行操作的内存重新排序，而释放语义则可防止对其进行操作前的内存重新排序。这些语义尤其适用于存在生产者&#x2F;消费者关系的情况，其中一个线程发布一些信息，而另一个线程读取它。</p>
<h4 id="无锁编程如何控制对一个很大的对象的访问"><a href="#无锁编程如何控制对一个很大的对象的访问" class="headerlink" title="无锁编程如何控制对一个很大的对象的访问"></a>无锁编程如何控制对一个很大的对象的访问</h4><p>如果这是一个高一致性的场景，也只能使用锁了。但是如果这并不是一个对一致性要求非常高的场景呢？比如可以允许修改内容在10s内生效而不是立即生效，那么就可以结合无锁编程使用一种高效的方法：</p>
<p>用指针来访问这个共享对象，写线程修改对象时，不直接在对象上进行修改，而是新建一个对象进行赋值，赋值完成后，再通过CAS将指针指向这个新的对象，然后销毁旧的对象。通过这种方法，可以将临界区从一大段代码缩减为一句代码，极大的减少了对读线程的影响。</p>
<p>修改指针这一步只有一条代码语句，虽然也可以用加锁的方式来保证线程安全，但是恰好无锁编程也是只能对一条语句进行操作，所以无锁编程非常符合这种方式，往往一想到无锁编程就想到这种方法。</p>
<h3 id="无锁队列"><a href="#无锁队列" class="headerlink" title="无锁队列"></a>无锁队列</h3><blockquote>
<p>如果一秒只需要处理几百或者几千的数据，是没有必要考虑用无锁队列的。用互斥锁就能解决问题，数据量相对少的时候互斥锁与无锁队列之间差别并不是很明显。</p>
</blockquote>
<p>无锁队列是lock-free中最基本的数据结构，一般应用场景是资源分配，比如TimerId的分配，WorkerId的分配，上电内存初始块数的申请等等。对于多线程用户来说，<strong>无锁队列的入队和出队操作是线程安全的</strong>，不用再加锁控制。</p>
<ul>
<li>initQueue初始化队列：根据unitSize和maxUnitNum申请内存，并对内存进行初始化。</li>
<li>enQueue入队：从队尾增加元素</li>
<li>dequeue出队：从队头删除元素</li>
<li>getQueueSize获取队列大小：返回队列中的元素数</li>
<li>isQueueEmpty队列是否为空：true表示队列为空，false表示队列非空</li>
</ul>
<h4 id="开源无锁队列"><a href="#开源无锁队列" class="headerlink" title="开源无锁队列"></a>开源无锁队列</h4><ul>
<li><strong>Boost库</strong>：Boost库提供了<code>boost::lockfree::queue</code>，这是一个支持多个生产者和多个消费者线程的无锁队列。此外，Boost库还提供了<code>boost::lockfree::stack</code>（无锁栈）和<code>boost::lockfree::spsc_queue</code>(仅支持单个生产者和单个消费者线程的无锁队列)。</li>
<li><strong>ConcurrentQueue</strong>：<a target="_blank" rel="noopener" href="https://github.com/cameron314/concurrentqueue">ConcurrentQueue</a>是一个基于C++实现的工业级无锁队列方案。</li>
<li><strong>ReaderWriterQueue</strong>：<a target="_blank" rel="noopener" href="https://github.com/cameron314/readerwriterqueue">ReaderWriterQueue</a>是一个基于C++实现的单生产者单消费者场景的无锁队列方案。</li>
<li><a target="_blank" rel="noopener" href="https://gitee.com/videoaudioer/lockfreequeue"><strong>lockfreequeue</strong>：lockfreequeue是一个使用C++11原子操作实现的高性能自旋锁队列</a>。</li>
</ul>
<h1 id="软件事务内存和协程"><a href="#软件事务内存和协程" class="headerlink" title="软件事务内存和协程"></a>软件事务内存和协程</h1><blockquote>
<p>并发编程领域不断发展，新的模式和技术持续出现。无锁编程正成为一种越来越受欢迎的方法，但同时新的同步原语和库也在不断涌现。例如，软件事务内存（Software Transactional Memory, STM）和协程（Coroutines）提供了新的并发处理方式。</p>
<p>正如计算机科学家 Edsger Dijkstra 曾指出：“<strong>简单性是成功复杂系统设计的关键</strong>。” 无论选择哪种并发策略，始终需要在性能、复杂性、可维护性和未来可扩展性之间找到平衡点。</p>
</blockquote>
<h1 id="如何排查并发编程死锁问题"><a href="#如何排查并发编程死锁问题" class="headerlink" title="如何排查并发编程死锁问题"></a>如何排查并发编程死锁问题</h1><p>[[linux基础以及系统编程#如何避免死锁|如何避免死锁参阅]]</p>
<p>如果死锁已经发生,又应该如何排查呢?</p>
<h2 id="使用gdb等调试工具来排查"><a href="#使用gdb等调试工具来排查" class="headerlink" title="使用gdb等调试工具来排查"></a>使用gdb等调试工具来排查</h2><p>在运行时检查线程的状态,找出死锁的原因</p>
<p><code>ps aux | grep  xxxx</code></p>
<p><code>top -Hp xxxx的pid</code></p>
<p>查看进程的cpu利用率,如果cpu利用率和内存异常低,可能是发生了死锁</p>
<p>使用gdb <code>info threads</code>去查看线程情况,结合线程调用栈<code>bt 线程编号</code>,定位到线程的代码,如果刚好是在等锁的代码上,就要留意这块的逻辑是否陷入了死锁.</p>
<blockquote>
<p>使用lldb的话命令有所不同,比如说<code>thread list</code>和<code>thread backtrace 线程编号</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202404131505391.png" alt="image-20240413150549654" style="zoom: 25%;" />定位到行:<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202404131506402.png" alt="image-20240413150620177" style="zoom:25%;" /></p>
</blockquote>
<h2 id="Valgrind"><a href="#Valgrind" class="headerlink" title="Valgrind"></a>Valgrind</h2><p>支持Linux&#x2F;Mac不支持windows系统</p>
<p>Valgrind是另一个强大的工具，它提供了一系列的内存调试和分析工具。其中的Helgrind工具专门用于检测多线程程序中的同步错误，包括死锁。Helgrind通过分析程序的运行，识别竞争条件、锁顺序不一致等问题，帮助开发者定位和解决死锁问题。</p>
<p>windows上可以使用Process Explorer来排查死锁</p>
<h2 id="Linux-Perf-Tools"><a href="#Linux-Perf-Tools" class="headerlink" title="Linux Perf Tools"></a>Linux Perf Tools</h2><p>Linux Perf Tools是一组性能分析工具，它可以用来分析程序的运行时性能，包括CPU使用情况、缓存命中率、上下文切换次数等。这些工具对于理解程序的运行时行为，包括可能导致死锁的情况，非常有帮助。</p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4" title="头像" alt="头像"></a><div class="post-copyright__author_name">ZEROKO14</div><div class="post-copyright__author_desc">zeroko14's blog</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://che77a38.github.io/posts/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://che77a38.github.io/posts/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B/')">C++多线程</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://che77a38.github.io/posts/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=C++多线程&amp;url=https://che77a38.github.io/posts/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B/&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://che77a38.github.io" target="_blank">ZEROKO14的个人博客</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/C/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>C++<span class="tagsPageCount">5</span></a><a class="post-meta__box__tags" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>多线程<span class="tagsPageCount">1</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">并发模式</div></div></a></div><div class="next-post pull-right"><a href="/posts/slidev/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">slidev</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/posts/C++11%E4%B8%8E14/" title="C++11与14"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-11-28</div><div class="title">C++11与14</div></div></a></div><div><a href="/posts/opencv/" title="opencv"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-04-29</div><div class="title">opencv</div></div></a></div><div><a href="/posts/C++%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7%E7%9B%98%E7%82%B9/" title="C++相关工具盘点"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-04-22</div><div class="title">C++相关工具盘点</div></div></a></div><div><a href="/posts/mac%E5%8F%8Alinux_C++%E7%8E%AF%E5%A2%83/" title="mac及linux C++环境配置"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-07-16</div><div class="title">mac及linux C++环境配置</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description">欢迎来到ZEROKO14的个人博客</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">ZEROKO14</h1><div class="author-info__desc">zeroko14's blog</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/che77a38" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5%E5%8C%BA%E5%88%86"><span class="toc-number">2.</span> <span class="toc-text">多线程概念区分</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C"><span class="toc-number">2.1.</span> <span class="toc-text">并发与并行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5"><span class="toc-number">2.2.</span> <span class="toc-text">同步与异步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B-vs-%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B"><span class="toc-number">2.3.</span> <span class="toc-text">多线程编程 vs 单线程异步编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E4%B8%80%E5%AE%9A%E6%98%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%90%97"><span class="toc-number">2.4.</span> <span class="toc-text">异步一定是多线程吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E5%92%8C%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.5.</span> <span class="toc-text">协程和异步编程的关系</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Thread%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">Thread类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%95%E6%97%B6%E6%89%A7%E8%A1%8C"><span class="toc-number">3.1.</span> <span class="toc-text">何时执行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">3.2.</span> <span class="toc-text">线程函数参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E7%BA%BF%E7%A8%8B%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.1.</span> <span class="toc-text">函数作为线程函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E7%BA%BF%E7%A8%8B%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.2.</span> <span class="toc-text">成员函数作为线程函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E7%BA%BF%E7%A8%8B%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.3.</span> <span class="toc-text">函数对象作为线程函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BD%9C%E4%B8%BA%E7%BA%BF%E7%A8%8B%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.4.</span> <span class="toc-text">lambda表达式作为线程函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%8F%82%E6%95%B0%E4%BC%A0%E5%BC%95%E7%94%A8"><span class="toc-number">3.2.5.</span> <span class="toc-text">线程参数传引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#std-ref"><span class="toc-number">3.2.5.1.</span> <span class="toc-text">std::ref</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#std-cref"><span class="toc-number">3.2.5.2.</span> <span class="toc-text">std::cref</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Thread%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">3.3.</span> <span class="toc-text">Thread的成员函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#join-detach"><span class="toc-number">3.3.1.</span> <span class="toc-text">join&#x2F;detach</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#swap"><span class="toc-number">3.3.2.</span> <span class="toc-text">swap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#native-handle"><span class="toc-number">3.3.3.</span> <span class="toc-text">native_handle</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E6%95%B0"><span class="toc-number">3.3.4.</span> <span class="toc-text">硬件线程并发数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#this-thread"><span class="toc-number">4.</span> <span class="toc-text">this_thread</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E4%BA%92%E6%96%A5%E4%BD%93%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">5.</span> <span class="toc-text">通用互斥体管理器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#lock-guard"><span class="toc-number">5.1.</span> <span class="toc-text">lock_guard</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%8F%82%E6%95%B0adopt-lock"><span class="toc-number">5.1.1.</span> <span class="toc-text">第二个参数adopt_lock</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unique-lock"><span class="toc-number">5.2.</span> <span class="toc-text">unique_lock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%8F%82%E6%95%B0"><span class="toc-number">5.2.1.</span> <span class="toc-text">第二个参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unique-lock%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">5.2.2.</span> <span class="toc-text">unique_lock成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unique-lock%E6%89%80%E6%9C%89%E6%9D%83%E8%BD%AC%E7%A7%BB"><span class="toc-number">5.2.3.</span> <span class="toc-text">unique_lock所有权转移</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#shared-lock"><span class="toc-number">5.3.</span> <span class="toc-text">shared_lock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#scoped-lock"><span class="toc-number">5.4.</span> <span class="toc-text">scoped_lock</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mutex%E7%B3%BB%E5%88%97"><span class="toc-number">6.</span> <span class="toc-text">mutex系列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#lock-unlock"><span class="toc-number">6.1.</span> <span class="toc-text">lock&#x2F;unlock</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%95%E6%AC%A1%E8%B0%83%E7%94%A8"><span class="toc-number">7.</span> <span class="toc-text">单次调用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">8.</span> <span class="toc-text">条件变量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#condition-variable"><span class="toc-number">8.1.</span> <span class="toc-text">condition_variable</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">8.1.1.</span> <span class="toc-text">成员函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95"><span class="toc-number">8.2.</span> <span class="toc-text">简单测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%85%E4%BD%BF%E7%94%A8%E4%BA%92%E6%96%A5%E4%BD%93"><span class="toc-number">8.2.1.</span> <span class="toc-text">仅使用互斥体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">8.2.2.</span> <span class="toc-text">使用条件变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#notify-all-at-thread-exit%E5%87%BD%E6%95%B0"><span class="toc-number">8.3.</span> <span class="toc-text">notify_all_at_thread_exit函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#promise-future%E6%A8%A1%E5%9E%8B"><span class="toc-number">9.</span> <span class="toc-text">promise\future模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#future"><span class="toc-number">9.1.</span> <span class="toc-text">future</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#future%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">9.1.1.</span> <span class="toc-text">future成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#future%E7%9A%84%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.1.2.</span> <span class="toc-text">future的源码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#future%E6%9E%84%E9%80%A0%E6%BA%90%E7%A0%81"><span class="toc-number">9.1.2.1.</span> <span class="toc-text">future构造源码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#get%E5%87%BD%E6%95%B0%E6%BA%90%E7%A0%81"><span class="toc-number">9.1.2.2.</span> <span class="toc-text">get函数源码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#future%E6%9E%90%E6%9E%84%E6%BA%90%E7%A0%81"><span class="toc-number">9.1.2.3.</span> <span class="toc-text">future析构源码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#promise"><span class="toc-number">9.2.</span> <span class="toc-text">promise</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-1"><span class="toc-number">9.2.1.</span> <span class="toc-text">成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#promise%E7%9A%84%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.2.2.</span> <span class="toc-text">promise的源码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#promise%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">9.2.2.1.</span> <span class="toc-text">promise默认构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#get-future%E7%9A%84%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.2.2.2.</span> <span class="toc-text">get_future的源码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#set-value%E7%9A%84%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.2.2.3.</span> <span class="toc-text">set_value的源码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#promise%E6%9E%90%E6%9E%84%E6%BA%90%E7%A0%81"><span class="toc-number">9.2.2.4.</span> <span class="toc-text">promise析构源码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%8A%B6%E6%80%81%E6%BA%90%E7%A0%81"><span class="toc-number">9.3.</span> <span class="toc-text">内部状态源码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E7%8A%B6%E6%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.3.1.</span> <span class="toc-text">关联状态对象的代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#assoc-state"><span class="toc-number">9.3.1.1.</span> <span class="toc-text">__assoc_state</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#set-value%E6%BA%90%E7%A0%81"><span class="toc-number">9.3.1.1.1.</span> <span class="toc-text">set_value源码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#move%E5%87%BD%E6%95%B0%E6%BA%90%E7%A0%81"><span class="toc-number">9.3.1.1.2.</span> <span class="toc-text">move函数源码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#on-zero-shared%E6%BA%90%E7%A0%81"><span class="toc-number">9.3.1.1.3.</span> <span class="toc-text">__on_zero_shared源码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#assoc-sub-state"><span class="toc-number">9.3.2.</span> <span class="toc-text">__assoc_sub_state</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#async"><span class="toc-number">9.4.</span> <span class="toc-text">async</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E4%BD%BF%E7%94%A8async%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%BC%BC%E6%95%88%E6%9E%9C%E6%A1%88%E4%BE%8B"><span class="toc-number">9.4.1.</span> <span class="toc-text">不使用async实现类似效果案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%8F%82%E6%95%B0"><span class="toc-number">9.4.2.</span> <span class="toc-text">回调参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%9B%9E%E8%B0%83%E5%8F%82%E6%95%B0%E6%A1%88%E4%BE%8B"><span class="toc-number">9.4.2.1.</span> <span class="toc-text">函数作为回调参数案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%9B%9E%E8%B0%83%E5%8F%82%E6%95%B0%E6%A1%88%E4%BE%8B"><span class="toc-number">9.4.2.2.</span> <span class="toc-text">成员函数作为回调参数案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E5%9B%9E%E8%B0%83%E5%8F%82%E6%95%B0%E6%A1%88%E4%BE%8B"><span class="toc-number">9.4.2.3.</span> <span class="toc-text">函数对象作为回调参数案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BD%9C%E4%B8%BA%E5%9B%9E%E8%B0%83%E5%8F%82%E6%95%B0%E6%A1%88%E4%BE%8B"><span class="toc-number">9.4.2.4.</span> <span class="toc-text">Lambda表达式作为回调参数案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#async%E7%9A%84%E5%8F%B3%E5%80%BC%E6%9E%90%E6%9E%84%E9%97%AE%E9%A2%98"><span class="toc-number">9.4.3.</span> <span class="toc-text">async的右值析构问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#future%E5%92%8Cpromise%E4%B9%8B%E9%97%B4%E7%9A%84%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">9.5.</span> <span class="toc-text">future和promise之间的并发安全和线程同步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#future%E5%92%8Cpromise%E4%B9%8B%E9%97%B4%E7%9A%84%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8"><span class="toc-number">9.6.</span> <span class="toc-text">future和promise之间的异常安全</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#packaged-task"><span class="toc-number">9.7.</span> <span class="toc-text">packaged_task</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8ECSharp%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.8.</span> <span class="toc-text">与CSharp异步编程模型的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E5%BA%93"><span class="toc-number">10.</span> <span class="toc-text">原子库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F"><span class="toc-number">10.1.</span> <span class="toc-text">原子变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8B"><span class="toc-number">10.1.1.</span> <span class="toc-text">原子类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B%E9%80%82%E7%94%A8%E4%BA%8E%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-number">10.1.2.</span> <span class="toc-text">哪些类型适用于原子操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8B%E5%87%BD%E6%95%B0"><span class="toc-number">10.2.</span> <span class="toc-text">原子类型函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">10.2.1.</span> <span class="toc-text">使用示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%9A%84atomic-flag"><span class="toc-number">10.2.2.</span> <span class="toc-text">特殊的atomic_flag</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#memory-order%E7%9A%84%E6%9E%9A%E4%B8%BE%E5%80%BC"><span class="toc-number">10.3.</span> <span class="toc-text">memory_order的枚举值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">10.3.1.</span> <span class="toc-text">顺序一致性的核心概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%92%8C%E9%87%8A%E6%94%BE%E8%AF%AD%E4%B9%89"><span class="toc-number">10.3.2.</span> <span class="toc-text">获取和释放语义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">10.4.</span> <span class="toc-text">性能与安全性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E9%94%81%E7%BC%96%E7%A8%8B"><span class="toc-number">10.5.</span> <span class="toc-text">无锁编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%97%A0%E9%94%81"><span class="toc-number">10.5.1.</span> <span class="toc-text">为什么要无锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%97%A0%E9%94%81"><span class="toc-number">10.5.2.</span> <span class="toc-text">如何无锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">10.5.2.1.</span> <span class="toc-text">工作原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E9%94%81%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF"><span class="toc-number">10.5.3.</span> <span class="toc-text">无锁编程技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E4%BF%9D%E5%BA%8F"><span class="toc-number">10.5.3.1.</span> <span class="toc-text">内存保序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E9%94%81%E7%BC%96%E7%A8%8B%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E5%AF%B9%E4%B8%80%E4%B8%AA%E5%BE%88%E5%A4%A7%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-number">10.5.3.2.</span> <span class="toc-text">无锁编程如何控制对一个很大的对象的访问</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97"><span class="toc-number">10.5.4.</span> <span class="toc-text">无锁队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E6%BA%90%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97"><span class="toc-number">10.5.4.1.</span> <span class="toc-text">开源无锁队列</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E4%BA%8B%E5%8A%A1%E5%86%85%E5%AD%98%E5%92%8C%E5%8D%8F%E7%A8%8B"><span class="toc-number">11.</span> <span class="toc-text">软件事务内存和协程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98"><span class="toc-number">12.</span> <span class="toc-text">如何排查并发编程死锁问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8gdb%E7%AD%89%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E6%9D%A5%E6%8E%92%E6%9F%A5"><span class="toc-number">12.1.</span> <span class="toc-text">使用gdb等调试工具来排查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Valgrind"><span class="toc-number">12.2.</span> <span class="toc-text">Valgrind</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux-Perf-Tools"><span class="toc-number">12.3.</span> <span class="toc-text">Linux Perf Tools</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/%E7%89%A9%E7%90%86/" title="物理">物理</a><time datetime="2025-09-29T01:48:42.561Z" title="发表于 2025-09-29 09:48:42">2025-09-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/%E5%B7%A5%E4%B8%9A%E7%9B%B8%E5%85%B3/" title="工业相关">工业相关</a><time datetime="2025-02-14T03:04:40.761Z" title="发表于 2025-02-14 11:04:40">2025-02-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3/" title="嵌入式相关">嵌入式相关</a><time datetime="2025-02-14T03:04:40.761Z" title="发表于 2025-02-14 11:04:40">2025-02-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/" title="操作系统">操作系统</a><time datetime="2024-12-16T01:38:01.470Z" title="发表于 2024-12-16 09:38:01">2024-12-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/%E8%AE%A1%E7%BB%84/" title="计算机组成原理">计算机组成原理</a><time datetime="2024-12-16T01:38:01.470Z" title="发表于 2024-12-16 09:38:01">2024-12-16</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2025 By <a class="footer-bar-link" href="/" title="ZEROKO14" target="_blank">ZEROKO14</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu"></a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">74</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">57</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">6</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AI/" style="font-size: 0.88rem;">AI<sup>1</sup></a><a href="/tags/C/" style="font-size: 0.88rem;">C#<sup>3</sup></a><a href="/tags/C/" style="font-size: 0.88rem;">C++<sup>5</sup></a><a href="/tags/CSS/" style="font-size: 0.88rem;">CSS<sup>1</sup></a><a href="/tags/CSharp/" style="font-size: 0.88rem;">CSharp<sup>1</sup></a><a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 0.88rem;">C语言<sup>1</sup></a><a href="/tags/FPS/" style="font-size: 0.88rem;">FPS<sup>1</sup></a><a href="/tags/HTML/" style="font-size: 0.88rem;">HTML<sup>1</sup></a><a href="/tags/JavaScript/" style="font-size: 0.88rem;">JavaScript<sup>1</sup></a><a href="/tags/MFC/" style="font-size: 0.88rem;">MFC<sup>1</sup></a><a href="/tags/PE/" style="font-size: 0.88rem;">PE<sup>1</sup></a><a href="/tags/QT/" style="font-size: 0.88rem;">QT<sup>1</sup></a><a href="/tags/WPF/" style="font-size: 0.88rem;">WPF<sup>3</sup></a><a href="/tags/ai/" style="font-size: 0.88rem;">ai<sup>1</sup></a><a href="/tags/cmake/" style="font-size: 0.88rem;">cmake<sup>1</sup></a><a href="/tags/doxygen/" style="font-size: 0.88rem;">doxygen<sup>1</sup></a><a href="/tags/git/" style="font-size: 0.88rem;">git<sup>1</sup></a><a href="/tags/linux/" style="font-size: 0.88rem;">linux<sup>1</sup></a><a href="/tags/nas/" style="font-size: 0.88rem;">nas<sup>1</sup></a><a href="/tags/next/" style="font-size: 0.88rem;">next<sup>1</sup></a><a href="/tags/ppt/" style="font-size: 0.88rem;">ppt<sup>1</sup></a><a href="/tags/python/" style="font-size: 0.88rem;">python<sup>1</sup></a><a href="/tags/slidev/" style="font-size: 0.88rem;">slidev<sup>1</sup></a><a href="/tags/vue/" style="font-size: 0.88rem;">vue<sup>1</sup></a><a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 0.88rem;">代码规范<sup>1</sup></a><a href="/tags/%E5%86%85%E6%A0%B8/" style="font-size: 0.88rem;">内核<sup>2</sup></a><a href="/tags/%E5%86%85%E6%A0%B8%E7%9B%B8%E5%85%B3/" style="font-size: 0.88rem;">内核相关<sup>5</sup></a><a href="/tags/%E5%8A%A0%E8%A7%A3%E5%AF%86/" style="font-size: 0.88rem;">加解密<sup>1</sup></a><a href="/tags/%E5%9F%BA%E7%A1%80/" style="font-size: 0.88rem;">基础<sup>6</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 0.88rem;">多线程<sup>1</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F/" style="font-size: 0.88rem;">并发模式<sup>1</sup></a><a href="/tags/%E5%BC%80%E5%8F%91/" style="font-size: 0.88rem;">开发<sup>4</sup></a><a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 0.88rem;">数学<sup>1</sup></a><a href="/tags/%E6%9D%82%E9%A1%B9/" style="font-size: 0.88rem;">杂项<sup>1</sup></a><a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 0.88rem;">正则表达式<sup>1</sup></a><a href="/tags/%E7%89%A9%E7%90%86/" style="font-size: 0.88rem;">物理<sup>1</sup></a><a href="/tags/%E7%9B%91%E6%8E%A7/" style="font-size: 0.88rem;">监控<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 0.88rem;">网络<sup>3</sup></a><a href="/tags/%E9%80%86%E5%90%91/" style="font-size: 0.88rem;">逆向<sup>5</sup></a><a href="/tags/%E9%AD%94%E6%B3%95/" style="font-size: 0.88rem;">魔法<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.cbd.int/mathjax@3.2.2/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.cbd.int/mermaid@10.2.4/dist/mermaid.min.js').then(runMermaid)
  }

  anzhiyu.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>