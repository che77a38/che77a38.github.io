<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>算法 | ZEROKO14的个人博客</title><meta name="keywords" content="算法"><meta name="author" content="ZEROKO14"><meta name="copyright" content="ZEROKO14"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#18171d"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="算法"><meta name="application-name" content="算法"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#18171d"><meta property="og:type" content="article"><meta property="og:title" content="算法"><meta property="og:url" content="https://che77a38.github.io/posts/%E7%AE%97%E6%B3%95/index.html"><meta property="og:site_name" content="ZEROKO14的个人博客"><meta property="og:description" content="算法是指解决问题的方法(或过程),是若干指令的有穷序列 算法的本质就是「穷举」  算法的本质都是穷举二（多）叉树，有机会的话通过剪枝或者备忘录的方式减少冗余计算，提高效率    利用计算机的速度,解决现实中的抽象问题 穷举要做到两点  无遗漏 无冗余  遗漏会导致算法错误,冗余会拖慢算法运行速度 算"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4"><meta property="article:author" content="ZEROKO14"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4"><meta name="description" content="算法是指解决问题的方法(或过程),是若干指令的有穷序列 算法的本质就是「穷举」  算法的本质都是穷举二（多）叉树，有机会的话通过剪枝或者备忘录的方式减少冗余计算，提高效率    利用计算机的速度,解决现实中的抽象问题 穷举要做到两点  无遗漏 无冗余  遗漏会导致算法错误,冗余会拖慢算法运行速度 算"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://che77a38.github.io/posts/%E7%AE%97%E6%B3%95/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2024/07/27/125766904/ba62475f396df9de3316a08ed9e65d86_5680958632268053399..png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":true,"limitCount":50,"languages":{"author":"作者: ZEROKO14","link":"链接: ","source":"来源: ZEROKO14的个人博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'ZEROKO14的个人博客',
  title: '算法',
  postAI: '',
  pageFillDescription: '算法入门, 时间复杂度, 空间复杂度, 算法概述, 问题建模, 图灵机, 排序算法, 冒泡排序, 选择排序, 插入排序, 快速排序, 归并排序, 堆排序, 计数排序, 随眠排序, 查找算法, 二分查找, 字符串匹配算法, KMP算法, 生成next数组函数, kmp搜索函数, BM算法, 坏字符规则, 好后缀规则, Sunday算法, 原理, 编码, 多种算法间的比较, 贪心算法, 排列组合公式, 排列公式, 去重, 组合公式, 排列与组合的关系, 动态规划, 动态规划与其他思想的差异, 分治算法与动态规划——重叠子问题, 与动态规划——最优子结构, 以赌场的骰子算法为例, 增益校正算法, 路径规划算法, Dijkstra算法, 校验算法, CRC校验算法, CRC16, 校验和计算, 令人惊叹的平方根算法, 平方根快速计算算法, 闭环控制算法, PID控制算法, PID公式, PID代码, 现成的pid算法, PID变种, PID参数评估, 时域指标(动态响应), 频域指标(鲁棒性), PID调参参考, 适用于非线性系统的控制算法, 模糊控制算法, 模型预测控制, 其他控制算法, 多因子PID控制, 多变量并行PID控制, 用于PID的温度仿真模拟, 快速傅里叶变换算法, 基于fft的快速快速乘法, 物理仿真算法, 运动学算法, 正向运动学, 反向运动学, 碰撞检测, FABRIK, FABRIK基本原理, LQR控制器, 工业上的平滑算法, 卡拉楚巴算法, 滤波器, 常用滤波器介绍, 中值滤波, 一阶(αβ)滤波, 巴特沃斯滤波, 卡尔曼滤波, 波函数坍缩算法, 熵, 回溯机制, 总结, 模拟退火算法, 鸟群模拟算法, 避障算法, 插值算法, 线性插值, 样条插值, 拉格朗日算法, 贝塞尔曲线, 公式, 分段贝塞尔曲线, 曲线相关算法, 曲线平滑, 圆角平滑算法, 超椭圆, 曲线相似算法, Fréchet距离算法, 计算方式, 动态规划矩阵的填充步骤, 动态规划表格的实际构建演示, 递归实现代码案例, 曲线抽稀, Douglas-Peucker算法, 案例, 垂距限值法, 曲线趋势中心点, 数值分析曲线拟合算法和函数逼近, 动态时间归整, 离群点x2F异常点查找算法, 离群点x2F异常点介绍, 难点, 异常检测算法的分类, 异常检测的经典思想模型, 统计检验方法, 基于偏差的方法, 基于距离的方法, 基于密度的方法, 深度学习方法–Autoencoder, 方法盘点, 四分位距法, Z-score, 箱线图法, 孤立森林算法, 理解, 具体步骤, 常数𝑐(𝑛)的计算, 实现代码, 定义节点类, 构建孤立树, 计算路径长度, 计算异常得分, 使用孤立森林算法, 一维孤立森林完整代码, 添加并行处理的一维孤立森林代码, 适用场景, 其他更高级的算法, 回归分析, 线性拟合, 最小二乘法, 图算法, Union Find并查集算法, 回溯算法, 引力模拟算法, 一些算法技巧, double类型带容差的哈希判断, 异或运算, Boyer-Moore投票算法, 快慢指针, Floyd判圈算法, 链表中的哑节点, 前缀和, 差分数组, 荷兰国旗问题, 巧妙的递归解法思路盘点, 对称二叉树, 全排列, 子集, 巧妙的算法解决记录, 15.三数之和, 128.最长连续序列, 878.第N个神奇数字, 待解决算法是指解决问题的方法或过程是若干指令的有穷序列算法的本质就是穷举算法的本质都是穷举二多叉树有机会的话通过剪枝或者备忘录的方式减少冗余计算提高效率利用计算机的速度解决现实中的抽象问题穷举要做到两点无遗漏无冗余遗漏会导致算法错误冗余会拖慢算法运行速度算法的难点在于两类问题如何穷举递归算法往往解决的是这类问题如何聪明的穷举比如后文并查集算法详解告诉你一种高效计算连通分量的技巧理论上说想判断两个节点是否连通用暴力搜索穷举肯定可以做到但人家算法硬是用数组模拟树结构给你把连通性相关的操作复杂度给干到了再比如贪心算法技巧所谓贪心算法就是在题目中发现一些规律专业点叫贪心选择性质使得你不用完整穷举所有解就可以得出答案动态规划好歹是无冗余地穷举所有解然后找一个最值贪心算法倒好都不用穷举所有解就可以找到答案所以后文贪心算法解决跳跃游戏中贪心算法的效率比动态规划还高再比如大名鼎鼎的算法算法的本质是聪明地缓存并复用一些信息减少了冗余计算后文字符匹配算法就是使用计算机的思路实现的算法顺便强调下算法工程师做的这个算法和数据结构与算法中的这个算法完全是两码事对前者来说重点在数学建模和调参经验计算机真就只是拿来做计算的工具而已而后者的重点是计算机思维需要你能够站在计算机的视角抽象化简实际问题然后用合理的数据结构去解决问题所以你千万别以为学好了数据结构和算法就能去做算法工程师也不要以为只要不做算法工程师就不需要学习数据结构和算法坦白说大部分开发岗位工作中都是基于现成的开发框架做事不怎么会碰到底层数据结构和算法相关的问题但另一个事实是只要找技术相关的岗位数据结构和算法的考察是绕不开的因为这块知识点是公认的程序员基本功为了区分不妨称算法工程师研究的算法为数学算法称刷题面试的算法为计算机算法此篇内容主要聚焦的是计算机算法计算机算法的思维恰恰相反有没有什么数学公式就交给你们人类去推导吧如果能找到一些巧妙的定理那最好但如果找不到那就穷举呗反正只要复杂度允许没有什么答案是穷举不出来的算法导论麻省理工前人学习经验大佬非常全面的博客算法入门时间复杂度时间复杂度是衡量算法执行时间的一个指标它表示算法运行时间随输入规模增长的趋势通常使用大符号表示描述算法在输入规模增大时的渐进行为举个例子冒泡排序算法的时间复杂度是这意味着算法的运行时间与输入规模的平方成正比也就是说当输入规模翻倍时算法的运行时间会变为原来的四倍时间复杂度可以有多种不同的衡量方式一种常见的方式是计算算法执行的操作次数另一种方式是测量算法在特定计算机上运行所需的时间时间复杂度在算法设计中非常重要因为它可以帮助确定算法的效率时间复杂度较高的算法可能不适用于大规模数据集因为它们可能需要太长的运行时间有许多技巧可以改善算法的时间复杂度一种常见的方法是使用分治策略将问题分解为更小的子问题以便更高效地解决另一种方法是使用动态规划将子问题的结果存储起来避免重复计算时间复杂度是一个复杂的主题没有一种通用的方法适用于所有算法然而通过了解不同的时间复杂度衡量方式并使用适当的技巧改善算法的时间复杂度可以设计出适用于各种问题的高效算法常数时间的操作一个操作如果和样本的数据量没有关系每次都是固定时间内完成的操作叫做常数操作时间复杂度为一个算法流程中常数操作数量的一个指标常用读作来表示具体来说先要对一个算法流程非常熟悉然后去写出这个算法流程中发生了多少常数操作进而总结出常数操作数量的表达式表达式中只要高阶项不要低阶项的系数阶未知数的次方数剩下的部分如果为那么时间复杂度为评价一个算法流程的好坏先看时间复杂度的指标然后再分析不同数据样本下的实际运行时间也就是常数项时间空间复杂度与时间复杂度相似但针对空间算法概述递归与分治动态规划贪心算法回溯算法分支限界法随机算法近似算法算法第一步是问题建模问题建模问题类型计数问题构造问题判定问题二元的最优化问题问题建模输入定义问题空间即特定对象集合输出定义解空间约束定义约束函数目标定义目标函数问题实例问题模型的实例化即一个给定输入的实际问题图灵机年提出了一种在理论计算机科学中广泛采用的抽象计算机它是通用数字计算机的理论原型图灵机可制造出一种十分简单但计算能力极强的计算机装置用有限的指令和有限的存储空间可算尽一切可算之物一台图灵机是一个七元组图灵机有限状态自动机无限纸带算尽一切可算之物排序算法概念排序是计算机内经常进行的一种操作其目的是将一组无序的数据元素调整为有序的数据元素排序数学定义假设含个数据元素的序列为其相应的关键字序列为这些关键字相互之间可以进行比较即在它们之间存在着这样一个关系按此固有关系将上式记录序列重新排列为的操作称作排序排序的稳定性如果在序列中有两个数据元素和它们的关键字且在排序之前对象排在前面如果在排序之后对象仍在前面则称这个排序方法是稳定的否则称这个排序方法是不稳定的内排序和外排序内排序在排序过程中待排序的所有记录全部都放置在内存中排序分为内排序和外排序外排序由于排序的记录个数太多不能同时放置在内存整个排序过程需要在内外存之间多次交换数据才能进行排序的审判时间性能关键性能差异体现在比较和交换的数量辅助存储空间为完成排序操作需要的额外的存储空间必要时可以空间换时间算法的实现复杂性过于复杂的排序法会影响代码的可读性和可维护性也可能影响排序的性能总结排序是数据元素从无序到有序的过程排序具有稳定性是选择排序算法的因素之一比较和交换是排序的基本操作多关键字排序与单关键字排序无本质区别排序的时间性能是区分排序算法好坏的主要因素其他的一些排序算法快速排序快速排序是一种基于分治思想的排序算法通过选择一个基准元素将数组分为两个子数组并递归地对子数组进行排序快速排序的平均时间复杂度为在大多数情况下具有较高的效率快速排序与下文的排序算法不是一个东西归并排序归并排序也是一种分治算法它将数组递归地分成两个子数组然后将两个有序子数组合并成一个有序数组归并排序的时间复杂度为并且具有稳定性堆排序堆排序利用堆这种数据结构进行排序通过构建最大堆或最小堆来实现排序堆排序的时间复杂度为并且具有原地排序的特点需要注意的是这些算法的性能取决于输入数据的规模和特征对于小规模的数据集简单的排序算法如插入排序和冒泡排序可能更高效对于已经部分有序的数据集插入排序和冒泡排序也可能比其他算法更快标准库中的函数使用了一种高效的排序算法通常是快速排序或归并排序冒泡排序时间复杂度是冒泡排序是一种效率低下的排序方法在数据规模很小时可以采用数据规模比较大时最好用其它排序方法上述例子对冒泡做了优化添加了作为标记记录序列是否已经有序减少循环次数选择排序时间复杂度是插入排序插入排序算法是一种简单的排序算法也成为直接插入排序算法它是一种稳定的排序算法对局部有序的数据具有较高的效率插入排序算法是一个队少量元素进行排序的有效算法比如打牌是我们使用插入排序方法最多的日常生活例子我们在摸牌时一般会重复一下步骤期初我们手里没有牌摸出第一张随意放在左手上以后每一次摸排都会按照花色从小到大排列直到所有的牌摸完插入排序算法采用的类似思路每一次从无序序列中拿出一个数据将它放到已排序的序序列的正确位置如此重复直到所有的无序序列中的数据都找到了正确位置插入排序的时间复杂度是在最坏的情况下需要比较和移动元素的次数是次其中是待排序数组的长度快速排序时间复杂度为下面代码是使用交换法实现的快排递归结束条件双指针选取第一个数为基准数不断往右移动左指针找到第一个大于基准数的数不断往左移动右指针找到第一个小于基准数的数意思就是的时候不交换会走向循环跳出交换中和指针指向的值一轮基准值定位已经结束该递归处理两边的数组了此时了用哪个无所谓归并排序时间复杂度为堆排序时间复杂度为堆排序是指利用堆这种数据结构所设计的一种排序算法堆积是一个近似完全二叉树的结构并同时满足堆积的性质即子结点的键值或索引总是小于或者大于它的父节点基本思想利用大顶堆小顶堆堆顶记录的是最大关键字最小关键字这一特性使得每次从无序中选择最大记录最小记录变得简单倒序对每个父节点进行下潜操作通过这个操作使得混乱数组具备堆序性如下流程反复调用函数来实现每次将最大元素移动到范围的末尾就可以实现堆排序函数的实现参考下面流程数据结构堆堆的详解点击跳转堆相关算法中也有提供各种现成函数计数排序计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中作为一种线性时间复杂度的排序计数排序要求输入的数据必须是有确定范围的整数找出待排序的数组中最大和最小的元素统计数组中每个值为的元素出现的次数存入数组的第项对所有的计数累加从中的第一个元素开始每一项和前一项相加反向填充目标数组将每个元素放在新数组的第项每放一个元素就将减去平均时间复杂度最佳时间复杂度最差时间复杂度空间复杂度随眠排序遍历数组对每个元素创建一个新线程该线程休眠的时间与元素的值成正比将排序任务委托给了的调度器查找算法二分查找无重复元素的升序排列数组中的插入查找给定一个排序数组和一个目标值在数组中找到目标值并返回其索引如果目标值不存在于数组中返回它将会被按顺序插入的位置灵魂就在于这个和下面的时间复杂度其中为数组的长度二分查找所需的时间复杂度为空间复杂度我们只需要常数空间存放若干变量字符串匹配算法算法一种改进的字符串匹配算法利用匹配失败后的信息尽量减少模式串与主串的匹配次数以达到快速匹配的目的将时间复杂度从变成数组含义为存放子串对应下标前存在的最长相等前后缀的长度相等前后缀不能是字符串本身生成数组函数递推思维通过已经掌握的信息来避免进行重复的运算生成数组数组含义为存放子串对应下标前存在的最长相等前后缀的长度前缀末尾指针也可以表示相等前后缀长度表示准备填写的数组下标跳过是因为函数中针对下标不使用数组的值前后相等情况相等就将累计的相等前缀长度赋给对应位置遇到前后不相等情况相等前后缀长度为相等前后缀长度不为可以利用之前的相等前后缀递推递推思维的关键代码更简洁的版本任何位置匹配到的同时就继续匹配下一个同时把当前匹配的数量写入搜索函数借助于数组生成数组主串为主串长度为子串为子串长度为展示数组分析得到的数组为开始查找子串下标主串下标匹配的话主串与子串下标相加子串非第一个就不匹配更新子串下标子串第一个就不匹配全都相等就跳出循环返回找到的下标算法字符串搜索算法字符串匹配算法全称是算法其核心思想是在模式串中某个字符与主串不能匹配的时候将模式串往后多滑动几位以此提高匹配的效率为了能够一次性多滑动几位在真正进行字符串匹配之前先进行了一系列预处理操作遵循坏字符规则和好后缀规则坏字符规则按模式串倒序匹配的过程中把匹配失败时主串中的字符叫做坏字符然后在模式串中查找坏字符若找到匹配字符则将模式串中的匹配字符和坏字符对齐否则直接将模式串滑动到坏字符之后的一位再重复进行上述过程把坏字符在模式串中的位置记为值如果坏字符在模式串中存在将坏字符在模式串中的下标记作值若不存在记作移动的位数就等于值把坏字符在模式串中的位置记为值如果坏字符在模式串中存在将坏字符在模式串中的下标记作值若不存在记作移动的位数就等于值注意单纯采用坏字符的策略计算出来的移动位数有可能是负数因此算法还需要使用好后缀规则来避免这种情况因此在该算法中可以省略坏字符规则却不能省略好后缀规则好后缀规则按模式串倒序匹配过程中失配点之后模式串中匹配成功的那段字符为好后缀好后缀规则在于考虑能否根据已经匹配成功的字符直接推算出下次移动的位置理论依据如果好后缀在模式串找不到另一个匹配子串只要整体还参与匹配就肯定无法匹配因为已经确定模式串中没有与和整体相同的字符串但若的部分后缀和模式串的前缀有重合且相等则有可能会完全匹配上图是只基于好后缀规则的匹配过程涉及后缀整体匹配和后缀子串和模式串前缀的匹配而下图则是坏字符好后缀两种规则的匹配方式具体选哪种取决于可移动的最大距离算法算法实际上是一种对算法的改进其基本思路与算法相似但是与算法不同的是算法的比较是从模式串的开头进行比较的并且算法在不匹配情况发生时模式串跳转的幅度更大所以从这一点上来说算法的效率甚至比算法更高原理从左到右比对当发现比对失败时候观察与模式串对齐的最后一位字符的下一位字符本例中就是文本串中的是否出现在模式串中这一做法的意图是如果文本串中与模式串对齐位置上的下一位字符也就是文本串中的并没有出现在文本串中的话那么就可以确定从失配字符向后一直到字符中间的这段内容与模式串肯定是不可能匹配了所以我们可以直接跳过这段内容直接将模式串跳转到字符后面的位置进行对齐然后重新开始比较依然以上图为例在进行模式串跳转之后我们发现文本串中的与模式串中的首先就是不匹配的但是此时在文本串中与模式串对齐的下一位字符在模式串中出现过此时我们将与模式串对齐的下一位字符与模式串中出现的位置对齐然后继续进行比较编码坏字表记录了是否有某个字符表示没有该字符又记录了字符最后出现的位置的每一个索引表示一个字符因为字符本身就能通过码表示为整数的值表示中的元素在末尾的哪一位出现初始化坏字表为为字串到的长度如果没匹配成功那么的索引向后移动位为模式串的长度该算法也常用于特征码查询下面代码为转载未测试删除所有空格特征码进程模块句柄特征码找偏移上负下正找基址偏移偏移是从特征码地址算起特征码删除特征码所有空格特征码长度特征码长度不能为单数定义一个字节变量并开辟指定长度的内存空间通配符首次位置模块开始地址模块大小模块结束地址存放读取的内存数据的缓冲区内存信息记录起始搜索时间结束条件开始扫描内存查询地址空间中内存地址的信息过滤内存空间根据内存的状态和保护属性进行过滤申请动态内存通配符首次位置是偏移为没有找到记录结束时间用时毫秒如果是找拷贝出对应地址上的机器码复制个字节返回用时毫秒下一条指令地址也就是目标地址如果是找基址拷贝出对应地址上的机器码复制个字节返回基址返回特征码地址取下一块内存地址没找到返回带通配符的字符串转字节数组通配符第次出现的位置通配符第次出现的位置通配符第次出现的位置通配符第次出现的位置通配符第次出现的位置偏移量数组下标内存特征码返回地址算法模板数组赋值防止特征码出现时越界通配符第次出现的位置以特征码长度进行循环代表通配符如果相等通配符第次出现的位置判断偏移量是否大于缓冲区判断模板数组里有没有内存偏移后的值有则回溯否则计算找到的目标地址特征码地址当前内存块基址偏移特征码长度多种算法间的比较算法适用于需要频繁匹配的场景能够保证线性时间复杂度算法在处理较长模式串或较大的字母表时表现较好适合于文本中出现模式串较少的情况算法通常在实际应用中表现得更快适合于大多数字符串匹配场景尤其是当模式串较短时贪心算法贪心算法又称贪婪法是寻找最优解问题的常用方法这种方法模式一般将求解过程分成若干个步骤但每个步骤都应用贪心原则选取当前状态下最好或最优的选择局部最有利的选择并以此希望最后堆叠出的结果也是最好或最优的解这就好像一个贪婪的人他事事都想要眼前看到最好的那个看不到长远的东西也不为最终的结果和将来着想贪图眼前局部的利益最大化有点走一步看一步的感觉例如假设你开了间小店不能电子支付钱柜里的货币只有分分分和分四种硬币如果你是售货员且要找给客户分钱的硬币如何安排才能找给客人的钱既正确且硬币的个数又最少这就是一个典型的贪心算法的应用场景然而贪心算法不能保证最后求得的解是最优的同时贪心算法只能求满足某些约束条件的可行解的范围如果一个问题的最优解只能用蛮力法穷举得到则贪心法不失为寻找问题近似最优解的一种较好的方法贪心算法的时间复杂度通常比较低但不一定能够得到全局最优解总的来说贪心算法是一种基于贪心策略的算法它在每一步选择中都采取在当前状态下最好或最优的选择从而希望导致结果是最好或最优的贪心算法通常适用于求解最优化问题如最小生成树最短路径背包问题等排列组合公式记忆有点模糊故写在此处以做温习排列组合公式推导简单理解更多公式推导排列公式排列需要考虑顺序排列或排列从个中取个排列的个数实际计算中往往不用阶乘从大的数字开始往小乘乘小的数字那么多个去重例有种排序方式而的排序方式有种意味着将视作个不同的元素而这与实际不符若两个是不同的交换后是种序但它们相同啊所以计算出的结果是将实际情况重复计算了次那么除以就是正确答案了同理可组成多少个位数答组合公式组合组合不需要考虑排序从个中取个组合的个数实际计算中往往不用阶乘从大的数字开始往小乘乘小的数字那么多个再除以小的数字开始往小乘乘小的数字那么多个排列与组合的关系动态规划动态规划是运筹学的一个分支求解决策过程最优值的一种思想求解最优解的时候需要想到动态规划本质就是给定一个大问题把它拆成一个个子问题直到子问题可以直接解决然后把子问题的答案保存起来以减少重复计算再根据子问题答案反推得到大问题解题的一种方法动态规划中最重要的两个概念重叠子问题最优子结构重叠子问题动态规划会将每个求解过的子问题的解记录下来这样当下一次碰到同样的子问题时就可以直接使用之前记录的结果而不是重复计算虽然动态规划使用这种方式来提高计算效率但不能说这种做法就是动态规划的核心如果一个问题可以被分解成若干个子问题且这些子问题会重复出现那么称这个问题拥有重叠子问题如果一个问题的最优解可以由其子问题的最优解有效地构造出来那么称这个问题拥有最优子结构最优子结构保证了动态规划中原问题的最优解可以由子问题的最优解推导而来一个问题必须拥有重叠子问题和最优子结构才能使用动态规划去解决动态规划通过额外空间避免重复计算来加速计算过程由于用到其余空间来保存计算结果因此也称之为记忆化搜索本质上是用空间换时间也有人叫他带备忘录的递归或者递归树的剪枝因为整个递归树不需要全部访问到仿佛有些枝叶被剪掉了上面说的递归也可以是迭代动态规划不一定得是递归动态规划的两种写法递推写法自底向上即从边界开始不断向上解决问题直到解决了目标问题递归写法自顶向下即从目标问题开始将它分解成子问题的组合直到分解至边界为至标准的动态规划实例爬楼梯问题动态规划与其他思想的差异分治算法与动态规划重叠子问题相同点将问题分解成子问题然后合并子问题的解得到原问题的解不同点分治法解决的问题不拥有重叠子问题解决的问题不一定是最优化问题动态规划解决的问题拥有重叠子问题解决的问题一定是最优化问题贪心算法与动态规划最优子结构相同点都要求原问题必须拥有最优子结构不同点贪心的计算方式类似于自顶向下但是并不等待所有子问题求解完毕后再选择使用哪一个而是通过一种策略直接选择一个子问题去求解没被选择的子问题就不会再去求解了动态规划的计算方式有自顶向下和自底向上两种都是从边界开始向上得到目标问题的解也就是说它总是会考虑所有子问题并选择继承能得到最优结果的那个对暂时没有被继承的子问题由于重叠子问题的存在后期可能会再次考虑它们因此还有机会成为全局最优的一部分不需要放弃最大子数组和这题同时有贪心算法解法和动态规划解法官方解释中有视频两种方式的视频讲解思路贪心算法若当前指针所指元素之前的和小于则丢弃当前元素之前的数列维护两个值当前和之前和动态规划若前一个元素大于则将其加到当前元素上这样实际上存储的就是一个不确定左边界到当前边界的最大和时间复杂度不如贪心算法以赌场的骰子算法为例参考视频问题就是通过个骰子掷出总数为有多少种方式递归回溯地思考问题通过将大问题分解为相似的小问题来解决以两个骰子为例掷出一个总点数为的话第二次掷出的点数必须为或所以要使总数为第一次掷骰必须分别为或是不可能的用一个骰子掷出点数为的方式都只有一种因此使用个骰子掷出个点数的方式是种准确地描述一个简单问题的解法能帮助我们找到更一般性的解决方案可以总结为对于用个骰子掷出点的总数那么前个骰子必须掷出或的总数这样就提供了一种递归算法用来解决该问题假设想用个骰子掷出的总和那么前个骰子的总和必须是或的一个将一个问题拆解为多个问题分别是用个骰子掷出这个小问题到这一步就完成了递归式的遍历但是如果仔细观察中间的步骤就会发现有很多重复性的计算因此可以采用类似缓存机制的方式来剪枝于是就能大幅提高效率这就是动态规划的原理通过递归的描述问题即使用较小版本的相同问题来定义问题再结合查找表保存我们已经完成的计算结果我们通常可以显著加速这些算法增益校正算法路径规划算法算法算法迎来新突破经典本科算法被证为普遍最优最坏性能也达极限校验算法校验算法循环冗余校验算法可以提供更强大的校验功能用于检测数据传输中的错误算法通过对数据进行多项式除法运算生成一个固定长度的校验码校验码用于校验数据在传输过程中是否发生了错误或被篡改算法相比简单的校验和方法具有以下优点更强的错误检测能力算法可以检测更多类型的错误包括单比特错误多比特错误以及一些特定的错误模式低错误漏检率算法的设计可以降低错误漏检率提高数据传输的可靠性固定长度的校验码算法生成的校验码长度固定不受数据长度影响便于在数据传输中使用在通信协议存储系统网络通信等领域算法被广泛应用于数据完整性校验通过计算接收数据的校验码并与发送数据的校验码进行比较接收方可以判断数据是否在传输过程中发生了错误从而保证数据的可靠传输计组循环冗余校验码更多理解可以参考计组以为例运行循环冗余校验算法于输入完成后返回位的值并始终在消息中添加个字节如果传入消息具有正确的则返回初始化值为当前处理的字节转换为类型用于存储每次移位后的最低位用于循环计数的变量存储最终计算出的高位和低位的值验证是否正确正确返回否则返回提取消息中的字节移除消息末尾的字节重新计算检查计算出的是否与消息末尾的相同也有查表法基于的实现摘要参数基于实现高字节初始化值低字节初始化值校验和计算数据分割将待发送的数据按照固定的单位如字节进行分割每个单位称为一个数据块加和计算对每个数据块中的值进行加和运算生成一个校验和值通常采用模加法二进制异或运算或者累加和的方式进行计算模加法的特点包括与传统加法不同模加法中进位被忽略只关注每个位上的值模加法满足交换律和结合律任何数与进行模加法得到原数任何数与自身进行模加法得到校验和附加将计算得到的校验和值附加到数据中一起发送给接收方接收端校验接收方在接收数据后对接收到的数据进行相同的加和计算得到一个校验和值比较校验和接收方将计算得到的校验和值与接收到的校验和值进行比较如果两者相等则数据传输过程中没有出现错误如果不相等则表示数据可能存在错误需要进行相应的处理如重新发送数据校验和是一种简单有效的数据完整性校验方法适用于对数据传输中的随机错误进行检测然而校验和并不能提供纠错能力只能检测错误并提示出错的可能性在需要更强大的错误检测和纠正能力时通常会采用更复杂的校验算法如循环冗余校验等令人惊叹的平方根算法平方根快速计算算法二分法和牛顿迭代法都可以用来计算平方根另外还有一种被称为神奇的方法的算法它使用了一个特殊的常数和牛顿迭代法来快速计算平方根闭环控制算法专业术语测量值这是控制系统中的一个术语指的是控制过程中实际测量到的值比如温度压力流量等过程变量的实时测量值在温度控制系统中通常指的是当前的温度读数是控制系统的反馈部分控制系统会根据与设定值之间的偏差来调整输出以保持过程的稳定设定值是用户设定的目标值即希望控制系统达到的值操作输出值控制输出值是控制器输出的控制信号用于驱动执行器如阀门电机等从而影响是控制器用来调整的控制动作的量级是控制器用来影响的输出信号而向靠近的过程是控制系统响应变化的结果的大小和方向取决于控制器如何解释与之间的偏差如果低于控制器可能会增加来增加输出例如打开阀门或增加加热如果高于控制器可能会减少来减少输出例如关闭阀门或减少加热控制算法控制是一种线性控制它将给定值与实际输出值的偏差的比例积分微分通过线性组合形成控制量对被控对象进行控制控制系统通常根据有没有反馈会分为开环系统和闭环系统在闭环系统的控制中算法非常强大工业应用上占了的应用比例使用起来简单无需精确建模其三个部分分别为比例比例组件根据过程距设定点的距离按比例施加作用力积分积分组件会努力将过程返回到设定点误差存在的时间越长量越大积分输出越大微分微分组件着眼于过程远离设定点的速度相当于预测未来的误差来调整输出适用于二阶以内的线性系统线性指满足齐次性和叠加性阶以内是指系统动态方程中导数的最高次数在以内针对高阶系统可以化为二阶系统针对非线性系统可以通过李雅普诺夫线性化近似为线性系统算法可以自动对控制系统进行准确且迅速的校正因此被广泛地应用于工业控制系统参考公式下面过程出自此博客控制的完整公式实际上是是误差实际上常用的是离散化后如下比例项离散化积分项离散化微分项离散化分别看比例项表示点的状态值与目标状态值的偏差如图就是积分项表示为下图三个颜色块的面积之和微分项表示下图中点的微分离散化后得到的离散表达式由于是固定值将归入中就得到了位置式根据可得到增量式的离散公式如下比例增益决定减少误差的速度的参数积分增益取决于之前所有误差的累积消除了稳态误差但也可能引入震荡微分增益取决于误差变化速度增加阻尼减弱震荡效果增加稳定性当偏差变化过快微分环节会输出较大的负数作为抑制输出继续上升从而抑制过冲位置式和增量式本质是同一个公式在真正使用控制算法的时候最好还要做到积分限幅积分分离微分先行代码比例增益积分增益微分增益循环间隔时间受控变量的最大值受控变量的最小值用指定的循环间隔时间最大和最小的受控变量值和以及比例微分和积分增益和初始化控制器根据设定点和当前过程值计算并返回受控变量计算误差比例项积分项微分项计算总输出限制在最大最小值范围内保存当前误差为上次误差测试代码现成的算法库里有控制器的封装是基于的算法实现提供基本的功能库内的头文件封装了控制器类支持增量式算法库中的类实现了离散控制器科学库中的函数提供了单点离散控制库中有类实现基本控制变种控制器仅使用比例和积分控制适用于对稳态误差要求较高的系统但不需要微分控制控制器仅使用比例和微分控制适用于快速响应的系统能够减少超调但不能消除稳态误差控制器经典的控制器结合了比例积分和微分控制适用于大多数工业控制系统自整定控制器具有自动调节参数的功能可以根据系统的响应自动调整和的值模糊控制器将模糊逻辑与控制相结合通过模糊规则来调整参数以适应非线性系统滑模控制在控制过程中引入滑模控制策略以提高系统的鲁棒性和抗干扰能力增益调度控制器根据系统状态或工作点动态调整参数适用于具有非线性特性的系统复合控制器将多个控制器级联在一起形成复合控制策略以提高控制性能位置控制器与速度控制器针对不同的控制需求分别设计用于位置控制和速度控制的控制器抗饱和控制器在积分部分引入抗饱和机制以防止积分风现象确保系统稳定性控制器的变种如这些变种根据具体需求调整了控制器的组成部分例如引入前馈控制调整积分和微分的计算方式等参数评估时域指标动态响应超调量响应曲线超过设定值的最大偏差百分比优秀参数应使超调量高精度场景要求上升时间响应从稳态值升至所需时间需平衡速度与超调过快易引发振荡调节时间系统进入并保持在设定值误差带内的时间代表收敛速度典型要求为系统主时间常数稳态误差系统稳定后与设定值的偏差积分项可消除稳态误差但过度会导致超调单位就是检测的值本身的单位峰值时间达到第一个峰值所需时间反映初始响应速度这些性能指标超调量上升时间调节时间稳态误差和峰值时间的计算只需要两个核心数据设定值控制系统期望达到的目标值过程变量被控对象实际反馈的测量值频域指标鲁棒性相位裕度开环传递函数在增益交界频率处的相位偏移量表明系统稳定增益裕度系统达到临界稳定前可增加的增益倍数为安全边界带宽系统有效跟踪输入信号的频率范围带宽越宽响应越快但噪声敏感性增加阶跃响应法整定法临界震荡法整定调参参考参考指标设定点曲线过程变量曲线控制输出曲线积分项曲线初始准备设置初始限幅初始按照物理限制设置输出限幅区间初始积分限幅为最大值最小值左右初始值调节值从纯开始小步增加找到临界振荡点临界增益临界周期初始工作点或倾向于更保守以缓解后续和积分限幅的压力调节值保留上一步得到的设定一个较小的例如或基于如小步长提高观察目标系统趋向稳定查看积分项曲线应该在积分限幅内活动暂时不要撞到限幅如果系统不稳定或震荡加剧减小或略微减小目标是得到一个有稳态误差但过程平稳的响应观察积分项的值是否达到了饱和积分限幅积分项没有饱和仍在积分限幅内说明当前的太小了稍微增大重复这个过程直到积分项开始接近积分饱和或者稳态误差消失积分项已经饱和但仍然有显著的稳态误差说明消除此误差所需的积分贡献超出了你设定的积分限幅此时保持不变仅小步幅增大积分限幅直到稳态误差归零或小于要求精度调节值保持调好的积分限幅加入小小步增大目标是抑制超调加快系统响应如果输出抖动输出噪声放大如果有则立即减小许多系统不需要特别是噪声大的系统整体微调适用于非线性系统的控制算法模糊控制自适应控制滑膜控制非线性反馈控制神经网络控制预测控制增益调度模糊控制算法模糊化是根据特定输入值的拟合程度将特定输入值转换为模糊集某种程度的隶属度的过程隶属函数描述特定输入或输出变量这些隶属函数可以用图形表示这些隶属函数有助于量化基于语言变量而不是精确数值做出决策所涉及的模糊逻辑模型预测控制是一种反馈控制技术基于数学模型预测系统未来行为的控制算法作为许多工业应用中强大且广泛使用的控制策略其他控制算法自适应控制算法神经网络控制算法多因子控制控制器可以实现多个控制因子对一个最终采样值的控制称为多输入单输出控制系统三种主要实现方法多变量并行控制协同控制矩阵法增益调度多变量并行控制各控制因子独立影响输出作用可线性叠加用于的温度仿真模拟电热丝功率比热容质量环境温度散热系数输出百分比当前温度开始仿真上一次的热量上一次的温度环境温度当前温度环境温度热量发热功率电热丝功率输出百分比使用上一次的温度计算散热功率避免循环依赖温度变化当前温度环境温度散热功率散热系数温度变化实际功率发热功率散热功率热量上一次的热量实际功率新温度变化比热容热量比热容质量当前温度环境温度新温度变化上一次的温度当前温度上一次的热量热量获取当前温度当前温度设置输出百分比输出百分比输出百分比输出百分比设置晶振快速傅里叶变换算法数学傅里叶变化参考傅里叶变换数学原理基于的快速快速乘法物理仿真算法运动学算法此处收录一个程序化动画技术视频链接生物模拟机械臂等都属于这个可用范围中设置一个锚点并通过数学圆参数方程圆参数方程约束下一个点的位置如果移动锚点下一个点也会跟随锚点移动将多个点用这种约束串联起来使每个点都能约束到下一个点当我们移动第一个点的时候整个链条会按照我们的约束的顺序跟随移动然后如果有需要可以添加每两节体节的角度平滑给定任意两体节若干角度差太大缩回至所需阈值正向运动学通过多个向量相加计算出目标的坐标点反向运动学由目标坐标点如何找到正确角度旋转手臂有一种非常简单的近似技术碰撞检测参考链接最简单的思路就是遍历所有两个对象之间的重叠判断以圆为例就是判断两个对象锚点间的距离小于两半斤之和则为重叠这样可以做到碰撞检测但是效率十分低下低效之处在于两个远离的对象之间执行了很多无用的检查因此必须引入空间分割的概念最简单的结构之一就是固定网格加速是一种用于逆向运动学求解的算法广泛应用于计算机动画游戏开发和机器人运动控制等领域它的主要目的是通过调整关节的位置来实现目标位置的达成通常用于角色动画和机械臂控制在锚点和目标点之间不断重复来回拉扯机械臂直到收敛于从锚点开始并朝向目标位置的排列基本原理算法的核心思想是通过前向和后向的迭代过程来求解关节的位置使得末端效应器如手脚等能够达到目标位置具体步骤如下初始化设置关节的初始位置和目标位置前向迭代从根关节开始逐个更新关节的位置使得每个关节与其下一个关节之间的距离保持不变这一过程会将末端效应器逐渐移动到目标位置后向迭代从末端效应器开始逐个更新关节的位置使得每个关节与其上一个关节之间的距离保持不变这一过程会确保关节的运动不会超出其物理限制重复迭代重复前向和后向迭代直到末端效应器接近目标位置或达到预设的迭代次数控制器工业上的平滑算法在工业上当传感器测得的数据波动非常大时常用的方法之一是数据平滑处理以下是几种常见的数据平滑方法移动平均法计算一定时间窗口内的数据平均值用平均值替代原始数据点移动平均法可以有效地减少数据的波动使数据更加平滑指数加权移动平均法与简单移动平均法不同指数加权移动平均法给予最近数据点更大的权重使得平均值更加灵活地跟随数据的变化滤波器使用数字滤波器对数据进行滤波处理常见的滤波器包括低通滤波器和中值滤波器滑动窗口取排序后的中位数小值滤波器滑动窗口取排序后的最小值等滤波器可以有效地去除数据中的噪声和波动数据插值通过插值算法对数据进行插值处理填补数据中的缺失或异常值使得数据更加平滑现在是这个这样的情况我需要实时修正一组数据的离群点数据点以一秒一个的方式获取到需要实时处理已经出现的数据点中的异常点这些离群点可能连续几个上下连续大幅以激变的形式出现我需要将这样的异常点找出来并且不具备任何的数学模型是否有合适的算法可以使用卡拉楚巴算法属于底层数学原理上层用不上参考视频为了让电脑更快他们把乘法玩到了极致优化乘法运算的复杂度滤波器消除噪声平均滤波器高斯滤波器维纳滤波器保留边缘细节中值滤波器高斯滤波器动态系统状态估计卡尔曼滤波器自适应滤波器图像处理高斯滤波器卷积滤波器音频处理巴特沃斯滤波器切比雪夫滤波器常用滤波器介绍中值滤波器优势对于脉冲噪声如盐椒噪声效果显著能有效去除异常值保留边缘细节不会模糊图像适用场景图像处理中去除单像素噪声传感器数据处理去除瞬时噪声平均滤波器优势简单易实现计算速度快平滑效果较好能有效消除高频噪声适用场景需要快速处理的信号平滑对频谱不敏感适合于一般噪声的平滑高斯滤波器优势保留图像细节平滑效果较为自然通过调节参数可以控制平滑程度和边缘保留效果适用场景图像处理中常用的模糊滤波方法需要平滑信号但又不希望失去细节的情况巴特沃斯滤波器优势频率响应平坦截止频率处不产生波纹可以实现比较陡峭的频率特性适用场景通信系统中的滤波器设计需要平滑频率响应的应用如音频和语音处理切比雪夫滤波器优势可以实现非常陡峭的频率特性在通带或阻带允许一定纹波情况下能提供更好的截止特性适用场景对频率响应要求较高的通信和雷达系统需要在频域上实现比较严格的要求维纳滤波器优势根据信号和噪声的统计特性自适应调整滤波器参数在知道信号和噪声的统计特性时能够达到最优的去噪效果适用场景信号和噪声的统计特性已知如通信系统中的信号重建和去噪卡尔曼滤波器优势可以对动态系统的状态进行估计和预测适用于非线性和线性系统通过状态预测和更新能够提供最优的估计结果适用场景航空航天导航系统中的位置和速度估计移动机器人的轨迹跟踪和状态估计自适应滤波器优势能够动态调整滤波器参数根据信号特性自适应地优化滤波效果在信号特性随时间变化或环境变化的情况下能够保持较好的滤波效果适用场景信号特性动态变化的自适应滤波需求如通信雷达和生物信号处理梯形滤波器优势通过加权平均当前和前后若干点的数据能够较好地平滑信号权重的梯形分布有助于保留信号的边缘细节适用场景需要在平滑信号的同时保留边缘细节的应用如图像和声音处理卷积滤波器优势通过卷积运算处理信号可以实现多种复杂的滤波效果在图像处理和深度学习中有广泛应用能够实现多种空间和频域上的滤波需求适用场景图像处理中的边缘检测模糊处理和特征提取深度学习中的卷积神经网络中的特征卷积中值滤波中值滤波是一种常用的信号处理方法用于去除噪声和平滑数据它通过将每个点替换为其邻域窗口中的中值从而有效地去除尖锐的噪声边缘效应对于数据集的边缘部分由于窗口的一部分会超出数据边界可以采用不同的策略处理边缘如重复边缘数据补零仅使用有效数据等下面提供一个中值滤波的例子一阶滤波一阶滤波是比较常用简单的滤波方法就是当前采样结果和上一个滤波结果加权求和权重和为对周期干扰噪声有良好的抑制作用但同样会产生相位滞后权重是固定值也是其缺点之一巴特沃斯滤波巴特沃斯滤波器是一种数字滤波器常用于信号处理领域中对频率进行滤波和调整巴特沃斯滤波器的设计基于巴特沃斯多项式具有平滑的频率响应曲线和良好的通频带特性巴特沃斯滤波器在信号处理中具有广泛的应用可以帮助滤除噪声调整信号频率特性设计滤波器等巴特沃斯滤波器主要用于解决以下问题信号滤波巴特沃斯滤波器可以对信号进行滤波去除不需要的频率成分保留感兴趣的频率成分这在信号处理中常用于去除噪声平滑数据提取特定频率成分等频率调整巴特沃斯滤波器可以调整信号的频率特性包括增强或抑制特定频率范围内的信号这在音频处理图像处理通信系统等领域中很有用滤波器设计巴特沃斯滤波器是一种经典的滤波器类型其设计方法相对简单且易于实现因此它常被用于滤波器设计中满足不同应用场景的频率响应要求卡尔曼滤波我的理解一句话概括就是理论值和实际值的加权平均卡尔曼滤波是一种用于估计系统状态的最优滤波算法它基于对系统的动态模型和测量模型进行建模通过递归地更新状态估计值提供对系统状态的最优估计和预测卡尔曼滤波在以下情况需要使用当系统受到噪声干扰时需要准确估计系统的状态当系统具有复杂的动态模型或多个传感器测量值时需要融合这些信息来得到更准确的状态估计当系统需要快速响应和准确跟踪目标时卡尔曼滤波可以提供更优秀的性能当系统需要实时进行状态估计并且需要考虑系统的动态特性和测量误差时卡尔曼滤波是一个有效的选择这里我们就不扯那些专业术语了我们讲人话首先我们需要对卡尔曼滤波具体是干什么的要建立起一个最基本的概念这里先借鉴知乎用户的说法给大家打一个大致的基础假设你现在处于某颗星球上手上有两个力传感器并且有一个已知质量为的物体但是你不清楚他们的重力大小而且你也不知道你现在所处位置的重力加速度的具体值为多少因此你打算通过两个传感器获得物体的重力但不幸的是它们测得的读数似乎每次都不太一样那该怎么办没错就是取平均再假设你知道其中贵的那个传感器应该准一些便宜的那个应该差一些那有比取平均更好的办法吗没错加权平均再然后假如你手上只有一个传感器但是你碰巧得知了当地的重力加速度为那么你现在可以知道传感器测出的重力值为你自己通过数学模型推导出来的重力但是这两个值之间似乎也有偏差那该怎么办呢没错我们还是取两值的加权平均但是你不清楚和哪个更加可信那么如何确定权值系数这取决于你对这个值的确信度如果你更相信数学模型的推导结果那么对应数学模型的权值更大而你传感器的观测模型的权值则变小如果你对的确信度较小那么就正好相反而这个权值在卡尔曼滤波中也叫作卡尔曼系数以上就是卡尔曼滤波最基本的思想没错是不是很简单呢当然在这之中我们也忽略掉了一些东西但是不要着急我们一步一步来卡尔曼滤波实际上就是把传感器测得的值和根据数学模型推导出来的值融合以逼近实际值的过程因此卡尔曼滤波也经常被称作传感器融合算法左侧正态分布表示汽车起始点经过一段时间后右侧蓝色正态分布表示汽车计算出来可能落到的正态分布右侧红色正态分布表示传感器测量出来的正态分布卡尔曼滤波测出来的正态分布为右侧灰色正态分布通过数学模型预测得到了时刻的位置估算值然后将其与小车传感器的测量值进行结合得到了当前时刻小车的最佳位置估算值卡尔曼滤波的思想卡尔曼滤波是利用线性状态模型以及模型的输入和输出值结合传感器测量值获取当前时刻的最佳状态估计值卡尔曼滤波假设所有的不确定性因素理论上都服从正态分布卡尔曼滤波就是使最后估算状态的高斯分布的期望值能够接近实际值并且方差够小卡尔曼滤波工作于连续的系统并通过迭代操作估算每一个时刻的最佳状态估计值是小车的真实模型内部的方程我们是不清楚的这里只是为了更好地示意真实噪声环境下传感器测量结果的不确定性我们能得知并且运用的只有输入量和传感器测量值而则是我们实际运用的数学模型我们可以从中得出状态估计量其中和是随机噪声相关公式参考此链接尾部分波函数坍缩算法该算法的命名来源于量子力学量子系统在测量过程中从多个可能状态逐渐坍缩到一个确定状态的现象量子力学波函数坍缩需要制定约束规则每当完成一个位置的坍缩后会逐一调整剩余位置的可选坍缩可能坍缩完成后下一个坍缩位置选择对于各种坍缩可能概率一致的情况选坍缩数量最少的位置进行坍缩因为可选坍缩数量越少代表这个位置对地图后续走向越关键因此处理的优先级更高并且对最小的可能性数量的坍缩结果进行坍缩会提高整体效率对于各种坍缩可能不一致的情况引入熵的概念选择熵概念上表示最稳定的位置最小的位置作为下一个坍缩目标熵熵为第个坍缩可能的概率回溯机制在坍缩的过程中可能会出现某个位置的可选坍缩可能数为的情况因此无法进行坍缩为了解决这种场景波函数坍缩算法加入了回溯机制每当完成一次坍缩后算法会记录所有位置的状态快照并将快照保存到一个栈中当面临无解的情况就可以回溯到有解的状态来避免做出那个选择总结制定约束规则并在坍缩过程中不断调整剩余未坍缩位置的可选瓦片计算未坍缩位置的熵值并选择熵值最小的位置作为下一个坍缩目标每次坍缩后保存状态快照并在遇到无解的情况时进行回溯模拟退火算法在众多好的算法中寻找最优的算法鸟群模拟算法算法是一种用于模拟鸟群行为的计算模型由在年提出该算法通过简单的规则来模拟个体如鸟之间的互动从而形成复杂的群体行为模型主要基于三个基本规则分离个体会避免与邻近的其他个体过于接近以防止碰撞对齐个体会调整自己的运动方向朝向鸟群的平均方向聚合个体会朝向邻近个体的中心位置移动以保持群体的整体性通过这三条简单的规则算法能够生成自然的群体运动效果广泛应用于计算机图形学动画机器人技术等领域仅凭三条简单规则就能产生涌现复杂性或美丽避障算法插值算法知乎详解参考关于插值的详解线性插值最简单的线性插值公式对于和之间的任意值可以计算它们之间的百分比线性插值最简单的公式就是这样线性插值如下但是最后一个参数可以玩出很多花样来的时候这就是一个线性插值于是一个插值函数可以概括为上图绿线为紫线为此时就不是线性插值了可以理解为插值的密度或权重变化了如果把轴理解成一个小球向上运动的小球此时两个函数虽然他们还是在同一个点开始同一个点结束但是小球向上运动的速度却在变化后者需要一个启动时间就相当于被设置另一个固定的加速度然后从开始加速同样上图可见紫色线为初始高速度弹射起步固定的加速度降低速度同样也有平滑曲线从左到中间缓慢加速中间到终点时缓慢减速起点和终点附近曲线平缓中间曲线最陡可以通过上面两个函数得到下面盘点记录一下常用的函数图二次缓出图二次缓入图图三角形来回弹跳图弹射起步会超终点图重力落地方式到终点弹跳停止到终点图缓入缓出混合得到函数二次缓出二次缓入二次缓出二次缓出来回弹跳来回弹跳弹射起步会超终点重力落地方式到终点弹跳停止到终点混合缓入和缓出函数得到缓入缓出函数应用场景如采样纹理时采用的双线性插值界面元素采用函数等动画中利用这些变化缩放的时候使用比使用更好对颜色进行插值很容易比方说对蓝色到黄色进行插值要用线性颜色空间进行插值最后再转换回空间得到的渐变效果会更好线性颜色空间是指在颜色表示中颜色的数值与人眼对光强度的感知之间是线性关系的颜色空间在这个空间中颜色的数值如值直接对应于物理光强度这意味着如果一个颜色的数值是另一个颜色的两倍那么它在视觉上看起来也会是前者的两倍亮度阻尼帧数无关的向的追踪效果是可以变化的样条插值用途根据数据做预测或则根据局部情况估计整体分布图形化呈现计算结果缺点不能给出明确函数关系一般用于对数据的概括性描述从中发现分布特征样条名词解析样条这个术语源自于造船业用来描述在木船的曲线形状中使用的一种柔软且易弯曲的木条在数学和计算机科学领域样条被引入用来描述一种平滑且连续的插值函数因此样条插值指的是通过连接相邻数据点的一系列曲线段来逼近数据的插值方法以实现平滑的曲线拟合在样条插值中通常会使用多项式函数来拟合相邻数据点之间的曲线段以确保在数据点处函数值的连续性和平滑性样条插值方法在数据处理图像处理和数值分析等领域广泛应用可以有效地处理数据的平滑和插值问题不用给出具体的函数关系根据已有数据预测其他数据即可的情况可以使用样条插值算法根据实际应用对于平滑的要求通常会有以下不同的约束要求生成的参考曲线是连续的在的基础上要求参考曲线的速度是连续的在和的基础上要参考曲线的加速度是连续的速度是位置对时间的导数加速度是速度对时间的导数加速度对时间的导数我们称之为在多项式插值里面给定多项式的阶次越高能拟合的函数曲线就越复杂但越高阶次的多项式对于计算资源的要求越多因此对于这个要求我们可以分别用不同阶次的多项式函数来拟合实际应用时根据需求选择合适的方法下面的公式讲解如下是待确定的常量参数表示初始时刻表示初始时刻的位置表示斜率也就是速度这里为常量因此给定下一个时刻处的位置表示分割点时间线性插值一阶恒定速度线性插值顾名思义就是使用线性的方法来进行插值即将给定的数据点依次用线段连起来点与点之间运动的速度是恒定值得出常数为以代码为例给出线性插值的代码如下序列中第个点对应的原始序列中的下标整数部分小数部分线性插值的关键体现是在和之间进行线性插值计算的值时目标位置在如果已经是最后一个索引直接取其值针对二维点的线性插值生成指定个数的线性插值点插值点的列表和不能相同权重来看这两边权重很容易理解反左侧整数位置的权重越靠近左侧位置权重越大右侧整数位置的权重越靠近右侧位置权重越大抛物线插值二阶恒定加速度抛物线差值是二阶多项式插值方法与线性插值法将各个数据点用线段连起来不同抛物线插值方法是用二次曲线将各个数据点连接起来在连接处使用平滑的曲线来过渡而避免速度不连续导致的急剧拐弯抛物线差值的特征是具有恒定的加速度减速度一般是由两个二阶多项式的组合来得到为什么是两个二阶多项式呢因为一个用于加速阶段一个用于减速阶段加速阶段和减速阶段的分割点叫加速阶段减速阶段常数公式略三次多项式插值三阶加速度可变三次多项式插值方法是一种常用的插值方法其位置和速度曲线是连续的加速度是可变的但加速度不一定连续考虑个数据点之间插值的情况其数学表达式为两种计算情况给定了初始时刻和最终时刻处的位置与速度信息设则参数可以使用一下公式计算对于给定个一系列数据点进行插值的情况只需要对所有相邻的两个数据点使用上述公式即可依次计算得到整条插值曲线给定了每一个点的位置信息但中间点的速度未给定这种情况整条曲线最开始的起点和最终的终点速度需要直接给定一般为零中间各个数据点的速度可以通过启发式方法得到即通过求解位置对时间的导数得到那么对于第个中间点我们有其中表示曲线的导数或斜率为符号函数返回或直观理解考察第个数据点若其导数在该点进行了符号反转则该点速度为否则该点速度为其导数可以看到位置曲线是平滑的速度曲线是连续的加速度曲线是可变的但是不连续这样对于高速控制的场合来说控制器的输入仍然会存在阶跃导致不连续的情况五次多项式插值五阶加速度连续略更多详情参考此处可以看出位置速度加速度三条曲线都是连续的并且位置和速度还是平滑的如果加速度曲线也要求是平滑的那么就需要更高阶次的多项式插值方法了例如七阶多项式插值七次及更高阶次的多项式插值各种方法插值的对比图相关开源代码及的仓库次拉格朗日插值多项式太复杂但能推出一个统一的多项式分段线性插值针对每两个点分段进行线性插值三次样条插值的语法语法或分段三次多项式插值拉格朗日算法贝塞尔曲线参考视频在线尝试贝塞尔曲线线性插值如下用于描述一个点在两点之间的移动轨迹实际上就是个线性插值算法二阶贝塞尔曲线这里的分别称之为控制点贝塞尔曲线的产生完全与这三个点位置相关三个匀速前进的点各自速度不同分别是沿着到到以及沿着绿色线前进同时从起点出发同时到达终点三阶贝塞尔曲线四阶贝塞尔曲线贝塞尔曲线可以由阶数递归定义这也就意味着我们可以通过调节控制点的位置进而调整整个曲线公式通过递归地应用函数可以实现任意阶数的贝塞尔曲线如果只有一个点直接返回对相邻控制点进行线性插值递归调用处理新的点列表对每个值生成一个点使用方式生成贝塞尔曲线更简洁的版本方法这个方法通过两个点和一个参数来计算它们之间的线性插值方法这个方法会逐步对相邻的控制点进行插值直到只剩下一个点对于每个递归调用我们会生成一个新的控制点列表其中每个新的控制点都是相邻原始点之间的线性插值方法这个方法遍历的值从到并调用来生成贝塞尔曲线上的点通过调整的大小你可以控制贝塞尔曲线的精度还有公式实现法效率更高公式推导参考使用公式实现的算法暂略分段贝塞尔曲线虽然贝塞尔曲线的阶数可以很高但是如果曲线的阶数过高调整控制点对曲线的影响就比较小调整起来相当麻烦因此常常使用分段的贝塞尔曲线来保证每一小段不会太复杂分段带来的唯一问题是曲线在段与段的交界处如何保证平滑所谓平滑其实就是一阶导数连续导数的值不会出现突变跳跃或不连续的情况也就是左右导数的极限相同对两侧的贝塞尔曲线求导分别代入和即贝塞尔曲线的开始和结束时间让二者相等此时能发现当两侧控制点与分段交接点共线且形成的线段长度相等时满足曲线平滑性质曲线相关算法曲线平滑样条插值算法就可以作为一种曲线平滑算法圆角平滑算法圆的曲率为半径的倒数直线的曲率为在二维空间中曲线的曲率可以通过其切线的变化率来定义具体来说曲率可以表示为其中是切线的角度是沿着曲线的弧长在三维空间中曲面的曲率通常用高斯曲率和平均曲率等来描述这些曲率量化了曲面在不同方向上的弯曲程度在曲率的圆角设计中和是用于描述曲线连接的几何连续性标准这些标准通常用于计算机辅助设计和计算机图形学中以确保曲线或曲面的平滑连接具体来说连接一次连续性连接要求在连接的两个曲线或曲面之间具有相同的端点位置并且在该点的切线方向相同换句话说连接确保了曲线在连接点处是连续的但可能会有角度的突变这种连接适用于对平滑度要求不高的情况连接二次连续性连接不仅要求连接的曲线在端点位置相同而且要求在连接点的切线方向即一阶导数也相同这意味着在连接点处曲线的斜率是连续的从而提供了更高的平滑度连接适用于需要更高平滑度的设计连接三次连续性连接要求在连接点处不仅切线方向相同而且切线的变化率即二阶导数也相同这意味着在连接点处曲线的加速度也是连续的从而提供了最高级别的平滑度连接通常用于对光滑度要求极高的应用比如高端工业设计和汽车外观设计对比的问题如下下图蓝底为平滑黄色为平滑苹果的圆角设计为圆角是一种看起来更自然更舒服的圆角超椭圆小米的设计利用的是超椭圆公式适合用于做底图超椭圆公式超椭圆也称为拉梅曲线是在笛卡尔坐标系下满足以下方程式的点的集合时该曲线就是圆的曲线时圆角矩形小米的轮廓就是为时的超椭圆曲线相似算法曲线相似算法盘点参考动态时间归整算法也可以作为曲线相似算法距离算法弗雷歇距离是一种用于测量两条曲线或路径之间相似性的距离度量由法国数学家在年提出的一种路径空间相似形描述此外还在这篇论文里定义了度量空间这种描述同时还考虑进路径空间距离的因素广泛应用于计算机科学图形学地理信息系统等领域与传统的欧几里德距离不同距离不仅考虑曲线上的点对点距离还考虑曲线的形状和走向距离是一种强大的曲线相似性度量方法通过考虑曲线的形状和走向能够更精确地衡量两条曲线之间的相似性在实际应用中可以通过动态规划等方法来计算该距离并结合修正值处理数值计算中的不精确性尽管计算复杂度较高但在需要精确比较曲线的场景中距离具有无可替代的重要性应用场景计算机图形学用于比较和对齐曲线形状匹配地理信息系统用于路径比较轨迹相似性分析如分析动物迁徙路径或车辆行驶轨迹模式识别和机器学习用于时间序列分析手写字符识别等优点能够有效地比较曲线的形状和几何特征考虑了曲线的连续性和走向适合路径和轨迹比较缺点计算复杂度较高特别是在处理高维数据时动态规划方法在处理大规模数据时可能会消耗大量内存和计算资源计算方式将连续的曲线离散化为一系列点集这一步是将曲线和分别用一组离散点表示构建距离矩阵距离矩阵的元素表示曲线上第个点和曲线上第个点之间的欧几里德距离动态规划矩阵的初始化与填充最终矩阵的右下角元素即为曲线和曲线之间的距离动态规划矩阵的填充步骤动态规划矩阵的尺寸与距离矩阵相同大小为其中和分别是曲线和曲线的离散点数初始条件表示从和的起点出发时的距离对于第一行和第一列对于其他使用如下递推公式解释上述公式是曲线上的第个点和曲线上的第个点之间的欧几里德距离表示从之前的状态转移到当前状态的最小距离确保当前状态的距离考虑了当前点之间的距离这样计算的每一步都确保了距离考虑了曲线上的所有点对点距离同时保持了路径的连贯性和正确性通过动态规划的方法我们逐步计算和记录了从曲线起点到各个点之间的距离确保考虑到曲线的全局形状和相似性这种方法在理论上和实际应用中都被证明是有效的动态规划表格的实际构建演示下面是一个示例假设我们有两个离散化的曲线和它们的点集分别为和对应的距离矩阵和动态规划矩阵的构建过程如下计算距离矩阵初始化动态规划矩阵填充第一行和第一列使用递推公式填充其余部分最终我们得到填充完的动态规划矩阵最终得到曲线和的距离为递归实现代码案例这个代码可以计算元素个数不同的两个序列的相似度版权声明本文为博主原创文章遵循版权协议转载请附上原文出处链接和本声明本文链接计算两段曲线的距离作为判断曲线相似的依据计算的值越小说明这两段曲线越相似使用该函数得到距离最终结果计算两个节点之间的欧式距离曲线抽稀在处理矢量化数据时记录中往往会有很多重复数据对进一步数据处理带来诸多不便多余的数据一方面浪费了较多的存储空间另一方面造成所要表达的图形不光滑或不符合标准因此要通过某种规则在保证矢量曲线形状不变的情况下最大限度地减少数据点个数这个过程称为抽稀通俗的讲就是对曲线进行采样简化即在曲线上取有限个点将其变为折线并且能够在一定程度保持原有形状比较常用的两种抽稀算法是道格拉斯普克算法效率更高主流做法垂距限值法优劣对简化精度要求较高且数据量不大垂距限值法可能更合适对于大规模数据或需要快速处理的情况算法则更为优越阈值越高抽稀后越平滑除了这两套算法外还有如下方式基于时间间隔的抽稀如果你的数据是基于时间产生的使用一定的时间窗口对数据进行采样例如每秒显示一个数据点当数据增加到一定程度时你可以调整窗口增加每次采样的时间间隔比如从秒变成秒这样可以避免在图表上显示过多数据点基于像素密度的抽稀对于每个像素宽度只保留一个数据点可以通过计算当前图表宽度上的像素数并动态调整你显示的数据点数量比如当图表只有个像素宽时你可以从原始数据中选择个代表性点算法该算法用于线简化通过去除不重要的点来减少数据算法会从一条折线中移除那些不会显著改变曲线形状的点从而降低点的密度适合用于有曲线的图表指数采样根据数据点的数量使用指数抽稀策略比如当数据点少于个时保持全部显示当数据点超过个时只显示每个数据点中的一个当数据点超过时显示每个数据点中的一个依此类推关键点保留策略在进行抽稀时确保保留关键点例如局部极值点峰值和谷值转折点或数据斜率变化剧烈的点这可以通过检测局部变化来实现如果某点相对于前后的点有明显的变化标记它为关键点并保留比如使用二阶差分或曲率判断是否为关键点算法线简化算法该算法通过递归划分折线保留那些对线条形状影响较大的点并删除对整体形状影响较小的点这有助于保持数据的形状特征同时减少点数算法的优点是可以通过调整容差来控制抽稀后的精度自适应采样根据数据的变化速率或斜率来调整采样频率在平滑或变化较慢的区域可以稀疏采样而在数据变化剧烈的区域保留更多的点例如当检测到数据变化较大时动态减少抽稀的频率确保保留细节多分辨率展示保持多层次的数据抽样结果例如绘制时可以使用较稀疏的抽样数据来保证性能而在用户缩放或平移到某个区域时动态加载和显示该区域的详细数据这样可以在保证整体形状的同时提供详细的局部信息滑动窗口平滑法在保留原始数据点形状的基础上你可以在抽稀过程中应用滑动窗口平滑法这种方法能够保留整体形态并减少噪声引起的小幅波动滑动窗口可以随着数据点的密度自适应调整大小保留首尾点在抽稀过程中始终保留数据的起点和终点确保曲线的整体趋势不会丢失这有助于在大幅抽稀的情况下保持数据的宏观走势窗口缩放如果你的图表支持平移和缩放功能可以让用户通过缩放来查看更多细节当缩小时显示较少的数据点而当放大时展示更多的原始数据动态抽样比例调整根据图表的渲染性能动态调整抽稀比例可以定期测量绘制速度和响应时间如果发现绘制过慢就增加抽稀率这样保证在不同设备上都能有流畅的绘图体验算法道格拉斯普克算法通常简称为算法是一种用于曲线抽稀简化曲线的方法是线状要素抽稀的经典算法用它处理大量冗余的几何数据点既可以达到数据量精简的目的又可以在很大程度上保留几何形状的骨架算法的步骤通常如下连接曲线首尾两点依次计算曲线上所有点到两点所在曲线的距离即作垂线垂线的长短计算最大距离如果小于阈值则去掉曲线上除外的所有点如果大于阈值则把曲线以最大距离分割成两段对所有曲线分段重复步骤直到所有均小于阈值即完成抽稀这种算法的抽稀精度与阈值有很大关系阈值越大简化程度越大点减少的越多反之简化程度越低点保留的越多形状也越趋于原曲线此处附一个计算点到直线距离的代码数学点到直线的距离数学推导参考此处包含和函数计算点到直线的距离计算直线的参数直线的直线的直线的使用距离公式计算点到直线的距离通过这种方式算法能够有效地减少曲线的复杂度同时尽量保留曲线的形状特征广泛应用于计算机图形学地理信息系统等领域在中轮廓近似函数由算法实现案例计算点到线段的距离和是同一点限制在之间道格拉斯普克算法非递归实现如果点少于个直接返回保留起点保留终点保留这个点使用方式示例数据简化的阈值输出简化后的点简化后的点由于算法中的阈值需要人工手动设定因此此处记录一个自适应算法自适应算法论文可以根据垂比弦值来量化节点的重要性节点的重要值衡量了该节点对整个矢量图形维持原形状的重要性重要值越大该节点对原图形形状越重要为了使压缩后的矢量图形尽可能地维持原图形形状就需要保留这些重要值很大的节点然后引入了角度变化率指的是拟合曲线上相邻两点切线方向上角度的变化率用于局部计算阈值粗略提取了一些思想整体算法较为复杂涉及到曲线拟合暂略垂距限值法垂距限值法是一种简单的轨迹平滑算法用于将给定的轨迹进行简化从而减少轨迹的噪声并减少机器人的运动轨迹该算法的基本思想是对轨迹上的每个点进行垂线投影如果垂线的长度小于某个阈值则认为该点是不必要的可以将其删除从而实现轨迹的简化算法原理以第一个点开始计算第一个点到前一个点和后一个点所在直线的垂距如果垂距小于阈值则保留该点并将其作为下一个点计算如果垂距大于阈值则舍弃该点并将下一个点作为当前点重新进行计算依次类推直到计算完最后一个点计算垂距垂距限值法函数记录当前点在中的索引将第一个点添加到输出路径中若垂距大于阈值则保留该点更新当前点的索引将最后一个点添加到输出路径中这里罗列一个算垂距的例子将转换为时间戳获取坐标的计算根据公式计算距离曲线趋势中心点整体思路如下准备数据排序平滑定义度量设计误差函数确定采样策略粗搜索大范围低精度扫描细搜索小范围高精度定位结果验证计算对称评分可视化检查输出返回最佳值及相关指标详细参考如下去噪突出整体趋势减少噪声对对称性判断的影响移动平均低通滤波高斯滤波样条拟合定义对称性度量定义一个函数误差函数来量化曲线关于某个中心点的对称程度核心思路对于候选中心点曲线左右对称意味着对于任意偏移量左侧点的值右侧点的值误差函数设计均方误差计算所有偏移量对应的求这些平方差的平均值优点对大误差更敏感能更好区分对称性程度平均绝对误差计算所有偏移量对应的求这些绝对差的平均值优点对异常值不敏感偏移量采样策略确定取到左边界和右边界距离的较小值采样点数量通常在个点之间平衡精度和效率采样方式均匀分布在区间搜索候选中心点分层搜索策略粗搜索阶段目的快速定位大致区域方法将整个范围分成个等距点计算每个点的对称误差记录误差最小的点作为初步中心细搜索阶段目的在粗搜索结果附近精确查找方法在粗搜索最佳点周围小范围内密集采样范围设置通常取粗搜索步长的倍为半径采样密度比粗搜索高倍插值处理为什么需要插值数据点是离散的但对称点可能不在原始数据点上需要估计任意位置的值插值方法选择线性插值原理在相邻两点间画直线优点计算简单快速缺点曲线不够平滑时精度有限三次样条插值原理使用分段三次多项式连接点优点能生成平滑曲线精度高缺点计算稍复杂需要足够数据点边界处理当超出数据范围时返回无效值或使用外推法在算法中应跳过这些点不参与误差计算优化策略效率优化采样点优化在平坦区域减少采样密度在变化剧烈区域增加采样密度并行计算粗搜索中各候选点可并行计算误差细搜索中各点也可并行处理提前终止当找到明显低误差点时停止搜索但需设置合理阈值防止局部最优精度优化迭代细化在细搜索结果基础上再次缩小范围搜索可进行多轮迭代提高精度动态步长调整根据误差变化率调整搜索步长误差变化大时用小步长变化平缓时用大步长结果评估与输出对称性评分计算方法实际误差最大可能误差意义之间的值越接近对称性越好用途判断结果可靠性过滤低质量结果多峰处理当发现多个局部最优解时记录所有候选点根据对称性评分排序返回最佳点或所有候选点供用户选择结果验证可视化绘制对称轴和原始曲线对比统计检验计算左右两侧的相关系数残差分析检查误差分布是否随机特殊场景处理非理想对称曲线整体趋势处理方法先去除线性或多项式趋势前提是如果需要去除整体趋势影响的干扰才考虑这样处理若趋势本身就是对称的一部分在这情况下可以跳过此步骤步骤拟合整体趋势线原始数据减去趋势值在残差数据上找对称中心部分对称处理指定关注区间而非整个曲线在局部区域应用相同算法噪声处理进阶鲁棒统计方法使用中位数代替平均值忽略一定比例的异常点多尺度分析在不同平滑程度上分别计算综合多个尺度的结果无解情况处理当最小误差仍很大时返回未找到有效对称中心提供可能原因分析如数据噪声大曲线不对称数值分析曲线拟合算法和函数逼近与插值方法最大的区别在于最终要得到具体的函数关系在数值积分中除了使用梯形简单计算积分外还可以使用插值或拟合技术来构造多项式来逼近被积函数这里简单介绍一下常用的方法插值法插值法通过已知数据点来构造通过这些点的多项式函数常见的插值方法包括拉格朗日插值和牛顿插值在辛普森法则中我们可以通过子区间的左端点右端点和中点处的函数值来构造一个二次多项式从而近似代替被积函数拟合法拟合法通过已知数据点来拟合一个多项式函数使得这个多项式函数与原函数在这些点上尽可能接近常见的拟合方法包括最小二乘法和最小二乘多项式拟合在数值积分中我们可以使用拟合技术来构造一个简单的多项式函数来逼近被积函数动态时间归整按照距离最近的原则构建两个序列中的元素之间的对应的关系用于评估两个序列的相似性应用场景计算两个序列之间的相似性动作识别传感器的加速度和角速度维数据作为一组数据评估运动的相似性获取匹配特征对最终取路径声音转换源说话人的语音转换为目标说话人的特征需要先配对才能构造转换函数语音识别文本和语音特征对齐距离计算要提前训练一个的深度神经网络的分类器输入的是特征输出的是音素概率使用最终输出的概率值作为距离股市交易曲线匹配碱基序列匹配非常多应用场景要求单向对应不能回头一一对应不能有空对应之后距离最近定义一个距离公式怎么定义都可以比如说最简单的假设有两个序列序列有个元素序列有个元素将会产出一个的累计距离矩阵填充算法遵循如下公司对于最左边的一列对于最下面的一行实际上算法与上面一样方向变了而已对于其他元素为什么是左下三个点呢原因是因为一对一矩阵被填充完毕后从右上角开始向左下找寻配准路径找到左下三点中较小的那个作为下一节点如图最终就能得到配准结果完整过程参考该视频实际计算的过程中只需要利用动态规划的思想就可以实现并不需要填充矩阵离群点异常点查找算法异常就是偏离数据主要分布的点或者群体导致异常的原因有很多比如恶意行为系统故障蓄意欺诈等因此异常检测对于决策系统是必须的离群点异常点介绍异常点分类单点异常个体数据实例相对于其余数据被视为异常例如交易流水中的大额交易上下文异常时间序列一般是在有时间的序列集中才存在仅在特定上下文中异常单拿出来看不出异常集体异常连续性异常相关数据实例的集合相对于整个数据集是异常的对于单个值则不是两种可能性按无法预料的顺序发生值的组合是无法预料的难点大部分情况下数据是没有标签的各种成熟的监督学习没有用武之地区分噪音和异常点时难度很大甚至需要发挥一点点想象力和直觉当多种诈骗数据混合在一起区分不同的诈骗类型更难根本原因还是因为我们并不了解每一种诈骗定义异常检测算法的分类时序相关时序独立数据的变化是否依赖于时间维度全局局部每个点的参考对象是全局的点还是仅参考周围的点标签异常分数算法检测结果的输出形式不同异常分数可以对异常程度进行排序基于模型特性根据异常点的特性采用不同的算法直接建模时序相关下的异常检测滑动窗口根据不同场景可以选择或等组合进行计算马尔科夫链可用马尔科夫链来测时间序列发生的概率从而检测到那些发生概率低的异常序列时间序列聚类采用的方式计算不同时间序列间的距离减弱时间差的影响检测出那些高度相似的时序群组时序预测方法通过对已有时序的预测评估预测值与实际值的偏差是否过大从而判断某个时间点是否存在异常异常检测的经典思想模型这里提到的经典思想模型很少拿来直接使用但如今常用的流行算法都是基于这些原始模型的思想衍生出来的统计检验方法基本假设正常的数据遵循特定的分布形式并占了很大比例异常点的位置较正常点范围存在较大偏移存在的问题往往是均值和标准差都对异常值很敏感在实际计算的时候异常值也被包含在全部数据集里如基于偏差的方法给定一个数据集可以为局部子集或全局点集若一个点自身的值与整个集合的指标有过大的偏差则该点为异常点去除掉这个点后整个集合的方差会减小基本假设数据集最外围的点为异常点模型思想定义一个指标它表示当某个点从集合移除掉后方差降低的值基于距离的方法计算每个点与周围点的距离来判断该点是否为异常点基本假设正常点的周围存在多个近邻点而异常点分布在稀疏区域距离周围点的距离较远模型给定半径和比例假设对点进行检测若与点距离小于半径的点数对于全部点数的比例低于则该点为异常点基于密度的方法对比目标点的周围密度与其近邻点的周围密度基于两个密度值计算出相对密度作为异常分数基本假设正常点与其近邻点的密度是相近的而异常点的密度与其近邻点存在较大的差异开发该方法的动机基于距离的异常检测方法无法处理密度不同的情况针对右图若采用半径和比例固定会被识别为异常点而子集中的很多点的距离都比小也就会被识别为正常点若引入密度作为标准就会有不同的检测结果解决方法引入相对密度深度学习方法即自编码器是一种无监督学习模型包含两个部分编码器和解码器用来发现给定数据的压缩表示用来重建原始输入在训练时强迫选择最有信息量的特征最终保存在压缩表示中最终压缩后的表示就在中间的层中方法盘点有如下方法统计方法标准分数计算数据点距离均值的标准差数通常超过或小于的点被认为是异常点四分位距计算数据的四分位数和然后计算通常定义在以下或以上的点为异常点用于检测单变量数据集中的单个异常值该测试假设数据呈正态分布基于距离的方法均值聚类在进行均值聚类后距离其最近质心最远的点可以被认为是异常点基于密度的聚类该方法可以找出密度较低区域中的点认为它们是异常点局部离群因子基于密度的局部异常值检测方法通过比较点与其邻居的局部密度来判断是否是异常点机器学习方法孤立森林基于树的随机森林方法通过随机分割数据来检测异常点一种支持向量机方法适用于异常检测自编码器一种神经网络方法通过重构误差来检测异常点基于概率的方法高斯混合模型通过拟合数据的多峰分布来识别异常点贝叶斯方法通过计算数据点的概率分布来检测异常点可视化方法箱线图通过箱线图可以直观地看到异常点散点图特别适合二维数据通过观察数据点的分布情况来发现异常点结合滑动窗口动态检测异常点下面罗列几种方法四分位距法先要获取到完整的数据序列才能处理四分位距法是一种统计方法用于衡量数据的离散程度它通过计算数据的上四分位数和下四分位数之间的差值来描述数据的分散程度具体步骤如下首先将数据按大小顺序排列然后计算数据的上四分位数和下四分位数上四分位数是将数据分成四等份后位于第三份的数值下四分位数是将数据分成四等份后位于第一份的数值计算四分位距根据的大小可以判断数据的离散程度如果某个数据点小于或大于则可以被视为异常值离群值四分位距法相对于标准差等其他离散度量具有一定的优势因为它对异常值的影响较小更能反映数据的真实分布情况在数据分析和异常值检测中四分位距法常被用于识别离群值代码计算四分位距数据序列不能为空方法是一种常用的统计方法用于衡量数据点与数据集均值之间的差异即数据点距离均值的标准差数可以帮助我们判断数据点在数据集中的相对位置从而进行比较和分析缺陷因涉及到均值对异常点相对敏感数学标准差标准差参考的计算公式如下其中表示表示数据点的数值表示数据集的均值表示数据集的标准差通过计算我们可以将数据标准化为标准正态分布即均值为标准差为的分布在标准正态分布中大约的数据点落在个标准差范围内约的数据点落在个标准差范围内约的数据点落在个标准差范围内通常情况下超过或小于的数据点被认为是异常值方法适用于数据符合正态分布的情况可以帮助我们识别和处理数据中的异常值并进行数据分析和统计推断正常范围也可以这么理解某个值处于正常范围某个值平均值的绝对值倍标准差代码计算标准差数据点数量应至少为判断是否异常值如下异常箱线图法箱线图法是一种可视化离群值异常值的有效方法箱线图是一种用于显示数据分布情况的统计图表能够直观地展示数据的中位数上下四分位数最大值最小值以及离群点箱线图通常包含以下几个要素箱体箱体代表数据的四分位数范围即数据的中间箱体上边界表示数据的上四分位数下边界表示数据的下四分位数箱体内部的线表示数据的中位数触须触须延伸自箱体用于显示数据的最大值和最小值触须的长度通常是箱体高度的倍的距离超出该距离的数据点被认为是异常值离群点箱线图中的离群点是指远离箱体的个别数据点它们可能是数据中的异常值离群点通常被标记出来帮助我们识别数据中的异常情况孤立森林算法属于机器学习算法孤立森林算法年由刘飞周志华等提出算法不借助类似距离密度等指标去描述样本与其他样本的差异而是直接去刻画所谓的疏离程度因此该算法简单高效在工业界应用较多一种集成模型线性时间复杂度可以用来处理大规模数据集孤立森林通过构建随机二叉树来快速识别异常点其效率得益于随机化过程和树结构的特性由于它不需要假设数据的分布或异常点的比例因此在处理大规模数据集和高维数据时表现出色此外由于算法的并行性它还可以很好地利用多核处理器进行加速适用情况在数据量比较大的情况下效果更好一般来说异常值在数据集中占的比例较小通常是到能较好地处理这种低比例异常值的情况理解孤立森林的详细参考孤立森林是一种基于树的无监督学习算法用于异常检测它的核心思想是异常点更容易被孤立隔离出来以下是孤立森林算法的详细原理孤立森林通过随机选择一个特征并在特征的随机值上切分数据构建多棵树称为孤立树它利用树的深度来测量数据点的孤立程度深度越浅越容易被孤立越可能是异常点用一个例子来说明孤立森林的思想假设现在有一组一维数据如下图我们要对这组数据进行切分目的是把点和单独切分出来先在最大值和最小值之间随机选择一个值然后按照和可以把数据分成左右两组在这两组数据中分别重复这个步骤直到数据不可再分点跟其他数据比较疏离可能用很少的次数就可以把它切分出来点跟其他数据点聚在一起可能需要更多的次数才能把它切分出来那么从统计意义上来说相对聚集的点需要分割的次数较多比较孤立的点需要的分割次数少孤立森林就是利用分割的次数来度量一个点是聚集的正常还是孤立的异常随机选择特征和随机切割孤立森林通过随机选择一个特征和一个随机切割值来构建二叉树该过程重复进行直到每个样本点都被孤立在叶子节点异常值定位由于异常值更容易被孤立因此异常值通常在树的较浅层被划分出来通过路径长度可以衡量样本点在树中的孤立程度路径长度越短则样本点越可能是异常值异常得分计算根据样本点在多棵树中的平均路径长度来计算异常得分路径长度越短异常得分越高反之则越低对于未曾见过的新数据点将其在孤立森林训练好的中的每棵孤立树中进行路径长度的计算计算路径长度的方法是从根节点开始根据节点的分割特征和分割值确定数据点进入左子树还是右子树直到到达叶子节点记录经过的节点数即为路径长度对新数据点在多棵孤立树中的路径长度取平均值如果平均路径长度明显短于正常数据在孤立森林中的平均路径长度那么就可以认为这个新数据点可能是异常的具体步骤随机选择特征和切分点对于每棵树从数据集中随机选择一个特征并在该特征的范围内随机选择一个切分点递归地对每个分区重复此过程直到达到预定的树深度或节点包含的样本数量小于等于构建孤立树孤立树是通过不断随机选择特征和切分点来构建的二叉树每个节点对应一次数据的分裂分裂点是根据选定特征的随机切分点计算路径长度对于每个数据点计算其在孤立树中从根节点到达叶节点的路径长度路径长度较短的数据点更容易被孤立通常被认为是异常点异常得分计算孤立森林利用多棵孤立树来稳定路径长度的估计异常得分是基于平均路径长度计算的通常归一化到到之间计算公式其中是数据点在孤立森林中的平均路径长度是一个常数用于标准化路径长度常数的计算是用于标准化路径长度的常数定义如下其中是第个调和数欧拉马歇罗尼常数实现代码注意下面的代码可以针对多维数据采用的数据存储容器是定义节点类定义孤立森林中的树节点类节点的分割值用于决定数据点如何在左右子树间分配节点的分割属性索引表示在哪个特征上进行分割左子树节点右子树节点标记节点是否为叶子节点节点所包含的样本数量构造函数初始化节点为非叶子节点构建孤立树归方法构建孤立树定义孤立森林中的单棵树构建逻辑静态随机数生成器用于在构建树过程中生成随机数递归构建孤立树当前节点的数据集当前树的高度树的最大高度构建完成的树节点如果当前高度等于最大高度或数据集中只剩一个样本创建叶子节点随机选择一个属性作为分割属性计算该属性上的最小值和最大值如果最小值等于最大值说明所有样本在这个属性上的值都相同创建叶子节点随机选择一个分割值用于划分数据集根据分割值将数据集分为左右两部分创建新的树节点并递归构建左右子树计算路径长度实现一个方法来计算数据点在孤立树中的路径长度定义一个方法来计算从根节点到特定数据点的路径长度这是孤立森林算法中的一部分如果当前节点是叶子节点那么返回当前高度加上基于节点大小的常数根据数据点在分割属性上的值与节点的分割值比较决定进入左子树还是右子树如果小于分割值则递归地在左子树中查找同时增加路径高度否则在右子树中查找同样增加路径高度定义一个辅助方法用于计算基于节点大小的常数值常数约为公式用于估算路径长度的期望值计算异常得分注意异常得分越高越异常实现一个类来封装整个孤立森林算法包含训练和预测方法定义孤立森林类用于异常检测存储多棵决策树的列表最大采样数量最大树的高度构造函数初始化孤立森林表示森林的树数表示每棵树的训练数据量个数计算最大树高度为样本数量的对数以为底初始化树列表训练孤立森林模型对每棵树进行训练随机采样数据构建决策树并存储计算数据点的异常分数对每个数据点计算平均路径长度并转换为异常分数计算平均路径长度转换为异常分数数据采样方法使用随机数生成器进行随机采样计算常数用于异常分数计算常数约为使用孤立森林算法示例数据二维数组每行代表一个样本创建孤立森林算法实例表示建立个孤立树训练模型获取异常分数设定阈值来标记异常点输出结果一维孤立森林完整代码下面附带一个完整版的一维孤立森林算法更方便理解创建并训练孤立森林模型计算异常得分添加并行处理的一维孤立森林代码并行化建树过程使用来并行构建多棵孤立树提高了建模过程的效率并行化计算异常得分在计算异常得分时使用来并行处理每个数据点从而加速了异常检测过程创建并训练孤立森林模型计算异常得分适用场景常用于网络流量异常检测工业故障检测等领域网络流量异常检测首先对网络流量数据进行特征提取例如数据包大小流量速率协议类型源和目的地址等然后将这些特征数据输入到孤立森林模型中正常的网络流量模式往往具有相似的特征需要较多的分割才能被孤立而异常的流量如攻击非法访问等由于其特征与正常流量差异较大可能在孤立树中较浅的层次就被孤立出来通过分析数据点在孤立森林中的路径长度可以判断其是否为异常流量工业故障检测在工业故障检测方面例如对于一条生产线收集诸如设备温度压力转速能耗等参数作为特征正常运行时这些参数会在一定范围内稳定变化形成一种常见的模式当出现故障时某些参数可能会偏离正常范围将这些参数数据输入孤立森林模型故障状态所对应的特征组合可能更容易被孤立从而被检测为异常实现故障的早期发现和预警其他更高级的算法原理是一种深度学习模型由多个隐藏层组成的神经网络它通过学习数据的复杂非线性关系来进行异常检测优点可以学习数据中的高阶特征和复杂模式适用于处理大规模高维度的数据集缺点需要大量的标记数据进行训练且模型复杂度高训练时间长原理是一种支持向量机模型用于从单一类别的数据中学习正常样本的边界然后识别与正常样本差异较大的异常点优点不需要异常点的标记数据只需要正常样本进行训练适用于非常规数据集的异常检测缺点对参数的选择敏感可能需要调优自编码器原理是一种神经网络模型用于学习数据的压缩表示然后重构输入数据异常点通常在重构误差较大的数据点中被识别为异常优点可以自动学习数据的特征表示适用于无监督学习的异常检测缺点的性能受到数据分布的影响对于高度非线性的数据集可能表现不佳回归分析在统计学中回归分析是一种用来探讨一个或多个自变量与因变量之间关系的方法回归分析旨在了解自变量对因变量的影响程度以及预测因变量的数值回归分析可以帮助我们理解变量之间的关联性并用于预测和解释数据曲线拟合和回归分析都是统计学中常用的方法用于探索变量之间的关系曲线拟合是指通过拟合一个数学模型来描述变量之间的关系通常用于找到最能代表数据分布的曲线或函数而回归分析则是一种更广泛的方法用于研究自变量与因变量之间的关系并通过建立回归方程来预测或解释因变量的数值在某些情况下曲线拟合可以被看作是回归分析的一种特例特别是当我们试图拟合一个曲线来描述自变量和因变量之间的关系时线性拟合线性拟合是一种统计学和数学中常用的方法用于找到一条最佳拟合直线来描述两个变量之间的关系在线性拟合中我们尝试找到一条直线使得该直线与数据点的残差实际观测值与拟合值之间的差异之和最小性拟合通常用于分析两个变量之间的线性关系例如通过一组数据点来找到最佳拟合直线以便预测未来的数值或者对数据进行建模线性拟合的目标是找到最佳拟合直线的斜率和截距以最好地描述数据点之间的关系最小二乘法线性回归预测下一个值预测下一个点的值图算法深度优先搜索广度优先搜索可以用来求最短路径问题常用来处理全排列问题这里提一嘴深度优先遍历递归栈它们三者的关系我个人以为它们背后统一的逻辑都是后进先出图算法本质上是二叉树算法的延续并查集算法回溯算法回溯法采用试错的思想它尝试分步的去解决一个问题在分步解决问题的过程中当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候它将取消上一步甚至是上几步的计算再通过其它的可能的分步解答再次尝试寻找问题的答案回溯法通常用最简单的递归方法来实现在反复重复上述的步骤后可能出现两种情况回溯算法本质就是一种暴力穷举算法虽然效率低但是简单回溯算法一般不会让你求最值而是用于罗列所有无重叠的子结果回溯算法和的区别是一个劲的往某一个方向搜索而回溯算法建立在基础之上的但不同的是在搜索过程中达到结束条件后恢复状态回溯上一层再次搜索因此回溯算法与的区别就是有无状态重置何时使用回溯算法当问题需要回头以此来查找出所有的解的时候使用回溯算法即满足结束条件或者发现不是正确路径的时候走不通要撤销选择回退到上一个状态继续尝试直到找出所有解为止找到一个可能存在的正确的答案在尝试了所有可能的分步方法后宣告该问题没有答案回溯算法强调了深度优先遍历思想的用途用一个不断变化的变量在尝试各种可能的过程中搜索需要的结果强调了回退操作对于搜索的合理性回溯算法框架伪代码路径选择列表满足结束条件路径选择选择列表做选择路径选择列表撤销选择递归之后需要做和递归之前相同的逆向操作实例可以参考全排列问题可以使用排列树和子集树来理解回溯算法子集树参考子集排列树参考全排列下图中最上方为叉树左下角为子集树右下角为排列树引力模拟算法优质视频参考一些算法技巧类型带容差的哈希判断支持容差的比较器容差不能为负数处理和的特殊情况同符号的才相等如果其中一个为或另一个不是则不相等容差比较处理特殊值统一返回正负分别返回最大最小值将值按容差进行量化确保容差范围内的值有相同的使用确保容差边界的一致性先把值除以容差得到它在第几个容差区间对结果四舍五入得到最近的区间编号再乘回容差得到这个区间的中心数用这个区间中心值来生成哈希码这样只要两个落在同一个容差区间它们的就一样先把值除以容差得到它在第几个容差区间如则对结果四舍五入得到最近的区间编号表示属于第个容差区间再乘回容差得到这个区间的中心值所以被归到这个区间用这个区间中心值来生成哈希码这样只要两个落在同一个容差区间它们的就一样异或运算任何数和做异或运算结果仍然是原来的数即任何数和其自身做异或运算结果是即异或运算满足交换律和结合律即针对该题给你一个非空整数数组除了某个元素只出现一次以外其余每个元素均出现两次找出那个只出现了一次的元素解法如下投票算法如果一个数组有大于一半的数相同那么任意删去两个不同的数字新数组还是会有相同的性质即数组有大于一半的数相同思路详解同归于尽消杀法由于多数超过比如个数那么多数至少个剩下少数是个第一个到来的士兵直接插上自己阵营的旗帜占领这块高地此时领主就是这个阵营的人现存兵力如果新来的士兵和前一个士兵是同一阵营则集合起来占领高地领主不变依然是当前这个士兵所属阵营现存兵力如果新来到的士兵不是同一阵营则前方阵营派一个士兵和它同归于尽此时前方阵营兵力即使双方都死光这块高地的旗帜依然不变因为已经没有活着的士兵可以去换上自己的新旗帜当下一个士兵到来发现前方阵营已经没有兵力新士兵就成了领主变成这个士兵所属阵营的旗帜现存兵力就这样各路军阀一直以这种以一敌一同归于尽的方式厮杀下去直到少数阵营都死光那么最后剩下的几个必然属于多数阵营就是多数阵营多数阵营个少数阵营只有个死剩下的个就是多数阵营的人针对题型最优解法如下快慢指针链表中如何在一次遍历中找到中间节点可以使用快慢指针慢指针一次走一步快指针一次走两步快慢指针同时出发当快指针移动到链表的末尾时慢指针恰好到链表的中间通过慢指针将链表分为两部分适用于所有链表的比例定位问题判圈算法问题如何检测一个链表是否有环如果有那么如何确定环的起点如何确定环的长度判圈算法又称龟兔赛跑算法判圈算法又称龟兔赛跑算法是一个可以在有限状态机迭代函数或者链表上判断是否存在环求出该环的起点与长度的算法该算法据高德纳称由美国科学家罗伯特弗洛伊德发明假想乌龟和兔子在链表上移动兔子跑得快乌龟跑得慢当乌龟和兔子从链表上的同一个节点开始移动时如果该链表中没有环那么兔子将一直处于乌龟的前方如果该链表中有环那么兔子会先于乌龟进入环并且一直在环内移动等到乌龟进入环时由于兔子的速度快它一定会在某个时刻与乌龟相遇即套了乌龟若干圈原理理解参阅上面视频公式推导得到以下定理有限时间内都从起点出发快慢指针必然相遇且相遇点在环上一定会相遇是基于有一个指针每个节点都走到了在环上相遇的等速指针必定在环的入口处相遇推导找到的相遇点和起点的等速指针将在环的入口处相遇判断是否有环定义两个指针与起始时都指向链表的起点每次移动个长度每次移动个长度如果在移到链表的尾端时并未与相遇表明链表中不存在环如果与相遇在环上的某一点表明链表有环环的长度将指针固定在相遇位置从点移动每次移动个长度并用变量计数当再次与相遇时此时的值就是环的长度环的起点环的起点即图中点将指针指向链表的起始位置指针仍在位置指针与每次均移动一个单位与再次相遇的位置就是环的起点位置点还有更高效率的做法的移动的兔子和传送的乌龟参阅此链接链表中的哑节点哑节点的意义简化插入和删除操作哑节点可以作为链表的起始节点使得插入和删除操作在任意位置都可以统一处理无论是在链表头部中间还是尾部插入或删除节点都不需要特殊处理边界情况处理空链表当链表为空时哑节点可以作为链表的唯一节点避免了对空链表的额外判断和处理这样在处理链表时不需要单独考虑链表为空的情况简化遍历操作哑节点可以作为链表的起始节点使得遍历链表时不需要对头节点进行特殊处理遍历操作可以从哑节点的下一个节点开始一直遍历到链表的末尾提高代码的一致性和可读性通过使用哑节点链表的操作可以统一处理减少了重复的代码和特殊情况的处理使得代码更加简洁一致和易于理解需要注意的是哑节点并不存储实际的数据它的存在仅仅是为了简化链表的操作在实际应用中根据具体的需求和场景可以选择在链表的头部或尾部添加哑节点使用哑节点的问题代码案例新建哑节点作为结果链表返回动态指针永远指向结果链表最后一个位置只要有一个链表走到末尾就退出循环补上未空链表前缀和可以将求子数组的和为问题转化为求解两个前缀和之差等于的问题通过这种方式在某些题型中可以降低一维题型参考解法如下参考前缀和哈希表优化将求子数组的和为问题转化为求解两个前缀和之差等于的情况使用一个哈希表来存储每个前缀和出现的次数对于任意的两个下标和如果即从第个位置到第个位置的元素之和等于那么说明从第个位置到第个位置的连续子数组的和为此时计数通过遍历数组计算每个位置的前缀和并使用一个哈希表来存储每个前缀和出现的次数在遍历的过程中我们检查是否存在的前缀和如果存在说明从某个位置到当前位置的连续子数组的和为我们将对应的次数累加到结果中为前缀和为该和出现的次数初始化前缀和为出现的次数为如果没有这个初始化那么时中没有判断为就会漏掉这种情况判断是是否存在和为的值上面注释的代码实际上一句就搞定了差分数组荷兰国旗问题荷兰国旗问题该问题由荷兰计算机科学家所提出怎么对一组数做划分左边都小于他右边都大于他中间都等于他不要求有序只要求对数组进行划分参考的颜色分类解决代码如下双指针转移修正巧妙的递归解法思路盘点对称二叉树题目参考递归解法比较两棵树是否对称二叉树和都不为才可能走到这里判断树是否是二叉树该题思路的重点在于将一棵树当成两棵树来比较图解如下改成迭代方式代码如下比较抽象引入一个队列这是把递归程序改写成迭代程序的常用方法初始化时我们把根节点入队两次每次提取两个结点并比较它们的值队列中每两个连续的结点应该是相等的而且它们的子树互为镜像然后将两个结点的左右子结点按相反的顺序插入队列中当队列为空时或者我们检测到树不对称即从队列中取出两个不相等的连续结点时该算法结束全排列全排列伪代码遍历流程代码添加排列方案这里使用交换的原因是因为交换不会破坏本身的元素种类并且最后一个元素可以天然得到保留妙不可言交换将固定在第位开启固定第位元素恢复交换配合循环画龙点睛此代码后面使用交换的方式避免了检测是否已经重复处理过的时间复杂度子集子集这一题找了半天都没有找到递归规律看了题解才明白遂记录下来开始假设输出子集为空子集遍历数组对于数组中的每一个整数每一步都向输出子集中所有子集添加这个整数并生成新的子集最后少了一个的子集是解法如下假设中的元素个数为则的子集个数为时间复杂度空间复杂度巧妙的算法解决记录三数之和三数之和因为即个元素都大于在此固定指针之后不可能再找到结果了重复元素跳过第二指针第三指针找到为的值则插入代码执行流程上面代码详解详解参阅官方最长连续序列最长连续序列记录的这个代码主要是精彩在一次遍历解决问题哈希的为数组中的数为遍历到该元素时如果是某个连续区间的左右端点则为该连续区间的长度否则值无意义伪代码若数已在哈希表中跳过不做处理若是新数加入取出其左右相邻数已有的连续区间长度和计算当前数的区间长度为根据更新最大长度的值更新区间两端点的长度值本质上就是利用的来储存正在处理的数以及他左右的数的序列长度也即是通过来动态叠加连续序列长度第个神奇数字解题思路二分查找容斥原理找神奇数字到范围内的神奇数字的个数为于是就可以使用二分查找不断逼近第个神奇数字的位置而必然是待解决题使用中序遍历算法报栈溢出错误待解决',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-09-03 15:12:10',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://th.bing.com/th/id/OIP.wtmjepfWPBvn26uz7s18dgHaHa?rs=1&amp;pid=ImgDetMain"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">ZEROKO14的个人博客</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AI/" style="font-size: 1.05rem;">AI<sup>1</sup></a><a href="/tags/C/" style="font-size: 1.05rem;">C#<sup>3</sup></a><a href="/tags/C/" style="font-size: 1.05rem;">C++<sup>5</sup></a><a href="/tags/CSS/" style="font-size: 1.05rem;">CSS<sup>1</sup></a><a href="/tags/CSharp/" style="font-size: 1.05rem;">CSharp<sup>1</sup></a><a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 1.05rem;">C语言<sup>1</sup></a><a href="/tags/FPS/" style="font-size: 1.05rem;">FPS<sup>1</sup></a><a href="/tags/HTML/" style="font-size: 1.05rem;">HTML<sup>1</sup></a><a href="/tags/JavaScript/" style="font-size: 1.05rem;">JavaScript<sup>1</sup></a><a href="/tags/MFC/" style="font-size: 1.05rem;">MFC<sup>1</sup></a><a href="/tags/PE/" style="font-size: 1.05rem;">PE<sup>1</sup></a><a href="/tags/QT/" style="font-size: 1.05rem;">QT<sup>1</sup></a><a href="/tags/WPF/" style="font-size: 1.05rem;">WPF<sup>3</sup></a><a href="/tags/ai/" style="font-size: 1.05rem;">ai<sup>1</sup></a><a href="/tags/cmake/" style="font-size: 1.05rem;">cmake<sup>1</sup></a><a href="/tags/doxygen/" style="font-size: 1.05rem;">doxygen<sup>1</sup></a><a href="/tags/git/" style="font-size: 1.05rem;">git<sup>1</sup></a><a href="/tags/linux/" style="font-size: 1.05rem;">linux<sup>1</sup></a><a href="/tags/nas/" style="font-size: 1.05rem;">nas<sup>1</sup></a><a href="/tags/next/" style="font-size: 1.05rem;">next<sup>1</sup></a><a href="/tags/ppt/" style="font-size: 1.05rem;">ppt<sup>1</sup></a><a href="/tags/python/" style="font-size: 1.05rem;">python<sup>1</sup></a><a href="/tags/slidev/" style="font-size: 1.05rem;">slidev<sup>1</sup></a><a href="/tags/vue/" style="font-size: 1.05rem;">vue<sup>1</sup></a><a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 1.05rem;">代码规范<sup>1</sup></a><a href="/tags/%E5%86%85%E6%A0%B8/" style="font-size: 1.05rem;">内核<sup>2</sup></a><a href="/tags/%E5%86%85%E6%A0%B8%E7%9B%B8%E5%85%B3/" style="font-size: 1.05rem;">内核相关<sup>5</sup></a><a href="/tags/%E5%8A%A0%E8%A7%A3%E5%AF%86/" style="font-size: 1.05rem;">加解密<sup>1</sup></a><a href="/tags/%E5%9F%BA%E7%A1%80/" style="font-size: 1.05rem;">基础<sup>6</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 1.05rem;">多线程<sup>1</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F/" style="font-size: 1.05rem;">并发模式<sup>1</sup></a><a href="/tags/%E5%BC%80%E5%8F%91/" style="font-size: 1.05rem;">开发<sup>4</sup></a><a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 1.05rem;">数学<sup>1</sup></a><a href="/tags/%E6%9D%82%E9%A1%B9/" style="font-size: 1.05rem;">杂项<sup>1</sup></a><a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 1.05rem;">正则表达式<sup>1</sup></a><a href="/tags/%E7%89%A9%E7%90%86/" style="font-size: 1.05rem;">物理<sup>1</sup></a><a href="/tags/%E7%9B%91%E6%8E%A7/" style="font-size: 1.05rem;">监控<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 1.05rem;">网络<sup>3</sup></a><a href="/tags/%E9%80%86%E5%90%91/" style="font-size: 1.05rem;">逆向<sup>5</sup></a><a href="/tags/%E9%AD%94%E6%B3%95/" style="font-size: 1.05rem;">魔法<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/09/"><span class="card-archive-list-date">九月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/02/"><span class="card-archive-list-date">二月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/12/"><span class="card-archive-list-date">十二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/11/"><span class="card-archive-list-date">十一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/09/"><span class="card-archive-list-date">九月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">七月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">14</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/06/"><span class="card-archive-list-date">六月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/04/"><span class="card-archive-list-date">四月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url">技术</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>算法</span></a></span></div></div><h1 class="post-title" itemprop="name headline">算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2020-12-23T14:51:13.000Z" title="发表于 2020-12-23 22:51:13">2020-12-23</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-09-03T07:12:10.249Z" title="更新于 2025-09-03 15:12:10">2025-09-03</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="算法"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为新加坡"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>新加坡</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://che77a38.github.io/posts/%E7%AE%97%E6%B3%95/"><header><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url">技术</a><a href="/tags/%E7%AE%97%E6%B3%95/" tabindex="-1" itemprop="url">算法</a><h1 id="CrawlerTitle" itemprop="name headline">算法</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">ZEROKO14</span><time itemprop="dateCreated datePublished" datetime="2020-12-23T14:51:13.000Z" title="发表于 2020-12-23 22:51:13">2020-12-23</time><time itemprop="dateCreated datePublished" datetime="2025-09-03T07:12:10.249Z" title="更新于 2025-09-03 15:12:10">2025-09-03</time></header><p>算法是指解决问题的方法(或过程),是若干指令的有穷序列</p>
<p><strong>算法的本质就是「穷举」</strong></p>
<blockquote>
<p>算法的本质都是穷举二（多）叉树，有机会的话通过剪枝或者备忘录的方式减少冗余计算，提高效率</p>
</blockquote>
<span id="more"></span>

<p>利用计算机的速度,解决现实中的抽象问题</p>
<p>穷举要做到两点</p>
<ul>
<li>无遗漏</li>
<li>无冗余</li>
</ul>
<p>遗漏会导致算法错误,冗余会拖慢算法运行速度</p>
<p>算法的难点在于两类问题</p>
<ul>
<li><p>如何穷举(递归算法往往解决的是这类问题)</p>
</li>
<li><p>如何聪明的穷举</p>
<p>比如后文 Union Find 并查集算法详解,告诉你一种高效计算连通分量的技巧，理论上说，想判断两个节点是否连通，用DFS&#x2F;BFS 暴力搜索（穷举）肯定可以做到，但人家 Union Find 算法硬是用数组模拟树结构，给你把连通性相关的操作复杂度给干到<code>O(1)</code>了。<br>再比如贪心算法技巧，所谓贪心算法就是在题目中发现一些规律（专业点叫贪心选择性质），使得你不用完整穷举所有解就可以得出答案。<br>动态规划好歹是无冗余地穷举所有解，然后找一个最值，贪心算法倒好，都不用穷举所有解就可以找到答案，所以后文贪心算法解决跳跃游戏 中贪心算法的效率比动态规划还高。<br>再比如大名鼎鼎的KMP算法，KMP 算法的本质是聪明地缓存并复用一些信息，减少了冗余计算，后文 KMP 字符匹配算法 就是使用计算机的思路实现的 KMP 算法。</p>
</li>
</ul>
<blockquote>
<p>顺便强调下，「算法工程师」做的这个「算法」，和「数据结构与算法」中的这个「算法」完全是两码事</p>
<p><strong>对前者来说，重点在数学建模和调参经验，计算机真就只是拿来做计算的工具而已；而后者的重点是计算机思维，需要你能够站在计算机的视角，抽象、化简实际问题，然后用合理的数据结构去解决问题。</strong></p>
<p>所以，你千万别以为学好了数据结构和算法就能去做算法工程师，也不要以为只要不做算法工程师就不需要学习数据结构和算法。坦白说，大部分开发岗位工作中都是基于现成的开发框架做事，不怎么会碰到底层数据结构和算法相关的问题，但另一个事实是，只要找技术相关的岗位，数据结构和算法的考察是绕不开的，因为这块知识点是公认的程序员基本功。</p>
<p>为了区分，不妨称算法工程师研究的算法为「<strong>数学算法</strong>」，称刷题面试的算法为「计算机算法」，此篇内容主要聚焦的是「<strong>计算机算</strong><br><strong>法</strong>」。</p>
<p>「计算机算法」的思维恰恰相反：有没有什么数学公式就交给你们人类去推导吧，如果能找到一些巧妙的定理那最好，但如果找不<br>到，那就穷举呗，反正只要复杂度允许，没有什么答案是穷举不出来的</p>
</blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Tb411M7FA?from=search&amp;seid=12518312174180048412&amp;spm_id_from=333.337.0.0">算法导论-麻省理工</a></li>
<li><a target="_blank" rel="noopener" href="http://erdengk.top/archives/zuo-lao-shi-suan-fa-ke-xue-xi-jian-yi">前人学习经验</a></li>
<li><a target="_blank" rel="noopener" href="https://labuladong.github.io/algo/home/">大佬非常全面的博客</a></li>
</ul>
<h1 id="算法入门"><a href="#算法入门" class="headerlink" title="算法入门"></a>算法入门</h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2//202312182212066.png" alt="image-20231218221243795" style="zoom: 25%;" />

<blockquote>
<p>时间复杂度是衡量算法执行时间的一个指标，它表示算法运行时间随输入规模增长的趋势。通常使用大O符号表示，描述算法在输入规模增大时的渐进行为。</p>
<p>举个例子，冒泡排序算法的时间复杂度是 $O(n^2)$，这意味着算法的运行时间与输入规模的平方成正比。也就是说，当输入规模翻倍时，算法的运行时间会变为原来的四倍。</p>
<p>时间复杂度可以有多种不同的衡量方式。一种常见的方式是计算算法执行的操作次数。另一种方式是测量算法在特定计算机上运行所需的时间。</p>
<p>时间复杂度在算法设计中非常重要，因为它可以帮助确定算法的效率。时间复杂度较高的算法可能不适用于大规模数据集，因为它们可能需要太长的运行时间。</p>
<p>有许多技巧可以改善算法的时间复杂度。一种常见的方法是使用分治策略，将问题分解为更小的子问题，以便更高效地解决。另一种方法是使用动态规划，将子问题的结果存储起来，避免重复计算。</p>
<p>时间复杂度是一个复杂的主题，没有一种通用的方法适用于所有算法。然而，通过了解不同的时间复杂度衡量方式，并使用适当的技巧改善算法的时间复杂度，可以设计出适用于各种问题的高效算法。</p>
</blockquote>
<p><strong>常数时间的操作：</strong>一个操作如果和样本的数据量没有关系，每次都是固定时间内完成的操作，叫做<strong>常数操作</strong></p>
<p>时间复杂度为一个算法流程中，常数操作数量的一个指标。常用O(读作big O)来表示。具体来说，先要对一个算法流程非常熟悉，然后去写出这个算法流程中，发生了多少常数操作，进而总结出常数操作数量的表达式。</p>
<p>表达式中，只要高阶项，不要低阶项的系数（阶：未知数的次方数），剩下的部分如果为f(N)，那么时间复杂度为O(f(N))。</p>
<p><strong>【评价一个算法流程的好坏】</strong>:先看时间复杂度的指标，然后再分析不同数据样本下的实际运行时间，也就是“常数项时间”。</p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>与时间复杂度相似,但针对空间</p>
<h1 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h1><ul>
<li>递归与分治Divide and Conquer</li>
<li>动态规划Dynamic Programming</li>
<li>贪心算法Greedy</li>
<li>回溯算法Backtrack</li>
<li>分支限界法Branch and Bound</li>
<li>随机算法</li>
<li>近似算法</li>
</ul>
<p>算法第一步是<a href="#%E9%97%AE%E9%A2%98%E5%BB%BA%E6%A8%A1">问题建模</a></p>
<h2 id="问题建模"><a href="#问题建模" class="headerlink" title="问题建模"></a>问题建模</h2><p>问题类型:</p>
<ul>
<li>计数问题</li>
<li>构造问题</li>
<li>判定问题(二元的,yes or no)</li>
<li>最优化问题</li>
</ul>
<p>问题建模:</p>
<ol>
<li>输入<code>input</code>:定义问题空间(即特定对象集合)</li>
<li>输出<code>output</code>:定义解空间</li>
<li>约束<code>constraint</code>:定义约束函数</li>
<li>目标<code>objective function</code>:定义目标函数</li>
</ol>
<p>问题实例:<code>instance of a problem</code>:问题模型的实例化,即<strong>一个给定输入的实际问题</strong></p>
<h3 id="图灵机"><a href="#图灵机" class="headerlink" title="图灵机"></a>图灵机</h3><blockquote>
<p>1936年，Alan M. Turing （1912-1954）提出了一种在理论计算机科学中广泛采用的抽象计算机<br>它是通用数字计算机的理论原型。图灵机可制造出一种十分简单但计算能力极强的计算机装置。</p>
</blockquote>
<p>用有限的指令和有限的存储空间可算尽一切可算之物。</p>
<p>一台图灵机是一个七元组</p>
<p>图灵机&#x3D;有限状态自动机+无限纸带 &#x3D;&gt;  算尽一切可算之物</p>
<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><ul>
<li>概念</li>
</ul>
<p>排序是计算机内经常进行的一种操作，其目的是将一组“无序”的数据元素调整为“有序”的数据元素。</p>
<ul>
<li>排序数学定义：</li>
</ul>
<p>假设含n个数据元素的序列为{ R1, R2, …, Rn}，其相应的关键字序列为{ K1, K2, …, Kn}这些关键字相互之间可以进行比较，即在它们之间存在着这样一个关系 ：</p>
<p>Kp1≤Kp2≤…≤Kpn</p>
<p>按此固有关系将上式记录序列重新排列为{ Rp1, Rp2, …，Rpn}的操作称作排序</p>
<ul>
<li>排序的稳定性</li>
</ul>
<p>如果在序列中有两个数据元素r[i]和r[j]，它们的关键字k[i] &#x3D;&#x3D; k [j]，且在排序之前，对象r[i]排在r[j]前面。如果在排序之后，对象r[i]仍在r[j]前面，则称这个排序方法是稳定的，否则称这个排序方法是不稳定的。</p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/%E5%9B%BE%E7%89%8746.png" alt="img" style="zoom: 50%;" />

<ul>
<li>内排序和外排序<ol>
<li>内排序：在排序过程中，待排序的所有记录全部都放置在内存中，排序分为：内排序和外排序。</li>
<li>外排序：由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要在内外存之间多次交换数据才能进行。</li>
</ol>
</li>
<li>排序的审判<ol>
<li>时间性能：关键性能差异体现在比较和交换的数量</li>
<li>辅助存储空间：为完成排序操作需要的额外的存储空间，必要时可以“空间换时间”</li>
<li>算法的实现复杂性：过于复杂的排序法会影响代码的可读性和可维护性，也可能影响排序的性能</li>
</ol>
</li>
<li>总结<ol>
<li>排序是数据元素从无序到有序的过程</li>
<li>排序具有稳定性，是选择排序算法的因素之一</li>
<li>比较和交换是排序的基本操作</li>
<li>多关键字排序与单关键字排序无本质区别</li>
<li>排序的时间性能是区分排序算法好坏的主要因素</li>
</ol>
</li>
</ul>
<p>其他的一些排序算法:</p>
<ol>
<li><a href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">快速排序</a>（Quick Sort）：快速排序是一种基于分治思想的排序算法，通过选择一个基准元素，将数组分为两个子数组，并递归地对子数组进行排序。快速排序的平均时间复杂度为O(nlogn)，在大多数情况下具有较高的效率。(快速排序与下文的排序算法不是一个东西)</li>
<li><a href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F">归并排序</a>（Merge Sort）：归并排序也是一种分治算法，它将数组递归地分成两个子数组，然后将两个有序子数组合并成一个有序数组。归并排序的时间复杂度为O(nlogn)，并且具有稳定性。</li>
<li><a href="#%E5%A0%86%E6%8E%92%E5%BA%8F">堆排序</a>（Heap Sort）：堆排序利用堆这种数据结构进行排序，通过构建最大堆或最小堆来实现排序。堆排序的时间复杂度为O(nlogn)，并且具有<strong>原地排序</strong>的特点。</li>
</ol>
<p>需要注意的是，这些算法的性能取决于输入数据的规模和特征。对于小规模的数据集，简单的排序算法如插入排序和冒泡排序可能更高效。对于已经部分有序的数据集，插入排序和冒泡排序也可能比其他算法更快。</p>
<p>C++标准库中的<code>std::sort</code>函数使用了一种高效的排序算法（通常是快速排序或归并排序）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202401121114843.png" alt="sort"></p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>时间复杂度是$O(n^2)$</p>
<ul>
<li>冒泡排序是一种效率低下的排序方法，在数据规模很小时，可以采用。数据规模比较大时，最好用其它排序方法。</li>
<li>上述例子对冒泡做了优化，添加了flag作为标记，记录序列是否已经有序，减少循环次数。</li>
</ul>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>时间复杂度是$O(n^2)$</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/%E5%9B%BE%E7%89%8747.png" alt="img"  />

<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序算法是一种简单的排序算法，也成为直接插入排序算法。它是一种稳定的排序算法，对局部有序的数据具有较高的效率。</p>
<p>插入排序算法是一个队少量元素进行排序的有效算法。比如，打牌是我们使用插入排序方法最多的日常生活例子。我们在摸牌时，一般会重复一下步骤。期初，我们手里没有牌，摸出第一张，随意放在左手上，以后每一次摸排，都会按照花色从小到大排列，直到所有的牌摸完。插入排序算法采用的类似思路，每一次从无序序列中拿出一个数据，将它放到已排序的序序列的正确位置，如此重复，直到所有的无序序列中的数据都找到了正确位置。</p>
<p>插入排序（Insertion Sort）的时间复杂度是$O(n^2)$。在最坏的情况下，需要比较和移动元素的次数是n(n-1)&#x2F;2次，其中n是待排序数组的长度。</p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>时间复杂度为O(nlogn)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://www.bilibili.com/video/BV1pd4y1z7gf" alt="快排流程动画|720x360"></p>
<p>下面代码是使用交换法实现的快排</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> left,<span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&gt;=right)</span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">//递归结束条件</span></span><br><span class="line">    <span class="comment">//双指针</span></span><br><span class="line">    <span class="type">int</span> i=left;</span><br><span class="line">    <span class="type">int</span> j=right;</span><br><span class="line">    <span class="type">int</span> key=arr[left];<span class="comment">//选取第一个数为基准数</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="comment">//不断往右移动左指针,找到第一个大于基准数的数</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;j&amp;&amp;arr[j]&gt;=key)</span><br><span class="line">        &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不断往左移动右指针,找到第一个小于基准数的数</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;j&amp;&amp;arr[i]&lt;=key)</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)<span class="comment">//意思就是i==j的时候不交换,会走向循环跳出</span></span><br><span class="line">            <span class="built_in">swap</span>(arr[i], arr[j]);<span class="comment">//交换arr中i和j指针指向的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(arr[i], arr[left]);</span><br><span class="line">    <span class="comment">//一轮基准值定位已经结束</span></span><br><span class="line">    <span class="comment">//该递归处理两边的数组了(此时i==j了,用哪个无所谓)</span></span><br><span class="line">    <span class="built_in">quickSort</span>(arr,left,i<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(arr,j<span class="number">+1</span>,right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>时间复杂度为O(nlogn)</p>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>时间复杂度为O(nlogn)</p>
<p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
<blockquote>
<p>基本思想</p>
<p>利用大顶堆(小顶堆)堆顶记录的是最大关键字(最小关键字)这一特性，使得每次从无序中选择最大记录(最小记录)变得简单。</p>
</blockquote>
<p>倒序对每个父节点进行下潜操作,通过这个操作使得混乱数组具备堆序性,如下流程</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202401141635053.gif" alt="堆排序" style="zoom: 33%;" />

<p>反复调用<code>pop_heap</code>函数来实现，每次将最大元素移动到范围的末尾,就可以实现堆排序</p>
<p><code>pop_heap</code>函数的实现参考下面流程: </p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202401141703357.gif" alt="pop" style="zoom:33%;" />

<p>[[数据结构#堆|堆的详解点击跳转]]</p>
<p>[[stl#堆相关算法|stl中也有提供各种现成函数]]</p>
<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<p>① 找出待排序的数组中最大和最小的元素<br>② 统计数组中每个值为i的元素出现的次数，存入数组C的第i项<br>③ 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）<br>④ 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202401122024954.gif" alt="计数排序" style="zoom:67%;" />

<p>平均时间复杂度：O(n + k)<br>最佳时间复杂度：O(n + k)<br>最差时间复杂度：O(n + k)<br>空间复杂度：O(n + k)</p>
<h2 id="随眠排序"><a href="#随眠排序" class="headerlink" title="随眠排序"></a>随眠排序</h2><p>遍历数组,对每个元素创建一个新线程,该线程休眠的时间与元素的值成正比</p>
<p>将排序任务委托给了CPU的调度器…</p>
<h1 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h1><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p><strong>无重复元素</strong> 的 <strong>升序</strong> 排列数组中的插入查找</p>
<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">                left = mid + <span class="number">1</span>;<span class="comment">//灵魂就在于这个+1和下面的-1</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(log⁡n)，其中 n 为数组的长度。二分查找所需的时间复杂度为 O(log⁡n)</li>
<li>空间复杂度：O(1)。我们只需要常数空间存放若干变量</li>
</ul>
<h1 id="字符串匹配算法"><a href="#字符串匹配算法" class="headerlink" title="字符串匹配算法"></a>字符串匹配算法</h1><h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><p>一种改进的字符串匹配算法,利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的,将时间复杂度从<code>O(m*n)</code>变成<code>O(m+n)</code></p>
<p><strong>next数组</strong>含义为存放子串对应下标前存在的最长相等前后缀的长度(相等前后缀不能是字符串本身)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://www.bilibili.com/video/BV1AY4y157yL" alt="视频讲解跳转|720x360"></p>
<h3 id="生成next数组函数"><a href="#生成next数组函数" class="headerlink" title="生成next数组函数"></a>生成next数组函数</h3><p><strong>[递推思维]</strong>: 通过已经掌握的信息,来避免进行重复的运算</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成next数组(next数组含义为存放子串对应下标前存在的最长相等前后缀的长度)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">generateNext</span><span class="params">(<span class="type">char</span>* str,<span class="type">int</span>* next)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> strLen = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="type">int</span> prefixLocate = <span class="number">0</span>;<span class="comment">//前缀末尾指针,也可以表示相等前后缀长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; strLen; i++)<span class="comment">//i表示准备填写的next数组下标,跳过0是因为kkmpSearch函数中针对0下标不使用next数组的值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i]==str[prefixLocate])<span class="comment">//前后相等情况</span></span><br><span class="line">        &#123;</span><br><span class="line">            prefixLocate++;</span><br><span class="line">            next[i] = prefixLocate;<span class="comment">//相等就将累计的相等前缀长度赋给next对应位置</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//遇到前后不相等情况</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (prefixLocate == <span class="number">0</span>)<span class="comment">//相等前后缀长度为0</span></span><br><span class="line">            &#123;</span><br><span class="line">                next[i]=<span class="number">0</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//相等前后缀长度不为0,可以利用之前的相等前后缀递推</span></span><br><span class="line">            &#123;</span><br><span class="line">                prefixLocate=next[prefixLocate<span class="number">-1</span>];<span class="comment">//递推思维的关键代码</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>更简洁的版本</strong></p>
<p>任何位置匹配到的同时+1,就继续匹配下一个,同时把当前匹配的数量写入next[i+1]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pat,vector&lt;<span class="type">int</span>&gt;&amp; next)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="built_in">strlen</span>(pat) - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || pat[i] == pat[j]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="kmp搜索函数"><a href="#kmp搜索函数" class="headerlink" title="kmp搜索函数"></a>kmp搜索函数</h3><p>借助于next数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kmpSearch</span><span class="params">(<span class="type">char</span>* str,<span class="type">char</span>* subStr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//生成next数组</span></span><br><span class="line">    <span class="type">int</span> strLen = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="comment">//std::cout&lt;&lt;&quot;主串为:&quot;&lt;&lt;str&lt;&lt;std::endl;</span></span><br><span class="line">    <span class="comment">//std::cout&lt;&lt;&quot;主串长度为:&quot;&lt;&lt;strLen&lt;&lt;std::endl;</span></span><br><span class="line">    <span class="type">int</span> subStrLen = <span class="built_in">strlen</span>(subStr);</span><br><span class="line">    <span class="comment">//std::cout&lt;&lt;&quot;子串为:&quot;&lt;&lt;subStr&lt;&lt;std::endl;</span></span><br><span class="line">    <span class="comment">//std::cout&lt;&lt;&quot;子串长度为:&quot;&lt;&lt;subStrLen&lt;&lt;std::endl;</span></span><br><span class="line">    <span class="type">int</span>* next = new <span class="type">int</span>[subStrLen];</span><br><span class="line">    <span class="built_in">memset</span>(next,<span class="number">0</span>,subStrLen);</span><br><span class="line">    generateNext(subStr,next); </span><br><span class="line">    <span class="comment">//展示next数组=====================</span></span><br><span class="line">    <span class="comment">/*std::cout&lt;&lt;&quot;分析得到的next数组为&quot;&lt;&lt;std::endl;</span></span><br><span class="line"><span class="comment">    for (int i = 0; i &lt; subStrLen; i++)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        cout&lt;&lt;next[i]&lt;&lt;&quot; &quot;;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    std::cout&lt;&lt;std::endl;*/</span></span><br><span class="line">    <span class="comment">//==================================</span></span><br><span class="line">    <span class="comment">//开始查找</span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;<span class="comment">//子串下标</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;<span class="comment">//主串下标</span></span><br><span class="line">   <span class="keyword">while</span>(i&lt;strLen)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="comment">//匹配的话,主串与子串下标相加</span></span><br><span class="line">        <span class="keyword">if</span>(subStr[j]==str[i])</span><br><span class="line">        &#123;</span><br><span class="line">            i++;j++;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(j&gt;<span class="number">0</span>)<span class="comment">//子串非第一个就不匹配,更新子串下标</span></span><br><span class="line">        &#123;</span><br><span class="line">            j = next[j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//子串第一个就不匹配</span></span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j==subStrLen)<span class="comment">//全都相等就跳出循环,返回找到的下标</span></span><br><span class="line">        &#123;</span><br><span class="line">            delete [] next;</span><br><span class="line">            <span class="keyword">return</span> i-j;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    delete [] next;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM算法"><a href="#BM算法" class="headerlink" title="BM算法"></a>BM算法</h2><p>Boyer-Moore字符串搜索算法</p>
<p>字符串匹配BM算法,全称是<code>Boyer-Moore</code>算法,其核心思想是:在模式串中某个字符与主串不能匹配的时候,将模式串往后<strong>多滑动几位</strong>,以此提高匹配的效率</p>
<p>为了能够一次性多滑动几位,在真正进行字符串匹配之前,先进行了一系列预处理操作,遵循 <strong>坏字符规则</strong> 和 <strong>好后缀规则</strong></p>
<h3 id="坏字符规则"><a href="#坏字符规则" class="headerlink" title="坏字符规则"></a>坏字符规则</h3><p>按模式串倒序匹配的过程中,把匹配失败时主串中的字符,叫做坏字符,然后在模式串中查找坏字符,若找到匹配字符,则将模式串中的匹配字符和坏字符对齐,否则直接将模式串滑动到坏字符之后的一位,再重复进行上述过程.</p>
<p>把坏字符在模式串中的位置记为 si 值，如果 坏字符 在 模式串 中存在，将坏字符在模式串中的下标记作 xi 值，若不存在 xi 记作 -1，移动的位数就等于 si-xi 值。</p>
<p>把坏字符在模式串中的位置记为 si 值，如果 坏字符 在 模式串 中存在，将坏字符在模式串中的下标记作 xi 值，若不存在 xi 记作 -1，移动的位数就等于 si-xi 值。</p>
<p>注意：单纯采用坏字符的策略，计算出来的移动位数有可能是负数，因此 BM 算法还需要使用好后缀规则来避免这种情况。因此，<strong>在该算法中可以省略坏字符规则，却不能省略好后缀规则。</strong></p>
<h3 id="好后缀规则"><a href="#好后缀规则" class="headerlink" title="好后缀规则"></a>好后缀规则</h3><p>按模式串 倒序匹配 过程中，失配点之后模式串中 匹配成功的那段字符-U ，为好后缀。好后缀规则在于，考虑能否根据 已经匹配成功 的字符，直接推算出下次移动的位置。</p>
<blockquote>
<p>理论依据：如果 <code>好后缀-U</code> 在模式串找不到 另一个 匹配子串，只要 <code>U-整体</code> 还参与匹配，就肯定无法匹配，因为已经确定模式串中没有与和 <code>U-整体</code> 相同的字符串。但若 <code>U-的部分后缀</code> 和 <code>模式串的前缀</code> 有 重合 且相等，则有可能会完全匹配。</p>
</blockquote>
<p>上图是 只 基于 好后缀规则 的匹配过程，涉及 后缀整体匹配 和 后缀子串和模式串前缀 的匹配。而下图则是 坏字符+好后缀 两种规则的匹配方式，具体选哪种取决于可移动的最大距离。</p>
<h2 id="Sunday算法"><a href="#Sunday算法" class="headerlink" title="Sunday算法"></a>Sunday算法</h2><blockquote>
<p>  Sunday算法实际上是一种对BM算法的改进，其基本思路与BM算法相似。但是与BM算法不同的是，Sunday算法的比较是从模式串的开头进行比较的，并且Sunday算法在不匹配情况发生时，模式串跳转的幅度更大，所以从这一点上来说，Sunday算法的效率甚至比BM算法更高。</p>
</blockquote>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>从左到右比对,当发现比对失败时候(w),观察与模式串对齐的最后一位字符的下一位字符（本例中就是文本串中的D）是否出现在模式串中。</p>
<p>这一做法的意图是：如果文本串中，与模式串对齐位置上的下一位字符，也就是文本串中的D并没有出现在文本串中的话，那么就可以确定，从失配字符W向后，一直到字符D中间的这段内容与模式串肯定是不可能匹配了，所以我们可以直接跳过这段内容，直接将模式串跳转到字符D后面的位置进行对齐，然后重新开始比较。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202304011925190.png" alt="image-20230401191518703" style="zoom: 50%;" />

<p>  依然以上图为例，在进行模式串跳转之后，我们发现文本串中的_与模式串中的F首先就是不匹配的：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202304011933178.png" alt="image-20230401193314291"></p>
<p>但是此时在文本串中，与模式串对齐的下一位字符T在模式串中出现过：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202304011933817.png" alt="image-20230401193339668" style="zoom:50%;" />

<p>  此时，我们将与模式串对齐的下一位字符与模式串中出现的位置对齐，然后继续进行比较：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202304011934699.png" alt="image-20230401193429201" style="zoom:50%;" />

<h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>坏字表:记录了是否有某个字符(-1表示没有该字符),又记录了字符最后出现的位置.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sunday</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *text, <span class="type">const</span> <span class="type">char</span> *pattern)</span> </span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> BASE 256</span></span><br><span class="line">	<span class="type">int</span> n = <span class="built_in">strlen</span>(text), m, last_pos[BASE];</span><br><span class="line">	<span class="comment">//last_pos的每一个索引表示一个字符，因为字符本身就能通过ascll码表示为整数。</span></span><br><span class="line">	<span class="comment">//last_pos的值表示pattern中的元素在末尾的哪一位出现</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; BASE; i++) last_pos[i] = <span class="number">-1</span>; <span class="comment">//初始化坏字表为-1</span></span><br><span class="line">	<span class="keyword">for</span> (m = <span class="number">0</span>; pattern[m]; m++) last_pos[pattern[m]] = m; <span class="comment">//m为字串到\0的长度</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i + m &lt;= n; i += (m - last_pos[text[i + m]])) &#123;</span><br><span class="line">		<span class="comment">//如果没匹配成功，那么text的索引i向后移动 m - last_pos[text[i + m]] 位，m为模式串的长度</span></span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (text[i + j] == pattern[j]) <span class="keyword">continue</span>;</span><br><span class="line">			flag = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (flag) <span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该算法也常用于特征码查询.(下面代码为<a target="_blank" rel="noopener" href="https://blog.csdn.net/jinwei29/article/details/121265942">转载</a>,未测试)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;psapi.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"> <span class="function">std::string <span class="title">DeleteStringSpace</span><span class="params">(std::string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    str.<span class="built_in">erase</span>(std::<span class="built_in">remove</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>(), <span class="string">&#x27; &#x27;</span>), str.<span class="built_in">end</span>()); <span class="comment">// 删除所有空格</span></span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function">DWORD <span class="title">aobScan</span><span class="params">(HANDLE hProcess, HMODULE hModule, string 特征码,<span class="type">int</span> CallOffset=<span class="number">0</span>,DWORD* outCallAddre=<span class="number">0</span>,<span class="type">int</span> BaseAddreOffset=<span class="number">0</span>, DWORD* outBaseAddr=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">	</span>&#123;<span class="comment">//进程PID，模块句柄，特征码，CallOffset：找call偏移-上负下正，BaseAddreOffset：找基址偏移；偏移是从特征码地址算起</span></span><br><span class="line">		string tzm = <span class="built_in">DeleteStringSpace</span>(特征码);<span class="comment">//删除特征码所有空格</span></span><br><span class="line">		<span class="type">int</span> tzmLen = tzm.<span class="built_in">length</span>() / <span class="number">2</span>;<span class="comment">//特征码长度</span></span><br><span class="line">		<span class="keyword">if</span> (tzm.<span class="built_in">length</span>() % <span class="number">2</span> != <span class="number">0</span>)<span class="comment">/*特征码长度不能为单数*/</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		byte* tzmByte = <span class="keyword">new</span> byte[tzmLen];<span class="comment">//定义一个字节变量并开辟指定长度的内存空间</span></span><br><span class="line">		<span class="type">int</span> 通配符首次位置 = <span class="built_in">StringToByte</span>(tzm, tzmByte);</span><br><span class="line"> </span><br><span class="line">		MODULEINFO mMoudleInfo;</span><br><span class="line">		<span class="built_in">GetModuleInformation</span>(hProcess, hModule, &amp;mMoudleInfo, <span class="built_in">sizeof</span>(mMoudleInfo));</span><br><span class="line">		DWORD  ModuleBeginAddr = (DWORD)hModule;<span class="comment">//模块开始地址</span></span><br><span class="line">		DWORD  ModuleSize =mMoudleInfo.SizeOfImage;<span class="comment">//模块大小</span></span><br><span class="line">		DWORD  ModuleEndAddr = ModuleBeginAddr + ModuleSize;<span class="comment">//模块结束地址</span></span><br><span class="line"> </span><br><span class="line">		BYTE *pMemBuffer = <span class="literal">NULL</span>;<span class="comment">//存放读取的内存数据的缓冲区		</span></span><br><span class="line">		MEMORY_BASIC_INFORMATION mbi;<span class="comment">//内存信息</span></span><br><span class="line">		<span class="type">clock_t</span> nBeginTime = <span class="built_in">clock</span>();<span class="comment">//记录起始搜索时间</span></span><br><span class="line"> </span><br><span class="line">		<span class="keyword">while</span> (ModuleBeginAddr &lt; ModuleEndAddr)<span class="comment">//结束条件</span></span><br><span class="line">		&#123;<span class="comment">//开始扫描内存</span></span><br><span class="line">			<span class="built_in">memset</span>(&amp;mbi, <span class="number">0</span>, <span class="built_in">sizeof</span>(MEMORY_BASIC_INFORMATION));<span class="comment">//查询地址空间中内存地址的信息</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">VirtualQueryEx</span>(hProcess, (LPCVOID)ModuleBeginAddr, &amp;mbi, <span class="built_in">sizeof</span>(mbi)) == <span class="number">0</span>)<span class="keyword">break</span>;;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (MEM_COMMIT == mbi.State &amp;&amp; PAGE_READWRITE == mbi.Protect || PAGE_EXECUTE_READWRITE == mbi.Protect)</span><br><span class="line">			&#123;<span class="comment">//过滤内存空间, 根据内存的状态和保护属性进行过滤</span></span><br><span class="line">				<span class="keyword">if</span> (pMemBuffer) &#123;<span class="comment">// 申请动态内存</span></span><br><span class="line">					<span class="keyword">delete</span>[] pMemBuffer; pMemBuffer = <span class="literal">NULL</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				pMemBuffer = <span class="keyword">new</span> BYTE[mbi.RegionSize];</span><br><span class="line">				<span class="keyword">if</span> (!<span class="built_in">ReadProcessMemory</span>(hProcess, (LPCVOID)ModuleBeginAddr, pMemBuffer, mbi.RegionSize, <span class="number">0</span>))<span class="keyword">continue</span>;</span><br><span class="line">				UINT deviation = <span class="built_in">SundayCmp</span>(pMemBuffer, mbi.RegionSize, tzmByte, tzmLen, 通配符首次位置);</span><br><span class="line">				<span class="keyword">if</span> (<span class="number">-1</span> != deviation)<span class="comment">//deviation是偏移</span></span><br><span class="line">				&#123;<span class="comment">//-1为没有找到 </span></span><br><span class="line">					<span class="type">clock_t</span> nEndTime = <span class="built_in">clock</span>();<span class="comment">//记录结束时间</span></span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot; %x  用时：%d 毫秒\r\n&quot;</span>, ModuleBeginAddr + deviation, nEndTime - nBeginTime);</span><br><span class="line">					<span class="keyword">if</span> (<span class="number">0</span>!=CallOffset)</span><br><span class="line">					&#123;<span class="comment">//如果是找call</span></span><br><span class="line">						DWORD temp; </span><br><span class="line">						<span class="built_in">memcpy</span>(&amp;temp, &amp;pMemBuffer[deviation  + CallOffset + <span class="number">1</span>], <span class="number">4</span>);<span class="comment">//拷贝出对应地址上的机器码，复制4个字节</span></span><br><span class="line">						<span class="built_in">printf</span>(<span class="string">&quot; 返回call： %X  用时：%d 毫秒\r\n&quot;</span>, ModuleBeginAddr + deviation+ CallOffset + temp <span class="number">+5</span>, nEndTime - nBeginTime);</span><br><span class="line">						*outCallAddre= ModuleBeginAddr + deviation + CallOffset + temp <span class="number">+5</span>;<span class="comment">//下一条指令地址(也就是目标地址 + 5)</span></span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (<span class="number">0</span>!=BaseAddreOffset)</span><br><span class="line">					&#123;<span class="comment">//如果是找基址</span></span><br><span class="line">						DWORD temp;</span><br><span class="line">						<span class="built_in">memcpy</span>(outBaseAddr, &amp;pMemBuffer[deviation + BaseAddreOffset], <span class="number">4</span>);<span class="comment">//拷贝出对应地址上的机器码，复制4个字节</span></span><br><span class="line">						<span class="built_in">printf</span>(<span class="string">&quot; 返回基址： %X \r\n&quot;</span>, outBaseAddr);<span class="comment">//</span></span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">return</span> ModuleBeginAddr + deviation;<span class="comment">//返回特征码地址</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			ModuleBeginAddr += mbi.RegionSize; <span class="comment">//取下一块内存地址</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//没找到返回</span></span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">StringToByte</span><span class="params">(string &amp;markCode,byte* pMarkCode)</span></span></span><br><span class="line"><span class="function">	</span>&#123;<span class="comment">//带通配符的string字符串转byte字节数组</span></span><br><span class="line">		<span class="type">int</span> markCodeLen = markCode.<span class="built_in">length</span>() / <span class="number">2</span>;</span><br><span class="line">		<span class="type">int</span> 通配符第<span class="number">1</span>次出现的位置 = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//pMarkCode = new BYTE[markCodeLen];</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; markCodeLen; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			string tempStr = markCode.<span class="built_in">substr</span>(i * <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">			<span class="keyword">if</span> (tempStr == <span class="string">&quot;??&quot;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				pMarkCode[i] = <span class="number">0x3F</span>;</span><br><span class="line">				<span class="keyword">if</span> (通配符第<span class="number">1</span>次出现的位置 == <span class="number">0</span>) 通配符第<span class="number">1</span>次出现的位置 = i;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				pMarkCode[i] = <span class="built_in">strtoul</span>(tempStr.<span class="built_in">c_str</span>(), <span class="number">0</span>, <span class="number">16</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> 通配符第<span class="number">1</span>次出现的位置;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">SundayCmp</span><span class="params">(byte* dest, <span class="type">int</span> destLen, byte* pattern, <span class="type">int</span> patternLen, <span class="type">int</span> 通配符第<span class="number">1</span>次出现的位置)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> nOffset = <span class="number">0</span>;<span class="comment">//偏移量</span></span><br><span class="line">		<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, nCount = <span class="number">0</span>;<span class="comment">//数组下标：内存、特征码、返回地址</span></span><br><span class="line"> </span><br><span class="line">		<span class="type">int</span> Shift[<span class="number">0xFF</span> + <span class="number">1</span>] = &#123; <span class="number">0</span> &#125;;<span class="comment">//Sunday算法模板数组赋值，+1防止特征码出现FF时越界</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; 通配符第<span class="number">1</span>次出现的位置; i++) &#123;</span><br><span class="line">			Shift[pattern[i]] = i + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">while</span> (j &lt; patternLen)</span><br><span class="line">		&#123;<span class="comment">//以特征码长度进行循环</span></span><br><span class="line">			<span class="keyword">if</span> (dest[i] == pattern[j] || pattern[j] == <span class="number">0x3F</span>)<span class="comment">//0x3F代表通配符</span></span><br><span class="line">			&#123;<span class="comment">//如果相等</span></span><br><span class="line">				i++; j++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				nOffset = i - j + 通配符第<span class="number">1</span>次出现的位置;</span><br><span class="line">				<span class="keyword">if</span> (nOffset &gt; destLen - patternLen)<span class="comment">/*判断偏移量是否大于缓冲区*/</span> <span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">if</span> (Shift[dest[nOffset]])</span><br><span class="line">				&#123;<span class="comment">//判断 Shift模板数组 里有没有 内存偏移后的值，有则回溯，否则+1</span></span><br><span class="line">					i = nOffset - Shift[dest[nOffset]] + <span class="number">1</span>;</span><br><span class="line">					j = <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					i = nOffset + <span class="number">1</span>;</span><br><span class="line">					j = <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (j == patternLen)</span><br><span class="line">		&#123;<span class="comment">//计算找到的目标地址：//特征码地址 = 当前内存块基址 + i偏移 - 特征码长度</span></span><br><span class="line">			<span class="keyword">return</span>  i - patternLen;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多种算法间的比较"><a href="#多种算法间的比较" class="headerlink" title="多种算法间的比较"></a>多种算法间的比较</h2><ul>
<li><p><strong>KMP算法</strong>：</p>
<p>适用于需要频繁匹配的场景，能够保证线性时间复杂度。 </p>
</li>
<li><p><strong>BM算法</strong>： </p>
<p>在处理较长模式串或较大的字母表时表现较好，适合于文本中出现模式串较少的情况。 </p>
</li>
<li><p><strong>Sunday算法</strong>： </p>
<p> 通常在实际应用中表现得更快，适合于大多数字符串匹配场景，尤其是当模式串较短时。</p>
</li>
</ul>
<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><blockquote>
<p>贪心算法，又称贪婪法，是寻找最优解问题的常用方法。这种方法模式一般将求解过程分成若干个步骤，但每个步骤都应用贪心原则，选取当前状态下最好或最优的选择（局部最有利的选择），并以此希望最后堆叠出的结果也是最好或最优的解。</p>
<p>这就好像一个贪婪的人，他事事都想要眼前看到最好的那个，看不到长远的东西，也不为最终的结果和将来着想，贪图眼前局部的利益最大化，有点走一步看一步的感觉。</p>
<p>例如，假设你开了间小店，不能电子支付，钱柜里的货币只有25分、10分、5分和1分四种硬币，如果你是售货员且要找给客户41分钱的硬币，如何安排才能找给客人的钱既正确且硬币的个数又最少？这就是一个典型的贪心算法的应用场景。</p>
<p>然而，贪心算法不能保证最后求得的解是最优的，同时，贪心算法只能求满足某些约束条件的可行解的范围。如果一个问题的最优解只能用蛮力法穷举得到，则贪心法不失为寻找问题近似最优解的一种较好的方法。<strong>贪心算法的时间复杂度通常比较低，但不一定能够得到全局最优解</strong>。</p>
<p>总的来说，贪心算法是一种基于贪心策略的算法，它在每一步选择中都采取在当前状态下最好或最优的选择，从而希望导致结果是最好或最优的。贪心算法通常适用于求解最优化问题，如<strong>最小生成树、最短路径、背包问题</strong>等</p>
</blockquote>
<h1 id="排列组合公式"><a href="#排列组合公式" class="headerlink" title="排列组合公式"></a>排列组合公式</h1><p>记忆有点模糊,故写在此处以做温习</p>
<p>排列组合公式推导:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://www.bilibili.com/video/BV1uT411U7Ui" alt="排列组合公式推导|720x360"></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/26094736">简单理解</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/1024th/p/10623541.html">更多公式推导</a></p>
<h2 id="排列公式"><a href="#排列公式" class="headerlink" title="排列公式"></a>排列公式</h2><p>排列需要考虑顺序</p>
<p>Arrangement 排列 或 Permutation 排列</p>
<p>从n个中取m个排列的个数<br>$$<br>A_{n}^{m}&#x3D;\frac{n!}{(n-m)!}<br>$$</p>
<blockquote>
<p>实际计算中，往往不用阶乘。<strong>从大的数字开始往小乘，乘“小的数字那么多”个</strong></p>
</blockquote>
<h3 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h3><p>例：<code>1.2.3.4.5</code>有<code>5!</code>种排序方式，而<code>1.1.3.4.5</code>的排序方式有<code>5!/2!</code>种:</p>
<p>“5！”意味着将<code>1.1.3.4.5</code>视作5个不同的元素，而这与实际不符，若两个“1”是不同的，交换后是2种序；但它们相同啊，所以“5!”计算出的结果，是将实际情况重复计算了2次，那么除以2就是正确答案了。</p>
<blockquote>
<p>同理：<code>1.1.2.3.4.4.4.5</code>可组成多少个8位数？答：<code>8! / (2! x 3!)</code></p>
</blockquote>
<h2 id="组合公式"><a href="#组合公式" class="headerlink" title="组合公式"></a>组合公式</h2><p>Combination 组合</p>
<p>组合不需要考虑排序</p>
<p>从n个中取m个组合的个数<br>$$<br>C_n^m&#x3D;\frac{n!}{(n-m)!m!}<br>$$</p>
<blockquote>
<p>实际计算中，往往不用阶乘。从大的数字开始往小乘，乘“小的数字那么多”个，再除以“小的数字开始往小乘，乘小的数字那么多个”。</p>
</blockquote>
<h2 id="排列与组合的关系"><a href="#排列与组合的关系" class="headerlink" title="排列与组合的关系"></a>排列与组合的关系</h2><p>$$<br>C_n^m&#x3D;\frac{\mathrm{A}_n^m}{\mathrm{A}_m^m}&#x3D;\frac{n(n-1)(n-2)\cdots(n-m+1)}{m!}&#x3D;\frac{n!}{m!(n-m)!}<br>$$</p>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><blockquote>
<p>动态规划是运筹学的一个分支,<strong>求解决策过程最优值</strong>的一种思想</p>
<p><strong>求解最优解的时候需要想到动态规划</strong></p>
</blockquote>
<p>本质就是:给定一个大问题,把它拆成一个个子问题,直到子问题可以直接解决.然后把子问题的答案保存起来,以减少重复计算.再根据子问题答案反推,得到大问题解题的一种方法</p>
<blockquote>
<p>动态规划中最重要的两个概念</p>
<ul>
<li>重叠子问题</li>
<li>最优子结构</li>
</ul>
<p><strong>重叠子问题</strong>：动态规划会将每个求解过的子问题的解<strong>记录</strong>下来，这样当下一次碰到同样的子问题时，就可以<strong>直接使用</strong>之前记录的结果，而不是重复计算。<strong>（虽然动态规划使用这种方式来提高计算效率，但不能说这种做法就是动态规划的核心）</strong></p>
<p>如果一个问题可以被分解成若干个子问题，且这些子问题会重复出现，那么称这个问题拥有 <strong>重叠子问题（Overlapping Subproblems）</strong>。</p>
<p>如果一个问题的最优解可以由其子问题的最优解有效地构造出来，那么称这个问题拥有 <strong>最优子结构（Optimal Substructure）</strong>。最优子结构保证了动态规划中原问题的最优解可以由子问题的最优解推导而来</p>
<p><strong>一个问题必须拥有重叠子问题和最优子结构，才能使用动态规划去解决</strong></p>
</blockquote>
<p>动态规划通过额外空间避免重复计算来加速计算过程,由于用到其余空间来保存计算结果,因此也称之为记忆化搜索(Recursion with Memoization),本质上是用空间换时间,也有人叫他”带备忘录的递归”,或者递归树的剪枝(pruning).因为整个递归树不需要全部访问到,仿佛有些枝叶被剪掉了.上面说的递归也可以是迭代,动态规划不一定得是递归</p>
<p>动态规划的两种写法:</p>
<ul>
<li><strong>递推写法</strong>：<strong>自底向上（Bottom-up Approach）</strong>，即从边界开始，不断向上解决问题，直到解决了目标问题；</li>
<li><strong>递归写法</strong>：<strong>自顶向下（Top-down Approach）</strong>，即从目标问题开始，将它分解成子问题的组合，直到分解至边界为至。</li>
</ul>
<p>标准的动态规划实例:<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/solutions/?envType=study-plan-v2&envId=top-100-liked">爬楼梯问题</a></p>
<h2 id="动态规划与其他思想的差异"><a href="#动态规划与其他思想的差异" class="headerlink" title="动态规划与其他思想的差异"></a>动态规划与其他思想的差异</h2><h3 id="分治算法与动态规划——重叠子问题"><a href="#分治算法与动态规划——重叠子问题" class="headerlink" title="分治算法与动态规划——重叠子问题"></a>分治算法与动态规划——重叠子问题</h3><ul>
<li>相同点：<br>将问题分解成子问题，然后合并子问题的解得到原问题的解。</li>
<li>不同点：<br><strong>分治法</strong>解决的问题不拥有重叠子问题，解决的问题不一定是最优化问题；<br><strong>动态规划</strong>解决的问题拥有重叠子问题，解决的问题一定是最优化问题。</li>
</ul>
<h3 id="贪心算法与动态规划——最优子结构"><a href="#贪心算法与动态规划——最优子结构" class="headerlink" title="贪心算法与动态规划——最优子结构"></a><a href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95">贪心算法</a>与动态规划——最优子结构</h3><ul>
<li>相同点<br>都要求原问题必须拥有<strong>最优子结构</strong>。</li>
<li>不同点<br><strong>贪心</strong>的计算方式类似于”自顶向下“，但是并不等待<strong>所有子问题</strong>求解完毕后再选择使用哪一个，而是通过一种策略<strong>直接选择</strong>一个子问题去求解，没被选择的子问题就不会再去求解了。<br><strong>动态规划</strong>的计算方式有”自顶向下“和”自底向上“两种，都是从边界开始向上得到目标问题的解。也就是说，它总是会考虑<strong>所有子问题</strong>，并选择继承能得到最优结果的那个，对暂时没有被继承的子问题，由于重叠子问题的存在，后期可能会再次考虑它们，因此还有机会成为全局最优的一部分，不需要放弃。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/description/">53. 最大子数组和</a>这题同时有贪心算法解法和动态规划解法(官方解释中有视频两种方式的视频讲解)</p>
<p>思路:</p>
<ul>
<li><a href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95">贪心算法</a>:若当前指针所指元素之前的和小于0，则丢弃当前元素之前的数列.维护两个值:当前和,之前和</li>
<li>动态规划:若前一个元素大于0，则将其加到当前元素上.这样实际上存储的就是一个不确定左边界到当前边界的最大和,时间复杂度不如贪心算法</li>
</ul>
<h2 id="以赌场的骰子算法为例"><a href="#以赌场的骰子算法为例" class="headerlink" title="以赌场的骰子算法为例"></a>以赌场的骰子算法为例</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Lj411r7tM/">参考视频</a></p>
<p>问题就是: 通过Dice个骰子掷出总数为Total有多少种方式</p>
<p><strong>递归回溯地思考问题,通过将大问题分解为相似的小问题来解决</strong></p>
<p>以两个骰子为例,掷出一个总点数为8的话,第二次掷出的点数必须为1,2,3,4,5或6,所以要使总数为8,第一次掷骰必须分别为7,6,5,4,3或2,7是不可能的,用一个骰子掷出点数为6,5,4,3,2的方式都只有一种,因此,使用2个骰子掷出8个点数的方式是5种</p>
<p><strong>准确地描述一个简单问题的解法能帮助我们找到更一般性的解决方案</strong></p>
<p>可以总结为: 对于用n个骰子掷出m点的总数,那么前n-1个骰子必须掷出m-1,m-2,m-3,m-4,m-5或m-6的总数</p>
<p>这样就提供了一种递归算法,用来解决该问题</p>
<p>假设想用10个骰子掷出28的总和,那么前9个骰子的总和必须是27,26,25,24,23或22的一个,将一个问题拆解为多个问题,分别是用9个骰子掷出27 ,26,25,24,23,22这6个小问题</p>
<p><strong>到这一步,就完成了递归式的遍历,但是如果仔细观察中间的步骤,就会发现有很多重复性的计算,因此可以采用类似缓存机制的方式来剪枝,于是就能大幅提高效率</strong></p>
<p>这就是动态规划的原理: 通过递归的描述问题,即使用较小版本的相同问题来定义问题,再结合查找表保存我们已经完成的计算结果,我们通常可以显著加速这些算法</p>
<h1 id="增益校正算法"><a href="#增益校正算法" class="headerlink" title="增益校正算法"></a>增益校正算法</h1><h1 id="路径规划算法"><a href="#路径规划算法" class="headerlink" title="路径规划算法"></a>路径规划算法</h1><h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/k31woVkPyXMeDviXH4Q-SA">Dijkstra算法迎来新突破：经典本科算法被证为普遍最优，最坏性能也达极限！</a></p>
<h1 id="校验算法"><a href="#校验算法" class="headerlink" title="校验算法"></a>校验算法</h1><h2 id="CRC校验算法"><a href="#CRC校验算法" class="headerlink" title="CRC校验算法"></a>CRC校验算法</h2><p>CRC（循环冗余校验）算法可以提供更强大的校验功能，用于检测数据传输中的错误。CRC算法通过对数据进行多项式除法运算，生成一个固定长度的校验码（CRC校验码），用于校验数据在传输过程中是否发生了错误或被篡改。</p>
<p>CRC算法相比简单的校验和方法，具有以下优点：</p>
<ol>
<li><strong>更强的错误检测能力</strong>：CRC算法可以检测更多类型的错误，包括单比特错误、多比特错误、以及一些特定的错误模式。</li>
<li><strong>低错误漏检率</strong>：CRC算法的设计可以降低错误漏检率，提高数据传输的可靠性。</li>
<li><strong>固定长度的校验码</strong>：CRC算法生成的校验码长度固定，不受数据长度影响，便于在数据传输中使用。</li>
</ol>
<p>在通信协议、存储系统、网络通信等领域，CRC算法被广泛应用于数据完整性校验。通过计算接收数据的CRC校验码并与发送数据的CRC校验码进行比较，接收方可以判断数据是否在传输过程中发生了错误，从而保证数据的可靠传输。</p>
<p>[计组#CRC循环冗余校验码|更多理解可以参考计组]</p>
<h3 id="CRC16"><a href="#CRC16" class="headerlink" title="CRC16"></a>CRC16</h3><p>以CRC16为例</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CRC16</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">ushort</span> <span class="title">CalculateCRC</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">byte</span>[] z_p, <span class="built_in">ushort</span> z_message_length</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// CRC 运行循环冗余校验算法于输入 z_p</span></span><br><span class="line">        <span class="comment">// 完成后返回 16 位 CRC 的值，并始终在消息中添加 2 个 CRC 字节</span></span><br><span class="line">        <span class="comment">// 如果传入消息具有正确的 CRC，则返回 0</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">ushort</span> CRC = <span class="number">0xffff</span>;  <span class="comment">// 初始化CRC值为0xffff</span></span><br><span class="line">        <span class="built_in">ushort</span> next;          <span class="comment">// 当前处理的字节，转换为ushort类型</span></span><br><span class="line">        <span class="built_in">ushort</span> carry;         <span class="comment">// 用于存储每次移位后的最低位</span></span><br><span class="line">        <span class="built_in">ushort</span> n;             <span class="comment">// 用于循环计数的变量</span></span><br><span class="line">        <span class="built_in">byte</span> crch, crcl;      <span class="comment">// 存储最终计算出的高8位和低8位的CRC值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (z_message_length-- &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            next = (<span class="built_in">ushort</span>)z_p[z_p.Length - z_message_length - <span class="number">1</span>];</span><br><span class="line">            CRC ^= next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; <span class="number">8</span>; n++)</span><br><span class="line">            &#123;</span><br><span class="line">                carry = (<span class="built_in">ushort</span>)(CRC &amp; <span class="number">1</span>);</span><br><span class="line">                CRC &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (carry != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    CRC ^= <span class="number">0xA001</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        crch = (<span class="built_in">byte</span>)(CRC / <span class="number">256</span>);</span><br><span class="line">        crcl = (<span class="built_in">byte</span>)(CRC % <span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">        Array.Resize(<span class="keyword">ref</span> z_p, z_p.Length + <span class="number">2</span>);</span><br><span class="line">        z_p[z_p.Length - <span class="number">2</span>] = crcl;</span><br><span class="line">        z_p[z_p.Length - <span class="number">1</span>] = crch;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> CRC;</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">  	<span class="comment">//验证CRC是否正确,正确返回true,否则返回false</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">VerifyCRC</span>(<span class="params"><span class="built_in">byte</span>[] z_p</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 提取消息中的 CRC 字节</span></span><br><span class="line">        <span class="built_in">byte</span> crcl = z_p[z_p.Length - <span class="number">2</span>];</span><br><span class="line">        <span class="built_in">byte</span> crch = z_p[z_p.Length - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移除消息末尾的 CRC 字节  </span></span><br><span class="line">        Array.Resize(<span class="keyword">ref</span> z_p, z_p.Length - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新计算 CRC</span></span><br><span class="line">        <span class="built_in">ushort</span> computedCRC = CalculateCRC(z_p, (<span class="built_in">ushort</span>)z_p.Length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查计算出的 CRC 是否与消息末尾的 CRC 相同</span></span><br><span class="line">        <span class="keyword">return</span> (computedCRC &amp; <span class="number">0xFF</span>) == crcl &amp;&amp; (computedCRC &gt;&gt; <span class="number">8</span>) == crch;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>也有查表法</strong></p>
<p>基于c#的实现</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 摘要:</span></span><br><span class="line"><span class="comment">//     Calculates the CRC16 for Modbus-RTU</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 参数:</span></span><br><span class="line"><span class="comment">//   data:</span></span><br><span class="line"><span class="comment">//     Byte buffer to send</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   numberOfBytes:</span></span><br><span class="line"><span class="comment">//     Number of bytes to calculate CRC</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   startByte:</span></span><br><span class="line"><span class="comment">//     First byte in buffer to start calculating CRC</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">ushort</span> <span class="title">calculateCRC</span>(<span class="params"><span class="built_in">byte</span>[] data, <span class="built_in">ushort</span> numberOfBytes, <span class="built_in">int</span> startByte</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">byte</span>[] array = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">256</span>]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="number">0</span>, <span class="number">193</span>, <span class="number">129</span>, <span class="number">64</span>, <span class="number">1</span>, <span class="number">192</span>, <span class="number">128</span>, <span class="number">65</span>, <span class="number">1</span>, <span class="number">192</span>,</span><br><span class="line">        <span class="number">128</span>, <span class="number">65</span>, <span class="number">0</span>, <span class="number">193</span>, <span class="number">129</span>, <span class="number">64</span>, <span class="number">1</span>, <span class="number">192</span>, <span class="number">128</span>, <span class="number">65</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">193</span>, <span class="number">129</span>, <span class="number">64</span>, <span class="number">0</span>, <span class="number">193</span>, <span class="number">129</span>, <span class="number">64</span>, <span class="number">1</span>, <span class="number">192</span>,</span><br><span class="line">        <span class="number">128</span>, <span class="number">65</span>, <span class="number">1</span>, <span class="number">192</span>, <span class="number">128</span>, <span class="number">65</span>, <span class="number">0</span>, <span class="number">193</span>, <span class="number">129</span>, <span class="number">64</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">193</span>, <span class="number">129</span>, <span class="number">64</span>, <span class="number">1</span>, <span class="number">192</span>, <span class="number">128</span>, <span class="number">65</span>, <span class="number">0</span>, <span class="number">193</span>,</span><br><span class="line">        <span class="number">129</span>, <span class="number">64</span>, <span class="number">1</span>, <span class="number">192</span>, <span class="number">128</span>, <span class="number">65</span>, <span class="number">1</span>, <span class="number">192</span>, <span class="number">128</span>, <span class="number">65</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">193</span>, <span class="number">129</span>, <span class="number">64</span>, <span class="number">1</span>, <span class="number">192</span>, <span class="number">128</span>, <span class="number">65</span>, <span class="number">0</span>, <span class="number">193</span>,</span><br><span class="line">        <span class="number">129</span>, <span class="number">64</span>, <span class="number">0</span>, <span class="number">193</span>, <span class="number">129</span>, <span class="number">64</span>, <span class="number">1</span>, <span class="number">192</span>, <span class="number">128</span>, <span class="number">65</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">193</span>, <span class="number">129</span>, <span class="number">64</span>, <span class="number">1</span>, <span class="number">192</span>, <span class="number">128</span>, <span class="number">65</span>, <span class="number">1</span>, <span class="number">192</span>,</span><br><span class="line">        <span class="number">128</span>, <span class="number">65</span>, <span class="number">0</span>, <span class="number">193</span>, <span class="number">129</span>, <span class="number">64</span>, <span class="number">0</span>, <span class="number">193</span>, <span class="number">129</span>, <span class="number">64</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">192</span>, <span class="number">128</span>, <span class="number">65</span>, <span class="number">1</span>, <span class="number">192</span>, <span class="number">128</span>, <span class="number">65</span>, <span class="number">0</span>, <span class="number">193</span>,</span><br><span class="line">        <span class="number">129</span>, <span class="number">64</span>, <span class="number">1</span>, <span class="number">192</span>, <span class="number">128</span>, <span class="number">65</span>, <span class="number">0</span>, <span class="number">193</span>, <span class="number">129</span>, <span class="number">64</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">193</span>, <span class="number">129</span>, <span class="number">64</span>, <span class="number">1</span>, <span class="number">192</span>, <span class="number">128</span>, <span class="number">65</span>, <span class="number">1</span>, <span class="number">192</span>,</span><br><span class="line">        <span class="number">128</span>, <span class="number">65</span>, <span class="number">0</span>, <span class="number">193</span>, <span class="number">129</span>, <span class="number">64</span>, <span class="number">0</span>, <span class="number">193</span>, <span class="number">129</span>, <span class="number">64</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">192</span>, <span class="number">128</span>, <span class="number">65</span>, <span class="number">0</span>, <span class="number">193</span>, <span class="number">129</span>, <span class="number">64</span>, <span class="number">1</span>, <span class="number">192</span>,</span><br><span class="line">        <span class="number">128</span>, <span class="number">65</span>, <span class="number">1</span>, <span class="number">192</span>, <span class="number">128</span>, <span class="number">65</span>, <span class="number">0</span>, <span class="number">193</span>, <span class="number">129</span>, <span class="number">64</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">193</span>, <span class="number">129</span>, <span class="number">64</span>, <span class="number">1</span>, <span class="number">192</span>, <span class="number">128</span>, <span class="number">65</span>, <span class="number">1</span>, <span class="number">192</span>,</span><br><span class="line">        <span class="number">128</span>, <span class="number">65</span>, <span class="number">0</span>, <span class="number">193</span>, <span class="number">129</span>, <span class="number">64</span>, <span class="number">1</span>, <span class="number">192</span>, <span class="number">128</span>, <span class="number">65</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">193</span>, <span class="number">129</span>, <span class="number">64</span>, <span class="number">0</span>, <span class="number">193</span>, <span class="number">129</span>, <span class="number">64</span>, <span class="number">1</span>, <span class="number">192</span>,</span><br><span class="line">        <span class="number">128</span>, <span class="number">65</span>, <span class="number">0</span>, <span class="number">193</span>, <span class="number">129</span>, <span class="number">64</span>, <span class="number">1</span>, <span class="number">192</span>, <span class="number">128</span>, <span class="number">65</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">192</span>, <span class="number">128</span>, <span class="number">65</span>, <span class="number">0</span>, <span class="number">193</span>, <span class="number">129</span>, <span class="number">64</span>, <span class="number">1</span>, <span class="number">192</span>,</span><br><span class="line">        <span class="number">128</span>, <span class="number">65</span>, <span class="number">0</span>, <span class="number">193</span>, <span class="number">129</span>, <span class="number">64</span>, <span class="number">0</span>, <span class="number">193</span>, <span class="number">129</span>, <span class="number">64</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">192</span>, <span class="number">128</span>, <span class="number">65</span>, <span class="number">1</span>, <span class="number">192</span>, <span class="number">128</span>, <span class="number">65</span>, <span class="number">0</span>, <span class="number">193</span>,</span><br><span class="line">        <span class="number">129</span>, <span class="number">64</span>, <span class="number">0</span>, <span class="number">193</span>, <span class="number">129</span>, <span class="number">64</span>, <span class="number">1</span>, <span class="number">192</span>, <span class="number">128</span>, <span class="number">65</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">193</span>, <span class="number">129</span>, <span class="number">64</span>, <span class="number">1</span>, <span class="number">192</span>, <span class="number">128</span>, <span class="number">65</span>, <span class="number">1</span>, <span class="number">192</span>,</span><br><span class="line">        <span class="number">128</span>, <span class="number">65</span>, <span class="number">0</span>, <span class="number">193</span>, <span class="number">129</span>, <span class="number">64</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">byte</span>[] array2 = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">256</span>]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="number">0</span>, <span class="number">192</span>, <span class="number">193</span>, <span class="number">1</span>, <span class="number">195</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">194</span>, <span class="number">198</span>, <span class="number">6</span>,</span><br><span class="line">        <span class="number">7</span>, <span class="number">199</span>, <span class="number">5</span>, <span class="number">197</span>, <span class="number">196</span>, <span class="number">4</span>, <span class="number">204</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">205</span>,</span><br><span class="line">        <span class="number">15</span>, <span class="number">207</span>, <span class="number">206</span>, <span class="number">14</span>, <span class="number">10</span>, <span class="number">202</span>, <span class="number">203</span>, <span class="number">11</span>, <span class="number">201</span>, <span class="number">9</span>,</span><br><span class="line">        <span class="number">8</span>, <span class="number">200</span>, <span class="number">216</span>, <span class="number">24</span>, <span class="number">25</span>, <span class="number">217</span>, <span class="number">27</span>, <span class="number">219</span>, <span class="number">218</span>, <span class="number">26</span>,</span><br><span class="line">        <span class="number">30</span>, <span class="number">222</span>, <span class="number">223</span>, <span class="number">31</span>, <span class="number">221</span>, <span class="number">29</span>, <span class="number">28</span>, <span class="number">220</span>, <span class="number">20</span>, <span class="number">212</span>,</span><br><span class="line">        <span class="number">213</span>, <span class="number">21</span>, <span class="number">215</span>, <span class="number">23</span>, <span class="number">22</span>, <span class="number">214</span>, <span class="number">210</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">211</span>,</span><br><span class="line">        <span class="number">17</span>, <span class="number">209</span>, <span class="number">208</span>, <span class="number">16</span>, <span class="number">240</span>, <span class="number">48</span>, <span class="number">49</span>, <span class="number">241</span>, <span class="number">51</span>, <span class="number">243</span>,</span><br><span class="line">        <span class="number">242</span>, <span class="number">50</span>, <span class="number">54</span>, <span class="number">246</span>, <span class="number">247</span>, <span class="number">55</span>, <span class="number">245</span>, <span class="number">53</span>, <span class="number">52</span>, <span class="number">244</span>,</span><br><span class="line">        <span class="number">60</span>, <span class="number">252</span>, <span class="number">253</span>, <span class="number">61</span>, <span class="number">255</span>, <span class="number">63</span>, <span class="number">62</span>, <span class="number">254</span>, <span class="number">250</span>, <span class="number">58</span>,</span><br><span class="line">        <span class="number">59</span>, <span class="number">251</span>, <span class="number">57</span>, <span class="number">249</span>, <span class="number">248</span>, <span class="number">56</span>, <span class="number">40</span>, <span class="number">232</span>, <span class="number">233</span>, <span class="number">41</span>,</span><br><span class="line">        <span class="number">235</span>, <span class="number">43</span>, <span class="number">42</span>, <span class="number">234</span>, <span class="number">238</span>, <span class="number">46</span>, <span class="number">47</span>, <span class="number">239</span>, <span class="number">45</span>, <span class="number">237</span>,</span><br><span class="line">        <span class="number">236</span>, <span class="number">44</span>, <span class="number">228</span>, <span class="number">36</span>, <span class="number">37</span>, <span class="number">229</span>, <span class="number">39</span>, <span class="number">231</span>, <span class="number">230</span>, <span class="number">38</span>,</span><br><span class="line">        <span class="number">34</span>, <span class="number">226</span>, <span class="number">227</span>, <span class="number">35</span>, <span class="number">225</span>, <span class="number">33</span>, <span class="number">32</span>, <span class="number">224</span>, <span class="number">160</span>, <span class="number">96</span>,</span><br><span class="line">        <span class="number">97</span>, <span class="number">161</span>, <span class="number">99</span>, <span class="number">163</span>, <span class="number">162</span>, <span class="number">98</span>, <span class="number">102</span>, <span class="number">166</span>, <span class="number">167</span>, <span class="number">103</span>,</span><br><span class="line">        <span class="number">165</span>, <span class="number">101</span>, <span class="number">100</span>, <span class="number">164</span>, <span class="number">108</span>, <span class="number">172</span>, <span class="number">173</span>, <span class="number">109</span>, <span class="number">175</span>, <span class="number">111</span>,</span><br><span class="line">        <span class="number">110</span>, <span class="number">174</span>, <span class="number">170</span>, <span class="number">106</span>, <span class="number">107</span>, <span class="number">171</span>, <span class="number">105</span>, <span class="number">169</span>, <span class="number">168</span>, <span class="number">104</span>,</span><br><span class="line">        <span class="number">120</span>, <span class="number">184</span>, <span class="number">185</span>, <span class="number">121</span>, <span class="number">187</span>, <span class="number">123</span>, <span class="number">122</span>, <span class="number">186</span>, <span class="number">190</span>, <span class="number">126</span>,</span><br><span class="line">        <span class="number">127</span>, <span class="number">191</span>, <span class="number">125</span>, <span class="number">189</span>, <span class="number">188</span>, <span class="number">124</span>, <span class="number">180</span>, <span class="number">116</span>, <span class="number">117</span>, <span class="number">181</span>,</span><br><span class="line">        <span class="number">119</span>, <span class="number">183</span>, <span class="number">182</span>, <span class="number">118</span>, <span class="number">114</span>, <span class="number">178</span>, <span class="number">179</span>, <span class="number">115</span>, <span class="number">177</span>, <span class="number">113</span>,</span><br><span class="line">        <span class="number">112</span>, <span class="number">176</span>, <span class="number">80</span>, <span class="number">144</span>, <span class="number">145</span>, <span class="number">81</span>, <span class="number">147</span>, <span class="number">83</span>, <span class="number">82</span>, <span class="number">146</span>,</span><br><span class="line">        <span class="number">150</span>, <span class="number">86</span>, <span class="number">87</span>, <span class="number">151</span>, <span class="number">85</span>, <span class="number">149</span>, <span class="number">148</span>, <span class="number">84</span>, <span class="number">156</span>, <span class="number">92</span>,</span><br><span class="line">        <span class="number">93</span>, <span class="number">157</span>, <span class="number">95</span>, <span class="number">159</span>, <span class="number">158</span>, <span class="number">94</span>, <span class="number">90</span>, <span class="number">154</span>, <span class="number">155</span>, <span class="number">91</span>,</span><br><span class="line">        <span class="number">153</span>, <span class="number">89</span>, <span class="number">88</span>, <span class="number">152</span>, <span class="number">136</span>, <span class="number">72</span>, <span class="number">73</span>, <span class="number">137</span>, <span class="number">75</span>, <span class="number">139</span>,</span><br><span class="line">        <span class="number">138</span>, <span class="number">74</span>, <span class="number">78</span>, <span class="number">142</span>, <span class="number">143</span>, <span class="number">79</span>, <span class="number">141</span>, <span class="number">77</span>, <span class="number">76</span>, <span class="number">140</span>,</span><br><span class="line">        <span class="number">68</span>, <span class="number">132</span>, <span class="number">133</span>, <span class="number">69</span>, <span class="number">135</span>, <span class="number">71</span>, <span class="number">70</span>, <span class="number">134</span>, <span class="number">130</span>, <span class="number">66</span>,</span><br><span class="line">        <span class="number">67</span>, <span class="number">131</span>, <span class="number">65</span>, <span class="number">129</span>, <span class="number">128</span>, <span class="number">64</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">ushort</span> num = numberOfBytes;</span><br><span class="line">    <span class="built_in">byte</span> b = <span class="built_in">byte</span>.MaxValue;</span><br><span class="line">    <span class="built_in">byte</span> b2 = <span class="built_in">byte</span>.MaxValue;</span><br><span class="line">    <span class="built_in">int</span> num2 = <span class="number">0</span>;</span><br><span class="line">    checked</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (num &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            num = (<span class="built_in">ushort</span>)(<span class="keyword">unchecked</span>((<span class="built_in">uint</span>)num) - <span class="number">1u</span>);</span><br><span class="line">            <span class="keyword">if</span> (num2 + startByte &lt; data.Length)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">int</span> num3 = b2 ^ data[num2 + startByte];</span><br><span class="line">                b2 = (<span class="built_in">byte</span>)(b ^ array[num3]);</span><br><span class="line">                b = array2[num3];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            num2++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">ushort</span>)((b &lt;&lt; <span class="number">8</span>) | b2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于C&#x2F;C++实现</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> unsigned <span class="built_in">char</span> auchCRCHi[] = &#123;</span><br><span class="line">      <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>,</span><br><span class="line">      <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>,</span><br><span class="line">      <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>,</span><br><span class="line">      <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>,</span><br><span class="line">      <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>,</span><br><span class="line">      <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>,</span><br><span class="line">      <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x01</span>,</span><br><span class="line">      <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>,</span><br><span class="line">      <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>,</span><br><span class="line">      <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>,</span><br><span class="line">      <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>,</span><br><span class="line">      <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>,</span><br><span class="line">      <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>,</span><br><span class="line">      <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>,</span><br><span class="line">      <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x01</span>,</span><br><span class="line">      <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>,</span><br><span class="line">      <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>,</span><br><span class="line">      <span class="number">0x40</span> &#125; ;</span><br><span class="line">      <span class="keyword">static</span> <span class="built_in">char</span> auchCRCLo[] = &#123;</span><br><span class="line">      <span class="number">0x00</span>, <span class="number">0xC0</span>, <span class="number">0xC1</span>, <span class="number">0x01</span>, <span class="number">0xC3</span>, <span class="number">0x03</span>, <span class="number">0x02</span>, <span class="number">0xC2</span>, <span class="number">0xC6</span>, <span class="number">0x06</span>, <span class="number">0x07</span>, <span class="number">0xC7</span>, <span class="number">0x05</span>, <span class="number">0xC5</span>, <span class="number">0xC4</span>,</span><br><span class="line">      <span class="number">0x04</span>, <span class="number">0xCC</span>, <span class="number">0x0C</span>, <span class="number">0x0D</span>, <span class="number">0xCD</span>, <span class="number">0x0F</span>, <span class="number">0xCF</span>, <span class="number">0xCE</span>, <span class="number">0x0E</span>, <span class="number">0x0A</span>, <span class="number">0xCA</span>, <span class="number">0xCB</span>, <span class="number">0x0B</span>, <span class="number">0xC9</span>, <span class="number">0x09</span>,</span><br><span class="line">      <span class="number">0x08</span>, <span class="number">0xC8</span>, <span class="number">0xD8</span>, <span class="number">0x18</span>, <span class="number">0x19</span>, <span class="number">0xD9</span>, <span class="number">0x1B</span>, <span class="number">0xDB</span>, <span class="number">0xDA</span>, <span class="number">0x1A</span>, <span class="number">0x1E</span>, <span class="number">0xDE</span>, <span class="number">0xDF</span>, <span class="number">0x1F</span>, <span class="number">0xDD</span>,</span><br><span class="line">      <span class="number">0x1D</span>, <span class="number">0x1C</span>, <span class="number">0xDC</span>, <span class="number">0x14</span>, <span class="number">0xD4</span>, <span class="number">0xD5</span>, <span class="number">0x15</span>, <span class="number">0xD7</span>, <span class="number">0x17</span>, <span class="number">0x16</span>, <span class="number">0xD6</span>, <span class="number">0xD2</span>, <span class="number">0x12</span>, <span class="number">0x13</span>, <span class="number">0xD3</span>,</span><br><span class="line">      <span class="number">0x11</span>, <span class="number">0xD1</span>, <span class="number">0xD0</span>, <span class="number">0x10</span>, <span class="number">0xF0</span>, <span class="number">0x30</span>, <span class="number">0x31</span>, <span class="number">0xF1</span>, <span class="number">0x33</span>, <span class="number">0xF3</span>, <span class="number">0xF2</span>, <span class="number">0x32</span>, <span class="number">0x36</span>, <span class="number">0xF6</span>, <span class="number">0xF7</span>,</span><br><span class="line">      <span class="number">0x37</span>, <span class="number">0xF5</span>, <span class="number">0x35</span>, <span class="number">0x34</span>, <span class="number">0xF4</span>, <span class="number">0x3C</span>, <span class="number">0xFC</span>, <span class="number">0xFD</span>, <span class="number">0x3D</span>, <span class="number">0xFF</span>, <span class="number">0x3F</span>, <span class="number">0x3E</span>, <span class="number">0xFE</span>, <span class="number">0xFA</span>, <span class="number">0x3A</span>,</span><br><span class="line">      <span class="number">0x3B</span>, <span class="number">0xFB</span>, <span class="number">0x39</span>, <span class="number">0xF9</span>, <span class="number">0xF8</span>, <span class="number">0x38</span>, <span class="number">0x28</span>, <span class="number">0xE8</span>, <span class="number">0xE9</span>, <span class="number">0x29</span>, <span class="number">0xEB</span>, <span class="number">0x2B</span>, <span class="number">0x2A</span>, <span class="number">0xEA</span>, <span class="number">0xEE</span>,</span><br><span class="line">      <span class="number">0x2E</span>, <span class="number">0x2F</span>, <span class="number">0xEF</span>, <span class="number">0x2D</span>, <span class="number">0xED</span>, <span class="number">0xEC</span>, <span class="number">0x2C</span>, <span class="number">0xE4</span>, <span class="number">0x24</span>, <span class="number">0x25</span>, <span class="number">0xE5</span>, <span class="number">0x27</span>, <span class="number">0xE7</span>, <span class="number">0xE6</span>, <span class="number">0x26</span>,</span><br><span class="line">      <span class="number">0x22</span>, <span class="number">0xE2</span>, <span class="number">0xE3</span>, <span class="number">0x23</span>, <span class="number">0xE1</span>, <span class="number">0x21</span>, <span class="number">0x20</span>, <span class="number">0xE0</span>, <span class="number">0xA0</span>, <span class="number">0x60</span>, <span class="number">0x61</span>, <span class="number">0xA1</span>, <span class="number">0x63</span>, <span class="number">0xA3</span>, <span class="number">0xA2</span>,</span><br><span class="line">      <span class="number">0x62</span>, <span class="number">0x66</span>, <span class="number">0xA6</span>, <span class="number">0xA7</span>, <span class="number">0x67</span>, <span class="number">0xA5</span>, <span class="number">0x65</span>, <span class="number">0x64</span>, <span class="number">0xA4</span>, <span class="number">0x6C</span>, <span class="number">0xAC</span>, <span class="number">0xAD</span>, <span class="number">0x6D</span>, <span class="number">0xAF</span>, <span class="number">0x6F</span>,</span><br><span class="line">      <span class="number">0x6E</span>, <span class="number">0xAE</span>, <span class="number">0xAA</span>, <span class="number">0x6A</span>, <span class="number">0x6B</span>, <span class="number">0xAB</span>, <span class="number">0x69</span>, <span class="number">0xA9</span>, <span class="number">0xA8</span>, <span class="number">0x68</span>, <span class="number">0x78</span>, <span class="number">0xB8</span>, <span class="number">0xB9</span>, <span class="number">0x79</span>, <span class="number">0xBB</span>,</span><br><span class="line">      <span class="number">0x7B</span>, <span class="number">0x7A</span>, <span class="number">0xBA</span>, <span class="number">0xBE</span>, <span class="number">0x7E</span>, <span class="number">0x7F</span>, <span class="number">0xBF</span>, <span class="number">0x7D</span>, <span class="number">0xBD</span>, <span class="number">0xBC</span>, <span class="number">0x7C</span>, <span class="number">0xB4</span>, <span class="number">0x74</span>, <span class="number">0x75</span>, <span class="number">0xB5</span>,</span><br><span class="line">      <span class="number">0x77</span>, <span class="number">0xB7</span>, <span class="number">0xB6</span>, <span class="number">0x76</span>, <span class="number">0x72</span>, <span class="number">0xB2</span>, <span class="number">0xB3</span>, <span class="number">0x73</span>, <span class="number">0xB1</span>, <span class="number">0x71</span>, <span class="number">0x70</span>, <span class="number">0xB0</span>, <span class="number">0x50</span>, <span class="number">0x90</span>, <span class="number">0x91</span>,</span><br><span class="line">      <span class="number">0x51</span>, <span class="number">0x93</span>, <span class="number">0x53</span>, <span class="number">0x52</span>, <span class="number">0x92</span>, <span class="number">0x96</span>, <span class="number">0x56</span>, <span class="number">0x57</span>, <span class="number">0x97</span>, <span class="number">0x55</span>, <span class="number">0x95</span>, <span class="number">0x94</span>, <span class="number">0x54</span>, <span class="number">0x9C</span>, <span class="number">0x5C</span>,</span><br><span class="line">      <span class="number">0x5D</span>, <span class="number">0x9D</span>, <span class="number">0x5F</span>, <span class="number">0x9F</span>, <span class="number">0x9E</span>, <span class="number">0x5E</span>, <span class="number">0x5A</span>, <span class="number">0x9A</span>, <span class="number">0x9B</span>, <span class="number">0x5B</span>, <span class="number">0x99</span>, <span class="number">0x59</span>, <span class="number">0x58</span>, <span class="number">0x98</span>, <span class="number">0x88</span>,</span><br><span class="line">      <span class="number">0x48</span>, <span class="number">0x49</span>, <span class="number">0x89</span>, <span class="number">0x4B</span>, <span class="number">0x8B</span>, <span class="number">0x8A</span>, <span class="number">0x4A</span>, <span class="number">0x4E</span>, <span class="number">0x8E</span>, <span class="number">0x8F</span>, <span class="number">0x4F</span>, <span class="number">0x8D</span>, <span class="number">0x4D</span>, <span class="number">0x4C</span>, <span class="number">0x8C</span>,</span><br><span class="line">      <span class="number">0x44</span>, <span class="number">0x84</span>, <span class="number">0x85</span>, <span class="number">0x45</span>, <span class="number">0x87</span>, <span class="number">0x47</span>, <span class="number">0x46</span>, <span class="number">0x86</span>, <span class="number">0x82</span>, <span class="number">0x42</span>, <span class="number">0x43</span>, <span class="number">0x83</span>, <span class="number">0x41</span>, <span class="number">0x81</span>, <span class="number">0x80</span>,</span><br><span class="line">      <span class="number">0x40</span> &#125;;</span><br><span class="line">      <span class="function">unsigned <span class="built_in">short</span> <span class="title">CRC16</span> (<span class="params"> unsigned <span class="built_in">char</span> *puchMsg, unsigned <span class="built_in">short</span> usDataLen </span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">       unsigned <span class="built_in">char</span> uchCRCHi = <span class="number">0xFF</span> ;  <span class="comment">/* 高字节初始化值   */</span></span><br><span class="line">       unsigned <span class="built_in">char</span> uchCRCLo = <span class="number">0xFF</span> ;  <span class="comment">/* 低字节初始化值   */</span></span><br><span class="line">       unsigned uIndex ;</span><br><span class="line">       <span class="keyword">while</span> (usDataLen--)</span><br><span class="line">       &#123;</span><br><span class="line">        uIndex = uchCRCLo ^ *puchMsg++ ;</span><br><span class="line">        uchCRCLo = uchCRCHi ^ auchCRCHi[uIndex] ;</span><br><span class="line">        uchCRCHi = auchCRCLo[uIndex] ;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> (uchCRCHi &lt;&lt; <span class="number">8</span> | uchCRCLo) ;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<h2 id="校验和计算"><a href="#校验和计算" class="headerlink" title="校验和计算"></a>校验和计算</h2><ol>
<li><p><strong>数据分割</strong>：将待发送的数据按照固定的单位（如字节）进行分割，每个单位称为一个数据块。</p>
</li>
<li><p><strong>加和计算</strong>：对每个数据块中的值进行加和运算，生成一个校验和值。通常采用模2加法（二进制异或运算）或者累加和的方式进行计算。</p>
<blockquote>
<p>模2加法的特点包括：</p>
<ul>
<li>与传统加法不同，模2加法中进位被忽略，只关注每个位上的值。</li>
<li>模2加法满足交换律和结合律。</li>
<li>任何数与0进行模2加法得到原数。</li>
<li>任何数与自身进行模2加法得到0。</li>
</ul>
</blockquote>
</li>
<li><p><strong>校验和附加</strong>：将计算得到的校验和值附加到数据中，一起发送给接收方。</p>
</li>
<li><p><strong>接收端校验</strong>：接收方在接收数据后，对接收到的数据进行相同的加和计算，得到一个校验和值。</p>
</li>
<li><p><strong>比较校验和</strong>：接收方将计算得到的校验和值与接收到的校验和值进行比较。如果两者相等，则数据传输过程中没有出现错误；如果不相等，则表示数据可能存在错误，需要进行相应的处理（如重新发送数据）。</p>
</li>
</ol>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">byte</span> <span class="title">CalCheckSum</span>(<span class="params"><span class="built_in">byte</span>[] command</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">byte</span> checksum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="built_in">byte</span> b <span class="keyword">in</span> command)</span><br><span class="line">            &#123;</span><br><span class="line">                checksum = (<span class="built_in">byte</span>)(checksum + (b &amp; <span class="number">0x7f</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            checksum = (<span class="built_in">byte</span>)(<span class="number">0x3f</span> &amp; (checksum ^ (checksum &gt;&gt; <span class="number">6</span>)));</span><br><span class="line">            checksum = (<span class="built_in">byte</span>)((<span class="number">0x30</span> + checksum) &amp; <span class="number">0x7f</span>);</span><br><span class="line">            <span class="keyword">return</span> checksum;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>校验和是一种简单有效的数据完整性校验方法，适用于对数据传输中的随机错误进行检测。然而，校验和并不能提供纠错能力，只能检测错误并提示出错的可能性。在需要更强大的错误检测和纠正能力时，通常会采用更复杂的校验算法，如CRC（循环冗余校验）等。</p>
<h1 id="令人惊叹的平方根算法"><a href="#令人惊叹的平方根算法" class="headerlink" title="令人惊叹的平方根算法"></a>令人惊叹的平方根算法</h1><h2 id="平方根快速计算算法"><a href="#平方根快速计算算法" class="headerlink" title="平方根快速计算算法"></a>平方根快速计算算法</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/bluettt/p/13025259.html">二分法和牛顿迭代法都可以用来计算平方根</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/98501407">另外，还有一种被称为“神奇的方法”的算法，它使用了一个特殊的常数和牛顿迭代法来快速计算平方根</a>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://www.bilibili.com/video/BV18j411i7bp" alt="神奇方法视频详解|720x360"></p>
<h1 id="闭环控制算法"><a href="#闭环控制算法" class="headerlink" title="闭环控制算法"></a>闭环控制算法</h1><p>专业术语</p>
<ul>
<li><p>测量值(PV,Process Variable)</p>
<p>这是控制系统中的一个术语，指的是控制过程中实际测量到的值，比如温度、压力、流量等过程变量的实时测量值。</p>
<p>在温度控制系统中，PV通常指的是当前的温度读数。</p>
<p>PV是控制系统的反馈部分，控制系统会根据PV与设定值(SV)之间的偏差来调整输出，以保持过程的稳定。</p>
</li>
<li><p>设定值(SV,Set Variable)  是用户设定的目标值，即希望控制系统达到的值。</p>
</li>
<li><p>操作输出值&#x2F;控制输出值（MV,Manipulated Variable）：是控制器输出的控制信号，用于驱动执行器（如阀门、电机等），从而影响PV。是控制器用来调整PV的控制动作的量级。</p>
<p>MV是控制器用来影响PV的输出信号，而PV向SV靠近的过程是控制系统响应MV变化的结果。MV的大小和方向取决于控制器如何解释PV与SV之间的偏差。如果PV低于SV，控制器可能会增加MV来增加输出（例如打开阀门或增加加热），如果PV高于SV，控制器可能会减少MV来减少输出（例如关闭阀门或减少加热）。</p>
</li>
</ul>
<h2 id="PID控制算法"><a href="#PID控制算法" class="headerlink" title="PID控制算法"></a>PID控制算法</h2><blockquote>
<p>PID控制是一种线性控制，它将给定值(t)与实际输出值y(t)的偏差的比例(P),积分(I),微分(D)通过线性组合形成控制量，对被控对象进行控制。</p>
<p>控制系统通常根据有没有反馈会分为开环系统和闭环系统，在闭环系统的控制中，PID算法非常强大</p>
<p>工业应用上占了95%的应用比例,使用起来简单,无需精确建模</p>
<p>其三个部分分别为</p>
<ul>
<li>Proportion  比例   比例组件根据过程距设定点的距离按比例施加作用力</li>
<li>integration  积分   积分组件会努力将过程返回到设定点,误差存在的时间越长,量越大,积分输出越大</li>
<li>differential  微分   微分组件着眼于过程远离设定点的速度,相当于预测未来的误差来调整输出</li>
</ul>
<p>PID适用于二阶以内的线性系统   (线性指满足齐次性和叠加性,2阶以内是指系统动态方程中导数的最高次数在2以内)</p>
<p>针对高阶系统 可以化为 二阶系统</p>
<p>针对非线性系统 可以通过 李雅普诺夫线性化 近似为线性系统</p>
</blockquote>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2//202312121453911.png" alt="image-20231212145322088" style="zoom: 67%;" />

<p><code>PID</code>算法可以自动对控制系统进行准确且迅速的校正，因此被广泛地应用于工业控制系统   <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/168751613">参考</a></p>
<h3 id="PID公式"><a href="#PID公式" class="headerlink" title="PID公式"></a>PID公式</h3><p>下面过程出自<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/168751613">此博客</a></p>
<p>PID控制的完整公式实际上是:(e是误差)<br>$$<br>C&#x3D;\frac{1}{P}(e+\frac{1}{T_{i}}\int_{0}^{t}e{dt}+T_{d}\frac{de}{dt})<br>$$<br>实际上常用的是:<br>$$<br>C&#x3D;k_{p}e+k_{i}\int_{0}^{t}edt+k_{d}\frac{de}{dt}<br>$$<br>离散化后如下:<br>$$<br>\begin{aligned}&amp;\text{比例项: }K_pe(t)\xrightarrow{\textbf{离散化}} K _ p e _ k \\text{ 积分项: }&amp;K_i\int_0^{t_k}e(\tau)d\tau\xrightarrow{\text{离散化}} K _ i \sum _ { i &#x3D; 1 }^{k}e(i)\Delta t\&amp;\text{微分项: }K_d\frac{de(t_k)}{dt}\xrightarrow{\text{离散化}} K _ d \frac { e ( k ) - e ( k - 1 ) }{ \Delta t}\end{aligned}<br>$$<br>分别看</p>
<ul>
<li><p>比例项  $K_pe_k$</p>
<p>$e_k$表示x点的状态值与目标状态值的偏差(如图$e_x$就是$e_k$)</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202404221555611.png" alt="image-20240422155515897" style="zoom:25%;" />
</li>
<li><p>积分项  $K_i\sum_{i&#x3D;1}^ke(i)\Delta t$</p>
<p>$\sum_{i&#x3D;1}^ke(i)\Delta t$表示为下图三个颜色块的面积之和</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202404221558924.png" alt="image-20240422155832526" style="zoom:25%;" />
</li>
<li><p>微分项   $K_d\frac{e(k)-e(k-1)}{\Delta t}$</p>
<p>$\frac{e(k)-e(k-1)}{\Delta t}$表示下图中点的微分</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202404221602080.png" alt="image-20240422160219761" style="zoom:25%;" /></li>
</ul>
<p>离散化后得到PID的离散表达式:<br>$$<br>u(k)&#x3D;K_pe_k+K_i\sum_{i&#x3D;1}^ke(i)\Delta t+K_d\frac{e(k)-e(k-1)}{\Delta t}<br>$$<br>由于$\Delta t$是固定值,将$\Delta t$归入K中就得到了位置式PID</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202404221608502.png" alt="image-20240422160800161" style="zoom: 50%;" />

<p>根据$\Delta u(k)&#x3D;u(k)-u(k-1)$可得到增量式PID的离散公式如下:<br>$$<br>\Delta u(k)&#x3D;K_p(e(k)-e(k-1))+K_ie(k)+K_d\left(e(k)-2e(k-1)+e(k-2)\right)<br>$$</p>
<ul>
<li>$k_{p}$  比例增益:决定减少误差的速度的参数</li>
<li>$k_{i}$  积分增益:取决于之前所有误差的累积.消除了稳态误差,但也可能引入震荡</li>
<li>$k_{d}$  微分增益:取决于误差变化速度.增加阻尼减弱震荡效果增加稳定性:当偏差变化过快，微分环节会输出较大的负数，作为抑制输出继续上升，从而抑制过冲。</li>
</ul>
<p>位置式PID和增量式PID本质是同一个公式</p>
<p>在真正使用PID控制算法的时候:最好还要做到:积分限幅,积分分离,微分先行</p>
<h3 id="PID代码"><a href="#PID代码" class="headerlink" title="PID代码"></a>PID代码</h3><p>pid.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PIDImpl</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PID</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// Kp - 比例增益</span></span><br><span class="line">        <span class="comment">// Ki - 积分增益</span></span><br><span class="line">        <span class="comment">// Kd - 微分增益</span></span><br><span class="line">        <span class="comment">// dt - 循环间隔时间</span></span><br><span class="line">        <span class="comment">// max - 受控变量的最大值</span></span><br><span class="line">        <span class="comment">// min - 受控变量的最小值</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//用指定的循环间隔时间（dt），最大和最小的受控变量值（max和min），以及比例、微分和积分增益（Kp，Kd和Ki）初始化PID控制器。</span></span><br><span class="line">        <span class="built_in">PID</span>( <span class="type">double</span> dt, <span class="type">double</span> max, <span class="type">double</span> min, <span class="type">double</span> Kp, <span class="type">double</span> Kd, <span class="type">double</span> Ki );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据设定点和当前过程值计算并返回受控变量</span></span><br><span class="line">        <span class="function"><span class="type">double</span> <span class="title">calculate</span><span class="params">( <span class="type">double</span> setpoint, <span class="type">double</span> pv )</span></span>;</span><br><span class="line">        ~<span class="built_in">PID</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        PIDImpl *pimpl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PIDImpl</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">PIDImpl</span>( <span class="type">double</span> dt, <span class="type">double</span> max, <span class="type">double</span> min, <span class="type">double</span> Kp, <span class="type">double</span> Kd, <span class="type">double</span> Ki );</span><br><span class="line">        ~<span class="built_in">PIDImpl</span>();</span><br><span class="line">        <span class="function"><span class="type">double</span> <span class="title">calculate</span><span class="params">( <span class="type">double</span> setpoint, <span class="type">double</span> pv )</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">double</span> _dt;</span><br><span class="line">        <span class="type">double</span> _max;</span><br><span class="line">        <span class="type">double</span> _min;</span><br><span class="line">        <span class="type">double</span> _Kp;</span><br><span class="line">        <span class="type">double</span> _Kd;</span><br><span class="line">        <span class="type">double</span> _Ki;</span><br><span class="line">        <span class="type">double</span> _pre_error;</span><br><span class="line">        <span class="type">double</span> _integral;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>pid.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pid.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PID::<span class="built_in">PID</span>( <span class="type">double</span> dt, <span class="type">double</span> max, <span class="type">double</span> min, <span class="type">double</span> Kp, <span class="type">double</span> Kd, <span class="type">double</span> Ki )</span><br><span class="line">&#123;</span><br><span class="line">    pimpl = <span class="keyword">new</span> <span class="built_in">PIDImpl</span>(dt,max,min,Kp,Kd,Ki);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">PID::calculate</span><span class="params">( <span class="type">double</span> setpoint, <span class="type">double</span> pv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pimpl-&gt;<span class="built_in">calculate</span>(setpoint,pv);</span><br><span class="line">&#125;</span><br><span class="line">PID::~<span class="built_in">PID</span>() </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> pimpl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implementation</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PIDImpl::<span class="built_in">PIDImpl</span>( <span class="type">double</span> dt, <span class="type">double</span> max, <span class="type">double</span> min, <span class="type">double</span> Kp, <span class="type">double</span> Kd, <span class="type">double</span> Ki ) :</span><br><span class="line">    _dt(dt),</span><br><span class="line">    _max(max),</span><br><span class="line">    _min(min),</span><br><span class="line">    _Kp(Kp),</span><br><span class="line">    _Kd(Kd),</span><br><span class="line">    _Ki(Ki),</span><br><span class="line">    _pre_error(<span class="number">0</span>),</span><br><span class="line">    _integral(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">PIDImpl::calculate</span><span class="params">( <span class="type">double</span> setpoint, <span class="type">double</span> pv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算误差</span></span><br><span class="line">    <span class="type">double</span> error = setpoint - pv;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比例项</span></span><br><span class="line">    <span class="type">double</span> Pout = _Kp * error;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 积分项</span></span><br><span class="line">    _integral += error * _dt;</span><br><span class="line">    <span class="type">double</span> Iout = _Ki * _integral;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 微分项</span></span><br><span class="line">    <span class="type">double</span> derivative = (error - _pre_error) / _dt;</span><br><span class="line">    <span class="type">double</span> Dout = _Kd * derivative;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算总输出</span></span><br><span class="line">    <span class="type">double</span> output = Pout + Iout + Dout;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 限制在最大/最小值范围内</span></span><br><span class="line">    <span class="keyword">if</span>( output &gt; _max )</span><br><span class="line">        output = _max;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( output &lt; _min )</span><br><span class="line">        output = _min;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存当前误差为上次误差</span></span><br><span class="line">    _pre_error = error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PIDImpl::~<span class="built_in">PIDImpl</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PID pid2 = <span class="built_in">PID</span>(<span class="number">0.1</span>, <span class="number">100</span>, <span class="number">-100</span>, <span class="number">0.1</span>, <span class="number">0.01</span>, <span class="number">0.5</span>);</span><br><span class="line">  <span class="type">double</span> val = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">      <span class="type">double</span> inc = pid<span class="number">2.</span><span class="built_in">calculate</span>(<span class="number">0</span>, val);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;val:% 7.3f inc:% 7.3f\n&quot;</span>, val, inc);</span><br><span class="line">      val += inc;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="现成的pid算法"><a href="#现成的pid算法" class="headerlink" title="现成的pid算法"></a>现成的pid算法</h3><ul>
<li>Boost库里有PID控制器的封装。Boost::PID是基于boost::ublas的PID算法实现,提供基本的PID功能。</li>
<li>Arduino库内的PID.h头文件封装了PID控制器类,支持增量式PID算法。</li>
<li>OpenCV库中的cv::PIDController类实现了离散PID控制器。</li>
<li>GNU科学库GSL中的gsl_control_pid_ss函数提供了单点离散PID控制。</li>
<li>Eigen库中有BasicPIDControllers类实现基本PID控制。</li>
</ul>
<h3 id="PID变种"><a href="#PID变种" class="headerlink" title="PID变种"></a>PID变种</h3><ol>
<li><p><strong>PI 控制器</strong>：</p>
<p>仅使用比例和积分控制，适用于对稳态误差要求较高的系统，但不需要微分控制。</p>
</li>
<li><p><strong>PD 控制器</strong>：</p>
<p>仅使用比例和微分控制，适用于快速响应的系统，能够减少超调，但不能消除稳态误差。</p>
</li>
<li><p><strong>PID 控制器</strong>：</p>
<p>经典的 PID 控制器，结合了比例、积分和微分控制，适用于大多数工业控制系统。</p>
</li>
<li><p><strong>自整定 PID 控制器（Auto-tuning PID）</strong>：</p>
<p>具有自动调节参数的功能，可以根据系统的响应自动调整 Kp、Ki 和 Kd 的值。</p>
</li>
<li><p><strong>模糊 PID 控制器</strong>：</p>
<p>将模糊逻辑与 PID 控制相结合，通过模糊规则来调整 PID 参数，以适应非线性系统。</p>
</li>
<li><p><strong>滑模控制（Sliding Mode Control）</strong>：</p>
<p>在控制过程中引入滑模控制策略，以提高系统的鲁棒性和抗干扰能力。</p>
</li>
<li><p><strong>增益调度 PID 控制器</strong>：</p>
<p>根据系统状态或工作点动态调整 PID 参数，适用于具有非线性特性的系统。</p>
</li>
<li><p><strong>复合 PID 控制器（Cascade PID）</strong>：</p>
<p>将多个 PID 控制器级联在一起，形成复合控制策略，以提高控制性能。</p>
</li>
<li><p><strong>位置 PID 控制器与速度 PID 控制器</strong>：</p>
<p>针对不同的控制需求，分别设计用于位置控制和速度控制的 PID 控制器。</p>
</li>
<li><p><strong>抗饱和 PID 控制器</strong>：</p>
<p>在积分部分引入抗饱和机制，以防止积分风up现象，确保系统稳定性。</p>
</li>
<li><p><strong>PID 控制器的变种（如 PIDF、PI-D、PD-I）</strong>：</p>
<p>这些变种根据具体需求，调整了 PID 控制器的组成部分，例如引入前馈控制、调整积分和微分的计算方式等。</p>
</li>
</ol>
<h3 id="PID参数评估"><a href="#PID参数评估" class="headerlink" title="PID参数评估"></a>PID参数评估</h3><h4 id="时域指标-动态响应"><a href="#时域指标-动态响应" class="headerlink" title="时域指标(动态响应)"></a>时域指标(动态响应)</h4><ul>
<li><strong>超调量</strong>（Overshoot, $M_p$)：响应曲线超过设定值的最大偏差百分比。优秀PID参数应使超调量&lt;10%（高精度场景要求&lt;5%）。</li>
<li><strong>上升时间</strong>（$t_r$)：响应从稳态值10%升至90%所需时间。需平衡速度与超调，过快易引发振荡。</li>
<li><strong>调节时间</strong>（$t_s$)：系统进入并保持在设定值±5%误差带内的时间。代表收敛速度，典型要求为&lt;系统主时间常数。</li>
<li><strong>稳态误差</strong>（Steady-state Error）：系统稳定后与设定值的偏差。积分项（I）可消除稳态误差，但过度会导致超调。单位就是检测的值本身的单位</li>
<li><strong>峰值时间</strong>（$t_p$)：达到第一个峰值所需时间，反映初始响应速度。</li>
</ul>
<p>这些性能指标（超调量、上升时间、调节时间、稳态误差和峰值时间）的计算<strong>只需要两个核心数据</strong>：</p>
<ol>
<li><strong>设定值（Setpoint，SP）</strong>：控制系统期望达到的目标值</li>
<li><strong>过程变量（Process Variable，PV）</strong>：被控对象实际反馈的测量值</li>
</ol>
<h4 id="频域指标-鲁棒性"><a href="#频域指标-鲁棒性" class="headerlink" title="频域指标(鲁棒性)"></a>频域指标(鲁棒性)</h4><ul>
<li><p>相位裕度（PM）：开环传递函数在增益交界频率处的相位偏移量。PM&gt;45°表明系统稳定。</p>
</li>
<li><p>增益裕度（GM）：系统达到临界稳定前可增加的增益倍数。GM&gt;6dB为安全边界。</p>
</li>
<li><p>带宽（Bandwidth）：系统有效跟踪输入信号的频率范围，带宽越宽响应越快，但噪声敏感性增加。</p>
</li>
<li><p>阶跃响应法</p>
</li>
<li><p>ZN整定法</p>
</li>
<li><p>临界震荡法</p>
</li>
<li><p>Lambda整定</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202506121748640.png" alt="image-20250612174854130"></p>
<h2 id="PID调参参考"><a href="#PID调参参考" class="headerlink" title="PID调参参考"></a>PID调参参考</h2><p>参考指标: SP(设定点)曲线 ,PV（过程变量）曲线,OUT（控制输出）曲线, 积分项（Integral_Sum）曲线</p>
<ol>
<li>初始准备<ol>
<li>设置初始限幅   初始按照物理限制设置输出限幅区间,初始积分限幅为(最大值-最小值)*0.2左右</li>
<li>PID初始值: P&#x3D;0,I&#x3D;0,D&#x3D;0</li>
</ol>
</li>
<li>调节P值<ol>
<li>从纯P (<code>I=0, D=0</code>)开始，小步增加P，找到临界振荡点 (<code>Ku(临界增益)</code>, <code>Pu(临界周期)</code>)</li>
<li>初始工作点P：<code>P = Ku / 2.5</code> 或 <code>P = Ku / 3</code>（倾向于更保守以缓解后续I和积分限幅的压力）</li>
</ol>
</li>
<li>调节I值<ol>
<li>保留上一步得到的 <code>P</code>，设定一个<strong>较小的 <code>I</code> (例如 <code>I = P * 0.05</code> 或基于 <code>Pu</code> 如 <code>I = 0.6 * P / Pu</code>)</strong></li>
<li>小步长提高I,观察目标,系统趋向稳定,查看积分项曲线,应该在积分限幅内活动,暂时不要撞到限幅<ul>
<li>如果系统不稳定或震荡加剧: 减小I或略微减小P,目标是得到一个有稳态误差但过程平稳的响应</li>
</ul>
</li>
<li>观察积分项的值是否达到了饱和(积分限幅)?<ul>
<li>积分项没有饱和(仍在积分限幅内): 说明当前的I太小了,稍微增大I,重复这个过程直到积分项开始接近积分饱和,或者稳态误差消失</li>
<li>积分项已经饱和,但仍然有显著的稳态误差: 说明消除此误差所需的积分贡献超出了你设定的积分限幅.此时保持I不变,仅小步幅增大积分限幅,直到稳态误差归零或小于要求精度</li>
</ul>
</li>
</ol>
</li>
<li>调节D值<ol>
<li>保持调好的P,I,积分限幅,加入小D</li>
<li>小步增大D,目标是抑制超调,加快系统响应</li>
<li>如果输出抖动,输出噪声放大,如果有则立即减小D,许多系统不需要D(特别是噪声大的系统)</li>
</ol>
</li>
<li>整体微调</li>
</ol>
<h2 id="适用于非线性系统的控制算法"><a href="#适用于非线性系统的控制算法" class="headerlink" title="适用于非线性系统的控制算法"></a>适用于非线性系统的控制算法</h2><ol>
<li>模糊控制（Fuzzy Control）</li>
<li>自适应控制（Adaptive Control）</li>
<li>滑膜控制（Sliding Mode Control）</li>
<li>非线性反馈控制（Nonlinear Feedback Control）</li>
<li>神经网络控制（Neural Network Control）</li>
<li>预测控制（Model Predictive Control, MPC）</li>
<li>增益调度（Gain Scheduling）</li>
</ol>
<h2 id="模糊控制算法"><a href="#模糊控制算法" class="headerlink" title="模糊控制算法"></a>模糊控制算法</h2><p>Fuzzy Logic Control(FLC)</p>
<p>模糊化是根据特定输入值的拟合程度,将特定输入值转换为模糊集某种程度的隶属度的过程</p>
<p>隶属函数描述特定输入或输出变量,这些隶属函数可以用图形表示</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202405070853189.png" alt="image-20240507085315482" style="zoom: 25%;" />

<p>这些隶属函数有助于量化基于语言变量,而不是精确数值做出决策所涉及的模糊逻辑</p>
<h2 id="模型预测控制"><a href="#模型预测控制" class="headerlink" title="模型预测控制"></a>模型预测控制</h2><p>Model Predictive Control(MPC)</p>
<p>是一种反馈控制技术,基于数学模型预测系统未来行为的控制算法</p>
<p>作为许多工业应用中强大且广泛使用的控制策略</p>
<h2 id="其他控制算法"><a href="#其他控制算法" class="headerlink" title="其他控制算法"></a>其他控制算法</h2><ul>
<li>自适应控制算法</li>
<li>神经网络控制算法</li>
</ul>
<h2 id="多因子PID控制"><a href="#多因子PID控制" class="headerlink" title="多因子PID控制"></a>多因子PID控制</h2><p>PID控制器可以实现多个控制因子对一个最终采样值的控制,称为<strong>多输入单输出（MISO）控制系统</strong></p>
<p>三种主要实现方法</p>
<ul>
<li><a href="#%E5%A4%9A%E5%8F%98%E9%87%8F%E5%B9%B6%E8%A1%8CPID%E6%8E%A7%E5%88%B6">多变量并行PID控制</a></li>
<li><a href="#%E5%8D%8F%E5%90%8C%E6%8E%A7%E5%88%B6%E7%9F%A9%E9%98%B5%E6%B3%95">协同控制矩阵法</a></li>
<li><a href="#%E5%A2%9E%E7%9B%8A%E8%B0%83%E5%BA%A6PID">增益调度PID</a></li>
</ul>
<h3 id="多变量并行PID控制"><a href="#多变量并行PID控制" class="headerlink" title="多变量并行PID控制"></a>多变量并行PID控制</h3><p>各控制因子独立影响输出，作用可线性叠加</p>
<h2 id="用于PID的温度仿真模拟"><a href="#用于PID的温度仿真模拟" class="headerlink" title="用于PID的温度仿真模拟"></a>用于PID的温度仿真模拟</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SimulationTemperature</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">double</span> 电热丝功率 = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">double</span> 比热容 = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">double</span> 质量 = <span class="number">1.0</span>; <span class="comment">// kg;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">double</span> 环境温度 = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">double</span> 散热系数 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">double</span> 输出百分比 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">double</span> 当前温度;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> IntervalMS = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始仿真</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> 上一次的热量 = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">var</span> 上一次的温度 = 环境温度;</span><br><span class="line">        当前温度 = 环境温度;</span><br><span class="line">        <span class="built_in">double</span> 热量;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> 发热功率 = 电热丝功率 * 输出百分比 / <span class="number">100</span>;</span><br><span class="line">            <span class="comment">// 使用上一次的温度计算散热功率，避免循环依赖</span></span><br><span class="line">            <span class="keyword">var</span> 温度变化 = 当前温度 - 环境温度;</span><br><span class="line">            <span class="keyword">var</span> 散热功率 = 散热系数 * 温度变化;</span><br><span class="line">            <span class="keyword">var</span> 实际功率 = 发热功率 - 散热功率;</span><br><span class="line">            热量 = 上一次的热量 + 实际功率;</span><br><span class="line">            <span class="keyword">var</span> 新温度变化 = 比热容 == <span class="number">0</span> ? <span class="number">0</span> : 热量 / (比热容 * 质量);</span><br><span class="line">            当前温度 = 环境温度 + 新温度变化;</span><br><span class="line">            <span class="keyword">await</span> Task.Delay(IntervalMS);</span><br><span class="line">            上一次的温度 = 当前温度;</span><br><span class="line">            上一次的热量 = 热量;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> 获取当前温度()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> 当前温度;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 设置输出百分比(<span class="built_in">double</span> 输出百分比)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.输出百分比 = 输出百分比;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 设置晶振(<span class="built_in">int</span> milliseconds)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.IntervalMS = milliseconds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="快速傅里叶变换算法"><a href="#快速傅里叶变换算法" class="headerlink" title="快速傅里叶变换算法"></a>快速傅里叶变换算法</h1><p>[[数学#傅里叶变化|参考傅里叶变换数学原理]]</p>
<h2 id="基于fft的快速快速乘法"><a href="#基于fft的快速快速乘法" class="headerlink" title="基于fft的快速快速乘法"></a>基于fft的快速快速乘法</h2><h1 id="物理仿真算法"><a href="#物理仿真算法" class="headerlink" title="物理仿真算法"></a>物理仿真算法</h1><h2 id="运动学算法"><a href="#运动学算法" class="headerlink" title="运动学算法"></a>运动学算法</h2><p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=qlfh_rv6khY">此处收录一个程序化动画技术视频链接</a>,生物模拟,机械臂等都属于这个可用范围中</p>
<p>设置一个锚点,并通过[[数学#圆参数方程|圆参数方程]],约束下一个点的位置,如果移动锚点,下一个点也会跟随锚点移动</p>
<p>将多个点用这种约束串联起来,使每个点都能约束到下一个点.当我们移动第一个点的时候,整个链条会按照我们的约束的顺序跟随移动</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202409211005868.png" alt="image-20240921100550143" style="zoom: 33%;" />

<p>然后如果有需要可以添加每两节体节的角度平滑:给定任意两体节,若干角度差太大,缩回至所需阈值</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202409210941623.png" alt="image-20240921094108340"></p>
<h3 id="正向运动学"><a href="#正向运动学" class="headerlink" title="正向运动学"></a>正向运动学</h3><p>Forward Kinematics</p>
<p>通过多个向量相加计算出目标的坐标点</p>
<h3 id="反向运动学"><a href="#反向运动学" class="headerlink" title="反向运动学"></a>反向运动学</h3><p>Inverse Kinematics</p>
<p>由目标坐标点,如何找到正确角度旋转手臂</p>
<p> 有一种非常简单的近似技术,<a href="#FABRIK">FABRIK</a></p>
<h2 id="碰撞检测"><a href="#碰撞检测" class="headerlink" title="碰撞检测"></a>碰撞检测</h2><p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=9IULfQH7E90">参考链接</a></p>
<p>最简单的思路就是遍历所有两个对象之间的重叠判断,以圆为例就是判断两个对象锚点间的距离小于两半斤之和则为重叠</p>
<p>这样可以做到碰撞检测,但是效率十分低下,低效之处在于两个远离的对象之间执行了很多无用的检查</p>
<p>因此必须引入空间分割的概念 </p>
<p>最简单的结构之一就是固定网格加速</p>
<h3 id="FABRIK"><a href="#FABRIK" class="headerlink" title="FABRIK"></a>FABRIK</h3><p>FABRIK（Forward and Backward Reaching Inverse Kinematics）是一种用于逆向运动学（Inverse Kinematics, IK）求解的算法，广泛应用于计算机动画、游戏开发和机器人运动控制等领域。它的主要目的是通过调整关节的位置来实现目标位置的达成，通常用于角色动画和机械臂控制。</p>
<p>在锚点和目标点之间不断重复来回拉扯机械臂,直到收敛于从锚点开始并朝向目标位置的排列</p>
<h4 id="FABRIK基本原理"><a href="#FABRIK基本原理" class="headerlink" title="FABRIK基本原理"></a>FABRIK基本原理</h4><p>FABRIK 算法的核心思想是通过前向和后向的迭代过程来求解关节的位置，使得末端效应器（如手、脚等）能够达到目标位置。具体步骤如下：</p>
<ol>
<li><strong>初始化</strong>：设置关节的初始位置和目标位置。</li>
<li><strong>前向迭代</strong>：<ul>
<li>从根关节开始，逐个更新关节的位置，使得每个关节与其下一个关节之间的距离保持不变。</li>
<li>这一过程会将末端效应器逐渐移动到目标位置。</li>
</ul>
</li>
<li><strong>后向迭代</strong>：<ul>
<li>从末端效应器开始，逐个更新关节的位置，使得每个关节与其上一个关节之间的距离保持不变。</li>
<li>这一过程会确保关节的运动不会超出其物理限制。</li>
</ul>
</li>
<li><strong>重复迭代</strong>：重复前向和后向迭代，直到末端效应器接近目标位置或达到预设的迭代次数。</li>
</ol>
<h1 id="LQR控制器"><a href="#LQR控制器" class="headerlink" title="LQR控制器"></a>LQR控制器</h1><h1 id="工业上的平滑算法"><a href="#工业上的平滑算法" class="headerlink" title="工业上的平滑算法"></a>工业上的平滑算法</h1><p>在工业上，当传感器测得的数据波动非常大时，常用的方法之一是数据平滑处理。以下是几种常见的数据平滑方法：</p>
<ol>
<li><strong>移动平均法</strong>：计算一定时间窗口内的数据平均值，用平均值替代原始数据点。移动平均法可以有效地减少数据的波动，使数据更加平滑。</li>
<li><strong>指数加权移动平均法</strong>：与简单移动平均法不同，指数加权移动平均法给予最近数据点更大的权重，使得平均值更加灵活地跟随数据的变化。</li>
<li><a href="#%E6%BB%A4%E6%B3%A2%E5%99%A8">滤波器</a>：使用数字滤波器对数据进行滤波处理，常见的滤波器包括低通滤波器和中值滤波器(滑动窗口取排序后的中位数),小值滤波器(滑动窗口取排序后的最小值)等。滤波器可以有效地去除数据中的噪声和波动。</li>
<li><a href="#%E6%A0%B7%E6%9D%A1%E6%8F%92%E5%80%BC">数据插值</a>：通过插值算法对数据进行插值处理，填补数据中的缺失或异常值，使得数据更加平滑。</li>
</ol>
<p>现在是这个这样的情况,我需要实时修正一组数据的离群点,数据点以一秒一个的方式获取到,需要实时处理已经出现的数据点中的异常点,这些离群点可能连续几个上下连续大幅以激变的形式出现,我需要将这样的异常点找出来.并且不具备任何的数学模型,是否有合适的算法可以使用</p>
<h1 id="卡拉楚巴算法"><a href="#卡拉楚巴算法" class="headerlink" title="卡拉楚巴算法"></a>卡拉楚巴算法</h1><p>属于底层数学原理,上层用不上</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1xt1PYgE51/">参考视频:为了让电脑更快，他们把“乘法”玩到了极致</a></p>
<p>优化乘法运算的复杂度</p>
<h1 id="滤波器"><a href="#滤波器" class="headerlink" title="滤波器"></a>滤波器</h1><ul>
<li><strong>消除噪声</strong>：平均滤波器、高斯滤波器、维纳滤波器</li>
<li><strong>保留边缘细节</strong>：中值滤波器、高斯滤波器</li>
<li><strong>动态系统状态估计</strong>：卡尔曼滤波器、自适应滤波器</li>
<li><strong>图像处理</strong>：高斯滤波器、卷积滤波器</li>
<li><strong>音频处理</strong>：巴特沃斯滤波器、切比雪夫滤波器</li>
</ul>
<h2 id="常用滤波器介绍"><a href="#常用滤波器介绍" class="headerlink" title="常用滤波器介绍"></a>常用滤波器介绍</h2><p><a href="#%E4%B8%AD%E5%80%BC%E6%BB%A4%E6%B3%A2">中值滤波器 (Median Filter)</a></p>
<blockquote>
<p>优势:</p>
<ul>
<li>对于脉冲噪声（如盐椒噪声）效果显著，能<strong>有效去除异常值</strong>。</li>
<li>保留边缘细节，不会模糊图像。</li>
</ul>
<p>适用场景:</p>
<ul>
<li>图像处理中去除单像素噪声。</li>
<li><strong>传感器数据处理，去除瞬时噪声</strong>。</li>
</ul>
</blockquote>
<p><strong>平均滤波器 (Mean Filter)</strong></p>
<blockquote>
<p>优势:</p>
<ul>
<li>简单易实现，计算速度快。</li>
<li>平滑效果较好，能<strong>有效消除高频噪声</strong>。</li>
</ul>
<p>适用场景:</p>
<ul>
<li>需要快速处理的信号平滑。</li>
<li>对频谱不敏感，适合于一般噪声的平滑。</li>
</ul>
</blockquote>
<p><strong>高斯滤波器 (Gaussian Filter)</strong></p>
<blockquote>
<p>优势:</p>
<ul>
<li>保留图像细节，平滑效果较为自然。</li>
<li>通过调节参数可以控制平滑程度和边缘保留效果。</li>
</ul>
<p>适用场景:</p>
<ul>
<li>图像处理中常用的模糊滤波方法。</li>
<li>需要平滑信号但又不希望失去细节的情况。</li>
</ul>
</blockquote>
<p><a href="#%E5%B7%B4%E7%89%B9%E6%B2%83%E6%96%AF%E6%BB%A4%E6%B3%A2">巴特沃斯滤波器 (Butterworth Filter)</a></p>
<blockquote>
<p>优势:</p>
<ul>
<li>频率响应平坦，截止频率处不产生波纹。</li>
<li>可以实现比较陡峭的频率特性。</li>
</ul>
<p>适用场景:</p>
<ul>
<li>通信系统中的滤波器设计。</li>
<li>需要平滑频率响应的应用，如音频和语音处理。</li>
</ul>
</blockquote>
<p><strong>切比雪夫滤波器 (Chebyshev Filter)</strong></p>
<blockquote>
<p>优势:</p>
<ul>
<li>可以实现非常陡峭的频率特性。</li>
<li>在通带或阻带允许一定纹波情况下，能提供更好的截止特性。</li>
</ul>
<p>适用场景:</p>
<ul>
<li><strong>对频率响应要求较高的通信和雷达系统</strong>。</li>
<li>需要在频域上实现比较严格的要求。</li>
</ul>
</blockquote>
<p><strong>维纳滤波器 (Wiener Filter)</strong></p>
<blockquote>
<p>优势:</p>
<ul>
<li>根据信号和噪声的统计特性自适应调整滤波器参数。</li>
<li>在知道信号和噪声的统计特性时，能够达到最优的去噪效果。</li>
</ul>
<p>适用场景:</p>
<ul>
<li><strong>信号和噪声的统计特性已知</strong>，如通信系统中的信号重建和去噪。</li>
</ul>
</blockquote>
<p><a href="#%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2">卡尔曼滤波器 (Kalman Filter)</a></p>
<blockquote>
<p>优势:</p>
<ul>
<li>可以对动态系统的状态进行估计和预测，适用于非线性和线性系统。</li>
<li>通过状态预测和更新，能够提供最优的估计结果。</li>
</ul>
<p>适用场景:</p>
<ul>
<li>航空航天、导航系统中的位置和速度估计。</li>
<li>移动机器人的轨迹跟踪和状态估计。</li>
</ul>
</blockquote>
<p><strong>自适应滤波器 (Adaptive Filter)</strong></p>
<blockquote>
<p>优势:</p>
<ul>
<li>能够动态调整滤波器参数，根据信号特性自适应地优化滤波效果。</li>
<li>在信号特性随时间变化或环境变化的情况下，能够保持较好的滤波效果。</li>
</ul>
<p>适用场景:</p>
<ul>
<li>信号特性动态变化的自适应滤波需求，如通信、雷达和生物信号处理。</li>
</ul>
</blockquote>
<p><strong>梯形滤波器 (Trapezoidal Filter)</strong></p>
<blockquote>
<p>优势:</p>
<ul>
<li>通过加权平均当前和前后若干点的数据，能够较好地平滑信号。</li>
<li>权重的梯形分布有助于保留信号的边缘细节。</li>
</ul>
<p>适用场景:</p>
<ul>
<li>需要在平滑信号的同时保留边缘细节的应用，如图像和声音处理。</li>
</ul>
</blockquote>
<p><strong>卷积滤波器 (Convolution Filter)</strong></p>
<blockquote>
<p>优势:</p>
<ul>
<li>通过卷积运算处理信号，可以实现多种复杂的滤波效果。</li>
<li>在图像处理和深度学习中有广泛应用，能够实现多种空间和频域上的滤波需求。</li>
</ul>
<p>适用场景:</p>
<ul>
<li>图像处理中的边缘检测、模糊处理和特征提取。</li>
<li>深度学习中的卷积神经网络中的特征卷积。</li>
</ul>
</blockquote>
<h2 id="中值滤波"><a href="#中值滤波" class="headerlink" title="中值滤波"></a>中值滤波</h2><p>中值滤波是一种常用的信号处理方法，用于去除噪声和平滑数据。它通过将每个点替换为其邻域窗口中的中值，从而<strong>有效地去除尖锐的噪声</strong></p>
<p><strong>边缘效应</strong>：对于数据集的边缘部分，由于窗口的一部分会超出数据边界，可以采用不同的策略处理边缘（如<strong>重复边缘数据、补零、仅使用有效数据</strong>等）</p>
<p>下面提供一个中值滤波的例子</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;<span class="built_in">double</span>&gt; <span class="title">MedianFilter</span>(<span class="params">List&lt;<span class="built_in">double</span>&gt; data, <span class="built_in">int</span> windowSize</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (windowSize % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">&quot;Window size must be odd.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">int</span> halfWindowSize = windowSize / <span class="number">2</span>;</span><br><span class="line">  List&lt;<span class="built_in">double</span>&gt; filteredData = <span class="keyword">new</span> List&lt;<span class="built_in">double</span>&gt;(data.Count);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; data.Count; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    List&lt;<span class="built_in">double</span>&gt; window = <span class="keyword">new</span> List&lt;<span class="built_in">double</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> j = -halfWindowSize; j &lt;= halfWindo`wSize; j++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">int</span> index = i + j;</span><br><span class="line">      <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; data.Count)</span><br><span class="line">      &#123;</span><br><span class="line">        window.Add(data[index]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    window.Sort();</span><br><span class="line">    filteredData.Add(window[window.Count / <span class="number">2</span>]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> filteredData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="一阶-αβ-滤波"><a href="#一阶-αβ-滤波" class="headerlink" title="一阶(αβ)滤波"></a>一阶(αβ)滤波</h2><p>一阶滤波是比较常用简单的滤波方法，就是当前采样结果和上一个滤波结果加权求和，权重和为1。<strong>对周期干扰噪声有良好的抑制作用</strong>，但同样会产生<strong>相位滞后</strong>，权重是固定值也是其缺点之一。</p>
<h2 id="巴特沃斯滤波"><a href="#巴特沃斯滤波" class="headerlink" title="巴特沃斯滤波"></a>巴特沃斯滤波</h2><p>巴特沃斯滤波器（Butterworth Filter）是一种数字滤波器，常用于信号处理领域中对频率进行滤波和调整。巴特沃斯滤波器的设计基于巴特沃斯多项式，具有平滑的频率响应曲线和良好的通频带特性。</p>
<p>巴特沃斯滤波器在信号处理中具有广泛的应用，可以帮助滤除噪声、调整信号频率特性、设计滤波器等</p>
<p>巴特沃斯滤波器主要用于解决以下问题：</p>
<ol>
<li><strong>信号滤波：</strong> 巴特沃斯滤波器可以对信号进行滤波，去除不需要的频率成分，保留感兴趣的频率成分。这在信号处理中常用于去除噪声、平滑数据、提取特定频率成分等。</li>
<li><strong>频率调整：</strong> 巴特沃斯滤波器可以调整信号的频率特性，包括增强或抑制特定频率范围内的信号。这在音频处理、图像处理、通信系统等领域中很有用。</li>
<li><strong>滤波器设计：</strong> 巴特沃斯滤波器是一种经典的滤波器类型，其设计方法相对简单且易于实现。因此，它常被用于滤波器设计中，满足不同应用场景的频率响应要求。</li>
</ol>
<h2 id="卡尔曼滤波"><a href="#卡尔曼滤波" class="headerlink" title="卡尔曼滤波"></a>卡尔曼滤波</h2><blockquote>
<p>我的理解:一句话概括就是理论值和实际值的加权平均</p>
</blockquote>
<p>卡尔曼滤波（Kalman Filtering）是一种用于估计系统状态的最优滤波算法。它基于对系统的动态模型和测量模型进行建模，通过递归地更新状态估计值，提供对系统状态的最优估计和预测。</p>
<blockquote>
<p>卡尔曼滤波在以下情况需要使用</p>
<ol>
<li>当系统受到噪声干扰时，需要准确估计系统的状态。 </li>
<li>当系统具有复杂的动态模型或多个传感器测量值时，需要融合这些信息来得到更准确的状态估计。 </li>
<li>当系统需要快速响应和准确跟踪目标时，卡尔曼滤波可以提供更优秀的性能。 </li>
<li>当系统需要实时进行状态估计，并且需要考虑系统的动态特性和测量误差时，卡尔曼滤波是一个有效的选择。</li>
</ol>
</blockquote>
<p>这里我们就不扯那些专业术语了，我们讲“人话”。首先我们需要对卡尔曼滤波具体是干什么的要建立起一个最基本的概念，这里先借鉴<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/23971601">知乎用户Kent Zeng的说法</a>，给大家打一个大致的基础。</p>
<p>假设你现在处于某颗星球上，手上有两个力传感器，并且有一个已知质量为m的物体，但是你不清楚他们的重力大小，而且你也不知道你现在所处位置的重力加速度的具体值为多少，因此你打算通过两个传感器获得物体的重力。</p>
<p>但不幸的是它们测得的读数似乎每次都不太一样，那该怎么办？没错，就是<strong>取平均</strong>。</p>
<p>再假设你知道其中贵的那个传感器应该准一些，便宜的那个应该差一些。那有比取平均更好的办法吗？没错，<strong>加权平均</strong>。</p>
<p>再然后，假如你手上只有一个传感器，但是你碰巧得知了当地的重力加速度为g，那么你现在可以知道传感器测出的重力值为G1，你自己通过数学模型推导出来的重力G2 &#x3D; mg，但是这两个值之间似乎也有偏差，那该怎么办呢？</p>
<p>没错，我们还是取两值的加权平均，但是你不清楚G1和G2哪个更加可信，那么如何确定权值系数？这取决于你对这个g值的<strong>确信度</strong>，如果你更相信数学模型mg的推导结果，那么对应数学模型的权值更大，而你传感器的观测模型的权值则变小；如果你对g的确信度较小，那么就正好相反。而这个权值，在卡尔曼滤波中也叫作卡尔曼系数。</p>
<p>以上，就是卡尔曼滤波最基本的思想。没错，是不是很简单呢？当然，在这之中我们也忽略掉了一些东西，但是不要着急，我们一步一步来。</p>
<p>卡尔曼滤波实际上就是把传感器测得的值和根据数学模型推导出来的值融合以逼近实际值的过程，因此卡尔曼滤波也经常被称作传感器融合算法。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202407111046216.png" alt="在这里插入图片描述" style="zoom: 33%;" />

<p>左侧正态分布表示汽车起始点,经过一段时间后,右侧蓝色正态分布表示汽车计算出来可能落到的正态分布,右侧红色正态分布表示传感器测量出来的正态分布,卡尔曼滤波测出来的正态分布为右侧灰色正态分布</p>
<p><strong>通过数学模型预测得到了k时刻的位置估算值，然后将其与小车传感器的测量值进行结合，得到了当前k时刻小车的最佳位置估算值</strong></p>
<p>卡尔曼滤波的思想：</p>
<ol>
<li>卡尔曼滤波是利用线性状态模型，以及模型的输入和输出值，结合传感器测量值获取当前时刻的最佳状态估计值；</li>
<li>卡尔曼滤波假设所有的不确定性因素理论上都服从正态分布；</li>
<li>卡尔曼滤波就是使最后估算状态的高斯分布的期望值能够接近实际值，并且方差够小；</li>
<li>卡尔曼滤波工作于连续的系统，并通过迭代操作估算每一个时刻的最佳状态估计值。</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202407111043412.png" alt="在这里插入图片描述" style="zoom:33%;" />

<p>Car dynamics是小车的真实模型，内部的方程我们是不清楚的，这里只是为了更好地示意真实噪声环境下传感器测量结果的不确定性，我们能得知并且运用的，只有输入量$u_k$ 和传感器测量值 $k y_ky$；而 Car model 则是我们实际运用的数学模型，我们可以从中得出状态估计量 $\hat{x}$,其中w和v是随机噪声</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/moumde/article/details/107191722">相关公式参考此链接尾部分</a></p>
<h1 id="波函数坍缩算法"><a href="#波函数坍缩算法" class="headerlink" title="波函数坍缩算法"></a>波函数坍缩算法</h1><p>该算法的命名来源于量子力学<br>$$<br>量子系统在测量过程中，从多个可能状态，逐渐坍缩到一个确定状态的现象。      —–量子力学-波函数坍缩<br>$$</p>
<ul>
<li>需要制定约束规则</li>
<li>每当完成一个位置的坍缩后,会逐一调整剩余位置的可选坍缩可能</li>
<li>坍缩完成后下一个坍缩位置选择<ul>
<li>对于各种坍缩可能概率一致的情况,选坍缩数量最少的位置进行坍缩,因为可选坍缩数量越少,代表这个位置对地图后续走向越关键,因此处理的优先级更高;并且对最小的可能性数量的坍缩结果进行坍缩会提高整体效率</li>
<li>对于各种坍缩可能不一致的情况,引入熵的概念,选择熵(概念上表示最稳定的位置)最小的位置作为下一个坍缩目标</li>
</ul>
</li>
</ul>
<h2 id="熵"><a href="#熵" class="headerlink" title="熵"></a>熵</h2><p>$$<br>熵 &#x3D; -\sum_{i&#x3D;1}^Np_i\log_2p_i<br>$$</p>
<p>$p_i$为第i个坍缩可能的概率</p>
<h2 id="回溯机制"><a href="#回溯机制" class="headerlink" title="回溯机制"></a>回溯机制</h2><p>在坍缩的过程中可能会出现某个位置的可选坍缩可能数为0的情况,因此无法进行坍缩,为了解决这种场景,波函数坍缩算法加入了回溯机制:</p>
<p>每当完成一次坍缩后,算法会记录所有位置的状态快照,并将快照保存到一个栈中</p>
<p>当面临无解的情况,就可以回溯到有解的状态来避免做出那个选择</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>制定约束规则，并在坍缩过程中不断调整剩余未坍缩位置的可选瓦片</li>
<li>计算未坍缩位置的熵值，并选择熵值最小的位置作为下一个坍缩目标</li>
<li>每次坍缩后保存状态快照，并在遇到无解的情况时进行回溯</li>
</ul>
<h1 id="模拟退火算法"><a href="#模拟退火算法" class="headerlink" title="模拟退火算法"></a>模拟退火算法</h1><p>在众多好的算法中寻找最优的算法</p>
<h1 id="鸟群模拟算法"><a href="#鸟群模拟算法" class="headerlink" title="鸟群模拟算法"></a>鸟群模拟算法</h1><p>BOIDS算法是一种用于模拟鸟群行为的计算模型，由Craig Reynolds在1986年提出。该算法通过简单的规则来模拟个体（如鸟）之间的互动，从而形成复杂的群体行为。BOIDS模型主要基于三个基本规则：</p>
<ol>
<li><strong>分离（Separation）</strong>：个体会避免与邻近的其他个体过于接近，以防止碰撞。 </li>
<li><strong>对齐（Alignment）</strong>：个体会调整自己的运动方向，朝向鸟群的平均方向。 </li>
<li><strong>聚合（Cohesion）</strong>：个体会朝向邻近个体的中心位置移动，以保持群体的整体性。</li>
</ol>
<p>通过这三条简单的规则，BOIDS算法能够生成自然的群体运动效果，广泛应用于计算机图形学、动画、机器人技术等领域。</p>
<p>仅凭三条简单规则就能产生涌现复杂性或美丽</p>
<h1 id="避障算法"><a href="#避障算法" class="headerlink" title="避障算法"></a>避障算法</h1><h1 id="插值算法"><a href="#插值算法" class="headerlink" title="插值算法"></a>插值算法</h1><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/tardis/zm/art/269230598?source_id=1005">知乎详解参考</a></p>
<p>关于插值的详解:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://www.bilibili.com/video/BV17x4y1b7rr" alt="教程|720x360"></p>
<h2 id="线性插值"><a href="#线性插值" class="headerlink" title="线性插值"></a>线性插值</h2><p>最简单的线性插值公式</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202408291945145.png" alt="image-20240829194530379" style="zoom: 50%;" />
$$
对于0和1之间的任意t值,可以计算它们之间的百分比:A+(B-A)t
$$
线性插值最简单的公式就是👆🏻这样

<p>线性插值如下:<br>$$<br>\operatorname{lerp}(a, b, t)&#x3D;(1-t) a+t b<br>$$<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202501231118343.gif" alt="一次贝塞尔曲线演示.gif" style="zoom:67%;" /></p>
<p>但是最后一个参数t可以玩出很多花样来:<br>$$<br>A+(B-A)f(t)<br>$$</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">float <span class="title function_">lerp</span>(<span class="params">float A,float B,t</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> A+(B-A)*t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$f(t)&#x3D;t$的时候,这就是一个线性插值</p>
<p>于是一个插值函数可以概括为<code>lerp(A,B,f(t))</code></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202408291951195.png" alt="image-20240829195114565" style="zoom:25%;" />

<p>上图绿线为$f(t)&#x3D;t$,紫线为$f(t)&#x3D;t*t$,此时就不是线性插值了,可以理解为插值的密度或权重变化了.如果把y轴理解成一个小球向上运动的小球,此时两个函数虽然他们还是在同一个点开始,同一个点结束,但是小球向上运动的速度却在变化,后者需要一个启动时间,就相当于被设置另一个固定的加速度,然后从0开始加速</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202408291957340.png" alt="image-20240829195718722" style="zoom: 25%;" />

<p>同样,上图可见紫色线为$f(t)&#x3D;sqrt(t)$,初始高速度弹射起步,固定的加速度降低速度</p>
<p>同样也有平滑曲线(从左到中间缓慢加速,中间到终点时缓慢减速,起点和终点附近曲线平缓,中间曲线最陡)可以通过上面两个函数得到:</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202408292001862.png" alt="image-20240829200103300" style="zoom:25%;" />



<p>下面盘点记录一下常用的函数</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202408292004777.png" alt="image-20240829200440159" style="zoom:25%;" /><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202408300900916.png" alt="image-20240830090027555" style="zoom: 50%;" /><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202408292006894.png" alt="image-20240829200643254" style="zoom:25%;" /><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202408292008755.png" alt="image-20240829200809097" style="zoom:25%;" /></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202408300840096.png" alt="image-20240830084043785" style="zoom: 50%;" /><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202408300846362.png" alt="image-20240830084623005" style="zoom: 50%;" /><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202408300856449.png" alt="image-20240830085638802" style="zoom: 33%;" /></p>
<p>图1: 二次缓出   图2:二次缓入    图3:parabola   图4:Triangle三角形来回弹跳  图5:Elastic Out弹射起步,会超终点  图6:Bounce Out重力落地方式到终点,弹跳停止到终点 图7:缓入缓出,混合得到smoothstep函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二次缓出</span></span><br><span class="line">float <span class="title function_">f</span>(<span class="params">float t</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">sqrt</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二次缓入</span></span><br><span class="line">float <span class="title function_">f</span>(<span class="params">float t</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> t*t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Quadratic Ease Out  二次缓出 </span></span><br><span class="line">float <span class="title function_">f</span>(<span class="params">float t</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>-(<span class="number">1</span>-x)*(<span class="number">1</span>-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Quadratic Ease Out  二次缓出</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//parabola来回弹跳</span></span><br><span class="line">float <span class="title function_">f</span>(<span class="params">float t,float k</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">pow</span>(<span class="number">4</span>*x*(<span class="number">1</span>-x),k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Triangle来回弹跳</span></span><br><span class="line">float <span class="title function_">f</span>(<span class="params">float t</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>-<span class="number">2</span>*<span class="title function_">abs</span>(x-<span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Elastic Out弹射起步,会超终点</span></span><br><span class="line">float <span class="title function_">f</span>(<span class="params">float t</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">sin</span>(-<span class="number">13</span>*(t+<span class="number">1</span>)*<span class="variable constant_">HALF</span> <span class="variable constant_">PI</span>)*<span class="title function_">pow</span>(<span class="number">2</span>,-<span class="number">10</span>*t)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Bounce Out重力落地方式到终点,弹跳停止到终点</span></span><br><span class="line">float <span class="title function_">f</span>(<span class="params">float t</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> float n1 = <span class="number">7.5625</span>;</span><br><span class="line">  <span class="keyword">const</span> float d1 = <span class="number">2.75</span>;</span><br><span class="line">  <span class="keyword">if</span> (t &lt; <span class="number">1.0</span> / d1) &#123;</span><br><span class="line">    <span class="keyword">return</span> n1 * t * t;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t &lt; <span class="number">2.0</span> / d1) &#123;</span><br><span class="line">    t -= <span class="number">1.5</span> / d1;</span><br><span class="line">    <span class="keyword">return</span> n1 * t * t + <span class="number">0.75</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t &lt; <span class="number">2.5</span> / d1) &#123;</span><br><span class="line">    t -= <span class="number">2.25</span> / d1;</span><br><span class="line">    <span class="keyword">return</span> n1 * t * t + <span class="number">0.9375</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    t -= <span class="number">2.625</span> / d1;</span><br><span class="line">    <span class="keyword">return</span> n1 * t * t + <span class="number">0.984375</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//混合缓入和缓出函数得到 缓入缓出 smoothstep函数</span></span><br><span class="line">float <span class="title function_">f</span>(<span class="params">float t</span>)&#123;</span><br><span class="line">  float v1=t*t;</span><br><span class="line">  float v2=<span class="number">1</span>-(<span class="number">1</span>-t)*(<span class="number">1</span>-t);</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">lerp</span>(v1,v2,t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用场景如</p>
<ul>
<li><p>GPU<strong>采样纹理</strong>时,采用的双线性插值</p>
</li>
<li><p>界面元素采用Bounce函数等<strong>动画</strong>中利用这些变化</p>
</li>
<li><p><strong>缩放</strong>的时候,使用<code>lerp(log(Z0),log(Z1),time)</code>比使用<code>lerp(Z0,Z1,time)</code>更好</p>
</li>
<li><p>对<strong>颜色</strong>进行插值很容易,比方说对蓝色到黄色进行插值,要用线性颜色空间进行插值,最后再转换回RGB空间,得到的渐变效果会更好</p>
<p>线性颜色空间是指在颜色表示中，颜色的数值与人眼对光强度的感知之间是线性关系的颜色空间。在这个空间中，颜色的数值（如 RGB 值）直接对应于物理光强度，这意味着如果一个颜色的数值是另一个颜色的两倍，那么它在视觉上看起来也会是前者的两倍亮度</p>
</li>
<li><p><strong>阻尼</strong></p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//帧数无关的current向target的追踪效果,target是可以变化的</span></span><br><span class="line">K=<span class="number">1</span>-<span class="title function_">pow</span>(K,frameTime)</span><br><span class="line">pos=<span class="title function_">lerp</span>(current,target,k)</span><br></pre></td></tr></table></figure>

<h2 id="样条插值"><a href="#样条插值" class="headerlink" title="样条插值"></a>样条插值</h2><blockquote>
<p>用途:</p>
<ul>
<li>根据数据做预测,或则根据局部情况估计整体分布</li>
<li>图形化呈现计算结果</li>
</ul>
<p>缺点:不能给出明确函数关系,一般用于对数据的概括性描述,从中发现分布特征</p>
<p>样条名词解析:</p>
<p>“样条”这个术语源自于造船业，用来描述在木船的曲线形状中使用的一种柔软且易弯曲的木条。在数学和计算机科学领域，”样条”被引入用来描述一种平滑且连续的插值函数。因此，”样条插值”指的是通过连接相邻数据点的一系列曲线段来逼近数据的插值方法，以实现平滑的曲线拟合。 在样条插值中，通常会使用多项式函数来拟合相邻数据点之间的曲线段，以确保在数据点处函数值的连续性和平滑性。样条插值方法在数据处理、图像处理和数值分析等领域广泛应用，可以有效地处理数据的平滑和插值问题。</p>
</blockquote>
<p>不用给出具体的函数关系,根据已有数据预测其他数据即可的情况可以使用<strong>样条插值算法</strong></p>
<p>根据实际应用对于“平滑”的要求，通常会有以下不同的约束：</p>
<ol>
<li>要求生成的参考曲线是连续的；</li>
<li>在1的基础上，要求参考曲线的速度是连续的；</li>
<li>在1和2的基础上，要参考曲线的加速度是连续的；</li>
</ol>
<blockquote>
<p>速度是位置对时间的导数，加速度是速度对时间的导数，加速度对时间的导数我们称之为jerk。</p>
</blockquote>
<p>在多项式插值里面，给定多项式的阶次越高，能拟合的函数曲线就越复杂，但越高阶次的多项式对于计算资源的要求越多。因此对于这3个要求，我们可以分别用不同阶次的多项式函数来拟合，实际应用时根据需求选择合适的方法。</p>
<blockquote>
<p>下面的公式讲解如下:$a_0$,$a_1$是待确定的常量参数。$t_0$表示初始时刻， $a_0$表示初始时刻的位置， $a_1$表示斜率，也就是速度，这里为常量。因此，给定下一个时刻 $t_1$处的位置 q($t_1$), $t_f$表示分割点时间</p>
</blockquote>
<ol>
<li><p>线性插值（一阶，恒定速度）</p>
<p>线性插值，顾名思义，就是使用线性的方法来进行插值。即将给定的数据点依次用线段连起来，点与点之间运动的速度是恒定值。<br>$$<br>q(t)&#x3D;a_0+a_1(t-t_0)<br>$$<br>得出常数为:<br>$$<br>\left{\begin{array}{l}a_0&#x3D;q_0\a_1&#x3D;(q_1-q_0)&#x2F;(t_1-t_0)\end{array}\right.<br>$$</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202404230830700.png" alt="image-20240423082957322" style="zoom:33%;" />

<p>以C#代码为例,给出线性插值的代码如下:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">double</span>[] <span class="title">Interpolate</span>(<span class="params">List&lt;<span class="built_in">double</span>&gt; source, <span class="built_in">int</span> targetLength</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">double</span>[] result = <span class="keyword">new</span> <span class="built_in">double</span>[targetLength];</span><br><span class="line">    <span class="built_in">double</span> step = (<span class="built_in">double</span>)(source.Count - <span class="number">1</span>) / (targetLength - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; targetLength; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      	<span class="comment">//result序列中第i个点对应的source原始序列中的下标:index</span></span><br><span class="line">        <span class="built_in">double</span> index = i * step;</span><br><span class="line">      	<span class="comment">//整数部分</span></span><br><span class="line">        <span class="built_in">int</span> indexInt = (<span class="built_in">int</span>)index;</span><br><span class="line">      	<span class="comment">//小数部分</span></span><br><span class="line">        <span class="built_in">double</span> frac = index - indexInt;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (indexInt + <span class="number">1</span> &lt; source.Count)</span><br><span class="line">        &#123;</span><br><span class="line">          	<span class="comment">//线性插值的关键体现</span></span><br><span class="line">          	<span class="comment">//result[i] 是在 indexInt 和 indexInt + 1 之间进行线性插值计算的值</span></span><br><span class="line">          	<span class="comment">//	frac = 0时，目标位置在indexInt。</span></span><br><span class="line">            result[i] = source[indexInt] * (<span class="number">1</span> - frac) + source[indexInt + <span class="number">1</span>] * frac;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          	<span class="comment">// 如果 indexInt 已经是最后一个索引，直接取其值</span></span><br><span class="line">            result[i] = source[indexInt];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//针对二维点的线性插值</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 生成指定个数的线性插值点</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>插值点的列表<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;ObservablePoint&gt; <span class="title">GenerateLinearInterpolationPoints</span>(<span class="params"><span class="built_in">double</span> x0, <span class="built_in">double</span> y0, <span class="built_in">double</span> x1, <span class="built_in">double</span> y1, <span class="built_in">int</span> numberOfPoints</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (x1 == x0)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">&quot;x0 和 x1 不能相同。&quot;</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;ObservablePoint&gt; points = <span class="keyword">new</span> List&lt;ObservablePoint&gt;();</span><br><span class="line">    <span class="built_in">double</span> step = (x1 - x0) / (numberOfPoints + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= numberOfPoints; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">double</span> x = x0 + i * step;</span><br><span class="line">        <span class="built_in">double</span> y = y0 + (y1 - y0) * (x - x0) / (x1 - x0);</span><br><span class="line">        points.Add(<span class="keyword">new</span> ObservablePoint(x, y));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> points;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>权重来看(这两边权重很容易理解反!)</p>
<ul>
<li>左侧整数位置的权重：<code>1 - frac（越靠近左侧位置，权重越大）</code></li>
<li>右侧整数位置的权重：<code>frac</code>（越靠近右侧位置，权重越大）</li>
</ul>
</li>
<li><p>抛物线插值（二阶，恒定加速度）</p>
<p>抛物线差值（Parabolic Spline）是二阶多项式插值方法。与线性插值法将各个数据点用线段连起来不同，抛物线插值方法是用二次曲线将各个数据点连接起来，在连接处使用平滑的曲线来过渡，而避免速度不连续导致的“急剧拐弯”。抛物线差值的特征是具有恒定的加速度&#x2F;减速度，一般是由两个二阶多项式的组合来得到。为什么是两个二阶多项式呢？因为一个用于“加速阶段”，一个用于“减速阶段”。“加速阶段”和“减速阶段”的分割点叫flex point。</p>
<ul>
<li><p>加速阶段<br>$$<br>q_a(t)&#x3D;a_0+a_1(t-t_0)+a_2(t-t_0)^2,\quad t\in[t_0,t_f]<br>$$</p>
</li>
<li><p>减速阶段<br>$$<br>q_b(t)&#x3D;a_3+a_4\left(t-t_f\right)+a_5\left(t-t_f\right)^2\quad t\in[t_f,t_1]<br>$$</p>
</li>
<li></li>
</ul>
<p>常数公式略</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202404230830917.png" alt="image-20240423083052298" style="zoom:33%;" />
</li>
<li><p>三次多项式插值（三阶，加速度可变）</p>
<p>三次多项式插值方法（Cubic Spline）是一种常用的插值方法，其位置和速度曲线是连续的，加速度是可变的，但加速度不一定连续。考虑2个数据点之间插值的情况，其数学表达式为：<br>$$<br>q(t)&#x3D;a_0+a_1\left(t-t_0\right)+a_2(t-t_0)^2+a_3(t-t_0)^3,\quad t_0\leq t\leq t_1<br>$$<br>两种计算情况</p>
<ul>
<li><p>给定了初始时刻$t_0$和最终时刻$t_1$处的位置与速度信息($q_0,q_1,v_0,v_1$),设$h&#x3D;q_1-q_0,T&#x3D;t_1-t_0$,则参数可以使用一下公式计算:<br>$$<br>\left.\left{\begin{array}{l}a_0&#x3D;q_0\a_1&#x3D;\mathrm{v}_0\a_2&#x3D;\frac{3h-(2\mathrm{v}_0+\mathrm{v}_1)T}{T^2}\a_3&#x3D;\frac{-2h+(\mathrm{v}_0+\mathrm{v}_1)T}{T^3}.\end{array}\right.\right.<br>$$<br>对于给定 n 个一系列数据点进行插值的情况，只需要对所有相邻的两个数据点使用上述公式即可依次计算得到整条插值曲线。</p>
</li>
<li><p>给定了每一个点的位置信息$(\begin{array}{c}q_0,q_1,\ldots,q_n\end{array})$,但中间点的速度未给定</p>
<p>这种情况,整条曲线最开始的起点和最终的终点速度需要直接给定，一般为零,$v_0&#x3D;v_1&#x3D;0$.中间各个数据点的速度可以通过启发式方法得到，即通过求解位置对时间的导数得到，那么对于第k个中间点，我们有：<br>$$<br>\left.v_k&#x3D;\left{\begin{array}{ll}0,\quad sign(d_k)\neq sign(d_{k+1})\\frac12(d_k+d_{k+1}),\quad sign(d_k)&#x3D;sign(d_{k+1})\end{array}\right.\right.<br>$$<br>其中$d_k&#x3D;(q_k-q_{k-1})&#x2F;(t_k-t_{k-1})$,表示曲线的导数或斜率,sign()为符号函数,返回1或-1</p>
<blockquote>
<p>直观理解:考察第k个数据点,若其导数在该点进行了符号反转,则该点速度为0,否则该点速度为其导数</p>
</blockquote>
</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202404230831975.png" alt="image-20240423083157317" style="zoom:33%;" />

<p>可以看到，位置曲线是“平滑”的，速度曲线是连续的，加速度曲线是可变的，但是不连续。这样，对于高速控制的场合来说，控制器的输入仍然会存在阶跃，导致不连续的情况。</p>
</li>
<li><p>五次多项式插值（五阶，加速度连续）</p>
<p>略,<a target="_blank" rel="noopener" href="https://www.zhihu.com/tardis/zm/art/269230598?source_id=1005">更多详情参考此处</a></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202404230836012.png" alt="image-20240423083602333" style="zoom:33%;" />

<p>可以看出，位置、速度、加速度三条曲线都是连续的，并且位置和速度还是“平滑”的,如果加速度曲线也要求是平滑的，那么就需要更高阶次的多项式插值方法了，例如七阶多项式插值。</p>
</li>
<li><p>七次及更高阶次的多项式插值</p>
</li>
</ol>
<p>各种方法插值的对比图</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202404230839844.png" alt="image-20240423083925159" style="zoom:33%;" />

<p><a target="_blank" rel="noopener" href="https://github.com/chauby/PolynomialInterpolation">相关开源代码Python及Matlab的Github仓库</a></p>
<p>n次拉格朗日插值多项式:  太复杂,但能推出一个统一的多项式</p>
<p>分段线性插值:  针对每两个点,分段进行线性插值</p>
<p><strong>三次样条插值</strong>的Matlab语法</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#matlab语法</span><br><span class="line">interp1(x0,y0,x,<span class="string">&#x27;spline&#x27;</span>)</span><br><span class="line">#或</span><br><span class="line">spline(x0,y0,x)</span><br></pre></td></tr></table></figure>

<p><strong>分段三次多项式插值</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202404221417951.png" alt="image-20240422141726395" style="zoom:50%;" />

<h2 id="拉格朗日算法"><a href="#拉格朗日算法" class="headerlink" title="拉格朗日算法"></a>拉格朗日算法</h2><h2 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1YQCvYTEmT/">参考视频</a></p>
<p><a target="_blank" rel="noopener" href="https://math.hws.edu/eck/cs424/notes2013/canvas/bezier.html">在线尝试贝塞尔曲线</a></p>
<p>线性插值如下:<br>$$<br>\operatorname{lerp}(a, b, t)&#x3D;(1-t) a+t b<br>$$<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202501231118343.gif" alt="一次贝塞尔曲线演示.gif" style="zoom:67%;" /></p>
<p>用于描述一个点在两点之间的移动轨迹,实际上就是个<a href="#%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC">线性插值算法</a></p>
<p>二阶贝塞尔曲线</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202501231031610.webp" alt="动图"></p>
<p>这里的 P0、P1、P2 分别称之为<strong>控制点</strong>，贝塞尔曲线的产生<strong>完全</strong>与这三个点<strong>位置</strong>相关。</p>
<p>三个匀速前进的点(各自速度不同),分别是沿着P0到P1,P1到P2,以及沿着绿色线前进,同时从起点出发,同时到达终点</p>
<p>三阶贝塞尔曲线</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202501231036765.webp" alt="动图"></p>
<p>四阶贝塞尔曲线</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202501231036785.webp" alt="动图"></p>
<p>贝塞尔曲线可以由阶数递归定义</p>
<p>这也就意味着，<strong>我们可以通过调节控制点的位置，进而调整整个曲线。</strong></p>
<h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202501231049154.png" alt="image-20250123104911983" style="zoom: 25%;" />

<p>通过递归地应用lerp函数可以实现任意阶数的贝塞尔曲线 </p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> Point</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> X &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Y &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span>(<span class="params"><span class="built_in">double</span> x, <span class="built_in">double</span> y</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        X = x;</span><br><span class="line">        Y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Point <span class="title">Lerp</span>(<span class="params">Point P0, Point P1, <span class="built_in">double</span> t</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">double</span> x = (<span class="number">1</span> - t) * P0.X + t * P1.X;</span><br><span class="line">    <span class="built_in">double</span> y = (<span class="number">1</span> - t) * P0.Y + t * P1.Y;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Point(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Point RecursiveBézier(List&lt;Point&gt; points, <span class="built_in">double</span> t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果只有一个点，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (points.Count == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> points[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对相邻控制点进行线性插值</span></span><br><span class="line">    List&lt;Point&gt; newPoints = <span class="keyword">new</span> List&lt;Point&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; points.Count - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        newPoints.Add(Lerp(points[i], points[i + <span class="number">1</span>], t));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归调用，处理新的点列表</span></span><br><span class="line">    <span class="keyword">return</span> RecursiveBézier(newPoints, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;Point&gt; GenerateBézierCurve(List&lt;Point&gt; controlPoints, <span class="built_in">double</span> step)</span><br><span class="line">&#123;</span><br><span class="line">    List&lt;Point&gt; curvePoints = <span class="keyword">new</span> List&lt;Point&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对每个 t 值生成一个点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">double</span> t = <span class="number">0</span>; t &lt;= <span class="number">1</span>; t += step)</span><br><span class="line">    &#123;</span><br><span class="line">        Point point = RecursiveBézier(controlPoints, t);</span><br><span class="line">        curvePoints.Add(point);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> curvePoints;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用方式</span></span><br><span class="line">List&lt;Point&gt; controlPoints = <span class="keyword">new</span> List&lt;Point&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">new</span> Point(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">    <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">    <span class="keyword">new</span> Point(<span class="number">3</span>, <span class="number">3</span>),</span><br><span class="line">    <span class="keyword">new</span> Point(<span class="number">4</span>, <span class="number">0</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">List&lt;Point&gt; bezierCurve = GenerateBézierCurve(controlPoints, <span class="number">0.01</span>); <span class="comment">// 生成贝塞尔曲线</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//更简洁的版本</span></span><br><span class="line">cv::<span class="function">Point2f <span class="title">recursive_bezier</span>(<span class="params"><span class="keyword">const</span> std::vector&lt;cv::Point2f&gt; &amp;control_points, <span class="built_in">float</span> t</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Implement de Casteljau&#x27;s algorithm</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(control_points.size() == <span class="number">1</span>) <span class="keyword">return</span> control_points[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    std::vector&lt;cv::Point2f&gt; a;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i+<span class="number">1</span> &lt; control_points.size();i ++) &#123;</span><br><span class="line">        auto p = control_points[i] + t * (control_points[i+<span class="number">1</span>] - control_points[i]);</span><br><span class="line">        a.push_back(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> recursive_bezier(a, t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Lerp 方法</strong>：</p>
<p>这个方法通过两个点和一个参数 t 来计算它们之间的线性插值。</p>
<p><strong>RecursiveBézier 方法</strong>：</p>
<p>这个方法会逐步对相邻的控制点进行插值，直到只剩下一个点。对于每个递归调用，我们会生成一个新的控制点列表，其中每个新的控制点都是相邻原始点之间的线性插值。</p>
<p><strong>GenerateBézierCurve 方法</strong>：</p>
<p>这个方法遍历 t 的值（从 0 到 1），并调用 RecursiveBézier 来生成贝塞尔曲线上的点。通过调整 step 的大小，你可以控制贝塞尔曲线的精度。</p>
<p>还有公式实现法,效率更高,<a target="_blank" rel="noopener" href="https://www.cnblogs.com/zbyisgudi/p/18284215">公式推导参考</a></p>
<p>使用公式实现的算法,暂略</p>
<h3 id="分段贝塞尔曲线"><a href="#分段贝塞尔曲线" class="headerlink" title="分段贝塞尔曲线"></a>分段贝塞尔曲线</h3><p>虽然贝塞尔曲线的阶数可以很高，但是如果曲线的阶数过高，调整控制点对曲线的影响就比较小，调整起来相当麻烦。因此常常使用分段的贝塞尔曲线来保证每一小段不会太复杂</p>
<p>分段带来的唯一问题是，<strong>曲线在段与段的交界处，如何保证平滑？</strong></p>
<blockquote>
<p>所谓平滑，其实就是一阶导数连续(导数的值不会出现突变（跳跃）或不连续的情况)，也就是左右导数的极限相同。</p>
</blockquote>
<p>对两侧的贝塞尔曲线求导，分别代入 t&#x3D;0 和 t&#x3D;1 （即贝塞尔曲线的开始和结束时间），让二者相等。此时能发现，当两侧控制点与分段交接点<strong>共线且</strong>形成的线段<strong>长度相等</strong>时，满足曲线平滑性质。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202501231130784.png" alt="image-20250123113051628" style="zoom: 33%;" />

<h1 id="曲线相关算法"><a href="#曲线相关算法" class="headerlink" title="曲线相关算法"></a>曲线相关算法</h1><h2 id="曲线平滑"><a href="#曲线平滑" class="headerlink" title="曲线平滑"></a>曲线平滑</h2><p><a href="#%E6%A0%B7%E6%9D%A1%E6%8F%92%E5%80%BC">样条插值算法</a>就可以作为一种曲线平滑算法</p>
<h3 id="圆角平滑算法"><a href="#圆角平滑算法" class="headerlink" title="圆角平滑算法"></a>圆角平滑算法</h3><p>圆的曲率为半径的倒数,直线的曲率为0</p>
<p>在二维空间中，曲线的曲率可以通过其切线的变化率来定义。具体来说，曲率 ( k ) 可以表示为：<br>$$<br>k &#x3D; \frac{d\theta}{ds}<br>$$<br>其中 ( $\theta$ ) 是切线的角度,( $s$ ) 是沿着曲线的弧长。</p>
<p> 在三维空间中，曲面的曲率通常用高斯曲率和平均曲率等来描述，这些曲率量化了曲面在不同方向上的弯曲程度。</p>
<blockquote>
<p>在曲率的圆角设计中，G1、G2 和 G3 是用于描述曲线连接的几何连续性标准。这些标准通常用于 CAD（计算机辅助设计）和计算机图形学中，以确保曲线或曲面的平滑连接。具体来说：</p>
<ol>
<li><p><strong>G1 连接（一次连续性）</strong>：</p>
<ul>
<li>G1 连接要求在连接的两个曲线或曲面之间具有相同的端点位置，并且在该点的切线方向相同。换句话说，G1 连接确保了曲线在连接点处是连续的，但可能会有角度的突变。这种连接适用于对平滑度要求不高的情况。</li>
</ul>
</li>
<li><p><strong>G2 连接（二次连续性）</strong>：</p>
<ul>
<li>G2 连接不仅要求连接的曲线在端点位置相同，而且要求在连接点的切线方向（即一阶导数）也相同。这意味着在连接点处，曲线的斜率是连续的，从而提供了更高的平滑度。G2 连接适用于需要更高平滑度的设计。</li>
</ul>
</li>
<li><p><strong>G3 连接（三次连续性）</strong>：</p>
<ul>
<li>G3 连接要求在连接点处，不仅切线方向相同（G2），而且切线的变化率（即二阶导数）也相同。这意味着在连接点处，曲线的加速度也是连续的，从而提供了最高级别的平滑度。G3 连接通常用于对光滑度要求极高的应用，比如高端工业设计和汽车外观设计。</li>
</ul>
</li>
</ol>
</blockquote>
<p>G1,G2,G3对比:</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202408312048234.png" alt="image-20240831204857495" style="zoom: 33%;" />

<p>G2的问题如下:</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202408312047356.png" alt="image-20240831204719797" style="zoom: 33%;" />

<p>下图蓝底为G1平滑,黄色为G3平滑</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202408312045696.png" alt="image-20240831204551549"></p>
<p>苹果的圆角设计为G3圆角,是一种看起来更自然更舒服的圆角</p>
<h3 id="超椭圆"><a href="#超椭圆" class="headerlink" title="超椭圆"></a>超椭圆</h3><p>小米的logo设计利用的是超椭圆公式,适合用于做logo底图</p>
<p>超椭圆公式:<br>$$<br>|x|^{n}+|y|^{n}&#x3D;1<br>$$<br>超椭圆也称为拉梅曲线，<br>是在笛卡尔坐标系下满足以下方程式的点的集合。</p>
<ul>
<li>n&#x3D;2时:该曲线就是圆的曲线</li>
<li>n&gt;2时:圆角矩形(小米logo的轮廓就是n为3时的超椭圆)</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202408312054792.png" alt="image-20240831205456139" style="zoom:50%;" />

<h2 id="曲线相似算法"><a href="#曲线相似算法" class="headerlink" title="曲线相似算法"></a>曲线相似算法</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/384362352">曲线相似算法盘点参考</a></p>
<p><a href="#%E5%8A%A8%E6%80%81%E6%97%B6%E9%97%B4%E5%BD%92%E6%95%B4">动态时间归整算法</a>也可以作为曲线相似算法</p>
<h3 id="Frechet距离算法"><a href="#Frechet距离算法" class="headerlink" title="Fréchet距离算法"></a>Fréchet距离算法</h3><p>弗雷歇距离（Fréchet Distance）是一种用于测量两条曲线或路径之间相似性的距离度量，由法国数学家<a target="_blank" rel="noopener" href="http://www.nndb.com/people/481/000202872/">Maurice René Fréchet</a>在1906年提出的一种路径空间相似形描述(此外还在这篇论文里定义了 度量空间)，这种描述同时还考虑进路径空间距离的因素,广泛应用于计算机科学、图形学、地理信息系统等领域。与传统的欧几里德距离不同，Fréchet距离不仅考虑曲线上的点对点距离，还考虑曲线的形状和走向。</p>
<blockquote>
<p>Fréchet距离是一种强大的曲线相似性度量方法，通过考虑曲线的形状和走向，能够更精确地衡量两条曲线之间的相似性。在实际应用中，可以通过动态规划等方法来计算该距离，并结合修正值处理数值计算中的不精确性。尽管计算复杂度较高，但在需要<strong>精确比较曲线</strong>的场景中，Fréchet距离具有无可替代的重要性。</p>
<p>应用场景</p>
<ul>
<li><p><strong>计算机图形学</strong>：用于比较和对齐曲线、形状匹配。</p>
</li>
<li><p><strong>地理信息系统</strong>：用于路径比较、轨迹相似性分析，如分析动物迁徙路径或车辆行驶轨迹。</p>
</li>
<li><p><strong>模式识别和机器学习</strong>：用于时间序列分析、手写字符识别等。</p>
</li>
<li><p>优点</p>
<ul>
<li>能够有效地比较曲线的形状和几何特征</li>
<li>考虑了曲线的连续性和走向，适合路径和轨迹比较</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>计算复杂度较高，特别是在处理高维数据时</li>
<li>动态规划方法在处理大规模数据时可能会消耗大量内存和计算资源</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="计算方式"><a href="#计算方式" class="headerlink" title="计算方式"></a>计算方式</h4><ol>
<li><p>将连续的曲线离散化为一系列点集。这一步是将曲线(P)和(Q)分别用一组离散点表示</p>
</li>
<li><p>构建距离矩阵(D)</p>
<p>距离矩阵(D)的元素(D(i, j))表示曲线(P)上第i个点$(P_i)$和曲线(Q)上第j个点$(Q_j)$之间的欧几里德距离$D(i, j)&#x3D; | P_i - Q_j |$</p>
</li>
<li><p><a href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9F%A9%E9%98%B5%E7%9A%84%E5%A1%AB%E5%85%85%E6%AD%A5%E9%AA%A4">动态规划矩阵(C)的初始化与填充</a></p>
</li>
<li><p>最终矩阵(C)的右下角元素(C(n-1, m-1))即为曲线(P)和曲线(Q)之间的Fréchet距离</p>
</li>
</ol>
<h5 id="动态规划矩阵的填充步骤"><a href="#动态规划矩阵的填充步骤" class="headerlink" title="动态规划矩阵的填充步骤"></a>动态规划矩阵的填充步骤</h5><p>动态规划矩阵(C)的尺寸与距离矩阵(D)相同，大小为 $n \times m$ ,其中(n)和(m)分别是曲线(P)和曲线(Q)的离散点数。<br>初始条件：$C(0, 0) &#x3D; D(0, 0)$ ,表示从(P)和(Q)的起点出发时的距离</p>
<ul>
<li><p>对于第一行和第一列<br>$$<br>C(i, 0) &#x3D; \max(C(i-1, 0), D(i, 0)) \quad \forall i \geq 1<br>$$</p>
<p>$$<br>C(0, j) &#x3D; \max(C(0, j-1), D(0, j)) \quad \forall j \geq 1<br>$$</p>
</li>
<li><p>对于其他,使用如下递推公式<br>$$<br>C(i, j) &#x3D; \max\left( D(i, j), \min\left( C(i-1, j), C(i, j-1), C(i-1, j-1) \right) \right)<br>$$</p>
</li>
</ul>
<p>解释上述公式：</p>
<ul>
<li>$D(i, j)$是曲线(P)上的第(i)个点和曲线(Q)上的第(j)个点之间的欧几里德距离。</li>
<li>$\min(C(i-1, j), C(i, j-1), C(i-1, j-1))$表示从之前的状态转移到当前状态的最小Fréchet距离。</li>
<li>$\max$确保当前状态的Fréchet距离考虑了当前点之间的距离。</li>
</ul>
<p>这样计算的每一步都确保了Fréchet距离考虑了曲线上的所有点对点距离，同时保持了路径的连贯性和正确性。</p>
<p>通过动态规划的方法，我们逐步计算和记录了从曲线起点到各个点之间的Fréchet距离，确保考虑到曲线的全局形状和相似性。这种方法在理论上和实际应用中都被证明是有效的。</p>
<h5 id="动态规划表格的实际构建演示"><a href="#动态规划表格的实际构建演示" class="headerlink" title="动态规划表格的实际构建演示"></a>动态规划表格的实际构建演示</h5><p>下面是一个示例，假设我们有两个离散化的曲线(P)和(Q )，它们的点集分别为(P &#x3D; {P_0, P_1, P_2})和(Q &#x3D; {Q_0, Q_1} )，对应的距离矩阵(D)和动态规划矩阵(C)的构建过程如下：</p>
<ol>
<li><p>计算距离矩阵(D)</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202405241006131.png" alt="image-20240524100628238" style="zoom:33%;" />
</li>
<li><p>初始化动态规划矩阵(C)</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202405241012488.png" alt="image-20240524101251182" style="zoom:33%;" />
</li>
<li><p>填充第一行和第一列</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202405241007909.png" alt="image-20240524100722459" style="zoom:33%;" />
</li>
<li><p>使用递推公式填充其余部分<br>$$<br>C(1, 1) &#x3D; \max(D(1, 1), \min(C(0, 1), C(1, 0), C(0, 0)))<br>$$</p>
<p>$$<br>C(2, 1) &#x3D; \max(D(2, 1), \min(C(1, 1), C(2, 0), C(1, 0)))<br>$$</p>
</li>
<li><p>最终,我们得到填充完的动态规划矩阵(C)</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202405241007091.png" alt="image-20240524100742656" style="zoom:33%;" />
</li>
<li><p>最终得到曲线(P)和(Q)的Fréchet距离为<strong>C(2,1)</strong></p>
</li>
</ol>
<h3 id="递归实现代码案例"><a href="#递归实现代码案例" class="headerlink" title="递归实现代码案例"></a>递归实现代码案例</h3><p>这个代码可以计算元素个数不同的两个序列的相似度</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。</span></span><br><span class="line">    <span class="comment">//本文链接：https://blog.csdn.net/pz789as/article/details/52701371</span></span><br><span class="line">    <span class="comment">//————————————————</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 计算两段曲线的Frechet距离，作为判断曲线相似的依据</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 计算的值越小，说明这两段曲线越相似</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Frechet</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 使用该函数得到Frechet距离最终结果</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;xArray1&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;yArray1&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;xArray2&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;yArray2&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">double</span> <span class="title">Calc</span>(<span class="params">List&lt;<span class="built_in">double</span>&gt; xArray1, List&lt;<span class="built_in">double</span>&gt; yArray1, List&lt;<span class="built_in">double</span>&gt; xArray2, List&lt;<span class="built_in">double</span>&gt; yArray2</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">double</span>[,] matrix = InitMatrix(xArray1.Count, xArray2.Count);</span><br><span class="line">            <span class="keyword">return</span> CalcFrechetDistance(xArray1, yArray1, xArray2, yArray2, matrix, xArray1.Count - <span class="number">1</span>, xArray2.Count - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 计算两个节点之间的欧式距离</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;x1&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;y1&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;x2&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;y2&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">double</span> <span class="title">CalcPointDistanceF</span>(<span class="params"><span class="built_in">double</span> x1, <span class="built_in">double</span> y1, <span class="built_in">double</span> x2, <span class="built_in">double</span> y2</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.Sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">double</span>[,] InitMatrix(<span class="built_in">int</span> line1Count, <span class="built_in">int</span> line2Count)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">double</span>[,] matrix = <span class="keyword">new</span> <span class="built_in">double</span>[line1Count, line2Count];</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; line1Count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; line2Count; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    matrix[i, j] = <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> matrix;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">double</span> <span class="title">CalcFrechetDistance</span>(<span class="params">List&lt;<span class="built_in">double</span>&gt; xArray1, List&lt;<span class="built_in">double</span>&gt; yArray1, List&lt;<span class="built_in">double</span>&gt; xArray2, List&lt;<span class="built_in">double</span>&gt; yArray2, <span class="built_in">double</span>[,] matrix, <span class="built_in">int</span> i, <span class="built_in">int</span> j</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i, j] &gt; <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> matrix[i, j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                matrix[i, j] = CalcPointDistanceF(xArray1[<span class="number">0</span>], yArray1[<span class="number">0</span>], xArray2[<span class="number">0</span>], yArray2[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                matrix[i, j] = Math.Max(CalcFrechetDistance(xArray1, yArray1, xArray2, yArray2, matrix, i - <span class="number">1</span>, <span class="number">0</span>), CalcPointDistanceF(xArray1[i], yArray1[i], xArray2[<span class="number">0</span>], yArray2[<span class="number">0</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                matrix[i, j] = Math.Max(CalcFrechetDistance(xArray1, yArray1, xArray2, yArray2, matrix, <span class="number">0</span>, j - <span class="number">1</span>), CalcPointDistanceF(xArray1[<span class="number">0</span>], yArray1[<span class="number">0</span>], xArray2[j], yArray2[j]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">double</span> distance1 = CalcFrechetDistance(xArray1, yArray1, xArray2, yArray2, matrix, i - <span class="number">1</span>, j);</span><br><span class="line">                <span class="built_in">double</span> distance2 = CalcFrechetDistance(xArray1, yArray1, xArray2, yArray2, matrix, i - <span class="number">1</span>, j - <span class="number">1</span>);</span><br><span class="line">                <span class="built_in">double</span> distance3 = CalcFrechetDistance(xArray1, yArray1, xArray2, yArray2, matrix, i, j - <span class="number">1</span>);</span><br><span class="line">                <span class="built_in">double</span> pDistance = CalcPointDistanceF(xArray1[i], yArray1[i], xArray2[j], yArray2[j]);</span><br><span class="line">                matrix[i, j] = Math.Max(Math.Min(Math.Min(distance1, distance2), distance3), pDistance);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                matrix[i, j] = <span class="built_in">double</span>.MaxValue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> matrix[i, j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="曲线抽稀"><a href="#曲线抽稀" class="headerlink" title="曲线抽稀"></a>曲线抽稀</h2><blockquote>
<p>在处理矢量化数据时，记录中往往会有很多重复数据，对进一步数据处理带来诸多不便。多余的数据一方面浪费了较多的存储空间，另一方面造成所要表达的图形不光滑或不符合标准。因此要通过某种规则，在保证矢量曲线形状不变的情况下， 最大限度地减少数据点个数，这个过程称为抽稀。</p>
</blockquote>
<p>通俗的讲就是对曲线进行采样简化，即在曲线上取有限个点，将其变为折线，并且能够在一定程度保持原有形状。比较常用的两种抽稀算法是：</p>
<ul>
<li><a href="#Douglas-Peucker%E7%AE%97%E6%B3%95">道格拉斯-普克(Douglas-Peuker)算法</a>  效率更高,主流做法</li>
<li><a href="#%E5%9E%82%E8%B7%9D%E9%99%90%E5%80%BC%E6%B3%95">垂距限值法</a></li>
</ul>
<p><strong>优劣</strong></p>
<ul>
<li>对简化精度要求较高且数据量不大，垂距限值法可能更合适；</li>
<li>对于大规模数据或需要快速处理的情况，Douglas-Peucker算法则更为优越。</li>
</ul>
<p>阈值越高,抽稀后越平滑</p>
<p>除了这两套算法外,还有如下方式:</p>
<ol>
<li><p>基于时间间隔的抽稀：</p>
<p>如果你的数据是基于时间产生的，使用一定的时间窗口对数据进行采样。例如，每1秒显示一个数据点。当数据增加到一定程度时，你可以调整窗口，增加每次采样的时间间隔（比如从1秒变成5秒）。这样可以避免在图表上显示过多数据点。</p>
</li>
<li><p>基于像素密度的抽稀：</p>
<p>对于每个像素宽度，只保留一个数据点。可以通过计算当前图表宽度上的像素数，并动态调整你显示的数据点数量。比如当图表只有100个像素宽时，你可以从原始数据中选择100个代表性点。</p>
</li>
<li><p>Douglas-Peucker算法:</p>
<p>该算法用于线简化，通过去除不重要的点来减少数据。Douglas-Peucker算法会从一条折线中移除那些不会显著改变曲线形状的点，从而降低点的密度。适合用于有曲线的图表。</p>
</li>
<li><p>指数采样：</p>
<p>根据数据点的数量，使用指数抽稀策略。比如，当数据点少于100个时，保持全部显示。当数据点超过100个时，只显示每2个数据点中的一个；当数据点超过1000时，显示每4个数据点中的一个，依此类推。</p>
<ul>
<li><p>关键点保留策略</p>
<p>在进行抽稀时，确保保留关键点，例如局部极值点（峰值和谷值）、转折点或数据斜率变化剧烈的点。这可以通过检测局部变化来实现，如果某点相对于前后的点有明显的变化，标记它为关键点并保留。比如使用二阶差分或曲率判断是否为关键点。</p>
</li>
<li><p>Douglas-Peucker算法（线简化算法）</p>
<p>该算法通过递归划分折线，保留那些对线条形状影响较大的点，并删除对整体形状影响较小的点。这有助于保持数据的形状特征，同时减少点数。Douglas-Peucker算法的优点是可以通过调整容差来控制抽稀后的精度。</p>
</li>
<li><p>自适应采样</p>
<p>根据数据的变化速率或斜率来调整采样频率。在平滑或变化较慢的区域，可以稀疏采样，而在数据变化剧烈的区域，保留更多的点。例如，当检测到数据变化较大时，动态减少抽稀的频率，确保保留细节。</p>
</li>
<li><p>多分辨率展示</p>
<p>保持多层次的数据抽样结果。例如，绘制时可以使用较稀疏的抽样数据来保证性能，而在用户缩放或平移到某个区域时，动态加载和显示该区域的详细数据。这样可以在保证整体形状的同时，提供详细的局部信息。</p>
</li>
<li><p>滑动窗口平滑法</p>
<p>在保留原始数据点形状的基础上，你可以在抽稀过程中应用滑动窗口平滑法。这种方法能够保留整体形态，并减少噪声引起的小幅波动。滑动窗口可以随着数据点的密度自适应调整大小。</p>
</li>
<li><p>保留首尾点</p>
<p>在抽稀过程中，始终保留数据的起点和终点，确保曲线的整体趋势不会丢失。这有助于在大幅抽稀的情况下保持数据的宏观走势。</p>
</li>
</ul>
</li>
<li><p>窗口缩放：</p>
<p>如果你的图表支持平移和缩放功能，可以让用户通过缩放来查看更多细节。当缩小时，显示较少的数据点，而当放大时，展示更多的原始数据。</p>
</li>
<li><p>动态抽样比例调整：</p>
<p>根据图表的渲染性能动态调整抽稀比例。可以定期测量绘制速度和响应时间，如果发现绘制过慢，就增加抽稀率。这样保证在不同设备上都能有流畅的绘图体验。</p>
</li>
</ol>
<h3 id="Douglas-Peucker算法"><a href="#Douglas-Peucker算法" class="headerlink" title="Douglas-Peucker算法"></a>Douglas-Peucker算法</h3><p>道格拉斯普克(Douglas-Peuker)算法(通常简称为 DP 算法）是一种用于曲线抽稀（简化曲线）的方法,是线状要素抽稀的经典算法。用它处理大量冗余的几何数据点，既可以达到数据量精简的目的，又可以在很大程度上保留几何形状的骨架。</p>
<p>Douglas-Peucker 算法的步骤通常如下：</p>
<ol>
<li>连接曲线首尾两点A、B；</li>
<li>依次计算曲线上所有点到A、B两点所在曲线的距离(即作垂线,垂线的长短)；</li>
<li>计算最大距离D，如果D小于阈值threshold,则去掉曲线上除A、B外的所有点；如果D大于阈值threshold,则把曲线以最大距离分割成两段；</li>
<li>对所有曲线分段重复1-3步骤，直到所有D均小于阈值。即完成抽稀</li>
</ol>
<p>这种算法的<strong>抽稀精度与阈值有很大关系，阈值越大，简化程度越大，点减少的越多；反之简化程度越低，点保留的越多，形状也越趋于原曲线。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202410151459784.gif" alt="流程"></p>
<blockquote>
<p>此处附一个计算点到直线距离的代码:   [[数学#点到直线的距离|数学推导参考此处]]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span> <span class="comment">// 包含 sqrt 和 fabs 函数</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算点 C(x3, y3) 到直线 AB 的距离</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">pointToLineDistance</span><span class="params">(<span class="type">double</span> x1, <span class="type">double</span> y1, <span class="type">double</span> x2, <span class="type">double</span> y2, <span class="type">double</span> x3, <span class="type">double</span> y3)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算直线 AB 的参数 A, B, C</span></span><br><span class="line">    <span class="type">double</span> A = y2 - y1; <span class="comment">// 直线的 A</span></span><br><span class="line">    <span class="type">double</span> B = x1 - x2; <span class="comment">// 直线的 B</span></span><br><span class="line">    <span class="type">double</span> C = x2 * y1 - x1 * y2; <span class="comment">// 直线的 C</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用距离公式计算点 C 到直线 AB 的距离</span></span><br><span class="line">    <span class="type">double</span> distance = <span class="built_in">fabs</span>(A * x3 + B * y3 + C) / <span class="built_in">sqrt</span>(A * A + B * B);</span><br><span class="line">    <span class="keyword">return</span> distance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202410151359222.webp" style="zoom:50%;" />

<p>通过这种方式，Douglas-Peucker 算法能够有效地减少曲线的复杂度，同时尽量保留曲线的形状特征，广泛应用于计算机图形学、地理信息系统（GIS）等领域。</p>
<p>在opencv中，轮廓近似函数：<code>cv2.approxPolyDP(cnt, eps,True)</code>由Douglas-Peuker算法实现</p>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">double</span> x;</span><br><span class="line">    <span class="type">double</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算点到线段的距离</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">pointToSegmentDistance</span><span class="params">(<span class="type">const</span> Point&amp; p, <span class="type">const</span> Point&amp; a, <span class="type">const</span> Point&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> abx = b.x - a.x;</span><br><span class="line">    <span class="type">double</span> aby = b.y - a.y;</span><br><span class="line">    <span class="keyword">if</span> (abx == <span class="number">0</span> &amp;&amp; aby == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// a 和 b 是同一点</span></span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">sqrt</span>((p.x - a.x) * (p.x - a.x) + (p.y - a.y) * (p.y - a.y));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> t = ((p.x - a.x) * abx + (p.y - a.y) * aby) / (abx * abx + aby * aby);</span><br><span class="line">    t = std::<span class="built_in">max</span>(<span class="number">0.0</span>, std::<span class="built_in">min</span>(<span class="number">1.0</span>, t)); <span class="comment">// 限制 t 在 [0, 1] 之间</span></span><br><span class="line">    Point projection = &#123; a.x + t * abx, a.y + t * aby &#125;;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">sqrt</span>((p.x - projection.x) * (p.x - projection.x) + (p.y - projection.y) * (p.y - projection.y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 道格拉斯-普克算法非递归实现</span></span><br><span class="line"><span class="function">std::vector&lt;Point&gt; <span class="title">douglasPeucker</span><span class="params">(<span class="type">const</span> std::vector&lt;Point&gt;&amp; points, <span class="type">double</span> epsilon)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (points.<span class="built_in">size</span>() &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> points; <span class="comment">// 如果点少于3个，直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">bool</span>&gt; <span class="title">keep</span><span class="params">(points.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">    keep[<span class="number">0</span>] = <span class="literal">true</span>; <span class="comment">// 保留起点</span></span><br><span class="line">    keep[points.<span class="built_in">size</span>() - <span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">// 保留终点</span></span><br><span class="line"></span><br><span class="line">    std::stack&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; stack;</span><br><span class="line">    stack.<span class="built_in">push</span>(&#123; <span class="number">0</span>, <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(points.<span class="built_in">size</span>()) - <span class="number">1</span> &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [start, end] = stack.<span class="built_in">top</span>();</span><br><span class="line">        stack.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> maxDistance = <span class="number">0.0</span>;</span><br><span class="line">        <span class="type">int</span> index = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start + <span class="number">1</span>; i &lt; end; ++i) &#123;</span><br><span class="line">            <span class="type">double</span> distance = <span class="built_in">pointToSegmentDistance</span>(points[i], points[start], points[end]);</span><br><span class="line">            <span class="keyword">if</span> (distance &gt; maxDistance) &#123;</span><br><span class="line">                maxDistance = distance;</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (maxDistance &gt; epsilon) &#123;</span><br><span class="line">            keep[index] = <span class="literal">true</span>; <span class="comment">// 保留这个点</span></span><br><span class="line">            stack.<span class="built_in">push</span>(&#123; start, index &#125;);</span><br><span class="line">            stack.<span class="built_in">push</span>(&#123; index, end &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;Point&gt; result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; points.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (keep[i]) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(points[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用方式</span></span><br><span class="line"><span class="comment">// 示例数据</span></span><br><span class="line">std::vector&lt;Point&gt; points = &#123;</span><br><span class="line">  &#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">2</span>, <span class="number">0</span>&#125;, &#123;<span class="number">3</span>, <span class="number">1</span>&#125;, &#123;<span class="number">4</span>, <span class="number">0</span>&#125;, &#123;<span class="number">5</span>, <span class="number">1</span>&#125;, &#123;<span class="number">6</span>, <span class="number">0</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">double</span> epsilon = <span class="number">0.5</span>; <span class="comment">// 简化的阈值</span></span><br><span class="line"></span><br><span class="line">std::vector&lt;Point&gt; simplified = <span class="built_in">douglasPeucker</span>(points, epsilon);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出简化后的点</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;简化后的点:\n&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; point : simplified) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; point.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; point.y &lt;&lt; <span class="string">&quot;)\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于DP算法中的阈值需要人工手动设定,因此此处记录一个自适应DP算法</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://computing.hit.edu.cn/_upload/article/files/99/c7/50e62f564c27a323a254269f30b9/b817f576-b4b8-43a3-b847-2883443c8e16.pdf">自适应DP算法论文</a></p>
<p>可以根据垂比弦值来量化节点的重要性 </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202410181024086.png" alt="image-20241018102450684"><br>$$<br>importance(P_{i})&#x3D;\frac{Vert(P_{i})}{Chord(P_{i})}<br>$$<br>节点的重要值衡量了该节点对整个矢量图形维持原形状的重要性，重要值越大，该节点对原图形形状越重要。 为了使压缩后的矢量图形尽可能地维持原图形形状，就需要保留这些重要值很大的节点</p>
<p>然后引入了角度变化率(指的是拟合曲线上相邻两点切线方向上角度的变化率),用于局部计算阈值’</p>
<p>粗略提取了一些思想,整体算法较为复杂,涉及到<a href="#%E6%9B%B2%E7%BA%BF%E6%8B%9F%E5%90%88">曲线拟合</a>,暂略</p>
</blockquote>
<h3 id="垂距限值法"><a href="#垂距限值法" class="headerlink" title="垂距限值法"></a>垂距限值法</h3><p>垂距限值法是一种简单的<strong>轨迹平滑算法</strong>，用于将给定的轨迹进行简化，从而减少轨迹的噪声，并减少机器人的运动轨迹。该算法的基本思想是对轨迹上的每个点进行垂线投影，如果垂线的长度小于某个阈值，则认为该点是不必要的，可以将其删除，从而实现轨迹的简化。</p>
<p><strong>算法原理</strong></p>
<ol>
<li>以第一个点开始，计算第一个点到前一个点和后一个点所在直线的垂距；</li>
<li>如果垂距小于阈值，则保留该点，并将其作为下一个点计算；</li>
<li>如果垂距大于阈值，则舍弃该点，并将下一个点作为当前点重新进行计算；</li>
<li>依次类推，直到计算完最后一个点。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算垂距</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">DistanceToLine</span><span class="params">(<span class="type">const</span> geometry_msgs::Point&amp; p1, <span class="type">const</span> geometry_msgs::Point&amp; p2, <span class="type">const</span> geometry_msgs::Point&amp; p3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> numerator = <span class="built_in">abs</span>((p<span class="number">3.</span>y - p<span class="number">2.</span>y) * (p<span class="number">2.</span>x - p<span class="number">1.</span>x) - (p<span class="number">2.</span>y - p<span class="number">1.</span>y) * (p<span class="number">3.</span>x - p<span class="number">2.</span>x));</span><br><span class="line">    <span class="type">double</span> denominator = <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(p<span class="number">3.</span>y - p<span class="number">2.</span>y, <span class="number">2</span>) + <span class="built_in">pow</span>(p<span class="number">3.</span>x - p<span class="number">2.</span>x, <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> numerator / denominator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 垂距限值法函数</span></span><br><span class="line"><span class="function">nav_msgs::Path <span class="title">PerpendicularDistanceThreshold</span><span class="params">(<span class="type">const</span> nav_msgs::Path&amp; input_path, <span class="type">const</span> <span class="type">double</span> threshold)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nav_msgs::Path output_path;</span><br><span class="line">    <span class="type">int</span> input_size = input_path.poses.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (input_size &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        output_path = input_path;</span><br><span class="line">        <span class="keyword">return</span> output_path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>; <span class="comment">// 记录当前点在input_path中的索引</span></span><br><span class="line">    output_path.poses.<span class="built_in">push_back</span>(input_path.poses[index]); <span class="comment">// 将第一个点添加到输出路径中</span></span><br><span class="line">    output_path.header = input_path.header;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; input_size - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="type">double</span> distance = <span class="built_in">DistanceToLine</span>(input_path.poses[index].pose.position,</span><br><span class="line">                                                 input_path.poses[i].pose.position,</span><br><span class="line">                                                 input_path.poses[i + <span class="number">1</span>].pose.position);</span><br><span class="line">        <span class="keyword">if</span> (distance &gt; threshold) &#123;</span><br><span class="line">            output_path.poses.<span class="built_in">push_back</span>(input_path.poses[i]); <span class="comment">// 若垂距大于阈值，则保留该点</span></span><br><span class="line">            index = i; <span class="comment">// 更新当前点的索引</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    output_path.poses.<span class="built_in">push_back</span>(input_path.poses[input_size - <span class="number">1</span>]); <span class="comment">// 将最后一个点添加到输出路径中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> output_path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里罗列一个C#算垂距的例子</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">long</span> <span class="title">DateTimeToLong</span>(<span class="params">DateTime dateTime</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> dateTime.Ticks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">double</span> <span class="title">CalcVerticalDistance</span>(<span class="params">DateTimePoint start, DateTimePoint end, DateTimePoint point</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 将 DateTime 转换为 Unix 时间戳</span></span><br><span class="line">  <span class="built_in">long</span> x1 = DateTimeToLong(start.DateTime);</span><br><span class="line">  <span class="built_in">long</span> x2 = DateTimeToLong(end.DateTime);</span><br><span class="line">  <span class="built_in">long</span> x0 = DateTimeToLong(point.DateTime);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取 y 坐标</span></span><br><span class="line">  <span class="built_in">double</span> y1 = (<span class="built_in">double</span>)start.Value;</span><br><span class="line">  <span class="built_in">double</span> y2 = (<span class="built_in">double</span>)end.Value;</span><br><span class="line">  <span class="built_in">double</span> y0 = (<span class="built_in">double</span>)point.Value;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// A, B, C 的计算</span></span><br><span class="line">  <span class="built_in">double</span> A = y2 - y1;</span><br><span class="line">  <span class="built_in">double</span> B = x1 - x2;</span><br><span class="line">  <span class="built_in">double</span> C = x2 * y1 - x1 * y2;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据公式计算距离</span></span><br><span class="line">  <span class="built_in">double</span> distance = Math.Abs(A * x0 + B * y0 + C) / Math.Sqrt(A * A + B * B);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> distance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="曲线趋势中心点"><a href="#曲线趋势中心点" class="headerlink" title="曲线趋势中心点"></a>曲线趋势中心点</h2><p>整体思路如下:</p>
<ol>
<li><strong>准备数据</strong>：排序、平滑</li>
<li><strong>定义度量</strong>：设计误差函数，确定采样策略</li>
<li><strong>粗搜索</strong>：大范围低精度扫描</li>
<li><strong>细搜索</strong>：小范围高精度定位</li>
<li><strong>结果验证</strong>：计算对称评分，可视化检查</li>
<li><strong>输出</strong>：返回最佳X值及相关指标</li>
</ol>
<p>详细参考如下:</p>
<ol>
<li><p><strong>去噪</strong>,突出整体趋势,减少噪声对对称性判断的影响(移动平均&#x2F;低通滤波&#x2F;高斯滤波&#x2F;样条拟合)</p>
</li>
<li><p><strong>定义对称性度量</strong></p>
<p>定义一个函数（误差函数）来量化曲线关于某个中心点x_c的对称程度</p>
<p><strong>核心思路</strong></p>
<p>对于候选中心点X_c，曲线左右对称意味着：</p>
<ul>
<li>对于任意偏移量d</li>
<li>左侧点(X_c - d)的Y值 ≈ 右侧点(X_c + d)的Y值</li>
</ul>
<p><strong>误差函数设计</strong></p>
<ul>
<li>**均方误差(MSE)**：<ul>
<li>计算所有偏移量d对应的(Y_left - Y_right)²</li>
<li>求这些平方差的平均值</li>
<li>优点：对大误差更敏感，能更好区分对称性程度</li>
</ul>
</li>
<li>**平均绝对误差(MAE)**：<ul>
<li>计算所有偏移量d对应的|Y_left - Y_right|</li>
<li>求这些绝对差的平均值</li>
<li>优点：对异常值不敏感</li>
</ul>
</li>
</ul>
<p><strong>偏移量采样策略</strong></p>
<ul>
<li><strong>d_max确定</strong>：取X_c到左边界和右边界距离的较小值</li>
<li><strong>采样点数量</strong>：通常在50-100个点之间平衡精度和效率</li>
<li><strong>采样方式</strong>：均匀分布在[0, d_max]区间</li>
</ul>
</li>
<li><p><strong>搜索候选中心点</strong></p>
<p><strong>分层搜索策略</strong></p>
<ol>
<li><strong>粗搜索阶段</strong>：<ul>
<li>目的：快速定位大致区域</li>
<li>方法：将整个范围分成50-100个等距点</li>
<li>计算每个点的对称误差</li>
<li>记录误差最小的点作为初步中心</li>
</ul>
</li>
<li><strong>细搜索阶段</strong>：<ul>
<li>目的：在粗搜索结果附近精确查找</li>
<li>方法：在粗搜索最佳点周围小范围内密集采样</li>
<li>范围设置：通常取粗搜索步长的2倍为半径</li>
<li>采样密度：比粗搜索高5-10倍</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>插值处理</strong></p>
<p><strong>为什么需要插值</strong></p>
<ul>
<li>数据点是离散的，但对称点可能不在原始数据点上</li>
<li>需要估计任意X位置的Y值</li>
</ul>
<p><strong>插值方法选择</strong></p>
<ol>
<li><a href="#%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC">线性插值</a>：<ul>
<li>原理：在相邻两点间画直线</li>
<li>优点：计算简单快速</li>
<li>缺点：曲线不够平滑时精度有限</li>
</ul>
</li>
<li><a href="#%E6%A0%B7%E6%9D%A1%E6%8F%92%E5%80%BC">三次样条插值</a><ul>
<li>原理：使用分段三次多项式连接点</li>
<li>优点：能生成平滑曲线，精度高</li>
<li>缺点：计算稍复杂，需要足够数据点</li>
</ul>
</li>
</ol>
<p><strong>边界处理</strong></p>
<ul>
<li>当X超出数据范围时，返回无效值或使用外推法</li>
<li>在算法中应跳过这些点，不参与误差计算</li>
</ul>
</li>
<li><p><strong>优化策略</strong></p>
<p><strong>效率优化</strong></p>
<ul>
<li><strong>采样点优化</strong>：<ul>
<li>在平坦区域减少采样密度</li>
<li>在变化剧烈区域增加采样密度</li>
</ul>
</li>
<li><strong>并行计算</strong>：<ul>
<li>粗搜索中各候选点可并行计算误差</li>
<li>细搜索中各点也可并行处理</li>
</ul>
</li>
<li><strong>提前终止</strong>：<ul>
<li>当找到明显低误差点时停止搜索</li>
<li>但需设置合理阈值防止局部最优</li>
</ul>
</li>
</ul>
<p><strong>精度优化</strong></p>
<ul>
<li><strong>迭代细化</strong>：<ul>
<li>在细搜索结果基础上再次缩小范围搜索</li>
<li>可进行多轮迭代提高精度</li>
</ul>
</li>
<li><strong>动态步长调整</strong>：<ul>
<li>根据误差变化率调整搜索步长</li>
<li>误差变化大时用小步长，变化平缓时用大步长</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>结果评估与输出</strong></p>
<p><strong>对称性评分</strong></p>
<ul>
<li>计算方法：1 - (实际误差&#x2F;最大可能误差)</li>
<li>意义：0-1之间的值，越接近1对称性越好</li>
<li>用途：判断结果可靠性，过滤低质量结果</li>
</ul>
<p><strong>多峰处理</strong></p>
<p>当发现多个局部最优解时：</p>
<ul>
<li>记录所有候选点</li>
<li>根据对称性评分排序</li>
<li>返回最佳点或所有候选点供用户选择</li>
</ul>
<p><strong>结果验证</strong></p>
<ul>
<li>可视化：绘制对称轴和原始曲线对比</li>
<li>统计检验：计算左右两侧的相关系数</li>
<li>残差分析：检查误差分布是否随机</li>
</ul>
<p><strong>特殊场景处理</strong></p>
<p>非理想对称曲线</p>
<ul>
<li><p><strong>整体趋势处理</strong>：</p>
<ul>
<li><p>方法：先去除线性或多项式趋势</p>
</li>
<li><p>前提是如果需要去除整体趋势影响的干扰才考虑这样处理,若趋势本身就是对称的一部分,在这情况下，可以跳过此步骤。</p>
</li>
<li><p>步骤：</p>
<ol>
<li>拟合整体趋势线</li>
<li>原始数据减去趋势值</li>
<li>在残差数据上找对称中心</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>部分对称处理</strong>：</p>
<ul>
<li>指定关注区间而非整个曲线</li>
<li>在局部区域应用相同算法</li>
</ul>
</li>
</ul>
<p>噪声处理进阶</p>
<ul>
<li><strong>鲁棒统计方法</strong>：<ul>
<li>使用中位数代替平均值</li>
<li>忽略一定比例的异常点</li>
</ul>
</li>
<li><strong>多尺度分析</strong>：<ul>
<li>在不同平滑程度上分别计算</li>
<li>综合多个尺度的结果</li>
</ul>
</li>
</ul>
<p>无解情况处理</p>
<ul>
<li>当最小误差仍很大时：<ul>
<li>返回”未找到有效对称中心”</li>
<li>提供可能原因分析（如数据噪声大、曲线不对称）</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="数值分析-曲线拟合算法和函数逼近"><a href="#数值分析-曲线拟合算法和函数逼近" class="headerlink" title="数值分析:曲线拟合算法和函数逼近"></a>数值分析:曲线拟合算法和函数逼近</h1><p>与插值方法最大的区别在于最终要得到具体的函数关系 </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://www.bilibili.com/video/BV1HL4y1q7BV" alt="相关教程参考|720x360"></p>
<p>在数值积分中，除了使用梯形简单计算积分外,还可以使用插值或拟合技术来构造多项式来逼近被积函数。这里简单介绍一下常用的方法： </p>
<ol>
<li><strong>插值法</strong>：插值法通过已知数据点来构造通过这些点的多项式函数。常见的插值方法包括拉格朗日插值和牛顿插值。在辛普森法则中，我们可以通过子区间的左端点、右端点和中点处的函数值来构造一个二次多项式，从而近似代替被积函数。 </li>
<li><strong>拟合法</strong>：拟合法通过已知数据点来拟合一个多项式函数，使得这个多项式函数与原函数在这些点上尽可能接近。常见的拟合方法包括最小二乘法和最小二乘多项式拟合。在数值积分中，我们可以使用拟合技术来构造一个简单的多项式函数来逼近被积函数。</li>
</ol>
<h1 id="动态时间归整"><a href="#动态时间归整" class="headerlink" title="动态时间归整"></a>动态时间归整</h1><p>DTW(Dynamic Time Warping)</p>
<p>按照距离最近的原则，构建两个序列中的元素之间的对应的关系，用于评估两个序列的相似性。</p>
<blockquote>
<p>应用场景:</p>
<ul>
<li><p>计算两个序列之间的相似性</p>
<p>动作识别:传感器x,y,z的加速度和角速度6维数据作为一组数据,评估运动的相似性</p>
</li>
<li><p>获取匹配特征对(最终取路径)</p>
<p>声音转换,源说话人的语音转换为目标说话人的特征需要先配对,才能构造转换函数</p>
<p>语音识别: 文本和语音特征对齐 (距离计算要提前训练一个DNN的深度神经网络的分类器(输入的是特征,输出的是音素概率),使用最终输出的概率值作为距离)</p>
<p>股市交易曲线匹配</p>
<p>DNA碱基序列匹配</p>
<p>非常多应用场景</p>
</li>
</ul>
</blockquote>
<p>要求:</p>
<ol>
<li><strong>单向</strong>对应,不能回头</li>
<li><strong>一一对应</strong>,不能有空</li>
<li>对应之后,<strong>距离最近</strong></li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202405231041901.png" alt="image-20240523104142045" style="zoom:25%;" />

<p>定义一个距离公式,怎么定义都可以,比如说最简单的: dis(x,y)&#x3D;|x-y|</p>
<p>假设有A,B两个序列,A序列有m个元素,B序列有n个元素,将会产出一个m<em>n的*<em>累计距离矩阵</em></em>(D)</p>
<p>填充算法遵循如下公司</p>
<ul>
<li><p>对于最左边的一列:<br>$$<br>\mathrm{D}[i,0]&#x3D;\mathrm{dis}(\mathrm{A}_i,\mathrm{B}_0)+\mathrm{D}[i-1,0]<br>$$</p>
</li>
<li><p>对于最下面的一行:(实际上算法与上面一样,方向变了而已)<br>$$<br>\mathrm{D}[0,j]&#x3D;\mathrm{dis}(\mathrm{A}_0,\mathrm{B}_j)+\mathrm{D}[0,j-1]<br>$$</p>
</li>
<li><p>对于其他元素<br>$$<br>\begin{array}{c}\mathrm{D}[i,j]&#x3D;\mathrm{dis}(\mathrm{A}_i,\mathrm{B}_j)+\mathrm{min}(\mathrm{D}[\mathrm{i}-1,\mathrm{j}] ,\mathrm{D}[\mathrm{i},\mathrm{j}-1],\mathrm{D}[\mathrm{i}-1,\mathrm{j}-1] )\end{array}<br>$$<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202405231059989.png" alt="image-20240523105912963"></p>
</li>
</ul>
<blockquote>
<p>为什么是左下三个点呢?原因是因为一对一</p>
</blockquote>
<p>矩阵被填充完毕后,从右上角开始，向左下找寻配准路径找到左下三点中，较小的那个作为下一节点。</p>
<p>如图:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202405231123474.png" alt="image-20240523112324299">  </p>
<p><strong>最终就能得到配准结果</strong></p>
<p>完整过程参考该视频👇🏻</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://www.bilibili.com/video/BV12r4y1A7mT" alt="教程|720x360"></p>
<p>实际计算的过程中,只需要利用<a href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">动态规划</a>的思想就可以实现,并不需要填充矩阵</p>
<h1 id="离群点-异常点查找算法"><a href="#离群点-异常点查找算法" class="headerlink" title="离群点&#x2F;异常点查找算法"></a>离群点&#x2F;异常点查找算法</h1><p>异常就是偏离数据主要分布的点或者群体，导致异常的原因有很多，比如恶意行为，系统故障，蓄意欺诈等，</p>
<p>因此，异常检测对于决策系统是必须的。</p>
<h2 id="离群点-异常点介绍"><a href="#离群点-异常点介绍" class="headerlink" title="离群点&#x2F;异常点介绍"></a>离群点&#x2F;异常点介绍</h2><p>异常点分类</p>
<ul>
<li><p>单点异常</p>
<p>个体数据实例相对于其余数据被视为异常(例如交易流水中的大额交易)</p>
</li>
<li><p>上下文异常(时间序列)</p>
<p>一般是在有时间的序列集中才存在,仅在特定上下文中异常,单拿出来看不出异常</p>
</li>
<li><p>集体异常(连续性异常)</p>
<p>相关数据实例的集合相对于整个数据集是异常的,对于单个值则不是</p>
<p>两种可能性</p>
<ol>
<li>按无法预料的顺序发生</li>
<li>值的组合是无法预料的</li>
</ol>
</li>
</ul>
<h2 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h2><ul>
<li>大部分情况下数据是没有标签（label）的，各种成熟的监督学习（supervised learning）没有用武之地。</li>
<li>区分噪音（noise）和异常点（anomaly）时难度很大，甚至需要发挥一点点想象力和直觉。</li>
<li>当多种诈骗数据混合在一起，区分不同的诈骗类型更难。根本原因还是因为我们并不了解每一种诈骗定义。</li>
</ul>
<h2 id="异常检测算法的分类"><a href="#异常检测算法的分类" class="headerlink" title="异常检测算法的分类"></a>异常检测算法的分类</h2><ul>
<li><p>时序相关 vs  时序独立</p>
<p>数据的变化是否依赖于时间维度</p>
</li>
<li><p>全局 vs 局部</p>
<p>每个点的参考对象是全局的点,还是仅参考周围的点</p>
</li>
<li><p>标签 vs 异常分数</p>
<p>算法检测结果的输出形式不同</p>
<p>异常分数可以对异常程度进行排序</p>
</li>
<li><p>基于模型特性</p>
<p>根据异常点的特性,采用不同的算法直接建模</p>
</li>
</ul>
<p>时序相关下的异常检测:</p>
<ul>
<li><p>滑动窗口</p>
<p>根据不同场景，可以选择 Moving Average 或 Expanding MAD 等组合进行计算</p>
</li>
<li><p>马尔科夫链</p>
<p>可用马尔科夫链来测时间序列发生的概率，从而检测到那些发生概率低的异常序列</p>
</li>
<li><p>时间序列聚类</p>
<p>采用 <a href="#%E5%8A%A8%E6%80%81%E6%97%B6%E9%97%B4%E5%BD%92%E6%95%B4">DTW</a> 的方式计算不同时间序列间的距离，减弱时间差的影响，检测出那些高度相似的时序群组</p>
</li>
<li><p>时序预测方法</p>
<p>通过对已有时序的预测，评估预测值与实际值的偏差是否过大，从而判断某个时间点是否存在异常</p>
</li>
</ul>
<h2 id="异常检测的经典思想模型"><a href="#异常检测的经典思想模型" class="headerlink" title="异常检测的经典思想模型"></a>异常检测的经典思想模型</h2><p>这里提到的经典思想模型,很少拿来直接使用,但如今常用的流行算法都是基于这些原始模型的思想衍生出来的</p>
<h3 id="统计检验方法"><a href="#统计检验方法" class="headerlink" title="统计检验方法"></a>统计检验方法</h3><p>基本假设：正常的数据遵循特定的分布形式，并占了很大比例，异常点的位置较正常点范围存在较大偏移。</p>
<p>存在的问题往往是: 均值和标准差都对异常值很敏感,在实际计算的时候,异常值也被包含在全部数据集里</p>
<p>如<a href="#Z-score">Z-score</a> </p>
<h3 id="基于偏差的方法"><a href="#基于偏差的方法" class="headerlink" title="基于偏差的方法"></a>基于偏差的方法</h3><p>给定一个数据集（可以为局部子集或全局点集），若一个点自身的值与整个集合的指标有过大的偏差，则该点为异常点。去除掉这个点后，整个集合的方差会减小。</p>
<p>基本假设: 数据集最外围的点为异常点</p>
<p>模型思想：定义一个指标 SF（smooth factor），它表示当某个点从集合移除掉后，方差（ variance ）降低的值。［Arning et al. 1996］</p>
<h3 id="基于距离的方法"><a href="#基于距离的方法" class="headerlink" title="基于距离的方法"></a>基于距离的方法</h3><p>计算每个点与周围点的距离，来判断该点是否为异常点。</p>
<p>基本假设：正常点的周围存在多个近邻点，而异常点分布在稀疏区域，距离周围点的距离较远。</p>
<p>DB 模型：给定半径r和比例 T，假设对 p点进行检测，若与p点距离小于半径r的点数对于全部点数的比例低于 T，则该点为异常点。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202407111339169.png" alt="iShot_2024-07-11_13.38.44" style="zoom: 25%;" />

<h3 id="基于密度的方法"><a href="#基于密度的方法" class="headerlink" title="基于密度的方法"></a>基于密度的方法</h3><p>对比目标点的周围密度与其近邻点的周围密度，基于两个密度值计算出相对密度，作为异常分数。</p>
<p>基本假设：正常点与其近邻点的密度是相近的，而异常点的密度与其近邻点存在较大的差异。</p>
<p>开发该方法的动机：基于距离的异常检测方法无法处理密度不同的情况。针对右图，若采用 DB model，半径和比例固定，02 会被识别为异常点，而C1 子集中的很多点的距离都比02小，也就会被识别为正常点。若引入密度作为标准，就会有不同的检测结果。<br>解决方法：引入相对密度</p>
<h3 id="深度学习方法–Autoencoder"><a href="#深度学习方法–Autoencoder" class="headerlink" title="深度学习方法–Autoencoder"></a>深度学习方法–Autoencoder</h3><p>Autoencoder，即自编码器，是一种无监督学习模型，包含两个部分：encoder（编码器）和 decoder（解码器）。</p>
<p>Encoder 用来发现给定数据的压缩表示，decoder 用来重建原始输入。在训练时，decoder 强迫 autoencoder 选择最有信息量的特征，最终保存在压缩表示中。最终压缩后的表示就在中间的 coder 层中。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202407111344146.png" alt="image-20240711134417412" style="zoom: 15%;" />

<h2 id="方法盘点"><a href="#方法盘点" class="headerlink" title="方法盘点"></a>方法盘点</h2><p>有如下方法:</p>
<ol>
<li>统计方法</li>
</ol>
<ul>
<li>Z-score（标准分数）：计算数据点距离均值的标准差数，通常z-score超过3或小于-3的点被认为是异常点。</li>
<li><a href="#%E5%9B%9B%E5%88%86%E4%BD%8D%E8%B7%9D%E6%B3%95">IQR（四分位距）</a>：计算数据的四分位数（Q1和Q3），然后计算IQR &#x3D; Q3 - Q1。通常定义在Q1 - 1.5 * IQR以下或Q3 + 1.5 * IQR以上的点为异常点。</li>
<li>Grubbs’ Test：用于检测单变量数据集中的单个异常值。该测试假设数据呈正态分布。</li>
</ul>
<ol start="2">
<li>基于距离的方法</li>
</ol>
<ul>
<li>K-均值聚类：在进行K-均值聚类后，距离其最近质心最远的点可以被认为是异常点。</li>
<li>DBSCAN（基于密度的聚类）：该方法可以找出密度较低区域中的点，认为它们是异常点。</li>
<li>LOF（局部离群因子）：基于密度的局部异常值检测方法，通过比较点与其邻居的局部密度来判断是否是异常点。</li>
</ul>
<ol start="3">
<li>机器学习方法</li>
</ol>
<ul>
<li><a href="#%E5%AD%A4%E7%AB%8B%E6%A3%AE%E6%9E%97%E7%AE%97%E6%B3%95">孤立森林（Isolation Forest）</a>：基于树的随机森林方法，通过随机分割数据来检测异常点。</li>
<li>One-Class SVM：一种支持向量机方法，适用于异常检测。</li>
<li>自编码器（Autoencoder）：一种神经网络方法，通过重构误差来检测异常点。</li>
</ul>
<ol start="4">
<li>基于概率的方法</li>
</ol>
<ul>
<li>高斯混合模型（GMM）：通过拟合数据的多峰分布来识别异常点。</li>
<li>贝叶斯方法：通过计算数据点的概率分布来检测异常点。</li>
</ul>
<ol start="5">
<li>可视化方法</li>
</ol>
<ul>
<li>箱线图（Box Plot）：通过箱线图可以直观地看到异常点。</li>
<li>散点图（Scatter Plot）：特别适合二维数据，通过观察数据点的分布情况来发现异常点。</li>
</ul>
<p>结合滑动窗口动态检测异常点</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202407111353991.png" alt="image-20240711135317730" style="zoom: 20%;" />

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202407111354458.png" alt="image-20240711135416962" style="zoom:20%;" />

<p>下面罗列几种方法</p>
<h3 id="四分位距法"><a href="#四分位距法" class="headerlink" title="四分位距法"></a>四分位距法</h3><p>先要获取到完整的数据序列,才能处理</p>
<p>四分位距法（Interquartile Range, IQR）是一种统计方法，用于衡量数据的离散程度。它通过计算数据的上四分位数（Q3）和下四分位数（Q1）之间的差值来描述数据的分散程度。</p>
<p>具体步骤如下：</p>
<ol>
<li>首先，将数据按大小顺序排列。</li>
<li>然后计算数据的上四分位数（Q3）和下四分位数（Q1）。<ul>
<li>上四分位数（Q3）是将数据分成四等份后，位于第三份的数值。</li>
<li>下四分位数（Q1）是将数据分成四等份后，位于第一份的数值。</li>
</ul>
</li>
<li>计算四分位距（IQR）：IQR &#x3D; Q3 - Q1。</li>
<li>根据IQR的大小，可以判断数据的离散程度：<ul>
<li>如果某个数据点小于Q1 - 1.5 * IQR或大于Q3 + 1.5 * IQR，则可以被视为异常值（离群值）。</li>
</ul>
</li>
</ol>
<p>四分位距法相对于标准差等其他离散度量具有一定的优势，因为它对异常值的影响较小，更能反映数据的真实分布情况。在数据分析和异常值检测中，四分位距法常被用于识别离群值。</p>
<p>代码:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">double</span> <span class="title">GetPercentile</span>(<span class="params">List&lt;<span class="built_in">double</span>&gt; sortedData, <span class="built_in">double</span> percentile</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> N = sortedData.Count;</span><br><span class="line">    <span class="built_in">double</span> n = (N - <span class="number">1</span>) * percentile / <span class="number">100.0</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>d) <span class="keyword">return</span> sortedData[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (n == N) <span class="keyword">return</span> sortedData[N - <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">int</span> k = (<span class="built_in">int</span>)n;</span><br><span class="line">    <span class="built_in">double</span> d = n - k;</span><br><span class="line">    <span class="keyword">return</span> sortedData[k - <span class="number">1</span>] + d * (sortedData[k] - sortedData[k - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 计算四分位距</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;data&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;exception cref=&quot;ArgumentException&quot;&gt;</span><span class="doctag">&lt;/exception&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> (<span class="params"><span class="built_in">double</span>, <span class="built_in">double</span>, <span class="built_in">double</span></span>) <span class="title">CalculateInterquartileRange</span>(<span class="params">List&lt;<span class="built_in">double</span>&gt; data</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="literal">null</span> || data.Count == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">&quot;数据序列不能为空&quot;</span>);</span><br><span class="line">    List&lt;<span class="built_in">double</span>&gt; sortedData = <span class="keyword">new</span> List&lt;<span class="built_in">double</span>&gt;(data);</span><br><span class="line">    sortedData.Sort();</span><br><span class="line">    <span class="built_in">double</span> Q1 = GetPercentile(sortedData, <span class="number">25</span>);</span><br><span class="line">    <span class="built_in">double</span> Q3 = GetPercentile(sortedData, <span class="number">75</span>);</span><br><span class="line">    <span class="keyword">return</span> (Q1, Q3, Q3 - Q1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Z-score"><a href="#Z-score" class="headerlink" title="Z-score"></a>Z-score</h3><p>Z-score方法是一种常用的统计方法，用于衡量数据点与数据集均值之间的差异，即数据点距离均值的标准差数。Z-score可以帮助我们判断数据点在数据集中的相对位置，从而进行比较和分析。</p>
<p>缺陷:因涉及到均值,对异常点相对敏感</p>
<p>[[数学#标准差|标准差参考]]</p>
<p>Z-score的计算公式如下：<br>$$<br>Z &#x3D; \frac{x - \mu}{\sigma}<br>$$<br>其中，Z表示Z-score，x表示数据点的数值，μ表示数据集的均值，σ表示数据集的标准差。</p>
<p>通过计算Z-score，我们可以将数据标准化为标准正态分布，即均值为0，标准差为1的分布。在标准正态分布中，大约68%的数据点落在±1个标准差范围内，约95%的数据点落在±2个标准差范围内，约99.7%的数据点落在±3个标准差范围内。</p>
<p>通常情况下，Z-score超过3或小于-3的数据点被认为是异常值。Z-score方法适用于数据符合正态分布的情况，可以帮助我们识别和处理数据中的异常值，并进行数据分析和统计推断。<br>$$<br>正常范围:-3&lt;&#x3D;Z&lt;&#x3D;3<br>$$<br>也可以这么理解<br>$$<br>某个值处于正常范围:(某个值-平均值)的绝对值&lt;&#x3D;3倍标准差<br>$$</p>
<p>代码:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 计算标准差</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;data&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;exception cref=&quot;ArgumentException&quot;&gt;</span><span class="doctag">&lt;/exception&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">double</span> <span class="title">CalculateStandardDeviation</span>(<span class="params">List&lt;<span class="built_in">double</span>&gt; datas</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (datas.Count &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">&quot;数据点数量应至少为2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">double</span> mean = datas.Average();</span><br><span class="line">    <span class="built_in">double</span> sumOfSquares = datas.Sum(x =&gt; Math.Pow(x - mean, <span class="number">2</span>));</span><br><span class="line">    <span class="built_in">double</span> variance = sumOfSquares / (datas.Count - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">double</span> standardDeviation = Math.Sqrt(variance);</span><br><span class="line">    <span class="keyword">return</span> standardDeviation;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否异常值如下:</span></span><br><span class="line"><span class="keyword">var</span> avg = data.Average();</span><br><span class="line"><span class="keyword">var</span> standardDeviation = CalculateStandardDeviation(data);</span><br><span class="line"><span class="keyword">if</span> (Math.Abs(data[j] - avg) &gt; <span class="number">3</span> * standardDeviation)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="箱线图法"><a href="#箱线图法" class="headerlink" title="箱线图法"></a>箱线图法</h3><p>箱线图法是一种可视化离群值&#x2F;异常值的有效方法</p>
<p>箱线图（Box Plot）是一种用于显示数据分布情况的统计图表，能够直观地展示数据的中位数、上下四分位数、最大值、最小值以及离群点。箱线图通常包含以下几个要素：</p>
<ol>
<li><p><strong>箱体（Box）</strong>：箱体代表数据的四分位数范围，即数据的中间50%。箱体上边界表示数据的上四分位数（Q3），下边界表示数据的下四分位数（Q1），箱体内部的线表示数据的中位数。</p>
</li>
<li><p><strong>触须（Whiskers）</strong>：触须延伸自箱体，用于显示数据的最大值和最小值。触须的长度通常是箱体高度的1.5倍的距离，超出该距离的数据点被认为是异常值。</p>
</li>
<li><p><strong>离群点（Outliers）</strong>：箱线图中的离群点是指远离箱体的个别数据点，它们可能是数据中的异常值。离群点通常被标记出来，帮助我们识别数据中的异常情况。</p>
</li>
</ol>
<h3 id="孤立森林算法"><a href="#孤立森林算法" class="headerlink" title="孤立森林算法"></a>孤立森林算法</h3><p>属于机器学习算法</p>
<p>孤立森林(isolation Forest)算法，2008年由刘飞、周志华等提出，算法不借助类似距离、密度等指标去描述样本与其他样本的差异，而是直接去刻画所谓的**疏离程度(isolation)**，因此该算法简单、高效，在工业界应用较多。</p>
<p>一种集成模型,线性时间复杂度,可以用来处理大规模数据集</p>
<p>孤立森林通过构建随机二叉树来快速识别异常点，其效率得益于随机化过程和树结构的特性。由于它不需要假设数据的分布或异常点的比例，因此在处理大规模数据集和高维数据时表现出色。此外，<strong>由于算法的并行性，它还可以很好地利用多核处理器进行加速</strong>。</p>
<blockquote>
<p>适用情况</p>
<ul>
<li>Isolation Forest在<strong>数据量比较大的情况下效果更好</strong></li>
<li>一般来说，异常值在数据集中占的比例较小，通常是1%到5%。Isolation Forest能较好地处理这种低比例异常值的情况。</li>
</ul>
</blockquote>
<h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/492469453">孤立森林的详细参考</a></p>
<p>孤立森林（Isolation Forest）是一种基于树的无监督学习算法，用于异常检测。它的<strong>核心思想是异常点更容易被孤立（隔离）出来</strong>。以下是孤立森林算法的详细原理：</p>
<p><strong>孤立森林通过随机选择一个特征并在特征的随机值上切分数据，构建多棵树（称为孤立树）。它利用树的深度来测量数据点的孤立程度：深度越浅，越容易被孤立，越可能是异常点。</strong></p>
<p>用一个例子来说明孤立森林的思想：假设现在有一组一维数据（如下图），我们要对这组数据进行切分，<strong>目的是把点A和 B单独切分出来</strong>，先在最大，值和最小值之间随机选择一个值 X，然后按照 &lt;X 和 &gt;&#x3D;X 可以把数据分成左右两组，在这两组数据中分别重复这个步骤，直到数据不可再分。</p>
<p>点B跟其他数据比较疏离，可能用<strong>很少的次数</strong>就可以把它切分出来，点 A 跟其他数据点聚在一起，可能需要更多的次数才能把它切分出来。</p>
<p>那么<strong>从统计意义</strong>上来说，相对聚集的点需要分割的次数较多，比较孤立的点需要的分割次数少，孤立森林就是利用分割的次数来度量一个点是聚集的（正常）还是孤立的（异常）。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202407111113157.png" alt="图片" style="zoom: 50%;" />

<ol>
<li><strong>随机选择特征和随机切割</strong>：孤立森林通过随机选择一个特征和一个随机切割值来构建二叉树。该过程重复进行，直到每个样本点都被孤立在叶子节点。</li>
<li><strong>异常值定位</strong>：由于异常值更容易被孤立，因此异常值通常在树的较浅层被划分出来。通过路径长度可以衡量样本点在树中的孤立程度，路径长度越短，则样本点越可能是异常值。</li>
<li><strong>异常得分计算</strong>：根据样本点在多棵树中的平均路径长度来计算异常得分。路径长度越短，异常得分越高，反之则越低。</li>
</ol>
<blockquote>
<p>对于未曾见过的新数据点，将其在孤立森林(训练好的)中的每棵孤立树中进行路径长度的计算。</p>
<p>计算路径长度的方法是：从根节点开始，根据节点的分割特征和分割值，确定数据点进入左子树还是右子树，直到到达叶子节点，记录经过的节点数，即为路径长度。</p>
<p>对新数据点在多棵孤立树中的路径长度取平均值。</p>
<p>如果平均路径长度明显短于正常数据在孤立森林中的平均路径长度，那么就可以认为这个新数据点可能是异常的</p>
</blockquote>
<h4 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h4><p><strong>随机选择特征和切分点</strong>：</p>
<ul>
<li>对于每棵树，从数据集中随机选择一个特征，并在该特征的范围内随机选择一个切分点。</li>
<li>递归地对每个分区重复此过程，直到达到预定的树深度或节点包含的样本数量小于等于1。</li>
</ul>
<p><strong>构建孤立树</strong>：</p>
<ul>
<li>孤立树是通过不断随机选择特征和切分点来构建的二叉树。</li>
<li>每个节点对应一次数据的分裂，分裂点是根据选定特征的随机切分点。</li>
</ul>
<p><strong>计算路径长度</strong>：</p>
<ul>
<li>对于每个数据点，计算其在孤立树中从根节点到达叶节点的路径长度。</li>
<li>路径长度较短的数据点更容易被孤立，通常被认为是异常点。</li>
</ul>
<p><strong>异常得分计算</strong>：</p>
<ul>
<li><p>孤立森林利用多棵孤立树来稳定路径长度的估计。</p>
</li>
<li><p>异常得分是基于平均路径长度计算的，通常归一化到0到1之间。</p>
</li>
<li><p>计算公式：<br>$$<br>s(x,n)&#x3D;2^{-\frac{E(h(x))}{c(n)}}<br>$$<br>其中，𝐸(ℎ(𝑥))是数据点𝑥<em>x</em>在孤立森林中的平均路径长度，𝑐(𝑛)是一个常数，用于标准化路径长度。</p>
<h3 id="常数𝑐-𝑛-的计算"><a href="#常数𝑐-𝑛-的计算" class="headerlink" title="常数𝑐(𝑛)的计算"></a>常数𝑐(𝑛)的计算</h3><p>𝑐(𝑛)是用于标准化路径长度的常数，定义如下：<br>$$<br>c(n)&#x3D;2H(n-1)-\frac{2(n-1)}n<br>$$<br>其中，𝐻(𝑖) 是第𝑖个调和数<br>$$<br>H(i)&#x3D;\ln(i)+0.5772156649\text{(欧拉-马歇罗尼常数)}<br>$$</p>
</li>
</ul>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><p>注意:下面的代码可以针对多维数据,采用的数据存储容器是<code>List&lt;List&lt;double&gt;&gt;</code></p>
<h5 id="定义节点类"><a href="#定义节点类" class="headerlink" title="定义节点类"></a>定义节点类</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义孤立森林中的树节点类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 节点的分割值，用于决定数据点如何在左右子树间分配</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> SplitValue &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的分割属性索引，表示在哪个特征上进行分割</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> SplitAttribute &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左子树节点</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode Left &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 右子树节点</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode Right &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记节点是否为叶子节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> IsLeaf &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点所包含的样本数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Size &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数初始化节点为非叶子节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        IsLeaf = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="构建孤立树"><a href="#构建孤立树" class="headerlink" title="构建孤立树"></a>构建孤立树</h5><p>归方法构建孤立树。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义孤立森林中的单棵树构建逻辑</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">IsolationTree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 静态随机数生成器，用于在构建树过程中生成随机数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 递归构建孤立树</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;data&quot;&gt;</span>当前节点的数据集<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;currentHeight&quot;&gt;</span>当前树的高度<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;maxHeight&quot;&gt;</span>树的最大高度<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>构建完成的树节点<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">BuildTree</span>(<span class="params"><span class="built_in">double</span>[][] data, <span class="built_in">int</span> currentHeight, <span class="built_in">int</span> maxHeight</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果当前高度等于最大高度或数据集中只剩一个样本，创建叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> (currentHeight &gt;= maxHeight || data.Length &lt;= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode</span><br><span class="line">            &#123;</span><br><span class="line">                IsLeaf = <span class="literal">true</span>,</span><br><span class="line">                Size = data.Length</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 随机选择一个属性作为分割属性</span></span><br><span class="line">        <span class="built_in">int</span> attribute = rand.Next(data[<span class="number">0</span>].Length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算该属性上的最小值和最大值</span></span><br><span class="line">        <span class="built_in">double</span> min = data.Min(point =&gt; point[attribute]);</span><br><span class="line">        <span class="built_in">double</span> max = data.Max(point =&gt; point[attribute]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果最小值等于最大值，说明所有样本在这个属性上的值都相同，创建叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> (min == max)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode</span><br><span class="line">            &#123;</span><br><span class="line">                IsLeaf = <span class="literal">true</span>,</span><br><span class="line">                Size = data.Length</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 随机选择一个分割值，用于划分数据集</span></span><br><span class="line">        <span class="built_in">double</span> splitValue = min + rand.NextDouble() * (max - min);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据分割值将数据集分为左右两部分</span></span><br><span class="line">        <span class="keyword">var</span> left = data.Where(point =&gt; point[attribute] &lt; splitValue).ToArray();</span><br><span class="line">        <span class="keyword">var</span> right = data.Where(point =&gt; point[attribute] &gt;= splitValue).ToArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建新的树节点，并递归构建左右子树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeNode</span><br><span class="line">        &#123;</span><br><span class="line">            SplitAttribute = attribute,</span><br><span class="line">            SplitValue = splitValue,</span><br><span class="line">            Left = BuildTree(left, currentHeight + <span class="number">1</span>, maxHeight),</span><br><span class="line">            Right = BuildTree(right, currentHeight + <span class="number">1</span>, maxHeight)</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="计算路径长度"><a href="#计算路径长度" class="headerlink" title="计算路径长度"></a>计算路径长度</h5><p>实现一个方法来计算数据点在孤立树中的路径长度。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个方法来计算从根节点到特定数据点的路径长度，这是孤立森林算法中的一部分。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">PathLength</span>(<span class="params">TreeNode node, <span class="built_in">double</span>[] point, <span class="built_in">int</span> currentHeight</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果当前节点是叶子节点，那么返回当前高度加上基于节点大小的常数c</span></span><br><span class="line">    <span class="keyword">if</span> (node.IsLeaf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> currentHeight + c(node.Size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据数据点在分割属性上的值与节点的分割值比较，决定进入左子树还是右子树</span></span><br><span class="line">    <span class="keyword">if</span> (point[node.SplitAttribute] &lt; node.SplitValue)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果小于分割值，则递归地在左子树中查找，同时增加路径高度</span></span><br><span class="line">        <span class="keyword">return</span> PathLength(node.Left, point, currentHeight + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 否则，在右子树中查找，同样增加路径高度</span></span><br><span class="line">        <span class="keyword">return</span> PathLength(node.Right, point, currentHeight + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个辅助方法c，用于计算基于节点大小n的常数值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">c</span>(<span class="params"><span class="built_in">int</span> n</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Euler-Mascheroni常数约为0.5772156649，公式用于估算路径长度的期望值</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">int</span>)(<span class="number">2</span> * (Math.Log(n - <span class="number">1</span>) + <span class="number">0.5772156649</span>) - (<span class="number">2.0</span> * (n - <span class="number">1</span>) / n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="计算异常得分"><a href="#计算异常得分" class="headerlink" title="计算异常得分"></a>计算异常得分</h5><p>注意:异常得分越高,越异常</p>
<p>实现一个类来封装整个孤立森林算法，包含训练和预测方法。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义孤立森林类，用于异常检测</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">IsolationForest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 存储多棵决策树的列表</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;TreeNode&gt; trees;</span><br><span class="line">    <span class="comment">// 最大采样数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> maxSamples;</span><br><span class="line">    <span class="comment">// 最大树的高度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> maxTreeHeight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数初始化孤立森林 nTrees表示森林的树数,maxSamples表示每棵树的训练数据量个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IsolationForest</span>(<span class="params"><span class="built_in">int</span> nTrees, <span class="built_in">int</span> maxSamples</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        trees = <span class="keyword">new</span> List&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">this</span>.maxSamples = maxSamples;</span><br><span class="line">        <span class="comment">// 计算最大树高度为样本数量的对数（以2为底）</span></span><br><span class="line">        <span class="keyword">this</span>.maxTreeHeight = (<span class="built_in">int</span>)Math.Ceiling(Math.Log(maxSamples, <span class="number">2</span>));</span><br><span class="line">        <span class="comment">// 初始化树列表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nTrees; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            trees.Add(<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 训练孤立森林模型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fit</span>(<span class="params"><span class="built_in">double</span>[][] data</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 对每棵树进行训练</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; trees.Count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 随机采样数据</span></span><br><span class="line">            <span class="keyword">var</span> sample = SampleData(data, maxSamples);</span><br><span class="line">            <span class="comment">// 构建决策树并存储</span></span><br><span class="line">            trees[i] = IsolationTree.BuildTree(sample, <span class="number">0</span>, maxTreeHeight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算数据点的异常分数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">double</span>[] <span class="title">AnomalyScore</span>(<span class="params"><span class="built_in">double</span>[][] data</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">double</span>[] scores = <span class="keyword">new</span> <span class="built_in">double</span>[data.Length];</span><br><span class="line">        <span class="comment">// 对每个数据点计算平均路径长度并转换为异常分数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; data.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 计算平均路径长度</span></span><br><span class="line">            <span class="built_in">double</span> avgPathLength = trees.Average(tree =&gt; IsolationTree.PathLength(tree, data[i], <span class="number">0</span>));</span><br><span class="line">            <span class="comment">// 转换为异常分数</span></span><br><span class="line">            scores[i] = Math.Pow(<span class="number">2</span>, -avgPathLength / c(maxSamples));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> scores;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据采样方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">double</span>[][] SampleData(<span class="built_in">double</span>[][] data, <span class="built_in">int</span> sampleSize)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 使用随机数生成器进行随机采样</span></span><br><span class="line">        Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">return</span> data.OrderBy(x =&gt; rand.Next()).Take(sampleSize).ToArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算常数c(n)，用于异常分数计算</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="built_in">double</span> <span class="title">c</span>(<span class="params"><span class="built_in">int</span> n</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Euler-Mascheroni常数约为0.5772156649</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * (Math.Log(n - <span class="number">1</span>) + <span class="number">0.5772156649</span>) - <span class="number">2.0</span> * (n - <span class="number">1</span>) / n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用孤立森林算法"><a href="#使用孤立森林算法" class="headerlink" title="使用孤立森林算法"></a>使用孤立森林算法</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例数据，二维数组，每行代表一个样本</span></span><br><span class="line"><span class="built_in">double</span>[][] samples =</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">double</span>[] &#123; <span class="number">1</span>, <span class="number">2</span> &#125;,</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">double</span>[] &#123; <span class="number">2</span>, <span class="number">1</span> &#125;,</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">double</span>[] &#123; <span class="number">1</span>, <span class="number">1</span> &#125;,</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">double</span>[] &#123; <span class="number">2</span>, <span class="number">2</span> &#125;,</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">double</span>[] &#123; <span class="number">8</span>, <span class="number">8</span> &#125;,</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">double</span>[] &#123; <span class="number">9</span>, <span class="number">9</span> &#125;,</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">double</span>[] &#123; <span class="number">8</span>, <span class="number">9</span> &#125;,</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">double</span>[] &#123; <span class="number">9</span>, <span class="number">8</span> &#125;,</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">double</span>[] &#123; <span class="number">1</span>, <span class="number">8</span> &#125;,</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">double</span>[] &#123; <span class="number">8</span>, <span class="number">1</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建孤立森林算法实例,100表示建立100个孤立树</span></span><br><span class="line"><span class="keyword">var</span> isolationForest = <span class="keyword">new</span> IsolationForest(<span class="number">100</span>, samples.Count());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 训练模型</span></span><br><span class="line">isolationForest.Fit(samples);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取异常分数</span></span><br><span class="line"><span class="built_in">double</span>[] scores = isolationForest.Score(samples);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设定阈值来标记异常点</span></span><br><span class="line"><span class="built_in">double</span> threshold = <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; scores.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">string</span> label = scores[i] &gt; threshold ? <span class="string">&quot;Anomaly&quot;</span> : <span class="string">&quot;Normal&quot;</span>;</span><br><span class="line">  Console.WriteLine(<span class="string">$&quot;Sample <span class="subst">&#123;i&#125;</span>: Score = <span class="subst">&#123;scores[i]:F2&#125;</span>, Label = <span class="subst">&#123;label&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="一维孤立森林完整代码"><a href="#一维孤立森林完整代码" class="headerlink" title="一维孤立森林完整代码"></a>一维孤立森林完整代码</h4><p>下面附带一个完整版的一维孤立森林算法,更方便理解</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> SplitValue &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode Left &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode Right &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> IsLeaf &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Size &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        IsLeaf = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">IsolationTree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">BuildTree</span>(<span class="params">List&lt;<span class="built_in">double</span>&gt; data, <span class="built_in">int</span> currentHeight, <span class="built_in">int</span> maxHeight</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (currentHeight &gt;= maxHeight || data.Count &lt;= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode</span><br><span class="line">            &#123;</span><br><span class="line">                IsLeaf = <span class="literal">true</span>,</span><br><span class="line">                Size = data.Count</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">double</span> min = data.Min();</span><br><span class="line">        <span class="built_in">double</span> max = data.Max();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (min == max)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode</span><br><span class="line">            &#123;</span><br><span class="line">                IsLeaf = <span class="literal">true</span>,</span><br><span class="line">                Size = data.Count</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">double</span> splitValue = min + rand.NextDouble() * (max - min);</span><br><span class="line">        <span class="keyword">var</span> left = data.Where(<span class="keyword">value</span> =&gt; <span class="keyword">value</span> &lt; splitValue).ToList();</span><br><span class="line">        <span class="keyword">var</span> right = data.Where(<span class="keyword">value</span> =&gt; <span class="keyword">value</span> &gt;= splitValue).ToList();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeNode</span><br><span class="line">        &#123;</span><br><span class="line">            SplitValue = splitValue,</span><br><span class="line">            Left = BuildTree(left, currentHeight + <span class="number">1</span>, maxHeight),</span><br><span class="line">            Right = BuildTree(right, currentHeight + <span class="number">1</span>, maxHeight)</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">PathLength</span>(<span class="params">TreeNode node, <span class="built_in">double</span> point, <span class="built_in">int</span> currentHeight</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.IsLeaf)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> currentHeight + c(node.Size);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (point &lt; node.SplitValue)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> PathLength(node.Left, point, currentHeight + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> PathLength(node.Right, point, currentHeight + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">c</span>(<span class="params"><span class="built_in">int</span> n</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">int</span>)(<span class="number">2</span> * (Math.Log(n - <span class="number">1</span>) + <span class="number">0.5772156649</span>) - (<span class="number">2.0</span> * (n - <span class="number">1</span>) / n));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">IsolationForest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;TreeNode&gt; trees;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> maxSamples;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> maxTreeHeight;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IsolationForest</span>(<span class="params"><span class="built_in">int</span> nTrees, <span class="built_in">int</span> maxSamples</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        trees = <span class="keyword">new</span> List&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">this</span>.maxSamples = maxSamples;</span><br><span class="line">        <span class="keyword">this</span>.maxTreeHeight = (<span class="built_in">int</span>)Math.Ceiling(Math.Log(maxSamples, <span class="number">2</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nTrees; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            trees.Add(<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fit</span>(<span class="params">List&lt;<span class="built_in">double</span>&gt; data</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; trees.Count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> sample = SampleData(data, maxSamples);</span><br><span class="line">            trees[i] = IsolationTree.BuildTree(sample, <span class="number">0</span>, maxTreeHeight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">double</span>[] <span class="title">AnomalyScore</span>(<span class="params">List&lt;<span class="built_in">double</span>&gt; data</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">double</span>[] scores = <span class="keyword">new</span> <span class="built_in">double</span>[data.Count];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; data.Count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">double</span> avgPathLength = trees.Average(tree =&gt; IsolationTree.PathLength(tree, data[i], <span class="number">0</span>));</span><br><span class="line">            scores[i] = Math.Pow(<span class="number">2</span>, -avgPathLength / c(maxSamples));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> scores;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;<span class="built_in">double</span>&gt; <span class="title">SampleData</span>(<span class="params">List&lt;<span class="built_in">double</span>&gt; data, <span class="built_in">int</span> sampleSize</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> data.OrderBy(x =&gt; rand.Next()).Take(sampleSize).ToList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="built_in">double</span> <span class="title">c</span>(<span class="params"><span class="built_in">int</span> n</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * (Math.Log(n - <span class="number">1</span>) + <span class="number">0.5772156649</span>) - <span class="number">2.0</span> * (n - <span class="number">1</span>) / n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;<span class="built_in">double</span>&gt; data = <span class="keyword">new</span> List&lt;<span class="built_in">double</span>&gt; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建并训练孤立森林模型</span></span><br><span class="line">        IsolationForest iforest = <span class="keyword">new</span> IsolationForest(nTrees: <span class="number">100</span>, maxSamples: <span class="number">256</span>);</span><br><span class="line">        iforest.Fit(data);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算异常得分</span></span><br><span class="line">        <span class="built_in">double</span>[] scores = iforest.AnomalyScore(data);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; scores.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;Data point <span class="subst">&#123;i + <span class="number">1</span>&#125;</span>: Anomaly Score = <span class="subst">&#123;scores[i]&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="添加并行处理的一维孤立森林代码"><a href="#添加并行处理的一维孤立森林代码" class="headerlink" title="添加并行处理的一维孤立森林代码"></a>添加并行处理的一维孤立森林代码</h4><ol>
<li><strong>并行化建树过程</strong>：使用 <code>Parallel.For</code> 来并行构建多棵孤立树，提高了建模过程的效率。</li>
<li><strong>并行化计算异常得分</strong>：在计算异常得分时，使用 <code>Parallel.For</code> 来并行处理每个数据点，从而加速了异常检测过程。</li>
</ol>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> SplitValue &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode Left &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode Right &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> IsLeaf &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Size &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        IsLeaf = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">IsolationTree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">BuildTree</span>(<span class="params">List&lt;<span class="built_in">double</span>&gt; data, <span class="built_in">int</span> currentHeight, <span class="built_in">int</span> maxHeight</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (currentHeight &gt;= maxHeight || data.Count &lt;= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode</span><br><span class="line">            &#123;</span><br><span class="line">                IsLeaf = <span class="literal">true</span>,</span><br><span class="line">                Size = data.Count</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">double</span> min = data.Min();</span><br><span class="line">        <span class="built_in">double</span> max = data.Max();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (min == max)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode</span><br><span class="line">            &#123;</span><br><span class="line">                IsLeaf = <span class="literal">true</span>,</span><br><span class="line">                Size = data.Count</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">double</span> splitValue = min + rand.NextDouble() * (max - min);</span><br><span class="line">        <span class="keyword">var</span> left = data.Where(<span class="keyword">value</span> =&gt; <span class="keyword">value</span> &lt; splitValue).ToList();</span><br><span class="line">        <span class="keyword">var</span> right = data.Where(<span class="keyword">value</span> =&gt; <span class="keyword">value</span> &gt;= splitValue).ToList();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeNode</span><br><span class="line">        &#123;</span><br><span class="line">            SplitValue = splitValue,</span><br><span class="line">            Left = BuildTree(left, currentHeight + <span class="number">1</span>, maxHeight),</span><br><span class="line">            Right = BuildTree(right, currentHeight + <span class="number">1</span>, maxHeight)</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">PathLength</span>(<span class="params">TreeNode node, <span class="built_in">double</span> point, <span class="built_in">int</span> currentHeight</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.IsLeaf)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> currentHeight + c(node.Size);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (point &lt; node.SplitValue)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> PathLength(node.Left, point, currentHeight + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> PathLength(node.Right, point, currentHeight + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">c</span>(<span class="params"><span class="built_in">int</span> n</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">int</span>)(<span class="number">2</span> * (Math.Log(n - <span class="number">1</span>) + <span class="number">0.5772156649</span>) - (<span class="number">2.0</span> * (n - <span class="number">1</span>) / n));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">IsolationForest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;TreeNode&gt; trees;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> maxSamples;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> maxTreeHeight;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IsolationForest</span>(<span class="params"><span class="built_in">int</span> nTrees, <span class="built_in">int</span> maxSamples</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        trees = <span class="keyword">new</span> List&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">this</span>.maxSamples = maxSamples;</span><br><span class="line">        <span class="keyword">this</span>.maxTreeHeight = (<span class="built_in">int</span>)Math.Ceiling(Math.Log(maxSamples, <span class="number">2</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nTrees; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            trees.Add(<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fit</span>(<span class="params">List&lt;<span class="built_in">double</span>&gt; data</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Parallel.For(<span class="number">0</span>, trees.Count, i =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> sample = SampleData(data, maxSamples);</span><br><span class="line">            trees[i] = IsolationTree.BuildTree(sample, <span class="number">0</span>, maxTreeHeight);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">double</span>[] <span class="title">AnomalyScore</span>(<span class="params">List&lt;<span class="built_in">double</span>&gt; data</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">double</span>[] scores = <span class="keyword">new</span> <span class="built_in">double</span>[data.Count];</span><br><span class="line">        Parallel.For(<span class="number">0</span>, data.Count, i =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">double</span> avgPathLength = trees.AsParallel().Average(tree =&gt; IsolationTree.PathLength(tree, data[i], <span class="number">0</span>));</span><br><span class="line">            scores[i] = Math.Pow(<span class="number">2</span>, -avgPathLength / c(maxSamples));</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> scores;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;<span class="built_in">double</span>&gt; <span class="title">SampleData</span>(<span class="params">List&lt;<span class="built_in">double</span>&gt; data, <span class="built_in">int</span> sampleSize</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> data.OrderBy(x =&gt; rand.Next()).Take(sampleSize).ToList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="built_in">double</span> <span class="title">c</span>(<span class="params"><span class="built_in">int</span> n</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * (Math.Log(n - <span class="number">1</span>) + <span class="number">0.5772156649</span>) - <span class="number">2.0</span> * (n - <span class="number">1</span>) / n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;<span class="built_in">double</span>&gt; data = <span class="keyword">new</span> List&lt;<span class="built_in">double</span>&gt; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建并训练孤立森林模型</span></span><br><span class="line">        IsolationForest iforest = <span class="keyword">new</span> IsolationForest(nTrees: <span class="number">100</span>, maxSamples: <span class="number">256</span>);</span><br><span class="line">        iforest.Fit(data);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算异常得分</span></span><br><span class="line">        <span class="built_in">double</span>[] scores = iforest.AnomalyScore(data);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; scores.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;Data point <span class="subst">&#123;i + <span class="number">1</span>&#125;</span>: Anomaly Score = <span class="subst">&#123;scores[i]&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>常用于网络流量异常检测、工业故障检测等领域</p>
<ul>
<li><p>网络流量异常检测</p>
<p>首先，对网络流量数据进行特征提取，例如数据包大小、流量速率、协议类型、源和目的 IP 地址等。然后将这些特征数据输入到孤立森林模型中。正常的网络流量模式往往具有相似的特征，需要较多的分割才能被孤立；而异常的流量，如 DDoS 攻击、非法访问等，由于其特征与正常流量差异较大，可能在孤立树中较浅的层次就被孤立出来。通过分析数据点在孤立森林中的路径长度，可以判断其是否为异常流量。</p>
</li>
<li><p>工业故障检测</p>
<p>在工业故障检测方面，例如对于一条生产线，收集诸如设备温度、压力、转速、能耗等参数作为特征。正常运行时，这些参数会在一定范围内稳定变化，形成一种常见的模式。当出现故障时，某些参数可能会偏离正常范围。将这些参数数据输入孤立森林模型，故障状态所对应的特征组合可能更容易被孤立，从而被检测为异常，实现故障的早期发现和预警。</p>
</li>
</ul>
<h3 id="其他更高级的算法"><a href="#其他更高级的算法" class="headerlink" title="其他更高级的算法"></a>其他更高级的算法</h3><p><strong>DNN（Deep Neural Network）</strong>：</p>
<ul>
<li><strong>原理</strong>：DNN是一种深度学习模型，由多个隐藏层组成的神经网络。它通过学习数据的复杂非线性关系来进行异常检测。</li>
<li><strong>优点</strong>：DNN可以学习数据中的高阶特征和复杂模式，适用于处理大规模、高维度的数据集。</li>
<li><strong>缺点</strong>：DNN需要大量的标记数据进行训练，且模型复杂度高，训练时间长。</li>
</ul>
<p><strong>OneClass-SVM（One-Class Support Vector Machine）</strong>：</p>
<ul>
<li><strong>原理</strong>：OneClass-SVM是一种支持向量机模型，用于从单一类别的数据中学习正常样本的边界，然后识别与正常样本差异较大的异常点。</li>
<li><strong>优点</strong>：OneClass-SVM不需要异常点的标记数据，只需要正常样本进行训练，适用于非常规数据集的异常检测。</li>
<li><strong>缺点</strong>：OneClass-SVM对参数的选择敏感，可能需要调优。</li>
</ul>
<p><strong>AutoEncoder（自编码器）</strong>：</p>
<ul>
<li><strong>原理</strong>：AutoEncoder是一种神经网络模型，用于学习数据的压缩表示，然后重构输入数据。异常点通常在重构误差较大的数据点中被识别为异常。</li>
<li><strong>优点</strong>：AutoEncoder可以自动学习数据的特征表示，适用于无监督学习的异常检测。</li>
<li><strong>缺点</strong>：AutoEncoder的性能受到数据分布的影响，对于高度非线性的数据集可能表现不佳。</li>
</ul>
<h1 id="回归分析"><a href="#回归分析" class="headerlink" title="回归分析"></a>回归分析</h1><p>在统计学中，回归分析是一种用来探讨一个或多个自变量与因变量之间关系的方法。回归分析旨在了解自变量对因变量的影响程度，以及预测因变量的数值。回归分析可以帮助我们理解变量之间的关联性，并用于预测和解释数据。</p>
<p>曲线拟合和回归分析都是统计学中常用的方法，用于探索变量之间的关系。曲线拟合是指通过拟合一个数学模型来描述变量之间的关系，通常用于找到最能代表数据分布的曲线或函数。而回归分析则是一种更广泛的方法，用于研究自变量与因变量之间的关系，并通过建立回归方程来预测或解释因变量的数值。 </p>
<p>在某些情况下，曲线拟合可以被看作是回归分析的一种特例，特别是当我们试图拟合一个曲线来描述自变量和因变量之间的关系时</p>
<h2 id="线性拟合"><a href="#线性拟合" class="headerlink" title="线性拟合"></a>线性拟合</h2><p>线性拟合是一种统计学和数学中常用的方法，用于找到一条最佳拟合直线来描述两个变量之间的关系。在线性拟合中，我们尝试找到一条直线，使得该直线与数据点的残差（实际观测值与拟合值之间的差异）之和最小</p>
<p>性拟合通常用于分析两个变量之间的线性关系，例如通过一组数据点来找到最佳拟合直线，以便预测未来的数值或者对数据进行建模。线性拟合的目标是找到最佳拟合直线的斜率和截距，以最好地描述数据点之间的关系。</p>
<h3 id="最小二乘法"><a href="#最小二乘法" class="headerlink" title="最小二乘法"></a>最小二乘法</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 线性回归预测下一个值</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;data&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">double</span> <span class="title">PredictNextValue</span>(<span class="params">List&lt;<span class="built_in">double</span>&gt; data</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">double</span> sumX = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">double</span> sumY = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">double</span> sumXY = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">double</span> sumXSquare = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> n = data.Count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sumX += i;</span><br><span class="line">        sumY += data[i];</span><br><span class="line">        sumXY += i * data[i];</span><br><span class="line">        sumXSquare += i * i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">double</span> slope = (n * sumXY - sumX * sumY) / (n * sumXSquare - sumX * sumX);</span><br><span class="line">    <span class="built_in">double</span> intercept = (sumY - slope * sumX) / n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预测下一个点的值</span></span><br><span class="line">    <span class="built_in">double</span> nextX = n;</span><br><span class="line">    <span class="built_in">double</span> nextY = slope * nextX + intercept;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nextY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="图算法"><a href="#图算法" class="headerlink" title="图算法"></a>图算法</h1><ul>
<li>DFS 深度优先搜索</li>
<li>BFS 广度优先搜索</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202401291217810.gif" alt="bfsanddfs" style="zoom: 67%;" />

<p>BFS 可以用来求<strong>最短路径问题</strong></p>
<p>DFS 常用来处理<a href="#%E5%85%A8%E6%8E%92%E5%88%97">全排列问题</a></p>
<blockquote>
<p>这里提一嘴:深度优先遍历、递归、栈，它们三者的关系，我个人以为它们背后统一的逻辑都是「后进先出」</p>
<p>图算法本质上是二叉树算法的延续</p>
</blockquote>
<h2 id="Union-Find并查集算法"><a href="#Union-Find并查集算法" class="headerlink" title="Union Find并查集算法"></a>Union Find并查集算法</h2><h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><blockquote>
<p><strong>回溯法</strong> 采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：</p>
<p><strong>回溯算法本质就是一种暴力穷举算法</strong>,虽然效率低,但是简单</p>
<p>回溯算法一般不会让你求最值,而是用于罗列所有无重叠的子结果</p>
<ul>
<li><p>回溯算法和dfs的区别:</p>
<p>DFS 是一个劲的往某一个方向搜索，而回溯算法建立在 DFS 基础之上的，但不同的是在搜索过程中，达到结束条件后，恢复状态，回溯上一层，再次搜索。因此回溯算法与 DFS 的区别就是有无状态重置</p>
</li>
<li><p>何时使用回溯算法:</p>
<p>当问题需要 “回头”，以此来查找出所有的解的时候，使用回溯算法。即满足结束条件或者发现不是正确路径的时候(走不通)，要撤销选择，回退到上一个状态，继续尝试，直到找出所有解为止</p>
</li>
<li></li>
</ul>
</blockquote>
<ul>
<li>找到一个可能存在的正确的答案；</li>
<li>在尝试了所有可能的分步方法后宣告该问题没有答案。</li>
</ul>
<p>「回溯算法」强调了「深度优先遍历」思想的用途，用一个 不断变化 的变量，在尝试各种可能的过程中，搜索需要的结果。强调了 回退 操作对于搜索的合理性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//回溯算法框架伪代码</span></span><br><span class="line">List&lt;Value&gt; result;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(路径,选择列表)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(满足结束条件)&#123;</span><br><span class="line">        result.<span class="built_in">add</span>(路径);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(选择:选择列表)&#123;</span><br><span class="line">        做选择;</span><br><span class="line">        <span class="built_in">backtrack</span>(路径,选择列表);</span><br><span class="line">        撤销选择;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归之后需要做和递归之前相同的逆向操作,实例可以参考<a href="#%E5%85%A8%E6%8E%92%E5%88%97">全排列问题</a></p>
<blockquote>
<p>可以使用<strong>排列树</strong>和<strong>子集树</strong>来理解回溯算法      <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets/?envType=study-plan-v2&envId=top-100-liked">子集树参考78.子集</a>     <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations/description/?envType=study-plan-v2&envId=top-100-liked">排列树参考46.全排列</a></p>
<p>下图中:最上方为<strong>N叉树</strong>,左下角为<strong>子集树</strong>,右下角为<strong>排列树</strong></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202402061312311.png" alt="tree"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://www.bilibili.com/video/BV1YZ4y1H7TU" alt="该视频讲解得非常透彻|720x360"></p>
<h1 id="引力模拟算法"><a href="#引力模拟算法" class="headerlink" title="引力模拟算法"></a>引力模拟算法</h1><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1THubzPEEp">优质视频参考</a></p>
<h1 id="一些算法技巧"><a href="#一些算法技巧" class="headerlink" title="一些算法技巧"></a>一些算法技巧</h1><h2 id="double类型带容差的哈希判断"><a href="#double类型带容差的哈希判断" class="headerlink" title="double类型带容差的哈希判断"></a>double类型带容差的哈希判断</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">UI.Application.Share.Helper</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 支持容差的double比较器</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DoubleToleranceComparer</span> : <span class="title">IEqualityComparer</span>&lt;<span class="title">double</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">double</span> _tolerance;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DoubleToleranceComparer</span>(<span class="params"><span class="built_in">double</span> tolerance</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (tolerance &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">&quot;容差不能为负数&quot;</span>, <span class="keyword">nameof</span>(tolerance));</span><br><span class="line">            _tolerance = tolerance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Equals</span>(<span class="params"><span class="built_in">double</span> x, <span class="built_in">double</span> y</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 处理NaN和Infinity的特殊情况</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">double</span>.IsNaN(x) &amp;&amp; <span class="built_in">double</span>.IsNaN(y))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">double</span>.IsInfinity(x) &amp;&amp; <span class="built_in">double</span>.IsInfinity(y))</span><br><span class="line">                <span class="keyword">return</span> x == y; <span class="comment">// 同符号的Infinity才相等</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果其中一个为NaN或Infinity，另一个不是，则不相等</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">double</span>.IsNaN(x) || <span class="built_in">double</span>.IsNaN(y) || <span class="built_in">double</span>.IsInfinity(x) || <span class="built_in">double</span>.IsInfinity(y))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 容差比较</span></span><br><span class="line">            <span class="keyword">return</span> Math.Abs(x - y) &lt;= _tolerance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">GetHashCode</span>(<span class="params"><span class="built_in">double</span> obj</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 处理特殊值</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">double</span>.IsNaN(obj))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// NaN统一返回0</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">double</span>.IsInfinity(obj))</span><br><span class="line">                <span class="keyword">return</span> obj &gt; <span class="number">0</span> ? <span class="built_in">int</span>.MaxValue : <span class="built_in">int</span>.MinValue; <span class="comment">// 正负Infinity分别返回最大最小值</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将double值按容差进行&quot;量化&quot;，确保容差范围内的值有相同的HashCode</span></span><br><span class="line">            <span class="comment">// 使用Math.Round确保容差边界的一致性</span></span><br><span class="line">          	<span class="comment">// 先把 double 值除以容差，得到它在“第几个容差区间”;对结果四舍五入，得到最近的区间编号;再乘回容差,得到这个区间的&quot;中心数&quot;,用这个“区间中心值”来生成哈希码。这样，只要两个 double 落在同一个容差区间，它们的 HashCode 就一样</span></span><br><span class="line">            <span class="built_in">double</span> quantized = Math.Round(obj / _tolerance) * _tolerance;</span><br><span class="line">            <span class="keyword">return</span> quantized.GetHashCode();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>先把 double 值除以容差，得到它在“第几个容差区间”</p>
<p>如：<code>obj = 1.23，_tolerance = 0.1</code>，则 <code>1.23 / 0.1 = 12.3</code></p>
</li>
<li><p>对结果四舍五入，得到最近的区间编号</p>
<p><code>Math.Round(12.3) = 12</code>，表示 1.23 属于第 12 个容差区间</p>
</li>
<li><p>再乘回容差，得到这个区间的“中心值”</p>
<p><code>12 * 0.1 = 1.2</code>，所以 1.23 被归到 1.2 这个区间</p>
</li>
<li><p>用这个“区间中心值”来生成哈希码。这样，只要两个 double 落在同一个容差区间，它们的 HashCode 就一样。</p>
</li>
</ul>
<h2 id="异或运算"><a href="#异或运算" class="headerlink" title="异或运算"></a>异或运算</h2><ul>
<li>0 ⊕ 0 &#x3D; 0</li>
<li>1 ⊕ 0 &#x3D; 1</li>
<li>0 ⊕ 1 &#x3D; 1</li>
<li>1 ⊕ 1 &#x3D; 0</li>
</ul>
<ol>
<li>任何数和0做异或运算，结果仍然是原来的数，即:${a\oplus0&#x3D;a}$</li>
<li>任何数和其自身做异或运算，结果是0，即:${a\oplus a&#x3D;0}$</li>
<li>异或运算满足交换律和结合律，即:$a\oplus b\oplus a&#x3D;b\oplus a\oplus a&#x3D;b\oplus(a\oplus a)&#x3D;b\oplus0&#x3D;b$</li>
</ol>
<p>针对<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/single-number/description/">leetcode该题</a></p>
<blockquote>
<p>给你一个 <strong>非空</strong> 整数数组 <code>nums</code> ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
</blockquote>
<p>解法如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res^=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Boyer-Moore投票算法"><a href="#Boyer-Moore投票算法" class="headerlink" title="Boyer-Moore投票算法"></a>Boyer-Moore投票算法</h2><p>如果一个数组有大于一半的数相同，那么任意删去两个不同的数字，新数组还是会有相同的性质(即数组有大于一半的数相同)</p>
<p>思路详解:</p>
<blockquote>
<p><strong>同归于尽消杀法</strong> ：</p>
<p>由于多数超过50%, 比如100个数，那么多数至少51个，剩下少数是49个。</p>
<ol>
<li>第一个到来的士兵，直接插上自己阵营的旗帜占领这块高地，此时领主 winner 就是这个阵营的人，现存兵力 count &#x3D; 1。</li>
<li>如果新来的士兵和前一个士兵是同一阵营，则集合起来占领高地，领主不变，winner 依然是当前这个士兵所属阵营，现存兵力 count++；</li>
<li>如果新来到的士兵不是同一阵营，则前方阵营派一个士兵和它同归于尽。 此时前方阵营兵力count –。（即使双方都死光，这块高地的旗帜 winner 依然不变，因为已经没有活着的士兵可以去换上自己的新旗帜）</li>
<li>当下一个士兵到来，发现前方阵营已经没有兵力，新士兵就成了领主，winner 变成这个士兵所属阵营的旗帜，现存兵力 count ++。</li>
</ol>
<p>就这样各路军阀一直以这种以一敌一同归于尽的方式厮杀下去，直到少数阵营都死光，那么最后剩下的几个必然属于多数阵营，winner 就是多数阵营。（多数阵营 51个，少数阵营只有49个，死剩下的2个就是多数阵营的人）</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/majority-element/description/">针对题型</a></p>
<p>最优解法如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> winner=<span class="number">1e9</span><span class="number">+1</span>;</span><br><span class="line">        <span class="type">int</span> score=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=winner)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(score&gt;<span class="number">0</span>)</span><br><span class="line">                    score--;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    winner=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                score++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> winner;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><p>链表中如何在一次遍历中找到中间节点,可以使用快慢指针</p>
<blockquote>
<p>慢指针一次走一步，快指针一次走两步，快慢指针同时出发。当快指针移动到链表的末尾时，慢指针恰好到链表的中间。<strong>通过慢指针将链表分为两部分</strong></p>
</blockquote>
<p>适用于所有链表的比例定位问题</p>
<h3 id="Floyd判圈算法"><a href="#Floyd判圈算法" class="headerlink" title="Floyd判圈算法"></a>Floyd判圈算法</h3><p>问题：如何检测一个链表是否有环，如果有，那么如何确定环的起点？如何确定环的长度？</p>
<blockquote>
<p><strong>「Floyd 判圈算法」（又称龟兔赛跑算法）</strong></p>
<p>Floyd判圈算法(Floyd Cycle Detection Algorithm)，又称龟兔赛跑算法(Tortoise and Hare Algorithm)，是一个可以在有限状态机、迭代函数或者链表上判断是否存在环，求出该环的起点与长度的算法。该算法据高德纳称由美国科学家罗伯特·弗洛伊德发明。</p>
<p>假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。</p>
</blockquote>
<p>原理理解:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://www.youtube.com/watch?v=PvrxZaH_eZ4" alt="Floyd算法原理|720x360"></p>
<p>参阅上面视频,公式推导得到以下定理:</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202312261550430.png" alt="image-20231226154955021" style="zoom:67%;" />

<ol>
<li>有限时间内都从起点出发,快慢指针必然相遇且相遇点在环上:一定会相遇是基于有一个指针每个节点都走到了</li>
<li>在环上相遇的等速指针必定在环的入口处相遇  &#x3D;&#x3D;推导&#x3D;&gt;  [1找到的相遇点]和起点的等速指针将在环的入口处相遇</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2//202312261458055.jpeg" alt="imageTmp" style="zoom:33%;" />

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/龟兔赛跑算法.gif" style="zoom:50%;" />

<ul>
<li>判断是否有环</li>
</ul>
<p>定义两个指针p1与p2，起始时，都指向链表的起点A，p1每次移动1个长度，p2每次移动2个长度。如果p2在移到链表的尾端时，并未与p1相遇，表明链表中不存在环。如果p1与p2相遇在环上的某一点C，表明链表有环。</p>
<ul>
<li>环的长度</li>
</ul>
<p>将指针p1固定在相遇位置C，从C点移动p2，每次移动1个长度，并用变量<code>cnt</code>计数。当p2再次与p1相遇时，此时<code>cnt</code>的值就是环的长度。</p>
<ul>
<li>环的起点</li>
</ul>
<p>环的起点即图中点B，将指针p1指向链表的起始位置A，指针p2仍在位置C，指针p1与p2每次均移动一个单位，p1与p2再次相遇的位置就是环的起点位置点B。</p>
<p>还有更高效率的做法:Brent的移动的兔子和传送的乌龟,<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/413900856">参阅此链接</a></p>
<h2 id="链表中的哑节点"><a href="#链表中的哑节点" class="headerlink" title="链表中的哑节点"></a>链表中的哑节点</h2><p>哑节点的意义:</p>
<ol>
<li><p>简化插入和删除操作：哑节点可以作为链表的起始节点，使得插入和删除操作在任意位置都可以统一处理。无论是在链表头部、中间还是尾部插入或删除节点，都不需要特殊处理边界情况。</p>
</li>
<li><p>处理空链表：当链表为空时，哑节点可以作为链表的唯一节点，避免了对空链表的额外判断和处理。这样，在处理链表时，不需要单独考虑链表为空的情况。</p>
</li>
<li><p>简化遍历操作：哑节点可以作为链表的起始节点，使得遍历链表时不需要对头节点进行特殊处理。遍历操作可以从哑节点的下一个节点开始，一直遍历到链表的末尾。</p>
</li>
<li><p>提高代码的一致性和可读性：通过使用哑节点，链表的操作可以统一处理，减少了重复的代码和特殊情况的处理，使得代码更加简洁、一致和易于理解。</p>
</li>
</ol>
<p>需要注意的是，哑节点并不存储实际的数据，它的存在仅仅是为了简化链表的操作。在实际应用中，根据具体的需求和场景，可以选择在链表的头部或尾部添加哑节点。</p>
<p>使用哑节点的<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-sorted-lists/description/">问题</a>代码案例:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//新建哑节点作为结果链表返回</span></span><br><span class="line">        ListNode* res=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">//动态指针永远指向结果链表最后一个位置</span></span><br><span class="line">        ListNode* curRes=res;</span><br><span class="line">        <span class="keyword">while</span>(list1&amp;&amp;list2)&#123;<span class="comment">//只要有一个链表走到末尾,就退出循环</span></span><br><span class="line">            <span class="keyword">if</span>(list1-&gt;val&gt;list2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                curRes-&gt;next=list2;</span><br><span class="line">                list2=list2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                curRes-&gt;next=list1;</span><br><span class="line">                list1=list1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            curRes=curRes-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        curRes-&gt;next=list1==<span class="literal">NULL</span>?list2:list1;<span class="comment">//补上未空链表</span></span><br><span class="line">        <span class="keyword">return</span> res-&gt;next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><p>可以将<code>求子数组的和为k</code>问题转化为<code>求解两个前缀和之差等于k</code>的问题,通过这种方式在某些题型中可以降低一维</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subarray-sum-equals-k/description/">题型参考</a></p>
<p>解法如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        参考:前缀和 + 哈希表优化</span></span><br><span class="line"><span class="comment">        将求子数组的和为k问题转化为求解两个前缀和之差等于k的情况</span></span><br><span class="line"><span class="comment">        使用一个哈希表来存储每个前缀和出现的次数</span></span><br><span class="line"><span class="comment">        对于任意的两个下标i和j（i &lt; j），如果prefixSum[j] - prefixSum[i] = k，即从第i个位置到第j个位置的元素之和等于k，那么说明从第i+1个位置到第j个位置的连续子数组的和为k，此时计数+1。</span></span><br><span class="line"><span class="comment">        通过遍历数组，计算每个位置的前缀和，并使用一个哈希表来存储每个前缀和出现的次数。在遍历的过程中，我们检查是否存在prefixSum[j] - k的前缀和，如果存在，说明从某个位置到当前位置的连续子数组的和为k，我们将对应的次数累加到结果中。</span></span><br><span class="line"><span class="comment">        93/93 cases passed (76 ms)</span></span><br><span class="line"><span class="comment">        Your runtime beats 56.29 % of cpp submissions</span></span><br><span class="line"><span class="comment">        Your memory usage beats 44.43 % of cpp submissions (41 MB)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; prefixSum;<span class="comment">//// key为前缀和,value为该和出现的次数</span></span><br><span class="line">        prefixSum[<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//// 初始化：前缀和为0出现的次数为1:如果没有这个初始化，那么sum-k=0时，map中没有0，判断为false，就会漏掉这种情况</span></span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">            <span class="comment">//判断是是否存在和为k的值</span></span><br><span class="line">            <span class="keyword">if</span>(prefixSum.<span class="built_in">find</span>(sum-k)!=prefixSum.<span class="built_in">end</span>())</span><br><span class="line">                res+=prefixSum[sum-k];</span><br><span class="line">            <span class="comment">// if(prefixSum.find(sum)==prefixSum.end())</span></span><br><span class="line">            <span class="comment">//     prefixSum[sum]=1;</span></span><br><span class="line">            <span class="comment">// else</span></span><br><span class="line">            <span class="comment">//     prefixSum[sum]+=1;</span></span><br><span class="line">            <span class="comment">//上面注释的代码实际上一句就搞定了</span></span><br><span class="line">            prefixSum[sum]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="差分数组"><a href="#差分数组" class="headerlink" title="差分数组"></a>差分数组</h2><h2 id="荷兰国旗问题"><a href="#荷兰国旗问题" class="headerlink" title="荷兰国旗问题"></a>荷兰国旗问题</h2><blockquote>
<p>Dutch National Flag Problem 荷兰国旗问题，该问题由荷兰计算机科学家Dijkstra所提出</p>
</blockquote>
<p>怎么对一组数做划分,左边都小于他,右边都大于他,中间都等于他(不要求有序,只要求对数组进行划分)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202401171202150.png" alt="iShot_2024-01-17_12.01.13_magic"></p>
<p>参考leetcode的<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-colors/">75. 颜色分类</a></p>
<p>解决代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双指针,转移+修正</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sortColors</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> p0=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> p2=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;=p2;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i],nums[p0]);</span><br><span class="line">                p0++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i],nums[p2]);</span><br><span class="line">                p2--;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="巧妙的递归解法思路盘点"><a href="#巧妙的递归解法思路盘点" class="headerlink" title="巧妙的递归解法思路盘点"></a>巧妙的递归解法思路盘点</h1><h2 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/description/">题目参考</a></p>
<p>递归解法:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比较两棵树是否对称二叉树		</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(TreeNode *p, TreeNode *q)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!p &amp;&amp; !q)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (!p || !q)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   		<span class="comment">//p和q都不为NULL才可能走到这里</span></span><br><span class="line">      <span class="keyword">return</span> p-&gt;val == q-&gt;val &amp;&amp; <span class="built_in">check</span>(p-&gt;left, q-&gt;right) &amp;&amp; <span class="built_in">check</span>(p-&gt;right, q-&gt;left);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//判断树是否是二叉树</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">check</span>(root, root);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>该题思路的重点在于将一棵树,当成两棵树来比较</p>
<p>图解如下:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2//202312271758349.png" alt="image-20231227175839296" style="zoom: 25%;" /><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2//202312271754984.png" alt="image-20231227175442449" style="zoom: 25%;" /><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2//202312271758320.png" alt="image-20231227175855828" style="zoom: 25%;" /><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2//202312271800043.png" alt="image-20231227180002117" style="zoom:25%;" /></p>
<hr>
<p>改成迭代方式代码如下:  (比较抽象)</p>
<blockquote>
<p>引入一个队列，这是把递归程序改写成迭代程序的常用方法。初始化时我们把根节点入队两次。每次提取两个结点并比较它们的值（队列中每两个连续的结点应该是相等的，而且它们的子树互为镜像），然后将两个结点的左右子结点按相反的顺序插入队列中。当队列为空时，或者我们检测到树不对称（即从队列中取出两个不相等的连续结点）时，该算法结束。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(TreeNode *u, TreeNode *v)</span> </span>&#123;</span><br><span class="line">        queue &lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(u); q.<span class="built_in">push</span>(v);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            v = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (!u &amp;&amp; !v) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> ((!u || !v) || (u-&gt;val != v-&gt;val)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            q.<span class="built_in">push</span>(u-&gt;left); </span><br><span class="line">            q.<span class="built_in">push</span>(v-&gt;right);</span><br><span class="line"></span><br><span class="line">            q.<span class="built_in">push</span>(u-&gt;right); </span><br><span class="line">            q.<span class="built_in">push</span>(v-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">check</span>(root, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><p><a href="#https://leetcode.cn/problems/permutations/description/">46.全排列</a></p>
<p>伪代码</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2//202401091704999.png" alt="image-20240109170435720"  />

<p>遍历流程</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2//202401091714375.gif" alt="全排列" style="zoom: 33%;" />

<p>代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == nums.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(nums); <span class="comment">// 添加排列方案</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 这里使用交换的原因是因为交换不会破坏本身的元素种类,并且最后一个元素可以天然得到保留,妙不可言</span></span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[x]); <span class="comment">// 交换，将 nums[i] 固定在第 x 位</span></span><br><span class="line">            <span class="built_in">dfs</span>(nums, x + <span class="number">1</span>);       <span class="comment">// 开启固定第 x + 1 位元素</span></span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[x]); <span class="comment">// 恢复交换(配合循环画龙点睛)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>此代码后面使用交换的方式,避免了”检测是否已经重复处理过”的时间复杂度</p>
<h2 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets/description/">78.子集</a></p>
<p>这一题找了半天都没有找到递归规律,看了题解才明白,遂记录下来</p>
<ul>
<li>开始假设输出子集为空子集</li>
<li>遍历数组，对于数组中的每一个整数，每一步都向输出子集中所有子集添加这个整数，并生成新的子集。</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202402021724019.gif" alt="iShot_2024-02-02_16.55.51" style="zoom:50%;" />

<p>gif最后少了一个3的子集,是bug</p>
<p>解法如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res=&#123;&#123;&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; tmp = res;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> item:tmp)&#123;</span><br><span class="line">                item.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                res.<span class="built_in">push_back</span>(item);</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>假设 nums 中的元素个数为n，则 nums 的子集个数为$2^n$。</p>
<p>时间复杂度：$O(n•2^n)$<br>空间复杂度：$O(n•2^n)$</p>
<h1 id="巧妙的算法解决记录"><a href="#巧妙的算法解决记录" class="headerlink" title="巧妙的算法解决记录"></a>巧妙的算法解决记录</h1><h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15.三数之和"></a>15.三数之和</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum/description/">15.三数之和</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; size; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[k]&gt;<span class="number">0</span>)<span class="comment">//因为 nums[j] &gt;= nums[i] &gt;= nums[k] &gt; 0，即 3 个元素都大于 0 ，在此固定指针 k 之后不可能再找到结果了。</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(k&gt;<span class="number">0</span>&amp;&amp;nums[k]==nums[k<span class="number">-1</span>])<span class="comment">//重复元素,跳过</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> i = k<span class="number">+1</span>;<span class="comment">//第二指针</span></span><br><span class="line">            <span class="type">int</span> j = size - <span class="number">1</span>; <span class="comment">// 第三指针</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> sum = nums[k]+nums[i]+nums[j];</span><br><span class="line">                <span class="keyword">if</span> (sum &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">do</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        j--;</span><br><span class="line">                    &#125; <span class="keyword">while</span> (j&gt;i&amp;&amp;nums[j]==nums[j<span class="number">+1</span>]);</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">do</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125; <span class="keyword">while</span> (j&gt;i&amp;&amp;nums[i]==nums[i<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 找到为0的值则插入</span></span><br><span class="line">                    res.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;nums[k], nums[i], nums[j]&#125;);</span><br><span class="line">                    <span class="keyword">do</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125; <span class="keyword">while</span> (j&gt;i&amp;&amp;nums[i]==nums[i<span class="number">-1</span>]);</span><br><span class="line">                    <span class="keyword">do</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        j--;</span><br><span class="line">                    &#125; <span class="keyword">while</span> (j&gt;i&amp;&amp;nums[j]==nums[j<span class="number">+1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>代码执行流程</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202401201059831.gif" alt="三数之和" style="zoom:50%;" />

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum/solutions/11525/3sumpai-xu-shuang-zhi-zhen-yi-dong-by-jyd/">上面代码详解</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum/solutions/284681/san-shu-zhi-he-by-leetcode-solution/">详解参阅leetcode官方</a></p>
<h2 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128.最长连续序列"></a>128.最长连续序列</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-consecutive-sequence/description/">128. 最长连续序列</a></p>
<p>记录的这个代码主要是精彩在一次遍历解决问题</p>
<blockquote>
<ul>
<li>哈希map的key为:  数组中的数,</li>
<li>value为: 遍历到该元素时，如果 key 是某个连续区间的左&#x2F;右端点，则 value 为该连续区间的长度；否则 value 值无意义</li>
</ul>
<p>伪代码:</p>
<p>若数已在哈希表中：跳过不做处理</p>
<p>若是新数加入：</p>
<p>​     取出其左右相邻数已有的连续区间长度 left 和 right</p>
<p>​     计算当前数的区间长度为：cur_length &#x3D; left + right + 1</p>
<p>​     根据 cur_length 更新最大长度 max_length 的值</p>
<p>​     更新区间两端点的长度值</p>
</blockquote>
<p>本质上就是利用map的value来储存正在处理的数以及他左右的数的序列长度,也即是通过value来<strong>动态叠加连续序列长度</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> n : nums ) &#123;</span><br><span class="line">            <span class="keyword">if</span>( m.<span class="built_in">find</span>(n) != m.<span class="built_in">end</span>() ) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> left = m.<span class="built_in">find</span>(n<span class="number">-1</span>) == m.<span class="built_in">end</span>() ? <span class="number">0</span> : m[n<span class="number">-1</span>];</span><br><span class="line">            <span class="type">int</span> right = m.<span class="built_in">find</span>(n<span class="number">+1</span>) == m.<span class="built_in">end</span>() ? <span class="number">0</span> : m[n<span class="number">+1</span>];</span><br><span class="line">            <span class="type">int</span> len = left + right + <span class="number">1</span>;</span><br><span class="line">            m[n] = <span class="number">1</span>;</span><br><span class="line">            m[n-left] = m[n+right] = len;</span><br><span class="line">            result = <span class="built_in">max</span>(result, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="878-第N个神奇数字"><a href="#878-第N个神奇数字" class="headerlink" title="878.第N个神奇数字"></a>878.第N个神奇数字</h2><p>解题思路: 二分查找+容斥原理</p>
<p>a,b找神奇数字,1到x范围内的神奇数字的个数为:<code>x/a+x/b-x/ab</code>,于是就可以使用二分查找不断逼近第n个神奇数字的位置</p>
<p>而x必然是<code>min(a,b)*n</code></p>
<h1 id="待解决"><a href="#待解决" class="headerlink" title="待解决"></a>待解决</h1><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/description">230题</a>使用中序morris遍历算法报栈溢出错误?待解决</p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4" title="头像" alt="头像"></a><div class="post-copyright__author_name">ZEROKO14</div><div class="post-copyright__author_desc">zeroko14's blog</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://che77a38.github.io/posts/%E7%AE%97%E6%B3%95/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://che77a38.github.io/posts/%E7%AE%97%E6%B3%95/')">算法</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://che77a38.github.io/posts/%E7%AE%97%E6%B3%95/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=算法&amp;url=https://che77a38.github.io/posts/%E7%AE%97%E6%B3%95/&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://che77a38.github.io" target="_blank">ZEROKO14的个人博客</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>算法<span class="tagsPageCount">1</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/cmake/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">cmake</div></div></a></div><div class="next-post pull-right"><a href="/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">数据结构</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description">欢迎来到ZEROKO14的个人博客</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">ZEROKO14</h1><div class="author-info__desc">zeroko14's blog</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/che77a38" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8"><span class="toc-number">1.</span> <span class="toc-text">算法入门</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.1.</span> <span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.2.</span> <span class="toc-text">空间复杂度</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0"><span class="toc-number">2.</span> <span class="toc-text">算法概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%BB%BA%E6%A8%A1"><span class="toc-number">2.1.</span> <span class="toc-text">问题建模</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%81%B5%E6%9C%BA"><span class="toc-number">2.1.1.</span> <span class="toc-text">图灵机</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">3.1.</span> <span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">3.2.</span> <span class="toc-text">选择排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">3.3.</span> <span class="toc-text">插入排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">3.4.</span> <span class="toc-text">快速排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">3.5.</span> <span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">3.6.</span> <span class="toc-text">堆排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">3.7.</span> <span class="toc-text">计数排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%8F%E7%9C%A0%E6%8E%92%E5%BA%8F"><span class="toc-number">3.8.</span> <span class="toc-text">随眠排序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">查找算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">4.1.</span> <span class="toc-text">二分查找</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">5.</span> <span class="toc-text">字符串匹配算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#KMP%E7%AE%97%E6%B3%95"><span class="toc-number">5.1.</span> <span class="toc-text">KMP算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90next%E6%95%B0%E7%BB%84%E5%87%BD%E6%95%B0"><span class="toc-number">5.1.1.</span> <span class="toc-text">生成next数组函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kmp%E6%90%9C%E7%B4%A2%E5%87%BD%E6%95%B0"><span class="toc-number">5.1.2.</span> <span class="toc-text">kmp搜索函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BM%E7%AE%97%E6%B3%95"><span class="toc-number">5.2.</span> <span class="toc-text">BM算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9D%8F%E5%AD%97%E7%AC%A6%E8%A7%84%E5%88%99"><span class="toc-number">5.2.1.</span> <span class="toc-text">坏字符规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%BD%E5%90%8E%E7%BC%80%E8%A7%84%E5%88%99"><span class="toc-number">5.2.2.</span> <span class="toc-text">好后缀规则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sunday%E7%AE%97%E6%B3%95"><span class="toc-number">5.3.</span> <span class="toc-text">Sunday算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">5.3.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81"><span class="toc-number">5.3.2.</span> <span class="toc-text">编码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%A7%8D%E7%AE%97%E6%B3%95%E9%97%B4%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">5.4.</span> <span class="toc-text">多种算法间的比较</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="toc-number">6.</span> <span class="toc-text">贪心算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E5%85%AC%E5%BC%8F"><span class="toc-number">7.</span> <span class="toc-text">排列组合公式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%88%97%E5%85%AC%E5%BC%8F"><span class="toc-number">7.1.</span> <span class="toc-text">排列公式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%BB%E9%87%8D"><span class="toc-number">7.1.1.</span> <span class="toc-text">去重</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E5%85%AC%E5%BC%8F"><span class="toc-number">7.2.</span> <span class="toc-text">组合公式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%88%97%E4%B8%8E%E7%BB%84%E5%90%88%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">7.3.</span> <span class="toc-text">排列与组合的关系</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">8.</span> <span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%8E%E5%85%B6%E4%BB%96%E6%80%9D%E6%83%B3%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="toc-number">8.1.</span> <span class="toc-text">动态规划与其他思想的差异</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95%E4%B8%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E2%80%94%E2%80%94%E9%87%8D%E5%8F%A0%E5%AD%90%E9%97%AE%E9%A2%98"><span class="toc-number">8.1.1.</span> <span class="toc-text">分治算法与动态规划——重叠子问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E4%B8%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E2%80%94%E2%80%94%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84"><span class="toc-number">8.1.2.</span> <span class="toc-text">贪心算法与动态规划——最优子结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A5%E8%B5%8C%E5%9C%BA%E7%9A%84%E9%AA%B0%E5%AD%90%E7%AE%97%E6%B3%95%E4%B8%BA%E4%BE%8B"><span class="toc-number">8.2.</span> <span class="toc-text">以赌场的骰子算法为例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A2%9E%E7%9B%8A%E6%A0%A1%E6%AD%A3%E7%AE%97%E6%B3%95"><span class="toc-number">9.</span> <span class="toc-text">增益校正算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95"><span class="toc-number">10.</span> <span class="toc-text">路径规划算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Dijkstra%E7%AE%97%E6%B3%95"><span class="toc-number">10.1.</span> <span class="toc-text">Dijkstra算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%A1%E9%AA%8C%E7%AE%97%E6%B3%95"><span class="toc-number">11.</span> <span class="toc-text">校验算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CRC%E6%A0%A1%E9%AA%8C%E7%AE%97%E6%B3%95"><span class="toc-number">11.1.</span> <span class="toc-text">CRC校验算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CRC16"><span class="toc-number">11.1.1.</span> <span class="toc-text">CRC16</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%A1%E9%AA%8C%E5%92%8C%E8%AE%A1%E7%AE%97"><span class="toc-number">11.2.</span> <span class="toc-text">校验和计算</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%A4%E4%BA%BA%E6%83%8A%E5%8F%B9%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9%E7%AE%97%E6%B3%95"><span class="toc-number">12.</span> <span class="toc-text">令人惊叹的平方根算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B3%E6%96%B9%E6%A0%B9%E5%BF%AB%E9%80%9F%E8%AE%A1%E7%AE%97%E7%AE%97%E6%B3%95"><span class="toc-number">12.1.</span> <span class="toc-text">平方根快速计算算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AD%E7%8E%AF%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-number">13.</span> <span class="toc-text">闭环控制算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#PID%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-number">13.1.</span> <span class="toc-text">PID控制算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PID%E5%85%AC%E5%BC%8F"><span class="toc-number">13.1.1.</span> <span class="toc-text">PID公式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PID%E4%BB%A3%E7%A0%81"><span class="toc-number">13.1.2.</span> <span class="toc-text">PID代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%B0%E6%88%90%E7%9A%84pid%E7%AE%97%E6%B3%95"><span class="toc-number">13.1.3.</span> <span class="toc-text">现成的pid算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PID%E5%8F%98%E7%A7%8D"><span class="toc-number">13.1.4.</span> <span class="toc-text">PID变种</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PID%E5%8F%82%E6%95%B0%E8%AF%84%E4%BC%B0"><span class="toc-number">13.1.5.</span> <span class="toc-text">PID参数评估</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E5%9F%9F%E6%8C%87%E6%A0%87-%E5%8A%A8%E6%80%81%E5%93%8D%E5%BA%94"><span class="toc-number">13.1.5.1.</span> <span class="toc-text">时域指标(动态响应)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%91%E5%9F%9F%E6%8C%87%E6%A0%87-%E9%B2%81%E6%A3%92%E6%80%A7"><span class="toc-number">13.1.5.2.</span> <span class="toc-text">频域指标(鲁棒性)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PID%E8%B0%83%E5%8F%82%E5%8F%82%E8%80%83"><span class="toc-number">13.2.</span> <span class="toc-text">PID调参参考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E4%BA%8E%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-number">13.3.</span> <span class="toc-text">适用于非线性系统的控制算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E7%B3%8A%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-number">13.4.</span> <span class="toc-text">模糊控制算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E9%A2%84%E6%B5%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">13.5.</span> <span class="toc-text">模型预测控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-number">13.6.</span> <span class="toc-text">其他控制算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E5%9B%A0%E5%AD%90PID%E6%8E%A7%E5%88%B6"><span class="toc-number">13.7.</span> <span class="toc-text">多因子PID控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%8F%98%E9%87%8F%E5%B9%B6%E8%A1%8CPID%E6%8E%A7%E5%88%B6"><span class="toc-number">13.7.1.</span> <span class="toc-text">多变量并行PID控制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E4%BA%8EPID%E7%9A%84%E6%B8%A9%E5%BA%A6%E4%BB%BF%E7%9C%9F%E6%A8%A1%E6%8B%9F"><span class="toc-number">13.8.</span> <span class="toc-text">用于PID的温度仿真模拟</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">14.</span> <span class="toc-text">快速傅里叶变换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8Efft%E7%9A%84%E5%BF%AB%E9%80%9F%E5%BF%AB%E9%80%9F%E4%B9%98%E6%B3%95"><span class="toc-number">14.1.</span> <span class="toc-text">基于fft的快速快速乘法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E4%BB%BF%E7%9C%9F%E7%AE%97%E6%B3%95"><span class="toc-number">15.</span> <span class="toc-text">物理仿真算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E5%8A%A8%E5%AD%A6%E7%AE%97%E6%B3%95"><span class="toc-number">15.1.</span> <span class="toc-text">运动学算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%90%91%E8%BF%90%E5%8A%A8%E5%AD%A6"><span class="toc-number">15.1.1.</span> <span class="toc-text">正向运动学</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%90%91%E8%BF%90%E5%8A%A8%E5%AD%A6"><span class="toc-number">15.1.2.</span> <span class="toc-text">反向运动学</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B"><span class="toc-number">15.2.</span> <span class="toc-text">碰撞检测</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FABRIK"><span class="toc-number">15.2.1.</span> <span class="toc-text">FABRIK</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FABRIK%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">15.2.1.1.</span> <span class="toc-text">FABRIK基本原理</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#LQR%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">16.</span> <span class="toc-text">LQR控制器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B7%A5%E4%B8%9A%E4%B8%8A%E7%9A%84%E5%B9%B3%E6%BB%91%E7%AE%97%E6%B3%95"><span class="toc-number">17.</span> <span class="toc-text">工业上的平滑算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%A1%E6%8B%89%E6%A5%9A%E5%B7%B4%E7%AE%97%E6%B3%95"><span class="toc-number">18.</span> <span class="toc-text">卡拉楚巴算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%BB%A4%E6%B3%A2%E5%99%A8"><span class="toc-number">19.</span> <span class="toc-text">滤波器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%BB%A4%E6%B3%A2%E5%99%A8%E4%BB%8B%E7%BB%8D"><span class="toc-number">19.1.</span> <span class="toc-text">常用滤波器介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E5%80%BC%E6%BB%A4%E6%B3%A2"><span class="toc-number">19.2.</span> <span class="toc-text">中值滤波</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E9%98%B6-%CE%B1%CE%B2-%E6%BB%A4%E6%B3%A2"><span class="toc-number">19.3.</span> <span class="toc-text">一阶(αβ)滤波</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%B4%E7%89%B9%E6%B2%83%E6%96%AF%E6%BB%A4%E6%B3%A2"><span class="toc-number">19.4.</span> <span class="toc-text">巴特沃斯滤波</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2"><span class="toc-number">19.5.</span> <span class="toc-text">卡尔曼滤波</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%A2%E5%87%BD%E6%95%B0%E5%9D%8D%E7%BC%A9%E7%AE%97%E6%B3%95"><span class="toc-number">20.</span> <span class="toc-text">波函数坍缩算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%86%B5"><span class="toc-number">20.1.</span> <span class="toc-text">熵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E6%9C%BA%E5%88%B6"><span class="toc-number">20.2.</span> <span class="toc-text">回溯机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">20.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E7%AE%97%E6%B3%95"><span class="toc-number">21.</span> <span class="toc-text">模拟退火算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%B8%9F%E7%BE%A4%E6%A8%A1%E6%8B%9F%E7%AE%97%E6%B3%95"><span class="toc-number">22.</span> <span class="toc-text">鸟群模拟算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%81%BF%E9%9A%9C%E7%AE%97%E6%B3%95"><span class="toc-number">23.</span> <span class="toc-text">避障算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8F%92%E5%80%BC%E7%AE%97%E6%B3%95"><span class="toc-number">24.</span> <span class="toc-text">插值算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC"><span class="toc-number">24.1.</span> <span class="toc-text">线性插值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B7%E6%9D%A1%E6%8F%92%E5%80%BC"><span class="toc-number">24.2.</span> <span class="toc-text">样条插值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E7%AE%97%E6%B3%95"><span class="toc-number">24.3.</span> <span class="toc-text">拉格朗日算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF"><span class="toc-number">24.4.</span> <span class="toc-text">贝塞尔曲线</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E5%BC%8F"><span class="toc-number">24.4.1.</span> <span class="toc-text">公式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF"><span class="toc-number">24.4.2.</span> <span class="toc-text">分段贝塞尔曲线</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9B%B2%E7%BA%BF%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95"><span class="toc-number">25.</span> <span class="toc-text">曲线相关算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B2%E7%BA%BF%E5%B9%B3%E6%BB%91"><span class="toc-number">25.1.</span> <span class="toc-text">曲线平滑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%86%E8%A7%92%E5%B9%B3%E6%BB%91%E7%AE%97%E6%B3%95"><span class="toc-number">25.1.1.</span> <span class="toc-text">圆角平滑算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B6%85%E6%A4%AD%E5%9C%86"><span class="toc-number">25.1.2.</span> <span class="toc-text">超椭圆</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B2%E7%BA%BF%E7%9B%B8%E4%BC%BC%E7%AE%97%E6%B3%95"><span class="toc-number">25.2.</span> <span class="toc-text">曲线相似算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Frechet%E8%B7%9D%E7%A6%BB%E7%AE%97%E6%B3%95"><span class="toc-number">25.2.1.</span> <span class="toc-text">Fréchet距离算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%96%B9%E5%BC%8F"><span class="toc-number">25.2.1.1.</span> <span class="toc-text">计算方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9F%A9%E9%98%B5%E7%9A%84%E5%A1%AB%E5%85%85%E6%AD%A5%E9%AA%A4"><span class="toc-number">25.2.1.1.1.</span> <span class="toc-text">动态规划矩阵的填充步骤</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A1%A8%E6%A0%BC%E7%9A%84%E5%AE%9E%E9%99%85%E6%9E%84%E5%BB%BA%E6%BC%94%E7%A4%BA"><span class="toc-number">25.2.1.1.2.</span> <span class="toc-text">动态规划表格的实际构建演示</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B"><span class="toc-number">25.2.2.</span> <span class="toc-text">递归实现代码案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B2%E7%BA%BF%E6%8A%BD%E7%A8%80"><span class="toc-number">25.3.</span> <span class="toc-text">曲线抽稀</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Douglas-Peucker%E7%AE%97%E6%B3%95"><span class="toc-number">25.3.1.</span> <span class="toc-text">Douglas-Peucker算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-number">25.3.1.1.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%82%E8%B7%9D%E9%99%90%E5%80%BC%E6%B3%95"><span class="toc-number">25.3.2.</span> <span class="toc-text">垂距限值法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B2%E7%BA%BF%E8%B6%8B%E5%8A%BF%E4%B8%AD%E5%BF%83%E7%82%B9"><span class="toc-number">25.4.</span> <span class="toc-text">曲线趋势中心点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-%E6%9B%B2%E7%BA%BF%E6%8B%9F%E5%90%88%E7%AE%97%E6%B3%95%E5%92%8C%E5%87%BD%E6%95%B0%E9%80%BC%E8%BF%91"><span class="toc-number">26.</span> <span class="toc-text">数值分析:曲线拟合算法和函数逼近</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%97%B6%E9%97%B4%E5%BD%92%E6%95%B4"><span class="toc-number">27.</span> <span class="toc-text">动态时间归整</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A6%BB%E7%BE%A4%E7%82%B9-%E5%BC%82%E5%B8%B8%E7%82%B9%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="toc-number">28.</span> <span class="toc-text">离群点&#x2F;异常点查找算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A6%BB%E7%BE%A4%E7%82%B9-%E5%BC%82%E5%B8%B8%E7%82%B9%E4%BB%8B%E7%BB%8D"><span class="toc-number">28.1.</span> <span class="toc-text">离群点&#x2F;异常点介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%BE%E7%82%B9"><span class="toc-number">28.2.</span> <span class="toc-text">难点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">28.3.</span> <span class="toc-text">异常检测算法的分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E7%9A%84%E7%BB%8F%E5%85%B8%E6%80%9D%E6%83%B3%E6%A8%A1%E5%9E%8B"><span class="toc-number">28.4.</span> <span class="toc-text">异常检测的经典思想模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E6%A3%80%E9%AA%8C%E6%96%B9%E6%B3%95"><span class="toc-number">28.4.1.</span> <span class="toc-text">统计检验方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%81%8F%E5%B7%AE%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">28.4.2.</span> <span class="toc-text">基于偏差的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E8%B7%9D%E7%A6%BB%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">28.4.3.</span> <span class="toc-text">基于距离的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%AF%86%E5%BA%A6%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">28.4.4.</span> <span class="toc-text">基于密度的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E2%80%93Autoencoder"><span class="toc-number">28.4.5.</span> <span class="toc-text">深度学习方法–Autoencoder</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9B%98%E7%82%B9"><span class="toc-number">28.5.</span> <span class="toc-text">方法盘点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E5%88%86%E4%BD%8D%E8%B7%9D%E6%B3%95"><span class="toc-number">28.5.1.</span> <span class="toc-text">四分位距法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Z-score"><span class="toc-number">28.5.2.</span> <span class="toc-text">Z-score</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%B1%E7%BA%BF%E5%9B%BE%E6%B3%95"><span class="toc-number">28.5.3.</span> <span class="toc-text">箱线图法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%A4%E7%AB%8B%E6%A3%AE%E6%9E%97%E7%AE%97%E6%B3%95"><span class="toc-number">28.5.4.</span> <span class="toc-text">孤立森林算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%90%86%E8%A7%A3"><span class="toc-number">28.5.4.1.</span> <span class="toc-text">理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4"><span class="toc-number">28.5.4.2.</span> <span class="toc-text">具体步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E6%95%B0%F0%9D%91%90-%F0%9D%91%9B-%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="toc-number">28.5.5.</span> <span class="toc-text">常数𝑐(𝑛)的计算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81"><span class="toc-number">28.5.5.1.</span> <span class="toc-text">实现代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E8%8A%82%E7%82%B9%E7%B1%BB"><span class="toc-number">28.5.5.1.1.</span> <span class="toc-text">定义节点类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E5%AD%A4%E7%AB%8B%E6%A0%91"><span class="toc-number">28.5.5.1.2.</span> <span class="toc-text">构建孤立树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6"><span class="toc-number">28.5.5.1.3.</span> <span class="toc-text">计算路径长度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%BC%82%E5%B8%B8%E5%BE%97%E5%88%86"><span class="toc-number">28.5.5.1.4.</span> <span class="toc-text">计算异常得分</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AD%A4%E7%AB%8B%E6%A3%AE%E6%9E%97%E7%AE%97%E6%B3%95"><span class="toc-number">28.5.5.1.5.</span> <span class="toc-text">使用孤立森林算法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E7%BB%B4%E5%AD%A4%E7%AB%8B%E6%A3%AE%E6%9E%97%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="toc-number">28.5.5.2.</span> <span class="toc-text">一维孤立森林完整代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%80%E7%BB%B4%E5%AD%A4%E7%AB%8B%E6%A3%AE%E6%9E%97%E4%BB%A3%E7%A0%81"><span class="toc-number">28.5.5.3.</span> <span class="toc-text">添加并行处理的一维孤立森林代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">28.5.5.4.</span> <span class="toc-text">适用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%9B%B4%E9%AB%98%E7%BA%A7%E7%9A%84%E7%AE%97%E6%B3%95"><span class="toc-number">28.5.6.</span> <span class="toc-text">其他更高级的算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90"><span class="toc-number">29.</span> <span class="toc-text">回归分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E6%8B%9F%E5%90%88"><span class="toc-number">29.1.</span> <span class="toc-text">线性拟合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95"><span class="toc-number">29.1.1.</span> <span class="toc-text">最小二乘法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE%E7%AE%97%E6%B3%95"><span class="toc-number">30.</span> <span class="toc-text">图算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Union-Find%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-number">30.1.</span> <span class="toc-text">Union Find并查集算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95"><span class="toc-number">31.</span> <span class="toc-text">回溯算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%95%E5%8A%9B%E6%A8%A1%E6%8B%9F%E7%AE%97%E6%B3%95"><span class="toc-number">32.</span> <span class="toc-text">引力模拟算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E7%AE%97%E6%B3%95%E6%8A%80%E5%B7%A7"><span class="toc-number">33.</span> <span class="toc-text">一些算法技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#double%E7%B1%BB%E5%9E%8B%E5%B8%A6%E5%AE%B9%E5%B7%AE%E7%9A%84%E5%93%88%E5%B8%8C%E5%88%A4%E6%96%AD"><span class="toc-number">33.1.</span> <span class="toc-text">double类型带容差的哈希判断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97"><span class="toc-number">33.2.</span> <span class="toc-text">异或运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Boyer-Moore%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95"><span class="toc-number">33.3.</span> <span class="toc-text">Boyer-Moore投票算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88"><span class="toc-number">33.4.</span> <span class="toc-text">快慢指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Floyd%E5%88%A4%E5%9C%88%E7%AE%97%E6%B3%95"><span class="toc-number">33.4.1.</span> <span class="toc-text">Floyd判圈算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%93%91%E8%8A%82%E7%82%B9"><span class="toc-number">33.5.</span> <span class="toc-text">链表中的哑节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-number">33.6.</span> <span class="toc-text">前缀和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84"><span class="toc-number">33.7.</span> <span class="toc-text">差分数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97%E9%97%AE%E9%A2%98"><span class="toc-number">33.8.</span> <span class="toc-text">荷兰国旗问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B7%A7%E5%A6%99%E7%9A%84%E9%80%92%E5%BD%92%E8%A7%A3%E6%B3%95%E6%80%9D%E8%B7%AF%E7%9B%98%E7%82%B9"><span class="toc-number">34.</span> <span class="toc-text">巧妙的递归解法思路盘点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">34.1.</span> <span class="toc-text">对称二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-number">34.2.</span> <span class="toc-text">全排列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%90%E9%9B%86"><span class="toc-number">34.3.</span> <span class="toc-text">子集</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B7%A7%E5%A6%99%E7%9A%84%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E8%AE%B0%E5%BD%95"><span class="toc-number">35.</span> <span class="toc-text">巧妙的算法解决记录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">35.1.</span> <span class="toc-text">15.三数之和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#128-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97"><span class="toc-number">35.2.</span> <span class="toc-text">128.最长连续序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#878-%E7%AC%ACN%E4%B8%AA%E7%A5%9E%E5%A5%87%E6%95%B0%E5%AD%97"><span class="toc-number">35.3.</span> <span class="toc-text">878.第N个神奇数字</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BE%85%E8%A7%A3%E5%86%B3"><span class="toc-number">36.</span> <span class="toc-text">待解决</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/%E7%89%A9%E7%90%86/" title="物理">物理</a><time datetime="2025-09-29T01:48:42.561Z" title="发表于 2025-09-29 09:48:42">2025-09-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/%E5%B7%A5%E4%B8%9A%E7%9B%B8%E5%85%B3/" title="工业相关">工业相关</a><time datetime="2025-02-14T03:04:40.761Z" title="发表于 2025-02-14 11:04:40">2025-02-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3/" title="嵌入式相关">嵌入式相关</a><time datetime="2025-02-14T03:04:40.761Z" title="发表于 2025-02-14 11:04:40">2025-02-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/" title="操作系统">操作系统</a><time datetime="2024-12-16T01:38:01.470Z" title="发表于 2024-12-16 09:38:01">2024-12-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/%E8%AE%A1%E7%BB%84/" title="计算机组成原理">计算机组成原理</a><time datetime="2024-12-16T01:38:01.470Z" title="发表于 2024-12-16 09:38:01">2024-12-16</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2025 By <a class="footer-bar-link" href="/" title="ZEROKO14" target="_blank">ZEROKO14</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu"></a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">74</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">57</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">6</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AI/" style="font-size: 0.88rem;">AI<sup>1</sup></a><a href="/tags/C/" style="font-size: 0.88rem;">C#<sup>3</sup></a><a href="/tags/C/" style="font-size: 0.88rem;">C++<sup>5</sup></a><a href="/tags/CSS/" style="font-size: 0.88rem;">CSS<sup>1</sup></a><a href="/tags/CSharp/" style="font-size: 0.88rem;">CSharp<sup>1</sup></a><a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 0.88rem;">C语言<sup>1</sup></a><a href="/tags/FPS/" style="font-size: 0.88rem;">FPS<sup>1</sup></a><a href="/tags/HTML/" style="font-size: 0.88rem;">HTML<sup>1</sup></a><a href="/tags/JavaScript/" style="font-size: 0.88rem;">JavaScript<sup>1</sup></a><a href="/tags/MFC/" style="font-size: 0.88rem;">MFC<sup>1</sup></a><a href="/tags/PE/" style="font-size: 0.88rem;">PE<sup>1</sup></a><a href="/tags/QT/" style="font-size: 0.88rem;">QT<sup>1</sup></a><a href="/tags/WPF/" style="font-size: 0.88rem;">WPF<sup>3</sup></a><a href="/tags/ai/" style="font-size: 0.88rem;">ai<sup>1</sup></a><a href="/tags/cmake/" style="font-size: 0.88rem;">cmake<sup>1</sup></a><a href="/tags/doxygen/" style="font-size: 0.88rem;">doxygen<sup>1</sup></a><a href="/tags/git/" style="font-size: 0.88rem;">git<sup>1</sup></a><a href="/tags/linux/" style="font-size: 0.88rem;">linux<sup>1</sup></a><a href="/tags/nas/" style="font-size: 0.88rem;">nas<sup>1</sup></a><a href="/tags/next/" style="font-size: 0.88rem;">next<sup>1</sup></a><a href="/tags/ppt/" style="font-size: 0.88rem;">ppt<sup>1</sup></a><a href="/tags/python/" style="font-size: 0.88rem;">python<sup>1</sup></a><a href="/tags/slidev/" style="font-size: 0.88rem;">slidev<sup>1</sup></a><a href="/tags/vue/" style="font-size: 0.88rem;">vue<sup>1</sup></a><a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 0.88rem;">代码规范<sup>1</sup></a><a href="/tags/%E5%86%85%E6%A0%B8/" style="font-size: 0.88rem;">内核<sup>2</sup></a><a href="/tags/%E5%86%85%E6%A0%B8%E7%9B%B8%E5%85%B3/" style="font-size: 0.88rem;">内核相关<sup>5</sup></a><a href="/tags/%E5%8A%A0%E8%A7%A3%E5%AF%86/" style="font-size: 0.88rem;">加解密<sup>1</sup></a><a href="/tags/%E5%9F%BA%E7%A1%80/" style="font-size: 0.88rem;">基础<sup>6</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 0.88rem;">多线程<sup>1</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F/" style="font-size: 0.88rem;">并发模式<sup>1</sup></a><a href="/tags/%E5%BC%80%E5%8F%91/" style="font-size: 0.88rem;">开发<sup>4</sup></a><a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 0.88rem;">数学<sup>1</sup></a><a href="/tags/%E6%9D%82%E9%A1%B9/" style="font-size: 0.88rem;">杂项<sup>1</sup></a><a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 0.88rem;">正则表达式<sup>1</sup></a><a href="/tags/%E7%89%A9%E7%90%86/" style="font-size: 0.88rem;">物理<sup>1</sup></a><a href="/tags/%E7%9B%91%E6%8E%A7/" style="font-size: 0.88rem;">监控<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 0.88rem;">网络<sup>3</sup></a><a href="/tags/%E9%80%86%E5%90%91/" style="font-size: 0.88rem;">逆向<sup>5</sup></a><a href="/tags/%E9%AD%94%E6%B3%95/" style="font-size: 0.88rem;">魔法<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.cbd.int/mathjax@3.2.2/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.cbd.int/mermaid@10.2.4/dist/mermaid.min.js').then(runMermaid)
  }

  anzhiyu.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>