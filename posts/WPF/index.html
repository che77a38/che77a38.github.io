<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>WPF | ZEROKO14的个人博客</title><meta name="keywords" content="WPF,C#"><meta name="author" content="ZEROKO14"><meta name="copyright" content="ZEROKO14"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#18171d"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="WPF"><meta name="application-name" content="WPF"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#18171d"><meta property="og:type" content="article"><meta property="og:title" content="WPF"><meta property="og:url" content="https://che77a38.github.io/posts/WPF/index.html"><meta property="og:site_name" content="ZEROKO14的个人博客"><meta property="og:description" content="WPF是微软推出的一项基于windows操作系统,.net平台的c&amp;#x2F;s客户端构建技术,最大的特征就是可以快速构建项目从而达到节约项目成本的目的.   相关推荐书籍: &amp;lt;&amp;lt;WPF编程宝典使用c#2012和.net4.5 第四版&amp;gt;&amp;gt; &amp;lt;&amp;lt;c#高级编程&amp;gt;"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4"><meta property="article:author" content="ZEROKO14"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4"><meta name="description" content="WPF是微软推出的一项基于windows操作系统,.net平台的c&amp;#x2F;s客户端构建技术,最大的特征就是可以快速构建项目从而达到节约项目成本的目的.   相关推荐书籍: &amp;lt;&amp;lt;WPF编程宝典使用c#2012和.net4.5 第四版&amp;gt;&amp;gt; &amp;lt;&amp;lt;c#高级编程&amp;gt;"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://che77a38.github.io/posts/WPF/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2024/07/27/125766904/ba62475f396df9de3316a08ed9e65d86_5680958632268053399..png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":true,"limitCount":50,"languages":{"author":"作者: ZEROKO14","link":"链接: ","source":"来源: ZEROKO14的个人博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'ZEROKO14的个人博客',
  title: 'WPF',
  postAI: '',
  pageFillDescription: '完整的WPF对象层次结构, Dispatcher, XAML, 对xaml的理解, xmlns, XAML命名空间, 常见特征功能, xClass, xClassModifier, xName, xFieldModifier, xKey 与 xShared, 常见标记拓展功能, xType, xNull, xStatic, 常用指令元素功能, xCode, xData, XAML注释, XAML优点, XAML可视化视觉设计工具, Blend, 设计时特性, 布局, Grid, 嵌套Grid共享宽度, StackPanel, VirtualizingStackPanel, WrapPanel, DockPanel, Canvas, UniformGrid, 控件, 内置的WPF控件, 按钮, 数据显示, 日期显示和选择, 对话框, 数字墨迹, 文档, 输入, 布局, 媒体, 菜单, 导航, 选项, 信息, 依赖属性与普通属性, 属性变化的回调, 依赖属性详解, 自定义依赖属性, DependencyProperty.Register, 只读依赖属性, 依赖属性的继承, 依赖属性的优先级, 附加属性, 附加属性案例, 附加属性与依赖属性使用场景, 一般情况特性, x详解, 容器及其子项的对应, DataGrid详解, DataGrid属性例子, AutoGenerateColumns, 使用DataGrid实现一个全新的TreeGrid, CollectionView, ProgressBar, 虚拟化x2F延迟滚动, TreeView, 主要属性, 常用方法, 使用, 两层案例, 三层案例, 自定义选择层级显示实现案例, 样式模板, TreeView中如何获取选中值, ScrollViewer, Thumb, Popup, 自制Popup, Tooltip, ComboBox, 内部构成, ItemsControl, 简单列表显示案例, 结构体中多成员显示含命令案例, Menu, ContentControl, ContextMenu, PlacementTarget, 案例, 绑定到父级控件的DataContext, BindingProxy, 案例, ListView, ListView中插入自增列案例, TabControl, 自定义子项模板如下, ListBox, ListView, 基本使用案例, 进阶用法案例, CheckBox, 自定义CheckBox, HierarchicalDataTemplate, TextBlock, run标签, label, TextBox, 自定义TextBox, Button, 自定义Button, ToggleButton, 自定义ToggleButton, RichTextBox, 主要属性, 常用属性罗列, Margin, Widthx2FHeight, VerticalAlignmentx2FHorizontalAlignment, 控件组织结构, 逻辑树的结构, 查找控件, FindName, 逻辑树与视觉树, 视觉树, 逻辑树, 自绘控件, 完全自定义窗口, 简易反调试检测, 窗口x2F页面x2F用户控件, 窗口, 自定义拖拽控制窗体大小, 绑定, Binding源的指定, DataSourceProvider, XmlDataProvider, ObjectDataProvider, LINQ查询结果作为数据源, RelativeSource, 绑定解释, Binding路径的指定, 绑定和窗体xmal.cs中操作的区别, 使用绑定需要的步骤, 数据上下文支持变化通知, 绑定xml文件中的值, 绑定控件的方法, ElementNameSourceRelativeSource, ElementName, Source, RelativeSource, 主要模式, Self模式, TemplatedParent模式, FindAncestor模式, PreviousData模式, 控制绑定数据的显示格式, 数据校验与转换, Validation, 案例, INotifyDataErrorInfo, Convert, 案例, 多重绑定, 命令, 命令详解, 如何实现一个命令, ICommand, 如何让控件支持命令, ICommandSource, 开发者如何使用, 如何使用, 事件, 事件处理机制模型, 直接事件, 路由事件, 针对窗口的事件, WPF事件执行顺序, 针对控件和元素的事件, 输入事件, 焦点事件, 布局事件, 数据事件, MVVM项目架构, 如何连接三种文件, 代码分离, 最小MVVM案例, 事件驱动与数据驱动, 事件驱动, 数据驱动, MVVM下代码操作控件, behaviour, 案例, 自定义行为, 自定义行为的实现方式, 使用行为, 案例, MultiDataTrigger, MVVM常见误区, 资源和样式, 静态资源和动态资源, 资源管理形式, 样式, Setter, 样式案例, 全局样式, 定义样式, 引入样式写法, 主题切换方案, 模板, 相关构成, ContentPresenter, TemplateBinding, 模板中的绑定注意项, 控件模板, 触发器, 基本触发器, 多条件触发器, 数据触发器, 多路数据触发器, 事件触发器, 控件模板案例, 数据模板, 数据模板盘点, 层级数据模板, 自定义数据项模板, ObservableCollection, 模板的内部访问, 控件模板的内部访问, 数据模板的内部访问, 属性优先级规则, 自定义控件与用户控件, 用户控件x2F自定义控件案例, ItemsControl, 实现控件自定义所需知识点盘点, 动画, 动画案例, 变换, 渐变画刷写法记录, 子线程中操作ui界面, BindingOperations.EnableCollectionSynchronization, VS默认代码片段记录, wpf相关库, HandyControl, 主要特点, 如何使用 HandyControl, 控件使用方式盘点, 滑动条, 单值滑动条, 范围滑动条, 进度按钮, 数字输入框, 开关按钮, 按钮组, gif显示控件, 时间获取, 对话框, 自定义对话框, 阿里矢量图标库中获取图标, 使用按钮展示几何图形, 使用按钮动态切换几何图形, 切换主题色, Growl, 覆盖默认样式, wpfui, 图表控件库, ScottPlot, ScottPlot常用代码盘点, MSChart, OxyPlot, livechart2, 此处记录一个重置缩放的做法, WPF Suite, 引入库方式, 优化界面布局, 内容过渡效果封装, XamlAnimatedGif, gif显示的手动方法, CommunityToolkit.Mvvm, ValueConverters, 基本使用方式, 串联转换器组使用方式, 串联转换器代码原理参考, CalcBinding, 解读该开源项目, DXBinding, XamlFlair, MaterialDesignThemes, LayUI.Wpf, Dotnet9WPFControls, 混淆工具, FastHotKeyForWPF, System.Configuration.ConfigurationManager, WPF-ControlBase, 动态曲线案例, 示波器, 曲线抽稀, 值得参考的成品项目, 拖拽节点编辑器框架, WPF项目创建向导VS插件, 二进制编辑器控件库, 打包参考, MSIX Packaging, 动画库, WPF引入矢量图, WPF与HTML交互, WebBrowser, 显示相关, js和c交互, JS调用c方法, C调用JS方法, http服务器方式, WebView2, 显示相关, C到JS数据传递, JS调用C方法, 获取返回值, 网页加载时 JavaScript 代码, CefSharp, 使用方式, 显示相关, 显示外部链接, 显示本地html文件, C调用JS方法, 显示控制台, JS调用C方法, 第一个方案, 第二个方案, 现有程序迁移到WEB端, wpf与winform控件互相使用, 捕获全局异常, 无法全局捕获的异常, 快捷键相关, 程序内快捷键, 值得记录的代码, TextBox切换输入与绑定模式, 更好的方式, 这种方法的优点：, 一些技巧盘点, 混淆工具, obfuscar, 安装, 使用, 自定义可被观察容器, ObservableDictionary, 实现思路, 代码是微软推出的一项基于操作系统平台的客户端构建技术最大的特征就是可以快速构建项目从而达到节约项目成本的目的相关推荐书籍编程宝典使用和第四版高级编程精通你必须知道的下载通过使用和跨平台框架可以在上编写和运行类似于的桌面应用程序微软官方教程有前端经验很简单不过的绑定设计的太拉了双向绑定麻烦的要死循环也不好用第一次用没看文档和教程直接写的没法响应式研究了久最后还是在隐藏提示里发现的要用简单的双向绑定还要字段属性双重设计还得在用函数通知看似很美好用起来着实很折寿遍历后传参也麻烦的要死不改进基本没希望了怪不得没人用设计成那种简化版多好参考文章源码参考完整的对象层次结构由于是使用创建的因此类继承的第一个类是对象类此类确保所有对象只能由拥有它的线程直接访问其他不拥有他的线程必须通过对象是线程模型的核心部分它提供了一个机制允许在线程之外执行代码并在适当的时机将代码调度到线程上执行管理着线程的状态包括空闲活动和完成等元素使用格式的表示在任何时候元素都被其他元素包围并且包围的元素可以影响此元素因为这个类才使可能例如如果被包围则背景色很可能被文本框继承这是使具有视觉表示的类此类支持诸如事件输入布局等功能此类支持诸如等功能最后所有控件等任何东西都继承自类下面实现一个简单的实现代码确保程序退出时不阻止主线程结束向指定线程调度任务线程主循环处理调度的任务停止时退出循环停止调度器等待线程结束已经结束则忽略模拟在指定线程上调度任务延迟执行输出如下流程分析图如下上面的代码多个是各自启动一个线程如果想让所有线程中执行的该代码都在调度到同一个线程中执行应该使用单例类确保所有实例共享同一个线程和任务队列单例类管理共享的线程和任务队列使用实现单例模式确保只有一个实例提供对单例实例的访问工作线程用于执行任务队列中的任务任务队列用于存储待执行的任务取消令牌源用于停止工作线程私有构造函数确保外部无法直接实例化初始化任务队列初始化取消令牌源创建工作线程并设置其为后台线程确保程序退出时线程不会阻止主线程结束启动工作线程向指定线程调度任务将任务添加到任务队列中线程主循环处理调度的任务从任务队列中获取任务并执行执行任务捕获任务执行过程中的异常并输出当取消令牌被触发时退出循环停止调度器取消任务执行标记任务队列为完成状态不再接受新任务等待工作线程结束如果线程已经结束则忽略异常释放取消令牌源和任务队列继承自的类共享的实例获取的单例实例向指定线程调度任务通过实例调度任务停止调度器这里不需要释放因为它是一个单例创建两个实例模拟在指定线程上调度任务延迟执行是微软创造的一种新的可扩展应用程序标记语言是中专门用于设计的语言是一种单纯的声明型语言在语言中使用标签声明一个元素每个元素对应内存中的一个对象可以通过标签的语法进一步声明元素的特征和内容物有两种标签表现形式非空标签空标签不仅可以写成上面这样也可以把直接写成标签的形式对的理解将和类对应起来理解只是在描述这些类等同于被包裹其中的内容等同于展开案例此处的是颜色类型等同于此处的实际上是画刷属性展开案例即其一个使用优点是当要引用的来源不同类重名时可以使用命名空间加以区分中命名空间的语法与是不同的在中我们使用关键字在代码顶部调用命名空间在当中的语法格式如下命名空间无映射前缀映射前缀命名空间有映射前缀例子为什么的赋值是一个类似于地址的字符串这种表达是一种统一资源名称使得对于多个命名空间的引用能够集合在一个唯一标识上而创建可读的全局唯一标识符的可靠方法就是使用类似于网站的表达对于一个集合标识的引用声明就包含了对多个命名空间的引用使得代码方便简洁和统一在使用语法声明元素标签时其对应声明的对象与对象之间的关系要么是包含要么是并列关系所以我们又说的语法结构是一种树形的包含或并列结构上面写法只提供了颜色本质上没有提供类型只是纯色没关系如果想要写渐变色却不行因此可以改成下面这种更全能的形式可以指定类型此处指定了类型上面两种写法对应的代码实际上就都是如果使用对一个类的属性进行特征声明那么其逻辑代码中必然要有将特征赋值字符串值转换为属性值的赋值机制在中对特征进行声明使用的是字符串如果要对属性进行复杂赋值或内部精确赋值那么就会使得设计者在为此编写转换机制时十分困难命名空间命名空间是一种用于在标记中引用不同的类型和属性的机制命名空间可以将元素和属性与对应的类和成员映射从而实现对象构造和属性赋值命名空间中包含的工具如下图常见特征功能这个特征功能适用于告诉编译器将当前标签的编译结果与后台中指定的类进行合并在使用这个功能声明时需要满足以下要求此特征功能仅能在根节点声明根节点类型要与所指示的合并类型保持一致所指示的类型在声明时必须使用关键字使得文件和后台代码文件能够合并为一个类从而实现逻辑和界面的分离只能用于根元素并且必须与后台代码文件中的分部类名称一致告诉编译器该便签生成的类具有怎样的访问级别对于整个程序集来说和是等价的对应的文件的窗体类的访问级别也需要改成即需要对应否则就会导致含有冲突访问修饰符的编译错误一般程序中都会包含有一个映射前缀为的命名空间告诉编译器为当前的标签生成一个实例并为这个实例声明一个引用变量它可以为定义的对象指定一个唯一的标识符以便在代码中访问它不仅会为对象创建一个引用变量还会为对象的属性如果有的话赋值并将该值注册到名称范围中名称范围是一种用于查找和引用创建的对象的机制它可以支持数据绑定动画模板等功能与的区别使用场景属性是控件的一个标准属性通常用于为控件指定一个名称以便在代码中引用作用域在中属性只能用于某些控件例如等代码中引用在代码后面中可以直接使用来引用这个按钮使用场景是的一部分属于命名空间的定义提供了一个更通用的方式来为任何元素指定名称作用域可以用于所有元素包括那些没有属性的元素代码中引用在代码后面中同样可以直接使用和来引用它们为引用变量设置访问级别默认情况下字段的访问级别按照面向对象的封装原则被设置成了与可以为定义的资源指定一个唯一的标识符以便在中引用它只能用于资源字典中的对象例如样式模板画刷等你可以使用静态资源标记扩展或动态资源标记扩展来通过引用资源当多次检索到一个对象时若想得到的都是同一个对象则的值设为若想得到的是该对象的多个副本则设置的值为编译器会为资源隐式添加我们经常会把需要多次使用的内容提取出来放到资源词典中需要使用这个资源的时候就是使用对应的检索出来用于指示某个资源或元素是可以在多个地方共享的它的主要用途是在以下情况下资源共享如果有一些资源如图像样式等在多个地方使用设置为共享可以避免重复创建性能优化减少资源的重复加载和初始化常见标记拓展功能用于一些需要指定类型的属性或参数当我们需要引用的不是数据类型的实例而是数据类型本身时就可以使用此标记拓展功能或的值是一个类型的名称可以带有命名空间前缀也可以省略命名空间前缀如果省略则默认使用当前文件的默认命名空间可以用于一些需要指定类型的属性或参数可以显式地对一个特征或属性赋一个空值常用于清除一些设置将背景色置为空值它可以在中表示值没有任何参数只能用于属性语法可以用于一些需要清除或重置属性值的场景例如取消全局样式清除绑定源设置空背景等用于一些需要使用静态字段或属性的属性或参数可以用于一些需要使用静态字段或属性的属性或参数例如常量枚举值资源键等常用指令元素功能可以在中嵌入一些代码以便在文件中实现一些逻辑或事件处理必须用于根元素并且必须包含在节中需要使用语言的转移标签写法为代码内容这个功能几乎没用不符合设计哲学在中定义一个数据源以便在中使用数据绑定或数据模板可以用于一些需要指定数据源的属性或参数例如等注释注释内容的注释只能出现在标签的内容区域的注释不能用于注释掉标签的特征赋值的注释不能嵌套优点通常比等效代码更简洁更易读以更高的视觉清晰度模拟用户界面对象的父子层次结构可由程序员轻松手动编写但也使它成为可视化设计工具的可操作性和生成工具可视化视觉设计工具是一款用于设计应用用户界面的可视化工具用于设计它可以支持拖拽式创建控件与的使用类似可以快速精确地绘制图形界面并自动生成代码使用中视图在中设计从简化的角度来看使用来设计会有哪些冗余细节取值过于精确默认值会被直接写出一般情况下会用于复杂的界面设计和绘图动画创作可以先在里进行绘制再回到的代码中进行调整要保证不影响效果的情况下尽可能提高代码可读性借助快速入门动画以及行为视频讲解设计时特性设计时才能看到的数据源自动提供假数据布局布局控件可以理解为一个容器容器内可以嵌套容器可以嵌套层表格控件堆栈面板自动换行面板固定位置布局画布不常用上述的基本容器都是继承于中源码提及的的概念可以这么理解中的叫就是的生成器表格控件类似中的标签这里定义了纵向的三个空行因为只有一列下面三行实际可写可不写通过设置放在哪一行登录指定行序号指定列序号继承下有很重要的附加属性可以用于设置其内部的控件上下层级顺序注意定义好后空间就划好了没办法通过设置其中控件的为来不占用空间还可以使用来使用分隔条控制布局如下垂直分隔线水平分隔线嵌套共享宽度共享宽度在中的作用是让多个中的列或行共享相同的大小而不是限制内容的大小用于标识需要共享尺寸的列或行通过指定相同的组名如实现跨的尺寸同步仅当列宽或行高为或时生效固定数值如不参与共享需在父容器上设置为声明该容器内的所有子共享同一尺寸作用域父容器可以是等但必须显式设置该属性父容器设置子共享列子同名共享组对于多层嵌套的如主包含多个子每个子又包含其他控件可通过以下结构实现共享子子跨行共享列宽将自身内容横向或纵向排列的容器水平居中设置为横向的这里添加子元素内置的控件将会纵向排列会将子元素按顺序排列因此想要其内部的控件按照来排列不可行支持虚拟化仅渲染可见的子元素未在可视区域内的元素不会被创建这样可以显著提高性能尤其是在处理大量数据时适用于需要显示大量数据的场景如等也是基于因此也支持虚拟化控件自动的在一行里如果需要换行则规定好的布局控件的宽度如果布局内容超出了这个宽度则会自动换行水平居中是中的一种布局容器用于将子控件沿容器的边缘排列允许子控件依次对齐到容器的顶部底部左侧或右侧并且可以让最后一个子控件填充剩余的空间非常适合需要将控件固定在特定位置的布局需求有几个重要的属性可以帮助开发者灵活地控制子控件的排列方式附加属性控制子控件在中的停靠位置取值为或控制最后一个子控件是否填充的剩余空间默认为优点灵活性高允许子控件依次停靠在容器的边缘非常适合需要固定控件位置的布局自动填充可以自动填充剩余空间简化了布局管理直观简单对于需要将控件固定在特定位置的简单布局使用非常直观简单缺点不适合复杂布局对于复杂布局或需要精确控制控件位置的场景的能力有限性能问题在包含大量子控件时可能会导致性能问题因为它需要动态计算控件的位置和大小比较特殊它属于任意布局的一种概念就是你拖控件到上的时候你把它放在哪里它就在哪里这个里面的控件会自动生成等数值均匀分布的网格可以通过和指定网格的行数或列数有效防止宽或高特别大可以通过指定第一个子元素应该放置的列索引这个属性在需要偏移第一个元素的位置时很有用控件在中控件是一个涵盖性术语适用于在窗口中可视化可交互具有用户界面并实现某些行为设计好的控件能给用户带来更好的交互体验控件的基础属性宽高背景色字体颜色字体大小禁用启用显示隐藏等控件显示的值内蓉有的叫等这一些东西基本上不会随着的版本迭代有面目全非的变化所以是可以通过长期使用慢慢积累到控件属性从而掌握它们的使用方式或重写编写自定义控件属性可以给控件起名字得以索引到这个控件控件类关系图内置的控件此处可以参考各种内置控件的实现源码按钮基本的按钮控件用于执行点击事件类似于按钮但会在长按时反复触发点击事件数据显示用于显示和操作表格数据可以进行排序过滤和编辑显示数据集合的控件支持多种视图模式如用于显示层次化数据的控件日期显示和选择显示一个月历用于选择日期提供日期选择功能可以手动输入或通过下拉日历选择对话框用于打开文件的对话框用于打印文件的对话框用于保存文件的对话框数字墨迹提供数字墨迹输入功能的画布展示和管理数字墨迹输入文档查看文档的控件支持多种文档格式分页显示的控件提供阅读和导航的功能滚动显示的控件显示和编辑数字便笺输入单行文本输入控件支持富文本格式的多行文本输入控件用于输入密码的控件输入内容以掩码显示布局绘制边框包含单一子元素显示项目符号和内容允许通过绝对坐标指定子元素位置将子元素停靠在其边缘上下左右可扩展和折叠的面板基于行和列的布局支持复杂排列的视图模式用于显示表格数据允许调整的行和列大小带标题的容器用于分组内容所有布局控件的基类调整窗口大小的控件用于分隔菜单项或工具栏按钮的线条提供滚动功能使子元素内容可滚动将子元素堆叠在一起水平或垂直方向滑块控件的一部分支持拖动缩放和调整子元素大小类似但支持虚拟化提高性能表示一个窗口顺序排列子元素空间不足时自动换行媒体显示图片播放音频或视频播放音频文件的操作菜单右键上下文菜单应用程序主菜单工具栏用于放置工具按钮导航显示和导航内容页面超链接导航到指定表示导航的页面窗口支持导航功能选项卡控件允许切换多个页面选项复选框表示一个开关选项下拉列表允许选择一个项目列表框允许选择一个或多个项目单选按钮成组使用时只能选择一个滑块控件用于选择范围值信息带有快捷键的文本标签显示文本标签弹出窗口进度条显示任务进度状态栏显示应用程序状态信息显示文本内容工具提示显示额外信息依赖属性与普通属性依赖属性是一种特殊的属性系统通常用于应用程序中依赖属性允许属性的值能够从多个来源继承动态更新和通知变化同时提供了一种有效的方式来管理属性值的继承样式化数据绑定和动画赖属性有一个特性当你没有为控件的某个属性显式地赋值时它就会把自己所在容器的属性值拿过来当作自己的属性值依赖属性在主要扮演数据驱动中的重要角色它能配合绑定一起实时数据更新显示动画自定义控件等当第一个的文本发生变化时第二个的文本也会同步变化这种方式被称为元素绑定它允许一个控件的属性同步于另一个控件的属性依赖属性的实例表示默认值为自己定义了一个按钮按钮中添加了依赖属性后续可以在中使用普通属性也能实现实时数据更新但是需要额外实现一套通知机制叫做不支持其他操作依赖属性内置了通知机制可以输入再按两下键生成一个依赖属性的模板属性变化的回调如果您想在属性值变化时执行某些操作可以提供一个函数作为的参数例如处理属性变化的逻辑在这里可以添加响应逻辑例如更新依赖属性详解属性属性主要实现了面向对象的封装属性是通过和访问器方法来实现的这些方法允许你在读取或写入属性时执行自定义代码字段属性对内存的使用机制属性是常见的属性类型每个对象实例都有自己的一套属性每当创建一个新的对象实例时都会为该实例的所有属性分配内存依赖属性是中的特殊属性类型它的设计目标是减少内存使用依赖属性并不为每个对象实例分配内存而是将属性值存储在全局的哈希表中对于拥有依赖属性的类来说其实例化的对象可以称作为依赖对象中允许依赖对象在被创建时并不包含用于数据存储的空间只保留在需要用到数据时能够获得默认值或借用其他对象的数据具有实施分配空间的能力自定义依赖属性在编写一般属性时通常是声明字段然后添加和块封装为属性而在编写依赖属性时需要进行下面四个步骤在当中所有支持绑定的属性本质上它都是封装后的依赖属性那么也就是说只有依赖属性才可以进行绑定一定注意架构中这个依赖属性是写在的后台文件中的这样可以将数据绑定逻辑和逻辑分开保持代码的清晰性使类型继承类依赖属性声明只读的字段上面注册依赖属性依赖属性包装器使用属性封装和块内部使用和操作属性值需要通过和对依赖属性进行操作因此真正操作依赖属性通过来操作就是对依赖属性封装为属性声明依赖属性的所在位置的对象必须直接或简介继承于对象这样它才具备方法继承关系参数属性名表示以哪个属性作为这个依赖属性的包装器参数属性类型依赖属性用来存储什么类型的值参数宿主类型依赖属性的宿主类型参数指定依赖属性的其他功能的例如默认值回调函数属性变更后的操作继承双向绑定是否可以绑定等等参数一个实现校验功能的委托可以给依赖属性赋值的时候进行有效验证只读依赖属性在中只读的依赖属性的定义方式与一般依赖属性的定义方式基本一样只读依赖属性仅仅是用替换了内部使用来设置值属性包装器只提供你也可以设置一个的进行限制使用来代替来注册一个只读的依赖属性依赖属性的继承元素可以从其在对象树中的父级继承依赖属性的值属性值继承是一种机制通过这种机制依赖属性值可以在包含该属性的元素树中从父元素传播到子元素依赖属性的优先级每访问一个依赖属性它都会按照下面的顺序由高到底处理该值具体优先级从最高到最低排序如下动画绑定本地值自定义自定义自定义默认默认继承值默认值附加属性附加是一种特殊的依赖属性附加属性是说一个属性本来不属于某个对象但是由于某种需求而被后来附加上表现出来的就是被环境赋予的属性如这样的属性自定义附加属性和定义一般的依赖属性一样没什么区别只是用方法代替了方法下面代码演示了附加属性的定义可以输入再按两下键生成一个附加属性的模板声明附加属性的对象无需继承于因为这个时候对象作为方法参数传递附加属性案例不改变不继承的情况下做一个圆角控制定义附加属性附加属性主人是使用该附加属性你好世界附加属性与依赖属性使用场景依赖属性当您需要单独创建控件时并且希望控件的某个部分能够支持数据绑定时你则可以使用到依赖属性附加属性这种情况很多正因为当中并不是所有的内容都支持数据绑定但是我们希望其支持数据绑定这样我们就可以创建基于自己声明的附加属性添加到元素上让其元素的某个原本不支持数据绑定的属性间接形成绑定关系例如为定义附加属性与进行关联例如控件不支持但是我们想要实现选中多个条目进行数据绑定这个时候也可以声明附加属性的形式让其支持数据绑定很常用的一些附加属性如可以通过此附加属性在模板中设置而不需要设置中的一般情况特性对于许多控件来说属性通常用于表示其显示的文本内容这是比较常见和直观的控件的文本内容确实常常通过属性来设置而对于像这样可以包含多个可选项的数据控件设置等开头的属性来指定数据源是一种常见的方式开头的属性一般都是集合形式的通过这种方式可以方便地管理和显示多个数据项详解类似于中代码是通过给控件的属性设置索引名称来找到控件在中通过属性可以取到各种属性其中就包括属性即设置之后在代码中可以通过直接操作该控件容器及其子项的对应和对应的的罗列详解在中是一个用于显示和编辑表格数据的控件与类似也支持数据绑定但它提供了更多的功能尤其是在处理表格数据时适合用于显示大量数据并支持排序筛选分页和编辑等功能默认会显示所有数据列默认会显示所有成员数据绑定演示代码名称类型用户开始时间解决时间描述这些绑定确保了能够从视图模型中的集合属性获取数据并将每个数据项的特定字段显示在相应的列中这是设计模式的一个典型应用通过数据绑定将模型数据展示在视图上同时保持视图和模型的解耦以及其他通过属性指定的字段如都是集合中元素的属性属性例子属性用于为元素指定名称以便在后台代码中引用该元素在这里被命名为可以在后台代码中使用该名称来操作或访问属性用于设置控件的字体大小在这里的字体大小被设置为属性用于指定控件在布局中所在的行索引在这里被放置在布局的第行属性用于设置垂直滚动条的可见性在这里设置垂直滚动条始终可见属性用于设置控件的外边距在这里的外边距被设置为个逻辑单位属性用于绑定的数据源在这里绑定到名为的数据源属性用于设置用户是否可以添加新行在这里设置用户不能添加新行属性用于设置用户是否可以删除行在这里设置用户不能删除行属性用于设置用户是否可以重新排序列在这里设置用户不能重新排序列属性用于设置用户是否可以调整行的大小在这里设置用户不能调整行的大小属性用于设置用户是否可以对列进行排序在这里设置用户不能对列进行排序属性用于设置是否自动生成列在这里设置为不自动生成列属性用于设置是否为只读在这里设置为只读用户不能编辑数据属性用于指定是否按内容单位滚动在这里设置为按内容单位滚动属性用于设置虚拟化面板的滚动单位在这里设置为按项滚动属性用于启用或禁用虚拟化在这里启用虚拟化以提高性能属性用于设置虚拟化模式在这里设置为以重用可视元素属性用于控制控件中列的自动生成行为它的主要作用是在数据绑定时决定是否自动根据数据源的属性生成列这个属性是一个布尔值默认为当设置为时会根据绑定的数据源通常是集合类型比如的属性自动生成列每个属性都会对应一个列列的标题会使用属性名列的数据类型会根据属性的类型自动推断如果你希望手动定义列而不使用自动生成可以将设置为这时你需要显式地定义的列使用实现一个全新的参考文章是中的一个类用于对数据进行排序过滤分组等操作是一个抽象基类它定义了数据源排序规则过滤规则分页规则等属性和方法的实现类包括等这些类分别用于显示不同的数据布局和样式例如用于显示一个列表用于显示一个表格用于显示一个图标网格这些类都继承自并实现了的接口从而具有相同的方法和属性使用类可以方便地处理数据例如排序通过设置的属性可以实现数据的自定义排序过滤通过设置的属性可以实现数据的自定义过滤分页通过设置的和属性可以实现数据的分页显示导航通过实现的方法可以实现数据的导航操作例如上一页下一页首页等总之是应用程序中用于显示数据的一种控件它提供了一种灵活的方式来处理数据包括排序过滤分页导航等进度条案例虚拟化延迟滚动启用虚拟化动态回收创建容器复用容器虚拟化容器复用机制可提升展开折叠动画流畅度延迟滚动需要精确显示滚动位置时需禁用与触摸屏滚动存在兼容性问题时需测试虚拟化仅实例化可视区域内的节点容器如而非一次性创建全部容器延迟滚动用户拖动滚动条时不实时更新内容释放滚动块后才刷新避免滚动过程中的频繁布局计算和渲染快速滚动时不会出现白屏现象使用场景场景特征推荐方案原因说明纯展示型关闭虚拟化简化样式开发含复杂数据绑定的业务系统开启虚拟化避免未来扩展时的重构成本需要触摸屏操作开启延迟滚动提升滑动操作流畅度节点含动态加载内容开启虚拟化延迟滚动预防子项异步加载时的卡顿数据量较少的情况下不开启的主要原因盘点如下性能提升幅度样式开发复杂度增加可能引入不必要的渲染异常如部分阴影效果失效在等第三方控件中虚拟化可能破坏内置样式非常适合用于展示有层级多层嵌套的数据控件的主要功能包括显示层次化的数据结构支持节点折叠和展开支持选中和取消选中节点支持拖放节点重排支持显示以支持复选框功能使用到一个叫层次结构数据模板来绑定元素参考将数据显示未详解中显示数据转换器原理探寻主要属性指定控件的数据源注意必须为一个集合指定用于显示节点文本的属性路径指定当前选中的节点指定节点是否展开指定节点是否被选中如果要传递选中项可以通过绑定的过程中传递参数来实现如下常用方法在指定的父节点下添加一个新的子节点删除指定的节点清除指定节点的所有子节点展开所有节点折叠所有节点使用注意如果直接使用绑定一个集合其只能显示集合本身的数据默认调用的是集合中每个对象的方法如果没有重写对象的方法就会显示类型信息的文本最重要的一点是只使用是不能具备层次结构的需要配合使用使用案例如下包含包含两层案例单个项目录显示的名字定义每个展开显示的模板两层案例还有如下第一层模板第二层模板三层案例第一层显示信息第二层显示信息第三层显示信息自定义选择层级显示实现案例只是将中包含的所有的中的所有罗列出来只显示和两级但是要显示中所有的内的这些两级关系以下是实现方式第一层显示信息个学生第二层显示信息样式模板其模板使用了两个固定的名称用于的名字表示内一级用于的名字表示上一级自定义单个项目录显示的是其中学生的数量定义每个展开显示的模板下面设定样式下面是放入内容的意思的绑定的是一个集合有一个集合的迭代器一样遍历的是什么类型呢是一个上下文是你的成员所对应迭代器具体对应的具体的实例值的不行必须是双向绑定的子节点的缩进关键是这个支持展开收缩是如下代码注意上面二者的区别在于后者是单向绑定因为都是单向绑定中如何获取选中值对于控件我们通常可以去绑定来处理这个值但由于存在父子结构因此没法通过来处理值因此在中获取选中的值就要使用到拥有属性用于控制滚动条的显示与隐藏注意该控件如果置于中会失去滚动条效果如果本身被限制在中可以置于他所在的命名空间是表示可由用户拖动的控件主要的三个事件分别是一当控件具有逻辑焦点和鼠标捕获时随看鼠标位置更改发生一次或多次拖的过程中不断触发的事件一在控件接收逻辑焦点和鼠标捕获时发生开始拖的事件一在控件失去鼠标捕获时发生结束拖的事件和拖动的区别就在于后者没有拖动过程中的中间状态弹出窗口使用属性控制窗口是否弹出常用属性是否允许透明出现动画上往下滑动正是下拉的默认动画缩放自制添加更好的出现动画添加自定义控件继承官方所在为弹性动画弹性是一种用于显示附加信息的控件当用户将鼠标悬停在某个控件上时会弹出一个小窗口来显示这些信息是通过对进行了一层小小的封装实现的基本使用方式也可以设置为如下内部构成简述其构成触发下拉框打开关闭作为下拉框的框体自定义子项模板样式展开的选项卡的背景色设置为灰色设置鼠标悬浮颜色为橙色使用方式用于显示数据集合的控件用于简单的列表显示内部需要绑定中的内容可以参考此处简单列表显示案例定义了如何显示每个数据项在这里每个数据项将使用中定义的模板进行显示在使用的时候先使用一般来说如果只有一层可以使用但是如果嵌套层级很复杂就不要多个嵌套了直接使用是一个用于在垂直或水平方向上排列子元素的面板它支持虚拟化虚拟化的主要目的是提高性能尤其是在处理大量数据时虚拟化当使用时只有可见的元素会被创建和渲染未在可视区域内的元素不会被创建这样可以显著减少内存使用和提高性能当用户滚动视图时面板会动态地创建和释放元素以确保只有当前可见的元素在界面上如果要显示的是结构体中的各个成员方式如下结构体中多成员显示含命令案例描述怎么组织子项也可以使用等描述单个子项是怎么样的此处指明才有成员补全功能点击测试一般都配合使用意义在于数据超出显示窗体的时候可以滚动使用控件作为菜单栏的容器并在其中添加控件作为菜单项设置帮助关于使用和可以通过模板轻松切换整个内容使用按钮动态切换几何图形可以使用到比如说是一个抽象基类的对象定义的模板如下其他子类的会根据运行时的子类自动选择在中上下文菜单是一个独立的视觉树不会自动继承父元素的解决方案使用使用传递以在中添加为例菜单项菜单项注意如果要绑定内容的话要使用参考如下复制是连接与父级控件的桥梁解决了数据上下文隔离和参数传递问题通过灵活结合及代码动态设置可在模式下高效实现菜单交互逻辑是的一个依赖属性类型为它表示触发显示的父级控件如等通过该属性可以定位到与菜单关联的元素核心作用如下定位菜单位置确定相对于哪个控件弹出默认基于鼠标右键点击的控件数据上下文传递由于独立于可视化树无法直接继承父级控件的而提供了访问父级数据上下文的途径案例绑定到父级控件的由于默认无法继承父级控件的导致无法直接绑定到中的命令或属性通过访问父级控件的绑定到触发菜单的控件如的即通过获取当前选中项注意使用只能往上找弹出元素的父级因此可以利用父级控件的存储的然后通过来找到这个来获得的上下文解决跨视觉树绑定问题的作用将窗口或用户控件的即传递给确保绑定到正确的对象案例针对删除针对这里本身不直接支持分级显示但可以结合和可以在中实现分级的列表视图是中用于显示列表数据的控件它可以使用来显示多列数据允许您定义多个列每列可以绑定到不同的数据字段使用来设计定义多个表格列属性用于指定绑定到数据源中某个字段的路径在这个例子中使用了语法来指定数据的路径中插入自增列案例自增序号序号利用来自定义每一项内容刚需状态索引生成的核心机制在于下面通过定位到当前项的容器使用自定义的转换器获取索引位置转换器确保容器生成完成通常用于在一个窗口中显示多个选项卡选项卡中可以包含不同的内容用户可以通过点击不同的选项卡来切换显示的内容在许多应用程序中都很常见特别是在需要组织大量信息或功能时比如设置界面文档管理等组织形式如下用于设置标签的排列位置默认是定义选项卡的名称显示属性是个类型的什么都可以填用于表示选项卡中的内容是中其模板中内含一个用于陈列标签自定义子项模板如下设置选中颜色为紫色也可以写成使用上面的子项模板样式如下列表框是一个的自定义此处定义的样式在下方的中使用必须加这个才可以显示具体的内容通过选择器的属性设置选中变色通过选择器的属性设置鼠标悬浮变色注意设置集合容器的模板样式都是通过属性的绑定的是那么每个使用下面的方式告诉他如何解析用于显示列表项的控件是的一个扩展提供更强大的功能支持多种视图如详细视图列表视图等可以显示更复杂的数据结构允许使用数据模板和列定义适合展示更丰富的信息使用场景而言与的区别如下如果你的需求只是简单的选择列表项是一个合适的选择如果你需要展示更复杂的数据或者需要对数据进行更详细的控制和展示更为合适基本使用案例进阶用法案例内含在中获取下标的使用方式序号十进制值十六进制值描述绑定动作列动作设置值自定义框体文字部分这里写的版本是很简陋的主要是体现的点击切换效果是能够帮助层级控件显示层级数据的模板一般多用于和也可自己实现层级数据结构层级结构它是能描述层次关系的结构即有上下级关系参考文本块标签用于显示文本标签其中允许标签标签是一个用于在文本块中显示文本的内联元素标签不能单独使用它必须嵌套在其他文本相关的容器内例如或等再生状态如果想添加带边框的文本可以使用控件可以带边框的文本控件其可以直接设置和属性也可以额设置属性内边距可以使用下面的语法监听键盘事件是一种优雅的方式将用户输入和命令绑定解耦使得代码结构更清晰更易于维护特别适用于模式只会作用于当前拥有焦点的控件自定义微软用到的特殊的模板名字叫只有或元素可以用作只要起名为这个就可以输入在绘制的代码中会找到名为这个的控件手写一份此跟随的变化而变化可将模板拆解到样式中如下此处再次写的原因是为了让底下如果存在的或的属性可以找到的字段但是有点不会智能提示此跟随的变化而变化上方的如果写了使用才能找到对应的属性继续完善输入文本超出界限并未处理自定义可以参考官方的源码将会发现中的其实就是通过和实现的一个事件此处由于外边控件实际上没有属性因此需要自己提供一个依赖属性封装一个新的控件就可以在外界设置这个属性了自定义同样需要做精修主要是体现实现原理一个可支持显示或编辑丰富内容包括段落超链接和内联图像的控件两个同步滚动如果是写在文件中只需要详解主要属性中控件的主要属性如下用于获取或设置中的纯文本内容用于获取或设置中的文档内容这可以是一个对象用于获取或设置是否为只读模式用于获取或设置是否启用文档功能用于获取或设置中选中文本的范围用于获取或设置中垂直滚动条的可见性用于获取或设置中水平滚动条的可见性用于获取或设置是否可以接受键输入用于获取或设置的背景色用于获取或设置中前景色文本颜色用于获取或设置中文本的字号大小用于获取或设置中文本的字体用于获取或设置中文本的字重用于获取或设置中文本的字体样式如斜体加粗等用于获取或设置中文本的换行方式中的控件常用于以下场景编辑富文本内容可以让用户在控件中编辑富文本内容包括文字图像表格等显示富文本内容可以在控件中显示富文本内容包括从外部文件加载的内容或通过编程动态生成的内容实现文本格式化可以对富文本内容进行格式化例如加粗斜体下划线字体字号颜色等实现输入验证可以对用户输入的文本进行验证例如限制输入的字符类型长度格式等实现文本搜索和替换可以对富文本内容进行搜索和替换方便用户快速定位和修改内容实现语法高亮可以在富文本内容中实现语法高亮显示例如在代码编辑器中显示关键字注释等控件是一个非常强大和灵活的控件可以满足各种富文本编辑和显示的需求常用属性罗列间隔表示左右隔开表示左右隔开上下隔开分别表示左上右下左隔开上隔开右隔开下隔开宽高在当前空间中第一个按钮宽占第二个按钮宽占自动适应内容大小可以将和设置为垂直对齐水平对齐用于控制元素在容器中的垂直和水平对齐方式的属性设置为表示在对应方向拉伸缩填满像这样的控件还有用于控制其中的文本在按钮中的对齐方式的属性控件组织结构逻辑树可以在类的构造函数中遍历视觉树必须在经过至少一次的布局后才能形成所以它不能在构造函数遍历通常是在进行这个函数为在布局发生后被调用这里涉及到与的显著差异中使用的是控件层次结构来描述控件的组织方式每个空间都通过父控件与子控件形成层次关系中使用逻辑树与视觉树来组织控件逻辑树的结构辑树中的每个节点代表一个通常是元素如控件窗口等这些元素之间通过父子关系连接在一起辑树用于处理数据绑定和事件路由数据绑定通常是基于逻辑树的结构进行的事件的路由也是从逻辑树的根节点向下传播视觉树表示实际渲染的元素包括所有的视觉表现如形状颜色等而逻辑树则关注元素的结构和关系逻辑树中的元素不一定在视觉树中都有对应的可视元素查找控件方法用于在名称范围内查找具有特定名称的元素它通常用于在代码隐藏文件中查找由标识的控件优点简单直接易于使用性能较好因为它直接在名称范围内查找控件缺点只能查找当前名称范围内的控件不能跨越不同的名称范围如果控件在不同的命名空间或模板中可能无法找到使用方法如下逻辑树与视觉树视觉树是一种具体的结构它表示了元素的渲染细节和视觉效果例如布局样式动画变换等逻辑树是一种抽象的结构它表示了元素之间的逻辑关系和层次关系例如父子关系资源继承事件路由等下图展示了的逻辑树无阴影与视觉树有阴影视觉树视觉树是中的一个概念它表示应用程序中所有可视元素的层次结构视觉树包含了所有的元素包括用户能看到的控件和一些用户看不到的辅助元素是一个静态类用于遍历和操作视觉树它允许你递归地查找子元素适用于更复杂的场景逻辑树包含了应用程序中所有的元素包括控件数据对象和资源它反映了文件中的元素层次结构视觉树仅包含可视元素反映了实际渲染的元素层次结构视觉树是逻辑树的一个子集但包含更多的细节如模板生成的元素视觉树的作用渲染视觉树用于渲染元素事件路由视觉树用于路由输入事件如鼠标和键盘事件布局视觉树用于计算和安排元素的布局优点可以递归查找子元素适用于复杂的控件层次结构不受名称范围限制可以跨越不同的模板和命名空间缺点代码相对复杂需要递归遍历视觉树性能可能较差特别是在视觉树很深的情况下在视觉树中递归查找具有特定名称的一个子元素作为查找的起点方法会从这个元素开始递归查找其子元素要查找的子元素的名称这个名称是通过属性在中定义的使用方式逻辑树在中逻辑树表示应用程序中所有元素的层次结构包括控件数据对象和资源逻辑树反映了文件中的元素层次结构与视觉树不同逻辑树更关注元素之间的关系而不是它们的渲染细节类提供了一些静态方法用于遍历和操作逻辑树你可以使用这些方法递归查找逻辑树中的子元素常用方法获取指定元素的子元素集合获取指定元素的父元素在逻辑树中查找具有指定名称的元素递归查找逻辑树中的一个指定的控件自绘控件的底层不是实时绘制更新的而是事件驱动的绘制更新最终会触发的消息然后交给设备上绘制相关的是调用可以在中绘制东西如继承于继承于继承于就来源于完全自定义窗口完全自定义窗口参考下面的做法上面两行标签中的属性设置是为了实现去除窗口默认标题栏的效果是一个作用于的附加属性有了之后就可以拉伸拖拽等种种功能但是有缺陷会导致全屏的时候显示不完全一般要对界面中的内容设置为或或的设置为或简易反调试检测小心我被附加了调试器程序很安全最基本的反附加调试检测窗口页面用户控件窗口表示一个独立的顶级窗口通常是应用程序的主要界面可以包含其他控件和布局具有标题栏边框等窗口特征可以最小化最大化关闭页面通常用于导航框架中的页面与窗口类似但可能具有特定的导航行为和约定常用于单页应用程序或多页面应用程序用户控件可重用的自定义控件可以包含其他控件和布局用于封装特定的功能或界面部分可在多个窗口或页面中重复使用窗口窗口上面含的东西大致如下自定义拖拽控制窗体大小自定义的调整大小手柄放置在窗口的右下角函数的声明允许我们从代码调用函数事件处理这个方法处理的鼠标点击事件单击时调整大小双击时最大化或还原窗口这个方法使用来调整窗口大小具体来说用于获取窗口的句柄是一个函数用于向窗口发送消息消息用于执行系统命令指定了调整大小的方向例如表示从右下角调整大小绑定在绑定之前所使用的是通过设置设置索引名然后在代码中使用设置的来获取该控件下面介绍更方便的绑定方式绑定顾名思义是将我们获取到的数据和上的控件绑定起来利用数据的变化来更新界面所看到的内容把绑定分为五步绑定目标就是要操作绑定的控件如绑定属性就是依赖项属性是绑定属性是绑定关键字而后面的就是要绑定的数据源的变量名是声明好的属性变量绑定模式绑定模式双向绑定模式源和目标相互影响当源发生变化时目标更新同时目标属性的更改也会反馈到源单向绑定模式源的变化会自动传播到目标属性但目标属性的更改不会影响到源这是比较常用的模式用于显示数据源的实时变化仅当应用程序启动时或进行更改时更新目标属性当数据上下文发生改变时比如在不同的视图或页面之间切换导致绑定所关联的数据上下文对象被替换为新的这时在新的数据上下文下绑定会按照模式的规则进行一次更新反向的单向绑定与模式相反当目标属性发生更改时会自动更新源属性模式根据实际情况来定如果目标属性是可编辑的就是目标属性是只读的就是可以类比为的单向绑定和双向绑定绑定数据源可以是单个变量也可以是一个数据集等等关联资源在每一个窗体中都有一个他是一个类型主要用于存储绑定资源用于将数据库映射为实体它是实现数据绑定的基础在架构模式中通常将设置为控件或整个界面的这样控件可以通过绑定直接访问中的数据和命令绑定时机还可以使用绑定时机在中是一个枚举用于确定绑定源比如视图模型中的属性的更新时机它对于数据绑定非常重要因为它控制着用户界面上的更改何时反映到绑定的数据源属性上的值包括使用绑定目标属性的默认更新触发器对于大多数依赖属性是但对于属性是每当目标属性的值发生变化时都会更新源属性当控件失去焦点时更新源属性只有在调用方法时才更新源属性绑定的目标与数据源必须是同类型源的指定使用自定义类作为源一个对象只要通过属性公开自己的数据就可以作为的源作为源的对象需要实现接口并激发事件才能使属性具有自动通知发生了变化的能力除了使用自定义类作为源以外还有其他不同的形式将控件作为源关键词作为源当我们使用作数据源时它会自动将元素的数据源设置为当前窗口或用户控件的属性所以在文件中使用语法来绑定时而无需指定任何其他源因此这种形式也称作无源数据绑定使用不仅可以绑定公开属性还可以访问命令对象以及资源中定义的属性在通过元素树向根结点处方向寻找的现象其实只是一种描述效果真正的过程其实是结点上的属性值向下传递了这是因为是一个依赖属性而依赖属性有一个特性当你没有为控件的某个属性显式地赋值时它就会把自己所在容器的属性值拿过来当作自己的属性值使用类的子类成员作为数据源查询结果作为数据源类是一个抽象基类它定义了一些公共属性和方法用来执行某些查询生成可以用作绑定源的单个对象或对象列表类支持标准的窗体数据绑定模型可以处理不同类型的数据源例如数据库文档数组集合等类还实现了和接口用来提供对绑定和初始化的支持提供一种将不同类型的数据源用作绑定源的方式使用他的好处是可以简化数据绑定的过程无需编写额外的代码来加载和查询数据是一种可扩展标记语言它可以用来存储和传输数据的特点是它可以自定义标签用来描述数据的结构和含义可以与其他技术一起使用来处理和转換数据也可以用作配置文件元数据富文档等提供了文档对象模型类库用于处理数据包括等类是传统的功能强大的类库展示文档的数据可以使用或使用来设计定义多个表格列是一种用于在文档中查找信息的语言在中可以用于绑定数据在中符号用于表示属性特征例如表示绑定到元素的属性绑定代码如下载入文件对象用于支持对数据的访问以便用于数据绑定上述全部代码可简化为假设有一个文档如下能够将对象进行包装作为数据源提供给被包装的对象作为的属性我们可以通过属性来指明要调用的方法使用属性来传入参数其是一个集合因此可以使用下标形式指定和访问运行方法的结果会保存在属性中支持根据参数调用重载方法查询结果作为数据源的查询结果是可以作为数据绑定的数据源的这是因为其查询结果是一个对象所以可以作为列表控件的来使用的优点是可以提高数据处理的能力和开发效率使查询成为了语言的一部分还可以使用声明式查询语法或方法语法来编写查询表达式这些表达式可以在编译时进行类型检查和优化案例每当员工列表更改时重新过滤初始化员工列表过滤员工列表只保留名字以开头的员工当我们不能确定源对象的名称但是能知道其与目标对象在布局上有层级关系时可以使用属性属性数据类型为类其属性的类型是枚举其取值有和对于前三个枚举值还有同名的静态属性它们的类型是类不仅可以按照层级来寻找数据源对象还支持控件自身与自身的属性进行绑定绑定到集合中当前项的前一项的数据绑定到应用了控件模板的控件的属性绑定到绑定目标本身的属性绑定到绑定目标的某个祖先元素结点或根元素的属性绑定解释在您的中的绑定如下列这里的表示绑定到元素的属性列这里的表示绑定到元素的子元素列这里的表示绑定到元素的子元素路径的指定支持多级路径即可以一直点下去绑定和窗体中操作的区别窗体后台文件直接访问控件的操作是事件驱动的即如果没有事件的存在是改变不了界面的绑定的操作是以数据本身的变化来通知界面显示改变的因此绑定可以实现前后端分离使用绑定需要的步骤首先要在窗体文件中设定窗口的数据上下文比如说中给当前界面指定一个数据上下文窗口必须有这一句才能在该窗口中的控件实现绑定此处的上下文不一定得是等变量在哪里就指定什么设定的数据用于被控件绑定输入账户的控件的属性绑定变量这样只能实现修改更新值到变量中但是反过来中的值被修改不能反映到中按照下面来改动才可以让数据上下文支持变化通知数据上下文支持变化通知将控件绑定一个数据上下文控件默认只能单向绑定到数据上下文通过修改数据上下文中被绑定的变量默认无法影响到设置了绑定的控件要真正支持双向绑定需要修改数据上下文的类以支持数据变动时的通知需要数据上下文的类继承自此处以数据上下文指定自己为例子定义事件用于通知属性值的更改触发属性更改通知的方法将事件的委托复制给临时变量如果不为则调用委托传递当前对象和属性名称参数针对所有需要支持双向绑定的属性需要在中去调用方法内含这两行代码这样修改后才可以让下的所有属性真正可以支持变量到控件的变化通知即普通属性也支持通知机制了因为依赖属性本身就内置了通知机制绑定文件中的值假设文件名为岁中需要引用绑定如下平时使用的是或省略一个意思现在要用通过找到定义好的资源通过找到具体的值绑定控件的方法未完善绑定到中的方法为三种不同的绑定方式特性绑定目标元素的静态对象或资源自身模板化父元素祖先元素等常见应用场景同一个文件中的元素之间的绑定绑定到非的对象或静态属性在模板或复杂层次结构中绑定相关元素可见性要求必须在同一个逻辑树内不依赖可视元素直接绑定到对象通常查找祖先元素适合复杂的层次结构典型用例控件之间的数据共享绑定到静态资源或静态属性在控件模板中绑定到父级数据或绑定到上层容器的属性下面两种绑定效果相同利于理解本质不设定明确的绑定的这样就去从本控件类为开始根据可视树的层次结构自下而上查找不为空的属性的值绑定的为控件自身这样就绑定了自身控件的允许你通过指定目标元素的名称来进行数据绑定它通常用于同一文件内的不同控件之间的数据绑定尤其是在需要从其他元素获取值时特点只能绑定到具有属性的元素必须在同一个可见的逻辑树内同一个视图文件适用场景需要在同一个视图内从某个元素获取值显示的内容就是的中的文本下面有助于理解效果等同于属性允许你直接绑定到某个指定的对象而不是绑定到元素它可以用于在中绑定到某个数据源对象通常是静态的对象或在代码中初始化的对象适用场景绑定到非元素的对象比如后台代码中的对象静态资源静态属性等用法绑定到静态对象绑定到了资源字典中的对象用法绑定到静态属性这里绑定的是静态类的静态属性是一种特殊的绑定方式它允许你相对于绑定目标元素来查找数据源使用时可以指定查找方向祖先同级元素等它提供了更灵活的方式来绑定元素之间的关系适用场景需要绑定到和目标元素相关的父级同级或子级元素适用于复杂的结构或在模板中需要从模板外部访问数据的情况常规写法及完整展开如下可展开为主要模式模式绑定到自身这种情况下数据源就是绑定目标元素自己的属性绑定到了自身的属性模式绑定到控件模板的父元素通常在或中使用这里绑定到按钮的属性这是因为是的模板化父元素模式按照层次结构查找指定类型的祖先元素常用于需要从父元素中获取属性的场景这里的绑定到了最近的祖先的属性模式模式用于绑定到数据绑定集合如等中的上一个数据项这个模式通常在集合控件的模板中使用用于访问前一项的数据它允许你在当前项目的绑定上下文中引用上一个数据对象的属性值适用场景主要用于模板化控件如或中的让你在当前项的模板中能够绑定到前一项的数据对象这在需要上下文关联的绑定时比较有用例如你需要根据前一项的数据来展示当前项的样式或行为时特点模式只在模板化控件的数据绑定中有意义比如它让你在模板内的当前数据项中可以引用前一项的数据如果当前项是集合中的第一个项则没有上一个数据项绑定会返回需要考虑这种情况假设我们有一个控件里面显示一组数字如果我们希望每个项能够显示当前数字以及前一个数字的和我们可以使用进行绑定绑定到中的单个元素使用带边界处理的案例这个示例展示了如何使用绑定到前一项的数据并通过来处理边界情况即当没有前一个数据时如在第一项上显示替代文本这种边界处理在集合绑定和模板化控件中是常见需求当前项的数字前一个项的数字带有边界处理如果前一项不存在显示将会显示为如下控制绑定数据的显示格式这是一个格式化字符串用于指定如何显示绑定的数据表示将数值格式化为小数点后三位的浮点数数据校验与转换若在数据传输的过程中需要对数据进行限制可以在上设置数据校验若要对数据类型进行转换可以在上设置数据转换编写数据转换器在上提供了进行校验进行转换提供了两种数据转化的方式值转换器方法绑定后触发转换器转换器负责把值转换成需要的内容转换器需要实现命名空间的接口或接口分别用于单值转换和多值转换转换器可以在中定义为资源并在绑定中引用方法直接在里面对数据进行处理展示所需要的内容可以根据绑定的数据的值或条件来改变控件的属性或样式可以在或中定义用于数据校验的属性是在中要实现的数据校验需要以下几个步骤定义一个继承自的类重写其方法根据自己的逻辑和条件返回一个对象表示数据是否有效以及无效时的错误信息在对象中添加一个或多个对象表示要对数据应用哪些校验规则可以设置属性的属性为表示要在目标更新时也进行校验在对象中设置属性为表示当数据校验失败时要通知绑定目标或其祖先元素编写校验失败时执行的事件处理器方法获取事件参数获取错误信息编写显示错误信息的代码或其它执行内容在目标或祖先元素上添加一个事件处理器用于处理事件传入委托并指定方法总结来说就是编写校验规则类为添加校验规则打开校验通知开关编写校验失败事件处理器处理校验失败事件优势使用数据检验可以提高代码的质量和效率增强用户体验和交互性数据检验将校验功能独立出来可以将验证逻辑和视图逻辑分离使得代码更加清晰和可维护利用对象的各种属性和事件实现数据的自动更新和错误的通知数据检验可以使用不同的验证规则实现不同的验证需求使用预定好的类来编写验证功能更加规范和方便也可以为一个绑定添加多个规则实现重用数据检验可以使用属性实现对验证失败时的视觉反馈例如显示红色的感叹号或边框等案例标签文本框用于输入数字绑定到属性启用验证验证规则输入的内容必须是有效数字错误提示区域创建一个自定义的验证规则检查输入是否为空尝试将输入转换为数字返回默认校验结果为的对象架构中通过错误转换器创建一个将转换为可显示的错误信息转换器代码如下提供了一个灵活的机制来管理模型中的错误是一个接口主要用于在架构中管理和处理数据模型的验证错误它允许你在视图模型中集中管理错误并通过事件通知机制将错误反馈给视图层在中当你需要在数据绑定时显示错误或验证输入时是一个非常有用的工具更适合在控件级别执行单一字段的验证而可以在视图模型中集中处理多字段验证接口包含以下重要成员返回模型是否有任何验证错误返回指定属性的错误列表当某个属性的错误发生变化时触发此事件数据属性存储错误信息的字典检查是否有错误获取指定属性的错误信息验证逻辑清除错误验证输入是否为空验证是否为有效数字添加错误清除错误触发属性变化事件触发错误变化事件可以将源数据和目标数据之间进行特定的转化定义转换器需要继承接口下图的指的是当我们遇到需要自行编写转换器的情况时我们需要创建一个类并让这个类实现接口该接口的定义如下当数据从源流向目标时方法会被调用反之调用会进行源属性传给目标属性的特定转化会进行目标属性传给源属性的特定转化源属性传给目标属性时调用此方法这里应该实现转换逻辑目标属性传给源属性时调用此方法这里应该实现反向转换逻辑比如说实现一个根据值转换成前景色案例一个用于反转布尔值的值转换器创建一个新的文件并添加以下代码需要实现的接口在中使用接下来在文件中使用这个转换器首先需要在文件的资源字典中定义这个转换器其他代码使用转换器用法如下示例复选框多重绑定多重绑定不能嵌套但多重绑定下的每个绑定也可以设置转换器命令为了把业务都整合放到中因此不仅希望属性绑定还希望事件也能实现类似的效果命令正是为此诞生的命令由许多可变的部分组成但它们都具有以下个重要元素命令命令表示应用程序任务并且跟踪任务是否能够被执行然而命令实际上不包含执行应用程序任务的代码命令绑定每个命令绑定针对用户界面的具体元素将命令连接到相关的应用程序逻辑这种分解的设计是非常重要的因为单个命令可用于应用程序中的多个地方并且在每个地方具有不同的意义为处理这一问题需要将同一命令与不同的命令绑定命令源命令源触发命令例如就是命令源单击它们都会执行绑定命令命令目标命令目标是在执行过程中涉及到的其他元素命令详解命令对象代表一个具体的可执行操作通常具有名称执行逻辑等属性命令的绑定通用讲命令与控件进行绑定使控件可以响应命令在意在中直接设置控件的属性来建立绑定关系命令的执行当满足触发条件时如按钮点击等相应的命令被执行执行逻辑可以在代码中自定义编写命令的启用禁用状态可以根据特定条件动态控制命令是否可用比如某些操作在特定场景下不可用命令路由命令在控件层次结构中传播和处理允许父控件或更高级别的元素也能对命令做出响应如何实现一个命令命令的核心是接口该接口定义了命令的工作原理该接口包含两个方法和一个事件包含引用程序的任务逻辑返回命令的状态可用为不可用为当命令状态改变时引发该事件对于使用命令的任何控件这是指示信号表示他们应当调用方法检查命令的状态通过使用该事件当命令可用时命令源如可自动启用自身当命令不可用时禁用自身和方法都接受一个附加的对象参数可使用该对象传递所需的任何附加信息可以直接使用触发无参的命令如果需要传一个参可构造如下实例如何让控件支持命令支持命令的实现是在命令源这个环节实现的即要让某个元素能够作为命令的发起源并执行相关操作就需要在这个元素上实现接口这个接口定义了与命令相关的一些必要属性和方法不是每个控件都直接支持绑定的需要将他们关联到实现了接口的控件天然实现了接口的控件包括继承自类的控件和等它们可以直接作为命令源来进行命令的绑定和操作这是因为这些控件的本质特性决定了它们在交互中常常扮演着触发命令的角色定义了三个属性指向连接的命令这是唯一必须的细节提供其他希望随命令发送的数据确定将在其中执行命令的元素检查是一个标记扩展它允许您引用中定义的其他控件表示控件下的哪个属性开发者如何使用如何使用定义一个自己的针对类型支持针对一个参数的泛型类型使用该类型是定义好的方法这里的参数是下面的传过来的即传过来了先定义一个成员这样去构造在中这样去连接检查上面的部分也可以用如下代码实现来代替如下假设这个就是上面的这样当点击该的时候就会自动调用函数了就像前面说的这里之所以能这样去使用有一个隐含的条件是在于已经实现了接口才可以这样用目前来看这样开发比事件驱动要麻烦但长远考虑更好事件事件和命令是两种处理用户交互的机制事件是一种传统的机制允许一个对象通知另一个对象发生了某种情况命令是一种更高级的机制一个对象请求另一个对象执行某种任务并且可以跟踪该任务是否可以执行事件处理机制模型应用程序开发人员和组件创建者可以使用路由事件通过元素树来传播事件并在树中的多个侦听器上调用事件处理程序公共语言运行时事件事件也称作直接事件没有这些功能直接事件直接事件的前身是消息机制事件模型隐藏了消息机制的很多细节使得开发逻辑变得简单事件的拥有者也就是消息的发送者事件的宿主在某些条件下激发它拥有的事件触发后使得消息被发送事件的响应者将消息接收和处理使用事件处理器进行响应事件的订阅事件的响应者需要订阅事件才能实现事件从触发到处理的完整过程在一个窗体上有一个按钮和一个文本框按下按钮后文本框出现文字事件的拥有者事件事件的响应者事件处理器订阅关系直接事件的问题在于事件的拥有者和事件的响应者必须点对点建立订阅关系也就是说事件的拥有者必须能直接访问事件的响应者路由事件在路由事件中事件的拥有者和响应者之间没有直接显式的订阅关系事件的拥有者只负责激发事件事件由谁进行响应它并不关心事件的响应者通过事件侦听器针对某一类事件进行监听当监听到有事件传递过来时就可以使用事件处理器来响应事件并决定事件是否继续传递给其他对象需要先了解逻辑树与视觉树详细解释可以参考此处事件可以分为种类型事件的触发顺序是隧道事件直接事件冒泡事件直接事件事件在源头引发并在源头本身进行处理冒泡事件事件沿着视觉树层次向上传播例如就是一个冒泡事件从目标元素向根元素传播父级控件可以在子控件处理完事件后进行处理隧道事件事件沿着视觉树层次结构向下传播例如是一个隧道事件从根元素向目标元素传播通常以前缀命名假设有一个里面有一个而中有一个当用户点击时事件的触发顺序如下隧道事件根元素接收到接收到接收到直接事件接收到事件冒泡事件接收到接收到接收到在冒泡事件处理中取消事件继续处理方式如下取消事件继续处理隧道事件和冒泡事件都是这么处理其他处理但注意如果在隧道事件中设置了那么该事件将不会继续传播到目标元素导致目标元素的事件不会被触发针对窗口的事件事件执行顺序初始化开始初始化结束触发初始化时间计算内部控件所需空间排列内部控件计算控件实际显示大小如果元素大小超过可用的显示空间将自动进行剪切渲染窗口更新窗口的和控件加载内部渲染触发时机当控件被初始化时触发说明这是控件的构造函数完成后立即触发的事件此时控件的属性已经设置但还没有加载到视觉树中事件是自底向上触发先子后父触发时机当控件及其所有子元素加载完成并添加到视觉树中时触发所以在这里面查找控件可以到视觉树中查找说明这是一个常用的事件用于执行需要在控件加载完成后进行的初始化逻辑事件是自顶向下以广播方式触发从根节点由父向子触发这个元素不仅被构造并初始化完成布局也运行完毕数据也绑上来了它现在连到了渲染面上马上就要被渲染的节奏到这个时候就可以通过事件从根元素开始画出整棵树这个事件与属性绑定触发时机每次布局系统更新布局时触发说明这是一个频繁触发的事件用于确保所有子元素都已加载并完成布局可以用于在控件完全加载后执行逻辑触发时机当控件的大小发生变化时触发说明这是一个在控件的或属性发生变化时触发的事件示例触发时机当控件的数据上下文发生变化时触发说明这是一个在控件的属性发生变化时触发的事件通常用于处理数据绑定逻辑触发时机当控件及其所有子元素从视觉树中移除时触发说明这是一个在控件被卸载时触发的事件通常用于清理资源或取消订阅事件顺序盘点控件初始化控件加载布局更新可能多次触发大小变化如果控件大小发生变化数据上下文变化如果数据上下文发生变化控件卸载事件名称事件描述使用场景窗口或页面完全加载后触发用于在准备好后执行初始化任务窗口或页面即将卸载时触发用于在被移除时执行清理任务组件初始化时触发在加载到视觉树之前用于在控件渲染之前执行操作窗口成为活动窗口时触发当窗口获得焦点时执行操作窗口失去焦点时触发当窗口不再是活动窗口时执行操作窗口关闭之前触发可以在此事件中取消窗口关闭或执行清理操作窗口关闭后触发用于在窗口关闭后执行最终清理操作窗口内容渲染完成后触发用于依赖于内容完全渲染后的操作窗口状态改变时触发例如最小化最大化用于响应窗口状态变化窗口大小改变时触发用于响应窗口大小调整事件窗口位置改变时触发用于响应窗口位置变化窗口获得焦点时按下键盘按键时触发用于处理键盘输入窗口获得焦点时释放键盘按键时触发用于处理键盘输入窗口或页面完全加载并即将显示时触发在窗口或页面即将卸载或关闭时触发接到上面的命名空间后针对控件和元素的事件事件名称事件描述使用场景当用户点击按钮时触发用于按钮点击事件处理当鼠标光标进入控件区域时触发用于实现鼠标悬停效果当鼠标光标离开控件区域时触发用于实现鼠标离开效果当鼠标在控件上移动时触发用于实时响应鼠标移动事件当文本框中的文本发生变化时触发用于处理用户输入的文本变化当选择的项发生变化时触发例如在列表框中用于处理用户选择的变化当复选框被选中时触发用于处理复选框的选中状态当复选框被取消选中时触发用于处理复选框的取消选中状态当滑块的值发生变化时触发用于处理滑块控件的值变化当拖放操作完成时触发用于处理拖放操作当控件获得焦点时触发用于处理控件获得焦点的事件当控件失去焦点时触发用于处理控件失去焦点的事件输入事件这些事件与用户输入相关通常用于响应键盘或鼠标操作事件名称事件描述使用场景在鼠标按下事件被处理之前触发用于在鼠标点击前执行一些操作在鼠标释放事件被处理之前触发用于在鼠标释放前执行一些操作在键盘按下事件被处理之前触发用于在键盘按下前执行一些操作在键盘释放事件被处理之前触发用于在键盘释放前执行一些操作焦点事件这些事件与控件的焦点状态相关事件名称事件描述使用场景当控件获得键盘焦点时触发用于处理控件获得焦点的事件当控件失去键盘焦点时触发用于处理控件失去焦点的事件布局事件这些事件与控件的布局和大小变化相关事件名称事件描述使用场景当布局更新完成时触发用于在布局更新后执行操作当控件大小发生变化时触发用于响应控件的大小变化当控件位置发生变化时触发用于响应控件位置变化数据事件这些事件与数据绑定和数据上下文相关事件名称事件描述使用场景当控件的数据上下文发生变化时触发用于处理数据上下文变化的事件当绑定组发生变化时触发用于处理绑定组变化的事件项目架构开发项目管理详解每个界面包括三个文件夹可以理解成的属性映射层这个里面可以放窗体可以放控件注意文件夹文件的命名每个文件的拜放都是有讲究的切忽乱放可以聚合个可以对应多个是程序启动的配置文件如果需要更换起始运行窗体则需要修改即可要注意这里是相对路径主窗体的位置比较特殊它可以单独游离在所有文件夹之外如何连接三种文件比如说有窗体类的构造函数中通过来连接文件所有的变量字段命令都定义在这个中在中添加属性得存为一个属性和连接上演变上图是过渡方式下图才是最终采纳的三种文件的关系图代码分离包含各种控件绑定的属性需要支持包含通知代码应含有属性和属性包含各种供绑定的属性接口与交互也包含各种命令构造函数中初始化为即所有的被绑定的命令和属性会到中去找主要职责如下模型层定义业务对象和数据模型视图模型层属性用于绑定到视图命令处理用户交互业务逻辑和数据验证视图层布局和控件定义数据绑定到属性最小案例暂略使用框架实现要方便许多事件驱动与数据驱动事件驱动事件驱动通过事件一订阅一事件处理的关系组织应用程序事件驱动下用户进行每一个操作会激发程序发生的一个事件事件发生后用于响应事件的事件处理器就会执行事件驱动对应的表示模式正是事件驱动下界面控件占主动地位的界面逻辑与业务逻辑之间的桥梁是事件界面逻辑和业务逻辑多多少少都会有关联性数据是处于被动地位的是静态的等待着控件的事件去驱动他们当事件逻辑变得多且复杂的时候代码就会很容易变得复杂难懂遇到的时候难以排除数据驱动数据驱动的理念下数据占主动地位也就是由内容决定形式数据驱动的桥梁是双向数据绑定通过可以实现数据流向界面界面也可以将数据流回数据源当用户对控件进行操作带来数据变更时通过双向数据绑定会更新在中的数据在这个过程中控件和控件事件对程序的控制会被弱化他们只参与页面逻辑而不再主导业务逻辑可见在数据驱动的理念下数据占主动地位即由内容决定形式下代码操作控件必须是在对应的后台文件中才能直接使用而在模式中视图模型不直接操作视图但是你可以通过绑定和命令来间接操作视图中的控件可以通过有些控件无法通过绑定命令的可以通过双向绑定数据到一个属性然后在属性的方法中添加处理事件如下此属性绑定是的这样变相绑定了命令执行命令是一种可以附加到控件的功能它允许开发者将特定的交互逻辑封装在一个可重用的组件中使得控件能够以更灵活的方式响应用户输入和其他事件功能可以封装各种功能包括但不限于响应事件如点击鼠标悬停等执行动作如动画数据绑定等处理输入如拖放键盘输入等行为库是一组用于在中实现交互式行为的库它提供了一些附加功能和行为如触发器动作交互触发器等用于简化在中实现交互性功能的开发包含三个部分动作用于定义在触发器触发时要执行的操作或动作例如可以使用来执行命令触发动画导航到其他页面等通常与结合使用以在特定条件下执行相应的操作触发器用于定义触发某些操作或动作的条件或事件当定义的条件或事件发生时触发器会触发与之关联的操作常见的触发器包括事件触发器如属性触发器如属性值变化等交互触发器是行为库中的一种特殊触发器用于在中实现交互性功能它提供了一些特定的触发器类型如等以便在特定事件发生或属性变化时执行相应的操作案例本质上通过注册事件来实现类似的效果演示一个将事件接到的案例添加此命名空间给控件的事件绑定命令触发事件后直接修改样式案例中的与中的的不同在于中的要写成对的而中的可以有默认样式在中当你使用来为控件定义一些视觉外观时如果你为控件定义了触发器来动态更改某些属性它的优先级低于你直接在中为该控件设置的属性值但在中设置的例外而中的由于本质原理是通过注册事件来实现的因此没有这个限制虽然中也有但是他只可以用于路由事件比如的事件就不是路由事件而中却只要是事件都可以绑定自定义行为中的行为是指一种可以附加到控件上的功能行为的作用是扩展控件的功能而不需要修改控件本身的代码行为通过绑定附加属性能够方便地应用于不同控件行为可以被复用和配置使得控件的交互逻辑更加灵活通常行为有以下两种主要类型附加行为通过附加属性来实现拖放行为用于实现拖放功能自定义行为的实现方式要使用行为首先需要安装库这是微软提供的标准行为库允许你轻松创建和附加行为自定义行为通常继承自其中是行为所附加的控件类型我们可以通过重写和方法在行为附加到控件时初始化功能在行为附加时执行的代码在行为移除时执行的代码自定义的逻辑比如自动转换文本为大写使用行为在上面的例子中自定义行为会自动将的输入文本转换为大写除了简单的文本处理你还可以实现更复杂的行为例如拖放功能让控件支持拖放操作动画效果当用户与控件交互时启动动画命令行为将命令绑定到控件的事件中案例假设你需要在多个按钮上实现点击时的动画效果你可以创建一个类封装按钮点击时的动画逻辑实现动画效果然后在中使用这个在中的作用是将特定的功能逻辑封装成独立的组件以便于重用和维护通过使用开发者可以更灵活地扩展控件的功能同时保持代码的整洁和模块化是一个用于在中根据多个数据绑定条件来控制元素属性的触发器它的主要作用是在所有指定的条件都满足时执行特定的操作如设置属性值满足条件触发单个中多个是与的关系每个间是或的关系常见误区两个常见误区对于开发还不够了解很多思维停留在阶段比如在代码后台修改控件的样式对于开发还不够了解认为就是要用绑定和把事件改成常见错误例子的功能虽然使用了但是按钮是否可用是绑定了另外一个属性不再额外写一个属性用来控制的而是使用本身的本质上也是控制的使能会让控件变灰比方说执行处理时间中变灰处理完自动亮起的本身就可以处理这个逻辑但要注意才支持该功能想要让在鼠标置于上方时就实现交互操作相当于让按钮不再被点击后才触发事件直接修改的值中有如果想要实现在鼠标置于上方时修改文字内容会想办法注册和事件然后再写一个属性用于绑定使用注意上方的的会处理掉处理的事件即二者同时存在的时候只会处理为的无视后者当鼠标置于上方时实时输出鼠标在控件中的坐标虽然这里可以通过的参数把自身传到中进行处理但其实是不符合架构设计逻辑的错误做法如下此处不用手写直接使用会自动传递中直接就可以处理了但这种做法依旧是不对的违背了不处理的原则正确做法如下写一个自定义行为并通过绑定的用于传出信息资源和样式资源系统是一种保管一系列有用对象如常用的画刷样式和模板的简单方法从而使您可以更容易地重用这些对象每个元素都有属性该属性存储了一个资源字典集合它是类的实例资源集合可包含任意类型的对象根据字符串编写索引可以在任何元素上定义资源可通过指令来分配唯一键查找资源的方向是沿着逻辑树向上查找资源包含重复的内容控件风格样式数据模板动画窗体的写法控件的写法上面两种资源的作用范围都局限于当前窗口或控件下如果需要设置全局样式参考此处给单个控件添加样式很简单直接是通过给属性设置值的方式来设置样式但如果需要针对多个或同一类控件都设置为同一个样式呢单个添加属性的方法就很繁琐了此时就需要用到样式静态资源和动态资源静态资源使用指的是在程序载入内存时对资源的一次性使用之后就不再去访问这个资源了动态资源使用指的是在程序运行过程中仍然会去访问该资源只要是需要运行中改变的资源都得用动态资源例如最常见的改变颜色资源管理形式在项目中我们一般有以下几种方法来管理直接在窗口对应的中定义资源这样可以方便地在主窗口中使用资源但是如果资源很多或者需要在其他窗口或用户控件中使用就不太合适在中定义资源这样可以让资源在整个应用程序的范围内共享实现一致的主题和外观但是如果资源很多或者需要根据不同的窗口或用户控件进行区分就不太合适创建文件夹并创建内容元素为的页面这样可以将资源分组和模块化方便管理和维护也可以根据需要在不同的窗口或用户控件中引用或合并资源引用方法在中使用属性来合并多个文件资源字典这样可以让资源在整个应用程序的范围内共享样式样式是修改窗体控件样式的主要手段主要作用更改控件的外观以及增强用户体验样式是一种将一组特征属性值应用到多个元素的方法用于设置控件的外观属性如长宽颜色字体大小等中的各类控件元素都可以自由的设置其样式在设定时我们需要使用声明键名并设置目标类型使用将类型传入在标签的内容区通过标签设置属性和属性值案例可参考切换输入与绑定模式类的属性设置属性值以及自动关联事件处理程序的对象或对象的集合是类中最重要的属性但并非唯一属性类主要用于控制控件的静态外观风格继承自类能自动改变样式设置的对象集合例如当另一个属性改变时或者当发生某个时间时可以修改样式类主要用于控制控件的动态行为风格希望用于样式的资源集合通过该属性可创建继承自其它样式设置的更具体的样式虽然可以继承但建议继承关系尽量简单不建议过多使用该属性标识应用样式的元素类型通过该属性可创建只影响特定类型元素的设置器还可以创建能够为恰当的元素类型自动起作用的设置器是否允许派生出其他样式也就是是否密封具有两个主要属性属性指定要设置的属性名称可以是任何依赖属性或依赖对象的属性值指定要为属性设置的值样式案例下面内容包含于标签中针对这个窗口下的所有也能写成默认设置这个默认设置实际上没用因为的优先级要比他高上面是作用于一批控件如果想指定样式呢可以在控件上指定样式通过属性如果不添加属性那么就是针对当前作用范围内的全部指定控件重点是这里的他的值作为该的唯一标识默认设置这个默认设置实际上没用因为的优先级要比他高在控件上通过下面属性使用该注意标签必须定义在控件定义之前即写在上面登录此处使用的是表示静态资源即当程序运行起来后这个样式是不会发生变化的即使后续修改了样式真实的效果也不会变化在应用程序启动时就进行加载启动时消耗更多的资源但在运行时性能较好在需要时才加载支持在运行时动态更新资源提供了更大的灵活性可以使用沿用之前的代码如下继承原本的样式去设立新样式控件中使用样式索引名来使用该新增样式样式索引名全局样式项目上右键添加资源字典选择资源词典比如说新建资源词典在中编写如下代码引用文件全局引用文件由于是在中引入了文件因此作用范围是整个程序定义样式定义样式属性其他样式设置引入样式写法这是一个资源字典用于定义和组织可重用的资源如样式控件模板颜色等属性属性指定了资源字典的路径路径使用了语法这是中用于引用资源的标准方式表示这是一个应用程序包它通常用于引用应用程序中的资源这是语法的一部分用于分隔不同的组件这是资源的具体路径表示资源所在的程序集名表示这是程序集中的一个组件表示资源在程序集中的具体路径这行代码的作用是将程序集中文件夹下的文件中的资源字典合并到当前的资源字典中这样中定义的资源如样式模板等就可以在当前上下文中使用了在原有的样式上添加以下面的代码为例上面为在原有样式基础上添加的样式上面代码案例也可以了解一下通过转换器来进行的多绑定将自身元素的和自身元素的属性提供给来判断是否触发效果主题切换方案实现主题切换功能的基本思路是使用动态资源来定义控件的样式然后在运行时更换不同的资源字典来改变控件的外观模板控件模板控件模板定义了控件在界面上的呈现方式包括控件的布局样式触发器和绑定等通过修改控件模板可以自定义控件的外观使其符合特定的设计需求和用户体验要求在控件模板中可以使用各种控件和容器元素来构建控件的可视化结构数据模板数据模板和控件模板的关系对象通常被用来作为数据及数据模板的载体其只有属性而没有属性生成的控件树其根节点就是目标控件也就是要针对什么控件去设计模板生成的控件树根节点是一个控件控件是控件模板上的一个结点所以数据模板是控件模板的一颗子树相关构成元素经常被用于作为控件的底层包裹物并提供边框和背景样式用于呈现其他控件或对象的内容它通常用作控件模板中的占位符用于呈现控件的内容并根据模板中的属性设置进行对齐和布局既可以呈现对象的内容又可以是其他控件可以使用中心内容呈现控件或来呈现控件的内容或子元素从而保留控件的基本功能注意该控件内含属性绑定外界控件案例参考按钮开发案例模板绑定用于在控件模板中绑定模板内部元素的属性与外部控件的属性之间建立关联使用可以在控件模板内部直接引用外部控件的属性而无需手动编写绑定表达式以一种简洁直接的方式访问外部控件的属性从而实现属性在父子层级中的传递和同步模板中的绑定注意项模板中不能使用写法取而代之的语法是属性名通过这种方式找下的例子为上面的是自已定义的命名空间指定了要查找的祖先元素的类型会在视觉树中向上查找直到找到类型为的祖先元素指定了要绑定的属性路径综合理解查找类型为的祖先元素然后从该祖先元素的中获取名为的属性或命令并将其绑定到按钮的属性上或者类似下面这样连接控件模板的是一种用于定义和自定义控件的外观和结构的模板它可以完全替换控件的默认模板实现个性化和复杂的效果的有以下几个特点是一个元素它可以包含任何类型的元素如布局形状图像文本等这些元素构成了控件的视觉树可以使用或来绑定控件的属性或数据从而实现动态的显示和更新可以使用来定义控件对不同的条件或事件的响应如改变属性播放动画执行操作等可以使用中心内容呈现控件或来呈现控件的内容或子元素从而保留控件的基本功能可以在或中定义并应用到一个或多个控件上从而实现资源的重用和管理查看默认模板右键编辑模板编辑副本弹框点击确定这样就会在下边生成一个样式片段包含各种属性以及模板中含有的各种控件如简单自定义一个按钮的外观点击我触发器的是一种用于定义和管理资源的触发器它可以根据不同的条件或事件来改变控件的属性或行为以下是触发器的类型基本触发器这种触发器是根据控件自身的依赖属性的值来触发的例如当鼠标移动到按钮上时改变按钮的背景色数据触发器这种触发器是根据绑定的数据的值来触发的例如当绑定的数据为真时显示一个图标多路数据触发器与数据触发器类似但可以同时满足多个数据绑定的值事件触发器这种触发器是根据控件的路由事件来触发的例如当按钮被点击时播放一个动画多条件触发器这种触发器是根据多个条件的组合来触发的例如当控件的属性和绑定的数据同时满足某些值时改变控件的样式基本触发器基本触发器控制鼠标经过或按下时的案例鼠标经过时鼠标按下时多条件触发器下面条件满足一个相当于中的这一行才触发下面改变当条件同时满足时才会触发数据触发器该触发器无非就是多了属性多路数据触发器下面条件满足才触发下面改变事件触发器以窗口的加载事件为例接到上面的命名空间后这里值得注意的是在窗口关闭的时候并不会触发应该用绑定的事件才能触发控件模板案例以按钮的自定义模板为例通过来获取使用模板传入的属性自定义按钮设置模板的外观设置模板的交互上面这种写法只能作用于该在中引用新添加的资源词典在资源词典中写样式就可以用于全部控件也可以新建一个继承资源词典中的样式就针对来编写上描述的资源词典写法如下上面引入项目的命名空间下面可以添加指定引用名只让某些元素引用触发器中不能使用写法取而代之的语法是属性名注意数据模板在中有两种类型的控件支持数据模板内容控件通过属性支持数据模板内容模板用于显示任何放置在属性中的内容列表控件继承自类的控件通过或者属性使用支持数据模板这个模板用于显示作为提供的集合中的每个项或者来自的每一行定义数据模板放置什么都可以通过直接绑定某个类型在内部就可以直接绑定该类型内部的成员如例子中的是类型的一个成员使用数据模板数据模板盘点用途用于定义如何显示单个数据对象的视觉表示可以用于任何控件例如等示例用途用于表示层级数据结构特别是在树形控件如中可以定义父项及其子项的显示方式示例用途用于定义集合中每个项的显示方式通常用于等控件示例用途用于定义控件的外观和行为可以完全替换控件的视觉树示例用途虽然不是严格意义上的模板但样式可以定义控件的外观和行为包括触发器和属性设置示例用途用于根据特定条件选择不同的数据模板可以在运行时决定使用哪个模板示例层级数据模板中的是一种用于定义具有层次结构的数据的显示方式的模板它可以用于支持的控件例如或有一个属性用于指定子节点的数据源以及一个属性用于指定子节点的模板自定义数据项模板暂时放这不知道是否合适是中的一个控件用于显示一组数据项它提供了一种灵活的方式来定义如何呈现和布局这些数据项以下是的一些主要用途和功能数据绑定通常与数据绑定一起使用通过属性绑定到一个集合如等每个数据项都会生成一个对应的元素定义数据项的模板自定义数据项模板通过属性可以定义每个数据项的显示模板用于描述每个数据项的外观样式和外观可以通过属性自定义每个数据项容器的样式是提供的一个类它表示一个动态数据集合当集合中的项添加移除或刷新时它会提供通知当集合发生变化时会触发事件当集合的属性如或发生变化时就会触发事件使用后框架本身也就可以支持使用该注意注意的方法不会触发更新要尤其注意可以重新一个来赋值作为类似这种原本不属于而是属于语法的也不支持自动更新使用下面原始语法例子代替能更新绑定的代替不能更新绑定的模板的内部访问控件模板的内部访问和两个类均派生自类这个类有个名为的方法提供我们检索其内部的控件控件模板的内部访问非常简单核心在于针对目标控件的属性使用方法并使用关键字指定类型即可其实就是去找到对应控件的属性再调用它的方法数据模板的内部访问数据模板的内部访问核心在于对于视觉树的检索通常需要自建一个方法通过指定需要访问的目标类型借助类的方法递归地遍历的可视化树直到找到你想要的控件属性优先级规则有一套明确的属性优先级规则大致如下从高到低控件的直接属性设置中手动设置的值动画和数据绑定的值控件模板中的设置中的和默认值自定义控件与用户控件自定义控件通常涉及对控件的更底层的渲染和行为进行定义这包括从类或其他更具体的控件类继承以创建控件类定义控件的默认样式和模板添加新的依赖属性根据需要重写方法以自定义控件的行为以及定义和触发自定义事件等步骤这样的控件通常是从头开始创建或扩展现有控件功能的可以具有很高的灵活性和自定义程度用户控件则是通过组合其他控件来构建的用户控件允许开发者在其应用程序中轻松地添加和删除控件以实现特定功能创建用户控件需要创建一个新的类并继承自然后在用户控件类中添加所需的元素如按钮文本框等还可以添加事件处理程序和方法以实现自定义功能同样可以添加依赖属性使用难度来说自定义控件的开发过程相对复杂因它们涉及到底层的渲染和行为定义且没有设计器提供设计支持而用户控件的开发过程则相对简单并且有设计器提供设计支持使得开发者能够更直观地构建和编辑控件自定义控件一般用于控件的继承用于将一个控件继承出一个新的控件出来的将会是一个文件用户控件自定义控件案例以一个自定义控件为例注册依赖属性属性包装器使用方式你好世界解释依赖属性注册在类中使用方法注册一个名为的依赖属性这个属性的类型是并且它的默认值是一个空字符串属性包装器定义一个属性它使用和方法来访问和设置依赖属性的值绑定在中使用来绑定的属性到这种方式依赖于的设置如果的被设置为某个视图模型将会从这个视图模型中查找如果的没有被设置或者没有包含则会导致绑定失败这种方式明确指定了绑定的来源是本身这意味着无论是什么都会从中获取的值这种方式更加可靠确保了无论外部如何变化都能够正确显示的值案例如下绑定到集合的列数绑定到的属性绑定到当前项的值定义了的面板模板使用来布局子项设置的列数为集合的项数定义了每个子项的模板使用来定义子项的外观实现控件自定义所需知识点盘点动画进入动画代码详解动画逐帧动画时分秒动画间隔多久是否自动复原动画针对谁动画针对的属性将所设置的属性的值从多少设置到多少缓动函数三角函数缓动函数回弹式缓动函数函数贝塞尔曲线缓动函数有力量的缓动函数等等非常多动画案例下面以一个圆形红点的闪缩动画为例瞬间切换到不透明等待一段时间切回透明等待一段时间使用该动画录制中可以在中定义使用标识然后在中的中使用变换旋转度可以通过变换之前的点得到变换后的点的坐标位置渐变画刷写法记录渐变画刷的值通常在到之间表示渐变的起始位置而表示渐变的结束位置表示渐变的起始点通常以坐标的形式给出表示渐变的结束点通常也是以坐标的形式给出可选值如下表示渐变从左上角开始或结束表示渐变从左下角开始或结束表示渐变从右上角开始或结束表示渐变从右下角开始或结束子线程中操作界面在中控件绑定的属性通常是由线程主线程管理和更新的在大多数情况下不建议在子线程中直接操作绑定的属性因为的控件通常不是线程安全的直接在非线程中操作可能会导致线程安全问题和界面更新异常如果您需要在子线程中更新控件的绑定属性可以使用以下方法来确保线程安全使用在子线程中通过控件的调度到线程执行更新操作例如同步等待线程调用在线程中更新绑定属性异步等待线程调用或在线程中更新绑定属性上面这段代码一般会加使用如果需要定时更新控件的绑定属性可以使用它在线程上运行例如在线程中更新绑定属性在执行操作之前最好使用方法检查当前线程是否为线程如果不是再使用或来确保操作在线程上执行在线程上执行操作在线程上更新在非线程上使用确保在线程上执行在线程上更新提供了方法允许你在多线程环境中安全地更新这个方法会启用集合的线程安全访问使得你可以在后台线程中直接修改集合而不需要显式地使用启用集合的线程安全访问在后台线程中接收数据还有一种方法为自定义创建一个自定义的它内部使用来确保所有对集合的修改都在线程上执行这样可以简化代码避免在每个地方都显式地使用类似地可以重写其他方法如等使用自定义的在后台线程中接收数据自动调度到线程在线程中修改集合自动调度到线程默认代码片段记录快速生成属性代码快速生成完整属性代码快速生成依赖属性快速生成构造函数快速生成快速生成完整命令写法相关库库查询网址库开源地址开源下载链接其中有各种控件效果打包而成的应用程序参考链接提供的相关属性参考此处正确性未经验证是一个开源的控件库提供了一系列丰富的控件和功能旨在帮助开发者更轻松地构建现代化的应用程序它包含了许多常用的控件和样式极大地扩展了的默认控件集主要特点丰富的控件提供了许多额外的控件比如按钮文本框进度条日期选择器消息框等这些控件通常具有更丰富的功能和更现代的外观主题和样式它包含多种主题和样式可以轻松地应用到整个应用程序中帮助开发者快速实现统一的用户界面设计开源是开源的开发者可以自由使用修改和扩展它的功能易于集成它易于集成到现有的项目中并且有良好的文档和示例代码帮助开发者快速上手如何使用包管理器安装中引用引用的主题资源字典应用主题控件使用方式盘点滑动条单值滑动条范围滑动条进度按钮下面控制是否显示进度条启动自动演算数字输入框步长控制精度这里介绍一种样式当和属性不同的时候应用红色阴影效果当属性相同的时候取消阴影效果开关按钮启动自动演算按钮组应用比例带重置比例带显示控件时间获取用于指定如何显示时间选择器的时钟以列表的形式显示可选择的时间对话框使用现成的发送内容为空提示自定义对话框发送内容为空定义如下发送内容为空阿里矢量图标库中获取图标参考链接这里的就是自定义导入的几何图形在中进行导入如果获得的内容呢打开开发者工具去找中获取相关图标的代码然后把这段的值复制到我们的文件中如下所示上面的图表只有一个有时候阿里矢量图标库使用图标有多个的组合我们如果也要采用那么定义稍微调整一下通过来定义父级然后添加多个集合即可使用按钮展示几何图形但这样只适合展示静态几何图形使用按钮动态切换几何图形使用和的方法可以更灵活地切换内容的和有时可能无法直接影响复杂的子元素属性如几何图形而可以通过模板轻松切换整个内容模板切换可以根据数据绑定的值动态切换这使得在不同状态下显示不同的内容变得非常简单复杂内容可以在中定义复杂的结构而不仅限于简单的属性设置并且使用可以更好地控制整体大小并保持内容的比例切换主题色用法如下详情参考此处表示设置为置顶然后就可以使用这种语句来控制出现显示信息超时无响应此处的对应上面的覆盖默认样式可以使用这种语法来覆盖的默认样式开源控件库图表控件库库名称安装好看速度手册等专有技术文章必要必要必要不要如果以绘制大量数据的速度为准则最好如果为了绘图方便则是最佳选择如果你想专注于设计或制作动画是个不错的选择如果你想实现一个类似的图表的东西那就只能用是和的中间存在绘图库性能强悍千万级数据处理无压力媲美开源开源地址程序下载绘制速度与下的标准一样与相比较更快与标准相比图表类型更加丰富且视觉表现上更加漂亮下搜索选择安装缺点不支持模式缺点在图表上标注每个点的数据没有其他图表库方便缺点要绘实时折线图表没有其他图表库方便官方文档绘图这是一个来自库的控件用于在应用程序中绘制图表为该控件指定一个名称可以在代码后面中引用这个控件设置该控件的轴索引为意味着它会被放置在其他控件的下方如果存在其他控件启用内容滚动这样当内容超出可视区域时可以滚动设置滚动单位为项目这意味着滚动将以单个项目为单位进行启用虚拟化这意味着只会创建可视区域内的元素提高性能设置虚拟化模式为回收模式这样可以重用已经不再可见的元素进一步提高性能设置控件的宽度为像素设置控件的外边距左边距为像素可能会使控件向左移动上下和右边距为设置控件的背景颜色为黑色这款控件强大的根本原因可以参考官方网址其如此写到许多图表库使用和数据绑定模式与图表进行交互则不使用这一有意为之的决定让的性能更佳因为它让用户能够直接访问用于绘图的数组值并且还让用户能够完全控制何时渲染新帧这可能是一项成本高昂的操作虽然模式和数据绑定在设计交互式应用程序时通常很有用但请考虑几乎所有功能都可用于从无头控制台应用程序创建静态图像而这些模式在这些应用程序中的使用并不广泛和数据绑定模式可用于创建包装图的图形控件强烈希望使用数据绑定或模式的用户可能正在使用特定于平台的开发框架例如并且只想创建一个控件来完成一项任务例如具有特定样式和布局的交互式散点图鼓励这些用户编写自己的用户控件来实现此自定义数据处理和渲染功能控件的设计非常简单鼓励想要将数据管理与图形交互性结合起来的用户使用他们选择的模式编写自己的控件常用代码盘点官方详解标准平台下使用的图标控件平台通组件嵌入使用官方网站有说明但是并不容易看懂与其他图表库比较这个更加难以理解但是由于平台的信息比较丰富这就补足了它的不全可以创建类型的图表这是其他图表库中没有的功能并且可以绘制的图标种类繁多虽然需要编写一些代码单支持鼠标放大和缩小以及像一样的快速绘制图表设计时比其他图表库更令人着迷渲染万个点量级不卡官方网站上的信息有点难以理解许多地方的描述和图表示例不一致官方文档默认情况下使用来渲染控件这意味着您可以使用所有在画布上绘图您可以在此处找到有关的更多信息十字线参考多线程参考使用的多线程用法不要使用子线程执行效率大幅降低应该在线程中执行需要安装此处记录一个重置缩放的做法重置轴重置轴通知图表更新仓库地址引入库方式管理器中搜索找到下载在中引入库的命名空间优化界面布局原本需要间隔开空间是用控制的但添加外边距之后其本身与外边距是一个整体解决这个问题可以使用内置属性和可以设置水平和垂直间隔内容过渡效果封装以下面的平滑动画过渡为例支持显示与控制中的控件可以显示内容但是切换的话会卡在某一帧停止播放项目地址只支持注意不支持显示采用如下方法解决显示的手动方法显示动图要显示的控件文件的路径创建一个列表来存储的每一帧使用解码文件检查解码器和帧是否有效将所有帧添加到列表中创建一个对象动画用于逐帧显示设置动画持续时间为每一帧创建一个关键帧并添加到动画中设置控件的初始显示帧创建一个来控制动画设置动画循环播放设置动画结束后保持最后一帧将对象动画添加到中设置动画的目标控件和属性开始播放动画将存储在控件的属性中以便后续释放停止并清理动画使用如下开始停止这是一个框架包含很多功能其中有一个数据验证的功能可以参考此处好用的值转换器开源开源地址提供了很多现成的转换器允许串联转换器盘点一些转换器转换器组到可见性字符串非空或对于字符串表示长度是否在范围内对于数值表示值是否在范围内设置范围值反转字符串转换为小数做的事情只是把当前转换器的信息输出到中不会改变任何值用于调试转换器组基本使用方式没有方式引入直接使用引用程序集方式引入引入需要用到的转换器并定制使用上面定制的转换器绑定为名的控件的属性使用上面的转换器如果不定制只需要默认的就不需要引入串联转换器组使用方式引入需要用到的转换器并定制用于组合多个转换器是否为空或返回反转值值到可见性转换使用上面定制的转换器串联转换器代码原理参考核心就在于在中两两一组将转换器串联起来了该库只支持到版本需要支持跨平台桌面应用程序框架可以改用是一种高级绑定标记扩展它允许您在中编写计算绑定表达式而无需自定义转换器可以自动执行到可见性的转换不同的代数运算反转表达式等等使绑定表达式更短更方便用户使用这个库相当厉害很有研究价值开源地址使用方式如下布尔值运算如下可以编写任何代数逻辑和字符串表达式其中包含源属性路径字符串数字类的所有成员以及以下运算符因为在不支持在设置属性值时使用所以需要使用替换也可以使用中的方法这样的以及形式为的三元运算符字符串用法案例其中代表双引号颜色用法解读该开源项目功能详解表达式解析入门本质上上调用了第三方库文件类实现了接口并使用了缓存机制来提高表达式解析的性能它通过维护一个字典来存储已经解析过的表达式避免重复解析当需要解析一个表达式时它首先检查缓存中是否已经存在该表达式的解析结果如果存在则直接返回缓存中的结果如果不存在则使用内部的实例进行解析并将结果缓存起来文件类实现了接口它使用库来解析表达式它通过类的方法来解析表达式并通过方法来设置引用类型文件类提供了一个创建实例的工厂方法它可以创建一个实例并可以指定内部的实例如果没有指定则默认使用实例文件接口定义了表达式解析器的两个基本操作和方法用于解析表达式文本并返回一个对象而方法用于设置解析过程中可能需要的引用类型表达式求逆文件定义了一个自定义异常类用于在表达式求逆过程中抛出异常继承自并提供了四个构造函数分别用于无参数带消息带消息和内部异常以及序列化时使用文件定义了一个泛型类它继承自这个类的目的是提供一个二维字典的实现其中和是键的类型是值的类型它提供了添加元素和获取元素的方法以及一个索引器可以通过两个键来访问值文件这个文件是求逆操作的核心它包含了一个类用于对表达式进行求逆类依赖于一个表达式解释器用于将字符串表达式解析为对象类的构造函数接受一个接口的实现作为参数方法是求逆操作的入口它接受一个表达式和一个参数表达式返回一个表达式表示求逆后的表达式方法是一个递归方法用于遍历表达式树生成求逆后的表达式方法用于将表达式类型转换为字符串以便在生成求逆表达式时使用是一个常量字符串用于在生成求逆表达式时占位是一个私有字段用于存储表达式解释器部分定义了一些用于递归函数工作的类型包括和路径分析绑定路径解析器它的功能是分析绑定路径字符串并将其拆分成不同的路径片段以便于进一步处理定义了一个类用于标识路径片段的类型和值它包含两个属性和分别表示路径片段的类型和值此外它还重写了和方法以便于比较和哈希处理定义了一个枚举用于标识路径片段的类型它包含四个成员和分别表示数学路径属性路径静态属性路径和枚举路径定义了一个抽象类用于表示路径片段的基类它包含两个属性和分别表示路径片段的起始位置和结束位置此外它还包含一个抽象属性用于获取路径片段的标识定义了一个类用于表示枚举路径片段它继承自类并增加了两个属性和分别表示枚举类型和枚举成员此外它还重写了属性以便于返回正确的路径标识定义了一个类用于表示属性路径片段它继承自类并增加了一个属性用于表示属性路径的名称列表此外它还重写了属性以便于返回正确的路径标识定义了一个类用于表示数学路径片段它继承自类并增加了一个属性用于表示数学路径的名称此外它还重写了属性以便于返回正确的路径标识定义了一个类用于分析绑定路径字符串它包含一个静态构造函数用于初始化一些静态字段此外它还包含一些私有方法用于获取路径片段分析路径类型等最后它包含一个公共方法用于解析绑定路径字符串并返回一个路径片段列表定义了一个类用于表示静态属性路径片段它继承自类并增加了两个属性和分别表示静态属性所在的类和命名空间此外它还重写了属性以便于返回正确的路径标识追踪系统用于记录和输出程序运行时的信息帮助开发者调试和分析程序文件定义了一个枚举类型其中包含两个成员和这个枚举类型用于标识追踪信息的来源组件例如如果信息来自于组件那么在追踪信息中就会包含这个标识文件定义了一个密封类它负责追踪信息的记录和输出这个类有一个静态构造函数用于初始化两个静态字段和是一个对象用于控制追踪的级别是一个对象用于输出追踪信息类似于但是是商业产品要收费产品介绍是一个用于和的动画库旨在仅使用附加属性来实现动画开源开源地址是一个开源易于使用强大的控件库旨在帮助开发人员在和中实现的风格的用户界面该框架提供了一组丰富的控件样式和效果使开发人员能够轻松创建现代化具有吸引力的应用程序开源开源地址中修改要引用的文件中只作用于局部控件是一个版的前端样式库该控件库参考了版本的风格利用该控件库可以完成现代化客户端程序让你的客户端看起来更加简洁丰富又不失美感无开源协议开源地址新手引导控件开源开源地址注意在包搜索的时候要勾选包括预发行版才能搜到添加默认主题文件具体使用方式参考此链接相关的实现原理可以参考这个混淆工具开源混淆与反混淆工具大全盘点实测未找到反混淆工具不知道是否就是开源用于快速注册全局快捷键开源地址配置库控件库内含各种图表库看起来不赖图表所在包一些依赖属性盘点属性名称类型作用用于存储和绑定轴的显示数据用于存储和绑定轴的显示数据用于设置图例的样式用于设置视觉映射的样式控制是否显示刷新按钮控制是否使用图例控制是否显示网格控制是否使用标记线控制是否使用标记位置控制是否需要调用方法进行刷新表示需要手动调用刷新表示属性更改时自动刷新用于存储轴的坐标数据用于存储轴的坐标数据用于存储轴的数据点用于存储轴的数据点用于指定轴的坐标点个数用于指定轴的坐标点个数控制轴是否根据数据自动计算控制轴是否根据数据自动计算控制是否在数据刷新后只绘制一次图表相关动态曲线案例参考官方项目的正弦曲线平均值横轴显示如此写更新点数示波器最大值控制轴网格显示曲线抽稀参考的是主要是用于处理静态图抽稀前抽稀后阈值抽稀后阈值值得参考的成品项目拖拽节点编辑器框架开源支持学习参考官方学习项目创建向导插件可以支持直接常见应用程序的框架支持以及设计模式包括强制登录可选登录包括主题色选择功能打包功能等包括各种测试框架详细用法参考内含错误的解决方式二进制编辑器控件库开源协议二进制编辑器控件包下载的支持不是那么好需要自己进行二次封装打包参考是一种用于打包和分发应用程序的技术旨在取代传统的应用程序安装方式如和是提出的一个现代化的打包格式旨在提供更好的安全性可靠性和用户体验动画库开源动画库只需要为任何需要动画的内容设置附加属性即可引入矢量图参考链接与交互交互方案微软提供最老的不建议使用支持微软提供微软优化第三方用户数量大兼容浏览器最广泛最低可以支持到支持基于控件是基于的优点简单易用适合基本的网页显示需求可以直接在中使用缺点依赖于可能不支持现代网页技术如和性能较差尤其是在处理复杂网页时安全性较低可能会受到的安全限制显示相关直接显示一个外部网页显示一个自己编写的网页项目下创建一个文件夹为下面创建文件里面编写代码该代码文件必须设置属性为资源在后台文件中引入文件到控件加载资源到页面和交互调用方法中添加按钮按钮处理事件数据监视默认数据显示中文点击执行逻辑调用方法后台文件中为浏览器控件准备可调用的对象实例加载资源到页面给他更高权限关联技术基于这个方法将由调用调用时传递一个参数进来调用方法中添加方法数据监视准备一个方法给调用默认数据显示中文点击执行逻辑调用方法在中演示中绑定事件定义调用的方法因为在子线程中所以要由线程调用下面语句与的有区别调用方法服务器方式上面通过资源加载的方式有个很大的弊端就是无法加载单独的代码解决方案就是程序开启一个服务器通过服务器加载这一套网页控件通过本地链接绑定到本地页面上就不需要通过资源加载的方式进行这也是为什么用的少的原因要真正做好的话还得使用服务器就是解决这个问题的不存在上来就是基于是及更高版本中引入的控件基于优点支持现代网页技术性能较好提供了更好的安全性和稳定性可以使用适合开发现代应用程序缺点仅适用于和更高版本需要额外的设置和配置可能比更复杂使用需要引入库官方文档中引入命名空间等于号后输入自动补全中用这个中用这个显示相关显示外部链接显示本地网页后台文件注意文件要设置为始终复制比资源加载好在当更新的时候不需要更新程序直接更新就可以了到数据传递有两种方式执行方法也能通过参数传递信息传递数据方执行方法中文将发送到控件中除了信息也支持数据文件准备一个方法给调用监听传上来的信息除了也支持传递传上来的是一个对象要用取其中的值调用方法后台文件比资源加载好在当更新的时候不需要更新程序直接更新就可以了得在初始化完成的事件中才能将要被调用的方法传递给控件完成后才会回调的方法将要被调用的方法传递给控件点击执行逻辑调用方法注意中出现的就是后台文件中的获取返回值上面的方法向请求数据会比较麻烦因为需要两个处理传递请求传过去结果传回来能获得返回值的话也就可以一次处理完成使用来取返回值调用方法并接收返回值比资源加载好在当更新的时候不需要更新程序直接更新就可以了得在初始化完成的事件中才能将要被调用的方法传递给控件完成后才会回调的方法将要被调用的方法传递给控件给他更高权限关联技术基于返回的信息网页加载时代码方法非常强大可以帮助开发者在网页加载时注入自定义的代码从而实现各种功能和效果如可以直接创建一个语句来在文档创建时执行也得在初始化完成的事件中才能被正确执行基于是一个基于的开源项目按照文档内容使用时需要保留版权声明开源项目地址中文帮助文档包一层的方式进行的包装是一个开源项目允许开发者将浏览器的功能嵌入到其他应用程序中提供了一个简单的使得在桌面应用程序中使用技术如和变得更加容易在上开源免费功能上与是同步的是一个强大的工具允许开发者在其应用程序中嵌入现代网页技术提供丰富的用户体验优点支持现代网页技术性能优越可以自定义浏览器的行为功能强大可以处理复杂的网页和应用程序适合需要高性能和高兼容性的场景缺点相比于和集成和使用相对复杂需要额外的包和依赖项增加了项目的复杂性包体积较大可能影响应用程序的大小使用方式下面的流程适用于或更高版本参考的是此链接通过安装右击项目管理程序包在打开的界面中搜索依次安装因为不支持所以要配置点击菜单生成配置管理器选择解决方案平台点击编辑先将和删掉再重新新建重新配置比较容易些添加命名空间如下显示相关这个控件放置不会占用空间只有绘制先后的顺序因此可以直接在其上绘制控件显示外部链接后台文件如下显示本地文件要显示的文件一定要设置复制到输出目录为始终复制后台文件如下调用方法准备一个方法给调用调用方法代码调用代码是方法执行注意线程执行显示控制台调用方法在中注册对象有两种选择第一个是提前注册的这通常是在创建实例后立即完成的第二个选项更灵活并允许在需要时解决对象第二个方案试验不成功第一个方案这个方案必须在创建浏览控件之前注册提供给调用的类你好世界点击执行逻辑调用方法后台必须在创建之前注册个人理解定义的浏览器控件不能使用这种方法这里的就是在中的的新建类供调用的方法集合无返回值的带返回值的返回的信息第二个方案略参考该链接现有程序迁移到端平台与控件互相使用可以通过使用控件可以通过使用控件捕获全局异常线程未捕获异常默认情况下捕获未经处理的异常从对话框中通知用户异常他们可以从该对话框中报告异常并自动关闭应用程序这是和等框架特有的机制它会在线程上捕获未处理的异常如果方法是由线程的事件触发的异常会被传播到线程最终由捕获可以取消应用程序终止通过设置可以防止应用程序崩溃并处理异常非线程未捕获异常是框架中全局异常处理的机制用于捕获大部分未处理的异常无论它们来自线程还是后台线程此机制适用于整个应用程序域无论是同步代码还是异步代码中的异常只要没有在代码中捕获处理它们都会触发该事件应用程序仍会崩溃虽然该事件能捕获异常并进行日志记录或其他操作但应用程序通常仍然会崩溃因为事件仅用于通知而不能阻止应用崩溃未观察到的任务异常默认不会终止程序是用于处理异步任务中未观察到的异常如果你使用或当异步操作抛出异常且未被处理时该异常会触发事件虽然这个机制对没有直接帮助但它在处理时非常有效当任务出现异常并未被观察即没有或捕获异常该异常会被标记为未观察到的任务异常进而触发这提供了一层额外的保护确保在特定情况下未捕获的异常不会引发崩溃仅适用于异步任务中的异常用于处理异步代码中未被观察的异常可以避免应用崩溃通过标记异常为已观察防止崩溃可以防止由于未观察到的任务异常导致的应用程序崩溃垃圾回收前触发事件会在垃圾回收过程中触发如果该异常仍然没有被处理那么应用程序会终止下面是框架中注册全局异常捕获线程未捕获异常处理事件线程内未捕获异常处理事件多线程异常防止程序闪退标记异常为已观察判断是否会导致程序终止可以生成文件异常信息来自调用堆栈方法的异常会直接传播到调用它的线程而不会像那样生成一个可等待的任务因此方法中的异常不会触发或这些传统的全局异常捕获机制测试案例未添加任何防闪退代码情况下线程中触发除零异常导致了中断触发除零异常触发除零异常中断触发除零异常中断触发除零异常中断框架中的事件聚合器回调体中直接除零异常中断也许只有并且使用了承接并且整个调用链上都没有才能真正触发如果中使用则只会触发后续触发包括中断都不会发生作为对比在控制台的全局未捕获异常订阅全局未处理异常事件在中处理未处理的异常捕获到未处理的异常可以在这里添加更多的日志记录或清理操作但要注意只能捕获在主线程和其他非线程中未被捕获的异常如果在新线程中发生异常而没有适当的捕获机制这些异常将不会被全局异常处理程序捕获在新线程中你应该使用结构来捕获可能发生的异常创建并启动新线程这里将引发除零异常捕获到线程中的异常无法全局捕获的异常除了栈溢出之外还有一些其他类型的异常也是不允许捕获和处理的直接导致进程闪退无法被全局异常捕获机制捕获这些异常包括当程序尝试分配的内存超过可用内存时会抛出这个异常通常无法被捕获因为没有足够的内存来执行异常处理代码当程序尝试访问无效的内存地址时会抛出这个异常通常无法被捕获因为它会导致进程崩溃在某些情况下当程序尝试访问空引用时会抛出在某些情况下可能无法被捕获例如当异常发生在系统调用期间结构化异常处理异常是特有的异常类型当程序发生结构化异常处理异常时会抛出这个异常通常无法被捕获因为它会导致进程崩溃损坏状态异常当程序的状态已经被破坏当程序的状态已经被破坏时会抛出这个异常通常无法被捕获因为程序的状态已经不可恢复当程序的执行引擎发生异常时会抛出这个异常通常无法被捕获因为它会导致进程崩溃当程序的代码不正确或被破坏时会抛出这个异常通常无法被捕获因为程序的代码已经不可恢复当程序的执行引擎发生致命错误时会抛出这个异常通常无法被捕获因为它会导致进程崩溃请注意这些异常通常是由于程序的错误或系统级别的问题引起的而不是由于异常处理机制的缺陷因此应该重点关注程序的错误和系统级别的问题而不是尝试捕获和处理这些异常快捷键相关程序内快捷键使用和事件按下时执行的操作放开时执行的操作值得记录的代码切换输入与绑定模式下面介绍通过一系列的绑定触发器和命令来实现既能显示绑定值的变化又能让用户编辑的功能默认显示状态默认显示的是通过绑定的值这个值是只读的用于显示当前的设置值进入编辑模式当用户点击时触发事件这个事件执行命令传入引出电源作为参数在中这个命令执行以下操作当变为时触发这个触发器改变的背景色并将属性绑定到新的绑定是双向的允许用户编辑值编辑值用户可以直接在中编辑值由于绑定设置了每次文本变化都会更新属性退出编辑模式虽然在提供的代码中没有明确显示但可能存在一个失去焦点或其他事件来触发编辑模式的结束这可能涉及将设置回或保存编辑的值事件触发这个命令可能负责将编辑后的值保存或应用到实际的设置中重点是使用一个标志位切换编辑模式和显示模式编辑模式和显示模式分别绑定一套数据下面罗列一部分代码引出电源绑定的第一套数据只读的不可编辑的绑定的可读写的数据更好的方式下面是更好的方法来实现的绑定切换使代码更清晰更易维护以下是一些改进建议使用单一绑定源和转换器在中使用单一属性更新编辑值更新显示值可能需要进行格式转换使用来处理显示和编辑值的转换从底层值转换为显示值从编辑值转换为底层值使用命令来处理编辑模式的进入和退出在中使用这些命令这种方法的优点使用单一的绑定源简化了将显示逻辑和编辑逻辑清晰地分开使用命令来处理模式切换使逻辑更集中更易于管理通过转换器处理值的转换使代码更加灵活减少了对多个可见性属性的依赖这种实现方式更符合模式使代码更易于理解和维护同时保持了原有功能的灵活性一些技巧盘点自定义控件如果不设置的值默认的值是此时没有东西的位置是不可点击的这个时候可以通过给属性设置为使自定义控件整个区域都是可命中区控件的默认值为的情况下那么只有在将鼠标悬停在图标上的时候才能点击所以为了在控件的整个区域内启用点击事件建议是将设置为透明这样一来点击控件的任何部分都能触发事件混淆工具参考链接安装使用该指令来安装使用在根目录执行读取配置文件进行保护配置文件如下输入的工作路径采用如约定的下的路径表示法如以下表示当前工作路径推荐使用当前工作路径因为的混淆过程需要找到的所有依赖刚好当前工作路径下基本都能满足条件混淆之后的输出路径如下面代码设置为当前工作路径下的文件夹混淆完成之后的新将会存放在此文件夹里以下的都是细节的配置配置如何进行混淆使用配置是否保持公开的不进行混淆签名如公开的类型公开的方法等等就不进行混淆签名了语法的写法就是表示某个开关而表示值对于大部分的库来说设置公开的不进行混淆是符合预期的设置为表示对于私有的进行隐藏隐藏也就是混淆的意思可以通过后续的配置设置混淆的方式例如使用字符替换或者使用不可见的代替设置为可以设置是否将使用的字符串进行二次编码由于进行二次编码将会稍微伤一点点性能二次编码需要在运行的时候调用进行转换为字符串设置为表示使用不可见的字符代替原有的命名通过此配置可以让反编译看到的类和命名空间和成员等内容都是不可见的字符是否复用命名设置为的时候将会复用命名如在不同的类型里面对字段进行混淆那么不同的类型的字段可以是重名的设置为的时候全局将不会有重复的命名配置是否需要重命名字段默认配置了为将都会打开重命名字段因此这个配置的存在只是用来配置为表示不要重命名字段是否需要重新生成调试信息生成符号文件需要进行混淆的程序集可以传入很多个如传入一排排程序集的引用加载路径对于应用特别是或项目是需要特别指定引用加载路径的这里有一个小的需要敲黑板的知识点应该让放在之前对于部分项目如果没有找到如下顺序将会在混淆过程中将某些程序集解析为旧版本从而失败还支持可以自己将混淆过程嵌入到构建过程里面如此可以实现在开发阶段对混淆的结果进行调试也就是开发时调试的就是混淆过后的自定义可被观察容器在中标准的无法像一样自动通知界面更新因为它未实现和接口因此下面是一个自定义的实现思路继承或封装一个字典结构实现集合结构变化时通知如增删键值对和字典整体替换时通知对字典值的修改如需触发属性变更通知适用场景需要高效键值查找且动态更新值的场景代码返回类型改为传递完整的参数重构通知方法实现接口整个容器重绘使用无参版本触发其他接口实现尝试添加键值对如果键不存在则添加并返回否则返回要添加的键要添加的值如果键值对被成功添加则返回如果键已存在则返回显式接口实现',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-03-19 13:41:31',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://th.bing.com/th/id/OIP.wtmjepfWPBvn26uz7s18dgHaHa?rs=1&amp;pid=ImgDetMain"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">ZEROKO14的个人博客</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size: 1.05rem;">C#<sup>3</sup></a><a href="/tags/C/" style="font-size: 1.05rem;">C++<sup>5</sup></a><a href="/tags/CSS/" style="font-size: 1.05rem;">CSS<sup>1</sup></a><a href="/tags/CSharp/" style="font-size: 1.05rem;">CSharp<sup>1</sup></a><a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 1.05rem;">C语言<sup>1</sup></a><a href="/tags/FPS/" style="font-size: 1.05rem;">FPS<sup>1</sup></a><a href="/tags/HTML/" style="font-size: 1.05rem;">HTML<sup>1</sup></a><a href="/tags/JavaScript/" style="font-size: 1.05rem;">JavaScript<sup>1</sup></a><a href="/tags/MFC/" style="font-size: 1.05rem;">MFC<sup>1</sup></a><a href="/tags/PE/" style="font-size: 1.05rem;">PE<sup>1</sup></a><a href="/tags/QT/" style="font-size: 1.05rem;">QT<sup>1</sup></a><a href="/tags/WPF/" style="font-size: 1.05rem;">WPF<sup>3</sup></a><a href="/tags/ai/" style="font-size: 1.05rem;">ai<sup>1</sup></a><a href="/tags/cmake/" style="font-size: 1.05rem;">cmake<sup>1</sup></a><a href="/tags/doxygen/" style="font-size: 1.05rem;">doxygen<sup>1</sup></a><a href="/tags/git/" style="font-size: 1.05rem;">git<sup>1</sup></a><a href="/tags/json/" style="font-size: 1.05rem;">json<sup>1</sup></a><a href="/tags/linux/" style="font-size: 1.05rem;">linux<sup>1</sup></a><a href="/tags/nas/" style="font-size: 1.05rem;">nas<sup>1</sup></a><a href="/tags/next/" style="font-size: 1.05rem;">next<sup>1</sup></a><a href="/tags/ppt/" style="font-size: 1.05rem;">ppt<sup>1</sup></a><a href="/tags/slidev/" style="font-size: 1.05rem;">slidev<sup>1</sup></a><a href="/tags/vue/" style="font-size: 1.05rem;">vue<sup>1</sup></a><a href="/tags/xml/" style="font-size: 1.05rem;">xml<sup>1</sup></a><a href="/tags/yaml/" style="font-size: 1.05rem;">yaml<sup>1</sup></a><a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 1.05rem;">代码规范<sup>1</sup></a><a href="/tags/%E5%86%85%E6%A0%B8/" style="font-size: 1.05rem;">内核<sup>2</sup></a><a href="/tags/%E5%86%85%E6%A0%B8%E7%9B%B8%E5%85%B3/" style="font-size: 1.05rem;">内核相关<sup>5</sup></a><a href="/tags/%E5%8A%A0%E8%A7%A3%E5%AF%86/" style="font-size: 1.05rem;">加解密<sup>1</sup></a><a href="/tags/%E5%9F%BA%E7%A1%80/" style="font-size: 1.05rem;">基础<sup>3</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 1.05rem;">多线程<sup>1</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F/" style="font-size: 1.05rem;">并发模式<sup>1</sup></a><a href="/tags/%E5%BC%80%E5%8F%91/" style="font-size: 1.05rem;">开发<sup>4</sup></a><a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 1.05rem;">数学<sup>1</sup></a><a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 1.05rem;">正则表达式<sup>1</sup></a><a href="/tags/%E7%9B%91%E6%8E%A7/" style="font-size: 1.05rem;">监控<sup>1</sup></a><a href="/tags/%E7%A1%AC%E7%BC%96%E7%A0%81/" style="font-size: 1.05rem;">硬编码<sup>1</sup></a><a href="/tags/%E7%AE%A1%E7%90%86/" style="font-size: 1.05rem;">管理<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 1.05rem;">网络<sup>3</sup></a><a href="/tags/%E9%80%86%E5%90%91/" style="font-size: 1.05rem;">逆向<sup>2</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/02/"><span class="card-archive-list-date">二月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/12/"><span class="card-archive-list-date">十二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/11/"><span class="card-archive-list-date">十一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/09/"><span class="card-archive-list-date">九月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">七月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">14</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/06/"><span class="card-archive-list-date">六月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/04/"><span class="card-archive-list-date">四月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">十一月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">27</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url">技术</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/WPF/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>WPF</span></a><a class="article-meta__tags" href="/tags/C/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>C#</span></a></span></div></div><h1 class="post-title" itemprop="name headline">WPF</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-06-11T14:51:13.000Z" title="发表于 2024-06-11 22:51:13">2024-06-11</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-03-19T05:41:31.599Z" title="更新于 2025-03-19 13:41:31">2025-03-19</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="WPF"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为新加坡"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>新加坡</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://che77a38.github.io/posts/WPF/"><header><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url">技术</a><a href="/tags/WPF/" tabindex="-1" itemprop="url">WPF</a><a href="/tags/C/" tabindex="-1" itemprop="url">C#</a><h1 id="CrawlerTitle" itemprop="name headline">WPF</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">ZEROKO14</span><time itemprop="dateCreated datePublished" datetime="2024-06-11T14:51:13.000Z" title="发表于 2024-06-11 22:51:13">2024-06-11</time><time itemprop="dateCreated datePublished" datetime="2025-03-19T05:41:31.599Z" title="更新于 2025-03-19 13:41:31">2025-03-19</time></header><p>WPF是微软推出的一项基于windows操作系统,.net平台的c&#x2F;s客户端构建技术,最大的特征就是可以快速构建项目从而达到节约项目成本的目的.</p>
<span id="more"></span>

<p>相关推荐书籍: &lt;&lt;WPF编程宝典使用c#2012和.net4.5 第四版&gt;&gt; &lt;&lt;c#高级编程&gt;&gt; &lt;&lt;CLR Via C#&gt;&gt; &lt;&lt;精通C#&gt;&gt; &lt;&lt;你必须知道的.NET&gt;&gt;</p>
<p><a target="_blank" rel="noopener" href="https://dotnet.microsoft.com/zh-cn/download/dotnet">.net core下载</a></p>
<p>通过使用.NET Core和跨平台UI框架<a target="_blank" rel="noopener" href="https://avaloniaui.net/Blog/wpf-on-mac"><strong>Avalonia</strong></a>，可以在Mac上编写和运行类似于WPF的桌面应用程序</p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/desktop/wpf/overview/?view=netdesktop-7.0#why-upgrade-from-net-framework">wpf微软官方教程</a></p>
<blockquote>
<p>有前端经验很简单 不过wpf的绑定设计的太拉了 双向绑定麻烦的要死 xaml循环也不好用 第一次用wpf没看文档和教程直接写的 list没法响应式 研究了n久最后还是在vs隐藏提示里发现的要用bindlist!简单的双向绑定还要字段属性双重设计还得在set用函数通知 看似很美好用起来着实很折寿 xaml遍历后传参也麻烦的要死 不改进基本没希望了 怪不得没人用 设计成razor那种简化版多好</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.wolai.com/eE76xaXQuwTgUT6autG4qg">wpf参考文章</a></p>
<p><a target="_blank" rel="noopener" href="https://referencesource.microsoft.com/#PresentationFramework">WPF源码参考</a></p>
<h1 id="完整的WPF对象层次结构"><a href="#完整的WPF对象层次结构" class="headerlink" title="完整的WPF对象层次结构"></a>完整的WPF对象层次结构</h1><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202501041700258.png" alt="image-20250104170044642" style="zoom:67%;" />

<ol>
<li><p><strong>Object</strong>:由于WPF是使用.NET创建的,因此WPF UI类继承的第一个类是.NET对象类</p>
</li>
<li><p><strong>Dispatcher</strong>:此类确保所有WPF UI对象只能由拥有它的线程直接访问,其他不拥有他的线程必须通过dispatcher对象</p>
<p>Dispatcher 是 WPF 线程模型的核心部分。它提供了一个机制，允许在 UI 线程之外执行代码，并在适当的时机将代码调度到 UI 线程上执行。Dispatcher 管理着线程的状态，包括 idle（空闲）、active（活动）和 completed（完成）等</p>
</li>
<li><p><strong>Dependency</strong>:WPF UI元素使用XML格式的XAML表示.在任何时候,WPF元素都被其他WPF元素包围,并且包围的元素可以影响此元素,因为这个类才使可能.例如,如果TextBox被Panel包围,则Panel背景色很可能被文本框继承</p>
</li>
<li><p><strong>Visual</strong>:这是使WPF UI具有视觉表示的类</p>
</li>
<li><p><strong>UI Element</strong>:此类支持诸如事件,输入,布局等功能</p>
</li>
<li><p><strong>Framework Element</strong>:此类支持诸如templating,styles,binding,resources等功能</p>
</li>
</ol>
<p>最后所有WPF控件,TextBox,Button,Grid等任何东西都继承自Framework Element类</p>
<h2 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h2><p>下面实现一个简单的实现代码:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Concurrent;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">CustomThreadDispatcher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ThreadDispatcher</span> : <span class="title">IDisposable</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> Thread _workerThread;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> BlockingCollection&lt;Action&gt; _taskQueue;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> CancellationTokenSource _cts;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ThreadDispatcher</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            _taskQueue = <span class="keyword">new</span> BlockingCollection&lt;Action&gt;();</span><br><span class="line">            _cts = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line"></span><br><span class="line">            _workerThread = <span class="keyword">new</span> Thread(Run)</span><br><span class="line">            &#123;</span><br><span class="line">                IsBackground = <span class="literal">true</span> <span class="comment">// 确保程序退出时不阻止主线程结束</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            _workerThread.Start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向指定线程调度任务</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Invoke</span>(<span class="params">Action action</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(action));</span><br><span class="line"></span><br><span class="line">            _taskQueue.Add(action);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程主循环，处理调度的任务</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Run</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">foreach</span> (<span class="keyword">var</span> action <span class="keyword">in</span> _taskQueue.GetConsumingEnumerable(_cts.Token))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">try</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        action();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Console.WriteLine(<span class="string">$&quot;Task execution failed: <span class="subst">&#123;ex.Message&#125;</span>&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (OperationCanceledException)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 停止时退出循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 停止调度器</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            _cts.Cancel();</span><br><span class="line">            _taskQueue.CompleteAdding();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                _workerThread.Join(); <span class="comment">// 等待线程结束</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (ThreadStateException)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 已经结束则忽略</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            _cts.Dispose();</span><br><span class="line">            _taskQueue.Dispose();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;Main thread ID: <span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">using</span> (<span class="keyword">var</span> dispatcher = <span class="keyword">new</span> ThreadDispatcher())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 模拟在指定线程上调度任务</span></span><br><span class="line">                dispatcher.Invoke(() =&gt; Console.WriteLine(<span class="string">$&quot;Task 1 executed on thread <span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>));</span><br><span class="line">                dispatcher.Invoke(() =&gt; Console.WriteLine(<span class="string">$&quot;Task 2 executed on thread <span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 延迟执行</span></span><br><span class="line">                Thread.Sleep(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">                dispatcher.Invoke(() =&gt; Console.WriteLine(<span class="string">$&quot;Task 3 executed on thread <span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Dispatcher stopped. Press any key to exit...&quot;</span>);</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出如下:</span></span><br><span class="line">Main thread ID: <span class="number">1</span></span><br><span class="line">Task <span class="number">1</span> executed <span class="keyword">on</span> thread <span class="number">4</span></span><br><span class="line">Child thread ID: <span class="number">4</span></span><br><span class="line">Task <span class="number">2</span> executed <span class="keyword">on</span> thread <span class="number">4</span></span><br><span class="line">Child thread ID: <span class="number">4</span></span><br><span class="line">Task <span class="number">3</span> executed <span class="keyword">on</span> thread <span class="number">4</span></span><br><span class="line">Child thread ID: <span class="number">4</span></span><br><span class="line">Dispatcher stopped. Press any key to exit...</span><br></pre></td></tr></table></figure>

<p>流程分析图如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant MainThread as Main Thread</span><br><span class="line">    participant ThreadDispatcher as ThreadDispatcher</span><br><span class="line">    participant WorkerThread as Worker Thread</span><br><span class="line"></span><br><span class="line">    MainThread -&gt;&gt; ThreadDispatcher: Create instance</span><br><span class="line">    ThreadDispatcher -&gt;&gt; WorkerThread: Start thread</span><br><span class="line">    WorkerThread --&gt;&gt; WorkerThread: Run()</span><br><span class="line"></span><br><span class="line">    MainThread -&gt;&gt; ThreadDispatcher: Invoke(Action)</span><br><span class="line">    ThreadDispatcher -&gt;&gt; WorkerThread: Add action to queue</span><br><span class="line">    WorkerThread -&gt;&gt; WorkerThread: Dequeue and execute action</span><br><span class="line"></span><br><span class="line">    MainThread -&gt;&gt; ThreadDispatcher: Dispose()</span><br><span class="line">    WorkerThread -&gt;&gt; WorkerThread: Stop and exit loop</span><br><span class="line">    ThreadDispatcher -&gt;&gt; MainThread: Release resources</span><br></pre></td></tr></table></figure>

<p>上面的代码,多个Dispatcher是各自启动一个线程,如果想让所有线程中执行的该代码都在调度到同一个线程中执行,应该使用单例类,确保所有ThreadDispatcher实例共享同一个线程和任务队列</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Concurrent;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">CustomThreadDispatcher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 单例类，管理共享的线程和任务队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SharedDispatcher</span> : <span class="title">IDisposable</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 使用 Lazy&lt;T&gt; 实现单例模式，确保 SharedDispatcher 只有一个实例</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Lazy&lt;SharedDispatcher&gt; _instance = <span class="keyword">new</span> Lazy&lt;SharedDispatcher&gt;(() =&gt; <span class="keyword">new</span> SharedDispatcher());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提供对单例实例的访问</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> SharedDispatcher Instance =&gt; _instance.Value;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 工作线程，用于执行任务队列中的任务</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> Thread _workerThread;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 任务队列，用于存储待执行的任务</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> BlockingCollection&lt;Action&gt; _taskQueue;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取消令牌源，用于停止工作线程</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> CancellationTokenSource _cts;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 私有构造函数，确保外部无法直接实例化 SharedDispatcher</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">SharedDispatcher</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 初始化任务队列</span></span><br><span class="line">            _taskQueue = <span class="keyword">new</span> BlockingCollection&lt;Action&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化取消令牌源</span></span><br><span class="line">            _cts = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建工作线程，并设置其为后台线程（确保程序退出时线程不会阻止主线程结束）</span></span><br><span class="line">            _workerThread = <span class="keyword">new</span> Thread(Run)</span><br><span class="line">            &#123;</span><br><span class="line">                IsBackground = <span class="literal">true</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 启动工作线程</span></span><br><span class="line">            _workerThread.Start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向指定线程调度任务</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Invoke</span>(<span class="params">Action action</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(action));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将任务添加到任务队列中</span></span><br><span class="line">            _taskQueue.Add(action);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程主循环，处理调度的任务</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Run</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 从任务队列中获取任务并执行</span></span><br><span class="line">                <span class="keyword">foreach</span> (<span class="keyword">var</span> action <span class="keyword">in</span> _taskQueue.GetConsumingEnumerable(_cts.Token))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">try</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 执行任务</span></span><br><span class="line">                        action();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 捕获任务执行过程中的异常并输出</span></span><br><span class="line">                        Console.WriteLine(<span class="string">$&quot;Task execution failed: <span class="subst">&#123;ex.Message&#125;</span>&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (OperationCanceledException)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 当取消令牌被触发时，退出循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 停止调度器</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 取消任务执行</span></span><br><span class="line">            _cts.Cancel();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 标记任务队列为完成状态，不再接受新任务</span></span><br><span class="line">            _taskQueue.CompleteAdding();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 等待工作线程结束</span></span><br><span class="line">                _workerThread.Join();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (ThreadStateException)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果线程已经结束，则忽略异常</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 释放取消令牌源和任务队列</span></span><br><span class="line">            _cts.Dispose();</span><br><span class="line">            _taskQueue.Dispose();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 继承自 SharedDispatcher 的类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ThreadDispatcher</span> : <span class="title">IDisposable</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 共享的 SharedDispatcher 实例</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> SharedDispatcher _sharedDispatcher;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ThreadDispatcher</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取 SharedDispatcher 的单例实例</span></span><br><span class="line">            _sharedDispatcher = SharedDispatcher.Instance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向指定线程调度任务</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Invoke</span>(<span class="params">Action action</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 通过 SharedDispatcher 实例调度任务</span></span><br><span class="line">            _sharedDispatcher.Invoke(action);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 停止调度器</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 这里不需要释放 SharedDispatcher，因为它是一个单例</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;Main thread ID: <span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建两个 ThreadDispatcher 实例</span></span><br><span class="line">            <span class="keyword">using</span> (<span class="keyword">var</span> dispatcher1 = <span class="keyword">new</span> ThreadDispatcher())</span><br><span class="line">            <span class="keyword">using</span> (<span class="keyword">var</span> dispatcher2 = <span class="keyword">new</span> ThreadDispatcher())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 模拟在指定线程上调度任务</span></span><br><span class="line">                dispatcher1.Invoke(() =&gt; Console.WriteLine(<span class="string">$&quot;Task 1 executed on thread <span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>));</span><br><span class="line">                dispatcher2.Invoke(() =&gt; Console.WriteLine(<span class="string">$&quot;Task 2 executed on thread <span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 延迟执行</span></span><br><span class="line">                Thread.Sleep(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">                dispatcher1.Invoke(() =&gt; Console.WriteLine(<span class="string">$&quot;Task 3 executed on thread <span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Dispatcher stopped. Press any key to exit...&quot;</span>);</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant MainThread as Main Thread</span><br><span class="line">    participant Dispatcher1 as ThreadDispatcher (dispatcher1)</span><br><span class="line">    participant Dispatcher2 as ThreadDispatcher (dispatcher2)</span><br><span class="line">    participant SharedDispatcher as SharedDispatcher</span><br><span class="line">    participant WorkerThread as Worker Thread</span><br><span class="line"></span><br><span class="line">    MainThread -&gt;&gt; Dispatcher1: Create dispatcher1</span><br><span class="line">    MainThread -&gt;&gt; Dispatcher2: Create dispatcher2</span><br><span class="line">    Dispatcher1 -&gt;&gt; SharedDispatcher: Access Instance</span><br><span class="line">    Dispatcher2 -&gt;&gt; SharedDispatcher: Access Instance</span><br><span class="line"></span><br><span class="line">    MainThread -&gt;&gt; Dispatcher1: Invoke(Task 1)</span><br><span class="line">    Dispatcher1 -&gt;&gt; SharedDispatcher: Add Task 1 to queue</span><br><span class="line"></span><br><span class="line">    MainThread -&gt;&gt; Dispatcher2: Invoke(Task 2)</span><br><span class="line">    Dispatcher2 -&gt;&gt; SharedDispatcher: Add Task 2 to queue</span><br><span class="line"></span><br><span class="line">    WorkerThread -&gt;&gt; SharedDispatcher: Dequeue Task 1</span><br><span class="line">    WorkerThread -&gt;&gt; WorkerThread: Execute Task 1</span><br><span class="line"></span><br><span class="line">    WorkerThread -&gt;&gt; SharedDispatcher: Dequeue Task 2</span><br><span class="line">    WorkerThread -&gt;&gt; WorkerThread: Execute Task 2</span><br><span class="line"></span><br><span class="line">    MainThread -&gt;&gt; Dispatcher1: Invoke(Task 3)</span><br><span class="line">    Dispatcher1 -&gt;&gt; SharedDispatcher: Add Task 3 to queue</span><br><span class="line"></span><br><span class="line">    WorkerThread -&gt;&gt; SharedDispatcher: Dequeue Task 3</span><br><span class="line">    WorkerThread -&gt;&gt; WorkerThread: Execute Task 3</span><br><span class="line"></span><br><span class="line">    MainThread -&gt;&gt; Dispatcher1: Dispose()</span><br><span class="line">    MainThread -&gt;&gt; Dispatcher2: Dispose()</span><br><span class="line">    MainThread -&gt;&gt; SharedDispatcher: Dispose()</span><br><span class="line">    SharedDispatcher -&gt;&gt; WorkerThread: Stop and exit</span><br></pre></td></tr></table></figure>



<h1 id="XAML"><a href="#XAML" class="headerlink" title="XAML"></a>XAML</h1><p><strong>XAML（Extensible Application Markup Language）</strong>是微软创造的一种新的可扩展应用程序标记语言，是WPF中专门用于设计UI的语言，是一种单纯的<strong>声明型语言</strong>。</p>
<p>在XAML语言中，<strong>使用标签声明一个元素，每个元素对应内存中的一个对象</strong>。可以通过标签的语法进一步声明元素的特征（Attribute）和内容物。有两种标签表现形式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;Tag Attribute1 = &quot;Value1&quot; Attribute2 = &quot;Value2&quot;&gt;Content &lt;/Tag&gt; &lt;！--非空标签--&gt;</span><br><span class="line">&lt;Tag Attribute1 = &quot;Value1&quot; Attribute2 = &quot;value2&quot; ½&gt; &lt;！--空标签--&gt;</span><br></pre></td></tr></table></figure>

<p>Attribute不仅可以写成上面这样,也可以把 <code>Tag.Attribute</code>直接写成标签的形式</p>
<h2 id="对xaml的理解"><a href="#对xaml的理解" class="headerlink" title="对xaml的理解"></a>对xaml的理解</h2><p>将xaml和类对应起来理解,xaml只是在描述这些类</p>
<p>Content等同于被包裹其中的内容:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;window Content=&quot;...&quot;/&gt;</span><br><span class="line">&lt;!--等同于--&gt;</span><br><span class="line">&lt;window&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;/window&gt;</span><br></pre></td></tr></table></figure>

<p>Color展开案例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;Grid&gt;</span><br><span class="line">  &lt;Grid.Background&gt;</span><br><span class="line">    &lt;SolidColorBrush Color=&quot;Aqua&quot;/&gt; &lt;!--此处的Aqua是颜色类型--&gt;</span><br><span class="line">  &lt;/Grid.Background&gt;</span><br><span class="line">&lt;/Grid&gt;</span><br><span class="line">&lt;!--等同于--&gt;</span><br><span class="line">&lt;Grid Background=&quot;Aqua&quot;/&gt;&lt;!--此处的Aqua实际上是画刷属性--&gt;</span><br></pre></td></tr></table></figure>

<p>Binding展开案例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;Grid&gt;</span><br><span class="line">  &lt;Grid.Background&gt;</span><br><span class="line">        &lt;Binding&gt;</span><br><span class="line">        &lt;Binding.RelativeSource&gt;</span><br><span class="line">          &lt;RelativeSource Mode=&quot;TemplatedParent&quot;/&gt;</span><br><span class="line">        &lt;/Binding.RelativeSource&gt;</span><br><span class="line">        &lt;/Binding&gt;</span><br><span class="line">    &lt;/Grid.Background&gt;</span><br><span class="line">&lt;/Grid&gt;</span><br></pre></td></tr></table></figure>

<h2 id="xmlns"><a href="#xmlns" class="headerlink" title="xmlns"></a>xmlns</h2><p><strong>xmlns即XML-Namespace</strong>，其一个使用优点是，当要引用的来源不同类重名时，可以使用命名空间加以区分。XAML中命名空间的语法与C#是不同的，在C#中，我们使用using关键字在代码顶部调用命名空间，在XAML当中的语法格式如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">xmlns=&quot;[命名空间]&quot; &lt;!--无映射前缀--&gt;</span><br><span class="line">xmlns:[映射前缀]=&quot;[命名空间]&quot; &lt;!--有映射前缀--&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--例子--&gt;</span><br><span class="line">xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span><br><span class="line">xmlns:bb=&quot;clr-namespace:testGrid&quot;&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为什么xmlns的赋值是一个类似于URL地址的字符串？<br>这种表达是一种统一资源名称，使得对于多个命名空间的引用能够集合在一个唯一标识上，而创建可读的全局唯一标识符的可靠方法，就是使用类似于网站的URL表达。对于一个集合标识的引用声明就包含了对多个命名空间的引用，使得代码方便、简洁和统一。</p>
</blockquote>
<p>在使用XAML语法声明元素标签时，其对应声明的对象与对象之间的关系要么是包含，要么是并列关系，所以我们又说，XAML的语法结构是一种<strong>树形的包含或并列结构</strong>。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202406141755980.png" alt="iShot_2024-06-14_11.15.00" style="zoom: 25%;" />

<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;Rectangle x:Name=&quot;rectangle1&quot; Width=&quot;200&quot; Height=&quot;100&quot; Fill=&quot;Blue&quot;/&gt;</span><br><span class="line">&lt;!--上面写法Fill只提供了颜色,本质上没有提供类型,只是纯色没关系,如果想要写渐变色却不行,因此可以改成下面这种更全能的形式,可以指定类型--&gt;</span><br><span class="line">&lt;Rectangle x:Name=&quot;rectangle1&quot; Width=&quot;200&quot; Height=&quot;100&quot;&gt;</span><br><span class="line">    &lt;Rectangle.Fill&gt;</span><br><span class="line">        &lt;SolidColorBrush Color=&quot;Blue&quot;/&gt;&lt;!--此处指定了类型SolidColorBrush--&gt;</span><br><span class="line">    &lt;/Rectangle.Fill&gt;</span><br><span class="line">&lt;/Rectangle&gt;</span><br></pre></td></tr></table></figure>

<p>上面两种写法对应的c#代码实际上就都是</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SolidCoLorBrush SCB1 = <span class="keyword">new</span> SolidColorBrush();</span><br><span class="line">SCB1.Color = Colors. Blue;</span><br><span class="line"><span class="keyword">this</span>.rectangle.Fill = SCB1;</span><br><span class="line"><span class="keyword">this</span>.Name = <span class="string">&quot;rectangle1&quot;</span>;</span><br><span class="line"><span class="keyword">this</span>.Width = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">this</span>.Height = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果使用XAML对一个类的属性进行特征声明，那么其逻辑代码中必然要有将特征赋值字符串值转换为属性值的赋值机制。</li>
<li>在XAML中对特征进行声明使用的是字符串，如果要对属性进行复杂赋值或内部精确赋值，那么就会使得XAML设计者在为此编写转换机制时十分困难。</li>
</ul>
</blockquote>
<h2 id="XAML命名空间"><a href="#XAML命名空间" class="headerlink" title="XAML命名空间"></a>XAML命名空间</h2><p>XAML命名空间是一种用于在XAML标记中引用不同的类型和属性的机制</p>
<p><strong>XAML命名空间可以将XAML元素和属性与对应的.NET类和成员映射，从而实现对象构造和属性赋值</strong></p>
<p>XAML命名空间中包含的工具如下图</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202406141754546.png" alt="iShot_2024-06-14_13.55.08" style="zoom: 33%;" />

<h3 id="常见特征功能"><a href="#常见特征功能" class="headerlink" title="常见特征功能"></a>常见特征功能</h3><h4 id="x-Class"><a href="#x-Class" class="headerlink" title="x:Class"></a>x:Class</h4><p>这个特征功能，适用于告诉编译器将当前XAML标签的编译结果<strong>与后台中指定的类进行合并</strong>。在使用这个功能声明时需要满足以下要求：</p>
<ul>
<li>此特征功能仅能在根节点声明</li>
<li>根节点类型要与所指示的合并类型保持一致</li>
<li><strong>所指示的类型在声明时必须使用partial关键字</strong></li>
</ul>
<p>x:Class使得XAML文件和后台代码文件能够合并为一个类，从而实现逻辑和界面的分离。<code>x:Class</code>只能用于根元素，并且必须与后台代码文件中的分部类名称一致。</p>
<h5 id="x-ClassModifier"><a href="#x-ClassModifier" class="headerlink" title="x:ClassModifier"></a>x:ClassModifier</h5><p>告诉XAML编译器该便签生成的类具有怎样的访问级别。对于整个程序集来说，internal和private是等价的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Window x:Class=&quot;...&quot;</span><br><span class="line">        x:ClassModifier=&quot;internal&quot;&gt;</span><br><span class="line">&lt;/Window&gt;</span><br></pre></td></tr></table></figure>

<p>对应的c#文件的窗体类的访问级别也需要改成 <code>internal</code>,即需要对应,否则就会导致含有冲突访问修饰符的编译错误</p>
<p>一般WPF程序中都会包含有一个映射前缀为x的命名空间</p>
<h4 id="x-Name"><a href="#x-Name" class="headerlink" title="x:Name"></a>x:Name</h4><p>告诉XAML编译器为当前的标签生成一个实例，并为这个实例声明一个引用变量</p>
<p>它可以为XAML定义的对象指定一个唯一的标识符，以便在代码中访问它。x:Name不仅会为对象创建一个引用变量，还会为对象的Name属性（如果有的话）赋值，并将该值注册到XAML名称范围中。XAML名称范围是一种用于查找和引用XAML创建的对象的机制，它可以支持数据绑定、动画、模板等功能。</p>
<blockquote>
<p>Name 与 x:Name 的区别</p>
<p>Name</p>
<ul>
<li><strong>使用场景</strong>：<code>Name</code> 属性是 WPF 控件的一个标准属性，通常用于为控件指定一个名称，以便在代码中引用</li>
<li><strong>作用域</strong>：在 XAML 中，<code>Name</code> 属性只能用于某些控件，例如 <code>Button</code>、<code>TextBox</code> 等。</li>
<li><strong>代码中引用</strong>：在代码后面（C#）中，可以直接使用 <code>myButton</code> 来引用这个按钮。</li>
</ul>
<p>x:Name</p>
<ul>
<li><strong>使用场景</strong>：<code>x:Name</code> 是 XAML 的一部分，属于 XAML 命名空间的定义，提供了一个更通用的方式来为任何 XAML 元素指定名称。</li>
<li><strong>作用域</strong>：可以用于所有 XAML 元素，包括那些没有 <code>Name</code> 属性的元素。</li>
<li><strong>代码中引用</strong>：在代码后面（C#）中，同样可以直接使用 <code>myButton</code> 和 <code>myTextBlock</code> 来引用它们。</li>
</ul>
</blockquote>
<h5 id="x-FieldModifier"><a href="#x-FieldModifier" class="headerlink" title="x:FieldModifier"></a>x:FieldModifier</h5><p>为引用变量设置访问级别。默认情况下，字段的访问级别按照面向对象的封装原则被设置成了internal。</p>
<h4 id="x-Key-与-x-Shared"><a href="#x-Key-与-x-Shared" class="headerlink" title="x:Key 与 x:Shared"></a>x:Key 与 x:Shared</h4><p><code>x:Key</code>可以为XAML定义的资源指定一个唯一的标识符，以便在XAML中引用它。<strong>x:Key只能用于资源字典中的对象</strong>，例如样式、模板、画刷等。你可以使用静态资源标记扩展或动态资源标记扩展来通过 <code>x:Key</code>引用资源。</p>
<p>当多次检索到一个对象时，若想得到的都是同一个对象，则x:Shared的值设为true；若想得到的是该对象的多个副本，则设置x:Shared的值为false。</p>
<p>XAML编译器会为资源隐式添加x:Shared &#x3D; “true”。</p>
<p>我们经常会把需要多次使用的内容提取出来放到<strong>资源词典</strong>中,需要使用这个资源的时候就是使用对应的key检索出来</p>
<p><code>x:Shared=&quot;true&quot;</code></p>
<p>用于指示某个资源或元素是可以在多个地方共享的。</p>
<p>它的主要用途是在以下情况下</p>
<ul>
<li><strong>资源共享</strong>：如果有一些资源（如图像、样式等）在多个地方使用，设置为共享可以避免重复创建。</li>
<li><strong>性能优化</strong>：减少资源的重复加载和初始化。</li>
</ul>
<h3 id="常见标记拓展功能"><a href="#常见标记拓展功能" class="headerlink" title="常见标记拓展功能"></a>常见标记拓展功能</h3><h4 id="x-Type"><a href="#x-Type" class="headerlink" title="x:Type"></a>x:Type</h4><p>用于一些需要指定类型的属性或参数</p>
<p>当我们需要引用的不是数据类型的实例,而是<strong>数据类型本身</strong>时,就可以使用此标记拓展功能</p>
<p><code>&quot;&#123;x:Type TypeName=wins:SuggestionComment&#125;&quot;</code>或 <code>&#123;x:Type wins:SuggestionComment&#125;</code></p>
<p>x:Type的值是一个类型的名称，可以带有命名空间前缀，也可以省略命名空间前缀，如果省略，则默认使用当前XAML文件的默认命名空间。x:Type可以用于一些需要指定类型的属性或参数。</p>
<h4 id="x-Null"><a href="#x-Null" class="headerlink" title="x:Null"></a>x:Null</h4><p>可以显式地对一个特征或属性赋一个空值，常用于清除一些设置</p>
<p><code>Background = &quot;&#123;x:Null&#125;&quot;</code>将背景色置为空值</p>
<p>它可以在XAML中表示null值。x:Null没有任何参数，只能用于属性语法。x:NuII可以用于一些需要清除或重置属性值的场景，例如<strong>取消全局样式、清除绑定源、设置空背景等。</strong></p>
<h4 id="x-Static"><a href="#x-Static" class="headerlink" title="x:Static"></a>x:Static</h4><p>用于一些需要使用静态字段或属性的属性或参数</p>
<p>x:Static可以用于一些需要使用静态字段或属性的属性或参数，例如常量、枚举值、资源键等。</p>
<h3 id="常用指令元素功能"><a href="#常用指令元素功能" class="headerlink" title="常用指令元素功能"></a>常用指令元素功能</h3><h4 id="x-Code"><a href="#x-Code" class="headerlink" title="x:Code"></a>x:Code</h4><p>可以在XAML中嵌入一些C#代码，以便在XAML文件中实现一些逻辑或事件处理 . <code>x:Code</code>必须用于根元素,并且必须包含在CDATA节中,需要使用XML语言的 <code>&lt;!      [CDATA[...]]&gt;</code>转移标签，写法为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;Window&gt;</span><br><span class="line">    &lt;Grid&gt;</span><br><span class="line">    &lt;/Grid&gt;</span><br><span class="line">    &lt;x:Code&gt;</span><br><span class="line">        &lt;![CDATA[</span><br><span class="line">        ...代码内容...</span><br><span class="line">        ]]&gt;</span><br><span class="line">    &lt;/x:Code&gt;</span><br><span class="line">&lt;/Window&gt;</span><br></pre></td></tr></table></figure>

<p>这个功能几乎没用,不符合设计哲学</p>
<h4 id="x-Data"><a href="#x-Data" class="headerlink" title="x:Data"></a>x:Data</h4><p>在XAML中定义一个XML数据源，以便在XAML中使用数据绑定或数据模板。<code>x:Data</code>可以用于一些需要指定数据源的属性或参数，例如XmlDataProvider.Source、XmlDataProvider.XPath、<br>XmiDataProvider.Document等。</p>
<h2 id="XAML注释"><a href="#XAML注释" class="headerlink" title="XAML注释"></a>XAML注释</h2><p><code>&lt;!--  注释内容 --&gt;</code></p>
<ul>
<li>XAML的注释只能出现在标签的内容区域</li>
<li>XAML的注释不能用于注释掉标签的特征赋值</li>
<li>XAML的注释不能嵌套</li>
</ul>
<h2 id="XAML优点"><a href="#XAML优点" class="headerlink" title="XAML优点"></a>XAML优点</h2><ul>
<li>XAML通常比等效代码更简洁、更易读</li>
<li>XAML 以更高的视觉清晰度模拟用户界面对象的父子层次结构</li>
<li>XAML 可由程序员轻松手动编写，但也使它成为可视化设计工具的可操作性和生成工具</li>
</ul>
<h2 id="XAML可视化视觉设计工具"><a href="#XAML可视化视觉设计工具" class="headerlink" title="XAML可视化视觉设计工具"></a>XAML可视化视觉设计工具</h2><h3 id="Blend"><a href="#Blend" class="headerlink" title="Blend"></a>Blend</h3><p>Blend是一款用于设计应用用户界面的可视化工具，用于UI设计，它可以支持拖拽式创建控件，与PhotoShop的使用类似，可以快速、精确地绘制图形界面，并自动生成XAML代码。</p>
<p>使用 <code>Visual Studio中视图--在Blend中设计</code></p>
<p>从简化XAML的角度来看，使用Blend来设计UI会有哪些冗余细节？</p>
<ul>
<li>取值过于精确</li>
<li>默认值会被直接写出</li>
</ul>
<p>一般情况下，Blend会用于<strong>复杂的界面设计和绘图动画创作</strong>，可以先在Blend里进行绘制，再回到Visual Studio的XAML代码中进行调整，要保证不影响效果的情况下尽可能提高代码可读性。</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1gz4y1W7Ns/">借助Blend快速入门WPF动画以及行为视频讲解</a></p>
<h2 id="设计时特性"><a href="#设计时特性" class="headerlink" title="设计时特性"></a>设计时特性</h2><p>设计时才能看到的数据源</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;ListBox ItemsSource=&quot;&#123;Binding Items&#125;&quot;&gt;</span><br><span class="line">  &lt;d:ListBox.ItemsSource&gt;</span><br><span class="line">    &lt;x:Array Type=&quot;sys:string&quot;&gt;</span><br><span class="line">      &lt;sys:String&gt;Item1&lt;/sys:String&gt;</span><br><span class="line">      &lt;sys:String&gt;Item2&lt;/sys:String&gt;</span><br><span class="line">      &lt;sys:String&gt;Item3&lt;/sys:String&gt;</span><br><span class="line">    &lt;/x:Array&gt;</span><br><span class="line">    &lt;/d:ListBox.ItemsSource&gt;</span><br><span class="line">&lt;/ListBox&gt;</span><br></pre></td></tr></table></figure>

<p>自动提供假数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ListBox d:Source=&quot;&#123;d:SampleData ite&#125;&quot;</span><br></pre></td></tr></table></figure>

<h1 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h1><p>布局控件：可以理解为一个容器，容器内可以嵌套容器。可以嵌套N层</p>
<ul>
<li><a href="#Grid">Grid</a>   表格控件</li>
<li><a href="#StackPanel">StackPanel</a>    堆栈面板</li>
<li><a href="#WrapPanel">WrapPanel</a>   自动换行面板</li>
<li><a href="#DockPanel">DockPanel</a> 固定位置布局</li>
<li><a href="#Canvas">Canvas</a>   画布(不常用)</li>
</ul>
<p>上述的基本容器都是继承于Panel</p>
<blockquote>
<p>wpf中源码提及的Generator的概念可以这么理解:</p>
<p>ListBox中的item叫ListBoxItem,ListBox就是ListBoxItem的生成器</p>
</blockquote>
<h2 id="Grid"><a href="#Grid" class="headerlink" title="Grid"></a>Grid</h2><p>表格控件,类似HTML中的Table标签</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202406102039341.png" alt="image-20240610203936967"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;Grid Height=&quot;435&quot; VerticalAlignment=&quot;Top&quot;&gt;</span><br><span class="line">    #这里定义了纵向的三个空行</span><br><span class="line">    &lt;Grid.RowDefinitions&gt;</span><br><span class="line">        &lt;RowDefinition&gt;&lt;/RowDefinition&gt;</span><br><span class="line">        &lt;RowDefinition&gt;&lt;/RowDefinition&gt;</span><br><span class="line">        &lt;RowDefinition&gt;&lt;/RowDefinition&gt;</span><br><span class="line">    &lt;/Grid.RowDefinitions&gt;</span><br><span class="line">    &lt;!--因为只有一列,下面三行实际可写可不写--&gt;</span><br><span class="line">    &lt;Grid.ColumnDefinitions&gt;</span><br><span class="line">        &lt;ColumnDefinition/&gt;</span><br><span class="line">    &lt;/Grid.ColumnDefinitions&gt;</span><br><span class="line">    #通过Grid.Row设置放在哪一行</span><br><span class="line">    &lt;TextBox Width=&quot;300&quot; Height=&quot;30&quot;&gt;&lt;/TextBox&gt;</span><br><span class="line">    &lt;TextBox Grid.Row=&quot;1&quot; Width=&quot;300&quot; Height=&quot;30&quot;&gt;&lt;/TextBox&gt;</span><br><span class="line">    &lt;Button x:Name=&quot;button&quot; Content=&quot;登录&quot; Margin=&quot;358,0,358,0&quot; Grid.Row=&quot;2&quot; VerticalAlignment=&quot;Center&quot; Height=&quot;38&quot;/&gt;</span><br><span class="line">&lt;/Grid&gt;</span><br></pre></td></tr></table></figure>

<p><code> Grid.Row</code>指定行序号,<code> Grid.Column</code>指定列序号</p>
<p>继承Panel</p>
<p>Grid下有很重要的附加属性<code>Grid.ZIndex</code>可以用于设置其内部的控件上下层级顺序</p>
<p>注意Grid定义好后,空间就划好了,没办法通过设置其中控件的Visibility为Collapsed来不占用空间</p>
<p>Grid还可以使用GridSplitter来使用分隔条控制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 布局如下 --&gt;</span><br><span class="line">   &lt;Grid.ColumnDefinitions&gt;</span><br><span class="line">       &lt;ColumnDefinition Width=&quot;4*&quot; /&gt;</span><br><span class="line">       &lt;ColumnDefinition Width=&quot;Auto&quot; /&gt;</span><br><span class="line">       &lt;ColumnDefinition Width=&quot;5*&quot; /&gt;</span><br><span class="line">   &lt;/Grid.ColumnDefinitions&gt;</span><br><span class="line">   &lt;Grid.RowDefinitions&gt;</span><br><span class="line">       &lt;RowDefinition Height=&quot;*&quot; /&gt;</span><br><span class="line">       &lt;RowDefinition Height=&quot;Auto&quot; /&gt;</span><br><span class="line">       &lt;RowDefinition Height=&quot;*&quot; /&gt;</span><br><span class="line">   &lt;/Grid.RowDefinitions&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--  垂直分隔线  --&gt;</span><br><span class="line"> &lt;GridSplitter</span><br><span class="line">     Grid.Row=&quot;0&quot;</span><br><span class="line">     Grid.RowSpan=&quot;3&quot;</span><br><span class="line">     Grid.Column=&quot;1&quot;</span><br><span class="line">     Width=&quot;2&quot;</span><br><span class="line">     HorizontalAlignment=&quot;Stretch&quot;</span><br><span class="line">     VerticalAlignment=&quot;Stretch&quot;</span><br><span class="line">     Background=&quot;LightGray&quot;</span><br><span class="line">     ResizeDirection=&quot;Columns&quot; /&gt;</span><br><span class="line"></span><br><span class="line"> &lt;!--  水平分隔线  --&gt;</span><br><span class="line"> &lt;GridSplitter</span><br><span class="line">     Grid.Row=&quot;1&quot;</span><br><span class="line">     Grid.Column=&quot;0&quot;</span><br><span class="line">     Grid.ColumnSpan=&quot;3&quot;</span><br><span class="line">     Height=&quot;2&quot;</span><br><span class="line">     HorizontalAlignment=&quot;Stretch&quot;</span><br><span class="line">     VerticalAlignment=&quot;Stretch&quot;</span><br><span class="line">     Background=&quot;LightGray&quot;</span><br><span class="line">     ResizeDirection=&quot;Rows&quot; /&gt;</span><br></pre></td></tr></table></figure>

<h3 id="嵌套Grid共享宽度"><a href="#嵌套Grid共享宽度" class="headerlink" title="嵌套Grid共享宽度"></a>嵌套Grid共享宽度</h3><blockquote>
<p>共享宽度（Shared Size Group）在 WPF 中的作用是让多个 Grid 中的列或行共享相同的大小，而不是限制内容的大小</p>
</blockquote>
<ul>
<li><p><strong>SharedSizeGroup</strong></p>
<p>用于标识需要共享尺寸的列或行，通过指定相同的组名（如 <code>SharedSizeGroup=&quot;TextLabel&quot;</code>）实现跨 <code>Grid</code> 的尺寸同步</p>
<p><strong>仅当列宽或行高为 <code>Auto</code> 或 <code>\*</code> 时生效</strong>，固定数值（如 <code>Width=&quot;100&quot;</code>）不参与共享</p>
</li>
<li><p><strong>Grid.IsSharedSizeScope</strong></p>
<p>需在父容器上设置为 <code>True</code>，声明该容器内的所有子 <code>Grid</code> 共享同一尺寸作用域</p>
<p>父容器可以是 <code>Grid</code>、<code>StackPanel</code>、<code>DockPanel</code> 等，但必须显式设置该属性</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;DockPanel Grid.IsSharedSizeScope=&quot;True&quot;&gt;  &lt;!-- 父容器设置 IsSharedSizeScope --&gt;</span><br><span class="line">    &lt;!-- 子 Grid 1 --&gt;</span><br><span class="line">    &lt;Grid&gt;</span><br><span class="line">        &lt;Grid.ColumnDefinitions&gt;</span><br><span class="line">            &lt;ColumnDefinition Width=&quot;Auto&quot; SharedSizeGroup=&quot;LabelColumn&quot;/&gt;  &lt;!-- 共享列 --&gt;</span><br><span class="line">            &lt;ColumnDefinition Width=&quot;*&quot;/&gt;</span><br><span class="line">        &lt;/Grid.ColumnDefinitions&gt;</span><br><span class="line">        &lt;Label Content=&quot;Name:&quot;/&gt;</span><br><span class="line">        &lt;TextBox Grid.Column=&quot;1&quot;/&gt;</span><br><span class="line">    &lt;/Grid&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 子 Grid 2 --&gt;</span><br><span class="line">    &lt;Grid&gt;</span><br><span class="line">        &lt;Grid.ColumnDefinitions&gt;</span><br><span class="line">            &lt;ColumnDefinition Width=&quot;Auto&quot; SharedSizeGroup=&quot;LabelColumn&quot;/&gt;  &lt;!-- 同名共享组 --&gt;</span><br><span class="line">            &lt;ColumnDefinition Width=&quot;*&quot;/&gt;</span><br><span class="line">        &lt;/Grid.ColumnDefinitions&gt;</span><br><span class="line">        &lt;Label Content=&quot;Email:&quot;/&gt;</span><br><span class="line">        &lt;TextBox Grid.Column=&quot;1&quot;/&gt;</span><br><span class="line">    &lt;/Grid&gt;</span><br><span class="line">&lt;/DockPanel&gt;</span><br></pre></td></tr></table></figure>

<p>对于多层嵌套的 <code>Grid</code>（如主 <code>Grid</code> 包含多个子 <code>Grid</code>，每个子 <code>Grid</code> 又包含其他控件），可通过以下结构实现共享</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;Grid Grid.IsSharedSizeScope=&quot;True&quot;&gt;</span><br><span class="line">    &lt;Grid.RowDefinitions&gt;</span><br><span class="line">        &lt;RowDefinition/&gt;</span><br><span class="line">        &lt;RowDefinition/&gt;</span><br><span class="line">    &lt;/Grid.RowDefinitions&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 子 Grid 1 --&gt;</span><br><span class="line">    &lt;Grid Grid.Row=&quot;0&quot;&gt;</span><br><span class="line">        &lt;Grid.ColumnDefinitions&gt;</span><br><span class="line">            &lt;ColumnDefinition SharedSizeGroup=&quot;GroupA&quot;/&gt;</span><br><span class="line">            &lt;ColumnDefinition Width=&quot;*&quot;/&gt;</span><br><span class="line">        &lt;/Grid.ColumnDefinitions&gt;</span><br><span class="line">    &lt;/Grid&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 子 Grid 2 --&gt;</span><br><span class="line">    &lt;Grid Grid.Row=&quot;1&quot;&gt;</span><br><span class="line">        &lt;Grid.ColumnDefinitions&gt;</span><br><span class="line">            &lt;ColumnDefinition SharedSizeGroup=&quot;GroupA&quot;/&gt;  &lt;!-- 跨行共享列宽 --&gt;</span><br><span class="line">            &lt;ColumnDefinition Width=&quot;*&quot;/&gt;</span><br><span class="line">        &lt;/Grid.ColumnDefinitions&gt;</span><br><span class="line">    &lt;/Grid&gt;</span><br><span class="line">&lt;/Grid&gt;</span><br></pre></td></tr></table></figure>

<h2 id="StackPanel"><a href="#StackPanel" class="headerlink" title="StackPanel"></a>StackPanel</h2><p>将自身内容横向或纵向排列的容器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;StackPanel HorizontalAlignment=&quot;Center&quot;&gt;#水平居中</span><br><span class="line">  &lt;!--...--&gt;</span><br><span class="line">&lt;/StackPanel&gt;</span><br><span class="line"></span><br><span class="line">#设置为横向的</span><br><span class="line">&lt;StackPanel Orientation=&quot;Horizontal&quot;&gt;</span><br><span class="line">    &lt;!-- 这里添加子元素 --&gt;</span><br><span class="line">&lt;/StackPanel&gt;</span><br></pre></td></tr></table></figure>

<p>内置的控件将会纵向排列</p>
<p><code>StackPanel</code> 会将子元素按顺序排列,因此想要其内部的控件按照VerticalAlignment来排列不可行</p>
<h4 id="VirtualizingStackPanel"><a href="#VirtualizingStackPanel" class="headerlink" title="VirtualizingStackPanel"></a>VirtualizingStackPanel</h4><p><code>VirtualizingStackPanel</code> 支持虚拟化，仅渲染可见的子元素。未在可视区域内的元素不会被创建，这样可以显著提高性能，尤其是在处理大量数据时,适用于需要显示大量数据的场景</p>
<p>如ListView,ListBox,ComboBox等也是基于 <code>VirtualizingStackPanel</code>,因此也支持虚拟化</p>
<h2 id="WrapPanel"><a href="#WrapPanel" class="headerlink" title="WrapPanel"></a>WrapPanel</h2><p>控件自动的在一行里，如果需要换行则规定好WrapPanell的布局控件的宽度，如果布局内容超出了这个宽度则会自动换行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;WrapPanel HorizontalAlignment=&quot;Center&quot;&gt;#水平居中</span><br><span class="line">  &lt;!--...--&gt;</span><br><span class="line">&lt;/WrapPanel&gt;</span><br></pre></td></tr></table></figure>

<h2 id="DockPanel"><a href="#DockPanel" class="headerlink" title="DockPanel"></a>DockPanel</h2><p>DockPanel 是WPF中的一种布局容器，用于将子控件沿容器的边缘排列。DockPanel 允许子控件依次对齐到容器的顶部、底部、左侧或右侧，并且可以让最后一个子控件填充剩余的空间。DockPanel 非常适合需要将控件固定在特定位置的布局需求。</p>
<p>DockPanel 有几个重要的属性，可以帮助开发者灵活地控制子控件的排列方式：</p>
<ul>
<li><code>DockPanel.Dock</code>: 附加属性，控制子控件在 DockPanel 中的停靠位置，取值为 Top、Bottom、Left 或 Right。</li>
<li><code>LastChildFill</code>: 控制最后一个子控件是否填充 DockPanel 的剩余空间，默认为 true。</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202408281150975.png" alt="image-20240828115050359" style="zoom: 50%;" />

<p>优点<br>灵活性高：DockPanel 允许子控件依次停靠在容器的边缘，非常适合需要固定控件位置的布局。<br>自动填充：DockPanel 可以自动填充剩余空间，简化了布局管理。<br>直观简单：对于需要将控件固定在特定位置的简单布局，DockPanel 使用非常直观简单。</p>
<p>缺点<br>不适合复杂布局：对于复杂布局或需要精确控制控件位置的场景，DockPanel 的能力有限。<br>性能问题：在包含大量子控件时，DockPanel 可能会导致性能问题，因为它需要动态计算控件的位置和大小。</p>
<h2 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h2><p>Canvas比较特殊,它属于”任意布局”的一种概念,就是你拖控件到UI上的时候你把它放在哪里它就在哪里</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Canvas&gt;</span><br><span class="line">  #...(这个里面的控件会自动生成Canvas.Left等数值)</span><br><span class="line">&lt;/Canvas&gt;</span><br></pre></td></tr></table></figure>

<h2 id="UniformGrid"><a href="#UniformGrid" class="headerlink" title="UniformGrid"></a>UniformGrid</h2><p>均匀分布的网格</p>
<p>可以通过Rows和Columns指定网格的行数或列数,有效防止宽或高特别大</p>
<p>可以通过FirstColumn指定第一个子元素应该放置的列索引。这个属性在需要偏移第一个元素的位置时很有用。</p>
<h1 id="控件"><a href="#控件" class="headerlink" title="控件"></a>控件</h1><p>在WPF中，控件是一个涵盖性术语，适用于在窗口中可视化、可交互、具有用户界面并实现某些行为，设计好的控件能给用户带来更好的交互体验。</p>
<p>控件的基础属性宽、高、背景色、字体颜色、字体大小、禁用、启用、显示、隐藏等、控件显示的值内蓉有的叫Content、Text、Value等这一些东西基本上不会随着wpf的版本迭代有面目全非的变化所以是可以通过长期使用慢慢积累到控件属性。从而掌握它们的使用方式或重写、编写自定义控件</p>
<p>Name属性可以给控件起名字,得以索引到这个控件</p>
<p><strong>WPF控件类关系图</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202408270925443.png" alt="image-20240827092504643" style="zoom: 50%;" />

<h2 id="内置的WPF控件"><a href="#内置的WPF控件" class="headerlink" title="内置的WPF控件"></a>内置的WPF控件</h2><p><a target="_blank" rel="noopener" href="https://github.dev/dotnet/wpf/blob/0856b2f3c55fdfc2587e28c62944345d734af190/src/Microsoft.DotNet.Wpf/src/Themes/PresentationFramework.Fluent/Styles/TreeView.xaml#L24">此处可以参考各种内置控件的实现源码</a></p>
<h3 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h3><ul>
<li><strong>Button</strong>：基本的按钮控件，用于执行点击事件。</li>
<li><strong>RepeatButton</strong>：类似于按钮，但会在长按时反复触发点击事件。</li>
</ul>
<h3 id="数据显示"><a href="#数据显示" class="headerlink" title="数据显示"></a>数据显示</h3><ul>
<li><strong>DataGrid</strong>：用于显示和操作表格数据，可以进行排序、过滤和编辑。</li>
<li><strong>ListView</strong>：显示数据集合的控件，支持多种视图模式，如 GridView。</li>
<li><strong>TreeView</strong>：用于显示层次化数据的控件。</li>
</ul>
<h3 id="日期显示和选择"><a href="#日期显示和选择" class="headerlink" title="日期显示和选择"></a>日期显示和选择</h3><ul>
<li><strong>Calendar</strong>：显示一个月历，用于选择日期。</li>
<li><strong>DatePicker</strong>：提供日期选择功能，可以手动输入或通过下拉日历选择。</li>
</ul>
<h3 id="对话框"><a href="#对话框" class="headerlink" title="对话框"></a>对话框</h3><ul>
<li><strong>OpenFileDialog</strong>：用于打开文件的对话框。</li>
<li><strong>PrintDialog</strong>：用于打印文件的对话框。</li>
<li><strong>SaveFileDialog</strong>：用于保存文件的对话框。</li>
</ul>
<h3 id="数字墨迹"><a href="#数字墨迹" class="headerlink" title="数字墨迹"></a>数字墨迹</h3><ul>
<li><strong>InkCanvas</strong>：提供数字墨迹输入功能的画布。</li>
<li><strong>InkPresenter</strong>：展示和管理数字墨迹输入。</li>
</ul>
<h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><ul>
<li><strong>DocumentViewer</strong>：查看文档的控件，支持多种文档格式。</li>
<li><strong>FlowDocumentPageViewer</strong>：分页显示 FlowDocument 的控件。</li>
<li><strong>FlowDocumentReader</strong>：提供阅读和导航 FlowDocument 的功能。</li>
<li><strong>FlowDocumentScrollViewer</strong>：滚动显示 FlowDocument 的控件。</li>
<li><strong>StickyNoteControl</strong>：显示和编辑数字便笺。</li>
</ul>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><ul>
<li><strong>TextBox</strong>：单行文本输入控件。</li>
<li><strong>RichTextBox</strong>：支持富文本格式的多行文本输入控件。</li>
<li><strong>PasswordBox</strong>：用于输入密码的控件，输入内容以掩码显示。</li>
</ul>
<h3 id="布局-1"><a href="#布局-1" class="headerlink" title="布局"></a>布局</h3><ul>
<li><strong>Border</strong>：绘制边框，包含单一子元素。</li>
<li><strong>BulletDecorator</strong>：显示项目符号和内容。</li>
<li><strong>Canvas</strong>：允许通过绝对坐标指定子元素位置。</li>
<li><strong>DockPanel</strong>：将子元素停靠在其边缘（上、下、左、右）。</li>
<li><strong>Expander</strong>：可扩展和折叠的面板。</li>
<li><strong>Grid</strong>：基于行和列的布局，支持复杂排列。</li>
<li><strong>GridView</strong>：ListView 的视图模式，用于显示表格数据。</li>
<li><strong>GridSplitter</strong>：允许调整 Grid 的行和列大小。</li>
<li><strong>GroupBox</strong>：带标题的容器，用于分组内容。</li>
<li><strong>Panel</strong>：所有布局控件的基类。</li>
<li><strong>ResizeGrip</strong>：调整窗口大小的控件。</li>
<li><strong>Separator</strong>：用于分隔菜单项或工具栏按钮的线条。</li>
<li><strong>ScrollBar</strong>：提供滚动功能。</li>
<li><strong>ScrollViewer</strong>：使子元素内容可滚动。</li>
<li><strong>StackPanel</strong>：将子元素堆叠在一起，水平或垂直方向。</li>
<li><strong>Thumb</strong>：滑块控件的一部分，支持拖动。</li>
<li><strong>Viewbox</strong>：缩放和调整子元素大小。</li>
<li><strong>VirtualizingStackPanel</strong>：类似 StackPanel，但支持虚拟化，提高性能。</li>
<li><strong>Window</strong>：表示一个窗口。</li>
<li><strong>WrapPanel</strong>：顺序排列子元素，空间不足时自动换行。</li>
</ul>
<h3 id="媒体"><a href="#媒体" class="headerlink" title="媒体"></a>媒体</h3><ul>
<li><strong>Image</strong>：显示图片。</li>
<li><strong>MediaElement</strong>：播放音频或视频。</li>
<li><strong>SoundPlayerAction</strong>：播放音频文件的操作。</li>
</ul>
<h3 id="菜单"><a href="#菜单" class="headerlink" title="菜单"></a>菜单</h3><ul>
<li><strong>ContextMenu</strong>：右键上下文菜单。</li>
<li><strong>Menu</strong>：应用程序主菜单。</li>
<li><strong>ToolBar</strong>：工具栏，用于放置工具按钮。</li>
</ul>
<h3 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h3><ul>
<li><strong>Frame</strong>：显示和导航内容页面。</li>
<li><strong>Hyperlink</strong>：超链接，导航到指定 URL。</li>
<li><strong>Page</strong>：表示导航的页面。</li>
<li><strong>NavigationWindow</strong>：窗口，支持导航功能。</li>
<li><strong>TabControl</strong>：选项卡控件，允许切换多个页面。</li>
</ul>
<h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><ul>
<li><strong>CheckBox</strong>：复选框，表示一个开关选项。</li>
<li><strong>ComboBox</strong>：下拉列表，允许选择一个项目。</li>
<li><strong>ListBox</strong>：列表框，允许选择一个或多个项目。</li>
<li><strong>RadioButton</strong>：单选按钮，成组使用时只能选择一个。</li>
<li><strong>Slider</strong>：滑块控件，用于选择范围值。</li>
</ul>
<h3 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h3><ul>
<li><strong>AccessText</strong>：带有快捷键的文本标签。</li>
<li><strong>Label</strong>：显示文本标签。</li>
<li><strong>Popup</strong>：弹出窗口。</li>
<li><strong>ProgressBar</strong>：进度条，显示任务进度。</li>
<li><strong>StatusBar</strong>：状态栏，显示应用程序状态信息。</li>
<li><strong>TextBlock</strong>：显示文本内容。</li>
<li><strong>ToolTip</strong>：工具提示，显示额外信息。</li>
</ul>
<h2 id="依赖属性与普通属性"><a href="#依赖属性与普通属性" class="headerlink" title="依赖属性与普通属性"></a>依赖属性与普通属性</h2><blockquote>
<p>依赖属性（Dependency Property）是一种特殊的属性系统，通常用于WPF（Windows Presentation Foundation）应用程序中。依赖属性允许属性的值能够从多个来源继承、动态更新和通知变化，同时提供了一种有效的方式来管理属性值的继承、样式化、数据绑定和动画</p>
<p>赖属性有一个特性，当你没有为控件的某个属性显式地赋值时，它就会把自己所在容器的属性值拿过来，当作自己的属性值</p>
</blockquote>
<p>依赖属性:在wpf主要扮演数据驱动中的重要角色,它能配合绑定一起实时数据更新UI显示,动画,自定义控件等</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextBox Width=&quot;300&quot; Height=&quot;30&quot; Name=&quot;tbAccount&quot;&gt;&lt;/TextBox&gt;</span><br><span class="line">&lt;TextBox Grid.Row=&quot;1&quot; Width=&quot;300&quot; Height=&quot;30&quot; Text=&quot;&#123;Binding Path=Text, ElementName=tbAccount&#125;&quot;&gt;&lt;/TextBox&gt;</span><br><span class="line">#当第一个TextBox的文本发生变化时，第二个TextBox的文本也会同步变化。这种方式被称为元素绑定，它允许一个控件的属性同步于另一个控件的属性。</span><br></pre></td></tr></table></figure>

<p>依赖属性的实例:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">testGrid</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomButton</span>:<span class="title">Button</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> CornerRadius ButtonCornerRadiu</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span> &#123; <span class="keyword">return</span> (CornerRadius)GetValue(ButtonCornerRadiuProperty); &#125;</span><br><span class="line">            <span class="keyword">set</span> &#123; SetValue(ButtonCornerRadiuProperty, <span class="keyword">value</span>); &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Using a DependencyProperty as the backing store for ButtonCornerRadiu.  This enables animation, styling, binding, etc...</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> DependencyProperty ButtonCornerRadiuProperty =</span><br><span class="line">            DependencyProperty.Register(<span class="string">&quot;ButtonCornerRadiu&quot;</span>, <span class="keyword">typeof</span>(CornerRadius), <span class="keyword">typeof</span>(CustomButton), <span class="keyword">new</span> PropertyMetadata(<span class="number">0</span>));<span class="comment">// PropertyMetadata(0)表示默认值为0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自己定义了一个按钮,按钮中添加了依赖属性ButtonCornerRadiu,后续可以在xaml中使用</span></span><br><span class="line"><span class="comment">//&lt;CustomButton ButtonCornerRadiu=&quot;20&quot;&gt;&lt;/CustomButton&gt;</span></span><br></pre></td></tr></table></figure>

<p>普通属性也能实现实时数据更新,但是<a href="#%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%B8%8B%E6%96%87%E6%94%AF%E6%8C%81%E5%8F%98%E5%8C%96%E9%80%9A%E7%9F%A5">需要额外实现一套通知机制叫做INotifyPropertyChanged</a>,不支持其他操作</p>
<p>依赖属性内置了通知机制</p>
<p>可以输入propdp再按两下tab键生成一个依赖属性的模板</p>
<h3 id="属性变化的回调"><a href="#属性变化的回调" class="headerlink" title="属性变化的回调"></a>属性变化的回调</h3><p>如果您想在属性值变化时执行某些操作，可以提供一个 <code>PropertyChangedCallback</code> 函数作为 <code>PropertyMetadata</code> 的参数。例如：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> DependencyProperty ButtonCornerRadiuProperty =</span><br><span class="line">    DependencyProperty.Register(<span class="string">&quot;ButtonCornerRadiu&quot;</span>, <span class="keyword">typeof</span>(CornerRadius), <span class="keyword">typeof</span>(CustomButton), <span class="keyword">new</span> PropertyMetadata(<span class="keyword">new</span> CornerRadius(<span class="number">0</span>), OnButtonCornerRadiuChanged));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OnButtonCornerRadiuChanged</span>(<span class="params">DependencyObject d, DependencyPropertyChangedEventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理属性变化的逻辑</span></span><br><span class="line">    CustomButton button = d <span class="keyword">as</span> CustomButton;</span><br><span class="line">    CornerRadius newRadius = (CornerRadius)e.NewValue;</span><br><span class="line">    <span class="comment">// 在这里可以添加响应逻辑，例如更新 UI</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="依赖属性详解"><a href="#依赖属性详解" class="headerlink" title="依赖属性详解"></a>依赖属性详解</h3><blockquote>
<p>CLR属性:CLR属性主要实现了面向对象的封装。CLR属性是通过get和set访问器方法来实现的，这些方法允许你在读取或写入属性时执行自定义代码。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字段</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CLR属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>对内存的使用机制</strong><br>• CLR属性是常见的.NET属性类型，每个对象实例都有自己的一套CLR属性。每当创建一个新的对象实例时，都会为该实例的所有CLR属性分配内存。<br>• 依赖属性是WPF中的特殊属性类型，它的设计目标是减少内存使用。依赖属性并不为每个对象实例分配内存，而是<strong>将属性值存储在全局的哈希表中</strong>。对于拥有依赖属性的类来说，其实例化的对象可以称作为依赖对象（Dependency Object），WPF中允许依赖对象在被创建时并不包含用于数据存储的空间，只保留在需要用到数据时能够获得默认值或借用其他对象的数据，具有实施分配空间的能力。</p>
<h3 id="自定义依赖属性"><a href="#自定义依赖属性" class="headerlink" title="自定义依赖属性"></a>自定义依赖属性</h3><p>在编写一般属性时，通常是声明字段，然后添加get和set块封装为CLR属性。而在编写依赖属性时，需要进行下面四个步骤。</p>
<p>在WPF当中, 所有支持绑定的属性本质上它都是封装后的依赖属性。那么也就是说, <strong>只有依赖属性才可以进行绑定</strong></p>
<p><strong>一定注意,MVVM架构中,这个依赖属性是写在xaml的后台文件中的</strong>,这样可以将数据绑定逻辑和 UI 逻辑分开，保持代码的清晰性。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.使类型继承DependencyObject类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Student</span> : <span class="title">DependencyObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 依赖属性:2. 声明只读的DependencyProperty字段</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> DependencyProperty GradeProperty = </span><br><span class="line">      DependencyProperty.Register(<span class="string">&quot;Grade&quot;</span>, <span class="keyword">typeof</span>(<span class="built_in">int</span>), <span class="keyword">typeof</span>(Student));</span><br><span class="line">      <span class="comment">//上面3. 注册依赖属性  </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依赖属性包装器  4.使用属性封装,get和set块内部使用GetValue()和SetValue()操作属性值  ,需要通过GetValue和SetValue对依赖属性进行操作,因此真正操作依赖属性通过Grade来操作(Grade就是对依赖属性封装为CLR属性)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Grade</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> (<span class="built_in">int</span>)GetValue(GradeProperty); &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; SetValue(GradeProperty, <span class="keyword">value</span>); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>声明依赖属性的所在位置的对象必须直接或简介继承于DependencyObject对象, 这样它才具备GetValue&#x2F;SetValue方法。</p>
<p>DependencyObject继承关系</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202408280912885.png" alt="img" style="zoom: 50%;" />
</blockquote>
<h4 id="DependencyProperty-Register"><a href="#DependencyProperty-Register" class="headerlink" title="DependencyProperty.Register"></a>DependencyProperty.Register</h4><ul>
<li>参数1: CLR属性名: 表示以哪个CLR属性作为这个依赖属性的包装器</li>
<li>参数2: 属性类型: 依赖属性用来存储什么类型的值</li>
<li>参数3: 宿主类型: 依赖属性的宿主类型</li>
<li>参数4: 指定依赖属性的其他功能的,例如默认值,回调函数(属性变更后的操作),继承,双向绑定,是否可以绑定等等</li>
<li>参数5: 一个实现校验功能的委托: 可以给依赖属性赋值的时候进行有效验证</li>
</ul>
<h4 id="只读依赖属性"><a href="#只读依赖属性" class="headerlink" title="只读依赖属性"></a>只读依赖属性</h4><p>在WPF中只读的依赖属性的定义方式与一般依赖属性的定义方式基本一样，只读依赖属性仅仅是用 <code>DependencyProperty.RegisterReadonly</code>替换了 <code>DependencyProperty.Register</code>。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">MainWindow</span> : <span class="title">Window</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainWindow</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        InitializeComponent();</span><br><span class="line">        <span class="comment">// 内部使用SetValue来设置值</span></span><br><span class="line">        SetValue(counterKey, <span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 属性包装器，只提供GetValue，你也可以设置一个private的SetValue进行限制。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Counter</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> (<span class="built_in">int</span>)GetValue(counterKey.DependencyProperty); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用RegisterReadOnly来代替Register来注册一个只读的依赖属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> DependencyPropertyKey counterKey =</span><br><span class="line">        DependencyProperty.RegisterReadOnly(<span class="string">&quot;Counter&quot;</span>,</span><br><span class="line">            <span class="keyword">typeof</span>(<span class="built_in">int</span>),</span><br><span class="line">            <span class="keyword">typeof</span>(MainWindow),</span><br><span class="line">            <span class="keyword">new</span> PropertyMetadata(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="依赖属性的继承"><a href="#依赖属性的继承" class="headerlink" title="依赖属性的继承"></a>依赖属性的继承</h3><p>元素可以从其在对象树中的父级继承依赖属性的值。属性值继承是一种机制，通过这种机制，<strong>依赖属性值可以在包含该属性的元素树中从父元素传播到子元素。</strong></p>
<h3 id="依赖属性的优先级"><a href="#依赖属性的优先级" class="headerlink" title="依赖属性的优先级"></a>依赖属性的优先级</h3><p>WPF每访问一个依赖属性，它都会按照下面的顺序由高到底处理该值。具体优先级从最高到最低排序如下：</p>
<p>动画&gt;绑定&gt;本地值&gt;自定义Style Trigger&gt;自定义Template Trigger&gt;自定义Style Setter&gt;默认Style Trigger&gt;默认 Style Setter&gt;继承值&gt;默认值</p>
<h3 id="附加属性"><a href="#附加属性" class="headerlink" title="附加属性"></a>附加属性</h3><p>附加是一种特殊的依赖属性。附加属性是说，一个属性本来不属于某个对象，但是由于某种需求而被后来附加上，表现出来的就是被环境赋予的属性。</p>
<p>如:<code>Grid.Column</code>,<code>Canvas.Top</code>这样的属性</p>
<p>自定义附加属性和定义一般的依赖属性一样没什么区别，只是用RegisterAttached方法代替了Register方法。下面代码演示了附加属性的定义。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202407021530223.png" alt="iShot_2024-07-02_15.28.55" style="zoom:33%;" />

<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">GetMyProperty</span>(<span class="params">DependencyObject obj</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">int</span>)obj.GetValue(MyPropertyProperty);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetMyProperty</span>(<span class="params">DependencyObject obj, <span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    obj.SetValue(MyPropertyProperty, <span class="keyword">value</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Using a DependencyProperty as the backing store for MyProperty.  This enables animation, styling, binding, etc...</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> DependencyProperty MyPropertyProperty =</span><br><span class="line">    DependencyProperty.RegisterAttached(<span class="string">&quot;MyProperty&quot;</span>, <span class="keyword">typeof</span>(<span class="built_in">int</span>), <span class="keyword">typeof</span>(ownerclass), <span class="keyword">new</span> PropertyMetadata(<span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<p>可以输入propa再按两下tab键生成一个附加属性的模板</p>
<p>声明附加属性的对象无需继承于DependencyObject, 因为这个时候DependencyObject对象作为方法参数传递</p>
<h2 id="附加属性案例"><a href="#附加属性案例" class="headerlink" title="附加属性案例"></a>附加属性案例</h2><p>不改变不继承Button的情况下,做一个圆角控制</p>
<p>定义附加属性ButtonHelper</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">WpfApp1.Helper</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ButtonHelper</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//附加属性  主人是ButtonHelper</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> DependencyProperty CornerRadiusProperty = DependencyProperty.RegisterAttached(</span><br><span class="line">        <span class="string">&quot;CornerRadius&quot;</span>, <span class="keyword">typeof</span>(CornerRadius), <span class="keyword">typeof</span>(ButtonHelper), <span class="keyword">new</span> PropertyMetadata(<span class="keyword">new</span> CornerRadius(<span class="number">0</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetCornerRadius</span>(<span class="params">DependencyObject element, CornerRadius <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        element.SetValue(CornerRadiusProperty, <span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CornerRadius <span class="title">GetCornerRadius</span>(<span class="params">DependencyObject element</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (CornerRadius)element.GetValue(CornerRadiusProperty);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用该附加属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">xmlns:hhhh=&quot;clr-namespace:WpfApp1.Helper&quot;</span><br><span class="line"></span><br><span class="line">&lt;Button Content=&quot;你好,世界&quot; hhhh:ButtonHelper.CornerRadius=&quot;5&quot;&gt;</span><br><span class="line">          &lt;Button.Template&gt;</span><br><span class="line">              &lt;ControlTemplate TargetType=&quot;Button&quot;&gt;</span><br><span class="line">                  &lt;Border</span><br><span class="line">                      BorderBrush=&quot;Black&quot;</span><br><span class="line">                      BorderThickness=&quot;1&quot;</span><br><span class="line">                      CornerRadius=&quot;&#123;TemplateBinding hhhh:ButtonHelper.CornerRadius&#125;&quot;&gt;</span><br><span class="line">                      &lt;ContentPresenter Content=&quot;&#123;TemplateBinding Content&#125;&quot; /&gt;</span><br><span class="line">                  &lt;/Border&gt;</span><br><span class="line">              &lt;/ControlTemplate&gt;</span><br><span class="line">          &lt;/Button.Template&gt;</span><br><span class="line">      &lt;/Button&gt;</span><br></pre></td></tr></table></figure>

<h2 id="附加属性与依赖属性使用场景"><a href="#附加属性与依赖属性使用场景" class="headerlink" title="附加属性与依赖属性使用场景"></a>附加属性与依赖属性使用场景</h2><ul>
<li><strong>依赖属性</strong>: 当您需要单独创建控件时, 并且希望控件的某个部分能够支持数据绑定时, 你则可以使用到依赖属性。</li>
<li><strong>附加属性</strong>: 这种情况很多, 正因为WPF当中并不是所有的内容都支持数据绑定, 但是我们希望其支持数据绑定, 这样我们就可以<strong>创建基于自己声明的附加属性,添加到元素上, 让其元素的某个原本不支持数据绑定的属性间接形成绑定关系</strong>。</li>
<li><strong>例如</strong>:为PassWord定义附加属性与PassWord进行关联。例如DataGrid控件不支持SelectedItems, 但是我们想要实现选中多个条目进行数据绑定, 这个时候也可以声明附加属性的形式让其支持数据绑定。</li>
</ul>
<p>很常用的一些附加属性如 <code>TextElement.Foreground</code>,可以通过此附加属性在模板中设置Foreground,而不需要设置<a href="#ContentPresenter">ContentPresenter</a>中的Foreground</p>
<h2 id="一般情况特性"><a href="#一般情况特性" class="headerlink" title="一般情况特性"></a>一般情况特性</h2><p>对于许多控件来说，</p>
<ul>
<li>Text 属性通常用于表示其显示的文本内容，这是比较常见和直观的。</li>
<li>Button 控件的文本内容确实常常通过 Content 属性来设置。</li>
<li>而对于像 ComboBox 这样可以包含多个可选项的数据控件，设置 ItemsSource 等Items开头的属性来指定数据源是一种常见的方式(Items开头的属性一般都是集合形式的)，通过这种方式可以方便地管理和显示多个数据项。</li>
</ul>
<h2 id="x详解"><a href="#x详解" class="headerlink" title="x详解"></a>x详解</h2><p>类似于winform中代码是通过给控件的属性Name设置索引名称来找到控件,在WPF中通过属性 <code>x:</code>可以取到各种属性,其中就包括Name属性,即设置 <code>x: Name = &quot;btnThis&quot;</code>,之后在代码中可以通过btnThis直接操作该控件</p>
<h2 id="容器及其子项的对应"><a href="#容器及其子项的对应" class="headerlink" title="容器及其子项的对应"></a>容器及其子项的对应</h2><p>Generator和对应的Container的罗列:</p>
<table>
<thead>
<tr>
<th>Container</th>
<th>Generator&#x2F;item</th>
</tr>
</thead>
<tbody><tr>
<td>ListBox</td>
<td>ListBoxItem</td>
</tr>
<tr>
<td>TreeView</td>
<td>TreeViewItem</td>
</tr>
<tr>
<td>TabControl</td>
<td>TabItem</td>
</tr>
</tbody></table>
<h2 id="DataGrid详解"><a href="#DataGrid详解" class="headerlink" title="DataGrid详解"></a>DataGrid详解</h2><p>在 WPF 中，<code>DataGrid</code> 是一个用于显示和编辑表格数据的控件。与 <code>ListView</code> 类似，<code>DataGrid</code> 也支持数据绑定，但它提供了更多的功能，尤其是在处理表格数据时。<code>DataGrid</code> 适合用于显示大量数据，并支持排序、筛选、分页和编辑等功能</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202412061710477.png" alt="image-20241206171018922"></p>
<p>DataGrid默认会显示所有数据列,默认会显示所有成员</p>
<p>DataGrid数据绑定演示</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;DataGrid x:Name=<span class="string">&quot;DG_BlackBox&quot;</span> FontSize=<span class="string">&quot;20&quot;</span> Grid.Row=<span class="string">&quot;1&quot;</span> VerticalScrollBarVisibility=<span class="string">&quot;Visible&quot;</span> Margin=<span class="string">&quot;5&quot;</span> ItemsSource=<span class="string">&quot;&#123;Binding ViewSource&#125;&quot;</span> CanUserAddRows=<span class="string">&quot;False&quot;</span> CanUserDeleteRows=<span class="string">&quot;False&quot;</span> CanUserReorderColumns=<span class="string">&quot;False&quot;</span> CanUserResizeRows=<span class="string">&quot;False&quot;</span> CanUserSortColumns=<span class="string">&quot;False&quot;</span> AutoGenerateColumns=<span class="string">&quot;False&quot;</span> IsReadOnly=<span class="string">&quot;True&quot;</span> ScrollViewer.CanContentScroll=<span class="string">&quot;True&quot;</span> VirtualizingPanel.ScrollUnit=<span class="string">&quot;Item&quot;</span> VirtualizingPanel.IsVirtualizing=<span class="string">&quot;True&quot;</span> VirtualizingPanel.VirtualizationMode=<span class="string">&quot;Recycling&quot;</span>&gt;</span><br><span class="line">            &lt;DataGrid.Columns&gt;</span><br><span class="line">                &lt;DataGridTextColumn Binding=<span class="string">&quot;&#123;Binding Code&#125;&quot;</span> Width=<span class="string">&quot;100&quot;</span> Header=<span class="string">&quot;代码&quot;</span>/&gt;</span><br><span class="line">                &lt;DataGridTextColumn Binding=<span class="string">&quot;&#123;Binding Name&#125;&quot;</span> Width=<span class="string">&quot;150&quot;</span> Header=<span class="string">&quot;名称&quot;</span>/&gt;</span><br><span class="line">                &lt;DataGridTextColumn Binding=<span class="string">&quot;&#123;Binding Type&#125;&quot;</span> Width=<span class="string">&quot;150&quot;</span> Header=<span class="string">&quot;类型&quot;</span>/&gt;</span><br><span class="line">                &lt;DataGridTextColumn Binding=<span class="string">&quot;&#123;Binding UserName&#125;&quot;</span> Width=<span class="string">&quot;150&quot;</span> Header=<span class="string">&quot;用户&quot;</span>/&gt;</span><br><span class="line">                &lt;DataGridTextColumn Binding=<span class="string">&quot;&#123;Binding DateTime,Mode=OneWay,StringFormat=&#123;&#125;&#123;0:yyyy-MM-dd HH:mm:ss&#125;&#125;&quot;</span> Width=<span class="string">&quot;240&quot;</span> Header=<span class="string">&quot;开始时间&quot;</span>/&gt;</span><br><span class="line">                &lt;DataGridTextColumn Binding=<span class="string">&quot;&#123;Binding ResolveDateTime,Mode=OneWay,StringFormat=&#123;&#125;&#123;0:yyyy-MM-dd HH:mm:ss&#125;&#125;&quot;</span> Width=<span class="string">&quot;240&quot;</span> Header=<span class="string">&quot;解决时间&quot;</span>/&gt;</span><br><span class="line">                &lt;DataGridTextColumn Binding=<span class="string">&quot;&#123;Binding Description&#125;&quot;</span> Width=<span class="string">&quot;auto&quot;</span> Header=<span class="string">&quot;描述&quot;</span>/&gt;</span><br><span class="line">            &lt;/DataGrid.Columns&gt;</span><br><span class="line">        &lt;/DataGrid&gt;</span><br></pre></td></tr></table></figure>

<p>这些绑定确保了 DataGrid 能够从视图模型中的集合属性 ViewSource 获取数据，并将每个数据项的特定字段显示在相应的列中。这是 MVVM 设计模式的一个典型应用，通过数据绑定将模型数据展示在视图上，同时保持视图和模型的解耦</p>
<p>UserName 以及其他通过 Binding 属性指定的字段（如 Code, Name, Type, DateTime, ResolveDateTime, Description）都是 ViewSource 集合中元素的属性</p>
<h3 id="DataGrid属性例子"><a href="#DataGrid属性例子" class="headerlink" title="DataGrid属性例子"></a>DataGrid属性例子</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">x:Name=<span class="string">&quot;DG_BlackBox&quot;</span>：</span><br><span class="line">x:Name属性用于为XAML元素指定名称，以便在后台代码中引用该元素。在这里，DataGrid被命名为<span class="string">&quot;DG_BlackBox&quot;</span>，可以在后台代码中使用该名称来操作或访问DataGrid。</span><br><span class="line">FontSize=<span class="string">&quot;20&quot;</span>：</span><br><span class="line">FontSize属性用于设置控件的字体大小。在这里，DataGrid的字体大小被设置为<span class="number">20</span>。</span><br><span class="line">Grid.Row=<span class="string">&quot;1&quot;</span>：</span><br><span class="line">Grid.Row属性用于指定控件在Grid布局中所在的行索引。在这里，DataGrid被放置在Grid布局的第<span class="number">1</span>行。</span><br><span class="line">VerticalScrollBarVisibility=<span class="string">&quot;Visible&quot;</span>：</span><br><span class="line">VerticalScrollBarVisibility属性用于设置垂直滚动条的可见性。在这里，设置垂直滚动条始终可见。</span><br><span class="line">Margin=<span class="string">&quot;5&quot;</span>：</span><br><span class="line">Margin属性用于设置控件的外边距。在这里，DataGrid的外边距被设置为<span class="number">5</span>个逻辑单位。</span><br><span class="line">ItemsSource=<span class="string">&quot;&#123;Binding ViewSource&#125;&quot;</span>：</span><br><span class="line">ItemsSource属性用于绑定DataGrid的数据源。在这里，DataGrid绑定到名为<span class="string">&quot;ViewSource&quot;</span>的数据源。</span><br><span class="line">CanUserAddRows=<span class="string">&quot;False&quot;</span>：</span><br><span class="line">CanUserAddRows属性用于设置用户是否可以添加新行。在这里，设置用户不能添加新行。</span><br><span class="line">CanUserDeleteRows=<span class="string">&quot;False&quot;</span>：</span><br><span class="line">CanUserDeleteRows属性用于设置用户是否可以删除行。在这里，设置用户不能删除行。</span><br><span class="line">CanUserReorderColumns=<span class="string">&quot;False&quot;</span>：</span><br><span class="line">CanUserReorderColumns属性用于设置用户是否可以重新排序列。在这里，设置用户不能重新排序列。</span><br><span class="line">CanUserResizeRows=<span class="string">&quot;False&quot;</span>：</span><br><span class="line">CanUserResizeRows属性用于设置用户是否可以调整行的大小。在这里，设置用户不能调整行的大小。</span><br><span class="line">CanUserSortColumns=<span class="string">&quot;False&quot;</span>：</span><br><span class="line">CanUserSortColumns属性用于设置用户是否可以对列进行排序。在这里，设置用户不能对列进行排序。</span><br><span class="line">AutoGenerateColumns=<span class="string">&quot;False&quot;</span>：</span><br><span class="line">AutoGenerateColumns属性用于设置是否自动生成列。在这里，设置为不自动生成列。</span><br><span class="line">IsReadOnly=<span class="string">&quot;True&quot;</span>：</span><br><span class="line">IsReadOnly属性用于设置DataGrid是否为只读。在这里，设置DataGrid为只读，用户不能编辑数据。</span><br><span class="line">ScrollViewer.CanContentScroll=<span class="string">&quot;True&quot;</span>：</span><br><span class="line">ScrollViewer.CanContentScroll属性用于指定ScrollViewer是否按内容单位滚动。在这里，设置为按内容单位滚动。</span><br><span class="line">VirtualizingPanel.ScrollUnit=<span class="string">&quot;Item&quot;</span>：</span><br><span class="line">VirtualizingPanel.ScrollUnit属性用于设置虚拟化面板的滚动单位。在这里，设置为按项滚动。</span><br><span class="line">VirtualizingPanel.IsVirtualizing=<span class="string">&quot;True&quot;</span>：</span><br><span class="line">VirtualizingPanel.IsVirtualizing属性用于启用或禁用虚拟化。在这里，启用虚拟化以提高性能。</span><br><span class="line">VirtualizingPanel.VirtualizationMode=<span class="string">&quot;Recycling&quot;</span>：</span><br><span class="line">VirtualizingPanel.VirtualizationMode属性用于设置虚拟化模式。在这里，设置为<span class="string">&quot;Recycling&quot;</span>以重用可视元素。</span><br></pre></td></tr></table></figure>

<h3 id="AutoGenerateColumns"><a href="#AutoGenerateColumns" class="headerlink" title="AutoGenerateColumns"></a>AutoGenerateColumns</h3><p><code>AutoGenerateColumns</code> 属性用于控制 <code>DataGrid</code> 控件中列的自动生成行为。它的主要作用是在数据绑定时决定是否自动根据数据源的属性生成列</p>
<p><strong>AutoGenerateColumns</strong>：这个属性是一个布尔值，默认为 <code>true</code>。当设置为 <code>true</code> 时，<code>DataGrid</code> 会根据绑定的数据源（通常是集合类型，比如 <code>ObservableCollection</code>）的属性自动生成列。每个属性都会对应一个列，列的标题会使用属性名，列的数据类型会根据属性的类型自动推断。</p>
<p>如果你希望手动定义列，而不使用自动生成，可以将 <code>AutoGenerateColumns</code> 设置为 <code>false</code>。这时，你需要显式地定义 <code>DataGrid</code> 的列：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">DataGrid</span> <span class="attr">AutoGenerateColumns</span>=<span class="string">&quot;False&quot;</span> <span class="attr">ItemsSource</span>=<span class="string">&quot;&#123;Binding YourCollection&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">DataGrid.Columns</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">DataGridTextColumn</span> <span class="attr">Header</span>=<span class="string">&quot;Name&quot;</span> <span class="attr">Binding</span>=<span class="string">&quot;&#123;Binding Name&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">DataGridTextColumn</span> <span class="attr">Header</span>=<span class="string">&quot;Age&quot;</span> <span class="attr">Binding</span>=<span class="string">&quot;&#123;Binding Age&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">DataGrid.Columns</span>&gt;</span></span><br><span class="line">&lt;/DataGrid</span><br></pre></td></tr></table></figure>

<h3 id="使用DataGrid实现一个全新的TreeGrid"><a href="#使用DataGrid实现一个全新的TreeGrid" class="headerlink" title="使用DataGrid实现一个全新的TreeGrid"></a>使用DataGrid实现一个全新的TreeGrid</h3><p><a target="_blank" rel="noopener" href="https://www.codeproject.com/Articles/1213466/WPF-TreeGrid-using-a-DataGrid">参考文章</a></p>
<h2 id="CollectionView"><a href="#CollectionView" class="headerlink" title="CollectionView"></a>CollectionView</h2><p>CollectionView是WPF中的一个类，用于对数据进行排序、过滤、分组等操作</p>
<p>CollectionView是一个抽象基类，它定义了数据源、排序规则、过滤规则、分页规则等属性和方法。CollectionView的实现类包括ListView、GridView、DataGrid等。这些类分别用于显示不同的数据布局和样式。</p>
<p>例如，ListView用于显示一个列表，DataGrid用于显示一个表格，GridView用于显示一个图标网格。这些类都继承自CollectionView，并实现了CollectionView的接口，从而具有相同的方法和属性。</p>
<p>使用CollectionView类可以方便地处理数据，例如：</p>
<p>排序：通过设置CollectionView的SortDescriptors属性，可以实现数据的自定义排序。<br>过滤：通过设置CollectionView的FilterConditions属性，可以实现数据的自定义过滤。<br>分页：通过设置CollectionView的PageSize和CurrentPage属性，可以实现数据的分页显示。<br>导航：通过实现CollectionView的Navigate方法，可以实现数据的导航操作，例如上一页、下一页、首页等。<br>总之，CollectionView是WPF应用程序中用于显示数据的一种控件，它提供了一种灵活的方式来处理数据，包括排序、过滤、分页、导航等</p>
<h2 id="ProgressBar"><a href="#ProgressBar" class="headerlink" title="ProgressBar"></a>ProgressBar</h2><p>进度条案例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;ProgressBar Height=&quot;25&quot; Style=&quot;&#123;StaticResource ProgressBarInfoStripe&#125;&quot; Minimum=&quot;0&quot; Maximum=&quot;100&quot; Value=&quot;&#123;Binding Progress&#125;&quot;&gt;</span><br><span class="line">                &lt;ProgressBar.Triggers&gt;</span><br><span class="line">                    &lt;EventTrigger RoutedEvent=&quot;ProgressBar.ValueChanged&quot;&gt;</span><br><span class="line">                        &lt;BeginStoryboard&gt;</span><br><span class="line">                            &lt;Storyboard&gt;</span><br><span class="line">                                &lt;DoubleAnimation Storyboard.TargetProperty=&quot;Value&quot; </span><br><span class="line">                                                 From=&quot;&#123;Binding RelativeSource=&#123;RelativeSource Self&#125;, Path=Value&#125;&quot; </span><br><span class="line">                                                 To=&quot;&#123;Binding Progress,RelativeSource =&#123;RelativeSource Self&#125;&#125;&quot; </span><br><span class="line">                                                 Duration=&quot;0:0:0.1&quot;/&gt;</span><br><span class="line">                            &lt;/Storyboard&gt;</span><br><span class="line">                        &lt;/BeginStoryboard&gt;</span><br><span class="line">                    &lt;/EventTrigger&gt;</span><br><span class="line">                &lt;/ProgressBar.Triggers&gt;</span><br><span class="line">            &lt;/ProgressBar&gt;</span><br></pre></td></tr></table></figure>

<h2 id="虚拟化-延迟滚动"><a href="#虚拟化-延迟滚动" class="headerlink" title="虚拟化&#x2F;延迟滚动"></a>虚拟化&#x2F;延迟滚动</h2><ul>
<li><p>启用虚拟化：<code>VirtualizingStackPanel.IsVirtualizing=&quot;True&quot;</code></p>
<ul>
<li>动态回收&#x2F;创建容器（VirtualizationMode.Standard）</li>
<li>复用容器（VirtualizationMode.Recycling）</li>
</ul>
<p><code>VirtualizingStackPanel.VirtualizationMode=&quot;Recycling&quot;</code>  虚拟化容器复用机制可提升展开&#x2F;折叠动画流畅度</p>
</li>
<li><p>延迟滚动：<code>ScrollViewer.IsDeferredScrollingEnabled=&quot;True&quot;</code></p>
<ul>
<li>需要精确显示滚动位置时需禁用</li>
<li>与触摸屏滚动存在兼容性问题时需测试</li>
</ul>
</li>
</ul>
<blockquote>
<p>虚拟化: 仅实例化可视区域内的节点容器（如TreeViewItem），而非一次性创建全部容器</p>
<p>延迟滚动: 用户拖动滚动条时不实时更新内容，释放滚动块后才刷新,避免滚动过程中的频繁布局计算和渲染(快速滚动时不会出现”白屏”现象)</p>
</blockquote>
<p><strong>使用场景</strong></p>
<table>
<thead>
<tr>
<th>场景特征</th>
<th>推荐方案</th>
<th>原因说明</th>
</tr>
</thead>
<tbody><tr>
<td>纯展示型TreeView</td>
<td><strong>关闭虚拟化</strong></td>
<td>简化样式开发</td>
</tr>
<tr>
<td>含复杂数据绑定的业务系统</td>
<td>开启虚拟化</td>
<td>避免未来扩展时的重构成本</td>
</tr>
<tr>
<td>需要触摸屏操作</td>
<td>开启延迟滚动</td>
<td>提升滑动操作流畅度</td>
</tr>
<tr>
<td>节点含动态加载内容</td>
<td>开启虚拟化+延迟滚动</td>
<td>预防子项异步加载时的卡顿</td>
</tr>
</tbody></table>
<p>数据量较少的情况下不开启的主要原因盘点如下</p>
<ol>
<li>性能提升幅度 &lt; 样式开发复杂度增加</li>
<li>可能引入不必要的渲染异常（如部分阴影效果失效）</li>
<li>在DevExpress等第三方控件中，虚拟化可能破坏内置样式</li>
</ol>
<h2 id="TreeView"><a href="#TreeView" class="headerlink" title="TreeView"></a>TreeView</h2><p>非常适合用于展示有层级多层嵌套的数据</p>
<p>TreeView控件的主要功能包括：</p>
<ul>
<li>显示层次化的数据结构。</li>
<li>支持节点折叠和展开。</li>
<li>支持选中和取消选中节点。</li>
<li>支持拖放节点重排。</li>
<li>支持 CheckBox 显示，以支持复选框功能。</li>
</ul>
<p>使用到一个叫<strong>层次结构数据模板</strong>来绑定元素</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_30508241/article/details/98687395"> 参考将json数据显示未TreeView </a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xiaogongzhu001/article/details/131100371">treeview详解</a></p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/49580134/how-to-display-json-in-wpf-treeview">treeview中显示json数据转换器</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/opus/968011304135557192">TreeView原理探寻</a></p>
<h3 id="主要属性"><a href="#主要属性" class="headerlink" title="主要属性"></a>主要属性</h3><ul>
<li>ItemsSource：指定TreeView控件的数据源，<strong>注意必须为一个集合</strong>。</li>
<li>DisplayMemberPath：指定用于显示节点文本的属性路径。</li>
<li>SelectedItem：指定当前选中的节点。</li>
<li>IsExpanded：指定节点是否展开。</li>
<li>IsChecked：指定节点是否被选中。</li>
</ul>
<blockquote>
<p>TreeView如果要传递选中项,可以通过绑定Command的过程中传递参数来实现,如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;i:Interaction.Triggers&gt;</span><br><span class="line">    &lt;i:EventTrigger EventName=&quot;SelectedItemChanged&quot;&gt;</span><br><span class="line">         &lt;prism:InvokeCommandAction Command=&quot;&#123;Binding SelectionChanged&#125;&quot; </span><br><span class="line">                  TriggerParameterPath=&quot;NewValue&quot; /&gt;</span><br><span class="line">    &lt;/i:EventTrigger&gt;</span><br><span class="line">&lt;/i:Interaction.Triggers&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul>
<li>AddNode：在指定的父节点下添加一个新的子节点。</li>
<li>RemoveNode：删除指定的节点。</li>
<li>ClearNodes：清除指定节点的所有子节点。</li>
<li>ExpandAll：展开所有节点。</li>
<li>CollapseAll：折叠所有节点。</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>注意TreeView如果直接使用ItemsSource绑定一个集合,其只能显示集合本身的数据,默认调用的是集合中每个对象的toString方法,如果没有重写对象的toString方法,就会显示类型信息的文本.</p>
<p>最重要的一点是,TreeView只使用ItemsSource是不能具备层次结构的,需要配合<a href="#HierarchicalDataTemplate">HierarchicalDataTemplate</a>使用</p>
<p><strong>使用案例如下</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Classes --&gt; Classes 包含 Groups  --&gt; Group  包含 Students --&gt; Student</span><br><span class="line">Calssed: ObservableCollection&lt;Class&gt;</span><br><span class="line">Groups: ObservableCollection&lt;Group&gt;</span><br><span class="line">Students: ObservableCollection&lt;Student&gt;</span><br></pre></td></tr></table></figure>

<h4 id="两层案例"><a href="#两层案例" class="headerlink" title="两层案例"></a>两层案例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;TreeView Height=&quot;100&quot; ItemsSource=&quot;&#123;Binding Groups&#125;&quot;&gt;</span><br><span class="line">    &lt;TreeView.ItemTemplate&gt;</span><br><span class="line">        &lt;HierarchicalDataTemplate ItemsSource=&quot;&#123;Binding Students&#125;&quot;&gt;</span><br><span class="line">            &lt;!--  单个Group项目录显示的名字  --&gt;</span><br><span class="line">            &lt;TextBlock Text=&quot;&#123;Binding Students.Count&#125;&quot; /&gt;</span><br><span class="line">            &lt;!--  定义每个Group展开显示的模板  --&gt;</span><br><span class="line">            &lt;HierarchicalDataTemplate.ItemTemplate&gt;</span><br><span class="line">                &lt;DataTemplate DataType=&quot;&#123;x:Type vm:Student&#125;&quot;&gt;</span><br><span class="line">                    &lt;WrapPanel&gt;</span><br><span class="line">                        &lt;TextBlock Text=&quot;&#123;Binding Name&#125;&quot; /&gt;</span><br><span class="line">                        &lt;TextBlock Margin=&quot;5,0,0,0&quot; Text=&quot;&#123;Binding Age&#125;&quot; /&gt;</span><br><span class="line">                    &lt;/WrapPanel&gt;</span><br><span class="line">                &lt;/DataTemplate&gt;</span><br><span class="line">            &lt;/HierarchicalDataTemplate.ItemTemplate&gt;</span><br><span class="line">        &lt;/HierarchicalDataTemplate&gt;</span><br><span class="line">    &lt;/TreeView.ItemTemplate&gt;</span><br><span class="line">&lt;/TreeView&gt;</span><br></pre></td></tr></table></figure>

<p>两层案例还有如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;TreeView Width=&quot;300&quot; ItemsSource=&quot;&#123;Binding LoopMastersManaget.LoopMasters&#125;&quot;&gt;</span><br><span class="line">    &lt;TreeView.Resources&gt;</span><br><span class="line">        &lt;!--  第一层模板：LoopMasterInfo  --&gt;</span><br><span class="line">        &lt;HierarchicalDataTemplate DataType=&quot;&#123;x:Type d:LoopMasterInfo&#125;&quot; ItemsSource=&quot;&#123;Binding DeviceInfos&#125;&quot;&gt;</span><br><span class="line">            &lt;TextBlock</span><br><span class="line">                Margin=&quot;8,0&quot;</span><br><span class="line">                FontWeight=&quot;Bold&quot;</span><br><span class="line">                Foreground=&quot;#333&quot;</span><br><span class="line">                Text=&quot;&#123;Binding Description&#125;&quot; /&gt;</span><br><span class="line">        &lt;/HierarchicalDataTemplate&gt;</span><br><span class="line">        &lt;!--  第二层模板：DeviceInfo  --&gt;</span><br><span class="line">        &lt;DataTemplate DataType=&quot;&#123;x:Type d:DeviceInfo&#125;&quot;&gt;</span><br><span class="line">            &lt;WrapPanel&gt;</span><br><span class="line">                &lt;TextBlock Text=&quot;&#123;Binding DeviceHeader.DeviceTypeStr&#125;&quot; /&gt;</span><br><span class="line">                &lt;TextBlock Text=&quot;&#123;Binding DeviceHeader.Description&#125;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">            &lt;/WrapPanel&gt;</span><br><span class="line">        &lt;/DataTemplate&gt;</span><br><span class="line">    &lt;/TreeView.Resources&gt;</span><br><span class="line">&lt;/TreeView&gt;</span><br></pre></td></tr></table></figure>

<h4 id="三层案例"><a href="#三层案例" class="headerlink" title="三层案例"></a>三层案例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;TreeView Height=&quot;100&quot; ItemsSource=&quot;&#123;Binding Classes&#125;&quot;&gt;</span><br><span class="line">    &lt;TreeView.ItemTemplate&gt;</span><br><span class="line">        &lt;HierarchicalDataTemplate ItemsSource=&quot;&#123;Binding Groups&#125;&quot;&gt;</span><br><span class="line">            &lt;!--  第一层：显示Class信息  --&gt;</span><br><span class="line">            &lt;TextBlock Text=&quot;&#123;Binding Groups.Count&#125;&quot; /&gt;</span><br><span class="line">            &lt;HierarchicalDataTemplate.ItemTemplate&gt;</span><br><span class="line">                &lt;HierarchicalDataTemplate DataType=&quot;&#123;x:Type vm:Group&#125;&quot; ItemsSource=&quot;&#123;Binding Students&#125;&quot;&gt;</span><br><span class="line">                    &lt;!--  第二层：显示Group信息  --&gt;</span><br><span class="line">                    &lt;TextBlock Text=&quot;&#123;Binding Students.Count&#125;&quot; /&gt;</span><br><span class="line">                    &lt;HierarchicalDataTemplate.ItemTemplate&gt;</span><br><span class="line">                        &lt;!--  第三层：显示Student信息  --&gt;</span><br><span class="line">                        &lt;DataTemplate DataType=&quot;&#123;x:Type vm:Student&#125;&quot;&gt;</span><br><span class="line">                            &lt;WrapPanel&gt;</span><br><span class="line">                                &lt;TextBlock Text=&quot;&#123;Binding Name&#125;&quot; /&gt;</span><br><span class="line">                            &lt;/WrapPanel&gt;</span><br><span class="line">                        &lt;/DataTemplate&gt;</span><br><span class="line">                    &lt;/HierarchicalDataTemplate.ItemTemplate&gt;</span><br><span class="line">                &lt;/HierarchicalDataTemplate&gt;</span><br><span class="line">            &lt;/HierarchicalDataTemplate.ItemTemplate&gt;</span><br><span class="line">        &lt;/HierarchicalDataTemplate&gt;</span><br><span class="line">    &lt;/TreeView.ItemTemplate&gt;</span><br><span class="line">&lt;/TreeView&gt;</span><br></pre></td></tr></table></figure>

<h3 id="自定义选择层级显示实现案例"><a href="#自定义选择层级显示实现案例" class="headerlink" title="自定义选择层级显示实现案例"></a>自定义选择层级显示实现案例</h3><p>只是将Classes中包含的所有的Group中的所有Student罗列出来,只显示Group和Student两级,但是要显示Classes中所有的Class内的这些两级关系</p>
<p>以下是实现方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;TreeView Height=&quot;100&quot; ItemsSource=&quot;&#123;Binding AllGroups&#125;&quot;&gt;</span><br><span class="line">    &lt;TreeView.ItemTemplate&gt;</span><br><span class="line">        &lt;HierarchicalDataTemplate DataType=&quot;&#123;x:Type vm:Group&#125;&quot; </span><br><span class="line">                                 ItemsSource=&quot;&#123;Binding Students&#125;&quot;&gt;</span><br><span class="line">            &lt;!-- 第一层：显示Group信息 --&gt;</span><br><span class="line">            &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt;</span><br><span class="line">                &lt;TextBlock Text=&quot;&#123;Binding GroupName&#125;&quot; /&gt;</span><br><span class="line">                &lt;TextBlock Text=&quot; (&quot; /&gt;</span><br><span class="line">                &lt;TextBlock Text=&quot;&#123;Binding Students.Count&#125;&quot; /&gt;</span><br><span class="line">                &lt;TextBlock Text=&quot; 个学生)&quot; /&gt;</span><br><span class="line">            &lt;/StackPanel&gt;</span><br><span class="line">            &lt;!-- 第二层：显示Student信息 --&gt;</span><br><span class="line">            &lt;HierarchicalDataTemplate.ItemTemplate&gt;</span><br><span class="line">                &lt;DataTemplate DataType=&quot;&#123;x:Type vm:Student&#125;&quot;&gt;</span><br><span class="line">                    &lt;TextBlock Text=&quot;&#123;Binding Name&#125;&quot; /&gt;</span><br><span class="line">                &lt;/DataTemplate&gt;</span><br><span class="line">            &lt;/HierarchicalDataTemplate.ItemTemplate&gt;</span><br><span class="line">        &lt;/HierarchicalDataTemplate&gt;</span><br><span class="line">    &lt;/TreeView.ItemTemplate&gt;</span><br><span class="line">&lt;/TreeView&gt;</span><br></pre></td></tr></table></figure>

<h3 id="样式模板"><a href="#样式模板" class="headerlink" title="样式模板"></a>样式模板</h3><p>其模板使用了两个固定的名称:</p>
<ul>
<li><code>ItemsHost</code>    用于ItemsPresenter的名字表示内一级</li>
<li><code>PART_Header</code>   用于ContentPresenter的名字表示上一级</li>
</ul>
<p>自定义TreeView</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&lt;TreeView Height=&quot;100&quot; ItemsSource=&quot;&#123;Binding Groups&#125;&quot;&gt;</span><br><span class="line">    &lt;TreeView.ItemTemplate&gt;</span><br><span class="line">        &lt;HierarchicalDataTemplate ItemsSource=&quot;&#123;Binding Students&#125;&quot;&gt;</span><br><span class="line">            &lt;!--  单个Group项目录显示的是其中学生的数量  --&gt;</span><br><span class="line">            &lt;TextBlock Text=&quot;&#123;Binding Students.Count&#125;&quot; /&gt;</span><br><span class="line">            &lt;!--  定义每个Group展开显示的模板  --&gt;</span><br><span class="line">            &lt;HierarchicalDataTemplate.ItemTemplate&gt;</span><br><span class="line">                &lt;DataTemplate DataType=&quot;&#123;x:Type vm:Student&#125;&quot;&gt;</span><br><span class="line">                    &lt;WrapPanel&gt;</span><br><span class="line">                        &lt;TextBlock Text=&quot;&#123;Binding Name&#125;&quot; /&gt;</span><br><span class="line">                        &lt;TextBlock Margin=&quot;5,0,0,0&quot; Text=&quot;&#123;Binding Age&#125;&quot; /&gt;</span><br><span class="line">                    &lt;/WrapPanel&gt;</span><br><span class="line">                &lt;/DataTemplate&gt;</span><br><span class="line">            &lt;/HierarchicalDataTemplate.ItemTemplate&gt;</span><br><span class="line">        &lt;/HierarchicalDataTemplate&gt;</span><br><span class="line">    &lt;/TreeView.ItemTemplate&gt;</span><br><span class="line">    &lt;!--  下面设定样式  --&gt;</span><br><span class="line">    &lt;TreeView.Resources&gt;</span><br><span class="line">        &lt;Style TargetType=&quot;&#123;x:Type TreeViewItem&#125;&quot;&gt;</span><br><span class="line">            &lt;Setter Property=&quot;IsExpanded&quot; Value=&quot;True&quot; /&gt;</span><br><span class="line">            &lt;Setter Property=&quot;Template&quot;&gt;</span><br><span class="line">                &lt;Setter.Value&gt;</span><br><span class="line">                    &lt;ControlTemplate TargetType=&quot;&#123;x:Type TreeViewItem&#125;&quot;&gt;</span><br><span class="line">                        &lt;Border</span><br><span class="line">                            x:Name=&quot;PART_Border&quot;</span><br><span class="line">                            HorizontalAlignment=&quot;&#123;TemplateBinding HorizontalAlignment&#125;&quot;</span><br><span class="line">                            VerticalAlignment=&quot;&#123;TemplateBinding VerticalAlignment&#125;&quot;</span><br><span class="line">                            Background=&quot;&#123;TemplateBinding Background&#125;&quot;&gt;</span><br><span class="line">                            &lt;!--  下面是放入内容的意思  --&gt;</span><br><span class="line">                            &lt;!--  TreeView的ItemSources绑定的是一个集合,有一个集合的迭代器一样,遍历的Item是什么类型呢?Item是一个上下文是你的成员ItemSources所对应迭代器具体对应的具体的实例值的TreeViewItem  --&gt;</span><br><span class="line">                            &lt;StackPanel&gt;</span><br><span class="line">                                &lt;!--  TemplateBinding IsEnabled不行,必须是双向绑定的  --&gt;</span><br><span class="line">                                &lt;CheckBox x:Name=&quot;PART_CheckBox&quot; IsChecked=&quot;&#123;Binding RelativeSource=&#123;RelativeSource Mode=TemplatedParent&#125;, Path=IsExpanded, Mode=TwoWay&#125;&quot; /&gt;</span><br><span class="line">                                &lt;ContentPresenter x:Name=&quot;PART_Header&quot; Content=&quot;&#123;TemplateBinding Header&#125;&quot; /&gt;</span><br><span class="line">                                &lt;!--  子节点的缩进关键是这个Margin  --&gt;</span><br><span class="line">                                &lt;ItemsPresenter</span><br><span class="line">                                    x:Name=&quot;ItemsHost&quot;</span><br><span class="line">                                    Margin=&quot;10,0,0,0&quot;</span><br><span class="line">                                    DataContext=&quot;&#123;TemplateBinding ItemsSource&#125;&quot;</span><br><span class="line">                                    Visibility=&quot;Collapsed&quot; /&gt;</span><br><span class="line">                            &lt;/StackPanel&gt;</span><br><span class="line">                        &lt;/Border&gt;</span><br><span class="line">                        &lt;!--  支持展开收缩是如下代码  --&gt;</span><br><span class="line">                        &lt;ControlTemplate.Triggers&gt;</span><br><span class="line">                            &lt;Trigger Property=&quot;IsExpanded&quot; Value=&quot;True&quot;&gt;</span><br><span class="line">                                &lt;Setter TargetName=&quot;ItemsHost&quot; Property=&quot;Visibility&quot; Value=&quot;Visible&quot; /&gt;</span><br><span class="line">                            &lt;/Trigger&gt;</span><br><span class="line">                            &lt;Trigger Property=&quot;IsExpanded&quot; Value=&quot;False&quot;&gt;</span><br><span class="line">                                &lt;Setter TargetName=&quot;ItemsHost&quot; Property=&quot;Visibility&quot; Value=&quot;Collapsed&quot; /&gt;</span><br><span class="line">                            &lt;/Trigger&gt;</span><br><span class="line">                        &lt;/ControlTemplate.Triggers&gt;</span><br><span class="line">                    &lt;/ControlTemplate&gt;</span><br><span class="line">                &lt;/Setter.Value&gt;</span><br><span class="line">            &lt;/Setter&gt;</span><br><span class="line">        &lt;/Style&gt;</span><br><span class="line">    &lt;/TreeView.Resources&gt;</span><br><span class="line">&lt;/TreeView&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>IsChecked=&quot;&#123;Binding RelativeSource=&#123;RelativeSource Mode=TemplatedParent&#125;, Path=IsExpanded, Mode=TwoWay&#125;&quot;</code></p>
<p><code>IsChecked=&quot;&#123;TemplateBinding IsExpanded&#125;&quot;</code></p>
<p>注意:上面二者的区别在于后者是单向绑定(因为TemplateBinding都是单向绑定)</p>
</blockquote>
<h3 id="TreeView中如何获取选中值"><a href="#TreeView中如何获取选中值" class="headerlink" title="TreeView中如何获取选中值"></a>TreeView中如何获取选中值</h3><p>对于ItemsControl控件我们通常可以去绑定SelectedItem来处理这个值</p>
<p>但由于TreeView存在父子结构,因此没法通过SelectedItem来处理值,因此在MVVM中获取TreeView选中的值就要使用到ICommand</p>
<h2 id="ScrollViewer"><a href="#ScrollViewer" class="headerlink" title="ScrollViewer"></a>ScrollViewer</h2><p>拥有属性 <code>VerticalScrollBarVisibility</code>用于控制滚动条的显示与隐藏</p>
<p>注意该控件如果置于StackPanel中会失去滚动条效果,如果本身被限制在border中,可以置于Grid</p>
<h2 id="Thumb"><a href="#Thumb" class="headerlink" title="Thumb"></a>Thumb</h2><p>他所在的命名空间是 <code>System.Windows.Controls.Primitives</code></p>
<p>表示可由用户拖动的控件,主要的三个事件分别是</p>
<ul>
<li>DragDelta—一当 Thumb 控件具有逻辑焦点和鼠标捕获时，随看鼠标位置更改发生一次或多次。拖的过程中不断触发的事件</li>
<li>DragStarted—一在 Thumb 控件接收逻辑焦点和鼠标捕获时发生。开始拖的事件</li>
<li>DragCompleted—一在 Thumb 控件失去鼠标捕获时发生。结束拖的事件</li>
</ul>
<p>Theumb和Drop拖动的区别就在于:后者没有拖动过程中的中间状态</p>
<h2 id="Popup"><a href="#Popup" class="headerlink" title="Popup"></a>Popup</h2><p>弹出窗口</p>
<p>使用IsOpen属性控制窗口是否弹出</p>
<p>常用属性</p>
<ul>
<li>AllowsTransparency 是否允许透明</li>
<li>PopupAnimation 出现动画<ul>
<li>Slide 上往下滑动 ,正是comboBox下拉的默认动画</li>
<li>Scroll 缩放</li>
</ul>
</li>
</ul>
<h3 id="自制Popup"><a href="#自制Popup" class="headerlink" title="自制Popup"></a>自制Popup</h3><p>添加更好的出现动画</p>
<p>添加自定义控件继承Popup</p>
<p>官方Popup所在为: <code>System.Windows.Controls.Primitives</code></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//弹性动画</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnOpened</span>(<span class="params">EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> newanimation = <span class="keyword">new</span> ThicknessAnimation(<span class="keyword">new</span> Thickness(<span class="number">10</span>),<span class="keyword">new</span> Thickness(<span class="number">0</span>),<span class="keyword">new</span> Duration(TimeSpan.FromMilliseconds(<span class="number">400</span>)));</span><br><span class="line">  newanimation.EasingFunction = <span class="keyword">new</span> ElasticEase();<span class="comment">//弹性</span></span><br><span class="line">  Child.BeginAnimation(MarginProperty,newanimation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Tooltip"><a href="#Tooltip" class="headerlink" title="Tooltip"></a>Tooltip</h2><p><code>Tooltip</code> 是一种用于显示附加信息的控件，当用户将鼠标悬停在某个控件上时，会弹出一个小窗口来显示这些信息</p>
<p>Tooltip是通过对Popup进行了一层小小的封装实现的</p>
<h2 id="ComboBox"><a href="#ComboBox" class="headerlink" title="ComboBox"></a>ComboBox</h2><p>基本使用方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ComboBox ItemsSource=&quot;&#123;Binding Students&#125;&quot; SelectedItem=&quot;&#123;Binding Students[0]&#125;&quot; /&gt;</span><br><span class="line">&lt;!--  也可以设置SelectedIndex为0,如下  --&gt;</span><br><span class="line">&lt;ComboBox ItemsSource=&quot;&#123;Binding Students&#125;&quot; SelectedIndex=&quot;0&quot; /&gt;</span><br></pre></td></tr></table></figure>

<h3 id="内部构成"><a href="#内部构成" class="headerlink" title="内部构成"></a>内部构成</h3><p>简述其构成:</p>
<ul>
<li>ToggleButton 触发下拉框打开关闭</li>
<li>Popup 作为下拉框的框体</li>
</ul>
<p>自定义子项模板样式:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;Style x:Key=&quot;ComboBoxItem&quot; TargetType=&quot;ComboBoxItem&quot;&gt;</span><br><span class="line">   &lt;Setter Property=&quot;Template&quot;&gt;</span><br><span class="line">       &lt;Setter.Value&gt;</span><br><span class="line">           &lt;ControlTemplate TargetType=&quot;ComboBoxItem&quot;&gt;</span><br><span class="line">               &lt;!--  展开的选项卡的背景色设置为灰色  --&gt;</span><br><span class="line">               &lt;Border x:Name=&quot;PART_Border&quot; Background=&quot;Gray&quot;&gt;</span><br><span class="line">                   &lt;ContentControl Content=&quot;&#123;TemplateBinding Content&#125;&quot; /&gt;</span><br><span class="line">               &lt;/Border&gt;</span><br><span class="line">               &lt;ControlTemplate.Triggers&gt;</span><br><span class="line">                   &lt;!--  设置鼠标悬浮颜色为橙色  --&gt;</span><br><span class="line">                   &lt;Trigger Property=&quot;IsMouseOver&quot; Value=&quot;True&quot;&gt;</span><br><span class="line">                       &lt;Setter TargetName=&quot;PART_Border&quot; Property=&quot;Background&quot; Value=&quot;Orange&quot; /&gt;</span><br><span class="line">                   &lt;/Trigger&gt;</span><br><span class="line">               &lt;/ControlTemplate.Triggers&gt;</span><br><span class="line">           &lt;/ControlTemplate&gt;</span><br><span class="line">       &lt;/Setter.Value&gt;</span><br><span class="line">   &lt;/Setter&gt;</span><br><span class="line">&lt;/Style&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--使用方式--&gt;</span><br><span class="line"> &lt;ComboBox</span><br><span class="line">     ItemContainerStyle=&quot;&#123;StaticResource ComboBoxItem&#125;&quot;</span><br><span class="line">     ItemsSource=&quot;&#123;Binding Students&#125;&quot;</span><br><span class="line">     SelectedIndex=&quot;0&quot; /&gt;</span><br></pre></td></tr></table></figure>

<h2 id="ItemsControl"><a href="#ItemsControl" class="headerlink" title="ItemsControl"></a>ItemsControl</h2><p>用于显示数据集合的wpf控件,用于简单的列表显示</p>
<p><a href="#BindingProxy">ItemsControl内部需要绑定ViewModel中的内容可以参考此处</a></p>
<h3 id="简单列表显示案例"><a href="#简单列表显示案例" class="headerlink" title="简单列表显示案例"></a>简单列表显示案例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;ItemsControl ItemsSource=&quot;&#123;Binding Value.iDiValue&#125;&quot;&gt;</span><br><span class="line">  &lt;!--ItemTemplate定义了如何显示每个数据项。在这里，每个数据项将使用DataTemplate中定义的模板进行显示。--&gt;</span><br><span class="line">    &lt;ItemsControl.ItemTemplate&gt;</span><br><span class="line">        &lt;DataTemplate&gt;</span><br><span class="line">            &lt;TextBlock Text=&quot;&#123;Binding&#125;&quot; Margin=&quot;20,0,0,0&quot;/&gt;</span><br><span class="line">        &lt;/DataTemplate&gt;</span><br><span class="line">    &lt;/ItemsControl.ItemTemplate&gt;</span><br><span class="line">&lt;/ItemsControl&gt;</span><br></pre></td></tr></table></figure>

<p>在使用ItemsControl的时候,先使用ItemsControl.ItemsPanel</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;ItemsControl ItemsSource=&quot;&#123;Binding Team.Students&#125;&quot;&gt;</span><br><span class="line">    &lt;ItemsControl.ItemsPanel&gt;</span><br><span class="line">        &lt;ItemsPanelTemplate&gt;</span><br><span class="line">            &lt;VirtualizingStackPanel Orientation=&quot;Vertical&quot;/&gt;</span><br><span class="line">        &lt;/ItemsPanelTemplate&gt;</span><br><span class="line">    &lt;/ItemsControl.ItemsPanel&gt;</span><br><span class="line">&lt;/ItemsControl&gt;</span><br></pre></td></tr></table></figure>

<p>一般来说如果只有一层,可以使用StackPanel,但是如果嵌套层级很复杂,就不要多个ItemsControl嵌套了,直接使用Treeview</p>
<blockquote>
<p><code>VirtualizingStackPanel</code> 是一个用于在垂直或水平方向上排列子元素的面板，它支持虚拟化。虚拟化的主要目的是提高性能，尤其是在处理大量数据时</p>
<p><strong>虚拟化</strong>：</p>
<ul>
<li>当使用 <code>VirtualizingStackPanel</code> 时，只有可见的元素会被创建和渲染。未在可视区域内的元素不会被创建，这样可以显著减少内存使用和提高性能。</li>
<li>当用户滚动视图时，面板会动态地创建和释放元素，以确保只有当前可见的元素在界面上。</li>
</ul>
</blockquote>
<p>如果要显示的是结构体中的各个成员,方式如下</p>
<h3 id="结构体中多成员显示含命令案例"><a href="#结构体中多成员显示含命令案例" class="headerlink" title="结构体中多成员显示含命令案例"></a>结构体中多成员显示含命令案例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;ItemsControl ItemsSource=&quot;&#123;Binding Students&#125;&quot;&gt;</span><br><span class="line">    &lt;!--  ItemsControl.ItemsPanel描述怎么组织子项  --&gt;</span><br><span class="line">    &lt;ItemsControl.ItemsPanel&gt;</span><br><span class="line">        &lt;ItemsPanelTemplate&gt;</span><br><span class="line">            &lt;VirtualizingStackPanel Orientation=&quot;Horizontal&quot;/&gt;</span><br><span class="line">            &lt;!--  也可以使用wrapPanel等  --&gt;</span><br><span class="line">        &lt;/ItemsPanelTemplate&gt;</span><br><span class="line">    &lt;/ItemsControl.ItemsPanel&gt;</span><br><span class="line">    &lt;!--  ItemsControl.ItemTemplate描述单个子项是怎么样的  --&gt;</span><br><span class="line">    &lt;ItemsControl.ItemTemplate&gt;</span><br><span class="line">        &lt;!-- 此处指明DataType,才有成员补全功能--&gt;</span><br><span class="line">        &lt;DataTemplate DataType=&quot;&#123;x:Type vm:Student&#125;&quot;&gt; </span><br><span class="line">            &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt;</span><br><span class="line">                &lt;TextBlock Foreground=&quot;red&quot;</span><br><span class="line">                        Text=&quot;&#123;Binding Age&#125;&quot;/&gt;</span><br><span class="line">                &lt;Rectangle Width=&quot;10&quot;</span><br><span class="line">                        Fill=&quot;Aqua&quot;/&gt;</span><br><span class="line">                &lt;TextBlock Foreground=&quot;Blue&quot;</span><br><span class="line">                        Text=&quot;&#123;Binding Name&#125;&quot;/&gt;</span><br><span class="line">                &lt;Rectangle Width=&quot;10&quot;</span><br><span class="line">                        Fill=&quot;Aqua&quot;/&gt;</span><br><span class="line">                &lt;TextBlock Foreground=&quot;Blue&quot;</span><br><span class="line">                        Text=&quot;&#123;Binding Height&#125;&quot;/&gt;</span><br><span class="line">                &lt;Rectangle Width=&quot;40&quot;</span><br><span class="line">                        Fill=&quot;Transparent&quot;/&gt;</span><br><span class="line">                &lt;Button Command=&quot;&#123;Binding TestClick&#125;&quot;</span><br><span class="line">                        CommandParameter=&quot;&#123;Binding&#125;&quot;&gt;点击测试&lt;/Button&gt;</span><br><span class="line">            &lt;/StackPanel&gt;</span><br><span class="line">        &lt;/DataTemplate&gt;</span><br><span class="line">    &lt;/ItemsControl.ItemTemplate&gt;</span><br><span class="line">&lt;/ItemsControl&gt;</span><br></pre></td></tr></table></figure>

<p> 一般都配合 <code>ScrollViewer</code>使用,意义在于数据超出显示窗体的时候可以滚动</p>
<h2 id="Menu"><a href="#Menu" class="headerlink" title="Menu"></a>Menu</h2><p>使用Menu控件作为菜单栏的容器，并在其中添加MenuItem控件作为菜单项</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;Menu VerticalAlignment=&quot;Top&quot; Background=&quot;LightGray&quot;&gt;</span><br><span class="line">    &lt;MenuItem Header=&quot;设置&quot;&gt;</span><br><span class="line">        &lt;MenuItem Command=&quot;&#123;Binding NewCommand&#125;&quot; Header=&quot;_New&quot; /&gt;</span><br><span class="line">        &lt;MenuItem Command=&quot;&#123;Binding OpenCommand&#125;&quot; Header=&quot;_Open&quot; /&gt;</span><br><span class="line">        &lt;MenuItem Command=&quot;&#123;Binding SaveCommand&#125;&quot; Header=&quot;_Save&quot; /&gt;</span><br><span class="line">        &lt;Separator /&gt;</span><br><span class="line">        &lt;MenuItem Command=&quot;&#123;Binding ExitCommand&#125;&quot; Header=&quot;E_xit&quot; /&gt;</span><br><span class="line">    &lt;/MenuItem&gt;</span><br><span class="line">    &lt;MenuItem Header=&quot;_Edit&quot;&gt;</span><br><span class="line">        &lt;MenuItem Command=&quot;&#123;Binding UndoCommand&#125;&quot; Header=&quot;_Undo&quot; /&gt;</span><br><span class="line">        &lt;MenuItem Command=&quot;&#123;Binding RedoCommand&#125;&quot; Header=&quot;_Redo&quot; /&gt;</span><br><span class="line">    &lt;/MenuItem&gt;</span><br><span class="line">    &lt;MenuItem Header=&quot;帮助&quot;&gt;</span><br><span class="line">        &lt;MenuItem Command=&quot;&#123;Binding AboutCommand&#125;&quot; Header=&quot;关于&quot; /&gt;</span><br><span class="line">    &lt;/MenuItem&gt;</span><br><span class="line">&lt;/Menu&gt;</span><br></pre></td></tr></table></figure>

<h2 id="ContentControl"><a href="#ContentControl" class="headerlink" title="ContentControl"></a>ContentControl</h2><p>使用 <code>ContentControl</code> 和 <code>DataTemplate</code> 可以通过模板轻松切换整个内容</p>
<p><a href="#%E4%BD%BF%E7%94%A8%E6%8C%89%E9%92%AE%E5%8A%A8%E6%80%81%E5%88%87%E6%8D%A2%E5%87%A0%E4%BD%95%E5%9B%BE%E5%BD%A2">使用按钮动态切换几何图形可以使用到ContentControl</a></p>
<p>比如说port是一个抽象基类DevicePort的对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ContentControl Content=&quot;&#123;Binding port&#125;&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>定义的模板如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;Window.Resources&gt;</span><br><span class="line">    &lt;!-- SwitchPort --&gt;</span><br><span class="line">    &lt;DataTemplate DataType=&quot;&#123;x:Type local:SwitchPort&#125;&quot;&gt;</span><br><span class="line">        &lt;StackPanel&gt;</span><br><span class="line">            &lt;TextBlock Text=&quot;Switch Port Properties&quot; FontWeight=&quot;Bold&quot;/&gt;</span><br><span class="line">            &lt;TextBlock Text=&quot;First Control:&quot;/&gt;</span><br><span class="line">            &lt;TextBox Text=&quot;&#123;Binding firstCtl, UpdateSourceTrigger=PropertyChanged&#125;&quot; /&gt;</span><br><span class="line">            &lt;TextBlock Text=&quot;Second Control:&quot;/&gt;</span><br><span class="line">            &lt;TextBox Text=&quot;&#123;Binding secondCtl, UpdateSourceTrigger=PropertyChanged&#125;&quot; /&gt;</span><br><span class="line">            &lt;TextBlock Text=&quot;First Feedback:&quot;/&gt;</span><br><span class="line">            &lt;TextBox Text=&quot;&#123;Binding firstFbk, UpdateSourceTrigger=PropertyChanged&#125;&quot; /&gt;</span><br><span class="line">            &lt;TextBlock Text=&quot;Second Feedback:&quot;/&gt;</span><br><span class="line">            &lt;TextBox Text=&quot;&#123;Binding secondFbk, UpdateSourceTrigger=PropertyChanged&#125;&quot; /&gt;</span><br><span class="line">        &lt;/StackPanel&gt;</span><br><span class="line">    &lt;/DataTemplate&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- AnalogMonitorPort --&gt;</span><br><span class="line">    &lt;DataTemplate DataType=&quot;&#123;x:Type local:AnalogMonitorPort&#125;&quot;&gt;</span><br><span class="line">        &lt;StackPanel&gt;</span><br><span class="line">            &lt;TextBlock Text=&quot;Analog Monitor Port&quot; FontWeight=&quot;Bold&quot;/&gt;</span><br><span class="line">            &lt;TextBlock Text=&quot;Port:&quot;/&gt;</span><br><span class="line">            &lt;TextBox Text=&quot;&#123;Binding port, UpdateSourceTrigger=PropertyChanged&#125;&quot; /&gt;</span><br><span class="line">        &lt;/StackPanel&gt;</span><br><span class="line">    &lt;/DataTemplate&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- ControllerPort --&gt;</span><br><span class="line">    &lt;DataTemplate DataType=&quot;&#123;x:Type local:ControllerPort&#125;&quot;&gt;</span><br><span class="line">        &lt;StackPanel&gt;</span><br><span class="line">            &lt;TextBlock Text=&quot;Controller Port&quot; FontWeight=&quot;Bold&quot;/&gt;</span><br><span class="line">            &lt;TextBlock Text=&quot;Control Set:&quot;/&gt;</span><br><span class="line">            &lt;TextBox Text=&quot;&#123;Binding controlSet, UpdateSourceTrigger=PropertyChanged&#125;&quot; /&gt;</span><br><span class="line">            &lt;TextBlock Text=&quot;Control Feedback:&quot;/&gt;</span><br><span class="line">            &lt;TextBox Text=&quot;&#123;Binding controlFdbk, UpdateSourceTrigger=PropertyChanged&#125;&quot; /&gt;</span><br><span class="line">        &lt;/StackPanel&gt;</span><br><span class="line">    &lt;/DataTemplate&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 其他 DevicePort 子类的 DataTemplate... --&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/Window.Resources&gt;</span><br></pre></td></tr></table></figure>



<p><strong>WPF 会根据 port 运行时的子类，自动选择 DataTemplate</strong></p>
<h2 id="ContextMenu"><a href="#ContextMenu" class="headerlink" title="ContextMenu"></a>ContextMenu</h2><p>在 WPF 中，上下文菜单 ContextMenu 是一个独立的视觉树，不会自动继承父元素的 DataContext</p>
<p>解决方案</p>
<ul>
<li>使用 PlacementTarget</li>
<li>使用 Tag 传递 DataContext</li>
</ul>
<p>以在TextBlock中添加为例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextBlock&gt;</span><br><span class="line">  &lt;TextBlock.ContextMenu&gt;</span><br><span class="line">    &lt;ContextMenu&gt;</span><br><span class="line">      &lt;MenuItem Header=&quot;菜单项1&quot;/&gt;</span><br><span class="line">      &lt;MenuItem Header=&quot;菜单项2&quot;/&gt;</span><br><span class="line">    &lt;/ContextMenu&gt;</span><br><span class="line">  &lt;/TextBlock.ContextMenu&gt;</span><br><span class="line">&lt;/TextBlock&gt;</span><br></pre></td></tr></table></figure>

<p>注意,如果要绑定内容的话,要使用<code>PlacementTarget</code>,参考如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;ListBox.ContextMenu&gt;</span><br><span class="line">    &lt;ContextMenu&gt;</span><br><span class="line">        &lt;MenuItem</span><br><span class="line">            Command=&quot;&#123;Binding PlacementTarget.DataContext.CopyCommand, RelativeSource=&#123;RelativeSource AncestorType=ContextMenu&#125;&#125;&quot;</span><br><span class="line">            CommandParameter=&quot;&#123;Binding PlacementTarget.SelectedItem, RelativeSource=&#123;RelativeSource AncestorType=ContextMenu&#125;&#125;&quot;</span><br><span class="line">            Header=&quot;复制&quot; /&gt;</span><br><span class="line">    &lt;/ContextMenu&gt;</span><br><span class="line">&lt;/ListBox.ContextMenu&gt;</span><br></pre></td></tr></table></figure>

<h3 id="PlacementTarget"><a href="#PlacementTarget" class="headerlink" title="PlacementTarget"></a>PlacementTarget</h3><blockquote>
<p><code>PlacementTarget</code>是连接<code>ContextMenu</code>与父级控件的桥梁，解决了数据上下文隔离和参数传递问题。通过灵活结合<code>RelativeSource</code>、<code>BindingProxy</code>及代码动态设置，可在MVVM模式下高效实现菜单交互逻辑</p>
</blockquote>
<p><code>PlacementTarget</code>是<code>ContextMenu</code>的一个依赖属性，类型为<code>UIElement</code>。它表示触发<code>ContextMenu</code>显示的父级控件（如<code>ListViewItem</code>、<code>Button</code>等）。通过该属性，可以定位到与菜单关联的UI元素</p>
<p>核心作用如下:</p>
<ul>
<li><strong>定位菜单位置</strong>：确定<code>ContextMenu</code>相对于哪个控件弹出（默认基于鼠标右键点击的控件）。</li>
<li><strong>数据上下文传递</strong>：由于<code>ContextMenu</code>独立于可视化树，无法直接继承父级控件的<code>DataContext</code>，而<code>PlacementTarget</code>提供了访问父级数据上下文的途径</li>
</ul>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><h4 id="绑定到父级控件的DataContext"><a href="#绑定到父级控件的DataContext" class="headerlink" title="绑定到父级控件的DataContext"></a>绑定到父级控件的DataContext</h4><p>由于<code>ContextMenu</code>默认无法继承父级控件的<code>DataContext</code>，导致无法直接绑定到ViewModel中的命令或属性</p>
<p>通过<code>PlacementTarget</code>访问父级控件的<code>DataContext</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ContextMenu DataContext=&quot;&#123;Binding PlacementTarget.DataContext, RelativeSource=&#123;RelativeSource Self&#125;&#125;&quot;&gt;</span><br><span class="line">    &lt;MenuItem Command=&quot;&#123;Binding DeleteCommand&#125;&quot; </span><br><span class="line">              CommandParameter=&quot;&#123;Binding PlacementTarget.SelectedItem, </span><br><span class="line">                                  RelativeSource=&#123;RelativeSource AncestorType=ContextMenu&#125;&#125;&quot; /&gt;</span><br><span class="line">&lt;/ContextMenu&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>DataContext</code>绑定到触发菜单的控件（如<code>ListViewItem</code>）的<code>DataContext</code>（即ViewModel）。</li>
<li><code>CommandParameter</code>通过<code>PlacementTarget.SelectedItem</code>获取当前选中项</li>
</ul>
<h3 id="BindingProxy"><a href="#BindingProxy" class="headerlink" title="BindingProxy"></a>BindingProxy</h3><p>注意,使用PlacementTarget只能往上找弹出元素的父级,因此可以利用父级控件的Tag存储ViewModel的Context,然后通过PlacementTarget来找到这个Tag来获得ViewModel的上下文</p>
<p><strong>解决跨视觉树绑定问题</strong></p>
<p><strong>BindingProxy的作用</strong>： 将窗口或用户控件的<code>DataContext</code>（即ViewModel）传递给<code>ContextMenu</code>，确保<code>Command</code>绑定到正确的对象</p>
<h4 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;UserControl.Resources&gt;</span><br><span class="line">    &lt;helper:BindingProxy x:Key=&quot;BindingProxy&quot; Data=&quot;&#123;Binding&#125;&quot; /&gt;</span><br><span class="line">    &lt;helper:BindingProxy x:Key=&quot;HardwareManagerProxy&quot; Data=&quot;&#123;Binding HardwareManager&#125;&quot; /&gt;</span><br><span class="line">  &lt;/UserControl.Resources&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--针对ContextMenu--&gt;</span><br><span class="line">&lt;Setter Property=&quot;ContextMenu&quot;&gt;</span><br><span class="line">    &lt;Setter.Value&gt;</span><br><span class="line">        &lt;ContextMenu DataContext=&quot;&#123;Binding Source=&#123;StaticResource BindingProxy&#125;, Path=Data&#125;&quot;&gt;</span><br><span class="line">            &lt;MenuItem Command=&quot;&#123;Binding DeleteVirtualDevice&#125;&quot; Header=&quot;删除&quot; /&gt;</span><br><span class="line">            &lt;Separator /&gt;</span><br><span class="line">        &lt;/ContextMenu&gt;</span><br><span class="line">    &lt;/Setter.Value&gt;</span><br><span class="line">&lt;/Setter&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--针对ItemsControl--&gt;</span><br><span class="line"> &lt;Label MinWidth=&quot;100&quot;&gt;</span><br><span class="line">     &lt;Label.Content&gt;</span><br><span class="line">         &lt;MultiBinding Converter=&quot;&#123;StaticResource LoopMasterValueByIndexConfigConverter&#125;&quot;&gt;</span><br><span class="line">             &lt;Binding Path=&quot;Data&quot; Source=&quot;&#123;StaticResource HardwareManagerProxy&#125;&quot; /&gt;&lt;!--这里!!!--&gt;</span><br><span class="line">             &lt;Binding Path=&quot;Config&quot; /&gt;</span><br><span class="line">         &lt;/MultiBinding&gt;</span><br><span class="line">     &lt;/Label.Content&gt;</span><br><span class="line"> &lt;/Label&gt;</span><br></pre></td></tr></table></figure>

<h2 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h2><p>本身不直接支持分级显示,但可以结合 <code>HierarchicalDataTemplate</code>和 <code>GroupStyle</code>可以在WPF中实现分级的列表视图</p>
<ul>
<li><code>ListView</code> 是 WPF 中用于显示列表数据的控件。它可以使用 <code>GridView</code> 来显示多列数据。</li>
<li><code>GridView</code> 允许您定义多个列，每列可以绑定到不同的数据字段。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;ListView Height=&quot;130&quot; Margin=&quot;5&quot;&gt;</span><br><span class="line">  &lt;ListView.View&gt;</span><br><span class="line">    &lt;!--使用GridView来设计--&gt;</span><br><span class="line">    &lt;GridView&gt;</span><br><span class="line">      &lt;!--定义多个表格列--&gt;</span><br><span class="line">      &lt;GridViewColumn Header=&quot;Id&quot; Width=&quot;40&quot; DisplayMemberBinding=&quot;&#123;Binding XPath=@Id&#125;&quot;/&gt;</span><br><span class="line">      &lt;GridViewColumn Header=&quot;Name&quot; Width=&quot;100&quot; DisplayMemberBinding=&quot;&#123;Binding XPath=Name&#125;&quot;/&gt;</span><br><span class="line">      &lt;GridViewColumn Header=&quot;Price&quot; Width=&quot;70&quot; DisplayMemberBinding=&quot;&#123;Binding XPath=Price&#125;&quot;/&gt;</span><br><span class="line">    &lt;/GridView&gt;</span><br><span class="line">  &lt;/ListView.View&gt;</span><br><span class="line">&lt;/ListView&gt;</span><br></pre></td></tr></table></figure>

<p><code>DisplayMemberBinding</code> 属性用于指定绑定到数据源中某个字段的路径。在这个例子中，使用了 <code>XPath</code> 语法来指定数据的路径。</p>
<h3 id="ListView中插入自增列案例"><a href="#ListView中插入自增列案例" class="headerlink" title="ListView中插入自增列案例"></a>ListView中插入自增列案例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;ListView</span><br><span class="line">    AlternationCount=&quot;&#123;Binding CurrentDeviceInfo.Di.Count&#125;&quot;</span><br><span class="line">    ItemsSource=&quot;&#123;Binding CurrentDeviceInfo.Di&#125;&quot;</span><br><span class="line">    ScrollViewer.VerticalScrollBarVisibility=&quot;Auto&quot;&gt;</span><br><span class="line">    &lt;ListView.View&gt;</span><br><span class="line">        &lt;GridView&gt;</span><br><span class="line">            &lt;!--  自增序号  --&gt;</span><br><span class="line">            &lt;GridViewColumn Header=&quot;序号&quot;&gt;</span><br><span class="line">              &lt;!--利用CellTemplate来自定义每一项内容--&gt;</span><br><span class="line">                &lt;GridViewColumn.CellTemplate&gt;</span><br><span class="line">                    &lt;DataTemplate&gt;</span><br><span class="line">                        &lt;TextBlock&gt;</span><br><span class="line">                            &lt;TextBlock.Text&gt;</span><br><span class="line">                              &lt;!--↓IndexConverter刚需--&gt;</span><br><span class="line">                                &lt;Binding</span><br><span class="line">                                    Converter=&quot;&#123;StaticResource IndexConverter&#125;&quot;</span><br><span class="line">                                    Path=&quot;.&quot;</span><br><span class="line">                                    RelativeSource=&quot;&#123;RelativeSource Mode=FindAncestor,</span><br><span class="line">                                                                    AncestorType=&#123;x:Type ListViewItem&#125;&#125;&quot;</span><br><span class="line">                                    StringFormat=&quot;Di&#123;0&#125;&quot; /&gt;</span><br><span class="line">                            &lt;/TextBlock.Text&gt;</span><br><span class="line">                        &lt;/TextBlock&gt;</span><br><span class="line">                    &lt;/DataTemplate&gt;</span><br><span class="line">                &lt;/GridViewColumn.CellTemplate&gt;</span><br><span class="line">            &lt;/GridViewColumn&gt;</span><br><span class="line"></span><br><span class="line">            &lt;!--  Value Column  --&gt;</span><br><span class="line">            &lt;GridViewColumn Header=&quot;状态&quot;&gt;</span><br><span class="line">                &lt;GridViewColumn.CellTemplate&gt;</span><br><span class="line">                    &lt;DataTemplate&gt;</span><br><span class="line">                        &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt;</span><br><span class="line">                            &lt;TextBlock Margin=&quot;4,0&quot; Text=&quot;&#123;Binding&#125;&quot; /&gt;</span><br><span class="line">                            &lt;Ellipse</span><br><span class="line">                                Width=&quot;8&quot;</span><br><span class="line">                                Height=&quot;8&quot;</span><br><span class="line">                                Margin=&quot;4,0&quot;</span><br><span class="line">                                Fill=&quot;&#123;Binding Converter=&#123;StaticResource Bool2Color&#125;&#125;&quot; /&gt;</span><br><span class="line">                        &lt;/StackPanel&gt;</span><br><span class="line">                    &lt;/DataTemplate&gt;</span><br><span class="line">                &lt;/GridViewColumn.CellTemplate&gt;</span><br><span class="line">            &lt;/GridViewColumn&gt;</span><br><span class="line">        &lt;/GridView&gt;</span><br><span class="line">    &lt;/ListView.View&gt;</span><br><span class="line">&lt;/ListView&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>索引生成的核心机制在于下面:</p>
<p><code>&lt;Binding Converter=&quot;&#123;StaticResource IndexConverter&#125;&quot;         Path=&quot;.&quot;         RelativeSource=&quot;&#123;RelativeSource Mode=FindAncestor, AncestorType=&#123;x:Type ListViewItem&#125;&#125;&quot;/&gt;</code></p>
<ul>
<li>通过<code>RelativeSource</code>定位到当前项的ListViewItem容器</li>
<li>使用自定义的<code>IndexConverter</code>转换器获取索引位置</li>
</ul>
</blockquote>
<p>IndexConverter转换器</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Diagnostics;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Windows;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Controls;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Controls.Primitives;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Communicator.Converter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">IndexConverter</span> : <span class="title">IValueConverter</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">Convert</span>(<span class="params"><span class="built_in">object</span> <span class="keyword">value</span>, Type targetType, <span class="built_in">object</span> parameter, System.Globalization.CultureInfo culture</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">value</span> <span class="keyword">is</span> ListViewItem listViewItem)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> listView = ItemsControl.ItemsControlFromItemContainer(listViewItem) <span class="keyword">as</span> ListView;</span><br><span class="line">                <span class="keyword">if</span> (listView != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 确保容器生成完成</span></span><br><span class="line">                    <span class="keyword">if</span> (listView.ItemContainerGenerator.Status == GeneratorStatus.ContainersGenerated)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">var</span> index = listView.ItemContainerGenerator.IndexFromContainer(listViewItem);</span><br><span class="line">                        <span class="comment">//Debug.WriteLine($&quot;Found index: &#123;index&#125;&quot;);</span></span><br><span class="line">                        <span class="keyword">return</span> index &gt;= <span class="number">0</span> ? <span class="string">$&quot;<span class="subst">&#123;index&#125;</span>&quot;</span> : <span class="string">&quot;&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">ConvertBack</span>(<span class="params"><span class="built_in">object</span> <span class="keyword">value</span>, Type targetType, <span class="built_in">object</span> parameter, System.Globalization.CultureInfo culture</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="TabControl"><a href="#TabControl" class="headerlink" title="TabControl"></a>TabControl</h2><p>通常用于在一个窗口中显示多个选项卡(Tab),选项卡中可以包含不同的内容,用户可以通过点击不同的选项卡来切换显示的内容.TabControl在许多应用程序中都很常见,特别是在需要组织大量信息或功能时,比如设置界面,文档管理等</p>
<p>组织形式如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;TabControl ItemsSource=&quot;&#123;Binding Students&#125;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--TabStripPlacement用于设置标签的排列位置,默认是Top--&gt;</span><br><span class="line">&lt;TabControl TabStripPlacement=&quot;Left&quot;&gt;</span><br><span class="line">    &lt;!--  Header定义选项卡的名称显示  --&gt;</span><br><span class="line">    &lt;TabItem DataContext=&quot;&#123;Binding Students[0]&#125;&quot; Header=&quot;&#123;Binding Name&#125;&quot;&gt;</span><br><span class="line">        &lt;!--  Content属性是个Object类型的,什么都可以填,用于表示选项卡中的内容是  --&gt;</span><br><span class="line">        &lt;ContentControl Content=&quot;&#123;Binding&#125;&quot; DataContext=&quot;&#123;Binding&#125;&quot; /&gt;</span><br><span class="line">    &lt;/TabItem&gt;</span><br><span class="line">    &lt;TabItem DataContext=&quot;&#123;Binding Students[1]&#125;&quot; Header=&quot;&#123;Binding Name&#125;&quot;&gt;</span><br><span class="line">        &lt;ContentControl Content=&quot;&#123;Binding&#125;&quot; DataContext=&quot;&#123;Binding&#125;&quot; /&gt;</span><br><span class="line">    &lt;/TabItem&gt;</span><br><span class="line">    &lt;TabItem DataContext=&quot;&#123;Binding Students[2]&#125;&quot; Header=&quot;&#123;Binding Name&#125;&quot;&gt;</span><br><span class="line">        &lt;ContentControl Content=&quot;&#123;Binding&#125;&quot; DataContext=&quot;&#123;Binding&#125;&quot; /&gt;</span><br><span class="line">    &lt;/TabItem&gt;</span><br><span class="line">&lt;/TabControl&gt;</span><br></pre></td></tr></table></figure>

<p>TabControl中,其模板中内含一个TabPanel,用于陈列标签;</p>
<h3 id="自定义子项模板如下"><a href="#自定义子项模板如下" class="headerlink" title="自定义子项模板如下"></a>自定义子项模板如下</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> &lt;Style x:Key=&quot;TabItem.NormalStyle&quot; TargetType=&quot;TabItem&quot;&gt;</span><br><span class="line">     &lt;Setter Property=&quot;Template&quot;&gt;</span><br><span class="line">         &lt;Setter.Value&gt;</span><br><span class="line">             &lt;ControlTemplate TargetType=&quot;TabItem&quot;&gt;</span><br><span class="line">                 &lt;Border</span><br><span class="line">                     x:Name=&quot;PART_Border&quot;</span><br><span class="line">                     Margin=&quot;10,0,0,0&quot;</span><br><span class="line">                     Background=&quot;Orange&quot;&gt;</span><br><span class="line">                     &lt;ContentControl Content=&quot;&#123;TemplateBinding Header&#125;&quot; /&gt;</span><br><span class="line">                 &lt;/Border&gt;</span><br><span class="line">                 &lt;ControlTemplate.Triggers&gt;</span><br><span class="line">                     &lt;!--  设置选中颜色为紫色  --&gt;</span><br><span class="line">                     &lt;!--  IsSelected也可以写成Selector.IsSelected  --&gt;</span><br><span class="line">                     &lt;Trigger Property=&quot;IsSelected&quot; Value=&quot;True&quot;&gt;</span><br><span class="line">                         &lt;Setter TargetName=&quot;PART_Border&quot; Property=&quot;Background&quot; Value=&quot;Purple&quot; /&gt;</span><br><span class="line">                     &lt;/Trigger&gt;</span><br><span class="line">                 &lt;/ControlTemplate.Triggers&gt;</span><br><span class="line">             &lt;/ControlTemplate&gt;</span><br><span class="line"></span><br><span class="line">         &lt;/Setter.Value&gt;</span><br><span class="line">     &lt;/Setter&gt;</span><br><span class="line"> &lt;/Style&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--使用上面的子项模板样式如下--&gt;</span><br><span class="line">&lt;ListBox ItemContainerStyle=&quot;&#123;StaticResource ListBoxItem.NormalStyle&#125;&quot; ItemsSource=&quot;&#123;Binding Students&#125;&quot; /&gt;</span><br></pre></td></tr></table></figure>

<h2 id="ListBox"><a href="#ListBox" class="headerlink" title="ListBox"></a>ListBox</h2><p>列表框</p>
<p>ListBox是一个Selector的ItemControls</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ListBox ItemsSource=&quot;&#123;Binding Students&#125;&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>自定义ListBox:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--此处定义的样式,在下方的ListBox中使用--&gt;</span><br><span class="line">&lt;Window.Resources&gt;</span><br><span class="line">    &lt;Style x:Key=&quot;ListBoxItem.NormalStyle&quot; TargetType=&quot;ListBoxItem&quot;&gt;</span><br><span class="line">        &lt;Setter Property=&quot;Template&quot;&gt;</span><br><span class="line">            &lt;Setter.Value&gt;</span><br><span class="line">                &lt;ControlTemplate&gt;</span><br><span class="line">                    &lt;Border</span><br><span class="line">                        x:Name=&quot;PART_Border&quot;</span><br><span class="line">                        Height=&quot;20&quot;</span><br><span class="line">                        Background=&quot;Aqua&quot;</span><br><span class="line">                        BorderBrush=&quot;Black&quot;</span><br><span class="line">                        BorderThickness=&quot;2&quot;&gt;</span><br><span class="line">                        &lt;!--  必须加这个才可以显示具体的内容  --&gt;</span><br><span class="line">                        &lt;ContentPresenter Content=&quot;&#123;TemplateBinding ContentControl.Content&#125;&quot; /&gt;</span><br><span class="line">                    &lt;/Border&gt;</span><br><span class="line">                    &lt;ControlTemplate.Triggers&gt;</span><br><span class="line">                        &lt;!--  通过选择器的属性设置选中变色  --&gt;</span><br><span class="line">                        &lt;Trigger Property=&quot;Selector.IsSelected&quot; Value=&quot;True&quot;&gt;</span><br><span class="line">                            &lt;Setter TargetName=&quot;PART_Border&quot; Property=&quot;Background&quot; Value=&quot;Pink&quot; /&gt;</span><br><span class="line">                        &lt;/Trigger&gt;</span><br><span class="line">                        &lt;!--  通过选择器的属性设置鼠标悬浮变色  --&gt;</span><br><span class="line">                        &lt;Trigger Property=&quot;IsMouseOver&quot; Value=&quot;True&quot;&gt;</span><br><span class="line">                            &lt;Setter TargetName=&quot;PART_Border&quot; Property=&quot;Background&quot; Value=&quot;Green&quot; /&gt;</span><br><span class="line">                        &lt;/Trigger&gt;</span><br><span class="line">                    &lt;/ControlTemplate.Triggers&gt;</span><br><span class="line">                &lt;/ControlTemplate&gt;</span><br><span class="line">            &lt;/Setter.Value&gt;</span><br><span class="line">        &lt;/Setter&gt;</span><br><span class="line">    &lt;/Style&gt;</span><br><span class="line">&lt;/Window.Resources&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--注意设置集合容器的模板样式,都是通过ItemContainerStyle属性--&gt;</span><br><span class="line">&lt;ListBox ItemContainerStyle=&quot;&#123;StaticResource ListBoxItem.NormalStyle&#125;&quot; ItemsSource=&quot;&#123;Binding Students&#125;&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>ListBox的ItemSource绑定的是 <code>ObservableCollection&lt;ObservableCollection&lt;byte&gt;&gt;</code>,那么每个 <code>ObservableCollection&lt;byte&gt;</code>使用下面的方式告诉他如何解析</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;ListBox</span><br><span class="line">    Grid.Row=&quot;1&quot;</span><br><span class="line">    Grid.Column=&quot;1&quot;</span><br><span class="line">    ItemsSource=&quot;&#123;Binding RecvHistories&#125;&quot;&gt;</span><br><span class="line">    &lt;ListBox.ItemTemplate&gt;</span><br><span class="line">        &lt;DataTemplate&gt;</span><br><span class="line">            &lt;TextBlock Text=&quot;&#123;Binding Converter=&#123;StaticResource ByteCollectionToStringConverter&#125;&#125;&quot;/&gt;</span><br><span class="line">        &lt;/DataTemplate&gt;</span><br><span class="line">    &lt;/ListBox.ItemTemplate&gt;</span><br><span class="line">&lt;/ListBox&gt;</span><br></pre></td></tr></table></figure>

<h2 id="ListView-1"><a href="#ListView-1" class="headerlink" title="ListView"></a>ListView</h2><p>用于显示列表项的控件</p>
<ul>
<li>是 <code>ListBox</code> 的一个扩展，提供更强大的功能。</li>
<li>支持多种视图（如详细视图、列表视图等），可以显示更复杂的数据结构。</li>
<li>允许使用数据模板和列定义，适合展示更丰富的信息。</li>
</ul>
<blockquote>
<p>使用场景而言,与ListBox的区别如下:</p>
<ul>
<li>如果你的需求只是简单的选择列表项，<code>ListBox</code> 是一个合适的选择。</li>
<li>如果你需要展示更复杂的数据，或者需要对数据进行更详细的控制和展示，<code>ListView</code> 更为合适。</li>
</ul>
</blockquote>
<h3 id="基本使用案例"><a href="#基本使用案例" class="headerlink" title="基本使用案例"></a>基本使用案例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;ListView ItemsSource=&quot;&#123;Binding Students&#125;&quot;&gt;</span><br><span class="line">   &lt;ListView.View&gt;</span><br><span class="line">       &lt;GridView&gt;</span><br><span class="line">           &lt;GridViewColumn</span><br><span class="line">               Width=&quot;120&quot;</span><br><span class="line">               DisplayMemberBinding=&quot;&#123;Binding Name&#125;&quot;</span><br><span class="line">               Header=&quot;Name&quot; /&gt;</span><br><span class="line">           &lt;GridViewColumn</span><br><span class="line">               Width=&quot;120&quot;</span><br><span class="line">               DisplayMemberBinding=&quot;&#123;Binding Height&#125;&quot;</span><br><span class="line">               Header=&quot;Hegiht&quot; /&gt;</span><br><span class="line">           &lt;GridViewColumn</span><br><span class="line">               Width=&quot;120&quot;</span><br><span class="line">               DisplayMemberBinding=&quot;&#123;Binding Age&#125;&quot;</span><br><span class="line">               Header=&quot;Age&quot; /&gt;</span><br><span class="line">       &lt;/GridView&gt;</span><br><span class="line">   &lt;/ListView.View&gt;</span><br><span class="line">&lt;/ListView&gt;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202412061702447.png" alt="image-20241206170211560"></p>
<h3 id="进阶用法案例"><a href="#进阶用法案例" class="headerlink" title="进阶用法案例"></a>进阶用法案例</h3><p>内含在ListView中获取下标的使用方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">&lt;ListView</span><br><span class="line">    Grid.Row=&quot;1&quot;</span><br><span class="line">    Grid.Column=&quot;1&quot;</span><br><span class="line">    AlternationCount=&quot;&#123;Binding CurrentDeviceInfo.Aout.Count&#125;&quot;</span><br><span class="line">    ItemsSource=&quot;&#123;Binding CurrentDeviceInfo.Aout&#125;&quot;</span><br><span class="line">    ScrollViewer.VerticalScrollBarVisibility=&quot;Auto&quot;&gt;</span><br><span class="line">    &lt;ListView.View&gt;</span><br><span class="line">        &lt;GridView&gt;</span><br><span class="line">            &lt;!--  Index Column  --&gt;</span><br><span class="line">            &lt;GridViewColumn Width=&quot;80&quot; Header=&quot;序号&quot;&gt;</span><br><span class="line">                &lt;GridViewColumn.CellTemplate&gt;</span><br><span class="line">                    &lt;DataTemplate&gt;</span><br><span class="line">                        &lt;TextBlock&gt;</span><br><span class="line">                            &lt;TextBlock.Text&gt;</span><br><span class="line">                                &lt;Binding</span><br><span class="line">                                    Converter=&quot;&#123;StaticResource IndexConverter&#125;&quot;</span><br><span class="line">                                    Path=&quot;.&quot;</span><br><span class="line">                                    RelativeSource=&quot;&#123;RelativeSource Mode=FindAncestor,</span><br><span class="line">                                                                    AncestorType=&#123;x:Type ListViewItem&#125;&#125;&quot;</span><br><span class="line">                                    StringFormat=&quot;AOUT&#123;0&#125;&quot; /&gt;</span><br><span class="line">                            &lt;/TextBlock.Text&gt;</span><br><span class="line">                        &lt;/TextBlock&gt;</span><br><span class="line">                    &lt;/DataTemplate&gt;</span><br><span class="line">                &lt;/GridViewColumn.CellTemplate&gt;</span><br><span class="line">            &lt;/GridViewColumn&gt;</span><br><span class="line"></span><br><span class="line">            &lt;!--  Value Column  --&gt;</span><br><span class="line">            &lt;GridViewColumn Header=&quot;十进制值&quot;&gt;</span><br><span class="line">                &lt;GridViewColumn.CellTemplate&gt;</span><br><span class="line">                    &lt;DataTemplate&gt;</span><br><span class="line">                        &lt;hc:NumericUpDown</span><br><span class="line">                            Width=&quot;80&quot;</span><br><span class="line">                            Maximum=&quot;65535&quot;</span><br><span class="line">                            Minimum=&quot;0&quot;</span><br><span class="line">                            Value=&quot;&#123;Binding Path=Value, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged&#125;&quot; /&gt;</span><br><span class="line">                    &lt;/DataTemplate&gt;</span><br><span class="line">                &lt;/GridViewColumn.CellTemplate&gt;</span><br><span class="line">            &lt;/GridViewColumn&gt;</span><br><span class="line">            &lt;GridViewColumn Header=&quot;十六进制值&quot;&gt;</span><br><span class="line">                &lt;GridViewColumn.CellTemplate&gt;</span><br><span class="line">                    &lt;DataTemplate&gt;</span><br><span class="line">                        &lt;TextBox Width=&quot;60&quot; Text=&quot;&#123;Binding Path=Value, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged, Converter=&#123;StaticResource HexBindingConverter&#125;&#125;&quot; /&gt;</span><br><span class="line">                    &lt;/DataTemplate&gt;</span><br><span class="line">                &lt;/GridViewColumn.CellTemplate&gt;</span><br><span class="line">            &lt;/GridViewColumn&gt;</span><br><span class="line"></span><br><span class="line">            &lt;!--  Description Column  --&gt;</span><br><span class="line">            &lt;GridViewColumn Width=&quot;160&quot; Header=&quot;描述&quot;&gt;</span><br><span class="line">                &lt;GridViewColumn.CellTemplate&gt;</span><br><span class="line">                    &lt;DataTemplate&gt;</span><br><span class="line">                        &lt;TextBlock&gt;</span><br><span class="line">                            &lt;TextBlock.Text&gt;</span><br><span class="line">                                &lt;MultiBinding Converter=&quot;&#123;StaticResource IndexAndListToDescriptionConverter&#125;&quot;&gt;</span><br><span class="line">                                    &lt;Binding</span><br><span class="line">                                        Converter=&quot;&#123;StaticResource IndexConverter&#125;&quot;</span><br><span class="line">                                        Path=&quot;.&quot;</span><br><span class="line">                                        RelativeSource=&quot;&#123;RelativeSource Mode=FindAncestor,</span><br><span class="line">                                                                        AncestorType=&#123;x:Type ListViewItem&#125;&#125;&quot; /&gt;</span><br><span class="line">                                    &lt;!--  AoutNameList 绑定  --&gt;</span><br><span class="line">                                    &lt;Binding Path=&quot;DataContext.CurrentDeviceInfo.DeviceHeader.Config.AoutNameList&quot; RelativeSource=&quot;&#123;RelativeSource AncestorType=Window&#125;&quot; /&gt;</span><br><span class="line">                                &lt;/MultiBinding&gt;</span><br><span class="line">                            &lt;/TextBlock.Text&gt;</span><br><span class="line">                        &lt;/TextBlock&gt;</span><br><span class="line">                    &lt;/DataTemplate&gt;</span><br><span class="line">                &lt;/GridViewColumn.CellTemplate&gt;</span><br><span class="line">            &lt;/GridViewColumn&gt;</span><br><span class="line"></span><br><span class="line">            &lt;!--  动作列  --&gt;</span><br><span class="line">            &lt;GridViewColumn Header=&quot;动作&quot;&gt;</span><br><span class="line">                &lt;GridViewColumn.CellTemplate&gt;</span><br><span class="line">                    &lt;DataTemplate&gt;</span><br><span class="line">                        &lt;UniformGrid Columns=&quot;2&quot; Rows=&quot;1&quot;&gt;</span><br><span class="line">                            &lt;Button</span><br><span class="line">                                Command=&quot;&#123;Binding DataContext.SetAoutValue, RelativeSource=&#123;RelativeSource AncestorType=Window&#125;&#125;&quot;</span><br><span class="line">                                CommandParameter=&quot;&#123;Binding Path=., RelativeSource=&#123;RelativeSource AncestorType=ListViewItem&#125;, Converter=&#123;StaticResource IndexConverter&#125;&#125;&quot;</span><br><span class="line">                                Content=&quot;设置值&quot; /&gt;</span><br><span class="line">                        &lt;/UniformGrid&gt;</span><br><span class="line"></span><br><span class="line">                    &lt;/DataTemplate&gt;</span><br><span class="line">                &lt;/GridViewColumn.CellTemplate&gt;</span><br><span class="line">            &lt;/GridViewColumn&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/GridView&gt;</span><br><span class="line">    &lt;/ListView.View&gt;</span><br><span class="line">&lt;/ListView&gt;</span><br></pre></td></tr></table></figure>

<h2 id="CheckBox"><a href="#CheckBox" class="headerlink" title="CheckBox"></a>CheckBox</h2><h3 id="自定义CheckBox"><a href="#自定义CheckBox" class="headerlink" title="自定义CheckBox"></a>自定义CheckBox</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;CheckBox Content=&quot;hello world&quot;&gt;</span><br><span class="line">     &lt;CheckBox.Template&gt;</span><br><span class="line">         &lt;ControlTemplate TargetType=&quot;CheckBox&quot;&gt;</span><br><span class="line">             &lt;Grid&gt;</span><br><span class="line">                 &lt;Grid.ColumnDefinitions&gt;</span><br><span class="line">                     &lt;ColumnDefinition Width=&quot;100&quot; /&gt;</span><br><span class="line">                     &lt;ColumnDefinition Width=&quot;100&quot; /&gt;</span><br><span class="line">                 &lt;/Grid.ColumnDefinitions&gt;</span><br><span class="line">                 &lt;!--  框体  --&gt;</span><br><span class="line">                 &lt;Border Background=&quot;Transparent&quot;&gt;</span><br><span class="line">                     &lt;Rectangle x:Name=&quot;RectMark&quot; Fill=&quot;Red&quot; /&gt;</span><br><span class="line">                 &lt;/Border&gt;</span><br><span class="line">                 &lt;!--  文字部分  --&gt;</span><br><span class="line">                 &lt;ContentPresenter Grid.Column=&quot;1&quot; Content=&quot;&#123;TemplateBinding Content&#125;&quot; /&gt;</span><br><span class="line">             &lt;/Grid&gt;</span><br><span class="line">             &lt;ControlTemplate.Triggers&gt;</span><br><span class="line">                 &lt;Trigger Property=&quot;IsChecked&quot; Value=&quot;True&quot;&gt;</span><br><span class="line">                     &lt;Setter TargetName=&quot;RectMark&quot; Property=&quot;Visibility&quot; Value=&quot;Visible&quot; /&gt;</span><br><span class="line">                 &lt;/Trigger&gt;</span><br><span class="line">                 &lt;Trigger Property=&quot;IsChecked&quot; Value=&quot;False&quot;&gt;</span><br><span class="line">                     &lt;Setter TargetName=&quot;RectMark&quot; Property=&quot;Visibility&quot; Value=&quot;Hidden&quot; /&gt;</span><br><span class="line">                 &lt;/Trigger&gt;</span><br><span class="line">             &lt;/ControlTemplate.Triggers&gt;</span><br><span class="line">         &lt;/ControlTemplate&gt;</span><br><span class="line">     &lt;/CheckBox.Template&gt;</span><br><span class="line"></span><br><span class="line"> &lt;/CheckBox&gt;</span><br></pre></td></tr></table></figure>

<p>这里写的版本是很简陋的,主要是体现CheckBox的点击切换效果</p>
<h2 id="HierarchicalDataTemplate"><a href="#HierarchicalDataTemplate" class="headerlink" title="HierarchicalDataTemplate"></a>HierarchicalDataTemplate</h2><p>HierarchicalDataTemplate是能够帮助层级控件显示层级数据的模板，一般多用于MenuItem和TreeViewItem，也可自己实现层级数据结构。</p>
<p>层级结构——它是能描述层次关系的结构，即有上下级关系</p>
<p>参考<a href="#TreeView">TreeView</a></p>
<h2 id="TextBlock"><a href="#TextBlock" class="headerlink" title="TextBlock"></a>TextBlock</h2><p>文本块标签:用于显示文本</p>
<h3 id="run标签"><a href="#run标签" class="headerlink" title="run标签"></a>run标签</h3><p>其中允许run标签:</p>
<blockquote>
<p><code>Run</code> 标签是一个用于在文本块中显示文本的内联元素。<code>Run</code> 标签不能单独使用，它必须嵌套在其他文本相关的容器内，例如 <code>TextBlock</code>、<code>RichTextBox</code> 或 <code>FlowDocument</code> 等</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextBlock Width=&quot;120&quot;&gt;</span><br><span class="line">&lt;Run Text=&quot;再生状态：&quot;/&gt;</span><br><span class="line">&lt;Run Text=&quot;&#123;Binding HardwareManager.BokePumpController.Pump1.RegenerateStatus&#125;&quot;/&gt;</span><br><span class="line">&lt;/TextBlock&gt;</span><br></pre></td></tr></table></figure>

<p>如果想添加带边框的文本,可以使用label控件</p>
<h2 id="label"><a href="#label" class="headerlink" title="label"></a>label</h2><p>可以带边框的文本控件</p>
<p>其可以直接设置BorderBrush和BorderThickness属性,也可以额设置Padding属性(内边距)</p>
<h2 id="TextBox"><a href="#TextBox" class="headerlink" title="TextBox"></a>TextBox</h2><p>textbox可以使用下面的语法监听键盘事件:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextBox Width=<span class="string">&quot;60&quot;</span></span><br><span class="line">         Text=<span class="string">&quot;&#123;Binding Path=Value, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged, Converter=&#123;StaticResource HexBindingConverter&#125;&#125;&quot;</span>&gt;</span><br><span class="line">    &lt;TextBox.InputBindings&gt;</span><br><span class="line">        &lt;KeyBinding Command=<span class="string">&quot;&#123;Binding ConfirmCommand&#125;&quot;</span> Gesture=<span class="string">&quot;Ctrl+Enter&quot;</span> /&gt;</span><br><span class="line">  				&lt;MouseBinding Command=<span class="string">&quot;&#123;Binding ClickCommand&#125;&quot;</span> Gesture=<span class="string">&quot;LeftClick&quot;</span> /&gt;</span><br><span class="line">    &lt;/TextBox.InputBindings&gt;</span><br><span class="line">&lt;/TextBox&gt;</span><br></pre></td></tr></table></figure>

<p>InputBindings 是一种优雅的方式，将用户输入和命令绑定解耦，使得代码结构更清晰，更易于维护，特别适用于 MVVM 模式</p>
<p>只会作用于当前拥有焦点的控件。</p>
<h3 id="自定义TextBox"><a href="#自定义TextBox" class="headerlink" title="自定义TextBox"></a>自定义TextBox</h3><p>微软用到的特殊的模板名字叫 PART_ContentHost</p>
<p>只有Decorator或ScrollViewer元素可以用作 <code>PART_ContentHost</code>,只要起名为这个就可以输入</p>
<p>在绘制的代码中,会找到名为这个的控件</p>
<p>手写一份TextBox</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">TextBox</span> <span class="attr">SelectionBrush</span>=<span class="string">&quot;Orange&quot;</span> <span class="attr">Width</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">TextBox.Template</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">ControlTemplate</span> <span class="attr">TargetType</span>=<span class="string">&quot;TextBox&quot;</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">Grid</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">Grid.RowDefinitions</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;<span class="name">RowDefinition</span> <span class="attr">Height</span>=<span class="string">&quot;Auto&quot;</span> /&gt;</span></span><br><span class="line">                     <span class="tag">&lt;<span class="name">RowDefinition</span> <span class="attr">Height</span>=<span class="string">&quot;Auto&quot;</span> /&gt;</span></span><br><span class="line">                 <span class="tag">&lt;/<span class="name">Grid.RowDefinitions</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">Decorator</span> <span class="attr">x:Name</span>=<span class="string">&quot;PART_ContentHost&quot;</span>/&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">Rectangle</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">Grid.Row</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">Height</span>=<span class="string">&quot;2&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">HorizontalAlignment</span>=<span class="string">&quot;Stretch&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">VerticalAlignment</span>=<span class="string">&quot;Bottom&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">Fill</span>=<span class="string">&quot;&#123;Binding SelectionBrush, RelativeSource=&#123;RelativeSource TemplatedParent&#125;&#125;&quot;</span> /&gt;</span></span><br><span class="line">                               <span class="comment">&lt;!--👆🏻此Fill跟随SelectionBrush的变化而变化--&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">Grid</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">ControlTemplate</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">TextBox.Template</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">TextBox</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--可将模板拆解到样式中如下--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Window.Resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Style</span> <span class="attr">x:Key</span>=<span class="string">&quot;WPFTest.TextBox.NormalStyle&quot;</span> <span class="attr">TargetType</span>=<span class="string">&quot;TextBox&quot;</span>&gt;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Setter</span> <span class="attr">Property</span>=<span class="string">&quot;SelectionBrush&quot;</span> <span class="attr">Value</span>=<span class="string">&quot;Orange&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Setter</span> <span class="attr">Property</span>=<span class="string">&quot;Template&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Setter.Value</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="comment">&lt;!--此处再次写TargetType=&quot;TextBox&quot;的原因是为了让底下如果存在的TemplateBinding或Trigger的属性可以找到TextBox的字段(但是Trigger有点bug,不会智能提示)--&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">ControlTemplate</span> <span class="attr">TargetType</span>=<span class="string">&quot;TextBox&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">Grid</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">Grid.RowDefinitions</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                            <span class="tag">&lt;<span class="name">RowDefinition</span> <span class="attr">Height</span>=<span class="string">&quot;Auto&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">                            <span class="tag">&lt;<span class="name">RowDefinition</span> <span class="attr">Height</span>=<span class="string">&quot;Auto&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;/<span class="name">Grid.RowDefinitions</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">Decorator</span> <span class="attr">x:Name</span>=<span class="string">&quot;PART_ContentHost&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">Rectangle</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                            <span class="attr">Grid.Row</span>=<span class="string">&quot;1&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                            <span class="attr">Height</span>=<span class="string">&quot;2&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                            <span class="attr">HorizontalAlignment</span>=<span class="string">&quot;Stretch&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                            <span class="attr">VerticalAlignment</span>=<span class="string">&quot;Bottom&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                            <span class="attr">Fill</span>=<span class="string">&quot;&#123;Binding SelectionBrush, RelativeSource=&#123;RelativeSource TemplatedParent&#125;&#125;&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">                                  <span class="comment">&lt;!--👆🏻此Fill跟随SelectionBrush的变化而变化--&gt;</span></span></span><br><span class="line"><span class="language-xml">                                  <span class="comment">&lt;!--上方的ControlTemplate如果写了TargetType,使用TemplateBinding才能找到对应的属性:Fill=&quot;&#123;TemplateBinding SelectionBrush&#125;&quot;--&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;/<span class="name">Grid</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">ControlTemplate</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">Setter.Value</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Setter</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    </span><span class="tag">&lt;/<span class="name">Style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Window.Resources</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">TextBox</span> <span class="attr">Style</span>=<span class="string">&quot;&#123;StaticResource WPFTest.TextBox.NormalStyle&#125;&quot;</span> <span class="attr">Width</span>=<span class="string">&quot;100&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>继续完善(输入文本超出界限并未处理)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;Window.Resources&gt;</span><br><span class="line">    &lt;Style x:Key=&quot;WPFTest.TextBox.NormalStyle&quot; TargetType=&quot;TextBox&quot;&gt;</span><br><span class="line">        &lt;Setter Property=&quot;SelectionBrush&quot; Value=&quot;Orange&quot; /&gt;</span><br><span class="line">        &lt;Setter Property=&quot;Template&quot;&gt;</span><br><span class="line">            &lt;Setter.Value&gt;</span><br><span class="line">                &lt;ControlTemplate TargetType=&quot;TextBox&quot;&gt;</span><br><span class="line">                    &lt;Border</span><br><span class="line">                        x:Name=&quot;PART_Border&quot;</span><br><span class="line">                        BorderBrush=&quot;&#123;TemplateBinding SelectionBrush&#125;&quot;</span><br><span class="line">                        BorderThickness=&quot;1&quot;</span><br><span class="line">                        CornerRadius=&quot;5&quot;&gt;</span><br><span class="line">                        &lt;Grid&gt;</span><br><span class="line">                            &lt;Grid.RowDefinitions&gt;</span><br><span class="line">                                &lt;RowDefinition Height=&quot;Auto&quot; /&gt;</span><br><span class="line">                                &lt;RowDefinition Height=&quot;Auto&quot; /&gt;</span><br><span class="line">                            &lt;/Grid.RowDefinitions&gt;</span><br><span class="line">                            &lt;Decorator x:Name=&quot;PART_ContentHost&quot; /&gt;</span><br><span class="line">                            &lt;Rectangle</span><br><span class="line">                                x:Name=&quot;PART_Rectangle&quot;</span><br><span class="line">                                Grid.Row=&quot;1&quot;</span><br><span class="line">                                Height=&quot;2&quot;</span><br><span class="line">                                Margin=&quot;0&quot;</span><br><span class="line">                                HorizontalAlignment=&quot;Stretch&quot;</span><br><span class="line">                                VerticalAlignment=&quot;Bottom&quot;</span><br><span class="line">                                Fill=&quot;&#123;TemplateBinding SelectionBrush&#125;&quot; /&gt;</span><br><span class="line">                        &lt;/Grid&gt;</span><br><span class="line">                    &lt;/Border&gt;</span><br><span class="line">                    &lt;ControlTemplate.Triggers&gt;</span><br><span class="line">                        &lt;Trigger Property=&quot;IsFocused&quot; Value=&quot;True&quot;&gt;</span><br><span class="line">                            &lt;Trigger.Setters&gt;</span><br><span class="line">                                &lt;Setter TargetName=&quot;PART_Rectangle&quot; Property=&quot;Margin&quot; Value=&quot;2&quot; /&gt;</span><br><span class="line">                                &lt;Setter TargetName=&quot;PART_Border&quot; Property=&quot;BorderThickness&quot; Value=&quot;2&quot; /&gt;</span><br><span class="line">                            &lt;/Trigger.Setters&gt;</span><br><span class="line">                        &lt;/Trigger&gt;</span><br><span class="line">                    &lt;/ControlTemplate.Triggers&gt;</span><br><span class="line">                &lt;/ControlTemplate&gt;</span><br><span class="line">            &lt;/Setter.Value&gt;</span><br><span class="line">        &lt;/Setter&gt;</span><br><span class="line">    &lt;/Style&gt;</span><br><span class="line">&lt;/Window.Resources&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Button"><a href="#Button" class="headerlink" title="Button"></a>Button</h2><h3 id="自定义Button"><a href="#自定义Button" class="headerlink" title="自定义Button"></a>自定义Button</h3><p><a target="_blank" rel="noopener" href="https://referencesource.microsoft.com/#PresentationFramework/src/Framework/System/Windows/Controls/Primitives/ButtonBase.cs">可以参考官方Button的源码</a></p>
<p>将会发现Button中的Click其实就是通过OnMouseLeftButtonUp和OnMouseLeftButtonDown实现的一个事件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> &lt;Window.Resources&gt;</span><br><span class="line">        &lt;Style x:Key=&quot;NormalStyleForButton&quot; TargetType=&quot;Button&quot;&gt;</span><br><span class="line">                &lt;Setter Property=&quot;Background&quot; Value=&quot;White&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">                &lt;Setter Property=&quot;BorderBrush&quot; Value=&quot;Orange&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">                &lt;Setter Property=&quot;BorderThickness&quot; Value=&quot;5&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">                &lt;Setter Property=&quot;Template&quot;&gt;</span><br><span class="line">                        &lt;Setter.Value&gt;</span><br><span class="line">                                &lt;ControlTemplate TargetType=&quot;Button&quot;&gt;</span><br><span class="line">                                        &lt;Border x:Name=&quot;PART_Border&quot;</span><br><span class="line">                                                Margin=&quot;0&quot;</span><br><span class="line">                                                Background=&quot;&#123;TemplateBinding Background&#125;&quot;</span><br><span class="line">                                                BorderBrush=&quot;&#123;TemplateBinding BorderBrush&#125;&quot;</span><br><span class="line">                                                BorderThickness=&quot;&#123;TemplateBinding BorderThickness&#125;&quot;</span><br><span class="line">                                                CornerRadius=&quot;&#123;TemplateBinding CornerRadius&#125;&quot;&gt;  &lt;!--此处由于外边控件实际上没有CornerRadius属性,因此需要自己提供一个依赖属性封装一个新的控件就可以在外界设置这个属性了--&gt;</span><br><span class="line">                                                &lt;ContentPresenter</span><br><span class="line">                                                        HorizontalAlignment=&quot;&#123;TemplateBinding HorizontalContentAlignment&#125;&quot;</span><br><span class="line">                                                        VerticalAlignment=&quot;&#123;TemplateBinding VerticalContentAlignment&#125;&quot;</span><br><span class="line">                                                        Content=&quot;&#123;TemplateBinding Content&#125;&quot;</span><br><span class="line">                                                        TextElement.FontFamily=&quot;&#123;TemplateBinding FontFamily&#125;&quot;</span><br><span class="line">                                                        TextElement.FontSize=&quot;&#123;TemplateBinding  FontSize&#125;&quot;</span><br><span class="line">                                                        TextElement.Foreground=&quot;&#123;TemplateBinding Foreground&#125;&quot;</span><br><span class="line">                                                /&gt;</span><br><span class="line">                                        &lt;/Border&gt;</span><br><span class="line">                                &lt;/ControlTemplate&gt;</span><br><span class="line">                        &lt;/Setter.Value&gt;</span><br><span class="line">                &lt;/Setter&gt;</span><br><span class="line">        &lt;/Style&gt;</span><br><span class="line">&lt;/Window.Resources&gt;</span><br><span class="line">&lt;Button Margin=&quot;30&quot; Content=&quot;Click Me&quot; Style=&quot;&#123;StaticResource NormalStyleForButton&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h2 id="ToggleButton"><a href="#ToggleButton" class="headerlink" title="ToggleButton"></a>ToggleButton</h2><h3 id="自定义ToggleButton"><a href="#自定义ToggleButton" class="headerlink" title="自定义ToggleButton"></a>自定义ToggleButton</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;ToggleButton</span><br><span class="line">    Width=&quot;400&quot;</span><br><span class="line">    Height=&quot;200&quot;</span><br><span class="line">    Content=&quot;hello&quot;&gt;</span><br><span class="line">    &lt;ToggleButton.Template&gt;</span><br><span class="line">        &lt;ControlTemplate TargetType=&quot;ToggleButton&quot;&gt;</span><br><span class="line">            &lt;Border</span><br><span class="line">                BorderBrush=&quot;Black&quot;</span><br><span class="line">                BorderThickness=&quot;1&quot;</span><br><span class="line">                CornerRadius=&quot;100&quot;&gt;</span><br><span class="line">                &lt;Grid&gt;</span><br><span class="line">                    &lt;Grid.ColumnDefinitions&gt;</span><br><span class="line">                        &lt;ColumnDefinition /&gt;</span><br><span class="line">                        &lt;ColumnDefinition /&gt;</span><br><span class="line">                    &lt;/Grid.ColumnDefinitions&gt;</span><br><span class="line">                    &lt;Ellipse</span><br><span class="line">                        x:Name=&quot;InnerShape&quot;</span><br><span class="line">                        Width=&quot;150&quot;</span><br><span class="line">                        Height=&quot;150&quot;</span><br><span class="line">                        Fill=&quot;Black&quot; /&gt;</span><br><span class="line">                &lt;/Grid&gt;</span><br><span class="line">            &lt;/Border&gt;</span><br><span class="line">            &lt;ControlTemplate.Triggers&gt;</span><br><span class="line">                &lt;Trigger Property=&quot;IsChecked&quot; Value=&quot;true&quot;&gt;</span><br><span class="line">                    &lt;Setter TargetName=&quot;InnerShape&quot; Property=&quot;Grid.Column&quot; Value=&quot;0&quot; /&gt;</span><br><span class="line">                &lt;/Trigger&gt;</span><br><span class="line">                &lt;Trigger Property=&quot;IsChecked&quot; Value=&quot;false&quot;&gt;</span><br><span class="line">                    &lt;Setter TargetName=&quot;InnerShape&quot; Property=&quot;Grid.Column&quot; Value=&quot;1&quot; /&gt;</span><br><span class="line">                &lt;/Trigger&gt;</span><br><span class="line">            &lt;/ControlTemplate.Triggers&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/ControlTemplate&gt;</span><br><span class="line">    &lt;/ToggleButton.Template&gt;</span><br><span class="line"></span><br><span class="line">&lt;/ToggleButton&gt;</span><br></pre></td></tr></table></figure>

<p>同样需要做精修,主要是体现实现原理</p>
<h2 id="RichTextBox"><a href="#RichTextBox" class="headerlink" title="RichTextBox"></a>RichTextBox</h2><p>一个可支持显示或编辑丰富内容（包括段落、超链接和内联图像）的控件</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/kangweijian/article/details/120404664">两个RichTextBox同步滚动</a></p>
<p>如果是写在xaml.cs文件中,只需要:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Windows;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Controls;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Media;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">searchTest.Views</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Interaction logic for MainWindow.xaml</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">MainWindow</span> : <span class="title">Window</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MainWindow</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">            Loaded += MainWindow_Loaded;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">MainWindow_Loaded</span>(<span class="params"><span class="built_in">object</span> sender, RoutedEventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> richTextBox = FindName(<span class="string">&quot;richTextBox&quot;</span>) <span class="keyword">as</span> RichTextBox;</span><br><span class="line">            <span class="keyword">var</span> richTextBoxSearch = FindName(<span class="string">&quot;richTextBoxSearch&quot;</span>) <span class="keyword">as</span> RichTextBox;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (richTextBox != <span class="literal">null</span> &amp;&amp; richTextBoxSearch != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> richTextBoxScrollViewer = GetScrollViewer(richTextBox);</span><br><span class="line">                <span class="keyword">var</span> richTextBoxSearchScrollViewer = GetScrollViewer(richTextBoxSearch);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (richTextBoxScrollViewer != <span class="literal">null</span> &amp;&amp; richTextBoxSearchScrollViewer != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    richTextBoxScrollViewer.ScrollChanged += (s, ev) =&gt; SyncScroll(richTextBoxScrollViewer, richTextBoxSearchScrollViewer);</span><br><span class="line">                    richTextBoxSearchScrollViewer.ScrollChanged += (s, ev) =&gt; SyncScroll(richTextBoxSearchScrollViewer, richTextBoxScrollViewer);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SyncScroll</span>(<span class="params">ScrollViewer source, ScrollViewer target</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            target.ScrollToVerticalOffset(source.VerticalOffset);</span><br><span class="line">            target.ScrollToHorizontalOffset(source.HorizontalOffset);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> ScrollViewer <span class="title">GetScrollViewer</span>(<span class="params">DependencyObject dep</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dep <span class="keyword">is</span> ScrollViewer) <span class="keyword">return</span> dep <span class="keyword">as</span> ScrollViewer;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; VisualTreeHelper.GetChildrenCount(dep); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> child = VisualTreeHelper.GetChild(dep, i);</span><br><span class="line">                <span class="keyword">var</span> result = GetScrollViewer(child);</span><br><span class="line">                <span class="keyword">if</span> (result != <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/gaobing/p/3865254.html">RichTextBox详解</a></p>
<h3 id="主要属性-1"><a href="#主要属性-1" class="headerlink" title="主要属性"></a>主要属性</h3><p>WPF中RichTextBox控件的主要属性如下：</p>
<ol>
<li>Text：用于获取或设置RichTextBox中的纯文本内容。</li>
<li>Document：用于获取或设置RichTextBox中的文档内容，这可以是一个FlowDocument对象。</li>
<li>IsReadOnly：用于获取或设置RichTextBox是否为只读模式。</li>
<li>IsDocumentEnabled：用于获取或设置RichTextBox是否启用文档功能。</li>
<li>Selection：用于获取或设置RichTextBox中选中文本的范围。</li>
<li>VerticalScrollBarVisibility：用于获取或设置RichTextBox中垂直滚动条的可见性。</li>
<li>HorizontalScrollBarVisibility：用于获取或设置RichTextBox中水平滚动条的可见性。</li>
<li>AcceptsTab：用于获取或设置RichTextBox是否可以接受Tab键输入。</li>
<li>Background：用于获取或设置RichTextBox的背景色。</li>
<li>Foreground：用于获取或设置RichTextBox中前景色（文本颜色）。</li>
<li>FontSize：用于获取或设置RichTextBox中文本的字号大小。</li>
<li>FontFamily：用于获取或设置RichTextBox中文本的字体。</li>
<li>FontWeight：用于获取或设置RichTextBox中文本的字重。</li>
<li>FontStyle：用于获取或设置RichTextBox中文本的字体样式（如斜体、加粗等）。</li>
<li>TextWrapping：用于获取或设置RichTextBox中文本的换行方式。</li>
</ol>
<p>WPF中的RichTextBox控件常用于以下场景：</p>
<ol>
<li>编辑富文本内容：可以让用户在控件中编辑富文本内容，包括文字、图像、表格等。</li>
<li>显示富文本内容：可以在控件中显示富文本内容，包括从外部文件加载的内容或通过编程动态生成的内容。</li>
<li>实现文本格式化：可以对富文本内容进行格式化，例如加粗、斜体、下划线、字体、字号、颜色等。</li>
<li>实现输入验证：可以对用户输入的文本进行验证，例如限制输入的字符类型、长度、格式等。</li>
<li>实现文本搜索和替换：可以对富文本内容进行搜索和替换，方便用户快速定位和修改内容。</li>
<li>实现语法高亮：可以在富文本内容中实现语法高亮显示，例如在代码编辑器中显示关键字、注释等。</li>
</ol>
<p>RichTextBox控件是一个非常强大和灵活的控件，可以满足各种富文本编辑和显示的需求。</p>
<h2 id="常用属性罗列"><a href="#常用属性罗列" class="headerlink" title="常用属性罗列"></a>常用属性罗列</h2><h3 id="Margin"><a href="#Margin" class="headerlink" title="Margin"></a>Margin</h3><p>间隔</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button Margin=&quot;10&quot;/&gt;</span><br><span class="line">&lt;!--表示左右隔开10--&gt;</span><br><span class="line">&lt;Button Margin=&quot;10,20&quot;/&gt; </span><br><span class="line">&lt;!--表示左右隔开10,上下隔开20--&gt;</span><br><span class="line">&lt;Button Margin=&quot;10,20,30,40&quot;/&gt; </span><br><span class="line">&lt;!--分别表示左上右下;左隔开10.上隔开20,右隔开30,下隔开40--&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Width-Height"><a href="#Width-Height" class="headerlink" title="Width&#x2F;Height"></a>Width&#x2F;Height</h3><p>宽&#x2F;高</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button Width=&quot;1*&quot;&gt;&lt;/Button&gt;</span><br><span class="line">&lt;Button Width=&quot;9*&quot;&gt;&lt;/Button&gt;</span><br><span class="line">&lt;!--在当前空间中第一个按钮宽占1/10,第二个按钮宽占9/10--&gt;</span><br></pre></td></tr></table></figure>

<p>自动适应内容大小,可以将 <code>Width</code>和 <code>Height</code>设置为 <code>&quot;auto&quot;</code></p>
<h3 id="VerticalAlignment-HorizontalAlignment"><a href="#VerticalAlignment-HorizontalAlignment" class="headerlink" title="VerticalAlignment&#x2F;HorizontalAlignment"></a>VerticalAlignment&#x2F;HorizontalAlignment</h3><p><strong>垂直对齐&#x2F;水平对齐</strong></p>
<p>用于控制元素在容器中的垂直和水平对齐方式的属性。</p>
<p>设置为Stretch,表示在对应方向拉伸缩填满</p>
<p>像button这样的控件还有 <code>VerticalContentAlignment/HorizontalContentAlignment</code>用于控制其中的文本在按钮中的对齐方式的属性</p>
<h2 id="控件组织结构"><a href="#控件组织结构" class="headerlink" title="控件组织结构"></a>控件组织结构</h2><p><a href="#%E9%80%BB%E8%BE%91%E6%A0%91">逻辑树</a>可以在类的构造函数中遍历</p>
<p><a href="#%E8%A7%86%E8%A7%89%E6%A0%91">视觉树</a>必须在经过至少一次的布局后才能形成,所以它不能在构造函数遍历。通常是在OnContentRendered进行，这个函数为在布局发生后被调用</p>
<blockquote>
<p>这里涉及到与WinForms的显著差异</p>
<ul>
<li>WinForm中使用的是控件层次结构来描述控件的组织方式,每个空间都通过父控件与子控件形成层次关系</li>
<li>WPF中使用逻辑树与视觉树来组织控件</li>
</ul>
</blockquote>
<h3 id="逻辑树的结构"><a href="#逻辑树的结构" class="headerlink" title="逻辑树的结构"></a>逻辑树的结构</h3><p>辑树中的每个节点代表一个 <code>DependencyObject</code>，通常是 UI 元素（如控件、窗口等）。这些元素之间通过父子关系连接在一起</p>
<p>辑树用于处理数据绑定和事件路由。<strong>数据绑定通常是基于逻辑树的结构进行的，事件的路由也是从逻辑树的根节点向下传播</strong>。</p>
<p>视觉树表示实际渲染的元素，包括所有的视觉表现（如形状、颜色等），而逻辑树则关注元素的结构和关系。逻辑树中的元素不一定在视觉树中都有对应的可视元素</p>
<h3 id="查找控件"><a href="#查找控件" class="headerlink" title="查找控件"></a>查找控件</h3><h4 id="FindName"><a href="#FindName" class="headerlink" title="FindName"></a>FindName</h4><p>FindName 方法用于在 XAML 名称范围内查找具有特定名称的元素。它通常用于在代码隐藏文件中查找由 x:Name 标识的控件。</p>
<p>优点：</p>
<ul>
<li>简单直接，易于使用。</li>
<li>性能较好，因为它直接在名称范围内查找控件。</li>
</ul>
<p>缺点：</p>
<ul>
<li>只能查找当前名称范围内的控件，不能跨越不同的名称范围。</li>
<li>如果控件在不同的命名空间或模板中，可能无法找到。</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用方法如下</span></span><br><span class="line">RichText = System.Windows.Application.Current.MainWindow.FindName(<span class="string">&quot;richTextBox&quot;</span>) <span class="keyword">as</span> RichTextBox;</span><br></pre></td></tr></table></figure>

<h4 id="逻辑树与视觉树"><a href="#逻辑树与视觉树" class="headerlink" title="逻辑树与视觉树"></a>逻辑树与视觉树</h4><ul>
<li><a href="#%E8%A7%86%E8%A7%89%E6%A0%91">视觉树</a>是一种具体的UI结构，它表示了UI元素的渲染细节和视觉效果，例如布局、样式、动画、变换等。</li>
<li><a href="#%E9%80%BB%E8%BE%91%E6%A0%91">逻辑树</a>是一种抽象的UI结构，它表示了UI元素之间的逻辑关系和层次关系，例如父 子关系、资源继承、事件路由等。</li>
</ul>
<p>下图展示了XAML的逻辑树(无阴影)与视觉树(有阴影)</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202501041657006.png" alt="image-20250104165723110" style="zoom:67%;" />

<h5 id="视觉树"><a href="#视觉树" class="headerlink" title="视觉树"></a>视觉树</h5><p>System.Windows.Media.VisualTreeHelper</p>
<p>视觉树（Visual Tree）是 WPF 中的一个概念，它表示应用程序中所有可视元素的层次结构。视觉树包含了所有的 UI 元素，包括用户能看到的控件和一些用户看不到的辅助元素。</p>
<p>VisualTreeHelper 是一个静态类，用于遍历和操作视觉树。它允许你递归地查找子元素，适用于更复杂的场景。</p>
<blockquote>
<ul>
<li>逻辑树: 包含了应用程序中所有的元素，包括控件、数据对象和资源。它反映了 XAML 文件中的元素层次结构。</li>
<li>视觉树: 仅包含可视元素，反映了实际渲染的元素层次结构。视觉树是逻辑树的一个子集，但包含更多的细节，如模板生成的元素。</li>
</ul>
<p>视觉树的作用:</p>
<ul>
<li>渲染: 视觉树用于渲染 UI 元素。</li>
<li>事件路由: 视觉树用于路由输入事件（如鼠标和键盘事件）。</li>
<li>布局: 视觉树用于计算和安排元素的布局。</li>
</ul>
</blockquote>
<p>优点：</p>
<ul>
<li>可以递归查找子元素，适用于复杂的控件层次结构。</li>
<li>不受名称范围限制，可以跨越不同的模板和命名空间。</li>
</ul>
<p>缺点：</p>
<ul>
<li>代码相对复杂，需要递归遍历视觉树。</li>
<li>性能可能较差，特别是在视觉树很深的情况下。</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 在视觉树中递归查找具有特定名称的一个子元素</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name=&quot;T&quot;&gt;</span><span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;parent&quot;&gt;</span>作为查找的起点，方法会从这个元素开始递归查找其子元素<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;childName&quot;&gt;</span>要查找的子元素的名称。这个名称是通过 x:Name 属性在 XAML 中定义的<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">FindChild</span>&lt;<span class="title">T</span>&gt;(<span class="params">DependencyObject parent, <span class="built_in">string</span> childName</span>) <span class="keyword">where</span> T : DependencyObject</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (parent == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  T foundChild = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">int</span> childrenCount = VisualTreeHelper.GetChildrenCount(parent);</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; childrenCount; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">var</span> child = VisualTreeHelper.GetChild(parent, i);</span><br><span class="line">    T childType = child <span class="keyword">as</span> T;</span><br><span class="line">    <span class="keyword">if</span> (childType == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      foundChild = FindChild&lt;T&gt;(child, childName);</span><br><span class="line">      <span class="keyword">if</span> (foundChild != <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">string</span>.IsNullOrEmpty(childName))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">var</span> frameworkElement = child <span class="keyword">as</span> FrameworkElement;</span><br><span class="line">      <span class="keyword">if</span> (frameworkElement != <span class="literal">null</span> &amp;&amp; frameworkElement.Name == childName)</span><br><span class="line">      &#123;</span><br><span class="line">        foundChild = (T)child;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      foundChild = (T)child;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> foundChild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用方式</span></span><br><span class="line">RichText = FindChild&lt;RichTextBox&gt;(System.Windows.Application.Current.MainWindow, <span class="string">&quot;richTextBox&quot;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="逻辑树"><a href="#逻辑树" class="headerlink" title="逻辑树"></a>逻辑树</h5><p>System.Windows.LogicalTreeHelper</p>
<p>在 WPF 中，逻辑树（Logical Tree）表示应用程序中所有元素的层次结构，包括控件、数据对象和资源。逻辑树反映了 XAML 文件中的元素层次结构。与视觉树不同，逻辑树更关注元素之间的关系，而不是它们的渲染细节。</p>
<p>LogicalTreeHelper 类提供了一些静态方法，用于遍历和操作逻辑树。你可以使用这些方法递归查找逻辑树中的子元素。<br>常用方法：</p>
<ul>
<li><code>LogicalTreeHelper.GetChildren(DependencyObject parent)</code>: 获取指定元素的子元素集合。</li>
<li><code>LogicalTreeHelper.GetParent(DependencyObject child)</code>: 获取指定元素的父元素。</li>
<li><code>LogicalTreeHelper.FindLogicalNode(DependencyObject logicalTreeNode, string elementName)</code>: 在逻辑树中查找具有指定名称的元素。</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归查找逻辑树中的一个指定x:Name的控件</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">FindLogicalChild</span>&lt;<span class="title">T</span>&gt;(<span class="params">DependencyObject parent, <span class="built_in">string</span> childName</span>) <span class="keyword">where</span> T : DependencyObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">object</span> child <span class="keyword">in</span> LogicalTreeHelper.GetChildren(parent))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (child <span class="keyword">is</span> DependencyObject depChild)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (depChild <span class="keyword">is</span> T &amp;&amp; ((FrameworkElement)depChild).Name == childName)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> (T)depChild;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            T result = FindLogicalChild&lt;T&gt;(depChild, childName);</span><br><span class="line">            <span class="keyword">if</span> (result != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="自绘控件"><a href="#自绘控件" class="headerlink" title="自绘控件"></a>自绘控件</h1><p>WPF的底层不是实时绘制更新的,而是事件驱动的绘制更新.最终会触发windows的paint消息,然后交给设备上绘制相关的api</p>
<p>ArrangeOverride是调用OnRender</p>
<p>可以在OnRender中绘制东西,如:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyPanel</span>: <span class="title">Panel</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> Size <span class="title">ArrangeOverride</span>(<span class="params">Size arrangeBounds</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">base</span>.ArrangeOverride(arrangeBounds);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnRender</span>(<span class="params">DrawingContext dc</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">		dc.DrawRectangle(Background,<span class="literal">null</span>,<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,Width,Height));</span><br><span class="line">    dc.DrawEllipse(Brushes.LightGreen,<span class="literal">null</span>,<span class="keyword">new</span> Point(<span class="number">100</span>,<span class="number">100</span>),<span class="number">50</span>,<span class="number">50</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Panel–继承于–&gt;FrameworkElement–继承于–&gt;UIElement–继承于–&gt;Visual</p>
<p>OnRender就来源于Visual</p>
<h1 id="完全自定义窗口"><a href="#完全自定义窗口" class="headerlink" title="完全自定义窗口"></a>完全自定义窗口</h1><p>完全自定义窗口参考下面的做法:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AllowsTransparency=&quot;True&quot;</span><br><span class="line">WindowStyle=&quot;None&quot;</span><br></pre></td></tr></table></figure>

<p>上面两行Window标签中的属性设置是为了实现去除窗口默认标题栏的效果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--WindowChrome是一个作用于Window的附加属性,有了WindowChrome之后就可以拉伸拖拽等种种功能--&gt;</span><br><span class="line">&lt;WindowChrome.WindowChrome&gt;</span><br><span class="line">	  &lt;WindowChrome CaptionHeighty=&quot;100&quot;/&gt;</span><br><span class="line">&lt;/WindowChrome.WindowChrome&gt;</span><br></pre></td></tr></table></figure>

<p>但是WindowChrome有缺陷,会导致全屏的时候显示不完全,一般要对界面中的内容设置Margin为10或13  或  WindowChrome的GlassFrameThickness设置为10或13</p>
<h1 id="简易反调试检测"><a href="#简易反调试检测" class="headerlink" title="简易反调试检测"></a>简易反调试检测</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">DllImport(<span class="string">&quot;kernelbase.dll&quot;</span>, SetLastError = true)</span>]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">extern</span> <span class="built_in">bool</span> <span class="title">IsDebuggerPresent</span>()</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">    <span class="keyword">var</span> isAttached = IsDebuggerPresent();</span><br><span class="line">    <span class="keyword">if</span> (isAttached)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;/(ToT)/~~ 小心，我被附加了 调试器！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;O(n_n)O 程序很安全！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最基本的反附加调试检测</p>
<h1 id="窗口-页面-用户控件"><a href="#窗口-页面-用户控件" class="headerlink" title="窗口&#x2F;页面&#x2F;用户控件"></a>窗口&#x2F;页面&#x2F;用户控件</h1><p>窗口（Window）</p>
<ul>
<li>表示一个独立的顶级窗口，通常是应用程序的主要界面。</li>
<li>可以包含其他控件和布局。</li>
<li>具有标题栏、边框等窗口特征。</li>
<li>可以最小化、最大化、关闭。</li>
</ul>
<p>页面（Page）：</p>
<ul>
<li>通常用于导航框架中的页面。</li>
<li>与窗口类似，但可能具有特定的导航行为和约定。</li>
<li>常用于单页应用程序或多页面应用程序。</li>
</ul>
<p>用户控件（User Control）：</p>
<ul>
<li>可重用的自定义控件。</li>
<li>可以包含其他控件和布局。</li>
<li>用于封装特定的功能或界面部分。</li>
<li>可在多个窗口或页面中重复使用。</li>
</ul>
<h2 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h2><p>窗口上面含的东西大致如下:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202409191513939.png" alt="img"></p>
<h3 id="自定义拖拽控制窗体大小"><a href="#自定义拖拽控制窗体大小" class="headerlink" title="自定义拖拽控制窗体大小"></a>自定义拖拽控制窗体大小</h3><p>自定义的调整大小手柄，放置在窗口的右下角</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SendMessage 函数的 P/Invoke 声明，允许我们从 C# 代码调用 Windows API 函数。</span></span><br><span class="line">[<span class="meta">DllImport(<span class="string">&quot;user32.dll&quot;</span>, CharSet = CharSet.Auto)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> IntPtr <span class="title">m</span>(<span class="params">IntPtr hWnd, <span class="built_in">uint</span> Msg, IntPtr wParam, IntPtr lParam</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ResizeWindow</span>(<span class="params">ResizeDirection direction</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">       WindowInteropHelper helper = <span class="keyword">new</span> WindowInteropHelper(<span class="keyword">this</span>);</span><br><span class="line">       SendMessage(helper.Handle, <span class="number">0x112</span>, (IntPtr)(<span class="number">61440</span> + direction), IntPtr.Zero);</span><br><span class="line"><span class="comment">//事件处理:这个方法处理 ResizeGrip 的鼠标点击事件。单击时调整大小，双击时最大化或还原窗口。</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ResizeGrip_MouseLeftButtonDown</span>(<span class="params"><span class="built_in">object</span> sender, MouseButtonEventArgs e</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span> (e.ClickCount == <span class="number">2</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           ToggleMaximize();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           ResizeWindow(ResizeDirection.BottomRight);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这个方法使用 Windows API 来调整窗口大小。具体来说：</p>
<ul>
<li><code>WindowInteropHelper</code> 用于获取窗口的句柄（Handle）。</li>
<li><code>SendMessage</code> 是一个 Windows API 函数，用于向窗口发送消息。</li>
<li>消息 <code>0x112 (WM_SYSCOMMAND)</code> 用于执行系统命令。</li>
<li><code>61440 + direction</code> 指定了调整大小的方向（例如，61448 表示从右下角调整大小）。</li>
</ul>
<h1 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h1><p>在绑定之前所使用的是通过设置 <code>x:Name</code>设置索引名，然后在c#代码中使用设置的Name来获取该控件,下面介绍更方便的绑定方式</p>
<p>绑定顾名思义，是将我们获取到的数据和UI上的控件绑定起来利用数据的变化来更新界面所看到的内容 把绑定分为五步</p>
<ol>
<li><p><strong>绑定目标</strong>   就是要操作绑定的控件,如:Button,TextBox</p>
</li>
<li><p><strong>绑定属性</strong>  就是依赖项属性</p>
<p><code>&lt;TextBox Width=&quot;200&quot; Height=&quot;25&quot; Text=&quot;&#123;Binding Name&#125;&quot;&gt;&lt;/TextBox&gt;</code></p>
<p>Text是绑定属性,Bingding是绑定关键字,而后面的Name就是要绑定的数据源的变量名(Name是声明好的属性变量)</p>
</li>
<li><p><strong>绑定模式</strong></p>
<p><code>&lt;TextBox Width=&quot;200&quot; Height=&quot;25&quot; Text=&quot;&#123;Binding Name,Mode=绑定模式&#125;&quot;&gt;&lt;/TextBox&gt;</code></p>
<ul>
<li><p><code>TwoWay</code> <strong>双向绑定模式</strong>:源和目标相互影响。当源发生变化时目标更新，同时目标属性的更改也会反馈到源</p>
</li>
<li><p><code>OneWay</code> <strong>单向绑定模式</strong>:源的变化会自动传播到目标属性，但目标属性的更改不会影响到源。这是比较常用的模式，用于显示数据源的实时变化</p>
</li>
<li><p><code>OneTime</code> 仅当应用程序启动时或DataContext进行更改时更新目标属性</p>
<p>当数据上下文（DataContext）发生改变时，比如在不同的视图或页面之间切换，导致绑定所关联的数据上下文对象被替换为新的，这时在新的数据上下文下，绑定会按照 OneTime 模式的规则进行一次更新。</p>
</li>
<li><p><code>OneWayToSource</code> <strong>反向的单向绑定</strong>:与 <code>OneWay</code>模式相反，当目标属性发生更改时，会自动更新源属性</p>
</li>
<li><p><code>Default</code> 模式根据实际情况来定,如果目标属性是可编辑的就是TwoWay,目标属性是只读的就是OneWay</p>
</li>
</ul>
</li>
</ol>
<p>可以类比为Vue的单向绑定 <code>v-bind</code>和双向绑定 <code>v-model</code></p>
<ol>
<li><p><strong>绑定数据源</strong></p>
<p>可以是单个变量,也可以是一个数据集(List)等等</p>
</li>
<li><p><strong>关联资源</strong></p>
<p>在每一个窗体中,都有一个<strong>DataContext</strong>,他是一个object类型,主要用于存储绑定资源</p>
<p>DataContext 用于将数据库映射为实体，它是实现数据绑定的基础。在 MVVM 架构模式中，通常将 ViewModel 设置为控件或整个界面的 DataContext，这样 UI 控件可以通过绑定直接访问 ViewModel 中的数据和命令。</p>
</li>
<li><p><strong>绑定时机</strong></p>
<p>还可以使用 <code>Text = &quot;&#123;Binding Acount,UpdateSourceTrigger = 绑定时机&#125;&quot;</code></p>
<p>在 WPF 中，UpdateSourceTrigger是一个枚举，用于确定绑定源（比如视图模型中的属性）的更新时机。它对于数据绑定非常重要，因为它控制着用户界面上的更改何时反映到绑定的数据源属性上。</p>
<p>UpdateSourceTrigger的值包括</p>
<ul>
<li><code>Default</code>：使用绑定目标属性的默认更新触发器。对于大多数依赖属性是 <code>LostFocus</code>，但对于TextBox.Text属性是 <code>PropertyChanged</code>。</li>
<li><code>PropertyChanged</code>：每当目标属性的值发生变化时，都会更新源属性。</li>
<li><code>LostFocus</code>：当控件失去焦点时，更新源属性。</li>
<li><code>Explicit</code>：只有在调用BindingExpression.UpdateSource方法时，才更新源属性。</li>
</ul>
</li>
</ol>
<p><strong>绑定的目标与数据源必须是同类型</strong></p>
<h2 id="Binding源的指定"><a href="#Binding源的指定" class="headerlink" title="Binding源的指定"></a>Binding源的指定</h2><ul>
<li><p>使用自定义类作为源</p>
<p>一个对象只要通过属性公开自己的数据，就可以作为Binding的源。作为Binding源的对象需要实现INotifyPropertyChanged接口并激发PropertyChanged事件才能使属性具有自动通知Binding发生了变化的能力。除了使用自定义类作为源以外，还有其他不同的形式。</p>
</li>
<li><p>将控件作为源(关键词ElementName)</p>
</li>
<li><p>DataContext作为源</p>
<p>当我们使用DataContext作数据源时，它会自动将UI元素的数据源设置为当前窗口或用户控件的DataContext属性。所以在XAML文件中使用 <code>｛Binding｝</code>语法来绑定时而无需指定任何其他源，因此这种形式也称作无源数据绑定。</p>
<p>使用DataContext不仅可以绑定公开属性,还可以访问命令对象以及资源中定义的属性</p>
<blockquote>
<p>在Binding通过元素树向根结点处方向寻找DataContext的现象，其实只是一种描述效果。真正的过程其实是结点上的属性值向下传递了，这是因为DataContext是一个依赖属性，而依赖属性有一个特性，当你没有为控件的某个属性显式地赋值时，它就会把自己所在容器的属性值拿过来，当作自己的属性值。</p>
</blockquote>
</li>
<li><p>使用<a href="#DataSourceProvider">DataSourceProvider类</a>的子类成员作为数据源</p>
</li>
<li><p><a href="LINQ%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E4%BD%9C%E4%B8%BA%E6%95%B0%E6%8D%AE%E6%BA%90">LINQ查询结果作为数据源</a></p>
</li>
</ul>
<h3 id="DataSourceProvider"><a href="#DataSourceProvider" class="headerlink" title="DataSourceProvider"></a>DataSourceProvider</h3><p>DataSourceProvider类是一个抽象基类，它定义了一些公共属性和方法，用来执行某些查询，生成可以用作绑定源的单个对象或对象列表。DataSourceProvider类支持标准的Windows窗体数据绑定模型，可以处理不同类型的数据源，例如SQL数据库，<a href="#XmlDataProvider">XML文档</a>，数组集合等。DataSourceProvider类还实现了INotifyPropertyChanged和ISupportlnitialize接口，用来提供对绑定和初始化的支持。</p>
<p>提供一种将不同类型的数据源用作绑定源的方式,使用他的好处是可以简化数据绑定的过程,无需编写额外的代码来加载和查询数据</p>
<h4 id="XmlDataProvider"><a href="#XmlDataProvider" class="headerlink" title="XmlDataProvider"></a>XmlDataProvider</h4><p>XML是一种可扩展标记语言，它可以用来存储和传输数据。XML的特点是它可以自定义标签，用来描述数据的结构和含义。XML可以与其他技术一起使用来处理和转換数据。XML也可以用作配置文件，元数据，富文档等。NET提供了DOM（Document Obiject Model）文档对象模型类库用于处理XML数据，包括XmlDoucument、XmlElement等类，是传统的、功能强大的类库。</p>
<p>展示xml文档的数据,可以使用ListBox或ListView</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;ListView Height=&quot;130&quot; Margin=&quot;5&quot; x:Name=&quot;ListView_Goods&quot;&gt;</span><br><span class="line">  &lt;ListView.View&gt;</span><br><span class="line">    &lt;!--使用GridView来设计--&gt;</span><br><span class="line">    &lt;GridView&gt;</span><br><span class="line">      &lt;!--定义多个表格列--&gt;</span><br><span class="line">      &lt;GridViewColumn Header=&quot;Id&quot; Width=&quot;40&quot; DisplayMemberBinding=&quot;&#123;Binding XPath=@Id&#125;&quot;/&gt;</span><br><span class="line">      &lt;GridViewColumn Header=&quot;Name&quot; Width=&quot;100&quot; DisplayMemberBinding=&quot;&#123;Binding XPath=Name&#125;&quot;/&gt;</span><br><span class="line">      &lt;GridViewColumn Header=&quot;Price&quot; Width=&quot;70&quot; DisplayMemberBinding=&quot;&#123;Binding XPath=Price&#125;&quot;/&gt;</span><br><span class="line">    &lt;/GridView&gt;</span><br><span class="line">  &lt;/ListView.View&gt;</span><br><span class="line">&lt;/ListView&gt;</span><br></pre></td></tr></table></figure>

<p><code>XPath</code> 是一种用于在 XML 文档中查找信息的语言。在 WPF 中，<code>XPath</code> 可以用于绑定 XML 数据。</p>
<p>在 <code>XPath</code> 中，<code>@</code> 符号用于表示属性（特征）。例如，<code>XPath=@Id</code> 表示绑定到 XML 元素的 <code>Id</code> 属性。</p>
<p>绑定代码如下:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//载入XML文件对象</span></span><br><span class="line">XmlDocument xmlDocument = <span class="keyword">new</span> XmlDocument();</span><br><span class="line">xmlDocument.Load(<span class="string">@&quot;E:\GoodsData.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//XmlDataProvider用于支持对XML数据的访问,以便用于数据绑定</span></span><br><span class="line">XMLDataProvider xmlDataProvier = <span class="keyword">new</span> XmlDataProvider();</span><br><span class="line">XMLDataProvider.Document = xmlDocument;</span><br><span class="line">XMLDataProvider.XPath=<span class="string">@&quot;/GoodsList/Goods&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.ListView_Goods.DataContext = xmlDataProvider;</span><br><span class="line"><span class="keyword">this</span>.ListView_Goods.SetBinding(ListView.ItemsSourceProperty,<span class="keyword">new</span> Binding());</span><br><span class="line"></span><br><span class="line"><span class="comment">//上述全部代码可简化为：</span></span><br><span class="line">XMLDataProvider xmlDataProvier = <span class="keyword">new</span> XmlDataProvider();</span><br><span class="line">XMLDataProvider.Source = <span class="keyword">new</span> Uri(<span class="string">@&quot;E:\GoodsData.xml&quot;</span>);</span><br><span class="line">XMLDataProvider.XPath=<span class="string">@&quot;/GoodsList/Goods&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.ListView_Goods.DataContext = xmlDataProvider;</span><br><span class="line"><span class="keyword">this</span>.ListView_Goods.SetBinding(ListView.ItemsSourceProperty,<span class="keyword">new</span> Binding());</span><br></pre></td></tr></table></figure>

<p>假设有一个 XML 文档如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Products</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Product</span> <span class="attr">Id</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Name</span>&gt;</span>Apple<span class="tag">&lt;/<span class="name">Name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Price</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">Price</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Product</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Product</span> <span class="attr">Id</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Name</span>&gt;</span>Banana<span class="tag">&lt;/<span class="name">Name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Price</span>&gt;</span>0.8<span class="tag">&lt;/<span class="name">Price</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Product</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Products</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="ObjectDataProvider"><a href="#ObjectDataProvider" class="headerlink" title="ObjectDataProvider"></a>ObjectDataProvider</h4><p><strong>ObjectDataProvider能够将对象进行包装，作为数据源提供给Binding</strong>。被包装的对象作为ObjectDataProvider的Objectlnstance属性，我们可以通过MethodName属性来指明要调用的方法，使用MethodParameters属性来传入参数，其是一个集合，因此可以使用下标形式指定和访问。运行方法的结果会保存在Data属性中。</p>
<p>支持根据参数调用重载方法</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202412230901048.png" alt="image-20241223090153461" style="zoom: 33%;" />

<h3 id="LINQ查询结果作为数据源"><a href="#LINQ查询结果作为数据源" class="headerlink" title="LINQ查询结果作为数据源"></a>LINQ查询结果作为数据源</h3><p>LINQ的查询结果是可以作为数据绑定的数据源的，这是因为其查询结果是一个 <code>IEnumerable </code><T>&#96;&#96;&#96;&#96;&#96;对象，所以可以作为列表控件的ItemSource来使用。</p>
<p>LINQ的优点是可以提高数据处理的能力和开发效率,使查询成为了C#语言的一部分,LINK还可以使用声明式查询语法或方法语法来编写查询表达式.这些表达式可以在编译时进行类型检查和优化</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.ListView_Employee.ItemsSource=<span class="keyword">from</span> emp <span class="keyword">in</span> employeeList <span class="keyword">where</span> emp.Name.StartsWith(<span class="string">&quot;L&quot;</span>) <span class="keyword">select</span> emp;</span><br></pre></td></tr></table></figure>

<p>案例</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.ObjectModel;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EmployeeViewModel</span> : <span class="title">INotifyPropertyChanged</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> ObservableCollection&lt;Employee&gt; _employeeList;</span><br><span class="line">    <span class="keyword">private</span> ObservableCollection&lt;Employee&gt; _filteredEmployees;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ObservableCollection&lt;Employee&gt; EmployeeList</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _employeeList; &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            _employeeList = <span class="keyword">value</span>;</span><br><span class="line">            OnPropertyChanged(<span class="keyword">nameof</span>(EmployeeList));</span><br><span class="line">            FilterEmployees();  <span class="comment">// 每当员工列表更改时，重新过滤</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ObservableCollection&lt;Employee&gt; FilteredEmployees</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _filteredEmployees; &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            _filteredEmployees = <span class="keyword">value</span>;</span><br><span class="line">            OnPropertyChanged(<span class="keyword">nameof</span>(FilteredEmployees));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EmployeeViewModel</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 初始化员工列表</span></span><br><span class="line">        EmployeeList = <span class="keyword">new</span> ObservableCollection&lt;Employee&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">new</span> Employee &#123; Name = <span class="string">&quot;John&quot;</span>, Age = <span class="number">30</span>, Position = <span class="string">&quot;Manager&quot;</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span> Employee &#123; Name = <span class="string">&quot;Linda&quot;</span>, Age = <span class="number">25</span>, Position = <span class="string">&quot;Developer&quot;</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span> Employee &#123; Name = <span class="string">&quot;Liam&quot;</span>, Age = <span class="number">22</span>, Position = <span class="string">&quot;Intern&quot;</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span> Employee &#123; Name = <span class="string">&quot;Paul&quot;</span>, Age = <span class="number">35</span>, Position = <span class="string">&quot;Developer&quot;</span> &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        FilterEmployees();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 过滤员工列表，只保留名字以&quot;L&quot;开头的员工</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">FilterEmployees</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        FilteredEmployees = <span class="keyword">new</span> ObservableCollection&lt;Employee&gt;(</span><br><span class="line">            EmployeeList.Where(emp =&gt; emp.Name.StartsWith(<span class="string">&quot;L&quot;</span>))</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> PropertyChangedEventHandler PropertyChanged;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnPropertyChanged</span>(<span class="params"><span class="built_in">string</span> propertyName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        PropertyChanged?.Invoke(<span class="keyword">this</span>, <span class="keyword">new</span> PropertyChangedEventArgs(propertyName));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>xaml</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;Window x:Class=&quot;MVVMExample.MainWindow&quot;</span><br><span class="line">        xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span><br><span class="line">        xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span><br><span class="line">        Title=&quot;Employee List&quot; Height=&quot;350&quot; Width=&quot;525&quot;&gt;</span><br><span class="line">    &lt;Window.DataContext&gt;</span><br><span class="line">        &lt;local:EmployeeViewModel /&gt;</span><br><span class="line">    &lt;/Window.DataContext&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Grid&gt;</span><br><span class="line">        &lt;ListView ItemsSource=&quot;&#123;Binding FilteredEmployees&#125;&quot;&gt;</span><br><span class="line">            &lt;ListView.View&gt;</span><br><span class="line">                &lt;GridView&gt;</span><br><span class="line">                    &lt;GridViewColumn Header=&quot;Name&quot; DisplayMemberBinding=&quot;&#123;Binding Name&#125;&quot; Width=&quot;150&quot;/&gt;</span><br><span class="line">                    &lt;GridViewColumn Header=&quot;Age&quot; DisplayMemberBinding=&quot;&#123;Binding Age&#125;&quot; Width=&quot;100&quot;/&gt;</span><br><span class="line">                    &lt;GridViewColumn Header=&quot;Position&quot; DisplayMemberBinding=&quot;&#123;Binding Position&#125;&quot; Width=&quot;200&quot;/&gt;</span><br><span class="line">                &lt;/GridView&gt;</span><br><span class="line">            &lt;/ListView.View&gt;</span><br><span class="line">        &lt;/ListView&gt;</span><br><span class="line">    &lt;/Grid&gt;</span><br><span class="line">&lt;/Window&gt;</span><br></pre></td></tr></table></figure>

<h3 id="RelativeSource"><a href="#RelativeSource" class="headerlink" title="RelativeSource"></a>RelativeSource</h3><p>当我们不能确定源对象的名称，但是能知道其与目标对象在UI布局上有层级关系时，可以使用RelativeSource属性。RelativeSource属性数据类型为RelativeSource类，其<br>Mode属性的类型是RelativeSourceMode枚举，其取值有PreviousData、TemplateParent、Self和FindAncestor。对于前三个枚举值还有同名的静态属性，它们的类型是RelativeSource类。</p>
<p>不仅可以按照层级来寻找数据源对象,还支持控件自身与自身的属性进行绑定</p>
<ul>
<li>PreviousData 绑定到集合中当前项的前一项的数据。</li>
<li>TemplateParent 绑定到应用了控件模板的控件的属性。</li>
<li>Self 绑定到绑定目标本身的属性。</li>
<li>FindAncestor 绑定到绑定目标的某个祖先元素（结点或根元素）的属性。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextBox x:Name=&quot;TextBox1&quot; FontSize=&quot;16&quot; Margin=&quot;15&quot;</span><br><span class="line">    Background=&quot;&#123;Binding RelativeSource=&#123;RelativeSource FindAncestor, AncestorType=&#123;x:Type DockPanel&#125;&#125;, AncestorLevel=2&#125;, Path=Background&#125;&quot;</span><br><span class="line">    Text=&quot;&#123;Binding RelativeSource=&#123;RelativeSource Mode=Self&#125;, Path=Name&#125;&quot; /&gt;</span><br></pre></td></tr></table></figure>

<h3 id="绑定解释"><a href="#绑定解释" class="headerlink" title="绑定解释"></a>绑定解释</h3><p>在您的 <code>ListView</code> 中的 <code>GridViewColumn</code> 绑定如下：</p>
<ul>
<li><p><strong>Id 列</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;GridViewColumn Header=&quot;Id&quot; Width=&quot;40&quot; DisplayMemberBinding=&quot;&#123;Binding XPath=@Id&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里的 <code>XPath=@Id</code> 表示绑定到 <code>Product</code> 元素的 <code>Id</code> 属性。</li>
</ul>
</li>
<li><p><strong>Name 列</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;GridViewColumn Header=&quot;Name&quot; Width=&quot;100&quot; DisplayMemberBinding=&quot;&#123;Binding XPath=Name&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里的 <code>XPath=Name</code> 表示绑定到 <code>Product</code> 元素的 <code>Name</code> 子元素。</li>
</ul>
</li>
<li><p><strong>Price 列</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;GridViewColumn Header=&quot;Price&quot; Width=&quot;70&quot; DisplayMemberBinding=&quot;&#123;Binding XPath=Price&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里的 <code>XPath=Price</code> 表示绑定到 <code>Product</code> 元素的 <code>Price</code> 子元素。</li>
</ul>
</li>
</ul>
<h2 id="Binding路径的指定"><a href="#Binding路径的指定" class="headerlink" title="Binding路径的指定"></a>Binding路径的指定</h2><p>Binding 支持多级路径,即可以一直点下去</p>
<h2 id="绑定和窗体xmal-cs中操作的区别"><a href="#绑定和窗体xmal-cs中操作的区别" class="headerlink" title="绑定和窗体xmal.cs中操作的区别"></a>绑定和窗体xmal.cs中操作的区别</h2><ul>
<li>窗体后台文件直接访问控件的操作是<strong>事件驱动</strong>的,即如果没有事件的存在是改变不了界面的</li>
<li>绑定的操作是以<strong>数据本身的变化</strong>来通知界面显示改变的</li>
</ul>
<p>因此绑定可以实现<strong>前后端分离</strong></p>
<h2 id="使用绑定需要的步骤"><a href="#使用绑定需要的步骤" class="headerlink" title="使用绑定需要的步骤"></a>使用绑定需要的步骤</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先要在窗体文件中设定窗口的数据上下文(比如说MainWindow中)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MainWindow</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    InitializeComponent();</span><br><span class="line">    <span class="comment">//给当前界面指定一个数据上下文(窗口必须有这一句,才能在该窗口中的控件实现绑定)</span></span><br><span class="line">    <span class="comment">//此处的上下文不一定得是this,UserName等变量在哪里就指定什么</span></span><br><span class="line">    <span class="keyword">this</span>.DataContext = <span class="keyword">this</span>;<span class="comment">//!!!!!!!!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> UserName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;<span class="comment">//设定的数据,用于被控件绑定//!!!!!!!!</span></span><br></pre></td></tr></table></figure>

<p>输入账户的textBox控件的Text属性绑定UserName变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextBox Text =&quot;&#123;Binding UserName&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>这样只能实现修改TextBox.Text,更新值到UserName变量中;但是反过来,UserName中的值被修改不能反映到TextBox.Text中</p>
<p>按照<a href="#%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%B8%8B%E6%96%87%E6%94%AF%E6%8C%81%E5%8F%98%E5%8C%96%E9%80%9A%E7%9F%A5">下面</a>来改动才可以,让数据上下文支持变化通知</p>
<h2 id="数据上下文支持变化通知"><a href="#数据上下文支持变化通知" class="headerlink" title="数据上下文支持变化通知"></a>数据上下文支持变化通知</h2><p>将控件绑定一个数据上下文,控件默认只能单向绑定到数据上下文,通过修改数据上下文中被绑定的变量默认无法影响到设置了绑定的控件</p>
<p>要真正支持双向绑定,需要修改数据上下文 的类以支持数据变动时的通知</p>
<p>需要数据上下文的类继承自 <code>INotifyPropertyChanged</code></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">MainWindow</span>:<span class="title">Window</span>,<span class="title">INotifyPropertyChanged</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainWindow</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        InitializeComponent();</span><br><span class="line">        <span class="keyword">this</span>.DataContext = <span class="keyword">this</span>;<span class="comment">//此处以数据上下文指定自己为例子</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义 PropertyChanged 事件，用于通知属性值的更改</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> PropertyChangedEventHandler PropertyChanged;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发属性更改通知的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">RaisePropertyChanged</span>(<span class="params"><span class="built_in">string</span> propertyName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将 PropertyChanged 事件的委托复制给临时变量 handler</span></span><br><span class="line">        PropertyChangedEventHandler handler = PropertyChanged;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 handler 不为 null，则调用委托，传递当前对象和属性名称参数</span></span><br><span class="line">        <span class="keyword">if</span> (handler != <span class="literal">null</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            handler(<span class="keyword">this</span>, <span class="keyword">new</span> PropertyChangedEventArgs(propertyName));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//针对所有需要支持双向绑定的属性,需要在set中去调用RaisePropertyChanged方法</span></span><br><span class="line">     <span class="keyword">private</span> <span class="built_in">string</span> _UserName;</span><br><span class="line">     <span class="keyword">public</span> <span class="built_in">string</span> UserName</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">get</span> &#123; <span class="keyword">return</span> _UserName; &#125;</span><br><span class="line">         <span class="keyword">set</span> &#123; </span><br><span class="line">             _UserName = <span class="keyword">value</span>;</span><br><span class="line">             RaisePropertyChanged(<span class="string">&quot;UserName&quot;</span>);<span class="comment">//SetProperty内含这两行代码</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样修改后,才可以让ViewModel下的所有属性真正可以支持变量到控件的变化通知(即普通属性也支持通知机制了,因为依赖属性本身就内置了通知机制)</p>
<h2 id="绑定xml文件中的值"><a href="#绑定xml文件中的值" class="headerlink" title="绑定xml文件中的值"></a>绑定xml文件中的值</h2><p>假设xml文件名为 <code>Data.xml</code></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Colors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Color</span> <span class="attr">name</span>=<span class="string">&quot;Red&quot;</span>&gt;</span>#FF243A<span class="tag">&lt;/<span class="name">Color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Color</span> <span class="attr">name</span>=<span class="string">&quot;Blue&quot;</span>&gt;</span>#007ACC<span class="tag">&lt;/<span class="name">Color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Color</span> <span class="attr">name</span>=<span class="string">&quot;Yellow&quot;</span>&gt;</span>#FFFF00<span class="tag">&lt;/<span class="name">Color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">User</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Age</span> <span class="attr">name</span>=<span class="string">&quot;gao&quot;</span> <span class="attr">key</span>=<span class="string">&quot;test&quot;</span>&gt;</span>540岁<span class="tag">&lt;/<span class="name">Age</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">User</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Colors</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>App.xaml中需要引用XmlDataProvider</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Application.Resources&gt;</span><br><span class="line">  &lt;XmlDataProvider x:Key=&quot;ColorsXML&quot; Source=&quot;Data.xml&quot;/&gt;</span><br><span class="line">&lt;/Application.Resources&gt;</span><br></pre></td></tr></table></figure>

<p>绑定如下:(平时使用的是Path或省略(一个意思),现在要用XPath)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Border Background=&quot;&#123;Binding XPath=&#x27;/Colors/Color@name=Red&#x27;,Source=&#123;StaticResource ColorsXML&#125;&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>通过Source找到定义好的资源,通过XPath找到具体的值</p>
<h2 id="绑定控件的方法"><a href="#绑定控件的方法" class="headerlink" title="绑定控件的方法"></a>绑定控件的方法</h2><p>未完善</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt; xxx=&quot;&#123;binding Element Name =AllRecipesListBox,Path=SelectedValue&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>绑定到AllRecipesListBox中的SelectedValue方法</p>
<h2 id="ElementName，Source，RelativeSource"><a href="#ElementName，Source，RelativeSource" class="headerlink" title="ElementName，Source，RelativeSource"></a>ElementName，Source，RelativeSource</h2><p>ElementName，Source，RelativeSource 为三种不同的绑定方式</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>ElementName</th>
<th>Source</th>
<th>RelativeSource</th>
</tr>
</thead>
<tbody><tr>
<td>绑定目标</td>
<td>UI 元素的 x:Name</td>
<td>静态对象或资源</td>
<td>自身、模板化父元素、祖先元素等</td>
</tr>
<tr>
<td>常见应用场景</td>
<td>同一个 XAML 文件中的元素之间的绑定</td>
<td>绑定到非 UI 的对象或静态属性</td>
<td>在模板或复杂层次结构中绑定相关元素</td>
</tr>
<tr>
<td>可见性要求</td>
<td>必须在同一个逻辑树内</td>
<td>不依赖可视元素，直接绑定到对象</td>
<td>通常查找祖先元素，适合复杂的层次结构</td>
</tr>
<tr>
<td>典型用例</td>
<td>控件之间的数据共享</td>
<td>绑定到静态资源或静态属性</td>
<td>在控件模板中绑定到父级数据，或绑定到上层容器的属性</td>
</tr>
</tbody></table>
<blockquote>
<p>下面两种绑定效果相同:(利于理解本质)</p>
<ul>
<li><p><code>source = &#123;binding&#125;</code></p>
<p><code>&#123;binding&#125;</code> 不设定明确的绑定的source,这样binding就去从本控件类为开始根据可视树的层次结构自下而上查找不为空的Datacontext属性的值</p>
</li>
<li><p><code>source = &#123;binding RelativeSource=&#123;RelativeSource self&#125;,Path=DataContext&#125;</code></p>
<p>绑定的source为控件自身，这样binding 就绑定了自身控件的Datacontext</p>
</li>
</ul>
</blockquote>
<h3 id="ElementName"><a href="#ElementName" class="headerlink" title="ElementName"></a>ElementName</h3><p>ElementName 允许你通过指定目标元素的名称来进行数据绑定。它通常用于同一 XAML 文件内的不同控件之间的数据绑定，尤其是在需要从其他 UI 元素获取值时。</p>
<p>特点</p>
<ul>
<li>只能绑定到具有 x:Name 属性的元素。</li>
<li>必须在同一个可见的 XAML 逻辑树内（同一个视图文件）。</li>
<li></li>
<li></li>
</ul>
<p><strong>适用场景</strong>: 需要在同一个视图内从某个元素获取值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--TextBlock显示的内容就是TextBox的Text中的文本--&gt;</span><br><span class="line">&lt;TextBox x:Name=&quot;sourceTextBox&quot; Text=&quot;Some Text&quot;/&gt;</span><br><span class="line">&lt;TextBlock Text=&quot;&#123;Binding Text, ElementName=sourceTextBox&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>下面有助于理解ElementName</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;Window x:Name=&quot;MainWindow&quot;&gt;</span><br><span class="line">         &lt;Grid&gt;</span><br><span class="line">               &lt;Button Background=”&#123;Binding ElementName=MainWindow, Path=Background&#125;”/&gt;</span><br><span class="line">         &lt;/Grid&gt;</span><br><span class="line">  &lt;/Window&gt;</span><br><span class="line">&lt;!--效果等同于--&gt;</span><br><span class="line">&lt;Window&gt;</span><br><span class="line">   &lt;Grid&gt;</span><br><span class="line">      &lt;Button Background=”&#123;Binding RelativeSource=&#123;RelativeSource Mode=FindAncestor, AncestorType=&#123;x:Type Window&#125;,Path=Background&#125;”/&gt;</span><br><span class="line">   &lt;/Grid&gt;</span><br><span class="line">&lt;/Window&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>Source 属性允许你直接绑定到某个指定的对象，而不是绑定到 UI 元素。它可以用于在 XAML 中绑定到某个数据源对象，<strong>通常是静态的对象或在代码中初始化的对象</strong>。</p>
<p><strong>适用场景</strong>: 绑定到非 UI 元素的对象，比如后台代码中的对象、静态资源、静态属性等。</p>
<p>用法1 绑定到静态对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextBlock Text=&quot;&#123;Binding Source=&#123;StaticResource MyData&#125;&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>TextBlock绑定到了XAML资源字典中的MyData对象</p>
<p>用法2 绑定到静态属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextBlock Text=&quot;&#123;Binding Source=&#123;x:Static local:MyClass.MyProperty&#125;&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>这里绑定的是静态类 MyClass 的静态属性 MyProperty</p>
<h3 id="RelativeSource-1"><a href="#RelativeSource-1" class="headerlink" title="RelativeSource"></a>RelativeSource</h3><p>RelativeSource 是一种特殊的绑定方式，它允许你相对于绑定目标元素来查找数据源。使用时可以指定查找方向（祖先、同级元素等），它提供了更灵活的方式来绑定元素之间的关系。</p>
<p><strong>适用场景</strong>:</p>
<ul>
<li>需要绑定到和目标元素相关的父级、同级或子级元素。</li>
<li>适用于复杂的 UI 结构 或 在模板中需要从模板外部访问数据的情况。</li>
</ul>
<p>常规写法及完整展开如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Fill=&quot;&#123;Binding SelectionBrush, RelativeSource=&#123;RelativeSource TemplatedParent&#125;&#125;&quot; /&gt;</span><br><span class="line">&lt;!--可展开为--&gt;</span><br><span class="line">Fill=&quot;&#123;Binding RelativeSource=&#123;RelativeSource Mode=TemplatedParent&#125;,Path=SelectionBrush&#125;&quot; /&gt;</span><br></pre></td></tr></table></figure>

<h4 id="主要模式"><a href="#主要模式" class="headerlink" title="主要模式"></a>主要模式</h4><h5 id="Self模式"><a href="#Self模式" class="headerlink" title="Self模式"></a>Self模式</h5><p>绑定到自身，这种情况下，数据源就是绑定目标元素自己</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextBox Text=&quot;&#123;Binding RelativeSource=&#123;RelativeSource Self&#125;, Path=Tag&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>TextBox 的 Text 属性绑定到了自身的 Tag 属性</p>
<h5 id="TemplatedParent模式"><a href="#TemplatedParent模式" class="headerlink" title="TemplatedParent模式"></a>TemplatedParent模式</h5><p>绑定到控件模板的父元素，通常在 ControlTemplate 或 DataTemplate 中使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ControlTemplate TargetType=&quot;Button&quot;&gt;</span><br><span class="line">    &lt;TextBlock Text=&quot;&#123;Binding RelativeSource=&#123;RelativeSource TemplatedParent&#125;, Path=Content&#125;&quot;/&gt;</span><br><span class="line">&lt;/ControlTemplate&gt;</span><br></pre></td></tr></table></figure>

<p>这里 TextBlock 绑定到按钮的 Content 属性，这是因为 Button 是 ControlTemplate 的模板化父元素</p>
<h5 id="FindAncestor模式"><a href="#FindAncestor模式" class="headerlink" title="FindAncestor模式"></a>FindAncestor模式</h5><p>按照层次结构查找指定类型的祖先元素。常用于需要从父元素中获取属性的场景</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextBlock Text=&quot;&#123;Binding RelativeSource=&#123;RelativeSource FindAncestor, AncestorType=&#123;x:Type Window&#125;&#125;, Path=Title&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>这里 TextBlock 的 Text 绑定到了最近的 Window 祖先的 Title 属性</p>
<h5 id="PreviousData模式"><a href="#PreviousData模式" class="headerlink" title="PreviousData模式"></a>PreviousData模式</h5><p>PreviousData 模式用于绑定到数据绑定集合（如 ItemsControl、ListBox 等）中的上一个数据项。这个模式通常在集合控件的模板中使用，用于访问前一项的数据。它允许你在当前项目的绑定上下文中引用上一个数据对象的属性值</p>
<p><strong>适用场景</strong>: PreviousData 主要用于模板化控件（如 ItemsControl、ListBox 或 DataGrid）中的 ItemTemplate，让你在当前项的模板中能够绑定到前一项的数据对象。这在需要上下文关联的绑定时比较有用，例如你需要根据前一项的数据来展示当前项的样式或行为时</p>
<p>特点:</p>
<ul>
<li>PreviousData 模式只在模板化控件的数据绑定中有意义，比如 ItemsControl、ListBox、DataGrid。</li>
<li>它让你在模板内的当前数据项中可以引用前一项的数据。</li>
<li>如果<strong>当前项是集合中的第一个项，则没有上一个数据项，绑定会返回 null，需要考虑这种情况</strong>。</li>
</ul>
<p>假设我们有一个 ListBox 控件，里面显示一组数字。如果我们希望每个项能够显示当前数字以及前一个数字的和，我们可以使用 RelativeSource.PreviousData 进行绑定</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;ListBox ItemsSource=&quot;&#123;Binding Numbers&#125;&quot;&gt;</span><br><span class="line">    &lt;ListBox.ItemTemplate&gt;</span><br><span class="line">        &lt;DataTemplate&gt;</span><br><span class="line">            &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt;</span><br><span class="line">                  &lt;!--绑定到Numbers中的单个元素使用&#123;Binding .&#125;--&gt;</span><br><span class="line">                &lt;TextBlock Text=&quot;&#123;Binding .&#125;&quot; /&gt;</span><br><span class="line">                &lt;TextBlock Text=&quot; + &quot; /&gt;</span><br><span class="line">                &lt;TextBlock Text=&quot;&#123;Binding DataContext, RelativeSource=&#123;RelativeSource Mode=PreviousData&#125;&#125;&quot; /&gt;</span><br><span class="line">            &lt;/StackPanel&gt;</span><br><span class="line">        &lt;/DataTemplate&gt;</span><br><span class="line">    &lt;/ListBox.ItemTemplate&gt;</span><br><span class="line">&lt;/ListBox&gt;</span><br></pre></td></tr></table></figure>

<p><strong>带边界处理的案例</strong></p>
<p>这个示例展示了如何使用 PreviousData 绑定到前一项的数据，并通过 DataTrigger 来处理边界情况，即当没有前一个数据时（如在第一项上），显示替代文本 “N&#x2F;A”。这种边界处理在集合绑定和模板化控件中是常见需求</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;Window x:Class=&quot;PreviousDataExample.MainWindow&quot;</span><br><span class="line">        xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span><br><span class="line">        xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span><br><span class="line">        Title=&quot;PreviousData Example&quot; Height=&quot;350&quot; Width=&quot;525&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Window.DataContext&gt;</span><br><span class="line">        &lt;local:MainViewModel /&gt;</span><br><span class="line">    &lt;/Window.DataContext&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Grid&gt;</span><br><span class="line">        &lt;ListBox ItemsSource=&quot;&#123;Binding Numbers&#125;&quot;&gt;</span><br><span class="line">            &lt;ListBox.ItemTemplate&gt;</span><br><span class="line">                &lt;DataTemplate&gt;</span><br><span class="line">                    &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt;</span><br><span class="line">                        &lt;!-- 当前项的数字 --&gt;</span><br><span class="line">                        &lt;TextBlock Text=&quot;&#123;Binding&#125;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">                        &lt;!-- 前一个项的数字，带有边界处理 --&gt;</span><br><span class="line">                        &lt;TextBlock Text=&quot; (Previous: &quot; /&gt;</span><br><span class="line">                        &lt;TextBlock&gt;</span><br><span class="line">                            &lt;TextBlock.Style&gt;</span><br><span class="line">                                &lt;Style TargetType=&quot;TextBlock&quot;&gt;</span><br><span class="line">                                    &lt;Setter Property=&quot;Text&quot; Value=&quot;&#123;Binding DataContext, RelativeSource=&#123;RelativeSource Mode=PreviousData&#125;&#125;&quot; /&gt;</span><br><span class="line">                                    &lt;Style.Triggers&gt;</span><br><span class="line">                                        &lt;!-- 如果前一项不存在（null），显示 &#x27;N/A&#x27; --&gt;</span><br><span class="line">                                        &lt;DataTrigger Binding=&quot;&#123;Binding DataContext, RelativeSource=&#123;RelativeSource Mode=PreviousData&#125;&#125;&quot; Value=&quot;&#123;x:Null&#125;&quot;&gt;</span><br><span class="line">                                            &lt;Setter Property=&quot;Text&quot; Value=&quot;N/A&quot; /&gt;</span><br><span class="line">                                        &lt;/DataTrigger&gt;</span><br><span class="line">                                    &lt;/Style.Triggers&gt;</span><br><span class="line">                                &lt;/Style&gt;</span><br><span class="line">                            &lt;/TextBlock.Style&gt;</span><br><span class="line">                        &lt;/TextBlock&gt;</span><br><span class="line">                        &lt;TextBlock Text=&quot;)&quot; /&gt;</span><br><span class="line">                    &lt;/StackPanel&gt;</span><br><span class="line">                &lt;/DataTemplate&gt;</span><br><span class="line">            &lt;/ListBox.ItemTemplate&gt;</span><br><span class="line">        &lt;/ListBox&gt;</span><br><span class="line">    &lt;/Grid&gt;</span><br><span class="line">&lt;/Window&gt;</span><br></pre></td></tr></table></figure>

<p>将会显示为如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">10 (Previous: N/A)</span><br><span class="line">20 (Previous: 10)</span><br><span class="line">30 (Previous: 20)</span><br><span class="line">40 (Previous: 30)</span><br><span class="line">50 (Previous: 40)</span><br></pre></td></tr></table></figure>

<h2 id="控制绑定数据的显示格式"><a href="#控制绑定数据的显示格式" class="headerlink" title="控制绑定数据的显示格式"></a>控制绑定数据的显示格式</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextBlock Text=<span class="string">&quot;&#123;Binding HardwareManager.DoseControl.DoseControlData.CenterPos,StringFormat=&#123;&#125;&#123;0:0.000&#125;&#125;&quot;</span></span><br><span class="line">                                   VerticalAlignment=<span class="string">&quot;Center&quot;</span></span><br><span class="line">                                   Margin=<span class="string">&quot;5&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<p><code>StringFormat=&#123;&#125;&#123;0:0.000&#125;</code>：这是一个格式化字符串，用于指定如何显示绑定的数据。<code>&#123;0:0.000&#125;</code> 表示将数值格式化为小数点后三位的浮点数。</p>
<h2 id="数据校验与转换"><a href="#数据校验与转换" class="headerlink" title="数据校验与转换"></a>数据校验与转换</h2><p>若在数据传输的过程中，需要对数据进行限制，可以在Binding上设置数据校验；若要对数据类型进行转换，可以在Binding上设置数据转换，编写数据转换器。WPF在Binding上提供了<a href="Validation">Validation</a>进行校验，<a href="#Convert">Converter</a>进行转换。</p>
<p>WPF提供了两种数据转化的方式</p>
<ul>
<li><strong>值转换器方法（Converter）</strong>，绑定后，触发转换器，转换器负责把值转换成需要的内容。转换器需要实现System.Windows.Data命名空间的IValueConverter接口或IMultiValueConverter接口，分别用于单值转换和多值转换。转换器可以在XAML中定义为资源，并在绑定中引用。</li>
<li><strong>DataTrigger方法</strong>，直接在XAML里面对数据进行处理，展示所需要的内容。DataTrigger可以根据绑定的数据的值或条件来改变控件的属性或样式。DataTrigger可以在Style或ControlTemplate中定义。</li>
</ul>
<h3 id="Validation"><a href="#Validation" class="headerlink" title="Validation"></a>Validation</h3><p>Binding用于数据校验的属性是ValidationRules，在WPF中，要实现Binding的数据校验，需要以下几个步骤：</p>
<ol>
<li><p>定义一个继承自ValidationRule的类，重写其Validate方法，根据自己的逻辑和条件，返回一个ValidationResult对象，表示数据是否有效，以及无效时的错误信息。</p>
</li>
<li><p>在Binding对象中添加一个或多个ValidationRule对象，表示要对数据应用哪些校验规则。</p>
<p>可以设置ValidationRules属性的ValidatesOnTargetUpdated属性为true，表示要在目标更新时也进行校验。</p>
</li>
<li><p>在Binding对象中设置NotifyOnValidationError属性为true，表示当数据校验失败时，要通知绑定目标或其祖先元素。</p>
</li>
<li><p>编写校验失败时执行的事件处理器（方法），获取事件参数，获取错误信息，编写显示错误信息的代码或其它执行内容。</p>
</li>
<li><p>在目标或祖先元素上添加一个事件处理器，用于处理Validation.ErrorEvent事件，传入委托并指定方法。</p>
</li>
</ol>
<p>总结来说就是:</p>
<ol>
<li>编写校验规则类</li>
<li>为Binding添加校验规则</li>
<li>打开校验通知开关</li>
<li>编写校验失败事件处理器</li>
<li>处理校验失败事件</li>
</ol>
<p>优势: 使用WPF数据检验可以提高代码的质量和效率，增强用户体验和交互性。</p>
<ul>
<li>WPF数据检验将校验功能独立出来，可以将验证逻辑和视图逻辑分离，使得代码<br>更加清晰和可维护。</li>
<li>利用Binding对象的各种属性和事件，实现数据的自动更新和错误的通知。</li>
<li>数据检验可以使用不同的验证规则，实现不同的验证需求，使用预定好的类来编<br>写验证功能更加规范和方便。也可以为一个绑定添加多个规则，实现重用。</li>
<li>WPF数据检验可以使用ErrorTemplate属性，实现对验证失败时的视觉反馈，例<br>如显示红色的感叹号或边框等。</li>
</ul>
<h4 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;Window x:Class=&quot;WpfValidationExample.MainWindow&quot;</span><br><span class="line">        xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span><br><span class="line">        xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span><br><span class="line">        Title=&quot;WPF Validation Example&quot; Height=&quot;200&quot; Width=&quot;300&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Grid&gt;</span><br><span class="line">        &lt;!-- 标签 --&gt;</span><br><span class="line">        &lt;Label Content=&quot;Enter a number:&quot; HorizontalAlignment=&quot;Left&quot; VerticalAlignment=&quot;Top&quot; Margin=&quot;20,20,0,0&quot;/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 文本框，用于输入数字，绑定到属性，启用验证 --&gt;</span><br><span class="line">        &lt;TextBox Name=&quot;NumberTextBox&quot; HorizontalAlignment=&quot;Left&quot; VerticalAlignment=&quot;Top&quot; </span><br><span class="line">                 Margin=&quot;20,50,0,0&quot; Width=&quot;240&quot; Validation.ErrorTemplate=&quot;&#123;StaticResource ValidationTemplate&#125;&quot;&gt;</span><br><span class="line">            &lt;TextBox.Text&gt;</span><br><span class="line">                &lt;Binding Path=&quot;InputNumber&quot; UpdateSourceTrigger=&quot;PropertyChanged&quot;&gt;</span><br><span class="line">                    &lt;Binding.ValidationRules&gt;</span><br><span class="line">                        &lt;!-- 验证规则：输入的内容必须是有效数字 --&gt;</span><br><span class="line">                        &lt;local:NumericValidationRule/&gt;</span><br><span class="line">                    &lt;/Binding.ValidationRules&gt;</span><br><span class="line">                &lt;/Binding&gt;</span><br><span class="line">            &lt;/TextBox.Text&gt;</span><br><span class="line">        &lt;/TextBox&gt;</span><br><span class="line"></span><br><span class="line">         &lt;!-- 错误提示区域 --&gt;</span><br><span class="line">        &lt;TextBlock Foreground=&quot;Red&quot; Margin=&quot;20,90,0,0&quot; Text=&quot;&#123;Binding ElementName=NumberTextBox, Path=(Validation.Errors), Converter=&#123;StaticResource ErrorToStringConverter&#125;&#125;&quot;/&gt;</span><br><span class="line">    &lt;/Grid&gt;</span><br><span class="line">&lt;/Window&gt;</span><br></pre></td></tr></table></figure>

<p>**创建一个自定义的验证规则 **  NumericValidationRule</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Globalization;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Controls;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">WpfValidationExample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NumericValidationRule</span> : <span class="title">ValidationRule</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> ValidationResult <span class="title">Validate</span>(<span class="params"><span class="built_in">object</span> <span class="keyword">value</span>, CultureInfo cultureInfo</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 检查输入是否为空</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">value</span> == <span class="literal">null</span> || <span class="built_in">string</span>.IsNullOrWhiteSpace(<span class="keyword">value</span>.ToString()))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ValidationResult(<span class="literal">false</span>, <span class="string">&quot;Input cannot be empty.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 尝试将输入转换为数字</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">double</span>.TryParse(<span class="keyword">value</span>.ToString(), <span class="keyword">out</span> _))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> ValidationResult.ValidResult;<span class="comment">//返回默认校验结果为true的ValidationResult对象</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ValidationResult(<span class="literal">false</span>, <span class="string">&quot;Please enter a valid number.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MVVM架构中通过错误转换器,创建一个 IValueConverter，将 Validation.Errors 转换为可显示的错误信息</p>
<p>转换器代码如下:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Globalization;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Data;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Controls;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">WpfValidationExample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ErrorToStringConverter</span> : <span class="title">IValueConverter</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">Convert</span>(<span class="params"><span class="built_in">object</span> <span class="keyword">value</span>, Type targetType, <span class="built_in">object</span> parameter, CultureInfo culture</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> validationErrors = <span class="keyword">value</span> <span class="keyword">as</span> System.Collections.Generic.IEnumerable&lt;ValidationError&gt;;</span><br><span class="line">            <span class="keyword">return</span> validationErrors?.FirstOrDefault()?.ErrorContent?.ToString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">ConvertBack</span>(<span class="params"><span class="built_in">object</span> <span class="keyword">value</span>, Type targetType, <span class="built_in">object</span> parameter, CultureInfo culture</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="INotifyDataErrorInfo"><a href="#INotifyDataErrorInfo" class="headerlink" title="INotifyDataErrorInfo"></a>INotifyDataErrorInfo</h3><p>INotifyDataErrorInfo 提供了一个灵活的机制来管理模型中的错误</p>
<p><strong>INotifyDataErrorInfo</strong> 是一个接口，主要用于在 MVVM 架构中管理和处理数据模型的验证错误。它允许你在视图模型中集中管理错误，并通过事件通知机制将错误反馈给视图层。在 WPF 中，当你需要在数据绑定时显示错误或验证输入时，<strong>INotifyDataErrorInfo</strong> 是一个非常有用的工具。</p>
<ul>
<li><strong>ValidationRule</strong> 更适合在控件级别执行单一字段的验证</li>
<li>而 <strong>INotifyDataErrorInfo</strong> 可以在视图模型中集中处理多字段验证</li>
</ul>
<p>INotifyDataErrorInfo 接口包含以下重要成员：</p>
<ul>
<li><code>HasErrors</code>：返回模型是否有任何验证错误。</li>
<li>**<code>GetErrors(string propertyName)</code>**：返回指定属性的错误列表。</li>
<li><code>ErrorsChanged</code>：当某个属性的错误发生变化时，触发此事件。</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.ComponentModel;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">WpfValidationExample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MainViewModel</span> : <span class="title">INotifyPropertyChanged</span>, <span class="title">INotifyDataErrorInfo</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">string</span> _inputNumber;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数据属性</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> InputNumber</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span> =&gt; _inputNumber;</span><br><span class="line">            <span class="keyword">set</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (_inputNumber != <span class="keyword">value</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    _inputNumber = <span class="keyword">value</span>;</span><br><span class="line">                    OnPropertyChanged(<span class="keyword">nameof</span>(InputNumber));</span><br><span class="line">                    ValidateInputNumber();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储错误信息的字典</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> Dictionary&lt;<span class="built_in">string</span>, List&lt;<span class="built_in">string</span>&gt;&gt; _errors = <span class="keyword">new</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查是否有错误</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">bool</span> HasErrors =&gt; _errors.Any(e =&gt; e.Value.Any());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取指定属性的错误信息</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> IEnumerable&lt;<span class="built_in">string</span>&gt; <span class="title">GetErrors</span>(<span class="params"><span class="built_in">string</span> propertyName</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> _errors.ContainsKey(propertyName) ? _errors[propertyName] : <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 验证逻辑</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ValidateInputNumber</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 清除错误</span></span><br><span class="line">            ClearErrors(<span class="keyword">nameof</span>(InputNumber));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 验证输入是否为空</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrWhiteSpace(InputNumber))</span><br><span class="line">            &#123;</span><br><span class="line">                AddError(<span class="keyword">nameof</span>(InputNumber), <span class="string">&quot;Input cannot be empty.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 验证是否为有效数字</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">double</span>.TryParse(InputNumber, <span class="keyword">out</span> _))</span><br><span class="line">            &#123;</span><br><span class="line">                AddError(<span class="keyword">nameof</span>(InputNumber), <span class="string">&quot;Please enter a valid number.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加错误</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddError</span>(<span class="params"><span class="built_in">string</span> propertyName, <span class="built_in">string</span> error</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!_errors.ContainsKey(propertyName))</span><br><span class="line">            &#123;</span><br><span class="line">                _errors[propertyName] = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            _errors[propertyName].Add(error);</span><br><span class="line">            OnErrorsChanged(propertyName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清除错误</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ClearErrors</span>(<span class="params"><span class="built_in">string</span> propertyName</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (_errors.ContainsKey(propertyName))</span><br><span class="line">            &#123;</span><br><span class="line">                _errors[propertyName].Clear();</span><br><span class="line">                OnErrorsChanged(propertyName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 触发属性变化事件</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">event</span> PropertyChangedEventHandler PropertyChanged;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnPropertyChanged</span>(<span class="params"><span class="built_in">string</span> propertyName</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            PropertyChanged?.Invoke(<span class="keyword">this</span>, <span class="keyword">new</span> PropertyChangedEventArgs(propertyName));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 触发错误变化事件</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">event</span> EventHandler&lt;DataErrorsChangedEventArgs&gt; ErrorsChanged;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnErrorsChanged</span>(<span class="params"><span class="built_in">string</span> propertyName</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            ErrorsChanged?.Invoke(<span class="keyword">this</span>, <span class="keyword">new</span> DataErrorsChangedEventArgs(propertyName));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Convert"><a href="#Convert" class="headerlink" title="Convert"></a>Convert</h3><p>Convert可以将源数据和目标数据之间进行特定的转化。定义转换器，需要继承接口IValueConverter</p>
<p>下图的vm指的是<a href="#MVVM%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84">ViewModel</a></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202406141756474.png" alt="iShot_2024-06-13_15.08.31" style="zoom: 33%;" />

<p>当我们遇到需要自行编写转换器的情况时，我们需要创建一个类并让这个类实现<br>IValueConverter接口，该接口的定义如下，当数据从源流向目标时，<code>Convert()</code>方法会被调用，反之调用 <code>ConvertBack()</code></p>
<ul>
<li><code>Convert</code>: 会进行源属性传给目标属性的特定转化</li>
<li><code>ConvertBack</code>: 会进行目标属性传给源属性的特定转化</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ForeColorConverter</span> : <span class="title">IValueConverter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 源属性传给目标属性时，调用此方法 Convert</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">Convert</span>(<span class="params"><span class="built_in">object</span> <span class="keyword">value</span>, Type targetType, <span class="built_in">object</span> parameter, CultureInfo culture</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 这里应该实现转换逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目标属性传给源属性时，调用此方法 ConvertBack</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">ConvertBack</span>(<span class="params"><span class="built_in">object</span> <span class="keyword">value</span>, Type targetType, <span class="built_in">object</span> parameter, CultureInfo culture</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 这里应该实现反向转换逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如说实现一个根据bool值转换成前景色</p>
<h4 id="案例-3"><a href="#案例-3" class="headerlink" title="案例"></a>案例</h4><p><strong>一个用于反转布尔值的值转换器</strong></p>
<p>创建一个新的 C# 文件， Converters&#x2F;InverseBooleanConverter.cs，并添加以下代码：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Globalization;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">YourNamespace.Converters</span></span><br><span class="line">&#123;</span><br><span class="line">      <span class="comment">//需要实现IValueConverter的接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">InverseBooleanConverter</span> : <span class="title">IValueConverter</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">Convert</span>(<span class="params"><span class="built_in">object</span> <span class="keyword">value</span>, Type targetType, <span class="built_in">object</span> parameter, CultureInfo culture</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">value</span> <span class="keyword">is</span> <span class="built_in">bool</span> boolean)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> !boolean;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">ConvertBack</span>(<span class="params"><span class="built_in">object</span> <span class="keyword">value</span>, Type targetType, <span class="built_in">object</span> parameter, CultureInfo culture</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">value</span> <span class="keyword">is</span> <span class="built_in">bool</span> boolean)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> !boolean;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 XAML 中使用 InverseBooleanConverter<br>接下来，在 XAML 文件中使用这个转换器。首先，需要在 XAML 文件的资源字典中定义这个转换器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;Window x:Class=&quot;YourNamespace.YourWindow&quot;</span><br><span class="line">        xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span><br><span class="line">        xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span><br><span class="line">        xmlns:local=&quot;clr-namespace:YourNamespace.Converters&quot;&gt;</span><br><span class="line">    &lt;Window.Resources&gt;</span><br><span class="line">        &lt;local:InverseBooleanConverter x:Key=&quot;InverseBooleanConverter&quot;/&gt;</span><br><span class="line">    &lt;/Window.Resources&gt;</span><br><span class="line">    &lt;!-- 其他 XAML 代码 --&gt;</span><br><span class="line">&lt;/Window&gt;</span><br></pre></td></tr></table></figure>

<p>使用转换器用法如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;CheckBox Content=&quot;示例复选框&quot;</span><br><span class="line">          IsChecked=&quot;&#123;Binding SomeBooleanProperty, Converter=&#123;StaticResource InverseBooleanConverter&#125;&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h2 id="多重绑定"><a href="#多重绑定" class="headerlink" title="多重绑定"></a>多重绑定</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;cc:InfoShowGridUnit.ShowStrings&gt;</span><br><span class="line">  &lt;MultiBinding Converter=&quot;&#123;StaticResource MultiValueConverter&#125;&quot;&gt;</span><br><span class="line">    &lt;Binding Path=&quot;ShowStrings[0]&quot; /&gt;</span><br><span class="line">    &lt;Binding Path=&quot;ShowStrings[1&quot; /&gt;</span><br><span class="line">  &lt;/MultiBinding&gt;</span><br><span class="line">&lt;/cc:InfoShowGridUnit.ShowStrings&gt;</span><br></pre></td></tr></table></figure>

<p>多重绑定不能嵌套</p>
<p>但多重绑定下的每个绑定也可以设置转换器</p>
<h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><p>为了把业务都整合放到ViewModel中,因此不仅希望属性绑定,还希望事件也能实现类似的效果,<strong>命令</strong>正是为此诞生的</p>
<p>命令由许多可变的部分组成，但它们都具有以下4个重要元素：</p>
<ul>
<li><strong>命令</strong>：命令表示应用程序任务，并且跟踪任务是否能够被执行。然而，命令实际上不包含执行应用程序任务的代码。</li>
<li><strong>命令绑定</strong>：每个命令绑定针对用户界面的具体元素，将命令连接到相关的应用程序逻辑。这种分解的设计是非常重要的，因为单个命令可用于应用程序中的多个地方，并且在每个地方具有不同的意义。为处理这一问题，需要将同一命令与不同的命令绑定。</li>
<li><strong>命令源</strong>：命令源触发命令。例如，button就是命令源。单击它们都会执行绑定命令。</li>
<li><strong>命令目标</strong>：命令目标是在执行过程中涉及到的其他元素。</li>
</ul>
<h2 id="命令详解"><a href="#命令详解" class="headerlink" title="命令详解"></a>命令详解</h2><ul>
<li>命令对象:代表一个具体的可执行操作,通常具有名称,执行逻辑等属性</li>
<li>命令的绑定:通用讲命令与控件进行绑定,使控件可以响应命令.在意在XAML中直接设置控件的Command属性来建立绑定关系</li>
<li>命令的执行:当满足触发条件时(如按钮点击等),相应的命令被执行,执行逻辑可以在代码中自定义编写</li>
<li>命令的启用&#x2F;禁用状态: 可以根据特定条件动态控制命令是否可用,比如某些操作在特定场景下不可用</li>
<li>命令路由:命令在控件层次结构中传播和处理,允许父控件或更高级别的元素也能对命令做出响应</li>
</ul>
<h2 id="如何实现一个命令"><a href="#如何实现一个命令" class="headerlink" title="如何实现一个命令"></a>如何实现一个命令</h2><h3 id="ICommand"><a href="#ICommand" class="headerlink" title="ICommand"></a>ICommand</h3><p>WPF命令的核心是System.Windows.Input.ICommand接口,该接口定义了命令的工作原理.该接口包含两个方法和一个事件</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICommand</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//包含引用程序的任务逻辑</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"><span class="built_in">object</span> parameter</span>)</span>;</span><br><span class="line">    <span class="comment">//返回命令的状态,可用为true,不可用为false;</span></span><br><span class="line">    <span class="function"><span class="built_in">bool</span> <span class="title">Canexecute</span>(<span class="params"><span class="built_in">object</span> parameter</span>)</span>;</span><br><span class="line">    <span class="comment">//当命令状态改变时引发该事件.对于使用命令的任何控件,这是指示信号,表示他们应当调用CanExecute方法检查命令的状态.通过使用该事件,当命令可用时,命令源(如button)可自动启用自身;当命令不可用时,禁用自身</span></span><br><span class="line">    <span class="keyword">event</span> EventHandler CanExecuteChanged;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Execute和Canexecute方法都接受一个附加的对象参数,可使用该对象传递所需的任何附加信息</span></span><br></pre></td></tr></table></figure>

<p>可以直接使用RoutedCommand触发无参的命令</p>
<p>如果需要传一个参,可构造如下:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomCommand</span>&lt;<span class="title">T</span>&gt; : <span class="title">ICommand</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> Action&lt;T&gt; action;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomCommand</span>(<span class="params">Action&lt;T&gt; action</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.action = action;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">CanExecute</span>(<span class="params"><span class="built_in">object</span> parameter</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler CanExecuteChanged;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"><span class="built_in">object</span> parameter</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        action((T)parameter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Input;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">testGrid</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RelayCommand</span>&lt;<span class="title">T</span>&gt; : <span class="title">ICommand</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> Action&lt;T&gt; _execute;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> Predicate&lt;T&gt; _canExecute;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">RelayCommand</span>(<span class="params">Action&lt;T&gt; execute, Predicate&lt;T&gt; canExecute = <span class="literal">null</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            _execute = execute ?? <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(execute));</span><br><span class="line">            _canExecute = canExecute;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">CanExecute</span>(<span class="params"><span class="built_in">object</span> parameter</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> _canExecute?.Invoke((T)parameter) ?? <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"><span class="built_in">object</span> parameter</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            _execute((T)parameter);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">event</span> EventHandler CanExecuteChanged</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">add</span> &#123; CommandManager.RequerySuggested += <span class="keyword">value</span>; &#125;</span><br><span class="line">            <span class="keyword">remove</span> &#123; CommandManager.RequerySuggested -= <span class="keyword">value</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="如何让控件支持命令"><a href="#如何让控件支持命令" class="headerlink" title="如何让控件支持命令"></a>如何让控件支持命令</h2><p>支持命令的实现是在”命令源”这个环节实现的,即要让某个元素能够作为命令的发起源并执行相关操作，就需要在这个元素上实现 <code>ICommandSource</code> 接口。这个接口定义了与命令相关的一些必要属性和方法。.不是每个控件都直接支持command绑定的,需要将他们关联到实现了 <code>ICommandSource</code>接口的控件</p>
<p>天然实现了 <code>ICommandSource</code> 接口的控件包括继承自ButtonBase类的控件(button和Checkbox等).它们可以直接作为命令源来进行命令的绑定和操作，这是因为这些控件的本质特性决定了它们在交互中常常扮演着触发命令的角色。</p>
<h3 id="ICommandSource"><a href="#ICommandSource" class="headerlink" title="ICommandSource"></a>ICommandSource</h3><p>定义了三个属性</p>
<ul>
<li><code>Command</code> 指向连接的命令,这是<strong>唯一必须</strong>的细节</li>
<li><code>CommandParamter</code>: 提供其他希望随命令发送的数据</li>
<li><code>CommandTarget</code>: 确定将在其中执行命令的元素</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button</span><br><span class="line">        Width=&quot;200&quot;</span><br><span class="line">        Height=&quot;30&quot;</span><br><span class="line">        Margin=&quot;3&quot;</span><br><span class="line">        Command=&quot;&#123;Binding CancelRemberCommand&#125;&quot;</span><br><span class="line">        CommandParameter=&quot;&#123;Binding ElementName=ChkboxPwd,Path=IsChecked&#125;&quot;</span><br><span class="line">        Content=&quot;检查&quot;/&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ElementName 是一个标记扩展，它允许您引用 XAML 中定义的其他控件。Path表示控件下的哪个属性</p>
</blockquote>
<h2 id="开发者如何使用"><a href="#开发者如何使用" class="headerlink" title="开发者如何使用"></a>开发者如何使用</h2><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>定义一个自己的针对Command类型,支持针对一个参数的泛型类型</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomCommand</span>&lt;<span class="title">T</span>&gt; : <span class="title">ICommand</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> Action&lt;T&gt; action;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomCommand</span>(<span class="params">Action&lt;T&gt; action</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.action = action;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">CanExecute</span>(<span class="params"><span class="built_in">object</span> parameter</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler CanExecuteChanged;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"><span class="built_in">object</span> parameter</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        action((T)parameter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用该类型</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CancelAction是定义好的方法,这里的参数是下面的CommandParameter传过来的,即chkboxPwd.IsChecked传过来了</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CancelAction</span>(<span class="params"><span class="built_in">bool</span> obj</span>)</span>&#123;</span><br><span class="line">    MessageBox.Show(<span class="string">$&quot;check status <span class="subst">&#123;obj&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先定义一个成员:</span></span><br><span class="line"><span class="keyword">public</span> ICommand CancelRemberCommand = <span class="keyword">new</span> CustomCommand&lt;<span class="built_in">bool</span>&gt;(CancelAction);</span><br><span class="line"><span class="comment">//这样去构造</span></span><br><span class="line">CancelRemberCommand = <span class="keyword">new</span> RelayCommand&lt;<span class="built_in">bool</span>&gt;(CancelAction);</span><br></pre></td></tr></table></figure>

<p>在yaml中这样去连接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button</span><br><span class="line">        Width=&quot;200&quot;</span><br><span class="line">        Height=&quot;30&quot;</span><br><span class="line">        Margin=&quot;3&quot;</span><br><span class="line">        Command=&quot;&#123;Binding CancelRemberCommand&#125;&quot;</span><br><span class="line">        CommandParameter=&quot;&#123;Binding ElementName=ChkboxPwd,Path=IsChecked&#125;&quot;</span><br><span class="line">        Content=&quot;检查&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>上面的部分也可以用如下c#代码实现来代替,如下:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设这个button1就是上面的button</span></span><br><span class="line">button1.Command = CancelRemberCommand;</span><br><span class="line">button1.CommandTarget = ChkboxPwd;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p>这样,当点击该button的时候,就会自动调用CancelAction函数了</p>
<p>就像前面说的,这里之所以能这样去使用,有一个隐含的条件是在于button已经实现了<a href="#ICommandSource">ICommandSource接口</a>,才可以这样用</p>
<p>p.s. 目前来看,这样开发比事件驱动要麻烦,但长远考虑更好</p>
<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><blockquote>
<p>事件和命令是两种处理用户交互的机制</p>
<ul>
<li>事件: 是一种传统的.net机制,允许一个对象通知另一个对象发生了某种情况</li>
<li>命令: 是一种更高级的机制,一个对象请求另一个对象执行某种任务,并且可以跟踪该任务是否可以执行</li>
</ul>
</blockquote>
<h2 id="事件处理机制模型"><a href="#事件处理机制模型" class="headerlink" title="事件处理机制模型"></a>事件处理机制模型</h2><p>WPF应用程序开发人员和组件创建者可以使用<strong>路由事件</strong>，通过元素树来传播事件，并在树中的多个侦听器上调用事件处理程序。公共语言运行时 事件（CLR事件，也称作直接事件），没有这些功能。</p>
<h3 id="直接事件"><a href="#直接事件" class="headerlink" title="直接事件"></a>直接事件</h3><p>直接事件的前身是<strong>消息机制</strong>,事件模型隐藏了消息机制的很多细节,使得开发逻辑变得简单</p>
<ul>
<li>事件的拥有者：也就是消息的发送者（Sender）。事件的宿主在某些条件下激发它拥有的事件，触发后使得消息被发送。</li>
<li>事件的响应者：将消息接收和处理，使用事件处理器（Event Handler）进行响应。</li>
<li>事件的订阅：事件的响应者需要订阅事件才能实现事件从触发到处理的完整过程。</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202409021746507.png" alt="image-20240902174655806" style="zoom: 25%;" />

<p>E.g. 在一个窗体上有一个按钮Button_1和一个文本框TextBox_1，按下按钮后，文本框出现文字“Hello World！”</p>
<ul>
<li>事件的拥有者：<code>Button_1</code></li>
<li>事件：<code>Button_1_Click</code></li>
<li>事件的响应者：<code>Window</code></li>
<li>事件处理器：<code>private void Button_1_Click(this.Button_1, EventArgs e)&#123;&#125;</code></li>
<li>订阅关系：<code>this.Button_1.CLick += new System.EventHandLer(this.Button_1_Click);</code></li>
</ul>
<p>直接事件的问题在于: 事件的拥有者和事件的响应者必须点对点建立订阅关系,也就是说,事件的拥有者必须能直接访问事件的响应者</p>
<h3 id="路由事件"><a href="#路由事件" class="headerlink" title="路由事件"></a>路由事件</h3><p>在路由事件中，事件的拥有者和响应者之间没有直接显式的订阅关系，<strong>事件的拥有者只负责激发事件</strong>，事件由谁进行响应它并不关心，<strong>事件的响应者通过事件侦听器针对某一类事件进行监听</strong>，当监听到有事件传递过来时，就可以使用事件处理器来响应事件，并决定事件是否继续传递给其他对象。</p>
<p>需要先了解<a href="#%E9%80%BB%E8%BE%91%E6%A0%91%E4%B8%8E%E8%A7%86%E8%A7%89%E6%A0%91">逻辑树与视觉树</a></p>
<p><a target="_blank" rel="noopener" href="https://www.dotnetinterviewquestions.in/article_explain-routed-events-in-wpf-c-wpf-interview-questions-with-answers_194.html">详细解释可以参考此处</a></p>
<p>WPF事件可以分为3种类型</p>
<blockquote>
<p>事件的触发顺序是：<strong>隧道事件 → 直接事件 → 冒泡事件</strong>。</p>
</blockquote>
<ul>
<li><p><strong>直接事件</strong></p>
<p>事件在源头引发并在源头本身进行处理</p>
</li>
<li><p><strong>冒泡事件</strong></p>
<p>事件沿着视觉树层次向上传播.例如,”MouseDown”就是一个冒泡事件</p>
<p>从目标元素向根元素传播，父级控件可以在子控件处理完事件后进行处理</p>
</li>
<li><p><strong>隧道事件</strong></p>
<p>事件沿着视觉树层次结构向下传播.例如,”PreviewKeDown”是一个隧道事件</p>
<p>从根元素向目标元素传播，通常以 “Preview” 前缀命名。</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202501041654871.png" alt="image-20250104165405186"></p>
<p>假设有一个 <code>Window</code>，里面有一个 <code>StackPanel</code>，而 <code>StackPanel</code> 中有一个 <code>Button</code>。当用户点击 <code>Button</code> 时，事件的触发顺序如下：</p>
<ol>
<li><p><strong>隧道事件</strong>：</p>
<ul>
<li><code>Window</code>（根元素）接收到 <code>PreviewMouseDown</code></li>
<li><code>StackPanel</code> 接收到 <code>PreviewMouseDown</code></li>
<li><code>Button</code> 接收到 <code>PreviewMouseDown</code></li>
</ul>
</li>
<li><p><strong>直接事件</strong>：</p>
<ul>
<li><code>Button</code> 接收到 <code>Click</code> 事件</li>
</ul>
</li>
<li><p><strong>冒泡事件</strong>：</p>
<ul>
<li><code>Button</code> 接收到 <code>MouseDown</code></li>
<li><code>StackPanel</code> 接收到 <code>MouseDown</code></li>
<li><code>Window</code> 接收到 <code>MouseDown</code></li>
</ul>
</li>
</ol>
<p>在冒泡事件处理中取消事件继续处理方式如下:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">MouseLeftButtonUp</span>(<span class="params"><span class="built_in">object</span> sender,MouseButtonEventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    e.Handled = <span class="literal">true</span>;<span class="comment">//取消事件继续处理(隧道事件和冒泡事件都是这么处理)</span></span><br><span class="line">    <span class="comment">//其他处理...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但注意如果在隧道事件中设置了 <code>e.Handled = true</code>，那么该事件将不会继续传播到目标元素，导致目标元素的事件不会被触发。</p>
<h2 id="针对窗口的事件"><a href="#针对窗口的事件" class="headerlink" title="针对窗口的事件"></a>针对窗口的事件</h2><h3 id="WPF事件执行顺序"><a href="#WPF事件执行顺序" class="headerlink" title="WPF事件执行顺序"></a>WPF事件执行顺序</h3><ol>
<li>BeginInit 初始化开始</li>
<li>EndInit 初始化结束</li>
<li>OnInitialized 触发初始化时间</li>
<li>MeasureOverride 计算内部控件所需空间</li>
<li>ArrangeOverride 排列内部控件</li>
<li>GetLayoutClip 计算控件实际显示大小，如果元素大小超过可用的显示空间，将自动进行剪切</li>
<li>OnRender 渲染窗口</li>
<li>OnRenderSizeChanged 更新窗口的ActualHeight和ActualWidth</li>
<li>MeasureOverride</li>
<li>ArrangeOverride</li>
<li>Loaded 控件加载</li>
<li>OnContentRendered 内部渲染</li>
</ol>
<p><strong>Initialized</strong></p>
<p>触发时机: 当控件被初始化时触发。<br>说明: 这是控件的构造函数完成后立即触发的事件。此时控件的属性已经设置，但还没有加载到视觉树中。</p>
<p><strong>Initialized 事件是自底向上触发，先子后父</strong></p>
<p><strong>Loaded</strong></p>
<p>触发时机: 当控件及其<strong>所有子元素加载完成并添加到视觉树中时触发</strong>,所以在这里面查找控件可以到<a href="#%E8%A7%86%E8%A7%89%E6%A0%91">视觉树中查找</a>。<br>说明: 这是一个常用的事件，用于执行需要在控件加载完成后进行的初始化逻辑。</p>
<p><strong>Loaded事件是自顶向下以广播方式触发，从根节点，由父向子触发</strong></p>
<p>这个元素不仅被构造并初始化完成,布局也运行完毕,数据也绑上来了,它现在连到了渲染面上(rendering <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=surface&spm=1001.2101.3001.7020">surface</a>),马上就要被渲染的节奏.到这个时候,就可以通过 Loaded 事件从根元素开始画出整棵树. 这个事件与 IsLoaded 属性绑定.</p>
<p><strong>LayoutUpdated</strong></p>
<p>触发时机: 每次布局系统更新布局时触发。<br>说明: 这是一个频繁触发的事件，用于确保所有子元素都已加载并完成布局。可以用于在控件完全加载后执行逻辑。</p>
<p><strong>SizeChanged</strong></p>
<p>触发时机: 当控件的大小发生变化时触发。<br>说明: 这是一个在控件的 Width 或 Height 属性发生变化时触发的事件。<br>示例:</p>
<p><strong>DataContextChanged</strong></p>
<p>触发时机: 当控件的数据上下文发生变化时触发。<br>说明: 这是一个在控件的 DataContext 属性发生变化时触发的事件，通常用于处理数据绑定逻辑。</p>
<p><strong>Unloaded</strong></p>
<p>触发时机: 当控件及其所有子元素从视觉树中移除时触发。<br>说明: 这是一个在控件被卸载时触发的事件，通常用于清理资源或取消订阅事件。</p>
<p><strong>顺序盘点</strong></p>
<ol>
<li>控件初始化:<br>Initialized</li>
<li>控件加载:<br>Loaded</li>
<li>布局更新:<br>LayoutUpdated (可能多次触发)</li>
<li>大小变化:<br>SizeChanged (如果控件大小发生变化)</li>
<li>数据上下文变化:<br>DataContextChanged (如果数据上下文发生变化)</li>
<li>控件卸载:<br>Unloaded</li>
</ol>
<table>
<thead>
<tr>
<th>事件名称</th>
<th>事件描述</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Loaded</strong></td>
<td>窗口或页面完全加载后触发。</td>
<td>用于在 UI 准备好后执行初始化任务。</td>
</tr>
<tr>
<td><strong>Unloaded</strong></td>
<td>窗口或页面即将卸载时触发。</td>
<td>用于在 UI 被移除时执行清理任务。</td>
</tr>
<tr>
<td><strong>Initialized</strong></td>
<td>组件初始化时触发，在加载到视觉树之前。</td>
<td>用于在控件渲染之前执行操作。</td>
</tr>
<tr>
<td><strong>Activated</strong></td>
<td>窗口成为活动窗口时触发。</td>
<td>当窗口获得焦点时执行操作。</td>
</tr>
<tr>
<td><strong>Deactivated</strong></td>
<td>窗口失去焦点时触发。</td>
<td>当窗口不再是活动窗口时执行操作。</td>
</tr>
<tr>
<td><strong>Closing</strong></td>
<td>窗口关闭之前触发。</td>
<td>可以在此事件中取消窗口关闭或执行清理操作。</td>
</tr>
<tr>
<td><strong>Closed</strong></td>
<td>窗口关闭后触发。</td>
<td>用于在窗口关闭后执行最终清理操作。</td>
</tr>
<tr>
<td><strong>ContentRendered</strong></td>
<td>窗口内容渲染完成后触发。</td>
<td>用于依赖于内容完全渲染后的操作。</td>
</tr>
<tr>
<td><strong>StateChanged</strong></td>
<td>窗口状态改变时触发（例如，最小化、最大化）。</td>
<td>用于响应窗口状态变化。</td>
</tr>
<tr>
<td><strong>SizeChanged</strong></td>
<td>窗口大小改变时触发。</td>
<td>用于响应窗口大小调整事件。</td>
</tr>
<tr>
<td><strong>LocationChanged</strong></td>
<td>窗口位置改变时触发。</td>
<td>用于响应窗口位置变化。</td>
</tr>
<tr>
<td><strong>KeyDown</strong></td>
<td>窗口获得焦点时按下键盘按键时触发。</td>
<td>用于处理键盘输入。</td>
</tr>
<tr>
<td><strong>KeyUp</strong></td>
<td>窗口获得焦点时释放键盘按键时触发。</td>
<td>用于处理键盘输入。</td>
</tr>
</tbody></table>
<p>Loaded:窗口或页面完全加载并即将显示时触发</p>
<p>Unloaded:在窗口或页面即将卸载或关闭时触发</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">xmlns:i=<span class="string">&quot;http://schemas.microsoft.com/xaml/behaviors&quot;</span></span><br><span class="line">&lt;!--接到上面的命名空间后--&gt;</span><br><span class="line">    &lt;i:Interaction.Triggers&gt;   </span><br><span class="line">        &lt;i:EventTrigger EventName=<span class="string">&quot;Loaded&quot;</span>&gt;</span><br><span class="line">            &lt;i:InvokeCommandAction Command=<span class="string">&quot;&#123;Binding LoadedCommand&#125;&quot;</span>/&gt;</span><br><span class="line">        &lt;/i:EventTrigger&gt;</span><br><span class="line">        &lt;i:EventTrigger EventName=<span class="string">&quot;Unloaded&quot;</span>&gt;</span><br><span class="line">            &lt;i:InvokeCommandAction Command=<span class="string">&quot;&#123;Binding UnloadedCommand&#125;&quot;</span>/&gt;</span><br><span class="line">        &lt;/i:EventTrigger&gt;</span><br><span class="line">    &lt;/i:Interaction.Triggers&gt;</span><br></pre></td></tr></table></figure>

<h2 id="针对控件和元素的事件"><a href="#针对控件和元素的事件" class="headerlink" title="针对控件和元素的事件"></a>针对控件和元素的事件</h2><table>
<thead>
<tr>
<th>事件名称</th>
<th>事件描述</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Click</strong></td>
<td>当用户点击按钮时触发。</td>
<td>用于按钮点击事件处理。</td>
</tr>
<tr>
<td><strong>MouseEnter</strong></td>
<td>当鼠标光标进入控件区域时触发。</td>
<td>用于实现鼠标悬停效果。</td>
</tr>
<tr>
<td><strong>MouseLeave</strong></td>
<td>当鼠标光标离开控件区域时触发。</td>
<td>用于实现鼠标离开效果。</td>
</tr>
<tr>
<td><strong>MouseMove</strong></td>
<td>当鼠标在控件上移动时触发。</td>
<td>用于实时响应鼠标移动事件。</td>
</tr>
<tr>
<td><strong>TextChanged</strong></td>
<td>当文本框中的文本发生变化时触发。</td>
<td>用于处理用户输入的文本变化。</td>
</tr>
<tr>
<td><strong>SelectionChanged</strong></td>
<td>当选择的项发生变化时触发（例如在列表框中）。</td>
<td>用于处理用户选择的变化。</td>
</tr>
<tr>
<td><strong>Checked</strong></td>
<td>当复选框被选中时触发。</td>
<td>用于处理复选框的选中状态。</td>
</tr>
<tr>
<td><strong>Unchecked</strong></td>
<td>当复选框被取消选中时触发。</td>
<td>用于处理复选框的取消选中状态。</td>
</tr>
<tr>
<td><strong>ValueChanged</strong></td>
<td>当滑块的值发生变化时触发。</td>
<td>用于处理滑块控件的值变化。</td>
</tr>
<tr>
<td><strong>Drop</strong></td>
<td>当拖放操作完成时触发。</td>
<td>用于处理拖放操作。</td>
</tr>
<tr>
<td><strong>GotFocus</strong></td>
<td>当控件获得焦点时触发。</td>
<td>用于处理控件获得焦点的事件。</td>
</tr>
<tr>
<td><strong>LostFocus</strong></td>
<td>当控件失去焦点时触发。</td>
<td>用于处理控件失去焦点的事件。</td>
</tr>
</tbody></table>
<h2 id="输入事件"><a href="#输入事件" class="headerlink" title="输入事件"></a>输入事件</h2><p>这些事件与用户输入相关，通常用于响应键盘或鼠标操作。</p>
<table>
<thead>
<tr>
<th>事件名称</th>
<th>事件描述</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>PreviewMouseDown</strong></td>
<td>在鼠标按下事件被处理之前触发。</td>
<td>用于在鼠标点击前执行一些操作。</td>
</tr>
<tr>
<td><strong>PreviewMouseUp</strong></td>
<td>在鼠标释放事件被处理之前触发。</td>
<td>用于在鼠标释放前执行一些操作。</td>
</tr>
<tr>
<td><strong>PreviewKeyDown</strong></td>
<td>在键盘按下事件被处理之前触发。</td>
<td>用于在键盘按下前执行一些操作。</td>
</tr>
<tr>
<td><strong>PreviewKeyUp</strong></td>
<td>在键盘释放事件被处理之前触发。</td>
<td>用于在键盘释放前执行一些操作。</td>
</tr>
</tbody></table>
<h2 id="焦点事件"><a href="#焦点事件" class="headerlink" title="焦点事件"></a>焦点事件</h2><p>这些事件与控件的焦点状态相关。</p>
<table>
<thead>
<tr>
<th>事件名称</th>
<th>事件描述</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>GotKeyboardFocus</strong></td>
<td>当控件获得键盘焦点时触发。</td>
<td>用于处理控件获得焦点的事件。</td>
</tr>
<tr>
<td><strong>LostKeyboardFocus</strong></td>
<td>当控件失去键盘焦点时触发。</td>
<td>用于处理控件失去焦点的事件。</td>
</tr>
</tbody></table>
<h2 id="布局事件"><a href="#布局事件" class="headerlink" title="布局事件"></a>布局事件</h2><p>这些事件与控件的布局和大小变化相关。</p>
<table>
<thead>
<tr>
<th>事件名称</th>
<th>事件描述</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>LayoutUpdated</strong></td>
<td>当布局更新完成时触发。</td>
<td>用于在布局更新后执行操作。</td>
</tr>
<tr>
<td><strong>SizeChanged</strong></td>
<td>当控件大小发生变化时触发。</td>
<td>用于响应控件的大小变化。</td>
</tr>
<tr>
<td><strong>LocationChanged</strong></td>
<td>当控件位置发生变化时触发。</td>
<td>用于响应控件位置变化。</td>
</tr>
</tbody></table>
<h2 id="数据事件"><a href="#数据事件" class="headerlink" title="数据事件"></a>数据事件</h2><p>这些事件与数据绑定和数据上下文相关。</p>
<table>
<thead>
<tr>
<th>事件名称</th>
<th>事件描述</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>DataContextChanged</strong></td>
<td>当控件的数据上下文发生变化时触发。</td>
<td>用于处理数据上下文变化的事件。</td>
</tr>
<tr>
<td><strong>BindingGroupChanged</strong></td>
<td>当绑定组发生变化时触发。</td>
<td>用于处理绑定组变化的事件。</td>
</tr>
</tbody></table>
<h1 id="MVVM项目架构"><a href="#MVVM项目架构" class="headerlink" title="MVVM项目架构"></a>MVVM项目架构</h1><p>[[开发项目管理#MVVM|MVVM详解]]</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202406121729466.png" alt="iShot_2024-06-12_16.55.10" style="zoom:33%;" />

<p>每个界面包括三个文件夹</p>
<ul>
<li>Models</li>
<li>ViewModels 可以理解成view的属性映射层</li>
<li>Views  这个里面可以放窗体可以放控件</li>
</ul>
<p>注意文件夹,文件的命名,每个文件的拜放都是有讲究的切忽乱放</p>
<p>ViewModel可以聚合N个Model,ViewModel可以对应多个View</p>
<p>App.xaml是程序启动的配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;Application x:Class=&quot;testWPF.App&quot;</span><br><span class="line">             xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span><br><span class="line">             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span><br><span class="line">             xmlns:local=&quot;clr-namespace:testWPF&quot;</span><br><span class="line">             StartupUri=&quot;MainWindow.xaml&quot;&gt;</span><br><span class="line">    &lt;Application.Resources&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/Application.Resources&gt;</span><br><span class="line">&lt;/Application&gt;</span><br></pre></td></tr></table></figure>

<p>如果需要更换起始运行窗体则需要修改 <code>StartupUri = &quot;Views/xxxView.xaml&quot;</code>即可(要注意这里是相对路径)</p>
<p>MainWindow.xaml主窗体的位置比较特殊,它可以单独游离在所有文件夹之外</p>
<h2 id="如何连接三种文件"><a href="#如何连接三种文件" class="headerlink" title="如何连接三种文件"></a>如何连接三种文件</h2><p>比如说有LoginView窗体类的构造函数中,通过 <code>DataContext = new LoginViewModel(this);</code>来连接LoginViewModel文件,所有的变量字段,命令,都定义在这个LoginViewModel中</p>
<p>在LoginViewModel中添加属性 <code>LoginModel model = new LoginModel();</code>(model 得存为一个属性)和LoginModel连接上</p>
<p>演变:</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202406141753344.png" alt="屏幕截图 2024-06-14 095350"  />

<p>上图是过渡方式,下图才是最终采纳的三种文件的关系图:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202406141754535.png" alt="屏幕截图 2024-06-14 095327"></p>
<h2 id="代码分离"><a href="#代码分离" class="headerlink" title="代码分离"></a>代码分离</h2><ul>
<li>Model   包含各种控件绑定的属性,需要支持</li>
<li>ViewModel  包含<a href="#%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%B8%8B%E6%96%87%E6%94%AF%E6%8C%81%E5%8F%98%E5%8C%96%E9%80%9A%E7%9F%A5">通知代码</a>,应含有属性Model和属性View,包含各种供绑定的属性接口与Model交互,也包含各种命令</li>
<li>View 构造函数中初始化DataContext为ViewModel(即所有的被绑定的命令和属性会到ViewModel中去找)</li>
</ul>
<p><strong>主要职责如下:</strong></p>
<p><strong>Model（模型层）</strong>：</p>
<ul>
<li>定义业务对象和数据模型。</li>
</ul>
<p><strong>ViewModel（视图模型层）</strong>：</p>
<ul>
<li>属性，用于绑定到视图。</li>
<li>命令，处理用户交互。</li>
<li>业务逻辑和数据验证。</li>
</ul>
<p><strong>View（视图层）</strong>：</p>
<ul>
<li>XAML 布局和控件定义。</li>
<li>数据绑定到 ViewModel 属性。</li>
</ul>
<h2 id="最小MVVM案例"><a href="#最小MVVM案例" class="headerlink" title="最小MVVM案例"></a>最小MVVM案例</h2><p>暂略(使用[[prism|prism框架]]实现MVVM要方便许多)</p>
<h2 id="事件驱动与数据驱动"><a href="#事件驱动与数据驱动" class="headerlink" title="事件驱动与数据驱动"></a>事件驱动与数据驱动</h2><h3 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h3><p>事件驱动通过“事件一订阅一事件处理”的关系组织应用程序。事件驱动下，用户进行每一个操作会激发程序发生的一个事件，事件发生后，用于响应事件的事件处理器就会执行。</p>
<p>事件驱动对应的表示模式正是<a href="#MVC">MVC</a></p>
<p>事件驱动下<strong>界面控件占主动地位</strong>的,界面逻辑与业务逻辑之间的<strong>桥梁是事件</strong>.界面逻辑和业务逻辑多多少少都会有关联性.数据是处于被动地位的,是静态的,等待着控件的事件去驱动他们,当事件逻辑变得多且复杂的时候,代码就会很容易变得复杂难懂,遇到bug的时候难以排除</p>
<h3 id="数据驱动"><a href="#数据驱动" class="headerlink" title="数据驱动"></a>数据驱动</h3><p>数据驱动的理念下，<strong>数据占主动地位</strong>，也就是由<strong>内容决定形式</strong>。数据驱动的<strong>桥梁是双向数据绑定</strong>，通过Data Binding可以实现数据流向界面，界面也可以将数据流回数据源。</p>
<p>当用户对控件进行操作带来数据变更时,通过双向数据绑定会更新在model中的数据.在这个过程中,<strong>控件和控件事件对程序的控制会被弱化</strong>,他们只参与页面逻辑而不再主导业务逻辑.可见在数据驱动的理念下,数据占主动地位,即由内容决定形式</p>
<h2 id="MVVM下代码操作控件"><a href="#MVVM下代码操作控件" class="headerlink" title="MVVM下代码操作控件"></a>MVVM下代码操作控件</h2><p><code>x:Name</code>必须是在xaml对应的后台vs文件中才能直接使用</p>
<p>而在 MVVM 模式中，视图模型（ViewModel）不直接操作视图（View）。但是，你可以通过绑定和命令来间接操作视图中的控件</p>
<p>可以通过Command</p>
<p>有些控件无法通过Command绑定命令的,可以通过双向绑定数据到一个属性,然后在属性的set方法中添加处理事件,如下:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此属性绑定是ComboBox的SelectedItem=&quot;&#123;Binding SelectedUser&#125;&quot;,这样变相绑定了命令</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">string</span> _SelectedUser;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> SelectedUser</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span> &#123; <span class="keyword">return</span> _SelectedUser; &#125;</span><br><span class="line">    <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (SetProperty(<span class="keyword">ref</span> _SelectedUser, <span class="keyword">value</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                FilterCommand.Execute();<span class="comment">//执行命令</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="behaviour"><a href="#behaviour" class="headerlink" title="behaviour"></a>behaviour</h3><p>Behavior 是一种可以附加到 WPF 控件的功能，它允许开发者将特定的交互逻辑封装在一个可重用的组件中。Behavior 使得控件能够以更灵活的方式响应用户输入和其他事件。</p>
<p><strong>功能</strong>：Behavior 可以封装各种功能，包括但不限于：</p>
<ul>
<li>响应事件（如点击、鼠标悬停等）</li>
<li>执行动作（如动画、数据绑定等）</li>
<li>处理输入（如拖放、键盘输入等）</li>
</ul>
<blockquote>
<p>XAML行为库（XAML Behaviors Library）是一组用于在XAML中实现交互式行为的库，它提供了一些附加功能和行为，如触发器（Triggers）、动作（Actions）、交互触发器（Interaction Triggers）等，用于简化在XAML中实现交互性功能的开发。</p>
<p>包含三个部分</p>
<ol>
<li><strong>Actions（动作）</strong>：<ul>
<li>Actions用于定义<strong>在触发器触发时要执行的操作或动作</strong>。例如，可以使用Action来执行命令、触发动画、导航到其他页面等。Actions通常与Triggers结合使用，以在特定条件下执行相应的操作。</li>
</ul>
</li>
<li><strong>Triggers（触发器）</strong>：<ul>
<li>Triggers<strong>用于定义触发某些操作或动作的条件或事件。当定义的条件或事件发生时，触发器会触发与之关联的操作（Action）</strong>。常见的触发器包括事件触发器（如Loaded、Click）、属性触发器（如属性值变化）等。</li>
</ul>
</li>
<li><strong>Interaction Triggers（交互触发器）</strong>：<ul>
<li>Interaction Triggers是XAML行为库中的一种特殊触发器，用于在XAML中实现交互性功能。它提供了一些特定的触发器类型，如EventTrigger、DataTrigger、PropertyChangedTrigger等，以便在特定事件发生或属性变化时执行相应的操作。</li>
</ul>
</li>
</ol>
</blockquote>
<h4 id="案例-4"><a href="#案例-4" class="headerlink" title="案例"></a>案例</h4><p>本质上通过注册事件来实现类似的效果</p>
<p>演示一个将事件接到viewmodel的案例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--添加此命名空间--&gt;</span><br><span class="line">xmlns:i=&quot;http://schemas.microsoft.com/xaml/behaviors&quot;</span><br><span class="line">&lt;!--给ComboBox控件的SelectionChanged事件绑定FilterCommand命令--&gt;</span><br><span class="line">&lt;i:Interaction.Triggers&gt;</span><br><span class="line">    &lt;i:EventTrigger EventName=&quot;SelectionChanged&quot;&gt;</span><br><span class="line">        &lt;i:InvokeCommandAction Command=&quot;&#123;Binding FilterCommand&#125;&quot;/&gt;</span><br><span class="line">    &lt;/i:EventTrigger&gt;</span><br><span class="line">&lt;/i:Interaction.Triggers&gt;</span><br></pre></td></tr></table></figure>

<p>触发事件后直接修改样式案例:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;i:Interaction.Triggers&gt;</span><br><span class="line">    &lt;i:EventTrigger EventName=<span class="string">&quot;MouseEnter&quot;</span>&gt;</span><br><span class="line">        &lt;i:ChangePropertyAction PropertyName=<span class="string">&quot;FontSize&quot;</span> Value=<span class="string">&quot;32&quot;</span>/&gt;</span><br><span class="line">        &lt;i:ChangePropertyAction PropertyName=<span class="string">&quot;Content&quot;</span> Value=<span class="string">&quot;Hover&quot;</span>/&gt;</span><br><span class="line">    &lt;/i:EventTrigger&gt;</span><br><span class="line">      &lt;i:EventTrigger EventName=<span class="string">&quot;MouseLeave&quot;</span>&gt;</span><br><span class="line">        &lt;i:ChangePropertyAction PropertyName=<span class="string">&quot;FontSize&quot;</span> Value=<span class="string">&quot;18/&gt;</span></span><br><span class="line"><span class="string">        &lt;i:ChangePropertyAction PropertyName=&quot;</span>Content<span class="string">&quot; Value=&quot;</span>hello<span class="string">&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/i:EventTrigger&gt;</span></span><br><span class="line"><span class="string">&lt;/i:Interaction.Triggers&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>behaviour中的Trigger与<a href="#%E8%A7%A6%E5%8F%91%E5%99%A8">Style中的Trigger</a>的不同在于,behaviour中的Trigger要写成对的,而Style中的Trigger可以有默认样式</p>
<p>在 WPF 中，当你使用 Style 来为控件定义一些视觉外观时，如果你为控件定义了 Trigger（触发器）来动态更改某些属性，它的优先级低于你直接在 XAML 中为该控件设置的属性值,但<strong>在 Template 中设置的 Trigger 例外</strong>,而behaviour中的Trigger由于本质原理是通过注册事件来实现的,因此没有这个限制</p>
<p>虽然Style中也有EventTrigger,但是他只可以用于路由事件,比如ListBox的selectChanged事件就不是路由事件;而behaviour中却只要是事件都可以绑定</p>
</blockquote>
<h3 id="自定义行为"><a href="#自定义行为" class="headerlink" title="自定义行为"></a>自定义行为</h3><p>WPF中的行为（Behavior）是指一种可以附加到控件上的功能，<strong>行为的作用是扩展控件的功能，而不需要修改控件本身的代码</strong>。行为通过绑定附加属性，能够方便地应用于不同控件。行为可以被复用和配置，使得控件的交互逻辑更加灵活。</p>
<p>通常，WPF行为有以下两种主要类型：</p>
<ul>
<li><strong>附加行为</strong>：通过附加属性来实现。</li>
<li><strong>拖放行为</strong>：用于实现拖放功能。</li>
</ul>
<h4 id="自定义行为的实现方式"><a href="#自定义行为的实现方式" class="headerlink" title="自定义行为的实现方式"></a>自定义行为的实现方式</h4><p>要使用行为，首先需要安装Microsoft.Xaml.Behaviors.Wpf库。这是微软提供的标准行为库，允许你轻松创建和附加行为。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Install-Package Microsoft.Xaml.Behaviors.Wpf</span><br></pre></td></tr></table></figure>

<p>自定义行为通常继承自 <code>Behavior&lt;T&gt;</code>，其中T是行为所附加的控件类型。我们可以通过重写OnAttached和OnDetaching方法，在行为附加到控件时初始化功能。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.Xaml.Behaviors;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Controls;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomTextBoxBehavior</span> : <span class="title">Behavior</span>&lt;<span class="title">TextBox</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnAttached</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnAttached();</span><br><span class="line">        <span class="comment">// 在行为附加时执行的代码</span></span><br><span class="line">        <span class="keyword">this</span>.AssociatedObject.TextChanged += OnTextChanged;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnDetaching</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnDetaching();</span><br><span class="line">        <span class="comment">// 在行为移除时执行的代码</span></span><br><span class="line">        <span class="keyword">this</span>.AssociatedObject.TextChanged -= OnTextChanged;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTextChanged</span>(<span class="params"><span class="built_in">object</span> sender, TextChangedEventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 自定义的逻辑，比如自动转换文本为大写</span></span><br><span class="line">        <span class="keyword">var</span> textBox = sender <span class="keyword">as</span> TextBox;</span><br><span class="line">        textBox.Text = textBox.Text.ToUpper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用行为"><a href="#使用行为" class="headerlink" title="使用行为"></a>使用行为</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;Window x:Class=&quot;WpfApp.MainWindow&quot;</span><br><span class="line">        xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span><br><span class="line">        xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span><br><span class="line">        xmlns:i=&quot;http://schemas.microsoft.com/xaml/behaviors&quot;</span><br><span class="line">        xmlns:local=&quot;clr-namespace:WpfApp&quot;</span><br><span class="line">        Title=&quot;MainWindow&quot; Height=&quot;350&quot; Width=&quot;525&quot;&gt;</span><br><span class="line">    &lt;Grid&gt;</span><br><span class="line">        &lt;TextBox Width=&quot;200&quot; Height=&quot;30&quot;&gt;</span><br><span class="line">            &lt;i:Interaction.Behaviors&gt;</span><br><span class="line">                &lt;local:CustomTextBoxBehavior /&gt;</span><br><span class="line">            &lt;/i:Interaction.Behaviors&gt;</span><br><span class="line">        &lt;/TextBox&gt;</span><br><span class="line">    &lt;/Grid&gt;</span><br><span class="line">&lt;/Window&gt;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，自定义行为CustomTextBoxBehavior会自动将TextBox的输入文本转换为大写。</p>
<p>除了简单的文本处理，你还可以实现更复杂的行为，例如：</p>
<ul>
<li><strong>拖放功能</strong>：让控件支持拖放操作。</li>
<li><strong>动画效果</strong>：当用户与控件交互时启动动画。</li>
<li><strong>命令行为</strong>：将命令绑定到控件的事件中。</li>
</ul>
<h4 id="案例-5"><a href="#案例-5" class="headerlink" title="案例"></a>案例</h4><p>假设你需要在多个按钮上实现点击时的动画效果。你可以创建一个 <code>ButtonClickAnimationBehavior</code> 类，封装按钮点击时的动画逻辑：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ButtonClickAnimationBehavior</span> : <span class="title">Behavior</span>&lt;<span class="title">Button</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnAttached</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnAttached();</span><br><span class="line">        AssociatedObject.Click += OnButtonClick;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnDetaching</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnDetaching();</span><br><span class="line">        AssociatedObject.Click -= OnButtonClick;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnButtonClick</span>(<span class="params"><span class="built_in">object</span> sender, RoutedEventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 实现动画效果</span></span><br><span class="line">        <span class="keyword">var</span> animation = <span class="keyword">new</span> DoubleAnimation</span><br><span class="line">        &#123;</span><br><span class="line">            To = <span class="number">1.0</span>,</span><br><span class="line">            Duration = TimeSpan.FromSeconds(<span class="number">0.5</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        AssociatedObject.BeginAnimation(Button.OpacityProperty, animation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在 XAML 中使用这个 Behavior：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">Content</span>=<span class="string">&quot;Click Me&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i:Interaction.Behaviors</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">local:ButtonClickAnimationBehavior</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">i:Interaction.Behaviors</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Behavior 在 WPF 中的作用是将特定的功能逻辑封装成独立的组件，以便于重用和维护。通过使用 Behavior，开发者可以更灵活地扩展控件的功能，同时保持代码的整洁和模块化。</p>
<h3 id="MultiDataTrigger"><a href="#MultiDataTrigger" class="headerlink" title="MultiDataTrigger"></a>MultiDataTrigger</h3><p><code>MultiDataTrigger</code> 是一个用于在 WPF 中根据多个数据绑定条件来控制 UI 元素属性的触发器。它的主要作用是在所有指定的条件都满足时，执行特定的操作（如设置属性值）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;cc:LightLabel.Style&gt;</span><br><span class="line">    &lt;Style TargetType=&quot;cc:LightLabel&quot;&gt;</span><br><span class="line">        &lt;Setter Property=&quot;Status&quot; Value=&quot;False&quot; /&gt;</span><br><span class="line">        &lt;Style.Triggers&gt;</span><br><span class="line">            &lt;MultiDataTrigger&gt;</span><br><span class="line">                &lt;MultiDataTrigger.Conditions&gt;  &lt;!--满足条件--&gt;</span><br><span class="line">                    &lt;Condition Binding=&quot;&#123;Binding HardwareManager.CombineDataProvider.UDPData.Model.Door1Lock.Status&#125;&quot; Value=&quot;Close&quot; /&gt;</span><br><span class="line">                    &lt;Condition Binding=&quot;&#123;Binding HardwareManager.CombineDataProvider.UDPData.Model.Door2Lock.Status&#125;&quot; Value=&quot;Close&quot; /&gt;</span><br><span class="line">                    &lt;Condition Binding=&quot;&#123;Binding HardwareManager.CombineDataProvider.UDPData.Model.Door3Lock.Status&#125;&quot; Value=&quot;Close&quot; /&gt;</span><br><span class="line">                    &lt;Condition Binding=&quot;&#123;Binding HardwareManager.CombineDataProvider.UDPData.Model.Door4Lock.Status&#125;&quot; Value=&quot;Close&quot; /&gt;</span><br><span class="line">                    &lt;Condition Binding=&quot;&#123;Binding HardwareManager.CombineDataProvider.UDPData.Model.Door5Lock.Status&#125;&quot; Value=&quot;Close&quot; /&gt;</span><br><span class="line">                    &lt;Condition Binding=&quot;&#123;Binding HardwareManager.CombineDataProvider.UDPData.Model.Door6Lock.Status&#125;&quot; Value=&quot;Close&quot; /&gt;</span><br><span class="line">                    &lt;Condition Binding=&quot;&#123;Binding HardwareManager.CombineDataProvider.UDPData.Model.Door7Lock.Status&#125;&quot; Value=&quot;Close&quot; /&gt;</span><br><span class="line">                    &lt;Condition Binding=&quot;&#123;Binding HardwareManager.CombineDataProvider.UDPData.Model.Door8Lock.Status&#125;&quot; Value=&quot;Close&quot; /&gt;</span><br><span class="line">                    &lt;Condition Binding=&quot;&#123;Binding HardwareManager.CombineDataProvider.UDPData.Model.DoorLock.Status&#125;&quot; Value=&quot;Close&quot; /&gt;</span><br><span class="line">                    &lt;Condition Binding=&quot;&#123;Binding HardwareManager.CombineDataProvider.UDPData.Model.Door1Close.Port.Port&#125;&quot; Value=&quot;false&quot; /&gt;</span><br><span class="line">                    &lt;Condition Binding=&quot;&#123;Binding HardwareManager.CombineDataProvider.UDPData.Model.Door2Close.Port.Port&#125;&quot; Value=&quot;false&quot; /&gt;</span><br><span class="line">                    &lt;Condition Binding=&quot;&#123;Binding HardwareManager.CombineDataProvider.UDPData.Model.Door3Close.Port.Port&#125;&quot; Value=&quot;false&quot; /&gt;</span><br><span class="line">                    &lt;Condition Binding=&quot;&#123;Binding HardwareManager.CombineDataProvider.UDPData.Model.Door4Close.Port.Port&#125;&quot; Value=&quot;false&quot; /&gt;</span><br><span class="line">                    &lt;Condition Binding=&quot;&#123;Binding HardwareManager.CombineDataProvider.UDPData.Model.Door5Close.Port.Port&#125;&quot; Value=&quot;false&quot; /&gt;</span><br><span class="line">                    &lt;Condition Binding=&quot;&#123;Binding HardwareManager.CombineDataProvider.UDPData.Model.Door6Close.Port.Port&#125;&quot; Value=&quot;false&quot; /&gt;</span><br><span class="line">                    &lt;Condition Binding=&quot;&#123;Binding HardwareManager.CombineDataProvider.UDPData.Model.Door7Close.Port.Port&#125;&quot; Value=&quot;false&quot; /&gt;</span><br><span class="line">                    &lt;Condition Binding=&quot;&#123;Binding HardwareManager.CombineDataProvider.UDPData.Model.Door8Close.Port.Port&#125;&quot; Value=&quot;false&quot; /&gt;</span><br><span class="line">                &lt;/MultiDataTrigger.Conditions&gt;</span><br><span class="line">                  &lt;!--触发--&gt;</span><br><span class="line">                &lt;Setter Property=&quot;Status&quot; Value=&quot;True&quot; /&gt;</span><br><span class="line">            &lt;/MultiDataTrigger&gt;</span><br><span class="line">        &lt;/Style.Triggers&gt;</span><br><span class="line">    &lt;/Style&gt;</span><br><span class="line">&lt;/cc:LightLabel.Style&gt;</span><br></pre></td></tr></table></figure>

<p>单个Conditions中多个Condition是<strong>与</strong>的关系,每个Conditions间是<strong>或</strong>的关系</p>
<h2 id="MVVM常见误区"><a href="#MVVM常见误区" class="headerlink" title="MVVM常见误区"></a>MVVM常见误区</h2><p>两个常见误区</p>
<ul>
<li>对于 WPF开发还不够了解，很多思维停留在WinForms阶段，比如在代码后台修改控件的样式</li>
<li>对于 MVVM 开发还不够了解，认为MVVM 就是要用绑定和把 Click 事件改成 Command</li>
</ul>
<p>常见错误例子:</p>
<ol>
<li><p>Button的功能虽然使用了Command,但是按钮是否可用是IsEnabled绑定了另外一个bool属性</p>
<p>不再额外写一个bool属性用来控制Button的IsEnabled,而是使用Command本身的CanExecute,CanExecute本质上也是控制button的使能,会让控件变灰</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">bool</span> _isEnableLongTimeClick = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">bool</span> isEnableLongTimeClick</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">get</span> &#123; <span class="keyword">return</span> _isEnableLongTimeClick; &#125;</span><br><span class="line">  <span class="keyword">set</span></span><br><span class="line">  &#123;</span><br><span class="line">    SetProperty(<span class="keyword">ref</span> _isEnableLongTimeClick, <span class="keyword">value</span>);</span><br><span class="line">    _LongTimeClick.RaiseCanExecuteChanged();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> DelegateCommand _LongTimeClick;</span><br><span class="line"><span class="keyword">public</span> DelegateCommand LongTimeClick =&gt;</span><br><span class="line">  _LongTimeClick ?? (_LongTimeClick = <span class="keyword">new</span> DelegateCommand(ExecuteLongTimeClick, CanExecuteLongTimeClick));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">async</span> <span class="keyword">void</span> <span class="title">ExecuteLongTimeClick</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  isEnableLongTimeClick = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">await</span> Task.Delay(<span class="number">2000</span>);</span><br><span class="line">  isEnableLongTimeClick = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">bool</span> <span class="title">CanExecuteLongTimeClick</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> isEnableLongTimeClick;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比方说执行处理时间中变灰,处理完自动亮起,async的Relaycommand本身就可以处理这个逻辑 (但要注意,CommunityToolkit.Mvvm才支持该功能)</p>
</li>
<li><p>想要让Button在鼠标置于上方时就实现交互操作(相当于让按钮不再被点击后才触发Click事件)</p>
<p>直接修改Button的ClickMode值,ClickMode中有Hover,Press,Release</p>
</li>
<li><p>如果想要实现Button在鼠标置于上方时修改文字内容,会想办法注册MouseEnter和MouseLeave事件,然后再写一个string属性用于绑定Button.Content</p>
<p>使用<a href="#%E6%A0%B7%E5%BC%8F%E6%A1%88%E4%BE%8B">Style+Trigger</a>   (注意上方的Hover的ClickMode会处理掉Trugger处理的MouseEnter&#x2F;MouseLeave事件,即二者同时存在的时候,只会处理ClickMode为Hover的Command,无视后者)</p>
</li>
<li><p>当鼠标置于Button上方时,实时输出鼠标在Button控件中的坐标</p>
<p>虽然这里可以通过command的参数把自身传到viewModel中进行处理,但其实是不符合MVVM架构设计逻辑的,错误做法如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button Width=&quot;200&quot;</span><br><span class="line">Height=&quot;80&quot;</span><br><span class="line">FontSize=&quot;18&quot;</span><br><span class="line">Content=&quot;HeLlo&quot;&gt;</span><br><span class="line">&lt;i:Interaction.Triggers&gt;</span><br><span class="line">&lt;i:EventTrigger EventName=&quot;MouseEnter&quot;&gt;</span><br><span class="line">  &lt;!--此处不用手写CommandParameter,直接使用PassEventArgsToCommand会自动传递EventArgs--&gt;</span><br><span class="line">&lt;i:InvokeCommandAction Command=&quot;｛Binding MouseEnterCommand｝&quot; PassEventArgsToCommand=&quot;True&quot; /&gt;</span><br><span class="line">&lt;i:EventTrigger&gt;</span><br><span class="line">&lt;i:Interaction.Triggers&gt;</span><br><span class="line">&lt; Button&gt;</span><br></pre></td></tr></table></figure>

<p>viewmodel中t</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MouseMove</span>(<span class="params">MouseEventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//直接就可以处理了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这种做法依旧是不对的,违背了viewmodel不处理view的原则,正确做法✅如下:</p>
<p>写一个<a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">自定义行为</a>,并通过绑定的DP,用于传出信息</p>
</li>
</ol>
<h1 id="资源和样式"><a href="#资源和样式" class="headerlink" title="资源和样式"></a>资源和样式</h1><p>WPF资源系统是一种保管一系列有用对象（如常用的画刷、样式和模板）的简单方法，从而使您可以更容易地重用这些对象。每个元素都有Resources属性，该属性存储了一个资源字典集合（它是ResourceDictionary类的实例）。资源集合可包含任意类型的对象，根据字符串编写索引。可以在任何元素上定义资源,可通过 <code>x:Key</code>指令来分配唯一键</p>
<p>查找资源的方向是: 沿着逻辑树向上查找</p>
<p>资源包含</p>
<ul>
<li>重复的xaml内容</li>
<li>控件风格样式</li>
<li>数据模板</li>
<li>动画</li>
<li>…</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;！--窗体的写法--&gt;</span><br><span class="line">&lt;Window&gt;</span><br><span class="line">    &lt;Window.Resources&gt;</span><br><span class="line">    &lt;/Window.Resources&gt;</span><br><span class="line">&lt;/Window&gt;</span><br><span class="line"></span><br><span class="line">&lt;！--控件的写法--&gt;</span><br><span class="line">&lt;Control&gt;</span><br><span class="line">    &lt;Control.Resources&gt;</span><br><span class="line">    &lt;/Control.Resources&gt;</span><br><span class="line">&lt;/Control&gt;</span><br></pre></td></tr></table></figure>

<p>上面两种资源的作用范围都局限于当前窗口或控件下,如果需要设置全局样式,<a href="#%E5%85%A8%E5%B1%80%E6%A0%B7%E5%BC%8F">参考此处</a></p>
<p>给单个控件添加样式很简单,直接是通过给属性设置值的方式来设置样式,但如果需要针对多个或同一类控件都设置为同一个样式呢,单个添加属性的方法就很繁琐了,此时就需要用到<a href="#%E6%A0%B7%E5%BC%8F">样式</a></p>
<h2 id="静态资源和动态资源"><a href="#静态资源和动态资源" class="headerlink" title="静态资源和动态资源"></a>静态资源和动态资源</h2><ul>
<li><p>静态资源使用（StaticResource）指的是在程序载入内存时，对资源的一次性使用，之后就不再去访问这个资源了；</p>
</li>
<li><p>动态资源使用（DynamicResource）指的是在程序运行过程中,仍然会去访问该资源。</p>
<p>只要是需要运行中改变的资源都得用动态资源,例如最常见的改变颜色</p>
</li>
</ul>
<h2 id="资源管理形式"><a href="#资源管理形式" class="headerlink" title="资源管理形式"></a>资源管理形式</h2><p>在WPF 项目中，我们一般有以下几种方法来管理 Window.Resources：</p>
<p>• 直接在 窗口对应的xaml 中定义资源，这样可以方便地在主窗口中使用资源，但是如果资源很多或者需要在其他窗口或用户控件中使用，就不太合适。<br>• 在 App.xaml 中定义资源，这样可以让资源在整个应用程序的范围内共享，实现一致的主题和外观，但是如果资源很多或者需要根据不同的窗口或用户控件进行区分，就不太合适。<br>• 创建文件夹并创建内容元素为ResourceDictionary的xaml页面，这样可以将资源分组和模块化，方便管理和维护，也可以根据需要在不同的窗口或用户控件中引用或合并资源。</p>
<p><strong>ResourceDictionary引用方法</strong></p>
<p>在App.xaml中使用MergedDictionaries属性来合并多个ResourceDictionary文件(资源字典),这样可以让资源在整个应用程序的范围内共享</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;Application x:Class=&quot;MyApp.App&quot;</span><br><span class="line">xmLns=&quot;http://schemas.microsoft.com/winfx/2006/xamL/presentation&quot;</span><br><span class="line">xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xamL&quot;&gt;</span><br><span class="line">&lt;Application.Resources&gt;</span><br><span class="line">&lt;ResourceDictionary&gt;</span><br><span class="line">&lt;ResourceDictionary.MergedDictionaries&gt;</span><br><span class="line">&lt;ResourceDictionary Source=&quot;/Resources/Brushes.xamL&quot;/&gt;</span><br><span class="line">&lt;ResourceDictionary Source=&quot;/Resources/strings.xamL&quot;/&gt;</span><br><span class="line">&lt;/ResourceDictionary.MergedDictionaries&gt;</span><br><span class="line">&lt;/ResourceDictionary&gt;</span><br><span class="line">&lt;/Application.Resources&gt;</span><br><span class="line">&lt;/Application&gt;</span><br></pre></td></tr></table></figure>

<h2 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h2><p><strong>样式</strong>是修改View（窗体、控件）样式的主要手段，主要作用更改控件的外观以及增强用户体验。</p>
<blockquote>
<p><strong>样式（Style）</strong>是一种将一组特征属性值应用到多个元素的方法，用于设置控件的外观属性如长宽、颜色、字体、大小等。WPF中的各类控件元素，都可以自由的设置其样式。在设定Style时，我们需要使用 <code>x:Key</code>声明键名，并设置目标类型TargetType，使用x:Type将类型传入。在Style标签的内容区通过Setter标签，设置Property属性和属性值Value。</p>
</blockquote>
<p><a href="#TextBox%E5%88%87%E6%8D%A2%E8%BE%93%E5%85%A5%E4%B8%8E%E7%BB%91%E5%AE%9A%E6%A8%A1%E5%BC%8F">案例可参考TextBox切换输入与绑定模式</a></p>
<p>Style类的属性</p>
<ul>
<li><code>Setters</code>: 设置属性值以及自动关联事件处理程序的Setter对象或EventSetter对象的集合是Style类中最重要的属性,但并非唯一属性 - SetterBase类主要用于控制控件的静态外观风格</li>
<li><code>Triggers</code>:  继承自TriggerBase类能自动改变样式设置的对象集合。例如，当另一个属性改变时，或者当发生某个时间时，可以修改样式 - TriggerBase类主要用于控制控件的动态行为风格</li>
<li><code>Resources</code>：希望用于样式的资源集合</li>
<li><code>BasedOn</code>：通过该属性可创建继承自其它样式设置的更具体的样式,虽然可以继承,但建议继承关系尽量简单(不建议过多使用)</li>
<li><code>TargetType</code>：该属性标识应用样式的元素类型。通过该属性可创建只影响特定类型元素的设置器，还可以创建能够为恰当的元素类型自动起作用的设置器</li>
<li><code>IsSealed</code>: 是否允许“派生”出其他样式，也就是是否密封</li>
</ul>
<h3 id="Setter"><a href="#Setter" class="headerlink" title="Setter"></a>Setter</h3><p>Setter具有两个主要属性</p>
<ul>
<li>Property（属性）：指定要设置的属性名称。可以是任何依赖属性（DependencyProperty）或依赖对象 （DependencyObject）的属性。</li>
<li>Value（值）：指定要为属性设置的值。</li>
</ul>
<h3 id="样式案例"><a href="#样式案例" class="headerlink" title="样式案例"></a>样式案例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--下面内容包含于windows标签中--&gt;</span><br><span class="line">&lt;Window.Resources&gt;</span><br><span class="line">    &lt;!--针对这个窗口下的所有Button, TargetType=&quot;Button&quot;也能写成TargetType=&quot;&#123;x:Type Button&#125;&quot;--&gt;</span><br><span class="line">    &lt;Style TargetType=&quot;Button&quot;&gt;</span><br><span class="line">        &lt;!-- 默认设置(这个默认设置实际上没用,因为Trigger的优先级要比他高) --&gt;</span><br><span class="line">        &lt;Setter Property=&quot;Foreground&quot; Value=&quot;White&quot;/&gt;</span><br><span class="line">        &lt;Style.Triggers&gt;</span><br><span class="line">            &lt;Trigger Property=&quot;IsMouseOver&quot; Value=&quot;False&quot;&gt;</span><br><span class="line">                &lt;Setter Property=&quot;Foreground&quot; Value=&quot;BlueViolet&quot;/&gt;</span><br><span class="line">            &lt;/Trigger&gt;</span><br><span class="line">            &lt;Trigger Property=&quot;IsMouseOver&quot; Value=&quot;True&quot;&gt;</span><br><span class="line">                &lt;Setter Property=&quot;Foreground&quot; Value=&quot;Red&quot;/&gt;</span><br><span class="line">            &lt;/Trigger&gt;</span><br><span class="line">        &lt;/Style.Triggers&gt;</span><br><span class="line">    &lt;/Style&gt;</span><br><span class="line">&lt;/Window.Resources&gt;</span><br></pre></td></tr></table></figure>

<p>上面是作用于一批控件,如果想指定样式呢,可以在控件上指定样式,通过 <code>x:Key</code>属性,如果不添加 <code>x:Key</code>属性,那么就是针对当前作用范围内的全部指定控件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;Window.Resources&gt;</span><br><span class="line">    &lt;!-- 重点是这里的x:Key,他的值作为该Style的唯一标识 --&gt;</span><br><span class="line">    &lt;Style x:Key=&quot;TriggerStyle&quot; TargetType=&quot;Button&quot;&gt;</span><br><span class="line">        &lt;!-- 默认设置(这个默认设置实际上没用,因为Trigger的优先级要比他高) --&gt;</span><br><span class="line">        &lt;Setter Property=&quot;Foreground&quot; Value=&quot;White&quot;/&gt;</span><br><span class="line">        &lt;Style.Triggers&gt;</span><br><span class="line">            &lt;Trigger Property=&quot;IsMouseOver&quot; Value=&quot;False&quot;&gt;</span><br><span class="line">                &lt;Setter Property=&quot;Foreground&quot; Value=&quot;BlueViolet&quot;/&gt;</span><br><span class="line">            &lt;/Trigger&gt;</span><br><span class="line">            &lt;Trigger Property=&quot;IsMouseOver&quot; Value=&quot;True&quot;&gt;</span><br><span class="line">                &lt;Setter Property=&quot;Foreground&quot; Value=&quot;Red&quot;/&gt;</span><br><span class="line">            &lt;/Trigger&gt;</span><br><span class="line">        &lt;/Style.Triggers&gt;</span><br><span class="line">    &lt;/Style&gt;</span><br><span class="line">&lt;/Window.Resources&gt;</span><br></pre></td></tr></table></figure>

<p>在控件上通过下面属性使用该Style(注意Window.Resources标签必须定义在控件定义之前,即写在上面)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button Content=&quot;登录&quot; Width=&quot;30&quot; Style=&quot;&#123;StaticResource TriggerStyle&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>此处使用的是 <code>StaticResource</code>,表示静态资源,即当程序运行起来后,这个样式是不会发生变化的(即使后续修改了样式，真实的效果也不会变化)</p>
<ul>
<li><code>StaticResource</code>  <code>StaticResource</code> 在应用程序启动时就进行加载,启动时消耗更多的资源，但在运行时性能较好</li>
<li><code>DynamicResource </code> <code>DynamicResource</code> 在需要时才加载,支持在运行时动态更新资源,提供了更大的灵活性</li>
</ul>
<p>Style可以使用 <code>BasedOn</code>沿用之前的Style,代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--继承原本Button的样式去设立新样式,控件中使用样式索引名来使用该新增样式--&gt;</span><br><span class="line">&lt;Style x:Key=&quot;样式索引名&quot; BaseOn=&quot;&#123;StaticResource &#123;x:Type Button&#125;&#125;&quot;&gt;</span><br><span class="line">    &lt;!--...--&gt;</span><br><span class="line">&lt;/Style&gt;</span><br></pre></td></tr></table></figure>

<h3 id="全局样式"><a href="#全局样式" class="headerlink" title="全局样式"></a>全局样式</h3><p>项目上右键<strong>添加资源字典</strong>选择<strong>资源词典(wpf)</strong></p>
<p>比如说新建资源词典: <code>baseStyle.xaml</code></p>
<p>在App.xaml中编写如下代码,引用Style文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;Application x:Class=&quot;testWPF.App&quot;</span><br><span class="line">             xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span><br><span class="line">             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span><br><span class="line">             xmlns:local=&quot;clr-namespace:testWPF&quot;</span><br><span class="line">             StartupUri=&quot;MainWindow.xaml&quot;&gt;</span><br><span class="line">    &lt;Application.Resources&gt;</span><br><span class="line">        &lt;ResourceDictionary&gt;</span><br><span class="line">            &lt;ResourceDictionary.MergedDictionaries&gt;</span><br><span class="line">                &lt;!--全局引用Style文件--&gt;</span><br><span class="line">                &lt;ResourceDictionary Source=&quot;/testWPF;component/baseStyle.xaml&quot;/&gt;</span><br><span class="line">            &lt;/ResourceDictionary.MergedDictionaries&gt;</span><br><span class="line">        &lt;/ResourceDictionary&gt;</span><br><span class="line">    &lt;/Application.Resources&gt;</span><br><span class="line">&lt;/Application&gt;</span><br></pre></td></tr></table></figure>

<p>由于是在 <code>App.xaml</code>中引入了Style文件,因此作用范围是整个程序</p>
<h3 id="定义样式"><a href="#定义样式" class="headerlink" title="定义样式"></a>定义样式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;ResourceDictionary xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span><br><span class="line">                    xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;&gt;</span><br><span class="line">    &lt;Style x:Key=&quot;GroupBoxTab&quot; TargetType=&quot;GroupBox&quot;&gt;</span><br><span class="line">        &lt;!-- 定义样式属性 --&gt;</span><br><span class="line">        &lt;Setter Property=&quot;Background&quot; Value=&quot;LightGray&quot;/&gt;</span><br><span class="line">        &lt;Setter Property=&quot;BorderBrush&quot; Value=&quot;Black&quot;/&gt;</span><br><span class="line">        &lt;Setter Property=&quot;BorderThickness&quot; Value=&quot;1&quot;/&gt;</span><br><span class="line">        &lt;!-- 其他样式设置 --&gt;</span><br><span class="line">    &lt;/Style&gt;</span><br><span class="line">&lt;/ResourceDictionary&gt;</span><br></pre></td></tr></table></figure>

<h3 id="引入样式写法"><a href="#引入样式写法" class="headerlink" title="引入样式写法"></a>引入样式写法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ResourceDictionary Source=&quot;pack://application:,,,/HandyControl;component/Themes/SkinDefault.xaml&quot;/&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong><code>&lt;ResourceDictionary&gt;</code></strong>:</p>
<ul>
<li>这是一个 WPF 资源字典，用于定义和组织可重用的资源，如样式、控件模板、颜色等。</li>
</ul>
</li>
<li><p><strong><code>Source</code> 属性</strong>:</p>
<ul>
<li><code>Source</code> 属性指定了资源字典的路径。路径使用了 <code>pack://</code> URI 语法，这是 WPF 中用于引用资源的标准方式。</li>
</ul>
</li>
<li><p><strong><code>pack://application:,,,/HandyControl;component/Themes/SkinDefault.xaml</code></strong>:</p>
<ul>
<li><code>pack://application:</code>: 表示这是一个应用程序包 URI，它通常用于引用应用程序中的资源。</li>
<li><code>,,,</code>: 这是 URI 语法的一部分，用于分隔不同的 URI 组件。</li>
<li><pre><code>/HandyControl;component/Themes/SkinDefault.xaml
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">     : 这是资源的具体路径。</span><br><span class="line"></span><br><span class="line">     - `/HandyControl`: 表示资源所在的程序集（assembly）名。</span><br><span class="line">     - `;component`: 表示这是程序集中的一个组件。</span><br><span class="line">     - `/Themes/SkinDefault.xaml`: 表示资源在程序集中的具体路径。</span><br><span class="line"></span><br><span class="line">这行代码的作用是将 `HandyControl` 程序集中 `Themes` 文件夹下的 `SkinDefault.xaml` 文件中的资源字典合并到当前的资源字典中。这样，`SkinDefault.xaml` 中定义的资源（如样式、模板等）就可以在当前上下文中使用了。</span><br><span class="line"></span><br><span class="line">### 在原有的样式上添加</span><br><span class="line"></span><br><span class="line">以下面的代码为例:</span><br><span class="line"></span><br><span class="line">```xaml</span><br><span class="line">&lt;Style TargetType=&quot;hc:NumericUpDown&quot;</span><br><span class="line">       x:Key=&quot;IsChangedDifferenceStyle&quot;</span><br><span class="line">       BasedOn=&quot;&#123;StaticResource &#123;x:Type hc:NumericUpDown&#125;&#125;&quot;&gt;</span><br><span class="line">      &lt;!--上面为在原有样式基础上添加的样式--&gt;</span><br><span class="line">    &lt;Style.Triggers&gt;</span><br><span class="line">        &lt;DataTrigger Value=&quot;True&quot;&gt;</span><br><span class="line">            &lt;DataTrigger.Binding&gt;</span><br><span class="line">                &lt;MultiBinding Converter=&quot;&#123;StaticResource IsValueChangedDifferenceMultiConverter&#125;&quot;&gt;</span><br><span class="line">                    &lt;Binding Path=&quot;Value&quot;</span><br><span class="line">                             RelativeSource=&quot;&#123;RelativeSource Self&#125;&quot;/&gt;</span><br><span class="line">                    &lt;Binding Path=&quot;Tag&quot;</span><br><span class="line">                             RelativeSource=&quot;&#123;RelativeSource Self&#125;&quot;/&gt;</span><br><span class="line">                &lt;/MultiBinding&gt;</span><br><span class="line">            &lt;/DataTrigger.Binding&gt;</span><br><span class="line">            &lt;Setter Property=&quot;Effect&quot;&gt;</span><br><span class="line">                &lt;Setter.Value&gt;</span><br><span class="line">                    &lt;DropShadowEffect Color=&quot;Red&quot;</span><br><span class="line">                                      BlurRadius=&quot;10&quot;</span><br><span class="line">                                      ShadowDepth=&quot;0&quot;/&gt;</span><br><span class="line">                &lt;/Setter.Value&gt;</span><br><span class="line">            &lt;/Setter&gt;</span><br><span class="line">        &lt;/DataTrigger&gt;</span><br><span class="line">        &lt;DataTrigger Value=&quot;False&quot;&gt;</span><br><span class="line">            &lt;DataTrigger.Binding&gt;</span><br><span class="line">                &lt;MultiBinding Converter=&quot;&#123;StaticResource IsValueChangedDifferenceMultiConverter&#125;&quot;&gt;</span><br><span class="line">                    &lt;Binding Path=&quot;Value&quot;</span><br><span class="line">                             RelativeSource=&quot;&#123;RelativeSource Self&#125;&quot;/&gt;</span><br><span class="line">                    &lt;Binding Path=&quot;Tag&quot;</span><br><span class="line">                             RelativeSource=&quot;&#123;RelativeSource Self&#125;&quot;/&gt;</span><br><span class="line">                &lt;/MultiBinding&gt;</span><br><span class="line">            &lt;/DataTrigger.Binding&gt;</span><br><span class="line">            &lt;Setter Property=&quot;Effect&quot;</span><br><span class="line">                    Value=&quot;&#123;x:Null&#125;&quot;/&gt;</span><br><span class="line">        &lt;/DataTrigger&gt;</span><br><span class="line">    &lt;/Style.Triggers&gt;</span><br><span class="line">&lt;/Style&gt;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ol>
<p>上面代码案例也可以了解一下通过转换器来进行的多绑定 <code>MultiBinding</code>,将自身元素的Value和自身元素的Tag属性提供给MultiBinding来判断是否触发效果</p>
<h3 id="主题切换方案"><a href="#主题切换方案" class="headerlink" title="主题切换方案"></a>主题切换方案</h3><p>实现主题切换功能的基本思路是使用<strong>动态资源（DynamicResource）</strong>来定义控件的样式，然后在运行时更换不同的资源字典（ResourceDictionary）来改变控件的外观。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Button_Click</span>(<span class="params"><span class="built_in">object</span> sender, RoutedEventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ResourceDictionary resource = <span class="keyword">new</span> ResourceDictionary();</span><br><span class="line">    <span class="keyword">if</span> (Application.Current.Resources.MergedDictionaries[<span class="number">0</span>].Source.ToString() == <span class="string">&quot;pack://application:,,,/YourProject;component/Resources/Colors.xaml&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        resource.Source = <span class="keyword">new</span> Uri(<span class="string">&quot;pack://application:,,,/YourProject;component/Resources/DarkColors.xaml&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        resource.Source = <span class="keyword">new</span> Uri(<span class="string">&quot;pack://application:,,,/YourProject;component/Resources/Colors.xaml&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Application.Current.Resources.MergedDictionaries[<span class="number">0</span>] = resource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><ul>
<li><p><a href="#%E6%8E%A7%E4%BB%B6%E6%A8%A1%E6%9D%BF">控件模板(ControlTemplate)</a></p>
<p>控件模板定义了控件在界面上的呈现方式，包括控件的布局、样式、触发器和绑定等。通过修改控件模板，可以自定义控件的外观，使其符合特定的设计需求和用户体验要求。在控件模板中，可以使用各种控件和容器元素来构建控件的可视化结构。</p>
</li>
<li><p><a href="#%E6%95%B0%E6%8D%AE%E6%A8%A1%E6%9D%BF">数据模板(DataTemplate)</a></p>
</li>
</ul>
<p><strong>数据模板和控件模板的关系</strong></p>
<ul>
<li><a href="#ContentPresenter">ContentPresenter</a>对象通常被用来作为数据及数据模板的载体，其只有ContentTemplate属性，而没有Template属性。ControlTemplate生成的控件树其根节点就是目标控件，也就是要针对什么控件去设计模板</li>
<li>DataTemplate生成的控件树根节点是一个ContentPresenter控件。ContentPresenter控件是控件模板上的一个结点</li>
</ul>
<p>所以数据模板是控件模板的一颗子树</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202408271029960.png" alt="image-20240827102917217" style="zoom: 25%;" />

<h3 id="相关构成"><a href="#相关构成" class="headerlink" title="相关构成"></a>相关构成</h3><p>Border元素经常被用于作为控件的底层包裹物,并提供边框和背景样式</p>
<p>ContentPresenter用于呈现其他控件或对象的内容。它通常用作控件模板中的占位符，用于呈现控件的内容，并根据模板中的属性设置进行对齐和布局。ContentPresenter既可以呈现对象的内容，又可以是其他控件。</p>
<h4 id="ContentPresenter"><a href="#ContentPresenter" class="headerlink" title="ContentPresenter"></a>ContentPresenter</h4><p>ControlTemplate 可以使用 ContentPresenter(中心内容呈现控件) 或 ItemsPresenter 来呈现控件的内容或子元素，从而保留控件的基本功能。</p>
<p>[注意] 该控件内含foreground属性</p>
<p>ContentPresenter绑定外界控件案例</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ContentPresenter</span></span></span><br><span class="line"><span class="tag">    <span class="attr">HorizontalAlignment</span>=<span class="string">&quot;&#123;TemplateBinding HorizontalContentAlignment&#125;&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">VerticalAlignment</span>=<span class="string">&quot;&#123;TemplateBinding VerticalContentAlignment&#125;&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">Content</span>=<span class="string">&quot;&#123;TemplateBinding Content&#125;&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">TextElement.FontFamily</span>=<span class="string">&quot;&#123;TemplateBinding FontFamily&#125;&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">TextElement.FontSize</span>=<span class="string">&quot;&#123;TemplateBinding FontSize&#125;&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>

<p><a href="#%E4%BB%A5Button%E4%B8%BA%E4%BE%8B">参考按钮开发案例</a></p>
<h3 id="TemplateBinding"><a href="#TemplateBinding" class="headerlink" title="TemplateBinding"></a>TemplateBinding</h3><p>TemplateBinding（模板绑定）用于在控件模板中绑定模板内部元素的属性与外部控件的属性之间建立关联。使用TemplateBinding，可以在控件模板内部直接引用外部控件的属性，而无需手动编写绑定表达式，以一种简洁、直接的方式访问外部控件的属性，从而<strong>实现属性在父子层级中的传递和同步</strong>。</p>
<h3 id="模板中的绑定注意项"><a href="#模板中的绑定注意项" class="headerlink" title="模板中的绑定注意项"></a>模板中的绑定注意项</h3><p>模板中不能使用 <code>TemplateBinding</code>写法,取而代之的语法是 <code>&#123;Binding 属性名,RelativeSource=&#123;RelativeSource TemplatedParent&#125;&#125;</code></p>
<blockquote>
<p>通过这种方式找MainWindowViewModel下的DeleteCommand例子为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button Command = &quot;&#123;Binding RelativeSource=&#123;RelativeSource Ancestortype=local:MainWindow&#125;,Path=DataContext.DeleteCommand&#125;&quot;&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">上面的local是自已定义的命名空间</span><br><span class="line">Ancestortype: 指定了要查找的祖先元素的类型,会在视觉树中向上查找,直到找到类型为MainWindow的祖先元素</span><br><span class="line">Path: 指定了要绑定的属性路径</span><br><span class="line">综合理解: 查找类型为MainWindow的祖先元素，然后从该祖先元素的DataContext中获取名为DeleteCommand的属性或命令，并将其绑定到按钮的Command属性上</span><br><span class="line">--&gt;</span><br><span class="line">  </span><br><span class="line">&lt;!--或者类似下面这样--&gt;</span><br><span class="line">&lt;Button Command=&quot;&#123;Binding DataContext.Link, RelativeSource=&#123;RelativeSource AncestorType=UserControl&#125;&#125;&quot;&gt;连接&lt;/Button&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="控件模板"><a href="#控件模板" class="headerlink" title="控件模板"></a>控件模板</h3><p>WPF 的 ControlTemplate 是一种用于定义和自定义控件的外观和结构的模板，它可以完全替换控件的默认模板，实现个性化和复杂的效果。WPF 的 ControlTemplate 有以<br>下几个特点：</p>
<p>• ControlTemplate是一个XAML元素，它可以包含任何类型的UI 元素，如布局、形状、图像、文本等，这些元素构成了控件的视觉树（VisualTree）。<br>• ControlTemplate 可以使用 TemplateBinding 或 Binding 来绑定控件的属性或数据，从而实现动态的显示和更新。<br>• ControlTemplate 可以使用 Triggers 来定义控件对不同的条件或事件的响应，如改变属性、播放动画、执行操作等。<br>• ControlTemplate 可以使用 ContentPresenter(中心内容呈现控件) 或 ItemsPresenter 来呈现控件的内容或子元素，从而保留控件的基本功能。<br>• ControlTemplate 可以在 Style 或 ResourceDictionary 中定义，并应用到一个或多个控件上，从而实现资源的重用和管理。</p>
<blockquote>
<p>查看默认模板: 右键-编辑模板-编辑副本: 弹框点击确定,这样就会在windows resource下边生成一个样式片段(包含各种属性以及模板中含有的各种控件)</p>
</blockquote>
<p>如简单自定义一个按钮的外观:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button Width=&quot;200&quot; Height=&quot;50&quot; Content=&quot;点击我&quot;&gt;</span><br><span class="line">    &lt;Button.Template&gt;</span><br><span class="line">        &lt;ControlTemplate TargetType=&quot;Button&quot;&gt;</span><br><span class="line">            &lt;Border Background=&quot;LightBlue&quot; CornerRadius=&quot;10&quot;&gt;</span><br><span class="line">                &lt;ContentPresenter HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;/&gt;</span><br><span class="line">            &lt;/Border&gt;</span><br><span class="line">        &lt;/ControlTemplate&gt;</span><br><span class="line">    &lt;/Button.Template&gt;</span><br><span class="line">&lt;/Button&gt;</span><br></pre></td></tr></table></figure>

<h4 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h4><p>WPF 的 Trigger 是一种用于定义和管理 XAML 资源的触发器，它可以根据不同的条件或事件来改变控件的属性或行为。以下是触发器的类型：</p>
<ul>
<li>基本触发器（Trigger）：这种触发器是<strong>根据控件自身的依赖属性的值来触发</strong>的，例如，当鼠标移动到按钮上时，改变按钮的背景色。</li>
<li>数据触发器（DataTrigger）：这种触发器是<strong>根据绑定的数据的值来触发</strong>的，例如，当绑定的数据为真时，显示一个图标。</li>
<li>多路数据触发器（MultiDataTrigger）：与数据触发器类似,但可以同时满足多个数据绑定的值</li>
<li>事件触发器（EventTrigger）：这种触发器是<strong>根据控件的路由事件来触发</strong>的，例如，当按钮被点击时，播放一个动画。</li>
<li>多条件触发器（MultiTrigger、MultiDataTrigger）：这种触发器是<strong>根据多个条件的组合来触发</strong>的，例如，当控件的属性和绑定的数据同时满足某些值时，改变控件的样式。</li>
</ul>
<h5 id="基本触发器"><a href="#基本触发器" class="headerlink" title="基本触发器"></a>基本触发器</h5><p>基本触发器控制鼠标经过或按下时的案例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;Style.Triggers&gt;</span><br><span class="line">  &lt;!--鼠标经过时--&gt;</span><br><span class="line">    &lt;Trigger Property=&quot;IsMouseOver&quot; Value=&quot;True&quot;&gt;</span><br><span class="line">        &lt;Setter Property=&quot;Background&quot; Value=&quot;White&quot;/&gt;</span><br><span class="line">        &lt;Setter Property=&quot;Foreground&quot; Value=&quot;#0072C8&quot;/&gt;</span><br><span class="line">    &lt;/Trigger&gt;</span><br><span class="line">    &lt;!--鼠标按下时--&gt;</span><br><span class="line">    &lt;Trigger Property=&quot;IsMouseCaptured&quot; Value=&quot;True&quot;&gt;</span><br><span class="line">        &lt;Setter Property=&quot;Background&quot; Value=&quot;#9972C8&quot;/&gt;</span><br><span class="line">        &lt;Setter Property=&quot;Foreground&quot; Value=&quot;White&quot;/&gt;</span><br><span class="line">    &lt;/Trigger&gt;</span><br><span class="line">&lt;/Style.Triggers&gt;</span><br></pre></td></tr></table></figure>

<h5 id="多条件触发器"><a href="#多条件触发器" class="headerlink" title="多条件触发器"></a>多条件触发器</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;Style.Triggers&gt;</span><br><span class="line">  &lt;MultiTrigger&gt;</span><br><span class="line">    &lt;!--下面条件满足--&gt;</span><br><span class="line">    &lt;MultiTrigger.Condition&gt;  &lt;!--一个Condition相当于Trigger中的    &lt;Trigger Property=&quot;IsMouseOver&quot; Value=&quot;True&quot;&gt;这一行--&gt;</span><br><span class="line">      &lt;Condition Property=&quot;IsFocused&quot; Value=&quot;True&quot;/&gt;</span><br><span class="line">      &lt;Condition Property=&quot;Text&quot; Value=&quot;WPF&quot;/&gt;</span><br><span class="line">    &lt;/MultiTrigger.Condition&gt;</span><br><span class="line">    &lt;!--才触发下面改变--&gt;</span><br><span class="line">    &lt;MultiTrigger.Setters&gt;</span><br><span class="line">      &lt;Setter Property=&quot;background&quot; Value=&quot;LightPink&quot;/&gt;</span><br><span class="line">    &lt;/MultiTrigger.Setters&gt;</span><br><span class="line">  &lt;/MultiTrigger&gt;</span><br><span class="line">&lt;/Style.Triggers&gt;</span><br></pre></td></tr></table></figure>

<p>当条件同时满足时,才会触发</p>
<h5 id="数据触发器"><a href="#数据触发器" class="headerlink" title="数据触发器"></a>数据触发器</h5><p>该触发器无非就是多了Binding属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Style.Triggers&gt;</span><br><span class="line">  &lt;DataTrigger Binding=&quot;&#123;Binding RelativeSource=&#123;x:Static RelativeSource.Self&#125;,Path=Text&#125;&quot; Value=&quot;WPF&quot;&gt;</span><br><span class="line">    &lt;Setter Property=&quot;Background&quot; Value=&quot;LightPink&quot;/&gt;</span><br><span class="line">  &lt;/DataTrigger&gt;</span><br><span class="line">&lt;/Style.Triggers&gt;</span><br></pre></td></tr></table></figure>

<h5 id="多路数据触发器"><a href="#多路数据触发器" class="headerlink" title="多路数据触发器"></a>多路数据触发器</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;Style.Triggers&gt;</span><br><span class="line">  &lt;MultiDataTrigger&gt;</span><br><span class="line">     &lt;!--下面条件满足--&gt;</span><br><span class="line">    &lt;MultiDataTrigger.Conditions&gt;</span><br><span class="line">      &lt;Condition Property=&quot;&#123;Binding Path=Sex&#125;&quot; Value=&quot;Man&quot; /&gt;</span><br><span class="line">      &lt;Condition Property=&quot;IsEnabled&quot; Value=&quot;False&quot; /&gt;</span><br><span class="line">    &lt;/MultiDataTrigger.Conditions&gt;</span><br><span class="line">    &lt;!--才触发下面改变--&gt;</span><br><span class="line">    &lt;Setter Property=&quot;Background&quot; Value=&quot;Red&quot; /&gt;</span><br><span class="line">    &lt;Setter Property=&quot;Foreground&quot; Value=&quot;White&quot; /&gt;</span><br><span class="line">  &lt;/MultiDataTrigger&gt;</span><br><span class="line">&lt;/Style.Triggers&gt;</span><br></pre></td></tr></table></figure>

<h5 id="事件触发器"><a href="#事件触发器" class="headerlink" title="事件触发器"></a>事件触发器</h5><p>以窗口的加载事件为例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">xmlns:i=&quot;http://schemas.microsoft.com/xaml/behaviors&quot;</span><br><span class="line">&lt;!--接到上面的命名空间后--&gt;</span><br><span class="line">&lt;i:Interaction.Triggers&gt;</span><br><span class="line">    &lt;i:EventTrigger EventName=&quot;Loaded&quot;&gt;</span><br><span class="line">        &lt;i:InvokeCommandAction Command=&quot;&#123;Binding LoadedCommand&#125;&quot;/&gt;</span><br><span class="line">    &lt;/i:EventTrigger&gt;</span><br><span class="line">    &lt;i:EventTrigger EventName=&quot;Unloaded&quot;&gt;</span><br><span class="line">        &lt;i:InvokeCommandAction Command=&quot;&#123;Binding UnloadedCommand&#125;&quot;/&gt;</span><br><span class="line">    &lt;/i:EventTrigger&gt;</span><br><span class="line">&lt;/i:Interaction.Triggers&gt;</span><br></pre></td></tr></table></figure>

<p>这里值得注意的是: <code>Unloaded</code>在窗口关闭的时候并不会触发,应该用Closing绑定的事件才能触发</p>
<h4 id="控件模板案例"><a href="#控件模板案例" class="headerlink" title="控件模板案例"></a>控件模板案例</h4><p>以按钮的自定义模板为例</p>
<p>通过 <code>&#123;TemplateBinding xxx&#125;</code>来获取使用模板传入的属性xxx</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button Width=&quot;300&quot; Height=&quot;100&quot; Content=&quot;自定义按钮&quot; &gt;</span><br><span class="line">    &lt;Button.Template&gt;</span><br><span class="line">        &lt;ControlTemplate TargetType=&quot;&#123;x:Type Button&#125;&quot;&gt;</span><br><span class="line">            &lt;!--设置模板的外观--&gt;</span><br><span class="line">            &lt;Border x:Name=&quot;border&quot;  Background=&quot;&#123;TemplateBinding Background&#125;&quot; BorderBrush=&quot;Black&quot; BorderThickness=&quot;1&quot; CornerRadius=&quot;10&quot;&gt;</span><br><span class="line">                &lt;TextBlock Text=&quot;&#123;TemplateBinding Content&#125;&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;/&gt;</span><br><span class="line">            &lt;/Border&gt;</span><br><span class="line">            &lt;!--设置模板的交互--&gt;</span><br><span class="line">            &lt;ControlTemplate.Triggers&gt;</span><br><span class="line">                &lt;Trigger Property=&quot;IsMouseOver&quot; Value=&quot;True&quot;&gt;</span><br><span class="line">                    &lt;Setter TargetName=&quot;border&quot; Property=&quot;Background&quot; Value=&quot;Black&quot;/&gt;</span><br><span class="line">                &lt;/Trigger&gt;</span><br><span class="line">            &lt;/ControlTemplate.Triggers&gt;</span><br><span class="line">        &lt;/ControlTemplate&gt;</span><br><span class="line">    &lt;/Button.Template&gt;</span><br><span class="line">&lt;/Button&gt;</span><br></pre></td></tr></table></figure>

<p>上面这种写法只能作用于该Button在App.xaml中引用新添加的资源词典,在资源词典中写样式,就可以用于全部控件.</p>
<p>也可以新建一个CustomButton继承Button,资源词典中的样式就针对CustomButton来编写</p>
<p>上描述的资源词典写法如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;ResourceDictionary xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span><br><span class="line">                    xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span><br><span class="line">                    xmlns:local=&quot;clr-namespace:testGrid&quot;&gt;</span><br><span class="line">                    &lt;!-- 上面引入项目的命名空间 --&gt;</span><br><span class="line">  &lt;!--下面可以添加x:Key指定引用名,只让某些元素引用--&gt;</span><br><span class="line">    &lt;Style TargetType=&quot;&#123;x:Type local:CustomButton&#125;&quot;&gt;</span><br><span class="line">        &lt;Setter Property=&quot;Template&quot;&gt;</span><br><span class="line">            &lt;Setter.Value&gt;</span><br><span class="line">                &lt;ControlTemplate TargetType=&quot;&#123;x:Type local:CustomButton&#125;&quot;&gt;</span><br><span class="line">                    &lt;Border Name=&quot;buttonBorder&quot; Background=&quot;Gray&quot; CornerRadius=&quot;&#123;TemplateBinding ButtonCornerRadius&#125;&quot; Width=&quot;&#123;TemplateBinding Width&#125;&quot; Height=&quot;&#123;TemplateBinding Height&#125;&quot;&gt;</span><br><span class="line">                        &lt;TextBlock Text=&quot;&#123;TemplateBinding Content&#125;&quot; HorizontalAlignment=&quot;&#123;TemplateBinding HorizontalContentAlignment&#125;&quot; VerticalAlignment=&quot;&#123;TemplateBinding VerticalContentAlignment&#125;&quot;/&gt;</span><br><span class="line">                    &lt;/Border&gt;</span><br><span class="line">                    &lt;!--触发器中不能使用TemplateBinding写法,取而代之的语法是&#123;Binding 属性名,RelativeSource=&#123;RelativeSource TemplatedParent&#125;&#125;--&gt;</span><br><span class="line">                    &lt;ControlTemplate.Triggers&gt;</span><br><span class="line">                        &lt;Trigger Property=&quot;IsMouseOver&quot; Value=&quot;True&quot;&gt;</span><br><span class="line">                            &lt;Setter TargetName=&quot;buttonBorder&quot; Property=&quot;Background&quot; Value=&quot;&#123;Binding BackgroundHover,RelativeSource=&#123;RelativeSource TemplatedParent&#125;&#125;&quot;/&gt;</span><br><span class="line">                        &lt;/Trigger&gt;</span><br><span class="line">                        &lt;Trigger Property=&quot;IsPressed&quot; Value=&quot;True&quot;&gt;</span><br><span class="line">                            &lt;Setter TargetName=&quot;buttonBorder&quot; Property=&quot;Background&quot; Value=&quot;white&quot;/&gt;</span><br><span class="line">                        &lt;/Trigger&gt;</span><br><span class="line">                    &lt;/ControlTemplate.Triggers&gt;</span><br><span class="line">                &lt;/ControlTemplate&gt;</span><br><span class="line">            &lt;/Setter.Value&gt;</span><br><span class="line">        &lt;/Setter&gt;</span><br><span class="line">    &lt;/Style&gt;</span><br><span class="line">&lt;/ResourceDictionary&gt;</span><br></pre></td></tr></table></figure>

<p><a href="#%E6%A8%A1%E6%9D%BF%E4%B8%AD%E7%9A%84%E7%BB%91%E5%AE%9A%E6%B3%A8%E6%84%8F%E9%A1%B9">注意</a></p>
<h3 id="数据模板"><a href="#数据模板" class="headerlink" title="数据模板"></a>数据模板</h3><p>在WPF中，有两种类型的控件支持数据模板：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202408271011614.png" alt="image-20240827101114770" style="zoom:33%;" />

<p>• <strong>内容控件</strong>通过ContentTemplate属性支持数据模板。内容模板用于显示任何放置在Content属性中的内容<br>• <strong>列表控件</strong>（继承自ItemsControl类的控件）通过ItemTemplate或者CelTemplate属性（DataGrid使用）支持数据模板。这个模板 用于显示作为ItemsSource提供的集合中的每个项（或者来自DataTable的每一行）</p>
<p><strong>定义数据模板</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;DataTemplate x:Key=&quot;xxxTemplate&quot; DataType=&quot;&#123;x:Type local:Employee&#125;&gt;</span><br><span class="line">  &lt;!--放置什么都可以--&gt;</span><br><span class="line">&lt;/DataTemplate&gt;</span><br></pre></td></tr></table></figure>

<p>通过DataType直接绑定某个类型,在DataTemplate内部就可以直接绑定该类型内部的成员,如:<code>Text=&quot;&#123;Binding Job&#125;&quot;</code>例子中的Job是Employee类型的一个成员</p>
<p><strong>使用数据模板</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;UserControl ContentTemplate ContentTemplate=&quot;&#123;StaticResource xxxTemplate&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h4 id="数据模板盘点"><a href="#数据模板盘点" class="headerlink" title="数据模板盘点"></a>数据模板盘点</h4><ol>
<li><strong>DataTemplate</strong></li>
</ol>
<ul>
<li><p><strong>用途</strong>：用于定义如何显示单个数据对象的视觉表示。可以用于任何控件，例如 <code>ListBox</code>、<code>ComboBox</code>、<code>ContentControl</code> 等。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">DataTemplate</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextBlock</span> <span class="attr">Text</span>=<span class="string">&quot;&#123;Binding Name&#125;&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">DataTemplate</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li><strong>HierarchicalDataTemplate</strong></li>
</ol>
<ul>
<li><p><strong>用途</strong>：用于表示层级数据结构，特别是在树形控件（如 <code>TreeView</code>）中。可以定义父项及其子项的显示方式。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">HierarchicalDataTemplate</span> <span class="attr">ItemsSource</span>=<span class="string">&quot;&#123;Binding Children&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextBlock</span> <span class="attr">Text</span>=<span class="string">&quot;&#123;Binding Name&#125;&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">HierarchicalDataTemplate</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li><strong>ItemTemplate</strong></li>
</ol>
<ul>
<li><p><strong>用途</strong>：用于定义集合中每个项的显示方式。通常用于 <code>ItemsControl</code>、<code>ListBox</code>、<code>ComboBox</code> 等控件。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ListBox.ItemTemplate</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">DataTemplate</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextBlock</span> <span class="attr">Text</span>=<span class="string">&quot;&#123;Binding Name&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">DataTemplate</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ListBox.ItemTemplate</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="4">
<li><strong>ControlTemplate</strong></li>
</ol>
<ul>
<li><p><strong>用途</strong>：用于定义控件的外观和行为。可以完全替换控件的视觉树。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ControlTemplate</span> <span class="attr">TargetType</span>=<span class="string">&quot;Button&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Border</span> <span class="attr">Background</span>=<span class="string">&quot;&#123;TemplateBinding Background&#125;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ContentPresenter</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Border</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ControlTemplate</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="5">
<li><strong>Style</strong></li>
</ol>
<ul>
<li><p><strong>用途</strong>：虽然不是严格意义上的模板，但样式可以定义控件的外观和行为，包括触发器和属性设置。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Style</span> <span class="attr">TargetType</span>=<span class="string">&quot;Button&quot;</span>&gt;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Setter</span> <span class="attr">Property</span>=<span class="string">&quot;Background&quot;</span> <span class="attr">Value</span>=<span class="string">&quot;Blue&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Setter</span> <span class="attr">Property</span>=<span class="string">&quot;Foreground&quot;</span> <span class="attr">Value</span>=<span class="string">&quot;White&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">Style</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="6">
<li><strong>DataTemplateSelector</strong></li>
</ol>
<ul>
<li><p><strong>用途</strong>：用于根据特定条件选择不同的数据模板。可以在运行时决定使用哪个模板。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyTemplateSelector</span> : <span class="title">DataTemplateSelector</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> DataTemplate Template1 &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DataTemplate Template2 &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> DataTemplate <span class="title">SelectTemplate</span>(<span class="params"><span class="built_in">object</span> item, DependencyObject container</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (item <span class="keyword">is</span> Type1)</span><br><span class="line">            <span class="keyword">return</span> Template1;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> Template2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="层级数据模板"><a href="#层级数据模板" class="headerlink" title="层级数据模板"></a>层级数据模板</h4><p><strong>HierarchicalDataTemplate</strong></p>
<p>WPF中的HierarchicalDataTemplate是一种用于定义具有层次结构的数据的显示方式的模板。它可以用于支持HeaderedltemsControl的控件，例如TreeView或Menu。HierarchicalDataTemplate有一个<strong>ItemsSource属性，用于指定子节点的数据源，以及一个ItemTemplate属性，用于指定子节点的模板</strong>。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202408271040875.png" alt="image-20240827104004481" style="zoom:33%;" />

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;HierarchicalDataTemplate DataType=&quot;&#123;x:Type local:CompanyData&#125;&quot; ItemsSource=&quot;&#123;Binding Path=DepartmentDatas&#125;&quot;&gt;</span><br><span class="line">    &lt;TextBlock Text=&quot;&#123;Binding Name&#125;&quot;/&gt;</span><br><span class="line">&lt;/HierarchicalDataTemplate&gt;</span><br><span class="line">&lt;HierarchicalDataTemplate DataType=&quot;&#123;x:Type local:DepartmentData&#125;&quot; ItemsSource=&quot;&#123;Binding Path=EmployeeDatas&#125;&quot;&gt;</span><br><span class="line">    &lt;RadioButton Content=&quot;&#123;Binding Name&#125;&quot;/&gt;</span><br><span class="line">&lt;/HierarchicalDataTemplate&gt;</span><br><span class="line">&lt;HierarchicalDataTemplate DataType=&quot;&#123;x:Type local:EmployeeData&#125;&quot;&gt;</span><br><span class="line">    &lt;CheckBox Content=&quot;&#123;Binding Name&#125;&quot;/&gt;</span><br><span class="line">&lt;/HierarchicalDataTemplate&gt;</span><br></pre></td></tr></table></figure>

<h4 id="自定义数据项模板"><a href="#自定义数据项模板" class="headerlink" title="自定义数据项模板"></a>自定义数据项模板</h4><p>暂时放这,不知道是否合适</p>
<p>ItemsControl 是 WPF 中的一个控件，用于显示一组数据项。它提供了一种灵活的方式来定义如何呈现和布局这些数据项。以下是 ItemsControl 的一些主要用途和功能：</p>
<ol>
<li>数据绑定<br>ItemsControl 通常与数据绑定一起使用，通过 ItemsSource 属性绑定到一个集合（如 List、ObservableCollection 等）。每个数据项都会生成一个对应的 UI 元素。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ItemsControl ItemsSource=&quot;&#123;Binding MyDataCollection&#125;&quot;&gt;</span><br><span class="line">    &lt;!-- 定义数据项的模板 --&gt;</span><br><span class="line">&lt;/ItemsControl&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>自定义数据项模板<br>通过 ItemTemplate 属性，可以定义每个数据项的显示模板。DataTemplate 用于描述每个数据项的外观。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;ItemsControl ItemsSource=&quot;&#123;Binding MyDataCollection&#125;&quot;&gt;</span><br><span class="line">    &lt;ItemsControl.ItemTemplate&gt;</span><br><span class="line">        &lt;DataTemplate&gt;</span><br><span class="line">            &lt;TextBlock Text=&quot;&#123;Binding Name&#125;&quot; /&gt;</span><br><span class="line">        &lt;/DataTemplate&gt;</span><br><span class="line">    &lt;/ItemsControl.ItemTemplate&gt;</span><br><span class="line">&lt;/ItemsControl&gt;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>样式和外观<br>可以通过 ItemContainerStyle 属性自定义每个数据项容器的样式。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;ItemsControl ItemsSource=&quot;&#123;Binding MyDataCollection&#125;&quot;&gt;</span><br><span class="line">    &lt;ItemsControl.ItemContainerStyle&gt;</span><br><span class="line">        &lt;Style TargetType=&quot;ContentPresenter&quot;&gt;</span><br><span class="line">            &lt;Setter Property=&quot;Margin&quot; Value=&quot;5&quot; /&gt;</span><br><span class="line">        &lt;/Style&gt;</span><br><span class="line">    &lt;/ItemsControl.ItemContainerStyle&gt;</span><br><span class="line">&lt;/ItemsControl&gt;</span><br></pre></td></tr></table></figure>

<h3 id="ObservableCollection"><a href="#ObservableCollection" class="headerlink" title="ObservableCollection"></a>ObservableCollection</h3><p><code>ObservableCollection&lt;T&gt;</code>是 WPF 提供的一个类，它表示一个动态数据集合，当集合中的项添加、移除或刷新时，它会提供通知。<br>• 当集合发生变化时，会触发CollectionChanged 事件；<br>• 当集合的属性（如 Count 或 Item［］）发生变化时，就会触发PropertyChanged 事件。</p>
<p>使用ObservableCollection后,框架本身也就可以支持使用该</p>
<blockquote>
<p>注意注意:ObservableCollection的Clear方法不会触发ui更新,要尤其注意.可以重新new一个ObservableCollection来赋值作为Clear</p>
</blockquote>
<p>类似AddRange这种原本不属于ObservableCollection,而是属于Linq语法的,也不支持自动更新ui,使用下面原始语法例子代替AddRange</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> b <span class="keyword">in</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">    RecvMessage.Add(b);<span class="comment">//能更新绑定的ui</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代替</span></span><br><span class="line">RecvMessage.AddRange(bytes);<span class="comment">//不能更新绑定的ui</span></span><br></pre></td></tr></table></figure>

<h3 id="模板的内部访问"><a href="#模板的内部访问" class="headerlink" title="模板的内部访问"></a>模板的内部访问</h3><h4 id="控件模板的内部访问"><a href="#控件模板的内部访问" class="headerlink" title="控件模板的内部访问"></a>控件模板的内部访问</h4><p>ControlTemplate和DataTemplate两个类均派生自FrameworkTemplate类，这个类有个名为 <code>FindName</code>的方法提供我们检索其内部的控件。</p>
<p>控件模板的内部访问非常简单，核心在于针对目标控件的Template属性使用FindName方法，并使用as关键字指定类型即可。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TextBox? tbx = <span class="keyword">this</span>.uc.Template.FindName（<span class="string">&quot;textBox&quot;</span>， <span class="keyword">this</span>.uc） <span class="keyword">as</span> TextBox；</span><br><span class="line">Slider? sl = <span class="keyword">this</span>.up.Template.FindName（<span class="string">&quot;&#x27;slider&quot;</span>， <span class="keyword">this</span>.uc） <span class="keyword">as</span> Slider；</span><br><span class="line">StackPaneL? sp = tbx.Parent <span class="keyword">as</span> StackPaneL；</span><br></pre></td></tr></table></figure>

<p>其实就是去找到对应控件的Template属性,再调用它的FindName方法</p>
<h4 id="数据模板的内部访问"><a href="#数据模板的内部访问" class="headerlink" title="数据模板的内部访问"></a>数据模板的内部访问</h4><p>数据模板的内部访问核心在于对于视觉树的检索，通常需要自建一个 <code>FindVisualChild&lt;T&gt;</code>方法，通过指定需要访问的目标类型，借助VisualTreeHelper 类的 GetChild 方法，递归地遍历 ListBoxltem 的<a href="#%E8%A7%86%E8%A7%89%E6%A0%91">可视化树</a>，直到找到你想要的控件。</p>
<h1 id="属性优先级规则"><a href="#属性优先级规则" class="headerlink" title="属性优先级规则"></a>属性优先级规则</h1><p>WPF 有一套明确的属性优先级规则，大致如下（从高到低）：</p>
<ul>
<li><strong>控件的直接属性设置（XAML 中手动设置的值）</strong>。</li>
<li><strong>动画和数据绑定的值</strong>。</li>
<li><strong>控件模板 (<strong>ControlTemplate</strong>) 中的</strong> Trigger <strong>设置</strong>。</li>
<li>Style <strong>中的</strong> Setter <strong>和</strong> Trigger。</li>
<li><strong>默认值</strong>。</li>
</ul>
<h1 id="自定义控件与用户控件"><a href="#自定义控件与用户控件" class="headerlink" title="自定义控件与用户控件"></a>自定义控件与用户控件</h1><ul>
<li><strong>自定义控件（CustomControl）</strong>通常<strong>涉及对控件的更底层的渲染和行为进行定义</strong>。这包括从Control类或其他更具体的控件类继承以创建控件类，<strong>定义控件的默认样式和模板，添加新的依赖属性，根据需要重写方法以自定义控件的行为</strong>，以及定义和触发自定义事件等步骤。这样的控件通常是从头开始创建或扩展现有控件功能的，可以具有很高的灵活性和自定义程度。</li>
<li><strong>用户控件（User Control）</strong>则是通过<strong>组合</strong>其他控件来构建的。用户控件允许开发者在其应用程序中轻松地添加和删除控件，以实现特定功能。创建用户控件需要创建一个新的类，并继承自System.Windows.Controls. UserControl，然后在用户控件类中添加所需的UI元素，如按钮、文本框等，还可以添加事件处理程序和方法以实现自定义功能。同样可以添加依赖属性</li>
</ul>
<p>使用难度来说: 自定义控件的开发过程相对复杂，因它们涉及到底层的渲染和行为定义，且没有设计器提供设计支持。而用户控件的开发过程则相对简单，并且有设计器提供设计支持，使得开发者能够更直观地构建和编辑控件。</p>
<p>自定义控件,一般用于控件的继承,用于将一个控件继承出一个新的控件,出来的将会是一个cs文件</p>
<h2 id="用户控件-自定义控件案例"><a href="#用户控件-自定义控件案例" class="headerlink" title="用户控件&#x2F;自定义控件案例"></a>用户控件&#x2F;自定义控件案例</h2><p>以一个自定义控件MyCustomControl为例:</p>
<p>MyCustomControl.xaml</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;UserControl x:Class=&quot;YourNamespace.MyCustomControl&quot;</span><br><span class="line">             xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span><br><span class="line">             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;&gt;</span><br><span class="line">    &lt;Grid&gt;</span><br><span class="line">        &lt;TextBlock Text=&quot;&#123;Binding MyProperty, RelativeSource=&#123;RelativeSource AncestorType=UserControl&#125;&#125;&quot; /&gt;</span><br><span class="line">    &lt;/Grid&gt;</span><br><span class="line">&lt;/UserControl&gt;</span><br></pre></td></tr></table></figure>

<p>MyCustomControl.xaml.cs</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Windows;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Controls;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">YourNamespace</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">MyCustomControl</span> : <span class="title">UserControl</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyCustomControl</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册依赖属性</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> DependencyProperty MyPropertyProperty =</span><br><span class="line">            DependencyProperty.Register(<span class="string">&quot;MyProperty&quot;</span>, <span class="keyword">typeof</span>(<span class="built_in">string</span>), <span class="keyword">typeof</span>(MyCustomControl), <span class="keyword">new</span> PropertyMetadata(<span class="built_in">string</span>.Empty));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// CLR 属性包装器</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> MyProperty</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span> &#123; <span class="keyword">return</span> (<span class="built_in">string</span>)GetValue(MyPropertyProperty); &#125;</span><br><span class="line">            <span class="keyword">set</span> &#123; SetValue(MyPropertyProperty, <span class="keyword">value</span>); &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用方式: <code> &lt;local:MyCustomControl MyProperty=&quot;你好，世界！&quot; /&gt;</code></p>
<p>解释:</p>
<ol>
<li><strong>依赖属性注册</strong>：在 <code>MyCustomControl</code> 类中，使用 <code>DependencyProperty.Register</code> 方法注册一个名为 <code>MyProperty</code> 的依赖属性。这个属性的类型是 <code>string</code>，并且它的默认值是一个空字符串。</li>
<li><strong>CLR 属性包装器</strong>：定义一个 CLR 属性 <code>MyProperty</code>，它使用 <code>GetValue</code> 和 <code>SetValue</code> 方法来访问和设置依赖属性的值。</li>
<li><strong>XAML 绑定</strong>：在 XAML 中，使用 <code>&#123;Binding MyProperty, RelativeSource=&#123;RelativeSource AncestorType=UserControl&#125;&#125;</code> 来绑定 <code>TextBlock</code> 的 <code>Text</code> 属性到 <code>MyProperty</code>。</li>
</ol>
<blockquote>
<ul>
<li><p><strong><code>&lt;TextBlock Text=&quot;&#123;Binding MyProperty&#125;&quot; /&gt;</code></strong>:</p>
<p>这种方式依赖于 <code>DataContext</code> 的设置。如果 <code>MyCustomControl</code> 的 <code>DataContext</code> 被设置为某个视图模型，<code>TextBlock</code> 将会从这个视图模型中查找 <code>MyProperty</code>。</p>
<p>如果 <code>MyCustomControl</code> 的 <code>DataContext</code> 没有被设置，或者没有包含 <code>MyProperty</code>，则会导致绑定失败。</p>
</li>
<li><p><strong><code>&lt;TextBlock Text=&quot;&#123;Binding MyProperty, RelativeSource=&#123;RelativeSource AncestorType=UserControl&#125;&#125;&quot; /&gt;</code></strong>:</p>
<p>这种方式明确指定了绑定的来源是 <code>UserControl</code> 本身。这意味着无论 <code>DataContext</code> 是什么，<code>TextBlock</code> 都会从 <code>MyCustomControl</code> 中获取 <code>MyProperty</code> 的值。</p>
<p>这种方式更加可靠，确保了无论外部 <code>DataContext</code> 如何变化，<code>TextBlock</code> 都能够正确显示 <code>MyProperty</code> 的值。</p>
</li>
</ul>
</blockquote>
<h2 id="ItemsControl-1"><a href="#ItemsControl-1" class="headerlink" title="ItemsControl"></a>ItemsControl</h2><p>案例如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;ItemsControl Grid.Row=&quot;1&quot;</span><br><span class="line">              ItemsSource=&quot;&#123;Binding ShowStrings, RelativeSource=&#123;RelativeSource AncestorType=UserControl&#125;&#125;&quot;&gt;</span><br><span class="line">    &lt;ItemsControl.ItemsPanel&gt;</span><br><span class="line">        &lt;ItemsPanelTemplate&gt;</span><br><span class="line">            &lt;UniformGrid Columns=&quot;&#123;Binding ShowStrings.Count, RelativeSource=&#123;RelativeSource AncestorType=UserControl&#125;&#125;&quot;/&gt;</span><br><span class="line">        &lt;/ItemsPanelTemplate&gt;</span><br><span class="line">    &lt;/ItemsControl.ItemsPanel&gt;</span><br><span class="line">    &lt;ItemsControl.ItemTemplate&gt;</span><br><span class="line">        &lt;DataTemplate&gt;</span><br><span class="line">            &lt;Border</span><br><span class="line">                Background=&quot;White&quot;</span><br><span class="line">                BorderBrush=&quot;LightGray&quot;</span><br><span class="line">                BorderThickness=&quot;1&quot;&gt;</span><br><span class="line">                &lt;TextBlock</span><br><span class="line">                    Margin=&quot;10,0,0,0&quot;</span><br><span class="line">                    HorizontalAlignment=&quot;Left&quot;</span><br><span class="line">                    VerticalAlignment=&quot;Center&quot;</span><br><span class="line">                    FontSize=&quot;16&quot;</span><br><span class="line">                    FontWeight=&quot;Bold&quot;</span><br><span class="line">                    Foreground=&quot;DarkRed&quot;</span><br><span class="line">                    Text=&quot;&#123;Binding .&#125;&quot;/&gt;</span><br><span class="line">            &lt;/Border&gt;</span><br><span class="line">        &lt;/DataTemplate&gt;</span><br><span class="line">    &lt;/ItemsControl.ItemTemplate&gt;</span><br><span class="line">&lt;/ItemsControl&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>ItemsSource 绑定到 ShowStrings 集合。</li>
<li>UniformGrid 的列数绑定到 ShowStrings.Count。</li>
<li>TextBlock 的 Text 属性绑定到当前项的值（<code>Binding .</code>)</li>
</ul>
<p><strong>ItemsPanelTemplate</strong></p>
<ul>
<li>定义了 ItemsControl 的面板模板。</li>
<li>使用 UniformGrid 来布局子项。</li>
<li>Columns&#x3D;”{Binding ShowStrings.Count, RelativeSource&#x3D;{RelativeSource AncestorType&#x3D;UserControl}}”: 设置 UniformGrid 的列数为 ShowStrings 集合的项数。</li>
</ul>
<p><strong>ItemTemplate</strong></p>
<ul>
<li>定义了每个子项的模板。</li>
<li>使用 DataTemplate 来定义子项的外观。</li>
</ul>
<h2 id="实现控件自定义所需知识点盘点"><a href="#实现控件自定义所需知识点盘点" class="headerlink" title="实现控件自定义所需知识点盘点"></a>实现控件自定义所需知识点盘点</h2><h1 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h1><p>进入动画代码详解:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  动画  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">MultiTrigger.EnterActions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">BeginStoryboard</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Storyboard</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--  ThicknessAnimationUsingKeyFrames逐帧动画  --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">                Duration=&quot;时:分:秒&quot;  动画间隔多久</span></span><br><span class="line"><span class="comment">                AutoReverse  是否自动复原</span></span><br><span class="line"><span class="comment">                Storyboard.TargetName  动画针对谁</span></span><br><span class="line"><span class="comment">                Storyboard.TargetProperty 动画针对的属性</span></span><br><span class="line"><span class="comment">                From,To  将所设置的属性的值从多少(From)设置到多少(To)</span></span><br><span class="line"><span class="comment">                EasingFunction 缓动函数:</span></span><br><span class="line"><span class="comment">                  SineEase  三角函数缓动函数</span></span><br><span class="line"><span class="comment">                  BackEase  回弹式缓动函数函数</span></span><br><span class="line"><span class="comment">                  CubicEase  贝塞尔曲线缓动函数</span></span><br><span class="line"><span class="comment">                  PowerEase 有力量的缓动函数</span></span><br><span class="line"><span class="comment">                  等等非常多</span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ThicknessAnimation</span></span></span><br><span class="line"><span class="tag">                <span class="attr">AutoReverse</span>=<span class="string">&quot;True&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">Storyboard.TargetName</span>=<span class="string">&quot;PART_Border&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">Storyboard.TargetProperty</span>=<span class="string">&quot;Margin&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">From</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">To</span>=<span class="string">&quot;5&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">Duration</span>=<span class="string">&quot;0:0:0.2&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ThicknessAnimation.EasingFunction</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">PowerEase</span> <span class="attr">EasingMode</span>=<span class="string">&quot;EaseOut&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">ThicknessAnimation.EasingFunction</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">ThicknessAnimation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Storyboard</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">BeginStoryboard</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">MultiTrigger.EnterActions</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="动画案例"><a href="#动画案例" class="headerlink" title="动画案例"></a>动画案例</h2><p>下面以一个圆形红点的闪缩动画为例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;Window.Resources&gt;</span><br><span class="line">    &lt;Storyboard x:Key=&quot;FlashStoryboard&quot; RepeatBehavior=&quot;Forever&quot;&gt;</span><br><span class="line">        &lt;!--  瞬间切换到不透明  --&gt;</span><br><span class="line">        &lt;DoubleAnimation</span><br><span class="line">            Storyboard.TargetName=&quot;RecordEllipse&quot;</span><br><span class="line">            Storyboard.TargetProperty=&quot;Opacity&quot;</span><br><span class="line">            To=&quot;1&quot;</span><br><span class="line">            Duration=&quot;0:0:0&quot; /&gt;</span><br><span class="line">        &lt;!--  等待一段时间  --&gt;</span><br><span class="line">        &lt;DoubleAnimation</span><br><span class="line">            BeginTime=&quot;0:0:0.5&quot;</span><br><span class="line">            Storyboard.TargetName=&quot;RecordEllipse&quot;</span><br><span class="line">            Storyboard.TargetProperty=&quot;Opacity&quot;</span><br><span class="line">            To=&quot;1&quot;</span><br><span class="line">            Duration=&quot;0:0:0&quot; /&gt;</span><br><span class="line">        &lt;!--  切回透明  --&gt;</span><br><span class="line">        &lt;DoubleAnimation</span><br><span class="line">            BeginTime=&quot;0:0:1.0&quot;</span><br><span class="line">            Storyboard.TargetName=&quot;RecordEllipse&quot;</span><br><span class="line">            Storyboard.TargetProperty=&quot;Opacity&quot;</span><br><span class="line">            To=&quot;0&quot;</span><br><span class="line">            Duration=&quot;0:0:0&quot; /&gt;</span><br><span class="line">        &lt;!--  等待一段时间  --&gt;</span><br><span class="line">        &lt;DoubleAnimation</span><br><span class="line">            BeginTime=&quot;0:0:1.5&quot;</span><br><span class="line">            Storyboard.TargetName=&quot;RecordEllipse&quot;</span><br><span class="line">            Storyboard.TargetProperty=&quot;Opacity&quot;</span><br><span class="line">            To=&quot;0&quot;</span><br><span class="line">            Duration=&quot;0:0:0&quot; /&gt;</span><br><span class="line">    &lt;/Storyboard&gt;</span><br><span class="line">&lt;/Window.Resources&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--使用该动画--&gt;</span><br><span class="line"> &lt;Ellipse</span><br><span class="line">     x:Name=&quot;RecordEllipse&quot;</span><br><span class="line">     Width=&quot;8&quot;</span><br><span class="line">     Height=&quot;8&quot;</span><br><span class="line">     Margin=&quot;20,20,12,20&quot;</span><br><span class="line">     HorizontalAlignment=&quot;Right&quot;</span><br><span class="line">     VerticalAlignment=&quot;Bottom&quot;</span><br><span class="line">     Fill=&quot;Red&quot;</span><br><span class="line">     ToolTip=&quot;录制中&quot;</span><br><span class="line">     Visibility=&quot;&#123;Binding isSave, Converter=&#123;StaticResource Boolean2VisibilityConverter&#125;&#125;&quot;&gt;</span><br><span class="line">     &lt;Ellipse.Triggers&gt;</span><br><span class="line">         &lt;EventTrigger RoutedEvent=&quot;Window.Loaded&quot;&gt;</span><br><span class="line">             &lt;BeginStoryboard Storyboard=&quot;&#123;StaticResource FlashStoryboard&#125;&quot; /&gt;</span><br><span class="line">         &lt;/EventTrigger&gt;</span><br><span class="line">     &lt;/Ellipse.Triggers&gt;</span><br><span class="line"> &lt;/Ellipse&gt;</span><br></pre></td></tr></table></figure>

<p>Storyboard可以在resource中定义,使用key标识,然后在EventTrigger中的BeginStoryboard中使用key</p>
<h2 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TestButton.RenderTransform = <span class="keyword">new</span> RotateTransform()&#123; Angle = <span class="number">30</span> &#125;;<span class="comment">//旋转30度</span></span><br><span class="line"><span class="keyword">var</span> newPoint = TestButton.RenderTransform.Transform(<span class="keyword">new</span> Point(<span class="number">0</span>,<span class="number">0</span>));<span class="comment">//可以通过变换之前的点(0,0)得到变换后的点的坐标位置</span></span><br></pre></td></tr></table></figure>

<h1 id="渐变画刷写法记录"><a href="#渐变画刷写法记录" class="headerlink" title="渐变画刷写法记录"></a>渐变画刷写法记录</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextBlock&gt;</span><br><span class="line">    hello world!</span><br><span class="line">    &lt;TextBlock.Background&gt;</span><br><span class="line">        &lt;!--渐变画刷--&gt;</span><br><span class="line">        &lt;LinearGradientBrush StartPoint=&quot;0,0&quot; EndPoint=&quot;0,1&quot;&gt;</span><br><span class="line">            &lt;GradientStop Offset=&quot;0.0&quot; Color=&quot;AliceBlue&quot; /&gt;</span><br><span class="line">            &lt;GradientStop Offset=&quot;1.0&quot; Color=&quot;Black&quot; /&gt;</span><br><span class="line">        &lt;/LinearGradientBrush&gt;</span><br><span class="line">    &lt;/TextBlock.Background&gt;</span><br><span class="line">&lt;/TextBlock&gt;</span><br></pre></td></tr></table></figure>

<p>Offset</p>
<ul>
<li><code>Offset</code> 的值通常在 0.0 到 1.0 之间。</li>
<li>0.0 表示渐变的起始位置，而 1.0 表示渐变的结束位置。</li>
</ul>
<p>StartPoint&#x2F;EndPoint</p>
<ul>
<li><strong>StartPoint</strong>：表示渐变的起始点，通常以坐标的形式给出</li>
<li><strong>EndPoint</strong>：表示渐变的结束点，通常也是以坐标的形式给出</li>
</ul>
<p>可选值如下:</p>
<ul>
<li><strong>0, 0</strong>：表示渐变从左上角开始或结束</li>
<li><strong>0, 1</strong>：表示渐变从左下角开始或结束</li>
<li><strong>1, 0</strong>：表示渐变从右上角开始或结束</li>
<li><strong>1, 1</strong>：表示渐变从右下角开始或结束</li>
</ul>
<h1 id="子线程中操作ui界面"><a href="#子线程中操作ui界面" class="headerlink" title="子线程中操作ui界面"></a>子线程中操作ui界面</h1><p>在 WPF 中，UI 控件绑定的属性通常是由 UI 线程（主线程）管理和更新的。在大多数情况下，不建议在子线程中直接操作绑定的属性，因为 WPF 的控件通常不是线程安全的，直接在非 UI 线程中操作可能会导致线程安全问题和界面更新异常。</p>
<p>如果您需要在子线程中更新 UI 控件的绑定属性，可以使用以下方法来确保线程安全：</p>
<ol>
<li><p><strong>使用 Dispatcher：</strong> 在子线程中通过控件的 Dispatcher 调度到 UI 线程执行更新操作。例如：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同步等待ui线程调用</span></span><br><span class="line">System.Windows.Application.Current.Dispatcher.Invoke(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 在 UI 线程中更新绑定属性</span></span><br><span class="line">    YourProperty = newValue;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//异步等待ui线程调用  Dispatcher.InvokeAsync 或 Dispatcher.BeginInvoke</span></span><br><span class="line">System.Windows.Application.Current.Dispatcher.InvokeAsync(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 在 UI 线程中更新绑定属性</span></span><br><span class="line">    YourProperty = newValue;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//上面这段代码一般会加await</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>使用 DispatcherTimer：</strong> 如果需要定时更新 UI 控件的绑定属性，可以使用 DispatcherTimer，它在 UI 线程上运行。例如：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Windows.Threading;</span><br><span class="line"></span><br><span class="line">DispatcherTimer timer = <span class="keyword">new</span> DispatcherTimer();</span><br><span class="line">timer.Interval = TimeSpan.FromSeconds(<span class="number">1</span>);</span><br><span class="line">timer.Tick += (sender, e) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 在 UI 线程中更新绑定属性</span></span><br><span class="line">    YourProperty = newValue;</span><br><span class="line">&#125;;</span><br><span class="line">timer.Start();</span><br></pre></td></tr></table></figure></li>
</ol>
<p>在执行Dispatcher操作之前，最好使用<strong>CheckAccess</strong>方法检查当前线程是否为UI线程。如果不是，再使用Invoke或BeginInvoke来确保操作在UI线程上执行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Dispatcher.CheckAccess())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 在UI线程上执行操作</span></span><br><span class="line">    textBox.Text = <span class="string">&quot;在UI线程上更新UI&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 在非UI线程上使用Invoke确保在UI线程上执行</span></span><br><span class="line">    Dispatcher.Invoke(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        textBox.Text = <span class="string">&quot;在UI线程上更新UI&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BindingOperations-EnableCollectionSynchronization"><a href="#BindingOperations-EnableCollectionSynchronization" class="headerlink" title="BindingOperations.EnableCollectionSynchronization"></a>BindingOperations.EnableCollectionSynchronization</h2><p>WPF 提供了 BindingOperations.EnableCollectionSynchronization 方法，允许你在多线程环境中安全地更新 ObservableCollection<T>。这个方法会启用集合的线程安全访问，使得你可以在后台线程中直接修改集合，而不需要显式地使用 Dispatcher。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ObservableCollection&lt;<span class="built_in">string</span>&gt; _dataCollection = <span class="keyword">new</span> ObservableCollection&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">object</span> _lock = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MainWindow</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    InitializeComponent();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启用集合的线程安全访问</span></span><br><span class="line">    BindingOperations.EnableCollectionSynchronization(_dataCollection, _lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在后台线程中接收数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnDataReceived</span>(<span class="params"><span class="built_in">string</span> data</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">lock</span> (_lock)</span><br><span class="line">    &#123;</span><br><span class="line">        _dataCollection.Add(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一种方法为自定义ObservableCollection</p>
<p>创建一个自定义的 <code>AsyncObservableCollection&lt;T&gt;</code>，它内部使用 Dispatcher 来确保所有对集合的修改都在 UI 线程上执行。这样可以简化代码，避免在每个地方都显式地使用 Dispatcher</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AsyncObservableCollection</span>&lt;<span class="title">T</span>&gt; : <span class="title">ObservableCollection</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params">T item</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Application.Current.Dispatcher.CheckAccess())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">base</span>.Add(item);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Application.Current.Dispatcher.Invoke(() =&gt; <span class="keyword">base</span>.Add(item));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类似地，可以重写其他方法（如 Remove、Insert 等）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用自定义的 AsyncObservableCollection</span></span><br><span class="line"><span class="keyword">private</span> AsyncObservableCollection&lt;<span class="built_in">string</span>&gt; _dataCollection = <span class="keyword">new</span> AsyncObservableCollection&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在后台线程中接收数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnDataReceived</span>(<span class="params"><span class="built_in">string</span> data</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    _dataCollection.Add(data); <span class="comment">// 自动调度到 UI 线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 UI 线程中修改集合</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModifyCollectionInUIThread</span>(<span class="params"><span class="built_in">string</span> data</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    _dataCollection.Add(data); <span class="comment">// 自动调度到 UI 线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="VS默认代码片段记录"><a href="#VS默认代码片段记录" class="headerlink" title="VS默认代码片段记录"></a>VS默认代码片段记录</h1><p>prop 快速生成属性代码(property)</p>
<p>propfull 快速生成完整属性代码</p>
<p>propdp 快速生成依赖属性</p>
<p>ctor 快速生成构造函数</p>
<p>cmd 快速生成Command</p>
<p>cmdfull 快速生成完整命令写法</p>
<h1 id="wpf相关库"><a href="#wpf相关库" class="headerlink" title="wpf相关库"></a>wpf相关库</h1><p><a target="_blank" rel="noopener" href="https://www.nuget.org/packages">nuget库查询网址</a></p>
<p><code>xctk</code>库</p>
<h2 id="HandyControl"><a href="#HandyControl" class="headerlink" title="HandyControl"></a>HandyControl</h2><p><a target="_blank" rel="noopener" href="https://github.com/HandyOrg/HandyControl">开源地址</a>   MIT开源</p>
<p><a target="_blank" rel="noopener" href="https://github.com/HandyOrg/HandyControl/releases/tag/v3.1.0">下载链接</a>  其中有各种控件效果打包而成的demo应用程序</p>
<p>参考链接:</p>
<p><a target="_blank" rel="noopener" href="https://handyorg.github.io/handycontrol/attach/borderElement/">提供的相关属性参考此处</a></p>
<blockquote>
<p>正确性未经验证</p>
</blockquote>
<p>HandyControl 是一个开源的 WPF 控件库，提供了一系列丰富的控件和功能，旨在帮助开发者更轻松地构建现代化的 WPF 应用程序。它包含了许多常用的控件和样式，极大地扩展了 WPF 的默认控件集。</p>
<h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h3><ol>
<li><strong>丰富的控件</strong>:<ul>
<li>HandyControl 提供了许多额外的控件，比如按钮、文本框、进度条、日期选择器、消息框等，这些控件通常具有更丰富的功能和更现代的外观。</li>
</ul>
</li>
<li><strong>主题和样式</strong>:<ul>
<li>它包含多种主题和样式，可以轻松地应用到整个应用程序中，帮助开发者快速实现统一的用户界面设计。</li>
</ul>
</li>
<li><strong>开源</strong>:<ul>
<li>HandyControl 是开源的，开发者可以自由使用、修改和扩展它的功能。</li>
</ul>
</li>
<li><strong>易于集成</strong>:<ul>
<li>它易于集成到现有的 WPF 项目中，并且有良好的文档和示例代码，帮助开发者快速上手。</li>
</ul>
</li>
</ol>
<h3 id="如何使用-HandyControl"><a href="#如何使用-HandyControl" class="headerlink" title="如何使用 HandyControl"></a>如何使用 HandyControl</h3><p>nuget包管理器安装HandyControl:<code>Install-Package HandyControl</code></p>
<p>App.xaml中引用:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;Application x:Class=&quot;YourNamespace.App&quot;</span><br><span class="line">             xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span><br><span class="line">             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span><br><span class="line">             StartupUri=&quot;MainWindow.xaml&quot;&gt;</span><br><span class="line">    &lt;Application.Resources&gt;</span><br><span class="line">        &lt;!-- 引用 HandyControl 的主题资源字典 --&gt;</span><br><span class="line">        &lt;ResourceDictionary&gt;</span><br><span class="line">            &lt;ResourceDictionary.MergedDictionaries&gt;</span><br><span class="line">                &lt;ResourceDictionary Source=&quot;pack://application:,,,/HandyControl;component/Themes/SkinDefault.xaml&quot;/&gt;</span><br><span class="line">                &lt;ResourceDictionary Source=&quot;pack://application:,,,/HandyControl;component/Themes/Theme.xaml&quot;/&gt;</span><br><span class="line">            &lt;/ResourceDictionary.MergedDictionaries&gt;</span><br><span class="line">        &lt;/ResourceDictionary&gt;</span><br><span class="line">    &lt;/Application.Resources&gt;</span><br><span class="line">&lt;/Application&gt;</span><br></pre></td></tr></table></figure>

<p><strong>应用主题</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;Window x:Class=&quot;YourNamespace.MainWindow&quot;</span><br><span class="line">        xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span><br><span class="line">        xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span><br><span class="line">        xmlns:hc=&quot;https://handyorg.github.io/handycontrol&quot;</span><br><span class="line">        Title=&quot;MainWindow&quot; Height=&quot;350&quot; Width=&quot;525&quot;&gt;</span><br><span class="line">    &lt;Grid&gt;</span><br><span class="line">        &lt;hc:Button Content=&quot;HandyControl Button&quot; Width=&quot;200&quot; Height=&quot;50&quot;/&gt;</span><br><span class="line">  &lt;/Grid&gt;</span><br></pre></td></tr></table></figure>

<h3 id="控件使用方式盘点"><a href="#控件使用方式盘点" class="headerlink" title="控件使用方式盘点"></a>控件使用方式盘点</h3><h4 id="滑动条"><a href="#滑动条" class="headerlink" title="滑动条"></a>滑动条</h4><h5 id="单值滑动条"><a href="#单值滑动条" class="headerlink" title="单值滑动条"></a>单值滑动条</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;hc:PreviewSlider</span><br><span class="line">     Width=&quot;220&quot;</span><br><span class="line">     Value=&quot;&#123;Binding Ch[0].SetTemperature, StringFormat=F1&#125;&quot;</span><br><span class="line">     Minimum=&quot;0.0&quot;</span><br><span class="line">     Maximum=&quot;&#123;Binding Ch[0].Uplimit&#125;&quot;</span><br><span class="line">     HorizontalAlignment=&quot;Stretch&quot;&gt;</span><br><span class="line">     &lt;hc:PreviewSlider.PreviewContent&gt;</span><br><span class="line">         &lt;Label Style=&quot;&#123;StaticResource LabelPrimary&#125;&quot;</span><br><span class="line">                Content=&quot;&#123;Binding Path=(hc:PreviewSlider.PreviewPosition),RelativeSource=&#123;RelativeSource Self&#125;&#125;&quot;</span><br><span class="line">                ContentStringFormat=&quot;#0.0 °C&quot;/&gt;</span><br><span class="line">     &lt;/hc:PreviewSlider.PreviewContent&gt;</span><br><span class="line"> &lt;/hc:PreviewSlider&gt;</span><br></pre></td></tr></table></figure>

<h5 id="范围滑动条"><a href="#范围滑动条" class="headerlink" title="范围滑动条"></a>范围滑动条</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;hc:RangeSlider</span><br><span class="line">    hc:TipElement.Visibility=&quot;Visible&quot;</span><br><span class="line">    hc:TipElement.Placement=&quot;Top&quot;</span><br><span class="line">    IsSnapToTickEnabled=&quot;True&quot;</span><br><span class="line">    Maximum=&quot;105.0&quot;</span><br><span class="line">    Minimum=&quot;-5.0&quot;</span><br><span class="line">    ValueStart=&quot;&#123;Binding Ch[0].OutputLowlimit&#125;&quot;</span><br><span class="line">    ValueEnd=&quot;&#123;Binding Ch[0].OutputUplimit&#125;&quot;</span><br><span class="line">    VerticalAlignment=&quot;Center&quot;</span><br><span class="line">    Grid.Column=&quot;1&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h4 id="进度按钮"><a href="#进度按钮" class="headerlink" title="进度按钮"></a>进度按钮</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;ToggleButton Style=&quot;&#123;StaticResource ToggleButtonLoading&#125;&quot;</span><br><span class="line">              &lt;!--下面控制是否显示进度条--&gt;</span><br><span class="line">              IsChecked=&quot;&#123;Binding ATStatus[1],Mode=TwoWay&#125;&quot;</span><br><span class="line">              Margin=&quot;50 0 10 0&quot;</span><br><span class="line">              HorizontalAlignment=&quot;Left&quot;</span><br><span class="line">              Content=&quot;启动自动演算&quot;</span><br><span class="line">              Command=&quot;&#123;Binding StartAT&#125;&quot;</span><br><span class="line">              CommandParameter=&quot;1&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h4 id="数字输入框"><a href="#数字输入框" class="headerlink" title="数字输入框"></a>数字输入框</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;hc:NumericUpDown  Value=&quot;&#123;Binding Ch[1].RatioBand, StringFormat=F1&#125;&quot;</span><br><span class="line">                   &lt;!--步长 --&gt;</span><br><span class="line">                      Increment=&quot;0.1&quot;</span><br><span class="line">                      &lt;!--控制精度 --&gt;</span><br><span class="line">                   ValueFormat=&quot;F1&quot; </span><br><span class="line">                   Tag=&quot;&#123;Binding TemperatureController.Ch[1].RatioBand&#125;&quot;</span><br><span class="line">                   Style=&quot;&#123;StaticResource IsChangedDifferenceStyle&#125;&quot;</span><br><span class="line">                   Margin=&quot;5&quot;</span><br><span class="line">                   Minimum=&quot;0&quot;/&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里介绍一种样式:</p>
<p>当Tag和Value属性不同的时候,应用红色阴影效果,当属性相同的时候,取消阴影效果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;Style TargetType=&quot;hc:NumericUpDown&quot;</span><br><span class="line">       x:Key=&quot;IsChangedDifferenceStyle&quot;</span><br><span class="line">       BasedOn=&quot;&#123;StaticResource &#123;x:Type hc:NumericUpDown&#125;&#125;&quot;&gt;</span><br><span class="line">    &lt;Style.Triggers&gt;</span><br><span class="line">        &lt;DataTrigger Value=&quot;True&quot;&gt;</span><br><span class="line">            &lt;DataTrigger.Binding&gt;</span><br><span class="line">                &lt;MultiBinding Converter=&quot;&#123;StaticResource IsValueChangedDifferenceMultiConverter&#125;&quot;&gt;</span><br><span class="line">                    &lt;Binding Path=&quot;Value&quot;</span><br><span class="line">                             RelativeSource=&quot;&#123;RelativeSource Self&#125;&quot;/&gt;</span><br><span class="line">                    &lt;Binding Path=&quot;Tag&quot;</span><br><span class="line">                             RelativeSource=&quot;&#123;RelativeSource Self&#125;&quot;/&gt;</span><br><span class="line">                &lt;/MultiBinding&gt;</span><br><span class="line">            &lt;/DataTrigger.Binding&gt;</span><br><span class="line">            &lt;Setter Property=&quot;Effect&quot;&gt;</span><br><span class="line">                &lt;Setter.Value&gt;</span><br><span class="line">                    &lt;DropShadowEffect Color=&quot;Red&quot;</span><br><span class="line">                                      BlurRadius=&quot;10&quot;</span><br><span class="line">                                      ShadowDepth=&quot;0&quot;/&gt;</span><br><span class="line">                &lt;/Setter.Value&gt;</span><br><span class="line">            &lt;/Setter&gt;</span><br><span class="line">        &lt;/DataTrigger&gt;</span><br><span class="line">        &lt;DataTrigger Value=&quot;False&quot;&gt;</span><br><span class="line">            &lt;DataTrigger.Binding&gt;</span><br><span class="line">                &lt;MultiBinding Converter=&quot;&#123;StaticResource IsValueChangedDifferenceMultiConverter&#125;&quot;&gt;</span><br><span class="line">                    &lt;Binding Path=&quot;Value&quot;</span><br><span class="line">                             RelativeSource=&quot;&#123;RelativeSource Self&#125;&quot;/&gt;</span><br><span class="line">                    &lt;Binding Path=&quot;Tag&quot;</span><br><span class="line">                             RelativeSource=&quot;&#123;RelativeSource Self&#125;&quot;/&gt;</span><br><span class="line">                &lt;/MultiBinding&gt;</span><br><span class="line">            &lt;/DataTrigger.Binding&gt;</span><br><span class="line">            &lt;Setter Property=&quot;Effect&quot;</span><br><span class="line">                    Value=&quot;&#123;x:Null&#125;&quot;/&gt;</span><br><span class="line">        &lt;/DataTrigger&gt;</span><br><span class="line">    &lt;/Style.Triggers&gt;</span><br><span class="line">&lt;/Style&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="开关按钮"><a href="#开关按钮" class="headerlink" title="开关按钮"></a>开关按钮</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;ToggleButton Style=&quot;&#123;StaticResource ToggleButtonLoading&#125;&quot;</span><br><span class="line">              IsChecked=&quot;&#123;Binding ATStatus[2],Mode=TwoWay&#125;&quot;</span><br><span class="line">              Margin=&quot;50 0 10 0&quot;</span><br><span class="line">              HorizontalAlignment=&quot;Left&quot;</span><br><span class="line">              Content=&quot;启动自动演算&quot;</span><br><span class="line">              Command=&quot;&#123;Binding StartAT&#125;&quot;</span><br><span class="line">              CommandParameter=&quot;2&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h4 id="按钮组"><a href="#按钮组" class="headerlink" title="按钮组"></a>按钮组</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;hc:ButtonGroup Margin=&quot;5&quot;&gt;</span><br><span class="line">    &lt;Button Content=&quot;应用&quot;</span><br><span class="line">            Command=&quot;&#123;Binding Set&#125;&quot;</span><br><span class="line">            CommandParameter=&quot;Ch2|比例带&quot;/&gt;</span><br><span class="line">    &lt;Button Content=&quot;重置&quot;</span><br><span class="line">            Command=&quot;&#123;Binding Reset&#125;&quot;</span><br><span class="line">            CommandParameter=&quot;Ch2|比例带&quot;/&gt;</span><br><span class="line">    &lt;hc:ButtonGroup.IsEnabled&gt;</span><br><span class="line">        &lt;MultiBinding Converter=&quot;&#123;StaticResource IsValueChangedDifferenceMultiConverter&#125;&quot;&gt;</span><br><span class="line">            &lt;Binding Path=&quot;Ch[1].RatioBand&quot;/&gt;</span><br><span class="line">            &lt;Binding Path=&quot;TemperatureController.Ch[1].RatioBand&quot;/&gt;</span><br><span class="line">        &lt;/MultiBinding&gt;</span><br><span class="line">    &lt;/hc:ButtonGroup.IsEnabled&gt;</span><br><span class="line">&lt;/hc:ButtonGroup&gt;</span><br></pre></td></tr></table></figure>

<h4 id="gif显示控件"><a href="#gif显示控件" class="headerlink" title="gif显示控件"></a>gif显示控件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;hc:GifImage x:Name=&quot;GifImageMain&quot;</span><br><span class="line">                                             Stretch=&quot;Fill&quot;</span><br><span class="line">                                             Uri=&quot;/UI.Application.Maintain;Component/images/fire.gif&quot;</span><br><span class="line">                                             Width=&quot;20&quot;</span><br><span class="line">                                             Height=&quot;30&quot;</span><br><span class="line">                                             Margin=&quot;0,-10,0,0&quot;</span><br><span class="line">                                             HorizontalAlignment=&quot;Left&quot;</span><br><span class="line">                                             Visibility=&quot;&#123;Binding TemperatureController.Ch[0].Output, Converter=&#123;StaticResource ValueGreaterThan0ToOpacityConverter&#125;&#125;&quot;&gt;</span><br><span class="line">&lt;/hc:GifImage&gt; </span><br></pre></td></tr></table></figure>

<h4 id="时间获取"><a href="#时间获取" class="headerlink" title="时间获取"></a>时间获取</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;hc:TimePicker</span><br><span class="line">    Width=&quot;160&quot;</span><br><span class="line">    Margin=&quot;5,0,0,0&quot;</span><br><span class="line">    VerticalAlignment=&quot;Center&quot;</span><br><span class="line">    hc:InfoElement.ShowClearButton=&quot;True&quot;</span><br><span class="line">    SelectedTime=&quot;&#123;Binding SelectStartTime, UpdateSourceTrigger=PropertyChanged&#125;&quot;</span><br><span class="line">    Style=&quot;&#123;StaticResource TimePickerExtend&#125;&quot;&gt;</span><br><span class="line">  &lt;!--用于指定如何显示时间选择器的时钟--&gt;</span><br><span class="line">    &lt;hc:TimePicker.Clock&gt;</span><br><span class="line">      &lt;!--以列表的形式显示可选择的时间--&gt;</span><br><span class="line">        &lt;hc:ListClock /&gt;</span><br><span class="line">    &lt;/hc:TimePicker.Clock&gt;</span><br><span class="line">&lt;/hc:TimePicker&gt;</span><br></pre></td></tr></table></figure>

<h4 id="对话框-1"><a href="#对话框-1" class="headerlink" title="对话框"></a>对话框</h4><p>使用现成的</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HandyControl.Controls.MessageBox.Info(<span class="string">&quot;发送内容为空&quot;</span>, <span class="string">&quot;提示&quot;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="自定义对话框"><a href="#自定义对话框" class="headerlink" title="自定义对话框"></a>自定义对话框</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dialog.Show(<span class="keyword">new</span> TextDialog(), <span class="string">&quot;发送内容为空&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>TextDialog定义如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- TextDialog.xaml --&gt;</span><br><span class="line">&lt;UserControl x:Class=&quot;YourNamespace.TextDialog&quot;</span><br><span class="line">             xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span><br><span class="line">             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;&gt;</span><br><span class="line">    &lt;Grid&gt;</span><br><span class="line">        &lt;TextBlock Text=&quot;发送内容为空&quot; /&gt;</span><br><span class="line">    &lt;/Grid&gt;</span><br><span class="line">&lt;/UserControl&gt;</span><br></pre></td></tr></table></figure>

<h3 id="阿里矢量图标库中获取图标"><a href="#阿里矢量图标库中获取图标" class="headerlink" title="阿里矢量图标库中获取图标"></a>阿里矢量图标库中获取图标</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wuhuacong/p/17987022">参考链接</a></p>
<p><code>hc:IconElement.Geometry=&quot;&#123;StaticResource t_import&#125;&quot;</code></p>
<p>这里的 <code>t_import</code>就是自定义导入的Geometry几何图形</p>
<p>在APP中进行导入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;ResourceDictionary&gt;</span><br><span class="line">            &lt;ResourceDictionary.MergedDictionaries&gt;</span><br><span class="line">                &lt;ui:ThemesDictionary Theme=&quot;Dark&quot; /&gt;</span><br><span class="line">                &lt;ui:ControlsDictionary /&gt;</span><br><span class="line">                &lt;!--  Geometries  --&gt;</span><br><span class="line">                &lt;ResourceDictionary Source=&quot;/Styles/Geometries/Custom.xaml&quot; /&gt;</span><br><span class="line"></span><br><span class="line">                &lt;!--  HandyControl  --&gt;</span><br><span class="line">                &lt;ResourceDictionary Source=&quot;pack://application:,,,/HandyControl;component/Themes/SkinDefault.xaml&quot; /&gt;</span><br><span class="line">                &lt;ResourceDictionary Source=&quot;pack://application:,,,/HandyControl;component/Themes/Theme.xaml&quot; /&gt;</span><br><span class="line">            &lt;/ResourceDictionary.MergedDictionaries&gt;</span><br><span class="line">        &lt;/ResourceDictionary&gt;</span><br></pre></td></tr></table></figure>

<p>如果获得t_import的内容呢?打开F12开发者工具去找path</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img2024.cnblogs.com/blog/8867/202401/8867-20240125143701899-1127049765.png" alt="img" style="zoom:25%;" />

<p>F12中获取相关图标的代码,然后把这段Path的值复制到我们的 Custom.xaml 文件中，如下所示。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202409271349619.png" alt="img" style="zoom: 33%;" />

<p>上面的图表Path只有一个，有时候 阿里矢量图标库使用Geometry图标有多个Path的组合，我们如果也要采用，那么定义稍微调整一下。</p>
<p>通过GeometryGroup来定义父级，然后添加多个PathGeometry集合即可</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202409271349467.png" alt="img" style="zoom:33%;" />

<h3 id="使用按钮展示几何图形"><a href="#使用按钮展示几何图形" class="headerlink" title="使用按钮展示几何图形"></a>使用按钮展示几何图形</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button</span><br><span class="line">    hc:IconElement.Geometry=&quot;&#123;StaticResource SuccessGeometry&#125;&quot;</span><br><span class="line">    BorderBrush=&quot;Transparent&quot;</span><br><span class="line">    BorderThickness=&quot;0&quot;</span><br><span class="line">    Foreground=&quot;Green&quot;</span><br><span class="line">    IsHitTestVisible=&quot;False&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>但这样只适合展示静态几何图形</p>
<h4 id="使用按钮动态切换几何图形"><a href="#使用按钮动态切换几何图形" class="headerlink" title="使用按钮动态切换几何图形"></a>使用按钮动态切换几何图形</h4><p>使用 <code>ContentControl</code> 和 <code>DataTemplate</code> 的方法可以更灵活地切换内容。<code>Button</code> 的 <code>Style</code> 和 <code>DataTrigger</code> 有时可能无法直接影响复杂的子元素属性（如几何图形），而 <code>ContentControl</code> 可以通过模板轻松切换整个内容</p>
<ul>
<li>模板切换：ContentControl 可以根据数据绑定的值动态切换 DataTemplate，这使得在不同状态下显示不同的内容变得非常简单。</li>
<li>复杂内容：可以在 DataTemplate 中定义复杂的 UI 结构，而不仅限于简单的属性设置。</li>
</ul>
<p>并且使用 <code>Viewbox</code> 可以更好地控制整体大小，并保持内容的比例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button</span><br><span class="line">    Background=&quot;Transparent&quot;</span><br><span class="line">    BorderBrush=&quot;Transparent&quot;</span><br><span class="line">    BorderThickness=&quot;0&quot;</span><br><span class="line">    IsHitTestVisible=&quot;False&quot;&gt;</span><br><span class="line">    &lt;ContentControl&gt;</span><br><span class="line">        &lt;ContentControl.Style&gt;</span><br><span class="line">            &lt;Style TargetType=&quot;ContentControl&quot;&gt;</span><br><span class="line">                &lt;Setter Property=&quot;ContentTemplate&quot;&gt;</span><br><span class="line">                    &lt;Setter.Value&gt;</span><br><span class="line">                        &lt;DataTemplate&gt;</span><br><span class="line">                            &lt;Viewbox Width=&quot;18&quot;</span><br><span class="line">                                    Height=&quot;18&quot;&gt;</span><br><span class="line">                                &lt;Path Data=&quot;&#123;DynamicResource ErrorGeometry&#125;&quot;</span><br><span class="line">                                        Fill=&quot;Red&quot;&gt;</span><br><span class="line">                                &lt;/Path&gt;</span><br><span class="line">                            &lt;/Viewbox&gt;</span><br><span class="line">                        &lt;/DataTemplate&gt;</span><br><span class="line">                    &lt;/Setter.Value&gt;</span><br><span class="line">                &lt;/Setter&gt;</span><br><span class="line">                &lt;Style.Triggers&gt;</span><br><span class="line">                    &lt;DataTrigger Binding=&quot;&#123;Binding PRIOk&#125;&quot;</span><br><span class="line">                            Value=&quot;True&quot;&gt;</span><br><span class="line">                        &lt;Setter Property=&quot;ContentTemplate&quot;&gt;</span><br><span class="line">                            &lt;Setter.Value&gt;</span><br><span class="line">                                &lt;DataTemplate&gt;</span><br><span class="line">                                    &lt;Viewbox Width=&quot;18&quot;</span><br><span class="line">                                            Height=&quot;18&quot;&gt;</span><br><span class="line">                                        &lt;Path Data=&quot;&#123;DynamicResource SuccessGeometry&#125;&quot;</span><br><span class="line">                                                Fill=&quot;Green&quot;&gt;</span><br><span class="line">                                        &lt;/Path&gt;</span><br><span class="line">                                    &lt;/Viewbox&gt;</span><br><span class="line">                                &lt;/DataTemplate&gt;</span><br><span class="line">                            &lt;/Setter.Value&gt;</span><br><span class="line">                        &lt;/Setter&gt;</span><br><span class="line">                    &lt;/DataTrigger&gt;</span><br><span class="line">                    &lt;DataTrigger Binding=&quot;&#123;Binding SECOk&#125;&quot;</span><br><span class="line">                            Value=&quot;True&quot;&gt;</span><br><span class="line">                        &lt;Setter Property=&quot;ContentTemplate&quot;&gt;</span><br><span class="line">                            &lt;Setter.Value&gt;</span><br><span class="line">                                &lt;DataTemplate&gt;</span><br><span class="line">                                    &lt;Viewbox Width=&quot;18&quot;</span><br><span class="line">                                            Height=&quot;18&quot;&gt;</span><br><span class="line">                                        &lt;Path Data=&quot;&#123;DynamicResource SuccessGeometry&#125;&quot;</span><br><span class="line">                                                Fill=&quot;Green&quot;&gt;</span><br><span class="line">                                        &lt;/Path&gt;</span><br><span class="line">                                    &lt;/Viewbox&gt;</span><br><span class="line">                                &lt;/DataTemplate&gt;</span><br><span class="line">                            &lt;/Setter.Value&gt;</span><br><span class="line">                        &lt;/Setter&gt;</span><br><span class="line">                    &lt;/DataTrigger&gt;</span><br><span class="line">                &lt;/Style.Triggers&gt;</span><br><span class="line">            &lt;/Style&gt;</span><br><span class="line">        &lt;/ContentControl.Style&gt;</span><br><span class="line">    &lt;/ContentControl&gt;</span><br><span class="line">&lt;/Button&gt;</span><br></pre></td></tr></table></figure>

<h3 id="切换主题色"><a href="#切换主题色" class="headerlink" title="切换主题色"></a>切换主题色</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExecuteToggleTheme</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (IsLight)</span><br><span class="line">    &#123;</span><br><span class="line">        ResourceDictionary darkTheme = <span class="keyword">new</span> ResourceDictionary</span><br><span class="line">        &#123;</span><br><span class="line">            Source = <span class="keyword">new</span> Uri(<span class="string">&quot;pack://application:,,,/HandyControl;component/Themes/SkinDark.xaml&quot;</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        ResourceDictionary theme = <span class="keyword">new</span> ResourceDictionary</span><br><span class="line">        &#123;</span><br><span class="line">            Source = <span class="keyword">new</span> Uri(<span class="string">&quot;pack://application:,,,/HandyControl;component/Themes/Theme.xaml&quot;</span>)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Application.Current.Resources.MergedDictionaries.Clear();</span><br><span class="line">        Application.Current.Resources.MergedDictionaries.Add(darkTheme);</span><br><span class="line">        Application.Current.Resources.MergedDictionaries.Add(theme);</span><br><span class="line">        IsLight = !IsLight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ResourceDictionary lightTheme = <span class="keyword">new</span> ResourceDictionary</span><br><span class="line">        &#123;</span><br><span class="line">            Source = <span class="keyword">new</span> Uri(<span class="string">&quot;pack://application:,,,/HandyControl;component/Themes/SkinDefault.xaml&quot;</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        ResourceDictionary theme = <span class="keyword">new</span> ResourceDictionary</span><br><span class="line">        &#123;</span><br><span class="line">            Source = <span class="keyword">new</span> Uri(<span class="string">&quot;pack://application:,,,/HandyControl;component/Themes/Theme.xaml&quot;</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        Application.Current.Resources.MergedDictionaries.Clear();</span><br><span class="line">        Application.Current.Resources.MergedDictionaries.Add(lightTheme);</span><br><span class="line">        Application.Current.Resources.MergedDictionaries.Add(theme);</span><br><span class="line">        IsLight = !IsLight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Growl"><a href="#Growl" class="headerlink" title="Growl"></a>Growl</h4><p>Growl用法如下,<a target="_blank" rel="noopener" href="https://handyorg.github.io/handycontrol/extend_controls/growl/">详情参考此处</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">xmlns:hc=&quot;https://handyorg.github.io/handycontrol&quot;</span><br><span class="line">&lt;!--Grid.ZIndex=&quot;1000&quot;表示设置为置顶--&gt; </span><br><span class="line">&lt;StackPanel Grid.ZIndex=&quot;1000&quot;</span><br><span class="line">             Margin=&quot;0,10,10,10&quot;</span><br><span class="line">             VerticalAlignment=&quot;Top&quot;</span><br><span class="line">             HorizontalAlignment=&quot;Right&quot;</span><br><span class="line">             hc:Growl.GrowlParent=&quot;True&quot;</span><br><span class="line">             hc:Growl.Token=&quot;MainWindow&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>然后就可以使用这种语句来控制出现显示信息:<code>HandyControl.Controls.Growl.Error(&quot;超时无响应&quot;, &quot;MainWindow&quot;);</code>.此处的<code>MainWindow</code>对应上面的<code> hc:Growl.Token</code></p>
<h3 id="覆盖默认样式"><a href="#覆盖默认样式" class="headerlink" title="覆盖默认样式"></a>覆盖默认样式</h3><p>可以使用这种语法：<code>BasedOn=&quot;&#123;StaticResource &#123;x:Type Button&#125;&#125;&quot;</code>来覆盖Button的默认样式</p>
<h2 id="wpfui"><a href="#wpfui" class="headerlink" title="wpfui"></a>wpfui</h2><p><a target="_blank" rel="noopener" href="https://github.com/lepoco/wpfui">MIT开源控件库</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlns:ui=&quot;http://schemas.lepo.co/wpfui/2022/xaml&quot;</span><br></pre></td></tr></table></figure>

<h2 id="图表控件库"><a href="#图表控件库" class="headerlink" title="图表控件库"></a>图表控件库</h2><ul>
<li><a href="#livechart2">LiveCharts</a></li>
<li><a href="#ScottPlot">ScottPlot</a></li>
<li><a href="#MSChart">MSChart</a></li>
<li><a href="#OxyPlot">OxyPlot</a></li>
</ul>
<table>
<thead>
<tr>
<th align="left">库名称</th>
<th align="left">安装</th>
<th align="left">好看</th>
<th align="left">速度</th>
<th align="left">手册等</th>
<th align="left">专有技术文章</th>
</tr>
</thead>
<tbody><tr>
<td align="left">OxyPlot</td>
<td align="left">必要</td>
<td align="left">△</td>
<td align="left">○</td>
<td align="left">○</td>
<td align="left">△</td>
</tr>
<tr>
<td align="left">LiveCharts</td>
<td align="left">必要</td>
<td align="left">◎</td>
<td align="left">×</td>
<td align="left">○</td>
<td align="left">△</td>
</tr>
<tr>
<td align="left">ScottPlot</td>
<td align="left">必要</td>
<td align="left">○</td>
<td align="left">◎</td>
<td align="left">◎</td>
<td align="left">×</td>
</tr>
<tr>
<td align="left">Microsoft Chart</td>
<td align="left">不要</td>
<td align="left">△</td>
<td align="left">◎</td>
<td align="left">×</td>
<td align="left">◎</td>
</tr>
</tbody></table>
<ul>
<li>如果以<strong>绘制大量数据的速度为准</strong>，则Microsoft Chart、ScottPlot最好。</li>
<li>如果为了绘图方便，则ScattPlot是最佳选择。</li>
<li>如果你想专注于设计或制作动画，LiveCharts是个不错的选择。</li>
<li>如果你想实现一个类似EXCEL的3D图表的东西，那就只能用Microsoft Chart。</li>
<li>OxyPlot是ScottPlot和LiveCharts的中间存在</li>
</ul>
<h3 id="ScottPlot"><a href="#ScottPlot" class="headerlink" title="ScottPlot"></a>ScottPlot</h3><p>绘图库  性能强悍：千万级数据处理无压力, 媲美 Python Matplotlib。</p>
<p>MIT开源  <a target="_blank" rel="noopener" href="https://github.com/ScottPlot/ScottPlot">开源地址</a></p>
<p><a target="_blank" rel="noopener" href="https://scottplot.net/demo/5.0/#download">demo程序下载</a></p>
<p>绘制速度与Visual Stuido下的标准Chart一样。</p>
<p>与OxyPlot、 LiveCharts 相比较，ScottPlot更快。</p>
<p>与Visual Stuido标准Chart相比，图表类型更加丰富，且视觉表现上更加漂亮。</p>
<p>Nuget下搜索 “scottplot”、”ScottPlot.Wpf” 选择安装</p>
<ul>
<li>【缺点1】：不支持MVVM模式</li>
<li>【缺点2】：在图表上标注每个点的数据，没有其他图表库方便。</li>
<li>【缺点3】：要绘实时折线图表没有其他图表库方便。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://scottplot.net/cookbook/">ScottPlot Cookbook 官方文档</a></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202410170945109.jpeg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">xmlns:ScottPlot=&quot;clr-namespace:ScottPlot;assembly=ScottPlot.WPF&quot;  </span><br><span class="line"> &lt;!--绘图 ScottPlot--&gt;</span><br><span class="line">   &lt;ScottPlot:WpfPlot x:Name=&quot;WpfPlot1&quot; Panel.ZIndex=&quot;-1&quot; ScrollViewer.CanContentScroll=&quot;True&quot; VirtualizingPanel.ScrollUnit=&quot;Item&quot; VirtualizingPanel.IsVirtualizing=&quot;True&quot; VirtualizingPanel.VirtualizationMode=&quot;Recycling&quot; Width=&quot;1670&quot; Margin=&quot;-20,0,0,0&quot; Background=&quot;Black&quot;&gt;</span><br><span class="line">       &lt;ScottPlot:WpfPlot.Style&gt;</span><br><span class="line">           &lt;Style TargetType=&quot;ScottPlot:WpfPlot&quot;&gt;</span><br><span class="line">               &lt;Setter Property=&quot;Visibility&quot; Value=&quot;Hidden&quot;/&gt;</span><br><span class="line">               &lt;Style.Triggers&gt;</span><br><span class="line">                   &lt;DataTrigger Binding=&quot;&#123;Binding ElementName=ViewChartMI,Path=IsChecked&#125;&quot; Value=&quot;True&quot;&gt;</span><br><span class="line">                       &lt;Setter Property=&quot;Visibility&quot; Value=&quot;Visible&quot;/&gt;</span><br><span class="line">                   &lt;/DataTrigger&gt;</span><br><span class="line">               &lt;/Style.Triggers&gt;</span><br><span class="line">           &lt;/Style&gt;</span><br><span class="line">       &lt;/ScottPlot:WpfPlot.Style&gt;</span><br><span class="line">   &lt;/ScottPlot:WpfPlot&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>**<code>ScottPlot:WpfPlot</code>**：这是一个来自 ScottPlot 库的控件，用于在 WPF 应用程序中绘制图表。</li>
<li>**<code>x:Name=&quot;WpfPlot1&quot;</code>**：为该控件指定一个名称（<code>WpfPlot1</code>），可以在代码后面中引用这个控件。</li>
<li>**<code>Panel.ZIndex=&quot;-1&quot;</code>**：设置该控件的 Z 轴索引为 -1，意味着它会被放置在其他控件的下方（如果存在其他控件）。</li>
<li>**<code>ScrollViewer.CanContentScroll=&quot;True&quot;</code>**：启用内容滚动，这样当内容超出可视区域时可以滚动。</li>
<li>**<code>VirtualizingPanel.ScrollUnit=&quot;Item&quot;</code>**：设置滚动单位为项目，这意味着滚动将以单个项目为单位进行。</li>
<li>**<code>VirtualizingPanel.IsVirtualizing=&quot;True&quot;</code>**：启用虚拟化，这意味着只会创建可视区域内的元素，提高性能。</li>
<li>**<code>VirtualizingPanel.VirtualizationMode=&quot;Recycling&quot;</code>**：设置虚拟化模式为回收模式，这样可以重用已经不再可见的元素，进一步提高性能。</li>
<li>**<code>Width=&quot;1670&quot;</code>**：设置控件的宽度为 1670 像素。</li>
<li>**<code>Margin=&quot;-20,0,0,0&quot;</code>**：设置控件的外边距，左边距为 -20 像素（可能会使控件向左移动），上下和右边距为 0。</li>
<li>**<code>Background=&quot;Black&quot;</code>**：设置控件的背景颜色为黑色。</li>
</ul>
<blockquote>
<p>这款控件强大的根本原因可以参考<a target="_blank" rel="noopener" href="https://scottplot.net/faq/mvvm/">官方网址</a>,其如此写到:</p>
<p><strong>许多图表库使用 MVVM 和数据绑定模式与图表进行交互。ScottPlot 则不使用。</strong>这一有意为之的决定让 ScottPlot 的性能更佳，因为它让用户能够直接访问用于绘图的数组值，并且还让用户能够完全控制何时渲染新帧（这可能是一项成本高昂的操作）。虽然 MVVM 模式和数据绑定在设计交互式 GUI 应用程序时通常很有用，但请考虑几乎所有 ScottPlot 功能都可用于从无头控制台应用程序创建静态图像，而这些模式在这些应用程序中的使用并不广泛。</p>
<p><strong>MVVM 和数据绑定模式可用于创建包装 ScottPlot 图的图形控件。</strong>强烈希望使用数据绑定或 MVVM 模式的用户可能正在使用特定于平台的 GUI 开发框架（例如 WPF），并且只想创建一个控件来完成一项任务（例如具有特定样式和布局的交互式散点图）。鼓励这些用户编写自己的用户控件来实现此自定义数据处理和渲染功能。ScottPlot 控件的设计非常简单，鼓励想要将数据管理与图形交互性结合起来的用户使用他们选择的模式编写自己的控件。</p>
</blockquote>
<h3 id="ScottPlot常用代码盘点"><a href="#ScottPlot常用代码盘点" class="headerlink" title="ScottPlot常用代码盘点"></a>ScottPlot常用代码盘点</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">double</span>[] dataX = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="built_in">double</span>[] dataY = &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span> &#125;;</span><br><span class="line">myPlot.Add.Scatter(dataX, dataY);</span><br></pre></td></tr></table></figure>

<h3 id="MSChart"><a href="#MSChart" class="headerlink" title="MSChart"></a>MSChart</h3><p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/ja-jp/dotnet/api/system.windows.forms.datavisualization.charting.chart?view=netframework-4.8">官方详解</a></p>
<p>Visual Studio 标准Windows Form 平台下使用的图标控件，WPF平台通WindowsFormsHost 组件嵌入使用</p>
<p>Microsoft官方网站有说明，但是并不容易看懂。</p>
<p>与其他图表库比较，这个更加难以理解。</p>
<p>但是，由于WindowsForm平台的信息比较丰富，这就补足了它的不全。</p>
<p>可以创建３D类型的图表，这是其他图表库中没有的功能。并且可以绘制的图标种类繁多。</p>
<p>虽然需要编写一些代码，单支持鼠标放大和缩小，以及像ScottPlot一样的快速绘制图表，设计时比其他图表库更令人着迷。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202410170946762.jpeg" alt="img"></p>
<h3 id="OxyPlot"><a href="#OxyPlot" class="headerlink" title="OxyPlot"></a>OxyPlot</h3><p>渲染10万个点量级不卡</p>
<p>官方网站上的信息有点难以理解，许多地方的描述和图表示例不一致。</p>
<p><a target="_blank" rel="noopener" href="https://oxyplot.readthedocs.io/en/latest/index.html#">官方文档</a></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202410170948183.jpeg" alt="img"></p>
<h3 id="livechart2"><a href="#livechart2" class="headerlink" title="livechart2"></a>livechart2</h3><p><a target="_blank" rel="noopener" href="https://github.com/beto-rodriguez/LiveCharts2">livechart2</a></p>
<p>默认情况下 LiveCharts 使用 SkiaSharp 来渲染控件，这意味着您可以使用所有 SkiaSharp API 在画布上绘图，您可以<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/xamarin/xamarin-forms/user-interface/graphics/skiasharp/basics/">在此处</a>找到有关 SkiaSharp 的更多信息。</p>
<p>十字线参考:<a target="_blank" rel="noopener" href="https://livecharts.dev/docs/Maui/2.0.0-rc2/samples.axes.crosshairs">https://livecharts.dev/docs/Maui/2.0.0-rc2/samples.axes.crosshairs</a></p>
<p>多线程参考:<a target="_blank" rel="noopener" href="https://livecharts.dev/docs/Maui/2.0.0-rc2/samples.general.multiThreading">https://livecharts.dev/docs/Maui/2.0.0-rc2/samples.general.multiThreading</a></p>
<p>使用livechart2的多线程用法,不要使用子线程执行(效率大幅降低),应该在ui线程中执行</p>
<p>需要安装</p>
<ul>
<li><code>LiveChartsCore.SkiaSharpView</code></li>
<li><code>LiveChartsCore.SkiaSharpView.WPF</code></li>
<li></li>
</ul>
<h4 id="此处记录一个重置缩放的做法"><a href="#此处记录一个重置缩放的做法" class="headerlink" title="此处记录一个重置缩放的做法"></a>此处记录一个重置缩放的做法</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExecuteResetZoom</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 重置X轴</span></span><br><span class="line">    XAxes2[<span class="number">0</span>].MinLimit = <span class="literal">null</span>;</span><br><span class="line">    XAxes2[<span class="number">0</span>].MaxLimit = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置Y轴</span></span><br><span class="line">    YAxes2[<span class="number">0</span>].MinLimit = <span class="literal">null</span>;</span><br><span class="line">    YAxes2[<span class="number">0</span>].MaxLimit = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知图表更新</span></span><br><span class="line">    <span class="comment">//RaisePropertyChanged(nameof(XAxes));</span></span><br><span class="line">    <span class="comment">//RaisePropertyChanged(nameof(YAxes));</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="WPF-Suite"><a href="#WPF-Suite" class="headerlink" title="WPF Suite"></a>WPF Suite</h2><p><a target="_blank" rel="noopener" href="https://github.com/OrgEleCho/EleCho.WpfSuite">WPF Suite 仓库地址</a></p>
<h3 id="引入库方式"><a href="#引入库方式" class="headerlink" title="引入库方式"></a>引入库方式</h3><p>nuget管理器中搜索WPF Suite,找到EleCho.WpfSuite下载</p>
<p>在xaml中引入库的命名空间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlns:ws=&quot;https://schemas.elecho.dev/wpfsuite&quot;</span><br></pre></td></tr></table></figure>

<h3 id="优化界面布局"><a href="#优化界面布局" class="headerlink" title="优化界面布局"></a>优化界面布局</h3><p>WPF原本需要间隔开空间是用Margin控制的,但添加Margin(外边距)之后,其本身与外边距是一个整体</p>
<p>解决这个问题可以使用 <code>ws:WrapPanel</code>内置属性:<code>HorizontalSpacing</code>和 <code>VerticalSpacing</code>可以设置水平和垂直间隔</p>
<h3 id="内容过渡效果封装"><a href="#内容过渡效果封装" class="headerlink" title="内容过渡效果封装"></a>内容过渡效果封装</h3><p>以下面的平滑动画过渡为例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;ws:TransitioningContentContorl Name=&quot;transitioningContentControl&quot;</span><br><span class="line">                                Maring=&quot;0 8 0 0&quot;&gt;</span><br><span class="line">  &lt;ws:TransitioningContentControl.Transition&gt;</span><br><span class="line">    &lt;ws:SlideTransition/&gt;</span><br><span class="line">  &lt;/ws:TransitioningContentControl.Transition&gt;</span><br><span class="line">&lt;/ws:TransitioningContentContorl&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transitioningContentControl.Content = ...</span><br></pre></td></tr></table></figure>

<h2 id="XamlAnimatedGif"><a href="#XamlAnimatedGif" class="headerlink" title="XamlAnimatedGif"></a>XamlAnimatedGif</h2><p>支持gif显示与控制</p>
<blockquote>
<p>Handycontrol中的GifImage控件可以显示gif内容,但是切换tab的话会卡在某一帧停止播放</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/XamlAnimatedGif/XamlAnimatedGif">项目地址</a></p>
<p>只支持.net5.0,注意不支持.net6.0</p>
<p>.net6.0显示gif,采用如下方法解决</p>
<h3 id="gif显示的手动方法"><a href="#gif显示的手动方法" class="headerlink" title="gif显示的手动方法"></a>gif显示的手动方法</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 显示GIF动图</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;imageControl&quot;&gt;</span>要显示GIF的Image控件<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;filePath&quot;&gt;</span>GIF文件的路径<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ShowGifByAnimate</span>(<span class="params">Image imageControl, <span class="built_in">string</span> filePath</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">              <span class="keyword">if</span> (imageControl == <span class="literal">null</span> || filePath==<span class="string">&quot;&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">// 创建一个列表来存储GIF的每一帧</span></span><br><span class="line">            List&lt;BitmapFrame&gt; frameList = <span class="keyword">new</span> List&lt;BitmapFrame&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用GifBitmapDecoder解码GIF文件</span></span><br><span class="line">            GifBitmapDecoder decoder = <span class="keyword">new</span> GifBitmapDecoder(</span><br><span class="line">                <span class="keyword">new</span> Uri(filePath, UriKind.RelativeOrAbsolute),</span><br><span class="line">                BitmapCreateOptions.PreservePixelFormat, BitmapCacheOption.Default);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查解码器和帧是否有效</span></span><br><span class="line">            <span class="keyword">if</span> (decoder != <span class="literal">null</span> &amp;&amp; decoder.Frames != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 将所有帧添加到列表中</span></span><br><span class="line">                frameList.AddRange(decoder.Frames);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 创建一个对象动画，用于逐帧显示GIF</span></span><br><span class="line">                ObjectAnimationUsingKeyFrames objKeyAnimate = <span class="keyword">new</span> ObjectAnimationUsingKeyFrames</span><br><span class="line">                &#123;</span><br><span class="line">                    Duration = <span class="keyword">new</span> Duration(TimeSpan.FromSeconds(<span class="number">1</span>)) <span class="comment">// 设置动画持续时间</span></span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 为每一帧创建一个关键帧，并添加到动画中</span></span><br><span class="line">                <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> frameList)</span><br><span class="line">                &#123;</span><br><span class="line">                    DiscreteObjectKeyFrame keyFrame = <span class="keyword">new</span> DiscreteObjectKeyFrame(item);</span><br><span class="line">                    objKeyAnimate.KeyFrames.Add(keyFrame);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 设置Image控件的初始显示帧</span></span><br><span class="line">                imageControl.Source = frameList[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 创建一个Storyboard来控制动画</span></span><br><span class="line">                board = <span class="keyword">new</span> Storyboard</span><br><span class="line">                &#123;</span><br><span class="line">                    RepeatBehavior = RepeatBehavior.Forever, <span class="comment">// 设置动画循环播放</span></span><br><span class="line">                    FillBehavior = FillBehavior.HoldEnd <span class="comment">// 设置动画结束后保持最后一帧</span></span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将对象动画添加到Storyboard中</span></span><br><span class="line">                board.Children.Add(objKeyAnimate);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 设置动画的目标控件和属性</span></span><br><span class="line">                Storyboard.SetTarget(objKeyAnimate, imageControl);</span><br><span class="line">                Storyboard.SetTargetProperty(objKeyAnimate, <span class="keyword">new</span> PropertyPath(<span class="string">&quot;(Image.Source)&quot;</span>));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 开始播放动画</span></span><br><span class="line">                board.Begin();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将Storyboard存储在Image控件的Tag属性中，以便后续释放</span></span><br><span class="line">                imageControl.Tag = board;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 停止并清理GIF动画</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">StopGifAnimation</span>(<span class="params">Image imageControl</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (imageControl?.Tag <span class="keyword">is</span> Storyboard board)</span><br><span class="line">            &#123;</span><br><span class="line">                board.Stop();</span><br><span class="line">                imageControl.Tag = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用如下:</span></span><br><span class="line"><span class="comment">//开始</span></span><br><span class="line"><span class="keyword">var</span> imageControl = FindChild&lt;Image&gt;(System.Windows.Application.Current.MainWindow, <span class="string">&quot;GifImageMain&quot;</span>);</span><br><span class="line">ShowGifByAnimate(imageControl, <span class="string">@&quot;pack://application:,,,/UI.Application.Maintain;Component/images/fire.gif&quot;</span>);</span><br><span class="line"><span class="comment">//停止</span></span><br><span class="line">StopGifAnimation(imageControl);</span><br></pre></td></tr></table></figure>

<h2 id="CommunityToolkit-Mvvm"><a href="#CommunityToolkit-Mvvm" class="headerlink" title="CommunityToolkit.Mvvm"></a>CommunityToolkit.Mvvm</h2><p>这是一个MVVM框架</p>
<p>包含很多功能,其中有一个<a target="_blank" rel="noopener" href="https://mvvm.coldwind.top/ComponentModel/ObservableValidator/">数据验证的功能,可以参考此处</a></p>
<h2 id="ValueConverters"><a href="#ValueConverters" class="headerlink" title="ValueConverters"></a>ValueConverters</h2><p>好用的值转换器</p>
<p>MIT开源  <a target="_blank" rel="noopener" href="https://github.com/thomasgalliker/ValueConverters.NET">开源地址</a></p>
<p>提供了很多现成的转换器,<a href="#%E4%B8%B2%E8%81%94%E8%BD%AC%E6%8D%A2%E5%99%A8%E7%BB%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F">允许串联转换器</a></p>
<p>盘点一些转换器</p>
<ul>
<li>ValueConverterGroup  转换器组</li>
<li>BoolToVisibilityConverter  bool到可见性</li>
<li>StringIsNotNullOrEmptyConverter  字符串非空或null</li>
<li>IsInRangeConverter  对于字符串表示长度是否在范围内,对于数值表示值是否在范围内: MinValue,MaxValue设置范围</li>
<li>BoolInvert bool  值反转</li>
<li>StringToDecimalConverter   字符串转换为小数</li>
<li>DebugConverter  做的事情只是把当前转换器的信息输出到Debug.WriteLine中,不会改变任何值,用于调试转换器组</li>
</ul>
<h3 id="基本使用方式"><a href="#基本使用方式" class="headerlink" title="基本使用方式"></a>基本使用方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">xmlns:conv=&quot;clr-namespace:ValueConverters;assembly=ValueConverters&quot;</span><br><span class="line">&lt;!--没有url方式引入,直接使用引用程序集方式引入--&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--引入需要用到的转换器,并定制--&gt;</span><br><span class="line">&lt;Window.Resources&gt;</span><br><span class="line">  &lt;conv:BoolToVisibilityConverter x:Key=&quot;AgreementToVisibilityConverter&quot; IsInverted=&quot;True&quot; FalseValue=&quot;Hidden&quot;/&gt;</span><br><span class="line">&lt;/Window.Resources&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--使用上面定制的转换器,绑定为agree名的控件的IsChecked属性,使用上面的转换器--&gt;</span><br><span class="line">&lt;label Visibility=&quot;&#123;Binding ElementName=agree,Path=IsChecked,Converter=&#123;StaticResource AgreementToVisibilityConverter&#125;&#125;&quot;/&gt;</span><br><span class="line">&lt;!--如果不定制,只需要默认的,就不需要引入--&gt;</span><br><span class="line">&lt;label Visibility=&quot;&#123;Binding ElementName=agree,Path=IsChecked,Converter=&#123;x:Static conv:BoolToVisibilityConverter.Instance&#125;&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h3 id="串联转换器组使用方式"><a href="#串联转换器组使用方式" class="headerlink" title="串联转换器组使用方式"></a>串联转换器组使用方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--引入需要用到的转换器,并定制--&gt;</span><br><span class="line">&lt;Window.Resources&gt;</span><br><span class="line">  &lt;!--用于组合多个转换器--&gt;</span><br><span class="line">  &lt;conv:ValueConverterGroup x:Key=&quot;UserNameToVisibilityConverter&quot;&gt;</span><br><span class="line">    &lt;!--string是否为空或null返回反转bool值--&gt;</span><br><span class="line">    &lt;conv:StringIsNotNullOrEmptyConverter isInverted=&quot;True&quot;/&gt;</span><br><span class="line">    &lt;!--bool值到可见性转换--&gt;</span><br><span class="line">    &lt;conv:BoolToVisibilityConverter/&gt;</span><br><span class="line">  &lt;/conv:ValueConverterGroup&gt;</span><br><span class="line">&lt;/Window.Resources&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--使用上面定制的转换器--&gt;</span><br><span class="line">&lt;TextBlock Visibility=&quot;&#123;Binding ElementName=username,Path=Text,Converter=&#123;StaticResource UserNameToVisibilityConverter&#125;&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h3 id="串联转换器代码原理参考"><a href="#串联转换器代码原理参考" class="headerlink" title="串联转换器代码原理参考"></a>串联转换器代码原理参考</h3><p>核心就在于在 <code>List&lt;IValueConverter&gt;</code>中两两一组将转换器串联起来了</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ValueConverters</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Value converters which aggregates the results of a sequence of converters: Converter1 &gt;&gt; Converter2 &gt;&gt; Converter3</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> The output of converter N becomes the input of converter N+1.</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (NETFX || NETWPF || XAMARIN || MAUI)</span></span><br><span class="line">    [<span class="meta">ContentProperty(nameof(Converters))</span>]</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> (NETFX_CORE)</span></span><br><span class="line">    [<span class="meta">ContentProperty(Name = nameof(Converters))</span>]</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ValueConverterGroup</span> : <span class="title">SingletonConverterBase</span>&lt;<span class="title">ValueConverterGroup</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> List&lt;IValueConverter&gt; Converters &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="keyword">new</span> List&lt;IValueConverter&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="built_in">object</span> <span class="title">Convert</span>(<span class="params"><span class="built_in">object</span> <span class="keyword">value</span>, Type targetType, <span class="built_in">object</span> parameter, CultureInfo culture</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.Converters <span class="keyword">is</span> IEnumerable&lt;IValueConverter&gt; converters)</span><br><span class="line">            &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> NETFX_CORE</span></span><br><span class="line">                <span class="keyword">var</span> language = culture?.ToString();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">                <span class="keyword">var</span> language = culture;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                <span class="keyword">return</span> converters.Aggregate(<span class="keyword">value</span>, (current, converter) =&gt; converter.Convert(current, targetType, parameter, language));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> UnsetValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="built_in">object</span> <span class="title">ConvertBack</span>(<span class="params"><span class="built_in">object</span> <span class="keyword">value</span>, Type targetType, <span class="built_in">object</span> parameter, CultureInfo culture</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.Converters <span class="keyword">is</span> IEnumerable&lt;IValueConverter&gt; converters)</span><br><span class="line">            &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> NETFX_CORE</span></span><br><span class="line">                <span class="keyword">var</span> language = culture?.ToString();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">                <span class="keyword">var</span> language = culture;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                <span class="keyword">return</span> converters.Reverse&lt;IValueConverter&gt;().Aggregate(<span class="keyword">value</span>, (current, converter) =&gt; converter.Convert(current, targetType, parameter, language));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> UnsetValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CalcBinding"><a href="#CalcBinding" class="headerlink" title="CalcBinding"></a>CalcBinding</h2><p>该库.net core只支持到4.0版本</p>
<p>需要支持<a href="#Avalonia">Avalonia(c#跨平台Mac,Linux,Windows桌面应用程序框架)</a>可以改用<a target="_blank" rel="noopener" href="https://github.com/netwww1/CalcBindingAva">CalcBindingAva</a></p>
<p>CalcBinding 是一种高级绑定标记扩展，它允许您在 xaml 中编写计算绑定表达式，而无需自定义转换器。CalcBinding 可以自动执行 bool 到可见性的转换、不同的代数运算、反转表达式等等。CalcBinding 使绑定表达式更短、更方便用户使用。</p>
<p>这个库相当厉害,很有研究价值</p>
<p>Apache-2.0 license <a target="_blank" rel="noopener" href="https://github.com/Alex141/CalcBinding?tab=Apache-2.0-1-ov-file#readme">开源地址</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlns:c=&quot;clr-namespace:CalcBinding;assembly=CalcBinding&quot;</span><br></pre></td></tr></table></figure>

<p>使用方式如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextBlock Text=&quot;&#123;c:Binding 0.5*A+B&#125;&quot; /&gt;</span><br><span class="line">布尔值运算如下:</span><br><span class="line">&lt;TextBlock Text=&quot;&#123;c:Binding BoolA or BoolB&#125;&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>可以编写任何代数、逻辑和字符串表达式，其中包含源属性路径、字符串、数字、Math 类的所有成员以及以下运算符：<code>&quot;(&quot;, &quot;)&quot;, &quot;+&quot;, &quot;-&quot;, &quot;*&quot;, &quot;/&quot;, &quot;%&quot;, &quot;^&quot;, &quot;!&quot;, &quot;&amp;&amp;&quot;,&quot;||&quot;, &quot;&amp;&quot;, &quot;|&quot;, &quot;?&quot;, &quot;:&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;, &quot;&lt;=&quot;, &quot;&gt;=&quot;, &quot;==&quot;, &quot;!=&quot;&#125;;</code></p>
<p>因为在 xaml不支持在设置属性值时使用 <code>&amp;&amp;</code> <code>||</code> <code>&lt;=</code> 所以需要使用 <code>and</code> <code>or</code> <code>‘less=’</code> 替换</p>
<p>也可以使用Math中的方法,<code>Math.Sin()</code>,<code>Math.PI</code>这样的</p>
<p>以及形式为’bool_expression ? expression_1 : expression_2’的三元运算符</p>
<p>字符串用法案例: <code>  &lt;TextBox Text=&quot;&#123;c:Binding &#39;text+&amp;quot;haha&amp;quot;&#39;, UpdateSourceTrigger=PropertyChanged&#125;&quot; /&gt;</code>,其中 <code>&amp;quot;</code>代表双引号</p>
<p>颜色用法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">xmlns:media=&quot;clr-namespace:System.Windows.Media;assembly=PresentationCore&quot;</span><br><span class="line">&lt;Ellipse</span><br><span class="line">    Width=&quot;15&quot;</span><br><span class="line">    Height=&quot;15&quot;</span><br><span class="line">    Fill=&quot;&#123;c:Binding (HardwareManager.TemperatureController.Ch[2].IsOn and HardwareManager.TemperatureController.IsOn) ? media:Brushes.Green : media:Brushes.Red&#125;&quot;&gt;</span><br><span class="line">    &lt;Ellipse.Style&gt;</span><br><span class="line">        &lt;Style TargetType=&quot;Ellipse&quot; /&gt;</span><br><span class="line">    &lt;/Ellipse.Style&gt;</span><br><span class="line">&lt;/Ellipse&gt;</span><br></pre></td></tr></table></figure>

<h3 id="解读该开源项目"><a href="#解读该开源项目" class="headerlink" title="解读该开源项目"></a>解读该开源项目</h3><p>功能详解:</p>
<ul>
<li>ExpressionParsers   <strong>表达式解析</strong>   [[CSharp入门#Dynamic Express|本质上上调用了第三方库]]<ul>
<li><code>CachedExpressionParser.cs</code> 文件：<ul>
<li><code>CachedExpressionParser</code> 类实现了 <code>IExpressionParser</code> 接口，并使用了缓存机制来提高表达式解析的性能。它通过维护一个字典来存储已经解析过的表达式，避免重复解析。当需要解析一个表达式时，它首先检查缓存中是否已经存在该表达式的解析结果。如果存在，则直接返回缓存中的结果；如果不存在，则使用内部的 <code>IExpressionParser</code> 实例进行解析，并将结果缓存起来。</li>
</ul>
</li>
<li><code>ExpressionParser.cs</code> 文件：<ul>
<li><code>ExpressionParser</code> 类实现了 <code>IExpressionParser</code> 接口，它使用 <code>DynamicExpresso</code> 库来解析表达式。它通过 <code>Interpreter</code> 类的 <code>Parse</code> 方法来解析表达式，并通过 <code>Reference</code> 方法来设置引用类型。</li>
</ul>
</li>
<li><code>ParserFactory.cs</code> 文件：<ul>
<li><code>ParserFactory</code> 类提供了一个创建 <code>IExpressionParser</code> 实例的工厂方法。它可以创建一个 <code>CachedExpressionParser</code> 实例，并可以指定内部的 <code>IExpressionParser</code> 实例。如果没有指定，则默认使用 <code>ExpressionParser</code> 实例。</li>
</ul>
</li>
<li><code>IExpressionParser.cs</code> 文件：<ul>
<li><code>IExpressionParser</code> 接口定义了表达式解析器的两个基本操作：<code>Parse</code> 和 <code>SetReference</code>。<code>Parse</code> 方法用于解析表达式文本并返回一个 <code>Lambda</code> 对象，而 <code>SetReference</code> 方法用于设置解析过程中可能需要的引用类型。</li>
</ul>
</li>
</ul>
</li>
<li>Inversion    表达式求逆<ul>
<li><code>InverseException.cs</code>文件：<ul>
<li>定义了一个自定义异常类 <code>InverseException</code>，用于在表达式求逆过程中抛出异常。</li>
<li>继承自 <code>System.Exception</code>，并提供了四个构造函数，分别用于无参数、带消息、带消息和内部异常、以及序列化时使用。</li>
</ul>
</li>
<li><code>TwoKeysDictionary.cs</code>文件：<ul>
<li>定义了一个泛型类 <code>Dictionary&lt;TKey1, TKey2, TValue&gt;</code>，它继承自 <code>Dictionary&lt;TKey1, Dictionary&lt;TKey2, TValue&gt;&gt;</code>。</li>
<li>这个类的目的是提供一个二维字典的实现，其中 <code>TKey1</code>和 <code>TKey2</code>是键的类型，<code>TValue</code>是值的类型。</li>
<li>它提供了添加元素和获取元素的方法，以及一个索引器，可以通过两个键来访问值。</li>
</ul>
</li>
<li><code>Inverter.cs</code>文件：<ul>
<li>这个文件是求逆操作的核心，它包含了一个 <code>Inverter</code>类，用于对表达式进行求逆。</li>
<li><code>Inverter</code>类依赖于一个表达式解释器 <code>IExpressionParser</code>，用于将字符串表达式解析为 <code>Expression</code>对象。</li>
<li><code>Inverter</code>类的构造函数接受一个 <code>IExpressionParser</code>接口的实现作为参数。</li>
<li><code>InverseExpression</code>方法是求逆操作的入口，它接受一个表达式和一个参数表达式，返回一个Lambda表达式，表示求逆后的表达式。</li>
<li><code>InverseExpressionInternal</code>方法是一个递归方法，用于遍历表达式树，生成求逆后的表达式。</li>
<li><code>NodeTypeToString</code>方法用于将表达式类型转换为字符串，以便在生成求逆表达式时使用。</li>
<li><code>RES</code>是一个常量字符串，用于在生成求逆表达式时占位。</li>
<li><code>_interpreter</code>是一个私有字段，用于存储表达式解释器。</li>
<li><code>Types for recursion func work</code>部分定义了一些用于递归函数工作的类型，包括 <code>NodeType</code>、<code>ConstantPlace</code>、<code>RecursiveInfo</code>和 <code>ExpressionFuncsDictionary&lt;T&gt;</code>。</li>
</ul>
</li>
</ul>
</li>
<li>PathAnalysis   <strong>路径分析</strong>    XAML 绑定路径解析器，它的功能是分析 XAML 绑定路径字符串，并将其拆分成不同的路径片段，以便于进一步处理。<ul>
<li><code>PathTokenId.cs</code>：定义了一个 <code>PathTokenId</code> 类，用于标识路径片段的类型和值。它包含两个属性：<code>PathType</code> 和 <code>Value</code>，分别表示路径片段的类型和值。此外，它还重写了 <code>Equals</code> 和 <code>GetHashCode</code> 方法，以便于比较和哈希处理。</li>
<li><code>PathTokenType.cs</code>：定义了一个 <code>PathTokenType</code> 枚举，用于标识路径片段的类型。它包含四个成员：<code>Math</code>、<code>Property</code>、<code>StaticProperty</code> 和 <code>Enum</code>，分别表示数学路径、属性路径、静态属性路径和枚举路径。</li>
<li><code>PathToken.cs</code>：定义了一个 <code>PathToken</code> 抽象类，用于表示路径片段的基类。它包含两个属性：<code>Start</code> 和 <code>End</code>，分别表示路径片段的起始位置和结束位置。此外，它还包含一个抽象属性 <code>Id</code>，用于获取路径片段的标识。</li>
<li><code>EnumToken.cs</code>：定义了一个 <code>EnumToken</code> 类，用于表示枚举路径片段。它继承自 <code>PathToken</code> 类，并增加了两个属性：<code>Enum</code> 和 <code>EnumMember</code>，分别表示枚举类型和枚举成员。此外，它还重写了 <code>Id</code> 属性，以便于返回正确的路径标识。</li>
<li><code>PropertyPathToken.cs</code>：定义了一个 <code>PropertyPathToken</code> 类，用于表示属性路径片段。它继承自 <code>PathToken</code> 类，并增加了一个属性 <code>Properties</code>，用于表示属性路径的名称列表。此外，它还重写了 <code>Id</code> 属性，以便于返回正确的路径标识。</li>
<li><code>MathToken.cs</code>：定义了一个 <code>MathToken</code> 类，用于表示数学路径片段。它继承自 <code>PathToken</code> 类，并增加了一个属性 <code>MathMember</code>，用于表示数学路径的名称。此外，它还重写了 <code>Id</code> 属性，以便于返回正确的路径标识。</li>
<li><code>PropertyPathAnalyzer.cs</code>：定义了一个 <code>PropertyPathAnalyzer</code> 类，用于分析 XAML 绑定路径字符串。它包含一个静态构造函数，用于初始化一些静态字段。此外，它还包含一些私有方法，用于获取路径片段、分析路径类型等。最后，它包含一个公共方法 <code>GetPathes</code>，用于解析 XAML 绑定路径字符串，并返回一个路径片段列表。</li>
<li><code>StaticPropertyPathToken.cs</code>：定义了一个 <code>StaticPropertyPathToken</code> 类，用于表示静态属性路径片段。它继承自 <code>PropertyPathToken</code> 类，并增加了两个属性：<code>Class</code> 和 <code>Namespace</code>，分别表示静态属性所在的类和命名空间。此外，它还重写了 <code>Id</code> 属性，以便于返回正确的路径标识。</li>
</ul>
</li>
<li>Trace 追踪系统，用于记录和输出程序运行时的信息，帮助开发者调试和分析程序<ul>
<li><code>TraceComponent.cs</code> 文件定义了一个枚举类型 <code>TraceComponent</code>，其中包含两个成员：<code>CalcConverter</code> 和 <code>Parser</code>。这个枚举类型用于标识追踪信息的来源组件，例如，如果信息来自于 <code>CalcConverter</code> 组件，那么在追踪信息中就会包含 <code>CalcConverter</code> 这个标识。</li>
<li><code>Tracer.cs</code> 文件定义了一个密封类 <code>Tracer</code>，它负责追踪信息的记录和输出。这个类有一个静态构造函数，用于初始化两个静态字段：<code>_sourceSwitch</code> 和 <code>_traceSource</code>。<code>_sourceSwitch</code> 是一个 <code>SourceSwitch</code> 对象，用于控制追踪的级别；<code>_traceSource</code> 是一个 <code>TraceSource</code> 对象，用于输出追踪信息。</li>
</ul>
</li>
</ul>
<h2 id="DXBinding"><a href="#DXBinding" class="headerlink" title="DXBinding"></a>DXBinding</h2><p>类似于CalcBinding</p>
<p>但是是商业产品,要收费</p>
<p><a target="_blank" rel="noopener" href="https://docs.devexpress.com/WPF/115771/mvvm-framework/dxbinding/dxbinding">产品介绍</a></p>
<h2 id="XamlFlair"><a href="#XamlFlair" class="headerlink" title="XamlFlair"></a>XamlFlair</h2><p>XamlFlair 是一个用于 UWP、WPF 和 Uno 的动画库，旨在仅使用附加属性来实现 Xaml 动画。</p>
<p>MIT开源  <a target="_blank" rel="noopener" href="https://github.com/XamlFlair/XamlFlair">开源地址</a></p>
<h2 id="MaterialDesignThemes"><a href="#MaterialDesignThemes" class="headerlink" title="MaterialDesignThemes"></a>MaterialDesignThemes</h2><p>MaterialDesignInXamlToolkit 是一个开源、易于使用、强大的 WPF UI 控件库，旨在帮助开发人员在 C# 和 VB.Net 中实现 Google 的 Material Design 风格的用户界面。该框架提供了一组丰富的控件、样式和效果，使开发人员能够轻松创建现代化、具有吸引力的应用程序。</p>
<p>MIT开源  <a target="_blank" rel="noopener" href="https://github.com/MaterialDesignInXAML/MaterialDesignInXamlToolkit">开源地址</a></p>
<p>App.xaml中修改:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;Application </span><br><span class="line">  x:Class=&quot;Example.App&quot;</span><br><span class="line">  xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span><br><span class="line">  xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span><br><span class="line">  xmlns:materialDesign=&quot;http://materialdesigninxaml.net/winfx/xaml/themes&quot;</span><br><span class="line">  StartupUri=&quot;MainWindow.xaml&quot;&gt;</span><br><span class="line">    &lt;Application.Resources&gt;</span><br><span class="line">        &lt;ResourceDictionary&gt;</span><br><span class="line">            &lt;ResourceDictionary.MergedDictionaries&gt;</span><br><span class="line">                &lt;materialDesign:BundledTheme BaseTheme=&quot;Light&quot; PrimaryColor=&quot;DeepPurple&quot; SecondaryColor=&quot;Lime&quot; /&gt;</span><br><span class="line"></span><br><span class="line">                &lt;ResourceDictionary Source=&quot;pack://application:,,,/MaterialDesignThemes.Wpf;component/Themes/MaterialDesign2.Defaults.xaml&quot; /&gt; </span><br><span class="line">            &lt;/ResourceDictionary.MergedDictionaries&gt;</span><br><span class="line">        &lt;/ResourceDictionary&gt;</span><br><span class="line">    &lt;/Application.Resources&gt;</span><br><span class="line">&lt;/Application&gt;</span><br></pre></td></tr></table></figure>

<p>要引用的文件中:</p>
<p><code>xmlns:materialDesign=&quot;http://materialdesigninxaml.net/winfx/xaml/themes&quot;</code></p>
<p>只作用于局部控件:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;TabControl TabStripPlacement=&quot;Left&quot;&gt;</span><br><span class="line">  &lt;TabControl.Resources&gt;</span><br><span class="line">    &lt;ResourceDictionary&gt;</span><br><span class="line">      &lt;ResourceDictionary.MergedDictionaries&gt;</span><br><span class="line">        &lt;materialDesign:BundledTheme BaseTheme=&quot;Light&quot;</span><br><span class="line">                                     PrimaryColor=&quot;DeepPurple&quot;</span><br><span class="line">                                     SecondaryColor=&quot;Lime&quot;/&gt;</span><br><span class="line">        &lt;ResourceDictionary Source=&quot;pack://application:,,,/MaterialDesignThemes.Wpf;component/Themes/MaterialDesign2.Defaults.xaml&quot;/&gt;</span><br><span class="line">      &lt;/ResourceDictionary.MergedDictionaries&gt;</span><br><span class="line">    &lt;/ResourceDictionary&gt;</span><br><span class="line">  &lt;/TabControl.Resources&gt;</span><br><span class="line">  &lt;TabItem Header=&quot;TAB 1&quot;&gt;</span><br><span class="line">    &lt;TextBlock Margin=&quot;8&quot;</span><br><span class="line">               Text=&quot;Left placement&quot;/&gt;</span><br><span class="line">  &lt;/TabItem&gt;</span><br><span class="line">  &lt;TabItem Header=&quot;TAB 2&quot;&gt;</span><br><span class="line">    &lt;TextBlock Margin=&quot;8&quot;</span><br><span class="line">               Text=&quot;Left placement&quot;/&gt;</span><br><span class="line">  &lt;/TabItem&gt;</span><br><span class="line">&lt;/TabControl&gt;</span><br></pre></td></tr></table></figure>

<h2 id="LayUI-Wpf"><a href="#LayUI-Wpf" class="headerlink" title="LayUI.Wpf"></a>LayUI.Wpf</h2><p>LayUI-WPF是一个WPF版的Layui前端UI样式库，该控件库参考了Web版本的LayUI风格，利用该控件库可以完成现代化UI客户端程序，让你的客户端看起来更加简洁丰富又不失美感。</p>
<p>无开源协议  <a href="#https://github.com/Layui-WPF-Team/Layui-WPF">开源地址</a></p>
<h2 id="Dotnet9WPFControls"><a href="#Dotnet9WPFControls" class="headerlink" title="Dotnet9WPFControls"></a>Dotnet9WPFControls</h2><p>新手引导控件</p>
<p>MIT开源  <a target="_blank" rel="noopener" href="https://github.com/dotnet9/Dotnet9WPFControls">开源地址</a></p>
<p>注意在nuget包搜索的时候,要勾选包括预发行版才能搜到Dotnet9WPFControls</p>
<p>添加默认主题文件:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;prism:PrismApplication</span><br><span class="line">    x:Class=&quot;NewbieGuideDemo.App&quot;</span><br><span class="line">    xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span><br><span class="line">    xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span><br><span class="line">    xmlns:prism=&quot;http://prismlibrary.com/&quot;&gt;</span><br><span class="line">    &lt;prism:PrismApplication.Resources&gt;</span><br><span class="line"></span><br><span class="line">        &lt;ResourceDictionary&gt;</span><br><span class="line">            &lt;ResourceDictionary.MergedDictionaries&gt;</span><br><span class="line">                &lt;ResourceDictionary Source=&quot;pack://application:,,,/Dotnet9WPFControls;component/Themes/Dotnet9WPFControls.xaml&quot; /&gt;</span><br><span class="line">            &lt;/ResourceDictionary.MergedDictionaries&gt;</span><br><span class="line">        &lt;/ResourceDictionary&gt;</span><br><span class="line">    &lt;/prism:PrismApplication.Resources&gt;</span><br><span class="line">&lt;/prism:PrismApplication&gt;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7102807207468597261">具体使用方式参考此链接</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2066392">相关的实现原理可以参考这个</a></p>
<h2 id="混淆工具"><a href="#混淆工具" class="headerlink" title="混淆工具"></a>混淆工具</h2><p><a target="_blank" rel="noopener" href="https://github.com/obfuscar/obfuscar">Obfuscar</a>   MIT开源</p>
<p><a target="_blank" rel="noopener" href="https://github.com/NotPrab/.NET-Deobfuscator">混淆与反混淆工具大全盘点</a></p>
<p>Obfuscator实测未找到反混淆工具,不知道是否就是Obfuscar</p>
<h2 id="FastHotKeyForWPF"><a href="#FastHotKeyForWPF" class="headerlink" title="FastHotKeyForWPF"></a>FastHotKeyForWPF</h2><p>MIT开源  用于快速注册全局快捷键</p>
<p><a target="_blank" rel="noopener" href="https://github.com/ChengduNeusoftUniversity-FengJunjie-Y22/FastHotKeyForWPF">开源地址</a></p>
<h2 id="System-Configuration-ConfigurationManager"><a href="#System-Configuration-ConfigurationManager" class="headerlink" title="System.Configuration.ConfigurationManager"></a>System.Configuration.ConfigurationManager</h2><p>System.Configuration.ConfigurationManager  配置库</p>
<h2 id="WPF-ControlBase"><a href="#WPF-ControlBase" class="headerlink" title="WPF-ControlBase"></a>WPF-ControlBase</h2><p><a target="_blank" rel="noopener" href="https://github.com/HeBianGu/WPF-ControlBase">WPF控件库</a></p>
<p>内含各种图表库,看起来不赖</p>
<p>图表所在nuget包: HeBianGu.Control.Chart2D</p>
<p>一些依赖属性盘点</p>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>xDisplay</td>
<td><code>ObservableCollection&lt;string&gt;</code></td>
<td>用于存储和绑定 X 轴的显示数据。</td>
</tr>
<tr>
<td>yDisplay</td>
<td><code>ObservableCollection&lt;string&gt;</code></td>
<td>用于存储和绑定 Y 轴的显示数据。</td>
</tr>
<tr>
<td>LegendStyle</td>
<td>Style</td>
<td>用于设置图例的样式。</td>
</tr>
<tr>
<td>VisualMapStyle</td>
<td>Style</td>
<td>用于设置视觉映射的样式。</td>
</tr>
<tr>
<td>UseRefreshButton</td>
<td>bool</td>
<td>控制是否显示刷新按钮。</td>
</tr>
<tr>
<td>UseLegend</td>
<td>bool</td>
<td>控制是否使用图例。</td>
</tr>
<tr>
<td>UseGrid</td>
<td>bool</td>
<td>控制是否显示网格。</td>
</tr>
<tr>
<td>UseMarkLine</td>
<td>bool</td>
<td>控制是否使用标记线。</td>
</tr>
<tr>
<td>UseMarkPosition</td>
<td>bool</td>
<td>控制是否使用标记位置。</td>
</tr>
<tr>
<td>UseDrawOnce</td>
<td>bool</td>
<td>控制是否需要调用 DrawOnce 方法进行刷新。true 表示需要手动调用刷新，false 表示属性更改时自动刷新。</td>
</tr>
<tr>
<td>xAxis</td>
<td>DoubleCollection</td>
<td>用于存储 X 轴的坐标数据。</td>
</tr>
<tr>
<td>yAxis</td>
<td>DoubleCollection</td>
<td>用于存储 Y 轴的坐标数据。</td>
</tr>
<tr>
<td>xDatas</td>
<td>DoubleCollection</td>
<td>用于存储 X 轴的数据点。</td>
</tr>
<tr>
<td>yDatas</td>
<td>DoubleCollection</td>
<td>用于存储 Y 轴的数据点。</td>
</tr>
<tr>
<td>yAxisCount</td>
<td>int</td>
<td>用于指定 Y 轴的坐标点个数。</td>
</tr>
<tr>
<td>xAxisCount</td>
<td>int</td>
<td>用于指定 X 轴的坐标点个数。</td>
</tr>
<tr>
<td>yAxisAuto</td>
<td>bool</td>
<td>控制 Y 轴是否根据数据自动计算。</td>
</tr>
<tr>
<td>xAxisAuto</td>
<td>bool</td>
<td>控制 X 轴是否根据数据自动计算。</td>
</tr>
<tr>
<td>DrawOnce</td>
<td>bool</td>
<td>控制是否在数据刷新后只绘制一次。</td>
</tr>
</tbody></table>
<p>图表相关</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> xmlns:h=&quot;https://github.com/HeBianGu&quot;</span><br><span class="line">&lt;h:Chart Padding=&quot;100,50&quot;</span><br><span class="line">         DisplayName=&quot;Beijing AQI&quot;</span><br><span class="line">         Style=&quot;&#123;DynamicResource &#123;x:Static h:Chart.CoordKey&#125;&#125;&quot;</span><br><span class="line">         xAxis=&quot;0,90,180,270,360&quot;</span><br><span class="line">         yAxis=&quot;-2,0,2,4,6,8,10,12&quot;&gt;</span><br><span class="line">    &lt;h:Series&gt;</span><br><span class="line">        &lt;h:Series.Foreground&gt;</span><br><span class="line">            &lt;LinearGradientBrush StartPoint=&quot;0,0&quot; EndPoint=&quot;0,1&quot;&gt;</span><br><span class="line">                &lt;GradientStop Offset=&quot;0&quot; Color=&quot;#7e0023&quot; /&gt;</span><br><span class="line">                &lt;GradientStop Offset=&quot;0.1&quot; Color=&quot;#7e0023&quot; /&gt;</span><br><span class="line">                &lt;GradientStop Offset=&quot;0.1&quot; Color=&quot;#660099&quot; /&gt;</span><br><span class="line">                &lt;GradientStop Offset=&quot;0.4&quot; Color=&quot;#660099&quot; /&gt;</span><br><span class="line">                &lt;GradientStop Offset=&quot;0.4&quot; Color=&quot;#cc0033&quot; /&gt;</span><br><span class="line">                &lt;GradientStop Offset=&quot;0.6&quot; Color=&quot;#cc0033&quot; /&gt;</span><br><span class="line">                &lt;GradientStop Offset=&quot;0.6&quot; Color=&quot;#ff9933&quot; /&gt;</span><br><span class="line">                &lt;GradientStop Offset=&quot;0.8&quot; Color=&quot;#ff9933&quot; /&gt;</span><br><span class="line">                &lt;GradientStop Offset=&quot;0.8&quot; Color=&quot;#ffde33&quot; /&gt;</span><br><span class="line">                &lt;GradientStop Offset=&quot;1&quot; Color=&quot;#ffde33&quot; /&gt;</span><br><span class="line">                &lt;GradientStop Offset=&quot;1&quot; Color=&quot;#096&quot; /&gt;</span><br><span class="line">                &lt;GradientStop Offset=&quot;1.2&quot; Color=&quot;#096&quot; /&gt;</span><br><span class="line">            &lt;/LinearGradientBrush&gt;</span><br><span class="line">        &lt;/h:Series.Foreground&gt;</span><br><span class="line"></span><br><span class="line">        &lt;h:Line Data=&quot;5.5,5.99,6.48,6.95,7.4,7.82,8.22,8.59,8.92,9.21,9.46,9.66,9.82,9.93,9.99,10,9.96,9.87,9.73,9.55,9.32,9.04,8.73,8.38,7.99,7.58,7.14,6.67,6.2,5.71,5.21,4.71,4.21,3.72,3.25,2.79,2.35,1.94,1.56,1.22,0.91,0.64,0.42,0.24,0.11,0.03,0,0.02,0.09,0.21,0.37,0.58,0.84,1.14,1.47,1.84,2.25,2.68,3.13,3.6,4.09,4.58,5.08,5.58,6.08,6.56,7.02,7.47,7.89,8.28,8.64,8.97,9.25,9.49,9.69,9.84,9.94,9.99,9.99,9.95,9.85,9.7,9.51,9.27,8.99,8.67,8.31,7.92,7.51,7.06,6.6,6.11,5.62,5.12,4.62,4.13,3.64,3.17,2.71,2.28,1.87,1.5,1.16,0.86,0.6,0.39,0.22,0.1,0.02,0,0.03,0.1,0.23,0.4,0.62,0.89,1.19,1.53,1.91,2.32,2.75,3.21,3.68,4.17,4.67,5.17,5.67,6.16,6.64,7.1,7.54,7.96,8.35,8.7,9.02,9.3,9.53,9.72,9.86,9.95,10,9.99,9.93,9.83,9.67,9.47,9.23,8.94,8.61,8.25,7.86,7.43,6.98,6.52,6.03,5.54,5.04,4.54,4.05,3.56,3.09,2.64,2.21,1.81,1.44,1.11,0.81,0.56,0.35,0.19,0.08,0.02,0,0.04,0.12,0.26,0.44,0.66,0.93,1.25,1.59,1.98,2.39,2.83,3.29,3.77,4.26,4.75,5.25,5.75,6.24,6.72,7.18,7.62,8.03,8.41,8.76,9.07,9.34,9.56,9.75,9.88,9.96,10,9.98,9.92,9.81,9.64,9.44,9.18,8.89,8.56,8.19,7.79,7.36,6.91,6.44,5.95,5.46,4.96,4.46,3.96,3.48,3.01,2.56,2.14,1.75,1.38,1.06,0.77,0.52,0.32,0.17,0.07,0.01,0,0.05,0.14,0.28,0.47,0.71,0.98,1.3,1.66,2.04,2.46,2.9,3.37,3.85,4.34,4.84,5.34,5.83,6.32,6.8,7.25,7.69,8.09,8.47,8.81,9.12,9.38,9.6,9.77,9.9,9.97,10,9.98,9.9,9.78,9.61,9.4,9.14,8.84,8.5,8.12,7.72,7.28,6.83,6.35,5.87,5.37,4.87,4.37,3.88,3.4,2.94,2.49,2.07,1.68,1.33,1,0.72,0.49,0.29,0.15,0.05,0.01,0.01,0.06,0.16,0.31,0.51,0.75,1.03,1.36,1.72,2.11,2.53,2.98,3.45,3.93,4.42,4.92,5.42,5.92,6.4,6.87,7.33,7.76,8.16,8.53,8.87,9.16,9.42,9.63,9.8,9.91,9.98,10,9.97,9.89,9.76,9.58,9.36,9.09,8.78,8.44,8.06,7.65,7.21,6.75,6.27,5.78,5.29,4.79,4.29,3.8,3.32,2.86,2.42,2,1.62,1.27,0.95,0.68,0.45,0.27,0.13,0.04 &quot; xAxis=&quot;1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360&quot; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;h:MarkLine Data=&quot;2,4,6,9&quot; MarkBrushes=&quot;#ff9933,#cc0033,#660099,#7e0023&quot; /&gt;</span><br><span class="line">    &lt;/h:Series&gt;</span><br><span class="line">&lt;/h:Chart&gt;</span><br></pre></td></tr></table></figure>

<h3 id="动态曲线案例"><a href="#动态曲线案例" class="headerlink" title="动态曲线案例"></a>动态曲线案例</h3><p>SinPolarControl.xaml  参考官方项目的正弦曲线</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;h:Chart</span><br><span class="line">    Grid.Row=&quot;1&quot;</span><br><span class="line">    Padding=&quot;100,50&quot;</span><br><span class="line">    Style=&quot;&#123;DynamicResource &#123;x:Static h:Chart.CoordKey&#125;&#125;&quot;</span><br><span class="line">    xAxis=&quot;0,600,1200,1800,2400,3000,3600&quot;</span><br><span class="line">    yAxis=&quot;-50,-25,0,25,50&quot;&gt;</span><br><span class="line">    &lt;h:Series xDatas=&quot;&#123;Binding XDatas&#125;&quot; yDatas=&quot;&#123;Binding YDatas&#125;&quot;&gt;</span><br><span class="line">        &lt;h:Line Style=&quot;&#123;DynamicResource &#123;x:Static h:Line.SingleKey&#125;&#125;&quot; TryFreeze=&quot;False&quot; /&gt;</span><br><span class="line">          &lt;!--平均值横轴显示--&gt;</span><br><span class="line">        &lt;h:MarkLine</span><br><span class="line">            MarkLineType=&quot;Average&quot;</span><br><span class="line">            Style=&quot;&#123;DynamicResource &#123;x:Static h:MarkLine.SingleKey&#125;&#125;&quot;</span><br><span class="line">            TryFreeze=&quot;False&quot; /&gt;</span><br><span class="line">    &lt;/h:Series&gt;</span><br><span class="line">&lt;/h:Chart&gt;</span><br></pre></td></tr></table></figure>

<p>viewmodel如此写:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> DoubleCollection _YDatas;</span><br><span class="line"> <span class="keyword">public</span> DoubleCollection YDatas</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">get</span> &#123; <span class="keyword">return</span> _YDatas; &#125;</span><br><span class="line">     <span class="keyword">set</span> &#123; SetProperty(<span class="keyword">ref</span> _YDatas, <span class="keyword">value</span>); &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> DoubleCollection _XDatas;</span><br><span class="line"> <span class="keyword">public</span> DoubleCollection XDatas</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">get</span> &#123; <span class="keyword">return</span> _XDatas; &#125;</span><br><span class="line">     <span class="keyword">set</span> &#123; SetProperty(<span class="keyword">ref</span> _XDatas, <span class="keyword">value</span>); &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> List&lt;<span class="built_in">double</span>&gt; _Xdoubles = <span class="keyword">new</span>();</span><br><span class="line"> <span class="keyword">public</span> List&lt;<span class="built_in">double</span>&gt; Xdoubles</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">get</span> &#123; <span class="keyword">return</span> _Xdoubles; &#125;</span><br><span class="line">     <span class="keyword">set</span> &#123; SetProperty(<span class="keyword">ref</span> _Xdoubles, <span class="keyword">value</span>); &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> List&lt;<span class="built_in">double</span>&gt; _Ydoubles = <span class="keyword">new</span>();</span><br><span class="line"> <span class="keyword">public</span> List&lt;<span class="built_in">double</span>&gt; Ydoubles</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">get</span> &#123; <span class="keyword">return</span> _Ydoubles; &#125;</span><br><span class="line">     <span class="keyword">set</span> &#123; SetProperty(<span class="keyword">ref</span> _Ydoubles, <span class="keyword">value</span>); &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">async</span> <span class="keyword">void</span> <span class="title">startChartRefresh</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">double</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Xdoubles.Add(i++);</span><br><span class="line">        Ydoubles.Add(cpuUsage);</span><br><span class="line">        XDatas = <span class="keyword">new</span> DoubleCollection(Xdoubles);</span><br><span class="line">        YDatas = <span class="keyword">new</span> DoubleCollection(Ydoubles);</span><br><span class="line">        PointCount = Xdoubles.Count;<span class="comment">//更新点数</span></span><br><span class="line">        <span class="keyword">await</span> Task.Delay(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="示波器"><a href="#示波器" class="headerlink" title="示波器"></a>示波器</h3><p>OscControl</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;h:Chart Padding=&quot;100,50&quot;</span><br><span class="line">         Style=&quot;&#123;DynamicResource &#123;x:Static h:Chart.CoordKey&#125;&#125;&quot;</span><br><span class="line">         xAxis=&quot;0,600,1200,1800,2400,3000,3600&quot;</span><br><span class="line">         yAxis=&quot;-150,-100,-50,0,50,100,150&quot;&gt;</span><br><span class="line">    &lt;h:Chart.LegendStyle&gt;</span><br><span class="line">        &lt;Style TargetType=&quot;h:Legend&quot;&gt;</span><br><span class="line">            &lt;Setter Property=&quot;Visibility&quot; Value=&quot;Collapsed&quot; /&gt;</span><br><span class="line">        &lt;/Style&gt;</span><br><span class="line">    &lt;/h:Chart.LegendStyle&gt;</span><br><span class="line">    &lt;h:Series xDatas=&quot;&#123;Binding WaveyAxis&#125;&quot; yDatas=&quot;&#123;Binding WaveData2&#125;&quot;&gt;</span><br><span class="line">        &lt;h:Line Style=&quot;&#123;DynamicResource &#123;x:Static h:Line.SingleKey&#125;&#125;&quot;  TryFreeze=&quot;False&quot; /&gt;</span><br><span class="line">        &lt;h:MarkLine MarkLineType=&quot;Average&quot; Style=&quot;&#123;DynamicResource &#123;x:Static h:MarkLine.SingleKey&#125;&#125;&quot; TryFreeze=&quot;False&quot; /&gt;</span><br><span class="line">          &lt;!--最大值--&gt;</span><br><span class="line">        &lt;h:MarkPosition MarkValueType=&quot;Max&quot; Style=&quot;&#123;DynamicResource &#123;x:Static h:MarkPosition.SingleKey&#125;&#125;&quot; TryFreeze=&quot;False&quot; /&gt;</span><br><span class="line">    &lt;/h:Series&gt;</span><br><span class="line">&lt;/h:Chart&gt;</span><br></pre></td></tr></table></figure>

<p>控制x,y轴,网格显示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;h:Chart Padding=&quot;100,50&quot; xAxis=&quot;0,1,2,3,4,5,6,7,8,9,10,11,12&quot; yAxis=&quot;0,1,2,3,4,5,6,7,8,9,10&quot;&gt;</span><br><span class="line">    &lt;h:ViewLayerGroup&gt;</span><br><span class="line">        &lt;h:yAxis /&gt;</span><br><span class="line">        &lt;h:xAxis VerticalAlignment=&quot;Top&quot; DockAlignment=&quot;Top&quot; /&gt;</span><br><span class="line">        &lt;h:xAxis VerticalAlignment=&quot;Bottom&quot;  /&gt;</span><br><span class="line">    &lt;/h:ViewLayerGroup&gt;</span><br><span class="line">      &lt;h:Grid Style=&quot;&#123;DynamicResource &#123;x:Static h:Grid.CrossKey&#125;&#125;&quot; /&gt;</span><br><span class="line">&lt;/h:Chart&gt;</span><br><span class="line">&lt;!--&lt;h:xAxis Value=&quot;3&quot; /&gt;--&gt;</span><br></pre></td></tr></table></figure>

<h3 id="曲线抽稀"><a href="#曲线抽稀" class="headerlink" title="曲线抽稀"></a>曲线抽稀</h3><p>Thinning 参考的是  ThinningControl.xaml</p>
<p>主要是用于处理静态图</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">&lt;h:ChartMap Background=&quot;&#123;DynamicResource &#123;x:Static h:BrushKeys.Dark0_6&#125;&#125;&quot;</span><br><span class="line">                            Chart=&quot;&#123;Binding ElementName=chart&#125;&quot;</span><br><span class="line">                            DockPanel.Dock=&quot;Bottom&quot;</span><br><span class="line">                            xAxis=&quot;&#123;Binding xAxis&#125;&quot;</span><br><span class="line">                            xDatas=&quot;&#123;Binding xAxis&#125;&quot;</span><br><span class="line">                            yAxis=&quot;-50,-25,0,25,50&quot;</span><br><span class="line">                            yDatas=&quot;&#123;Binding Datas&#125;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">                &lt;h:Chart x:Name=&quot;chart&quot;</span><br><span class="line">                         Padding=&quot;100,50&quot;</span><br><span class="line">                         Background=&quot;Transparent&quot;</span><br><span class="line">                         Style=&quot;&#123;DynamicResource &#123;x:Static h:Chart.CoordKey&#125;&#125;&quot;</span><br><span class="line">                         UseLegend=&quot;True&quot;</span><br><span class="line">                         xAxisAuto=&quot;True&quot;</span><br><span class="line">                         yAxis=&quot;-50,-25,0,25,50&quot;</span><br><span class="line">                         yAxisAuto=&quot;True&quot;&gt;</span><br><span class="line">                    &lt;h:Series DisplayName=&quot;抽稀前&quot; Foreground=&quot;Green&quot;&gt;</span><br><span class="line">                        &lt;h:Line/&gt;</span><br><span class="line"></span><br><span class="line">                        &lt;h:Scatter&gt;</span><br><span class="line">                            &lt;h:Scatter.MarkStyle&gt;</span><br><span class="line">                                &lt;Style BasedOn=&quot;&#123;StaticResource &#123;x:Static h:EllipseMarker.DefaultKey&#125;&#125;&quot; TargetType=&quot;h:EllipseMarker&quot;&gt;</span><br><span class="line">                                    &lt;Setter Property=&quot;StrokeThickness&quot; Value=&quot;3&quot; /&gt;</span><br><span class="line">                                    &lt;Setter Property=&quot;Fill&quot; Value=&quot;&#123;DynamicResource &#123;x:Static h:BrushKeys.BackgroundDefault&#125;&#125;&quot; /&gt;</span><br><span class="line">                                    &lt;Setter Property=&quot;Rect&quot;&gt;</span><br><span class="line">                                        &lt;Setter.Value&gt;</span><br><span class="line">                                            &lt;Rect Width=&quot;5&quot; Height=&quot;5&quot; /&gt;</span><br><span class="line">                                        &lt;/Setter.Value&gt;</span><br><span class="line">                                    &lt;/Setter&gt;</span><br><span class="line">                                    &lt;Setter Property=&quot;ToolTip&quot; Value=&quot;&#123;Binding RelativeSource=&#123;RelativeSource Mode=Self&#125;, Path=Tag&#125;&quot; /&gt;</span><br><span class="line">                                &lt;/Style&gt;</span><br><span class="line">                            &lt;/h:Scatter.MarkStyle&gt;</span><br><span class="line">                        &lt;/h:Scatter&gt;</span><br><span class="line">                        &lt;h:MarkPosition Foreground=&quot;Green&quot; MarkValueType=&quot;Max&quot; Style=&quot;&#123;DynamicResource &#123;x:Static h:MarkPosition.SingleKey&#125;&#125;&quot; /&gt;</span><br><span class="line">                        &lt;h:MarkPosition Foreground=&quot;Green&quot; MarkValueType=&quot;Min&quot; Style=&quot;&#123;DynamicResource &#123;x:Static h:MarkPosition.SingleKey&#125;&#125;&quot; /&gt;</span><br><span class="line">                        &lt;h:MarkLine Foreground=&quot;Green&quot; MarkLineType=&quot;Average&quot; Style=&quot;&#123;DynamicResource &#123;x:Static h:MarkLine.SingleKey&#125;&#125;&quot; /&gt;</span><br><span class="line">                        &lt;h:MarkTip Foreground=&quot;Green&quot; MarkTipType=&quot;Step&quot; /&gt;</span><br><span class="line">                    &lt;/h:Series&gt;</span><br><span class="line"></span><br><span class="line">                    &lt;h:Series DisplayName=&quot;抽稀后 阈值 3&quot; Foreground=&quot;Purple&quot;&gt;</span><br><span class="line">                        &lt;h:Line ThinningType=&quot;Douglas&quot; Threshold=&quot;1&quot; /&gt;</span><br><span class="line"></span><br><span class="line">                        &lt;h:Scatter&gt;</span><br><span class="line">                            &lt;h:Scatter.MarkStyle&gt;</span><br><span class="line">                                &lt;Style BasedOn=&quot;&#123;StaticResource &#123;x:Static h:EllipseMarker.DefaultKey&#125;&#125;&quot; TargetType=&quot;h:EllipseMarker&quot;&gt;</span><br><span class="line">                                    &lt;Setter Property=&quot;StrokeThickness&quot; Value=&quot;3&quot; /&gt;</span><br><span class="line">                                    &lt;Setter Property=&quot;Fill&quot; Value=&quot;&#123;DynamicResource &#123;x:Static h:BrushKeys.BackgroundDefault&#125;&#125;&quot; /&gt;</span><br><span class="line">                                    &lt;Setter Property=&quot;Rect&quot;&gt;</span><br><span class="line">                                        &lt;Setter.Value&gt;</span><br><span class="line">                                            &lt;Rect Width=&quot;5&quot; Height=&quot;5&quot; /&gt;</span><br><span class="line">                                        &lt;/Setter.Value&gt;</span><br><span class="line">                                    &lt;/Setter&gt;</span><br><span class="line">                                    &lt;Setter Property=&quot;ToolTip&quot; Value=&quot;&#123;Binding RelativeSource=&#123;RelativeSource Mode=Self&#125;, Path=Tag&#125;&quot; /&gt;</span><br><span class="line">                                &lt;/Style&gt;</span><br><span class="line">                            &lt;/h:Scatter.MarkStyle&gt;</span><br><span class="line">                        &lt;/h:Scatter&gt;</span><br><span class="line">                        &lt;h:MarkPosition Foreground=&quot;Purple&quot; MarkValueType=&quot;Max&quot; Style=&quot;&#123;DynamicResource &#123;x:Static h:MarkPosition.SingleKey&#125;&#125;&quot; /&gt;</span><br><span class="line">                        &lt;h:MarkPosition Foreground=&quot;Purple&quot; MarkValueType=&quot;Min&quot; Style=&quot;&#123;DynamicResource &#123;x:Static h:MarkPosition.SingleKey&#125;&#125;&quot; /&gt;</span><br><span class="line">                        &lt;h:MarkLine Foreground=&quot;Purple&quot; MarkLineType=&quot;Average&quot; Style=&quot;&#123;DynamicResource &#123;x:Static h:MarkLine.SingleKey&#125;&#125;&quot; /&gt;</span><br><span class="line">                        &lt;h:MarkTip Foreground=&quot;Purple&quot; MarkTipType=&quot;Step&quot; /&gt;</span><br><span class="line">                    &lt;/h:Series&gt;</span><br><span class="line"></span><br><span class="line">                    &lt;h:Series DisplayName=&quot;抽稀后 阈值 10&quot; Foreground=&quot;Red&quot;&gt;</span><br><span class="line">                        &lt;h:Line ThinningType=&quot; &quot; Threshold=&quot;10&quot; /&gt;</span><br><span class="line"></span><br><span class="line">                        &lt;h:Scatter&gt;</span><br><span class="line">                            &lt;h:Scatter.MarkStyle&gt;</span><br><span class="line">                                &lt;Style BasedOn=&quot;&#123;StaticResource &#123;x:Static h:EllipseMarker.DefaultKey&#125;&#125;&quot; TargetType=&quot;h:EllipseMarker&quot;&gt;</span><br><span class="line">                                    &lt;Setter Property=&quot;StrokeThickness&quot; Value=&quot;3&quot; /&gt;</span><br><span class="line">                                    &lt;Setter Property=&quot;Fill&quot; Value=&quot;&#123;DynamicResource &#123;x:Static h:BrushKeys.BackgroundDefault&#125;&#125;&quot; /&gt;</span><br><span class="line">                                    &lt;Setter Property=&quot;Rect&quot;&gt;</span><br><span class="line">                                        &lt;Setter.Value&gt;</span><br><span class="line">                                            &lt;Rect Width=&quot;5&quot; Height=&quot;5&quot; /&gt;</span><br><span class="line">                                        &lt;/Setter.Value&gt;</span><br><span class="line">                                    &lt;/Setter&gt;</span><br><span class="line">                                    &lt;Setter Property=&quot;ToolTip&quot; Value=&quot;&#123;Binding RelativeSource=&#123;RelativeSource Mode=Self&#125;, Path=Tag&#125;&quot; /&gt;</span><br><span class="line">                                &lt;/Style&gt;</span><br><span class="line">                            &lt;/h:Scatter.MarkStyle&gt;</span><br><span class="line">                        &lt;/h:Scatter&gt;</span><br><span class="line">                        &lt;h:MarkPosition Foreground=&quot;Red&quot; MarkValueType=&quot;Max&quot; Style=&quot;&#123;DynamicResource &#123;x:Static h:MarkPosition.SingleKey&#125;&#125;&quot; /&gt;</span><br><span class="line">                        &lt;h:MarkPosition Foreground=&quot;Red&quot; MarkValueType=&quot;Min&quot; Style=&quot;&#123;DynamicResource &#123;x:Static h:MarkPosition.SingleKey&#125;&#125;&quot; /&gt;</span><br><span class="line">                        &lt;h:MarkLine Foreground=&quot;Red&quot; MarkLineType=&quot;Average&quot; Style=&quot;&#123;DynamicResource &#123;x:Static h:MarkLine.SingleKey&#125;&#125;&quot; /&gt;</span><br><span class="line">                        &lt;h:MarkTip Foreground=&quot;Red&quot; MarkTipType=&quot;Step&quot; /&gt;</span><br><span class="line">                    &lt;/h:Series&gt;</span><br><span class="line">                &lt;/h:Chart&gt;</span><br></pre></td></tr></table></figure>

<h3 id="值得参考的成品项目"><a href="#值得参考的成品项目" class="headerlink" title="值得参考的成品项目"></a>值得参考的成品项目</h3><p>HeBianGu.App.Track</p>
<h2 id="拖拽节点编辑器框架"><a href="#拖拽节点编辑器框架" class="headerlink" title="拖拽节点编辑器框架"></a>拖拽节点编辑器框架</h2><p><a target="_blank" rel="noopener" href="https://github.com/miroiu/nodify">nodify</a>  MIT开源,支持MVVM</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zt199510/p/18306876">学习参考</a></p>
<p><a target="_blank" rel="noopener" href="https://miroiu.github.io/nodify/">官方学习</a></p>
<h2 id="WPF项目创建向导VS插件"><a href="#WPF项目创建向导VS插件" class="headerlink" title="WPF项目创建向导VS插件"></a>WPF项目创建向导VS插件</h2><p>Template Studio for WPF</p>
<p>可以支持直接常见应用程序的框架,支持Prism,MVVM Toolkit以及Code Behind设计模式</p>
<p>包括强制登录,可选登录</p>
<p>包括主题色选择功能,打包功能等</p>
<p>包括各种测试框架</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lindexi/p/15152101.html">详细用法参考</a>  内含 <code>ClientId is not a GUID</code>错误的解决方式</p>
<h2 id="二进制编辑器控件库"><a href="#二进制编辑器控件库" class="headerlink" title="二进制编辑器控件库"></a>二进制编辑器控件库</h2><p>apache2开源协议</p>
<p><a target="_blank" rel="noopener" href="https://github.com/abbaye/WpfHexEditorControl">二进制编辑器控件 WpfHexEditorControl</a></p>
<p><a target="_blank" rel="noopener" href="https://www.nuget.org/packages/WPFHexaEditor/">nuget包下载</a></p>
<p>MVVM的支持不是那么好,需要自己进行二次封装</p>
<h2 id="打包参考"><a href="#打包参考" class="headerlink" title="打包参考"></a>打包参考</h2><h3 id="MSIX-Packaging"><a href="#MSIX-Packaging" class="headerlink" title="MSIX Packaging"></a>MSIX Packaging</h3><p>MSIX Packaging 是一种用于打包和分发 Windows 应用程序的技术，旨在取代传统的应用程序安装方式（如 MSI 和 EXE）。MSIX 是 Microsoft 提出的一个现代化的打包格式，旨在提供更好的安全性、可靠性和用户体验</p>
<h2 id="动画库"><a href="#动画库" class="headerlink" title="动画库"></a>动画库</h2><p><a target="_blank" rel="noopener" href="https://github.com/XamlFlair/XamlFlair">开源WPF动画库 XamlFlair</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xmlns:xf=&quot;clr-namespace:XamlFlair;assembly=XamlFlair.WPF&quot;</span><br><span class="line">&lt;!--只需要为任何需要动画的内容设置附加属性即可--&gt;</span><br><span class="line">&lt;Border xf:Animations.Primary=&quot;&#123;StaticResource FadeIn&#125;&quot; /&gt;</span><br></pre></td></tr></table></figure>



<h1 id="WPF引入矢量图"><a href="#WPF引入矢量图" class="headerlink" title="WPF引入矢量图"></a>WPF引入矢量图</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhaotianff/p/18058585">参考链接</a></p>
<h1 id="WPF与HTML交互"><a href="#WPF与HTML交互" class="headerlink" title="WPF与HTML交互"></a>WPF与HTML交互</h1><p>交互方案</p>
<ul>
<li>WebBrowser(微软提供)  最老的,不建议使用  支持Flash</li>
<li>WebView(微软提供)   微软优化</li>
<li>CefSharp(第三方,用户数量大)  兼容浏览器最广泛,最低可以支持到winXP  支持Flash</li>
</ul>
<h2 id="WebBrowser"><a href="#WebBrowser" class="headerlink" title="WebBrowser"></a>WebBrowser</h2><p><strong>基于</strong>：<code>WebBrowser</code> 控件是基于 Internet Explorer 的。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>简单易用，适合基本的网页显示需求。</li>
<li>可以直接在 XAML 中使用。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>依赖于 Internet Explorer，可能不支持现代网页技术（如 HTML5、CSS3 和 JavaScript ES6）。</li>
<li>性能较差，尤其是在处理复杂网页时。</li>
<li>安全性较低，可能会受到 IE 的安全限制。</li>
</ul>
<h3 id="显示相关"><a href="#显示相关" class="headerlink" title="显示相关"></a>显示相关</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//直接显示一个外部网页</span><br><span class="line">&lt;WebBrowser Source=&quot;http://www.bing.com&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>显示一个自己编写的网页:</p>
<p>项目下创建一个文件夹为Assets,下面创建文件Monitor.html,里面编写html代码</p>
<p>该html代码文件必须设置属性为<strong>资源</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;WebBrowser Name=&quot;browser&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>在xaml.cs后台文件中引入html文件到WebBrowser控件</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载资源到页面</span></span><br><span class="line"> Uri uri = <span class="keyword">new</span> Uri(<span class="string">&quot;pack://application:,,,/wpfWebbrowser;component/Assets/Monitor.html&quot;</span>,</span><br><span class="line"> UriKind.RelativeOrAbsolute);</span><br><span class="line"> Stream src = Application.GetResourceStream(uri).Stream;</span><br><span class="line"> browser.NavigateToStream(src);</span><br></pre></td></tr></table></figure>

<h3 id="js和c-交互"><a href="#js和c-交互" class="headerlink" title="js和c#交互"></a>js和c#交互</h3><h4 id="JS调用c-方法"><a href="#JS调用c-方法" class="headerlink" title="JS调用c#方法"></a>JS调用c#方法</h4><p>html中添加按钮,按钮处理事件</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-cn&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>数据监视<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;background-color:orange&quot;</span> <span class="attr">id</span>=<span class="string">&quot;data&quot;</span>&gt;</span>默认数据显示<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;window.external.JsMessage(&#x27;Hello 中文&#x27;)&quot;</span>&gt;</span>点击执行c#逻辑(JS调用C#方法)<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>xaml.cs后台文件中:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">MainWindow</span> : <span class="title">Window</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainWindow</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        InitializeComponent();</span><br><span class="line">        <span class="comment">//为浏览器控件准备可调用的对象实例</span></span><br><span class="line">        browser.ObjectForScripting = <span class="keyword">new</span> ScriptContext();</span><br><span class="line">        <span class="comment">//加载资源到页面</span></span><br><span class="line">        Uri uri = <span class="keyword">new</span> Uri(<span class="string">&quot;pack://application:,,,/wpfWebbrowser;component/Assets/Monitor.html&quot;</span>,</span><br><span class="line">        UriKind.RelativeOrAbsolute);</span><br><span class="line">        Stream src = Application.GetResourceStream(uri).Stream;</span><br><span class="line">        browser.NavigateToStream(src);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给他更高权限</span></span><br><span class="line">[<span class="meta">PermissionSet(SecurityAction.Demand, Name = <span class="string">&quot;FullTrust&quot;</span>)</span>]</span><br><span class="line"><span class="comment">//关联技术基于com</span></span><br><span class="line">[<span class="meta">ComVisible(true)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ScriptContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 这个方法将由JS调用,调用时传递一个参数进来</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;message&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">JsMessage</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        MessageBox.Show(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="C-调用JS方法"><a href="#C-调用JS方法" class="headerlink" title="C#调用JS方法"></a>C#调用JS方法</h4><p>html中添加js方法:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-cn&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>数据监视<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//准备一个方法给C#调用</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">CSharpMsg</span>(<span class="params">msg</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;data&quot;</span>).<span class="property">innerHTML</span> = msg;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;background-color:orange&quot;</span> <span class="attr">id</span>=<span class="string">&quot;data&quot;</span>&gt;</span>默认数据显示<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;window.external.JsMessage(&#x27;Hello 中文&#x27;)&quot;</span>&gt;</span>点击执行c#逻辑(JS调用C#方法)<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在viewmodel中演示:</p>
<p>viewmodel中:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绑定Loaded事件 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExecuteLoadedCommand</span>()</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">var</span> browser = FindChild&lt;WebBrowser&gt;(System.Windows.Application.Current.MainWindow, <span class="string">&quot;browser&quot;</span>);</span><br><span class="line">     Task.Run(<span class="keyword">async</span> () =&gt;</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">await</span> Task.Delay(<span class="number">500</span>);</span><br><span class="line">             <span class="keyword">var</span> v = <span class="keyword">new</span> Random().Next(<span class="number">10</span>, <span class="number">1090</span>);</span><br><span class="line">               <span class="comment">//定义调用的js方法</span></span><br><span class="line">             <span class="keyword">var</span> jsCode = <span class="string">$&quot;CSharpMsg(&#x27;<span class="subst">&#123;v&#125;</span>&#x27;)&quot;</span>;</span><br><span class="line">               <span class="comment">//因为在子线程中,所以要由ui线程调用</span></span><br><span class="line">             Application.Current.Dispatcher.Invoke(() =&gt;</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="keyword">try</span></span><br><span class="line">                 &#123;</span><br><span class="line">                   <span class="comment">//下面语句与Winform的WebBrowser有区别</span></span><br><span class="line">                     browser.InvokeScript(<span class="string">&quot;execScript&quot;</span>, <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; jsCode, <span class="string">&quot;JavaScript&quot;</span> &#125;);<span class="comment">//调用js方法</span></span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">                 &#123;</span><br><span class="line">                     Debug.WriteLine(ex);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="http服务器方式"><a href="#http服务器方式" class="headerlink" title="http服务器方式"></a>http服务器方式</h3><p>上面通过资源加载html的方式有个很大的弊端,就是html无法加载单独的js代码</p>
<p>解决方案,就是程序开启一个http服务器,通过http服务器加载http,js,css这一套网页,WebBrowser控件通过本地链接绑定到本地页面上,就不需要通过资源加载的方式进行</p>
<p>这也是为什么WebBroser用的少的原因,要真正做好的话还得使用web服务器,<a href="#WebView2">WebView2</a>就是解决这个问题的</p>
<h2 id="WebView2"><a href="#WebView2" class="headerlink" title="WebView2"></a>WebView2</h2><p>不存在WebView,上来就是WebView2</p>
<p><strong>基于</strong>：<code>WebView2</code> 是 Windows 10 及更高版本中引入的控件，基于 Microsoft Edge（Chromium）。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>支持现代网页技术，性能较好。</li>
<li>提供了更好的安全性和稳定性。</li>
<li>可以使用 UWP API，适合开发现代应用程序。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>仅适用于 Windows 10 和更高版本。</li>
<li>需要额外的设置和配置，可能比 <code>WebBrowser</code> 更复杂。</li>
</ul>
<p>使用需要引入库: Microsoft.Web.WebView2</p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/microsoft-edge/webview2/">官方文档</a></p>
<p>xaml中引入命名空间</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等于号后输入WebView2,自动补全</span></span><br><span class="line"><span class="comment">//wpf中用这个</span></span><br><span class="line">xmlns:wv =<span class="string">&quot;clr-namespace:Microsoft.Web.WebView2.Wpf;assembly=Microsoft.Web.WebView2.Wpf&quot;</span></span><br><span class="line"><span class="comment">//winform中用这个</span></span><br><span class="line">xmlns:wv=<span class="string">&quot;clr-namespace:Microsoft.Web.WebView2.WinForms;assembly=Microsoft.Web.WebView2.WinForms&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="显示相关-1"><a href="#显示相关-1" class="headerlink" title="显示相关"></a>显示相关</h3><p><strong>显示外部链接</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;wv:WebView2 Source=&quot;http://www.bing.com&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p><strong>显示本地网页</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;wv:WebView2 Name=&quot;webView&quot; Source=&quot;&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>xaml后台文件  (注意 <code>Monitor.html</code>文件要设置为始终复制)</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> src = <span class="string">$&quot;file:///<span class="subst">&#123;Environment.CurrentDirectory&#125;</span>/Assets/Htmls/Monitor.html&quot;</span>;</span><br><span class="line"><span class="keyword">this</span>.webView.Source = <span class="keyword">new</span> Uri(src);</span><br></pre></td></tr></table></figure>

<p>比资源加载好在当更新html的时候,不需要更新程序,直接更新html就可以了</p>
<h3 id="C-到JS数据传递"><a href="#C-到JS数据传递" class="headerlink" title="C#到JS数据传递"></a>C#到JS数据传递</h3><p>有两种方式</p>
<ul>
<li>执行js方法(也能通过参数传递信息)</li>
<li>传递数据</li>
</ul>
<p>c#方</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行js方法</span></span><br><span class="line">webView.CoreWebView2.ExecuteScriptAsync(<span class="string">&quot;CSharpMsg(&#x27;hello 中文&#x27;)&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将123abc发送到webview控件中,除了string信息,也支持json数据</span></span><br><span class="line">webView.CoreWebView2.PostWebMessageAsString(<span class="string">&quot;123abc&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>html文件</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//准备一个方法给C#调用</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">CSharpMsg</span>(<span class="params">msg</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;data&quot;</span>).<span class="property">innerHTML</span> = msg;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//监听传上来的信息(除了string,也支持json传递)</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="property">chrome</span>.<span class="property">webview</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;message&quot;</span>, <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//传上来的是一个对象,要用.data取其中的值</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;data&quot;</span>).<span class="property">innerHTML</span> = data.<span class="property">data</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="JS调用C-方法"><a href="#JS调用C-方法" class="headerlink" title="JS调用C#方法"></a>JS调用C#方法</h3><p>xaml.cs后台文件</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MainWindow</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    InitializeComponent();</span><br><span class="line">    <span class="comment">//比资源加载好在当更新html的时候,不需要更新程序,直接更新html就可以了</span></span><br><span class="line">    <span class="keyword">var</span> src = <span class="string">$&quot;file:///<span class="subst">&#123;Environment.CurrentDirectory&#125;</span>/Assets/Htmls/Monitor.html&quot;</span>;</span><br><span class="line">    <span class="keyword">this</span>.webView.Source = <span class="keyword">new</span> Uri(src);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得在初始化完成的事件中才能将要被js调用的C#方法传递给wenView2控件</span></span><br><span class="line">    <span class="keyword">this</span>.webView.CoreWebView2InitializationCompleted += WebView_CoreWebView2InitializationCompleted;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//wenView完成后才会回调的方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">WebView_CoreWebView2InitializationCompleted</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//将要被js调用的C#方法传递给wenView2控件</span></span><br><span class="line">    webView.CoreWebView2.AddHostObjectToScript(<span class="string">&quot;csobj&quot;</span>, <span class="keyword">new</span> ScriptContext());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>html</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;window.chrome.webview.hostObjects.csobj.JsMessage(&#x27;hello&#x27;)&quot;</span>&gt;</span>点击执行c#逻辑(JS调用C#方法)<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意html中出现的csobj就是xaml.cs后台文件中的csobj</p>
<h4 id="获取返回值"><a href="#获取返回值" class="headerlink" title="获取返回值"></a>获取返回值</h4><blockquote>
<p>上面的方法js向c#请求数据会比较麻烦,因为需要两个处理传递(请求传过去,结果传回来),能获得返回值的话,也就可以一次处理完成</p>
</blockquote>
<p>js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myFunc</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//使用then来取返回值</span></span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">chrome</span>.<span class="property">webview</span>.<span class="property">hostObjects</span>.<span class="property">csobj</span>.<span class="title class_">GetData</span>().<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;data&quot;</span>).<span class="property">innerHTML</span> = data;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>html</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;myFunc()&quot;</span>&gt;</span>调用c#方法并接收返回值<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>c#</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">MainWindow</span> : <span class="title">Window</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainWindow</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        InitializeComponent();</span><br><span class="line">        <span class="comment">//比资源加载好在当更新html的时候,不需要更新程序,直接更新html就可以了</span></span><br><span class="line">        <span class="keyword">var</span> src = <span class="string">$&quot;file:///<span class="subst">&#123;Environment.CurrentDirectory&#125;</span>/Assets/Htmls/Monitor.html&quot;</span>;</span><br><span class="line">        <span class="keyword">this</span>.webView.Source = <span class="keyword">new</span> Uri(src);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得在初始化完成的事件中才能将要被js调用的C#方法传递给wenView2控件</span></span><br><span class="line">        <span class="keyword">this</span>.webView.CoreWebView2InitializationCompleted += WebView_CoreWebView2InitializationCompleted;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//wenView完成后才会回调的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">WebView_CoreWebView2InitializationCompleted</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将要被js调用的C#方法传递给wenView2控件</span></span><br><span class="line">        webView.CoreWebView2.AddHostObjectToScript(<span class="string">&quot;csobj&quot;</span>, <span class="keyword">new</span> ScriptContext());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给他更高权限</span></span><br><span class="line">[<span class="meta">PermissionSet(SecurityAction.Demand, Name = <span class="string">&quot;FullTrust&quot;</span>)</span>]</span><br><span class="line"><span class="comment">//关联技术基于com</span></span><br><span class="line">[<span class="meta">ComVisible(true)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ScriptContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetData</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;c#返回的信息&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="网页加载时-JavaScript-代码"><a href="#网页加载时-JavaScript-代码" class="headerlink" title="网页加载时 JavaScript 代码"></a>网页加载时 JavaScript 代码</h3><p><code>AddScriptToExecuteOnDocumentCreatedAsync</code> 方法非常强大，可以帮助开发者在网页加载时注入自定义的 JavaScript 代码，从而实现各种功能和效果。如</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以直接创建一个JS语句来在文档创建时执行</span></span><br><span class="line"><span class="built_in">string</span> script = <span class="string">&quot;console.log(&#x27;Document created!&#x27;);&quot;</span>;</span><br><span class="line">webView.CoreWebView2.AddScriptToExecuteOnDocumentCreatedAsync(script);</span><br></pre></td></tr></table></figure>

<p>也得在WebView初始化完成的事件中才能被正确执行</p>
<h2 id="CefSharp"><a href="#CefSharp" class="headerlink" title="CefSharp"></a>CefSharp</h2><p><strong>基于</strong>：CefSharp 是一个基于 Chromium Embedded Framework (CEF) 的开源项目。</p>
<p>按照github文档内容: 使用时需要保留版权声明</p>
<p><a target="_blank" rel="noopener" href="https://github.com/cefsharp/CefSharp">开源项目地址</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/cefsharp/CefSharp/wiki/CefSharp%E4%B8%AD%E6%96%87%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3">中文帮助文档</a></p>
<p>Electron包一层的方式进行HTML的包装</p>
<blockquote>
<p>Chromium Embedded Framework（CEF）是一个开源项目，允许开发者将 Chromium 浏览器的功能嵌入到其他应用程序中。CEF 提供了一个简单的 API，使得在桌面应用程序中使用 Web 技术（如 HTML、JavaScript 和 CSS）变得更加容易。</p>
<p>CEF(C++)在github上开源免费    功能上与chrome是同步的</p>
<p>Chromium Embedded Framework 是一个强大的工具，允许开发者在其应用程序中嵌入现代网页技术，提供丰富的用户体验</p>
</blockquote>
<p><strong>优点</strong>：</p>
<ul>
<li>支持现代网页技术，性能优越。</li>
<li>可以自定义浏览器的行为，功能强大。</li>
<li>可以处理复杂的网页和应用程序，适合需要高性能和高兼容性的场景。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>相比于 <code>WebBrowser</code> 和 <code>WebView</code>，集成和使用相对复杂。</li>
<li>需要额外的 NuGet 包和依赖项，增加了项目的复杂性。</li>
<li>包体积较大，可能影响应用程序的大小。</li>
</ul>
<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>下面的流程适用于.Net5.0或更高版本,参考的是<a target="_blank" rel="noopener" href="https://github.com/cefsharp/CefSharp/wiki/Quick-Start-For-MS-.Net-5.0-or-greater">此链接</a></p>
<ol>
<li>通过Nuget安装，右击项目 -&gt; 管理Nuget程序包 -&gt; 在打开的界面中搜索CefSharp，依次安装 <code>CefSharp.Wpf.NETCore</code></li>
<li>因为CefSharp不支持ANYCPU所以要配置x86、x64，点击菜单生成 -&gt; 配置管理器。选择解决方案平台，点击编辑，先将x64和x86删掉，再重新新建，重新配置比较容易些。</li>
</ol>
<p>添加命名空间如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlns:cs=&quot;clr-namespace:CefSharp.Wpf;assembly=CefSharp.Wpf&quot;</span><br></pre></td></tr></table></figure>

<h3 id="显示相关-2"><a href="#显示相关-2" class="headerlink" title="显示相关"></a>显示相关</h3><p><code>cs:ChromiumWebBrowser</code>: 这个控件放置不会占用空间,只有绘制先后的顺序,因此可以直接在其上绘制控件</p>
<h4 id="显示外部链接"><a href="#显示外部链接" class="headerlink" title="显示外部链接"></a>显示外部链接</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;cs:ChromiumWebBrowser Name=&quot;browser&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>xaml.cs后台文件如下:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">browser.Load(<span class="string">&quot;http://www.baidu.com&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="显示本地html文件"><a href="#显示本地html文件" class="headerlink" title="显示本地html文件"></a>显示本地html文件</h4><p>要显示的html文件一定要设置<strong>复制到输出目录</strong>为<strong>始终复制</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;cs:ChromiumWebBrowser Name=&quot;browser&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>xaml.cs后台文件如下:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> file = <span class="string">$&quot;<span class="subst">&#123;Environment.CurrentDirectory&#125;</span>/Assets/Htmls/Monitor.html&quot;</span>;</span><br><span class="line">browser.Load(file);</span><br></pre></td></tr></table></figure>

<h3 id="C-调用JS方法-1"><a href="#C-调用JS方法-1" class="headerlink" title="C#调用JS方法"></a>C#调用JS方法</h3><p>html</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//准备一个方法给C#调用</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">CSharpMsg</span>(<span class="params">msg</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;data&quot;</span>).<span class="property">innerHTML</span> = msg;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>调用js方法代码</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//调用js代码  CSharpMsg是js方法</span></span><br><span class="line"> browser.ExecuteScriptAsync(<span class="string">&quot;CSharpMsg(&#x27;C#执行ExecuteScriptAsync&#x27;)&quot;</span>);</span><br><span class="line"><span class="comment">//注意UI线程执行</span></span><br></pre></td></tr></table></figure>

<h4 id="显示控制台"><a href="#显示控制台" class="headerlink" title="显示控制台"></a>显示控制台</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">browser.ShowDevTools();</span><br></pre></td></tr></table></figure>

<h3 id="JS调用C-方法-1"><a href="#JS调用C-方法-1" class="headerlink" title="JS调用C#方法"></a>JS调用C#方法</h3><p>在 .Net 中注册对象有两种选择，第一个是提前注册的，这通常是在创建 ChromiumWebBrowser 实例后立即完成的。第二个选项更灵活，并允许在需要时解决对象。</p>
<p>第二个方案试验不成功</p>
<h4 id="第一个方案"><a href="#第一个方案" class="headerlink" title="第一个方案"></a>第一个方案</h4><p>这个方案必须在创建浏览控件之前注册提供给js调用的类</p>
<p>html</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;window.zeroko.JsMessage(&#x27;你好,世界!&#x27;)&quot;</span>&gt;</span>点击执行c#逻辑(JS调用C#方法)<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>xaml.cs后台</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//必须在创建browser之前注册 ,个人理解:xaml定义的浏览器控件不能使用这种方法</span></span><br><span class="line">browser.JavascriptObjectRepository.Settings.LegacyBindingEnabled = <span class="literal">true</span>;</span><br><span class="line"> browser.JavascriptObjectRepository.Register(<span class="string">&quot;zeroko&quot;</span>, <span class="keyword">new</span> scriptContext());<span class="comment">//这里的zeroko就是在html中的window.zeroko的zeroko</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//新建类</span></span><br><span class="line">  <span class="comment">//供JS调用的C#方法集合</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">scriptContext</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">//无返回值的</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">JsMessage</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          Application.Current.Dispatcher.Invoke(() =&gt;</span><br><span class="line">          &#123;</span><br><span class="line">              MessageBox.Show(message);</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//带返回值的</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetData</span>()</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;C#返回的信息&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="第二个方案"><a href="#第二个方案" class="headerlink" title="第二个方案"></a>第二个方案</h4><p><a target="_blank" rel="noopener" href="https://github.com/cefsharp/CefSharp/wiki/General-Usage#3-how-do-you-expose-a-net-class-to-javascript">略,参考该链接</a></p>
<h2 id="现有程序迁移到WEB端"><a href="#现有程序迁移到WEB端" class="headerlink" title="现有程序迁移到WEB端"></a>现有程序迁移到WEB端</h2><p><a target="_blank" rel="noopener" href="https://platform.uno/docs/articles/get-started.html?tabs=windows">UNO平台</a></p>
<h1 id="wpf与winform控件互相使用"><a href="#wpf与winform控件互相使用" class="headerlink" title="wpf与winform控件互相使用"></a>wpf与winform控件互相使用</h1><ul>
<li>winform可以通过 <code>ElementHost</code>使用wpf控件</li>
<li>wpf可以通过 <code>WindowsFormsHost</code>使用winform控件</li>
</ul>
<h1 id="捕获全局异常"><a href="#捕获全局异常" class="headerlink" title="捕获全局异常"></a>捕获全局异常</h1><ul>
<li><p><strong>UI线程未捕获异常（DispatcherUnhandledException）</strong>：</p>
<p>默认情况下，Windows Presentation Foundation捕获未经处理的异常，从对话框中通知用户异常 (，他们可以从该对话框中报告异常) ，并自动关闭应用程序。</p>
<p>这是WPF和WinForms等UI框架特有的机制，它会在UI线程上捕获未处理的异常。如果async void方法是由UI线程的事件触发的，异常会被传播到UI线程，最终由DispatcherUnhandledException捕获。</p>
<p><strong>可以取消应用程序终止</strong>：通过设置 DispatcherUnhandledExceptionEventArgs.Handled &#x3D; true，可以防止应用程序崩溃并处理异常。</p>
</li>
<li><p><strong>非UI线程未捕获异常（AppDomain.UnhandledException）</strong>：</p>
<p>AppDomain.UnhandledException 是 .NET 框架中全局异常处理的机制，用于捕获大部分 <strong>未处理的异常</strong>，无论它们来自 UI 线程还是后台线程。此机制适用于 <strong>整个应用程序域（AppDomain）</strong>，无论是同步代码还是异步代码中的异常，只要没有在代码中捕获处理，它们都会触发该事件。</p>
<p><strong>应用程序仍会崩溃</strong>：虽然该事件能捕获异常并进行日志记录或其他操作，但应用程序通常仍然会崩溃，因为 UnhandledException 事件仅用于通知，而不能阻止应用崩溃。</p>
</li>
<li><p><strong>未观察到的任务异常（TaskScheduler.UnobservedTaskException）</strong>：</p>
<p>默认不会终止程序</p>
<p>TaskScheduler.UnobservedTaskException 是用于处理 <strong>异步任务（Task）</strong> 中未观察到的异常。如果你使用 async&#x2F;await 或 Task，当异步操作抛出异常且未被处理时，该异常会触发 UnobservedTaskException 事件</p>
<p>虽然这个机制对async void没有直接帮助，但它在处理async Task时非常有效。当任务出现异常并未被观察（即没有await或.ContinueWith捕获异常），该异常会被标记为未观察到的任务异常，进而触发TaskScheduler.UnobservedTaskException。这提供了一层额外的保护，确保在特定情况下未捕获的Task异常不会引发崩溃。</p>
<p><strong>仅适用于异步任务中的异常</strong>：用于处理异步代码中未被观察的异常。</p>
<p><strong>可以避免应用崩溃</strong>：通过 <code>e.SetObserved(); // 标记异常为已观察，防止崩溃</code>，可以防止由于未观察到的任务异常导致的应用程序崩溃。</p>
<p><strong>垃圾回收前触发</strong>：UnobservedTaskException 事件会在垃圾回收（GC）过程中触发，如果该异常仍然没有被处理，那么应用程序会终止。</p>
</li>
</ul>
<p>下面是App.xaml.cs:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> Window <span class="title">CreateShell</span>()</span></span><br><span class="line"> &#123;</span><br><span class="line">     LogGlobalException();<span class="comment">//wpf框架中注册全局异常捕获</span></span><br><span class="line">     <span class="keyword">return</span> Container.Resolve&lt;Shell&gt;();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">LogGlobalException</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//UI线程未捕获异常处理事件</span></span><br><span class="line">    <span class="keyword">this</span>.DispatcherUnhandledException += OnDispatcherUnhandledException;</span><br><span class="line">    <span class="comment">//Task线程内未捕获异常处理事件</span></span><br><span class="line">    TaskScheduler.UnobservedTaskException += OnUnobservedTaskException;</span><br><span class="line">    <span class="comment">//多线程异常</span></span><br><span class="line">    AppDomain.CurrentDomain.UnhandledException += OnUnhandledException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDispatcherUnhandledException</span>(<span class="params"><span class="built_in">object</span> sender, System.Windows.Threading.DispatcherUnhandledExceptionEventArgs e</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line">     LogException(<span class="string">&quot;DispatcherUnhandledException&quot;</span>, e.Exception);</span><br><span class="line">     e.Handled = <span class="literal">true</span>; <span class="comment">// 防止程序闪退</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnUnobservedTaskException</span>(<span class="params"><span class="built_in">object</span> sender, UnobservedTaskExceptionEventArgs e</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line">     LogException(<span class="string">&quot;UnobservedTaskException&quot;</span>, e.Exception);</span><br><span class="line">     e.SetObserved(); <span class="comment">// 标记异常为已观察</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnUnhandledException</span>(<span class="params"><span class="built_in">object</span> sender, UnhandledExceptionEventArgs e</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line">     Exception ex = (Exception)e.ExceptionObject;</span><br><span class="line">      LogException(<span class="string">&quot;UnhandledException&quot;</span>, ex);</span><br><span class="line">     <span class="comment">// Generate dump file</span></span><br><span class="line">     <span class="comment">// MiniDump.TryDump($&quot;dumps\\Wemail_&#123;DateTime.Now:HH-mm-ss-ms&#125;.dmp&quot;);</span></span><br><span class="line">    <span class="keyword">if</span> (e.IsTerminating) <span class="comment">// 判断是否会导致程序终止</span></span><br><span class="line">    &#123;</span><br><span class="line">     <span class="comment">//可以生成dump文件 </span></span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">LogException</span>(<span class="params"><span class="built_in">string</span> exceptionType, Exception ex</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">var</span> exceptionDetails = GetExceptionDetails(ex);</span><br><span class="line">     _logger.LogCritical(<span class="string">$&quot;[<span class="subst">&#123;exceptionType&#125;</span>]<span class="subst">&#123;exceptionDetails&#125;</span>&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="built_in">string</span> <span class="title">GetExceptionDetails</span>(<span class="params">Exception ex</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">var</span> details = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">     <span class="keyword">while</span> (ex != <span class="literal">null</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         details.AppendLine(<span class="string">$&quot;异常信息：<span class="subst">&#123;ex.Message&#125;</span>&quot;</span>);</span><br><span class="line">         details.AppendLine(<span class="string">$&quot;来自：<span class="subst">&#123;ex.Source&#125;</span>&quot;</span>);</span><br><span class="line">         details.AppendLine(<span class="string">$&quot;调用堆栈：\n<span class="subst">&#123;ex.StackTrace&#125;</span>&quot;</span>);</span><br><span class="line">         ex = ex.InnerException;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> details.ToString();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>async void方法的异常会直接传播到调用它的线程，而不会像async Task那样生成一个可等待的任务。因此，async void方法中的异常不会触发TaskScheduler.UnobservedTaskException或Application.DispatcherUnhandledException这些传统的全局异常捕获机制</p>
</blockquote>
<p>测试案例</p>
<p>未添加任何防闪退代码情况下:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">ui线程中触发除零异常 导致了  <span class="comment">//DispatcherUnhandledException  -&gt;  UnhandledException  --&gt;  VS中断</span></span><br><span class="line"></span><br><span class="line">Task.Run(()=&gt;&#123;触发除零异常&#125;);  <span class="comment">//UnobservedTaskException</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">async</span> <span class="keyword">void</span> <span class="title">test</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">await</span> Task.Run(()=&gt;&#123;触发除零异常&#125;);  <span class="comment">//DispatcherUnhandledException  -&gt;  UnhandledException  --&gt;  VS中断</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread th1 = <span class="keyword">new</span> Thread(() =&gt;&#123;触发除零异常&#125;);th1.Start();    <span class="comment">//UnhandledException --&gt;  VS中断</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">async</span> <span class="keyword">void</span> <span class="title">test</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">await</span> Task.Delay(<span class="number">100</span>).ConfigureAwait(<span class="literal">false</span>);</span><br><span class="line">    触发除零异常</span><br><span class="line">&#125;</span><br><span class="line">test()  <span class="comment">//DispatcherUnhandledException  -&gt;  UnhandledException  --&gt;  VS中断</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">async</span> Task <span class="title">test</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">await</span> Task.Delay(<span class="number">100</span>).ConfigureAwait(<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">int</span> b = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">int</span> a = <span class="number">3</span> / b;</span><br><span class="line">&#125;</span><br><span class="line"> Task.Run(<span class="keyword">async</span> () =&gt; &#123; <span class="keyword">await</span> test(); &#125;);   <span class="comment">//UnobservedTaskException</span></span><br><span class="line"></span><br><span class="line">prism框架中的事件聚合器回调体中直接除零异常       <span class="comment">//DispatcherUnhandledException  -&gt;  UnhandledException  --&gt;  VS中断</span></span><br></pre></td></tr></table></figure>

<p>也许只有Task并且使用了await承接,并且整个调用链上都没有async void才能真正触发UnobservedTaskException</p>
<p>如果DispatcherUnhandledException中使用e.Handled&#x3D;true 则只会触发DispatcherUnhandledException,后续触发,包括vs中断都不会发生</p>
<blockquote>
<p>作为对比,在控制台的全局未捕获异常:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 订阅全局未处理异常事件(在main中)</span></span><br><span class="line">AppDomain.CurrentDomain.UnhandledException += CurrentDomain_UnhandledException;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CurrentDomain_UnhandledException</span>(<span class="params"><span class="built_in">object</span> sender, UnhandledExceptionEventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理未处理的异常</span></span><br><span class="line">    Exception ex = (Exception)e.ExceptionObject;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;捕获到未处理的异常: <span class="subst">&#123;ex.Message&#125;</span>&quot;</span>);</span><br><span class="line">    <span class="comment">// 可以在这里添加更多的日志记录或清理操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但要注意:</p>
<p><code>AppDomain.CurrentDomain.UnhandledException</code> 只能捕获在主线程和其他非 UI 线程中未被捕获的异常。如果在新线程中发生异常而没有适当的捕获机制，这些异常将不会被全局异常处理程序捕获。</p>
<p>在新线程中，你应该使用 <code>try-catch</code> 结构来捕获可能发生的异常</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建并启动新线程</span></span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> b = <span class="number">3</span> / a; <span class="comment">// 这里将引发除零异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;捕获到线程中的异常: <span class="subst">&#123;ex.Message&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="无法全局捕获的异常"><a href="#无法全局捕获的异常" class="headerlink" title="无法全局捕获的异常"></a>无法全局捕获的异常</h2><p>除了栈溢出（StackOverflowException）之外，还有一些其他类型的异常也是不允许捕获和处理的，<strong>直接导致进程闪退，无法被全局异常捕获机制捕获</strong>。这些异常包括：</p>
<ol>
<li><strong>OutOfMemoryException</strong>：当程序尝试分配的内存超过可用内存时，会抛出OutOfMemoryException。这个异常通常无法被捕获，因为没有足够的内存来执行异常处理代码。</li>
<li><strong>AccessViolationException</strong>：当程序尝试访问无效的内存地址时，会抛出AccessViolationException。这个异常通常无法被捕获，因为它会导致进程崩溃。</li>
<li><strong>NullReferenceException</strong>（在某些情况下）：当程序尝试访问空引用时，会抛出NullReferenceException。在某些情况下， NullReferenceException可能无法被捕获，例如当异常发生在系统调用期间。</li>
<li><strong>SEHException</strong>（结构化异常处理异常）：SEHException是Windows特有的异常类型，当程序发生结构化异常处理异常时，会抛出SEHException。这个异常通常无法被捕获，因为它会导致进程崩溃。</li>
<li><strong>CorruptedStateException</strong>：(损坏状态异常)当程序的状态已经被破坏：当程序的状态已经被破坏时，会抛出CorruptedStateException。这个异常通常无法被捕获，因为程序的状态已经不可恢复。</li>
<li><strong>ExecutionEngineException</strong>：当程序的执行引擎发生异常时，会抛出ExecutionEngineException。这个异常通常无法被捕获，因为它会导致进程崩溃。</li>
<li><strong>InvalidProgramException</strong>：当程序的代码不正确或被破坏时，会抛出InvalidProgramException。这个异常通常无法被捕获，因为程序的代码已经不可恢复。</li>
<li><strong>FatalExecutionEngineError</strong>：当程序的执行引擎发生致命错误时，会抛出FatalExecutionEngineError。这个异常通常无法被捕获，因为它会导致进程崩溃。</li>
</ol>
<p>请注意，这些异常通常是由于程序的错误或系统级别的问题引起的，而不是由于异常处理机制的缺陷。因此，应该重点关注程序的错误和系统级别的问题，而不是尝试捕获和处理这些异常。</p>
<h1 id="快捷键相关"><a href="#快捷键相关" class="headerlink" title="快捷键相关"></a>快捷键相关</h1><h2 id="程序内快捷键"><a href="#程序内快捷键" class="headerlink" title="程序内快捷键"></a>程序内快捷键</h2><p>使用KeyDown和KeyUp事件</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.KeyDown += MainWindow_KeyDown;</span><br><span class="line"><span class="keyword">this</span>.KeyUp += MainWindow_KeyUp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">bool</span> isHotKeyPressed &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125; = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">MainWindow_KeyDown</span>(<span class="params"><span class="built_in">object</span> sender, KeyEventArgs e</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">if</span> ((e.Key == Key.LeftCtrl || e.Key == Key.RightCtrl) &amp;&amp; !isHotKeyPressed)</span><br><span class="line">     &#123;</span><br><span class="line">         isHotKeyPressed = <span class="literal">true</span>;</span><br><span class="line">         <span class="comment">//按下ctrl时执行的操作</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">MainWindow_KeyUp</span>(<span class="params"><span class="built_in">object</span> sender, KeyEventArgs e</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">if</span> (e.Key == Key.LeftCtrl || e.Key == Key.RightCtrl)</span><br><span class="line">     &#123;</span><br><span class="line">         isHotKeyPressed = <span class="literal">false</span>;</span><br><span class="line">         <span class="comment">//放开ctrl时执行的操作</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h1 id="值得记录的代码"><a href="#值得记录的代码" class="headerlink" title="值得记录的代码"></a>值得记录的代码</h1><h2 id="TextBox切换输入与绑定模式"><a href="#TextBox切换输入与绑定模式" class="headerlink" title="TextBox切换输入与绑定模式"></a>TextBox切换输入与绑定模式</h2><p>下面介绍:通过一系列的绑定、触发器和命令来实现既能显示绑定值的变化，又能让用户编辑的功能</p>
<p>默认显示状态:TextBox 默认显示的是通过 MultiBinding 绑定的值。这个值是只读的，用于显示当前的设置值。</p>
<p>进入编辑模式:</p>
<ul>
<li>当用户点击 TextBox 时，触发 PreviewMouseLeftButtonDown 事件。</li>
<li>这个事件执行 NewControlSetPointMouseEnterCommand 命令，传入 “引出电源” 作为参数。在 ViewModel 中，这个命令执行以下操作：<ul>
<li>当 TBoxExtractPowerControlVisibility 变为 Visible 时，触发 DataTrigger。</li>
<li>这个触发器改变 TextBox 的背景色，并将 Text 属性绑定到 NewExtractPowerControlSetPoint。</li>
<li>新的绑定是双向的（Mode&#x3D;TwoWay），允许用户编辑值。</li>
</ul>
</li>
<li>编辑值：<br>用户可以直接在 TextBox 中编辑值。<br>由于绑定设置了 UpdateSourceTrigger&#x3D;PropertyChanged，每次文本变化都会更新 NewExtractPowerControlSetPoint 属性。</li>
<li>退出编辑模式：<ul>
<li>虽然在提供的代码中没有明确显示，但可能存在一个失去焦点或其他事件来触发编辑模式的结束。</li>
<li>这可能涉及将 TBoxExtractPowerControlVisibility 设置回 Collapsed 或 Hidden。</li>
</ul>
</li>
<li>保存编辑的值：<ul>
<li>PreviewMouseLeftButtonUp 事件触发 PowerTextBoxSelectionChangedCommand。</li>
<li>这个命令可能负责将编辑后的值保存或应用到实际的设置中。</li>
</ul>
</li>
</ul>
<p><strong>重点是使用一个标志位切换编辑模式和显示模式,编辑模式和显示模式分别绑定一套数据</strong></p>
<p>下面罗列一部分代码</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextBox x:Name=<span class="string">&quot;tb_Control_ExtractPower&quot;</span> Width=<span class="string">&quot;87&quot;</span> Height=<span class="string">&quot;36&quot;</span> TextAlignment=<span class="string">&quot;Center&quot;</span> VerticalAlignment=<span class="string">&quot;Center&quot;</span> Foreground=<span class="string">&quot;Blue&quot;</span> FontSize=<span class="string">&quot;14&quot;</span> Padding=<span class="string">&quot;-5,8,8,0&quot;</span>&gt;</span><br><span class="line">                                &lt;i:Interaction.Triggers&gt;</span><br><span class="line">                                    &lt;i:EventTrigger EventName=<span class="string">&quot;PreviewMouseLeftButtonDown&quot;</span>&gt;</span><br><span class="line">                                        &lt;i:InvokeCommandAction Command=<span class="string">&quot;&#123;Binding NewControlSetPointMouseEnterCommand&#125;&quot;</span> CommandParameter=<span class="string">&quot;引出电源&quot;</span>/&gt;</span><br><span class="line">                                    &lt;/i:EventTrigger&gt;</span><br><span class="line">                                    &lt;i:EventTrigger EventName=<span class="string">&quot;PreviewMouseLeftButtonUp&quot;</span>&gt;</span><br><span class="line">                                        &lt;prism:InvokeCommandAction Command=<span class="string">&quot;&#123;Binding PowerTextBoxSelectionChangedCommand&#125;&quot;</span> TriggerParameterPath=<span class="string">&quot;Source&quot;</span>/&gt;</span><br><span class="line">                                    &lt;/i:EventTrigger&gt;</span><br><span class="line">                                &lt;/i:Interaction.Triggers&gt;</span><br><span class="line">                                &lt;TextBox.Style&gt;</span><br><span class="line">                                    &lt;Style TargetType=<span class="string">&quot;TextBox&quot;</span> BasedOn=<span class="string">&quot;&#123;StaticResource TextBoxBaseBaseStyle&#125;&quot;</span>&gt;</span><br><span class="line">                                        &lt;Setter Property=<span class="string">&quot;Text&quot;</span>&gt;</span><br><span class="line">                                                      &lt;!--绑定的第一套数据,只读的,不可编辑的--&gt;</span><br><span class="line">                                            &lt;Setter.Value&gt;</span><br><span class="line">                                                &lt;MultiBinding Converter=<span class="string">&quot;&#123;StaticResource DisplayDataCvt&#125;&quot;</span>&gt;</span><br><span class="line">                                                    &lt;Binding Path=<span class="string">&quot;CombineDataProvider.UDPData.Model.ExtractPower.Port.ControlSet&quot;</span>/&gt;</span><br><span class="line">                                                    &lt;Binding Path=<span class="string">&quot;SystemConfigProvider.SoftwareConfig.ExtractPower.ControlConvertCoefficient&quot;</span>/&gt;</span><br><span class="line">                                                    &lt;Binding Path=<span class="string">&quot;SystemConfigProvider.SoftwareConfig.ExtractPower.ControlDigits&quot;</span>/&gt;</span><br><span class="line">                                                    &lt;Binding Path=<span class="string">&quot;SystemConfigProvider.SoftwareConfig.ExtractPower.IsControlScientificNotation&quot;</span>/&gt;</span><br><span class="line">                                                &lt;/MultiBinding&gt;</span><br><span class="line">                                            &lt;/Setter.Value&gt;</span><br><span class="line">                                        &lt;/Setter&gt;</span><br><span class="line">                                        &lt;Style.Triggers&gt;</span><br><span class="line">                                            &lt;DataTrigger Binding=<span class="string">&quot;&#123;Binding TBoxExtractPowerControlVisibility&#125;&quot;</span> Value=<span class="string">&quot;Visible&quot;</span>&gt;</span><br><span class="line">                                                &lt;Setter Property=<span class="string">&quot;Background&quot;</span> Value=<span class="string">&quot;#AEEA00&quot;</span>/&gt;</span><br><span class="line">                                                              &lt;!--绑定的可读写的数据--&gt;</span><br><span class="line">                                                &lt;Setter Property=<span class="string">&quot;Text&quot;</span> Value=<span class="string">&quot;&#123;Binding NewExtractPowerControlSetPoint,Mode=TwoWay,UpdateSourceTrigger=PropertyChanged&#125;&quot;</span>/&gt;</span><br><span class="line">                                            &lt;/DataTrigger&gt;</span><br><span class="line">                                        &lt;/Style.Triggers&gt;</span><br><span class="line">                                    &lt;/Style&gt;</span><br><span class="line">                                &lt;/TextBox.Style&gt;</span><br><span class="line">                            &lt;/TextBox&gt;</span><br></pre></td></tr></table></figure>

<h3 id="更好的方式"><a href="#更好的方式" class="headerlink" title="更好的方式"></a>更好的方式</h3><p>下面是更好的方法来实现 <code>TextBox</code> 的绑定切换，使代码更清晰、更易维护。以下是一些改进建议：</p>
<ol>
<li><strong>使用单一绑定源和转换器</strong>：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextBox Text=&quot;&#123;Binding TextBoxValue, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged, Converter=&#123;StaticResource TextBoxValueConverter&#125;&#125;&quot;&gt;</span><br><span class="line">        &lt;TextBox.Style&gt;</span><br><span class="line">            &lt;Style TargetType=&quot;TextBox&quot; BasedOn=&quot;&#123;StaticResource TextBoxBaseStyle&#125;&quot;&gt;</span><br><span class="line">                &lt;Style.Triggers&gt;</span><br><span class="line">                    &lt;DataTrigger Binding=&quot;&#123;Binding IsEditing&#125;&quot; Value=&quot;True&quot;&gt;</span><br><span class="line">                        &lt;Setter Property=&quot;Background&quot; Value=&quot;#AEEA00&quot;/&gt;</span><br><span class="line">                    &lt;/DataTrigger&gt;</span><br><span class="line">                &lt;/Style.Triggers&gt;</span><br><span class="line">            &lt;/Style&gt;</span><br><span class="line">        &lt;/TextBox.Style&gt;</span><br><span class="line">    &lt;/TextBox&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p><strong>在 ViewModel 中使用单一属性</strong>：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">string</span> _textBoxValue;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> TextBoxValue</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span> =&gt; _textBoxValue;</span><br><span class="line">    <span class="keyword">set</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (SetProperty(<span class="keyword">ref</span> _textBoxValue, <span class="keyword">value</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            UpdateUnderlyingValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">bool</span> _isEditing;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">bool</span> IsEditing</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span> =&gt; _isEditing;</span><br><span class="line">    <span class="keyword">set</span> =&gt; SetProperty(<span class="keyword">ref</span> _isEditing, <span class="keyword">value</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">UpdateUnderlyingValue</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (IsEditing)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 更新编辑值</span></span><br><span class="line">        NewExtractSuppPowerControlSetPoint = TextBoxValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 更新显示值</span></span><br><span class="line">        <span class="comment">// 可能需要进行格式转换</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>使用 <code>IValueConverter</code> 来处理显示和编辑值的转换</strong>：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TextBoxValueConverter</span> : <span class="title">IValueConverter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">Convert</span>(<span class="params"><span class="built_in">object</span> <span class="keyword">value</span>, Type targetType, <span class="built_in">object</span> parameter, CultureInfo culture</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 从底层值转换为显示值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">ConvertBack</span>(<span class="params"><span class="built_in">object</span> <span class="keyword">value</span>, Type targetType, <span class="built_in">object</span> parameter, CultureInfo culture</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 从编辑值转换为底层值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>使用命令来处理编辑模式的进入和退出</strong>：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> DelegateCommand _enterEditModeCommand;</span><br><span class="line"><span class="keyword">public</span> DelegateCommand EnterEditModeCommand =&gt;</span><br><span class="line">    _enterEditModeCommand ?? (_enterEditModeCommand = <span class="keyword">new</span> DelegateCommand(ExecuteEnterEditMode));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ExecuteEnterEditMode</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    IsEditing = <span class="literal">true</span>;</span><br><span class="line">    TextBoxValue = NewExtractSuppPowerControlSetPoint;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> DelegateCommand _exitEditModeCommand;</span><br><span class="line"><span class="keyword">public</span> DelegateCommand ExitEditModeCommand =&gt;</span><br><span class="line">    _exitEditModeCommand ?? (_exitExitEditModeCommand = <span class="keyword">new</span> DelegateCommand(ExecuteExitEditMode));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ExecuteExitEditMode</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    IsEditing = <span class="literal">false</span>;</span><br><span class="line">    UpdateUnderlyingValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>在 XAML 中使用这些命令</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextBox Text=&quot;&#123;Binding TextBoxValue, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged&#125;&quot;&gt;</span><br><span class="line">    &lt;i:Interaction.Triggers&gt;</span><br><span class="line">        &lt;i:EventTrigger EventName=&quot;GotFocus&quot;&gt;</span><br><span class="line">            &lt;i:InvokeCommandAction Command=&quot;&#123;Binding EnterEditModeCommand&#125;&quot;/&gt;</span><br><span class="line">        &lt;/i:EventTrigger&gt;</span><br><span class="line">        &lt;i:EventTrigger EventName=&quot;LostFocus&quot;&gt;</span><br><span class="line">            &lt;i:InvokeCommandAction Command=&quot;&#123;Binding ExitEditModeCommand&#125;&quot;/&gt;</span><br><span class="line">        &lt;/i:EventTrigger&gt;</span><br><span class="line">    &lt;/i:Interaction.Triggers&gt;</span><br><span class="line">&lt;/TextBox&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="这种方法的优点："><a href="#这种方法的优点：" class="headerlink" title="这种方法的优点："></a>这种方法的优点：</h3><ol>
<li>使用单一的绑定源，简化了 XAML。</li>
<li>将显示逻辑和编辑逻辑清晰地分开。</li>
<li>使用命令来处理模式切换，使逻辑更集中、更易于管理。</li>
<li>通过转换器处理值的转换，使代码更加灵活。</li>
<li>减少了对多个可见性属性的依赖。</li>
</ol>
<p>这种实现方式更符合 MVVM 模式，使代码更易于理解和维护，同时保持了原有功能的灵活性。</p>
<h1 id="一些技巧盘点"><a href="#一些技巧盘点" class="headerlink" title="一些技巧盘点"></a>一些技巧盘点</h1><p>自定义控件如果不设置background的值,默认的值是null,此时没有东西的位置是不可点击的</p>
<p>这个时候可以通过给Background属性设置为transparent,使自定义控件整个区域都是可命中区</p>
<p>控件的默认 Background 值为 null的情况下，那么只有在将鼠标悬停在图标上的时候才能点击。所以为了在控件的整个区域内启用点击事件，建议是将 Background 设置为透明。这样一来，点击控件的任何部分都能触发事件</p>
<h1 id="混淆工具-1"><a href="#混淆工具-1" class="headerlink" title="混淆工具"></a>混淆工具</h1><h2 id="obfuscar"><a href="#obfuscar" class="headerlink" title="obfuscar"></a>obfuscar</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/502009935">参考链接</a></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>使用该指令<code>dotnet tool install --global Obfuscar.GlobalTool</code>来安装</p>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>在根目录执行<code>obfuscar.console Obfuscar.xml</code>读取配置文件,进行保护</p>
<p>配置文件如下:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&#x27;1.0&#x27;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Obfuscator</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 输入的工作路径，采用如约定的 Windows 下的路径表示法，如以下表示当前工作路径 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 推荐使用当前工作路径，因为 DLL 的混淆过程，需要找到 DLL 的所有依赖。刚好当前工作路径下，基本都能满足条件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Var</span> <span class="attr">name</span>=<span class="string">&quot;InPath&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.&quot;</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 混淆之后的输出路径，如下面代码，设置为当前工作路径下的 Obfuscar 文件夹 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 混淆完成之后的新 DLL 将会存放在此文件夹里 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Var</span> <span class="attr">name</span>=<span class="string">&quot;OutPath&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.\Obfuscar&quot;</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 以下的都是细节的配置，配置如何进行混淆 --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 使用 KeepPublicApi 配置是否保持公开的 API 不进行混淆签名，如公开的类型公开的方法等等，就不进行混淆签名了 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 语法的写法就是 name 表示某个开关，而 value 表示值 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 对于大部分的库来说，设置公开的 API 不进行混淆是符合预期的 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Var</span> <span class="attr">name</span>=<span class="string">&quot;KeepPublicApi&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 设置 HidePrivateApi 为 true 表示，对于私有的 API 进行隐藏，隐藏也就是混淆的意思 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 可以通过后续的配置，设置混淆的方式，例如使用 ABC 字符替换，或者使用不可见的 Unicode 代替 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Var</span> <span class="attr">name</span>=<span class="string">&quot;HidePrivateApi&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 设置 HideStrings 为 true 可以设置是否将使用的字符串进行二次编码 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 由于进行二次编码，将会稍微伤一点点性能，二次编码需要在运行的时候，调用 Encoding 进行转换为字符串 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Var</span> <span class="attr">name</span>=<span class="string">&quot;HideStrings&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 设置 UseUnicodeNames 为 true 表示使用不可见的 Unicode 字符代替原有的命名，通过此配置，可以让反编译看到的类和命名空间和成员等内容都是不可见的字符 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Var</span> <span class="attr">name</span>=<span class="string">&quot;UseUnicodeNames&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 是否复用命名，设置为 true 的时候，将会复用命名，如在不同的类型里面，对字段进行混淆，那么不同的类型的字段可以是重名的 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 设置为 false 的时候，全局将不会有重复的命名 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Var</span> <span class="attr">name</span>=<span class="string">&quot;ReuseNames&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 配置是否需要重命名字段，默认配置了 HidePrivateApi 为 true 将都会打开重命名字段，因此这个配置的存在只是用来配置为 false 表示不要重命名字段 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Var</span> <span class="attr">name</span>=<span class="string">&quot;RenameFields&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 是否需要重新生成调试信息，生成 PDB 符号文件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Var</span> <span class="attr">name</span>=<span class="string">&quot;RegenerateDebugInfo&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 需要进行混淆的程序集，可以传入很多个，如传入一排排 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;Module file=&quot;$(InPath)\Lib1.dll&quot; /&gt; --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;Module file=&quot;$(InPath)\Lib2.dll&quot; /&gt; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Module</span> <span class="attr">file</span>=<span class="string">&quot;$(InPath)\HeenerholiCeleehano.dll&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 程序集的引用加载路径，对于 dotnet 6 应用，特别是 WPF 或 WinForms 项目，是需要特别指定引用加载路径的 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 这里有一个小的需要敲黑板的知识点，应该让 Microsoft.WindowsDesktop.App 放在 Microsoft.NETCore.App 之前 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 对于部分项目，如果没有找到如下顺序，将会在混淆过程中，将某些程序集解析为旧版本，从而失败 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">AssemblySearchPath</span> <span class="attr">path</span>=<span class="string">&quot;C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App\6.0.1\&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">AssemblySearchPath</span> <span class="attr">path</span>=<span class="string">&quot;C:\Program Files\dotnet\shared\Microsoft.NETCore.App\6.0.1\&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Obfuscator</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>还支持可以自己将混淆过程嵌入到构建过程里面，如此可以实现在开发阶段对混淆的结果进行调试。也就是开发时调试的 DLL 就是混淆过后的</p>
<h1 id="自定义可被观察容器"><a href="#自定义可被观察容器" class="headerlink" title="自定义可被观察容器"></a>自定义可被观察容器</h1><h2 id="ObservableDictionary"><a href="#ObservableDictionary" class="headerlink" title="ObservableDictionary"></a>ObservableDictionary</h2><p>在 WPF 中，标准的 <code>Dictionary&lt;TKey, TValue&gt;</code> 无法像 <code>ObservableCollection&lt;T&gt;</code> 一样自动通知界面更新，因为它未实现 <code>INotifyCollectionChanged</code> 和 <code>INotifyPropertyChanged</code> 接口</p>
<p>因此下面是一个自定义的ObservableDictionary</p>
<h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>继承<code>Dictionary&lt;TKey,TValue&gt;</code>或封装一个字典结构</p>
<p>实现<code>INotifyCollectionChanged</code>(集合结构变化时通知,如增删键值对)和<code>INotifyPropertyChanged</code>(字典整体替换时通知)</p>
<p>对字典值的修改(如<code>dict[key] = newValue</code>)需触发属性变更通知</p>
<blockquote>
<p>适用场景: 需要高效键值查找且动态更新值的场景</p>
</blockquote>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Specialized;</span><br><span class="line"><span class="keyword">using</span> System.ComponentModel;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Core.UI.CustomContainer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ObservableDictionary</span>&lt;<span class="title">TKey</span>, <span class="title">TValue</span>&gt; :</span><br><span class="line">   <span class="title">INotifyCollectionChanged</span>, <span class="title">INotifyPropertyChanged</span>,</span><br><span class="line">   <span class="title">IDictionary</span>&lt;<span class="title">TKey</span>, <span class="title">TValue</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> Dictionary&lt;TKey, TValue&gt; _innerDictionary = <span class="keyword">new</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Keys/Values返回类型改为ICollection&lt;T&gt;</span></span><br><span class="line">        <span class="keyword">public</span> ICollection&lt;TKey&gt; Keys =&gt; _innerDictionary.Keys;</span><br><span class="line">        <span class="keyword">public</span> ICollection&lt;TValue&gt; Values =&gt; _innerDictionary.Values;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> TValue <span class="keyword">this</span>[TKey key]</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span> =&gt; _innerDictionary[key];</span><br><span class="line">            <span class="keyword">set</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">bool</span> isUpdate = _innerDictionary.TryGetValue(key, <span class="keyword">out</span> <span class="keyword">var</span> oldValue);</span><br><span class="line">                _innerDictionary[key] = <span class="keyword">value</span>;</span><br><span class="line"></span><br><span class="line">                OnPropertyChanged(<span class="keyword">nameof</span>(Values));</span><br><span class="line">                OnPropertyChanged(<span class="keyword">nameof</span>(Keys));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">var</span> action = isUpdate ?</span><br><span class="line">                    NotifyCollectionChangedAction.Replace :</span><br><span class="line">                    NotifyCollectionChangedAction.Add;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 传递完整的参数</span></span><br><span class="line">                OnCollectionChanged(</span><br><span class="line">                    action: action,</span><br><span class="line">                    key: key,</span><br><span class="line">                    oldValue: isUpdate ? oldValue! : <span class="literal">default</span>,</span><br><span class="line">                    newValue: <span class="keyword">value</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">event</span> NotifyCollectionChangedEventHandler? CollectionChanged;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">event</span> PropertyChangedEventHandler? PropertyChanged;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重构通知方法</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnCollectionChanged</span>(<span class="params">NotifyCollectionChangedAction action</span>)</span> =&gt;</span><br><span class="line">            CollectionChanged?.Invoke(<span class="keyword">this</span>, <span class="keyword">new</span> NotifyCollectionChangedEventArgs(action));</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnCollectionChanged</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">            NotifyCollectionChangedAction action,</span></span></span><br><span class="line"><span class="params"><span class="function">            TKey key,</span></span></span><br><span class="line"><span class="params"><span class="function">            TValue oldValue,</span></span></span><br><span class="line"><span class="params"><span class="function">            TValue newValue</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> args = action <span class="keyword">switch</span></span><br><span class="line">            &#123;</span><br><span class="line">                NotifyCollectionChangedAction.Add =&gt;</span><br><span class="line">                    <span class="keyword">new</span> NotifyCollectionChangedEventArgs(</span><br><span class="line">                        action,</span><br><span class="line">                        <span class="keyword">new</span> KeyValuePair&lt;TKey, TValue&gt;(key, newValue)),</span><br><span class="line"></span><br><span class="line">                NotifyCollectionChangedAction.Replace =&gt;</span><br><span class="line">                    <span class="keyword">new</span> NotifyCollectionChangedEventArgs(</span><br><span class="line">                        action,</span><br><span class="line">                        <span class="keyword">new</span> KeyValuePair&lt;TKey, TValue&gt;(key, newValue),</span><br><span class="line">                        <span class="keyword">new</span> KeyValuePair&lt;TKey, TValue&gt;(key, oldValue)),</span><br><span class="line"></span><br><span class="line">                NotifyCollectionChangedAction.Remove =&gt;</span><br><span class="line">                    <span class="keyword">new</span> NotifyCollectionChangedEventArgs(</span><br><span class="line">                        action,</span><br><span class="line">                        <span class="keyword">new</span> KeyValuePair&lt;TKey, TValue&gt;(key, oldValue)),</span><br><span class="line"></span><br><span class="line">                _ =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> NotSupportedException()</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            CollectionChanged?.Invoke(<span class="keyword">this</span>, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnPropertyChanged</span>(<span class="params"><span class="built_in">string</span> propertyName</span>)</span> =&gt;</span><br><span class="line">            PropertyChanged?.Invoke(<span class="keyword">this</span>, <span class="keyword">new</span> PropertyChangedEventArgs(propertyName));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实现IDictionary接口</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params">TKey key, TValue <span class="keyword">value</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            _innerDictionary.Add(key, <span class="keyword">value</span>);</span><br><span class="line">            OnCollectionChanged(NotifyCollectionChangedAction.Add, key, <span class="literal">default</span>!, <span class="keyword">value</span>);</span><br><span class="line">            OnPropertyChanged(<span class="keyword">nameof</span>(Values));</span><br><span class="line">            OnPropertyChanged(<span class="keyword">nameof</span>(Keys));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Remove</span>(<span class="params">TKey key</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!_innerDictionary.TryGetValue(key, <span class="keyword">out</span> <span class="keyword">var</span> <span class="keyword">value</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">bool</span> removed = _innerDictionary.Remove(key);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (removed)</span><br><span class="line">            &#123;</span><br><span class="line">                OnPropertyChanged(<span class="keyword">nameof</span>(Values));</span><br><span class="line">                OnPropertyChanged(<span class="keyword">nameof</span>(Keys));</span><br><span class="line">              	<span class="comment">//整个容器重绘</span></span><br><span class="line">                CollectionChanged?.Invoke(<span class="keyword">this</span>, <span class="keyword">new</span> NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Reset));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> removed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Clear</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            _innerDictionary.Clear();</span><br><span class="line">            <span class="comment">// 使用无参版本触发Reset</span></span><br><span class="line">            OnCollectionChanged(NotifyCollectionChangedAction.Reset);</span><br><span class="line">            OnPropertyChanged(<span class="keyword">nameof</span>(Values));</span><br><span class="line">            OnPropertyChanged(<span class="keyword">nameof</span>(Keys));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 其他接口实现</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">ContainsKey</span>(<span class="params">TKey key</span>)</span> =&gt; _innerDictionary.ContainsKey(key);</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">TryGetValue</span>(<span class="params">TKey key, <span class="keyword">out</span> TValue <span class="keyword">value</span></span>)</span> =&gt; _innerDictionary.TryGetValue(key, <span class="keyword">out</span> <span class="keyword">value</span>);</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Count =&gt; _innerDictionary.Count;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 尝试添加键值对，如果键不存在则添加并返回true，否则返回false</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;key&quot;&gt;</span>要添加的键<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;value&quot;&gt;</span>要添加的值<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>如果键值对被成功添加则返回true，如果键已存在则返回false<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">TryAdd</span>(<span class="params">TKey key, TValue <span class="keyword">value</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (_innerDictionary.ContainsKey(key))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            Add(key, <span class="keyword">value</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> IEnumerator&lt;KeyValuePair&lt;TKey, TValue&gt;&gt; GetEnumerator() =&gt; _innerDictionary.GetEnumerator();</span><br><span class="line">        IEnumerator IEnumerable.GetEnumerator() =&gt; GetEnumerator();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显式接口实现</span></span><br><span class="line">        <span class="keyword">void</span> ICollection&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;.Add(KeyValuePair&lt;TKey, TValue&gt; item) =&gt; Add(item.Key, item.Value);</span><br><span class="line">        <span class="built_in">bool</span> ICollection&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;.Contains(KeyValuePair&lt;TKey, TValue&gt; item) =&gt; ((ICollection&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;)_innerDictionary).Contains(item);</span><br><span class="line">        <span class="keyword">void</span> ICollection&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;.CopyTo(KeyValuePair&lt;TKey, TValue&gt;[] array, <span class="built_in">int</span> arrayIndex) =&gt; ((ICollection&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;)_innerDictionary).CopyTo(array, arrayIndex);</span><br><span class="line">        <span class="built_in">bool</span> ICollection&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;.Remove(KeyValuePair&lt;TKey, TValue&gt; item) =&gt; Remove(item.Key);</span><br><span class="line">        <span class="built_in">bool</span> ICollection&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;.IsReadOnly =&gt; <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





















































</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4" title="头像" alt="头像"></a><div class="post-copyright__author_name">ZEROKO14</div><div class="post-copyright__author_desc">zeroko14's blog</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://che77a38.github.io/posts/WPF/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://che77a38.github.io/posts/WPF/')">WPF</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://che77a38.github.io/posts/WPF/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=WPF&amp;url=https://che77a38.github.io/posts/WPF/&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://che77a38.github.io" target="_blank">ZEROKO14的个人博客</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/WPF/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>WPF<span class="tagsPageCount">3</span></a><a class="post-meta__box__tags" href="/tags/C/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>C#<span class="tagsPageCount">3</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/yaml/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">数据序列化格式盘点</div></div></a></div><div class="next-post pull-right"><a href="/posts/C++%E5%9F%BA%E7%A1%80/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">C++基础</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/posts/avalonia/" title="avalonia"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-09-11</div><div class="title">avalonia</div></div></a></div><div><a href="/posts/prism/" title="Prism"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-11-24</div><div class="title">Prism</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description">欢迎来到ZEROKO14的个人博客</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">ZEROKO14</h1><div class="author-info__desc">zeroko14's blog</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/che77a38" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E7%9A%84WPF%E5%AF%B9%E8%B1%A1%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">完整的WPF对象层次结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Dispatcher"><span class="toc-number">1.1.</span> <span class="toc-text">Dispatcher</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#XAML"><span class="toc-number">2.</span> <span class="toc-text">XAML</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9xaml%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">2.1.</span> <span class="toc-text">对xaml的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#xmlns"><span class="toc-number">2.2.</span> <span class="toc-text">xmlns</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#XAML%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">2.3.</span> <span class="toc-text">XAML命名空间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%89%B9%E5%BE%81%E5%8A%9F%E8%83%BD"><span class="toc-number">2.3.1.</span> <span class="toc-text">常见特征功能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#x-Class"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">x:Class</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#x-ClassModifier"><span class="toc-number">2.3.1.1.1.</span> <span class="toc-text">x:ClassModifier</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#x-Name"><span class="toc-number">2.3.1.2.</span> <span class="toc-text">x:Name</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#x-FieldModifier"><span class="toc-number">2.3.1.2.1.</span> <span class="toc-text">x:FieldModifier</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#x-Key-%E4%B8%8E-x-Shared"><span class="toc-number">2.3.1.3.</span> <span class="toc-text">x:Key 与 x:Shared</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%A0%87%E8%AE%B0%E6%8B%93%E5%B1%95%E5%8A%9F%E8%83%BD"><span class="toc-number">2.3.2.</span> <span class="toc-text">常见标记拓展功能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#x-Type"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">x:Type</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#x-Null"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">x:Null</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#x-Static"><span class="toc-number">2.3.2.3.</span> <span class="toc-text">x:Static</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E5%85%83%E7%B4%A0%E5%8A%9F%E8%83%BD"><span class="toc-number">2.3.3.</span> <span class="toc-text">常用指令元素功能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#x-Code"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">x:Code</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#x-Data"><span class="toc-number">2.3.3.2.</span> <span class="toc-text">x:Data</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#XAML%E6%B3%A8%E9%87%8A"><span class="toc-number">2.4.</span> <span class="toc-text">XAML注释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#XAML%E4%BC%98%E7%82%B9"><span class="toc-number">2.5.</span> <span class="toc-text">XAML优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#XAML%E5%8F%AF%E8%A7%86%E5%8C%96%E8%A7%86%E8%A7%89%E8%AE%BE%E8%AE%A1%E5%B7%A5%E5%85%B7"><span class="toc-number">2.6.</span> <span class="toc-text">XAML可视化视觉设计工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Blend"><span class="toc-number">2.6.1.</span> <span class="toc-text">Blend</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%97%B6%E7%89%B9%E6%80%A7"><span class="toc-number">2.7.</span> <span class="toc-text">设计时特性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%83%E5%B1%80"><span class="toc-number">3.</span> <span class="toc-text">布局</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Grid"><span class="toc-number">3.1.</span> <span class="toc-text">Grid</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97Grid%E5%85%B1%E4%BA%AB%E5%AE%BD%E5%BA%A6"><span class="toc-number">3.1.1.</span> <span class="toc-text">嵌套Grid共享宽度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StackPanel"><span class="toc-number">3.2.</span> <span class="toc-text">StackPanel</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#VirtualizingStackPanel"><span class="toc-number">3.2.0.1.</span> <span class="toc-text">VirtualizingStackPanel</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WrapPanel"><span class="toc-number">3.3.</span> <span class="toc-text">WrapPanel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DockPanel"><span class="toc-number">3.4.</span> <span class="toc-text">DockPanel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Canvas"><span class="toc-number">3.5.</span> <span class="toc-text">Canvas</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UniformGrid"><span class="toc-number">3.6.</span> <span class="toc-text">UniformGrid</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A7%E4%BB%B6"><span class="toc-number">4.</span> <span class="toc-text">控件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E7%9A%84WPF%E6%8E%A7%E4%BB%B6"><span class="toc-number">4.1.</span> <span class="toc-text">内置的WPF控件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E9%92%AE"><span class="toc-number">4.1.1.</span> <span class="toc-text">按钮</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%98%BE%E7%A4%BA"><span class="toc-number">4.1.2.</span> <span class="toc-text">数据显示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E6%98%BE%E7%A4%BA%E5%92%8C%E9%80%89%E6%8B%A9"><span class="toc-number">4.1.3.</span> <span class="toc-text">日期显示和选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%AF%9D%E6%A1%86"><span class="toc-number">4.1.4.</span> <span class="toc-text">对话框</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E5%A2%A8%E8%BF%B9"><span class="toc-number">4.1.5.</span> <span class="toc-text">数字墨迹</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%A1%A3"><span class="toc-number">4.1.6.</span> <span class="toc-text">文档</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5"><span class="toc-number">4.1.7.</span> <span class="toc-text">输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%83%E5%B1%80-1"><span class="toc-number">4.1.8.</span> <span class="toc-text">布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AA%92%E4%BD%93"><span class="toc-number">4.1.9.</span> <span class="toc-text">媒体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8F%9C%E5%8D%95"><span class="toc-number">4.1.10.</span> <span class="toc-text">菜单</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E8%88%AA"><span class="toc-number">4.1.11.</span> <span class="toc-text">导航</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E9%A1%B9"><span class="toc-number">4.1.12.</span> <span class="toc-text">选项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E6%81%AF"><span class="toc-number">4.1.13.</span> <span class="toc-text">信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%99%AE%E9%80%9A%E5%B1%9E%E6%80%A7"><span class="toc-number">4.2.</span> <span class="toc-text">依赖属性与普通属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E5%8F%98%E5%8C%96%E7%9A%84%E5%9B%9E%E8%B0%83"><span class="toc-number">4.2.1.</span> <span class="toc-text">属性变化的回调</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3"><span class="toc-number">4.2.2.</span> <span class="toc-text">依赖属性详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BE%9D%E8%B5%96%E5%B1%9E%E6%80%A7"><span class="toc-number">4.2.3.</span> <span class="toc-text">自定义依赖属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DependencyProperty-Register"><span class="toc-number">4.2.3.1.</span> <span class="toc-text">DependencyProperty.Register</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AA%E8%AF%BB%E4%BE%9D%E8%B5%96%E5%B1%9E%E6%80%A7"><span class="toc-number">4.2.3.2.</span> <span class="toc-text">只读依赖属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%B1%9E%E6%80%A7%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">4.2.4.</span> <span class="toc-text">依赖属性的继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%B1%9E%E6%80%A7%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">4.2.5.</span> <span class="toc-text">依赖属性的优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%84%E5%8A%A0%E5%B1%9E%E6%80%A7"><span class="toc-number">4.2.6.</span> <span class="toc-text">附加属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E5%8A%A0%E5%B1%9E%E6%80%A7%E6%A1%88%E4%BE%8B"><span class="toc-number">4.3.</span> <span class="toc-text">附加属性案例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E5%8A%A0%E5%B1%9E%E6%80%A7%E4%B8%8E%E4%BE%9D%E8%B5%96%E5%B1%9E%E6%80%A7%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.4.</span> <span class="toc-text">附加属性与依赖属性使用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E8%88%AC%E6%83%85%E5%86%B5%E7%89%B9%E6%80%A7"><span class="toc-number">4.5.</span> <span class="toc-text">一般情况特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#x%E8%AF%A6%E8%A7%A3"><span class="toc-number">4.6.</span> <span class="toc-text">x详解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%8F%8A%E5%85%B6%E5%AD%90%E9%A1%B9%E7%9A%84%E5%AF%B9%E5%BA%94"><span class="toc-number">4.7.</span> <span class="toc-text">容器及其子项的对应</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DataGrid%E8%AF%A6%E8%A7%A3"><span class="toc-number">4.8.</span> <span class="toc-text">DataGrid详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DataGrid%E5%B1%9E%E6%80%A7%E4%BE%8B%E5%AD%90"><span class="toc-number">4.8.1.</span> <span class="toc-text">DataGrid属性例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AutoGenerateColumns"><span class="toc-number">4.8.2.</span> <span class="toc-text">AutoGenerateColumns</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8DataGrid%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%85%A8%E6%96%B0%E7%9A%84TreeGrid"><span class="toc-number">4.8.3.</span> <span class="toc-text">使用DataGrid实现一个全新的TreeGrid</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CollectionView"><span class="toc-number">4.9.</span> <span class="toc-text">CollectionView</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ProgressBar"><span class="toc-number">4.10.</span> <span class="toc-text">ProgressBar</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%8C%96-%E5%BB%B6%E8%BF%9F%E6%BB%9A%E5%8A%A8"><span class="toc-number">4.11.</span> <span class="toc-text">虚拟化&#x2F;延迟滚动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TreeView"><span class="toc-number">4.12.</span> <span class="toc-text">TreeView</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E5%B1%9E%E6%80%A7"><span class="toc-number">4.12.1.</span> <span class="toc-text">主要属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">4.12.2.</span> <span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">4.12.3.</span> <span class="toc-text">使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E5%B1%82%E6%A1%88%E4%BE%8B"><span class="toc-number">4.12.3.1.</span> <span class="toc-text">两层案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E5%B1%82%E6%A1%88%E4%BE%8B"><span class="toc-number">4.12.3.2.</span> <span class="toc-text">三层案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%80%89%E6%8B%A9%E5%B1%82%E7%BA%A7%E6%98%BE%E7%A4%BA%E5%AE%9E%E7%8E%B0%E6%A1%88%E4%BE%8B"><span class="toc-number">4.12.4.</span> <span class="toc-text">自定义选择层级显示实现案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B7%E5%BC%8F%E6%A8%A1%E6%9D%BF"><span class="toc-number">4.12.5.</span> <span class="toc-text">样式模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TreeView%E4%B8%AD%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E9%80%89%E4%B8%AD%E5%80%BC"><span class="toc-number">4.12.6.</span> <span class="toc-text">TreeView中如何获取选中值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ScrollViewer"><span class="toc-number">4.13.</span> <span class="toc-text">ScrollViewer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Thumb"><span class="toc-number">4.14.</span> <span class="toc-text">Thumb</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Popup"><span class="toc-number">4.15.</span> <span class="toc-text">Popup</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%88%B6Popup"><span class="toc-number">4.15.1.</span> <span class="toc-text">自制Popup</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tooltip"><span class="toc-number">4.16.</span> <span class="toc-text">Tooltip</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ComboBox"><span class="toc-number">4.17.</span> <span class="toc-text">ComboBox</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E6%9E%84%E6%88%90"><span class="toc-number">4.17.1.</span> <span class="toc-text">内部构成</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ItemsControl"><span class="toc-number">4.18.</span> <span class="toc-text">ItemsControl</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%88%97%E8%A1%A8%E6%98%BE%E7%A4%BA%E6%A1%88%E4%BE%8B"><span class="toc-number">4.18.1.</span> <span class="toc-text">简单列表显示案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%E5%A4%9A%E6%88%90%E5%91%98%E6%98%BE%E7%A4%BA%E5%90%AB%E5%91%BD%E4%BB%A4%E6%A1%88%E4%BE%8B"><span class="toc-number">4.18.2.</span> <span class="toc-text">结构体中多成员显示含命令案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Menu"><span class="toc-number">4.19.</span> <span class="toc-text">Menu</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ContentControl"><span class="toc-number">4.20.</span> <span class="toc-text">ContentControl</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ContextMenu"><span class="toc-number">4.21.</span> <span class="toc-text">ContextMenu</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PlacementTarget"><span class="toc-number">4.21.1.</span> <span class="toc-text">PlacementTarget</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-number">4.21.2.</span> <span class="toc-text">案例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A%E5%88%B0%E7%88%B6%E7%BA%A7%E6%8E%A7%E4%BB%B6%E7%9A%84DataContext"><span class="toc-number">4.21.2.1.</span> <span class="toc-text">绑定到父级控件的DataContext</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BindingProxy"><span class="toc-number">4.21.3.</span> <span class="toc-text">BindingProxy</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-1"><span class="toc-number">4.21.3.1.</span> <span class="toc-text">案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ListView"><span class="toc-number">4.22.</span> <span class="toc-text">ListView</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ListView%E4%B8%AD%E6%8F%92%E5%85%A5%E8%87%AA%E5%A2%9E%E5%88%97%E6%A1%88%E4%BE%8B"><span class="toc-number">4.22.1.</span> <span class="toc-text">ListView中插入自增列案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TabControl"><span class="toc-number">4.23.</span> <span class="toc-text">TabControl</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%90%E9%A1%B9%E6%A8%A1%E6%9D%BF%E5%A6%82%E4%B8%8B"><span class="toc-number">4.23.1.</span> <span class="toc-text">自定义子项模板如下</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ListBox"><span class="toc-number">4.24.</span> <span class="toc-text">ListBox</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ListView-1"><span class="toc-number">4.25.</span> <span class="toc-text">ListView</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="toc-number">4.25.1.</span> <span class="toc-text">基本使用案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6%E7%94%A8%E6%B3%95%E6%A1%88%E4%BE%8B"><span class="toc-number">4.25.2.</span> <span class="toc-text">进阶用法案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CheckBox"><span class="toc-number">4.26.</span> <span class="toc-text">CheckBox</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89CheckBox"><span class="toc-number">4.26.1.</span> <span class="toc-text">自定义CheckBox</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HierarchicalDataTemplate"><span class="toc-number">4.27.</span> <span class="toc-text">HierarchicalDataTemplate</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TextBlock"><span class="toc-number">4.28.</span> <span class="toc-text">TextBlock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#run%E6%A0%87%E7%AD%BE"><span class="toc-number">4.28.1.</span> <span class="toc-text">run标签</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#label"><span class="toc-number">4.29.</span> <span class="toc-text">label</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TextBox"><span class="toc-number">4.30.</span> <span class="toc-text">TextBox</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89TextBox"><span class="toc-number">4.30.1.</span> <span class="toc-text">自定义TextBox</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Button"><span class="toc-number">4.31.</span> <span class="toc-text">Button</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89Button"><span class="toc-number">4.31.1.</span> <span class="toc-text">自定义Button</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ToggleButton"><span class="toc-number">4.32.</span> <span class="toc-text">ToggleButton</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89ToggleButton"><span class="toc-number">4.32.1.</span> <span class="toc-text">自定义ToggleButton</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RichTextBox"><span class="toc-number">4.33.</span> <span class="toc-text">RichTextBox</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E5%B1%9E%E6%80%A7-1"><span class="toc-number">4.33.1.</span> <span class="toc-text">主要属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7%E7%BD%97%E5%88%97"><span class="toc-number">4.34.</span> <span class="toc-text">常用属性罗列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Margin"><span class="toc-number">4.34.1.</span> <span class="toc-text">Margin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Width-Height"><span class="toc-number">4.34.2.</span> <span class="toc-text">Width&#x2F;Height</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VerticalAlignment-HorizontalAlignment"><span class="toc-number">4.34.3.</span> <span class="toc-text">VerticalAlignment&#x2F;HorizontalAlignment</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E4%BB%B6%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84"><span class="toc-number">4.35.</span> <span class="toc-text">控件组织结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E6%A0%91%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">4.35.1.</span> <span class="toc-text">逻辑树的结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E6%8E%A7%E4%BB%B6"><span class="toc-number">4.35.2.</span> <span class="toc-text">查找控件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FindName"><span class="toc-number">4.35.2.1.</span> <span class="toc-text">FindName</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E6%A0%91%E4%B8%8E%E8%A7%86%E8%A7%89%E6%A0%91"><span class="toc-number">4.35.2.2.</span> <span class="toc-text">逻辑树与视觉树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%86%E8%A7%89%E6%A0%91"><span class="toc-number">4.35.2.2.1.</span> <span class="toc-text">视觉树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E6%A0%91"><span class="toc-number">4.35.2.2.2.</span> <span class="toc-text">逻辑树</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%87%AA%E7%BB%98%E6%8E%A7%E4%BB%B6"><span class="toc-number">5.</span> <span class="toc-text">自绘控件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AA%97%E5%8F%A3"><span class="toc-number">6.</span> <span class="toc-text">完全自定义窗口</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E6%98%93%E5%8F%8D%E8%B0%83%E8%AF%95%E6%A3%80%E6%B5%8B"><span class="toc-number">7.</span> <span class="toc-text">简易反调试检测</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3-%E9%A1%B5%E9%9D%A2-%E7%94%A8%E6%88%B7%E6%8E%A7%E4%BB%B6"><span class="toc-number">8.</span> <span class="toc-text">窗口&#x2F;页面&#x2F;用户控件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3"><span class="toc-number">8.1.</span> <span class="toc-text">窗口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%96%E6%8B%BD%E6%8E%A7%E5%88%B6%E7%AA%97%E4%BD%93%E5%A4%A7%E5%B0%8F"><span class="toc-number">8.1.1.</span> <span class="toc-text">自定义拖拽控制窗体大小</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A"><span class="toc-number">9.</span> <span class="toc-text">绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Binding%E6%BA%90%E7%9A%84%E6%8C%87%E5%AE%9A"><span class="toc-number">9.1.</span> <span class="toc-text">Binding源的指定</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DataSourceProvider"><span class="toc-number">9.1.1.</span> <span class="toc-text">DataSourceProvider</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#XmlDataProvider"><span class="toc-number">9.1.1.1.</span> <span class="toc-text">XmlDataProvider</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ObjectDataProvider"><span class="toc-number">9.1.1.2.</span> <span class="toc-text">ObjectDataProvider</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LINQ%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E4%BD%9C%E4%B8%BA%E6%95%B0%E6%8D%AE%E6%BA%90"><span class="toc-number">9.1.2.</span> <span class="toc-text">LINQ查询结果作为数据源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RelativeSource"><span class="toc-number">9.1.3.</span> <span class="toc-text">RelativeSource</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A%E8%A7%A3%E9%87%8A"><span class="toc-number">9.1.4.</span> <span class="toc-text">绑定解释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Binding%E8%B7%AF%E5%BE%84%E7%9A%84%E6%8C%87%E5%AE%9A"><span class="toc-number">9.2.</span> <span class="toc-text">Binding路径的指定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A%E5%92%8C%E7%AA%97%E4%BD%93xmal-cs%E4%B8%AD%E6%93%8D%E4%BD%9C%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.3.</span> <span class="toc-text">绑定和窗体xmal.cs中操作的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%91%E5%AE%9A%E9%9C%80%E8%A6%81%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-number">9.4.</span> <span class="toc-text">使用绑定需要的步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%B8%8B%E6%96%87%E6%94%AF%E6%8C%81%E5%8F%98%E5%8C%96%E9%80%9A%E7%9F%A5"><span class="toc-number">9.5.</span> <span class="toc-text">数据上下文支持变化通知</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%91%E5%AE%9Axml%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%80%BC"><span class="toc-number">9.6.</span> <span class="toc-text">绑定xml文件中的值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A%E6%8E%A7%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">9.7.</span> <span class="toc-text">绑定控件的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ElementName%EF%BC%8CSource%EF%BC%8CRelativeSource"><span class="toc-number">9.8.</span> <span class="toc-text">ElementName，Source，RelativeSource</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ElementName"><span class="toc-number">9.8.1.</span> <span class="toc-text">ElementName</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Source"><span class="toc-number">9.8.2.</span> <span class="toc-text">Source</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RelativeSource-1"><span class="toc-number">9.8.3.</span> <span class="toc-text">RelativeSource</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E6%A8%A1%E5%BC%8F"><span class="toc-number">9.8.3.1.</span> <span class="toc-text">主要模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Self%E6%A8%A1%E5%BC%8F"><span class="toc-number">9.8.3.1.1.</span> <span class="toc-text">Self模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TemplatedParent%E6%A8%A1%E5%BC%8F"><span class="toc-number">9.8.3.1.2.</span> <span class="toc-text">TemplatedParent模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#FindAncestor%E6%A8%A1%E5%BC%8F"><span class="toc-number">9.8.3.1.3.</span> <span class="toc-text">FindAncestor模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#PreviousData%E6%A8%A1%E5%BC%8F"><span class="toc-number">9.8.3.1.4.</span> <span class="toc-text">PreviousData模式</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E7%BB%91%E5%AE%9A%E6%95%B0%E6%8D%AE%E7%9A%84%E6%98%BE%E7%A4%BA%E6%A0%BC%E5%BC%8F"><span class="toc-number">9.9.</span> <span class="toc-text">控制绑定数据的显示格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C%E4%B8%8E%E8%BD%AC%E6%8D%A2"><span class="toc-number">9.10.</span> <span class="toc-text">数据校验与转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Validation"><span class="toc-number">9.10.1.</span> <span class="toc-text">Validation</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-2"><span class="toc-number">9.10.1.1.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#INotifyDataErrorInfo"><span class="toc-number">9.10.2.</span> <span class="toc-text">INotifyDataErrorInfo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Convert"><span class="toc-number">9.10.3.</span> <span class="toc-text">Convert</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-3"><span class="toc-number">9.10.3.1.</span> <span class="toc-text">案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E7%BB%91%E5%AE%9A"><span class="toc-number">9.11.</span> <span class="toc-text">多重绑定</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4"><span class="toc-number">10.</span> <span class="toc-text">命令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3"><span class="toc-number">10.1.</span> <span class="toc-text">命令详解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4"><span class="toc-number">10.2.</span> <span class="toc-text">如何实现一个命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ICommand"><span class="toc-number">10.2.1.</span> <span class="toc-text">ICommand</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%A9%E6%8E%A7%E4%BB%B6%E6%94%AF%E6%8C%81%E5%91%BD%E4%BB%A4"><span class="toc-number">10.3.</span> <span class="toc-text">如何让控件支持命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ICommandSource"><span class="toc-number">10.3.1.</span> <span class="toc-text">ICommandSource</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E8%80%85%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8"><span class="toc-number">10.4.</span> <span class="toc-text">开发者如何使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8"><span class="toc-number">10.4.1.</span> <span class="toc-text">如何使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6"><span class="toc-number">11.</span> <span class="toc-text">事件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E6%A8%A1%E5%9E%8B"><span class="toc-number">11.1.</span> <span class="toc-text">事件处理机制模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E4%BA%8B%E4%BB%B6"><span class="toc-number">11.1.1.</span> <span class="toc-text">直接事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E4%BA%8B%E4%BB%B6"><span class="toc-number">11.1.2.</span> <span class="toc-text">路由事件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%92%88%E5%AF%B9%E7%AA%97%E5%8F%A3%E7%9A%84%E4%BA%8B%E4%BB%B6"><span class="toc-number">11.2.</span> <span class="toc-text">针对窗口的事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#WPF%E4%BA%8B%E4%BB%B6%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">11.2.1.</span> <span class="toc-text">WPF事件执行顺序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%92%88%E5%AF%B9%E6%8E%A7%E4%BB%B6%E5%92%8C%E5%85%83%E7%B4%A0%E7%9A%84%E4%BA%8B%E4%BB%B6"><span class="toc-number">11.3.</span> <span class="toc-text">针对控件和元素的事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E4%BA%8B%E4%BB%B6"><span class="toc-number">11.4.</span> <span class="toc-text">输入事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%84%A6%E7%82%B9%E4%BA%8B%E4%BB%B6"><span class="toc-number">11.5.</span> <span class="toc-text">焦点事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%83%E5%B1%80%E4%BA%8B%E4%BB%B6"><span class="toc-number">11.6.</span> <span class="toc-text">布局事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BA%8B%E4%BB%B6"><span class="toc-number">11.7.</span> <span class="toc-text">数据事件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MVVM%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84"><span class="toc-number">12.</span> <span class="toc-text">MVVM项目架构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%BF%9E%E6%8E%A5%E4%B8%89%E7%A7%8D%E6%96%87%E4%BB%B6"><span class="toc-number">12.1.</span> <span class="toc-text">如何连接三种文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%88%86%E7%A6%BB"><span class="toc-number">12.2.</span> <span class="toc-text">代码分离</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8FMVVM%E6%A1%88%E4%BE%8B"><span class="toc-number">12.3.</span> <span class="toc-text">最小MVVM案例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E4%B8%8E%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8"><span class="toc-number">12.4.</span> <span class="toc-text">事件驱动与数据驱动</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8"><span class="toc-number">12.4.1.</span> <span class="toc-text">事件驱动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8"><span class="toc-number">12.4.2.</span> <span class="toc-text">数据驱动</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MVVM%E4%B8%8B%E4%BB%A3%E7%A0%81%E6%93%8D%E4%BD%9C%E6%8E%A7%E4%BB%B6"><span class="toc-number">12.5.</span> <span class="toc-text">MVVM下代码操作控件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#behaviour"><span class="toc-number">12.5.1.</span> <span class="toc-text">behaviour</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-4"><span class="toc-number">12.5.1.1.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA"><span class="toc-number">12.5.2.</span> <span class="toc-text">自定义行为</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">12.5.2.1.</span> <span class="toc-text">自定义行为的实现方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%A1%8C%E4%B8%BA"><span class="toc-number">12.5.2.2.</span> <span class="toc-text">使用行为</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-5"><span class="toc-number">12.5.2.3.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MultiDataTrigger"><span class="toc-number">12.5.3.</span> <span class="toc-text">MultiDataTrigger</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MVVM%E5%B8%B8%E8%A7%81%E8%AF%AF%E5%8C%BA"><span class="toc-number">12.6.</span> <span class="toc-text">MVVM常见误区</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E5%92%8C%E6%A0%B7%E5%BC%8F"><span class="toc-number">13.</span> <span class="toc-text">资源和样式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%92%8C%E5%8A%A8%E6%80%81%E8%B5%84%E6%BA%90"><span class="toc-number">13.1.</span> <span class="toc-text">静态资源和动态资源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%BD%A2%E5%BC%8F"><span class="toc-number">13.2.</span> <span class="toc-text">资源管理形式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B7%E5%BC%8F"><span class="toc-number">13.3.</span> <span class="toc-text">样式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Setter"><span class="toc-number">13.3.1.</span> <span class="toc-text">Setter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B7%E5%BC%8F%E6%A1%88%E4%BE%8B"><span class="toc-number">13.3.2.</span> <span class="toc-text">样式案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E6%A0%B7%E5%BC%8F"><span class="toc-number">13.3.3.</span> <span class="toc-text">全局样式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%A0%B7%E5%BC%8F"><span class="toc-number">13.3.4.</span> <span class="toc-text">定义样式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%85%A5%E6%A0%B7%E5%BC%8F%E5%86%99%E6%B3%95"><span class="toc-number">13.3.5.</span> <span class="toc-text">引入样式写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E9%A2%98%E5%88%87%E6%8D%A2%E6%96%B9%E6%A1%88"><span class="toc-number">13.3.6.</span> <span class="toc-text">主题切换方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF"><span class="toc-number">13.4.</span> <span class="toc-text">模板</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%9E%84%E6%88%90"><span class="toc-number">13.4.1.</span> <span class="toc-text">相关构成</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ContentPresenter"><span class="toc-number">13.4.1.1.</span> <span class="toc-text">ContentPresenter</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TemplateBinding"><span class="toc-number">13.4.2.</span> <span class="toc-text">TemplateBinding</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E4%B8%AD%E7%9A%84%E7%BB%91%E5%AE%9A%E6%B3%A8%E6%84%8F%E9%A1%B9"><span class="toc-number">13.4.3.</span> <span class="toc-text">模板中的绑定注意项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E4%BB%B6%E6%A8%A1%E6%9D%BF"><span class="toc-number">13.4.4.</span> <span class="toc-text">控件模板</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">13.4.4.1.</span> <span class="toc-text">触发器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">13.4.4.1.1.</span> <span class="toc-text">基本触发器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E6%9D%A1%E4%BB%B6%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">13.4.4.1.2.</span> <span class="toc-text">多条件触发器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">13.4.4.1.3.</span> <span class="toc-text">数据触发器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E6%95%B0%E6%8D%AE%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">13.4.4.1.4.</span> <span class="toc-text">多路数据触发器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">13.4.4.1.5.</span> <span class="toc-text">事件触发器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A7%E4%BB%B6%E6%A8%A1%E6%9D%BF%E6%A1%88%E4%BE%8B"><span class="toc-number">13.4.4.2.</span> <span class="toc-text">控件模板案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%A8%A1%E6%9D%BF"><span class="toc-number">13.4.5.</span> <span class="toc-text">数据模板</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%A8%A1%E6%9D%BF%E7%9B%98%E7%82%B9"><span class="toc-number">13.4.5.1.</span> <span class="toc-text">数据模板盘点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%82%E7%BA%A7%E6%95%B0%E6%8D%AE%E6%A8%A1%E6%9D%BF"><span class="toc-number">13.4.5.2.</span> <span class="toc-text">层级数据模板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E9%A1%B9%E6%A8%A1%E6%9D%BF"><span class="toc-number">13.4.5.3.</span> <span class="toc-text">自定义数据项模板</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ObservableCollection"><span class="toc-number">13.4.6.</span> <span class="toc-text">ObservableCollection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%86%85%E9%83%A8%E8%AE%BF%E9%97%AE"><span class="toc-number">13.4.7.</span> <span class="toc-text">模板的内部访问</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A7%E4%BB%B6%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%86%85%E9%83%A8%E8%AE%BF%E9%97%AE"><span class="toc-number">13.4.7.1.</span> <span class="toc-text">控件模板的内部访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%86%85%E9%83%A8%E8%AE%BF%E9%97%AE"><span class="toc-number">13.4.7.2.</span> <span class="toc-text">数据模板的内部访问</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E4%BC%98%E5%85%88%E7%BA%A7%E8%A7%84%E5%88%99"><span class="toc-number">14.</span> <span class="toc-text">属性优先级规则</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E4%B8%8E%E7%94%A8%E6%88%B7%E6%8E%A7%E4%BB%B6"><span class="toc-number">15.</span> <span class="toc-text">自定义控件与用户控件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%8E%A7%E4%BB%B6-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E6%A1%88%E4%BE%8B"><span class="toc-number">15.1.</span> <span class="toc-text">用户控件&#x2F;自定义控件案例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ItemsControl-1"><span class="toc-number">15.2.</span> <span class="toc-text">ItemsControl</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%8E%A7%E4%BB%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E6%89%80%E9%9C%80%E7%9F%A5%E8%AF%86%E7%82%B9%E7%9B%98%E7%82%B9"><span class="toc-number">15.3.</span> <span class="toc-text">实现控件自定义所需知识点盘点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E7%94%BB"><span class="toc-number">16.</span> <span class="toc-text">动画</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E7%94%BB%E6%A1%88%E4%BE%8B"><span class="toc-number">16.1.</span> <span class="toc-text">动画案例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E6%8D%A2"><span class="toc-number">16.2.</span> <span class="toc-text">变换</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B8%90%E5%8F%98%E7%94%BB%E5%88%B7%E5%86%99%E6%B3%95%E8%AE%B0%E5%BD%95"><span class="toc-number">17.</span> <span class="toc-text">渐变画刷写法记录</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%90%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%93%8D%E4%BD%9Cui%E7%95%8C%E9%9D%A2"><span class="toc-number">18.</span> <span class="toc-text">子线程中操作ui界面</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#BindingOperations-EnableCollectionSynchronization"><span class="toc-number">18.1.</span> <span class="toc-text">BindingOperations.EnableCollectionSynchronization</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#VS%E9%BB%98%E8%AE%A4%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%E8%AE%B0%E5%BD%95"><span class="toc-number">19.</span> <span class="toc-text">VS默认代码片段记录</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#wpf%E7%9B%B8%E5%85%B3%E5%BA%93"><span class="toc-number">20.</span> <span class="toc-text">wpf相关库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HandyControl"><span class="toc-number">20.1.</span> <span class="toc-text">HandyControl</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9"><span class="toc-number">20.1.1.</span> <span class="toc-text">主要特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-HandyControl"><span class="toc-number">20.1.2.</span> <span class="toc-text">如何使用 HandyControl</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E4%BB%B6%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E7%9B%98%E7%82%B9"><span class="toc-number">20.1.3.</span> <span class="toc-text">控件使用方式盘点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E6%9D%A1"><span class="toc-number">20.1.3.1.</span> <span class="toc-text">滑动条</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E5%80%BC%E6%BB%91%E5%8A%A8%E6%9D%A1"><span class="toc-number">20.1.3.1.1.</span> <span class="toc-text">单值滑动条</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8C%83%E5%9B%B4%E6%BB%91%E5%8A%A8%E6%9D%A1"><span class="toc-number">20.1.3.1.2.</span> <span class="toc-text">范围滑动条</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E5%BA%A6%E6%8C%89%E9%92%AE"><span class="toc-number">20.1.3.2.</span> <span class="toc-text">进度按钮</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E8%BE%93%E5%85%A5%E6%A1%86"><span class="toc-number">20.1.3.3.</span> <span class="toc-text">数字输入框</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E5%85%B3%E6%8C%89%E9%92%AE"><span class="toc-number">20.1.3.4.</span> <span class="toc-text">开关按钮</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E9%92%AE%E7%BB%84"><span class="toc-number">20.1.3.5.</span> <span class="toc-text">按钮组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gif%E6%98%BE%E7%A4%BA%E6%8E%A7%E4%BB%B6"><span class="toc-number">20.1.3.6.</span> <span class="toc-text">gif显示控件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E8%8E%B7%E5%8F%96"><span class="toc-number">20.1.3.7.</span> <span class="toc-text">时间获取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%AF%9D%E6%A1%86-1"><span class="toc-number">20.1.3.8.</span> <span class="toc-text">对话框</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%AF%9D%E6%A1%86"><span class="toc-number">20.1.3.8.1.</span> <span class="toc-text">自定义对话框</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BF%E9%87%8C%E7%9F%A2%E9%87%8F%E5%9B%BE%E6%A0%87%E5%BA%93%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%9B%BE%E6%A0%87"><span class="toc-number">20.1.4.</span> <span class="toc-text">阿里矢量图标库中获取图标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%8C%89%E9%92%AE%E5%B1%95%E7%A4%BA%E5%87%A0%E4%BD%95%E5%9B%BE%E5%BD%A2"><span class="toc-number">20.1.5.</span> <span class="toc-text">使用按钮展示几何图形</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%8C%89%E9%92%AE%E5%8A%A8%E6%80%81%E5%88%87%E6%8D%A2%E5%87%A0%E4%BD%95%E5%9B%BE%E5%BD%A2"><span class="toc-number">20.1.5.1.</span> <span class="toc-text">使用按钮动态切换几何图形</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E6%8D%A2%E4%B8%BB%E9%A2%98%E8%89%B2"><span class="toc-number">20.1.6.</span> <span class="toc-text">切换主题色</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Growl"><span class="toc-number">20.1.6.1.</span> <span class="toc-text">Growl</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E9%BB%98%E8%AE%A4%E6%A0%B7%E5%BC%8F"><span class="toc-number">20.1.7.</span> <span class="toc-text">覆盖默认样式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#wpfui"><span class="toc-number">20.2.</span> <span class="toc-text">wpfui</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E8%A1%A8%E6%8E%A7%E4%BB%B6%E5%BA%93"><span class="toc-number">20.3.</span> <span class="toc-text">图表控件库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ScottPlot"><span class="toc-number">20.3.1.</span> <span class="toc-text">ScottPlot</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ScottPlot%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81%E7%9B%98%E7%82%B9"><span class="toc-number">20.3.2.</span> <span class="toc-text">ScottPlot常用代码盘点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MSChart"><span class="toc-number">20.3.3.</span> <span class="toc-text">MSChart</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OxyPlot"><span class="toc-number">20.3.4.</span> <span class="toc-text">OxyPlot</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#livechart2"><span class="toc-number">20.3.5.</span> <span class="toc-text">livechart2</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A4%E5%A4%84%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%AA%E9%87%8D%E7%BD%AE%E7%BC%A9%E6%94%BE%E7%9A%84%E5%81%9A%E6%B3%95"><span class="toc-number">20.3.5.1.</span> <span class="toc-text">此处记录一个重置缩放的做法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WPF-Suite"><span class="toc-number">20.4.</span> <span class="toc-text">WPF Suite</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%85%A5%E5%BA%93%E6%96%B9%E5%BC%8F"><span class="toc-number">20.4.1.</span> <span class="toc-text">引入库方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E7%95%8C%E9%9D%A2%E5%B8%83%E5%B1%80"><span class="toc-number">20.4.2.</span> <span class="toc-text">优化界面布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AE%B9%E8%BF%87%E6%B8%A1%E6%95%88%E6%9E%9C%E5%B0%81%E8%A3%85"><span class="toc-number">20.4.3.</span> <span class="toc-text">内容过渡效果封装</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#XamlAnimatedGif"><span class="toc-number">20.5.</span> <span class="toc-text">XamlAnimatedGif</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#gif%E6%98%BE%E7%A4%BA%E7%9A%84%E6%89%8B%E5%8A%A8%E6%96%B9%E6%B3%95"><span class="toc-number">20.5.1.</span> <span class="toc-text">gif显示的手动方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CommunityToolkit-Mvvm"><span class="toc-number">20.6.</span> <span class="toc-text">CommunityToolkit.Mvvm</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ValueConverters"><span class="toc-number">20.7.</span> <span class="toc-text">ValueConverters</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">20.7.1.</span> <span class="toc-text">基本使用方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E8%81%94%E8%BD%AC%E6%8D%A2%E5%99%A8%E7%BB%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">20.7.2.</span> <span class="toc-text">串联转换器组使用方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E8%81%94%E8%BD%AC%E6%8D%A2%E5%99%A8%E4%BB%A3%E7%A0%81%E5%8E%9F%E7%90%86%E5%8F%82%E8%80%83"><span class="toc-number">20.7.3.</span> <span class="toc-text">串联转换器代码原理参考</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CalcBinding"><span class="toc-number">20.8.</span> <span class="toc-text">CalcBinding</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E8%AF%BB%E8%AF%A5%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE"><span class="toc-number">20.8.1.</span> <span class="toc-text">解读该开源项目</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DXBinding"><span class="toc-number">20.9.</span> <span class="toc-text">DXBinding</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#XamlFlair"><span class="toc-number">20.10.</span> <span class="toc-text">XamlFlair</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MaterialDesignThemes"><span class="toc-number">20.11.</span> <span class="toc-text">MaterialDesignThemes</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LayUI-Wpf"><span class="toc-number">20.12.</span> <span class="toc-text">LayUI.Wpf</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dotnet9WPFControls"><span class="toc-number">20.13.</span> <span class="toc-text">Dotnet9WPFControls</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B7%E6%B7%86%E5%B7%A5%E5%85%B7"><span class="toc-number">20.14.</span> <span class="toc-text">混淆工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FastHotKeyForWPF"><span class="toc-number">20.15.</span> <span class="toc-text">FastHotKeyForWPF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#System-Configuration-ConfigurationManager"><span class="toc-number">20.16.</span> <span class="toc-text">System.Configuration.ConfigurationManager</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WPF-ControlBase"><span class="toc-number">20.17.</span> <span class="toc-text">WPF-ControlBase</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%9B%B2%E7%BA%BF%E6%A1%88%E4%BE%8B"><span class="toc-number">20.17.1.</span> <span class="toc-text">动态曲线案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E6%B3%A2%E5%99%A8"><span class="toc-number">20.17.2.</span> <span class="toc-text">示波器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B2%E7%BA%BF%E6%8A%BD%E7%A8%80"><span class="toc-number">20.17.3.</span> <span class="toc-text">曲线抽稀</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%BC%E5%BE%97%E5%8F%82%E8%80%83%E7%9A%84%E6%88%90%E5%93%81%E9%A1%B9%E7%9B%AE"><span class="toc-number">20.17.4.</span> <span class="toc-text">值得参考的成品项目</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%96%E6%8B%BD%E8%8A%82%E7%82%B9%E7%BC%96%E8%BE%91%E5%99%A8%E6%A1%86%E6%9E%B6"><span class="toc-number">20.18.</span> <span class="toc-text">拖拽节点编辑器框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WPF%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA%E5%90%91%E5%AF%BCVS%E6%8F%92%E4%BB%B6"><span class="toc-number">20.19.</span> <span class="toc-text">WPF项目创建向导VS插件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E8%BE%91%E5%99%A8%E6%8E%A7%E4%BB%B6%E5%BA%93"><span class="toc-number">20.20.</span> <span class="toc-text">二进制编辑器控件库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E5%8C%85%E5%8F%82%E8%80%83"><span class="toc-number">20.21.</span> <span class="toc-text">打包参考</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MSIX-Packaging"><span class="toc-number">20.21.1.</span> <span class="toc-text">MSIX Packaging</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E7%94%BB%E5%BA%93"><span class="toc-number">20.22.</span> <span class="toc-text">动画库</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#WPF%E5%BC%95%E5%85%A5%E7%9F%A2%E9%87%8F%E5%9B%BE"><span class="toc-number">21.</span> <span class="toc-text">WPF引入矢量图</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#WPF%E4%B8%8EHTML%E4%BA%A4%E4%BA%92"><span class="toc-number">22.</span> <span class="toc-text">WPF与HTML交互</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#WebBrowser"><span class="toc-number">22.1.</span> <span class="toc-text">WebBrowser</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E7%9B%B8%E5%85%B3"><span class="toc-number">22.1.1.</span> <span class="toc-text">显示相关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js%E5%92%8Cc-%E4%BA%A4%E4%BA%92"><span class="toc-number">22.1.2.</span> <span class="toc-text">js和c#交互</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JS%E8%B0%83%E7%94%A8c-%E6%96%B9%E6%B3%95"><span class="toc-number">22.1.2.1.</span> <span class="toc-text">JS调用c#方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E8%B0%83%E7%94%A8JS%E6%96%B9%E6%B3%95"><span class="toc-number">22.1.2.2.</span> <span class="toc-text">C#调用JS方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">22.1.3.</span> <span class="toc-text">http服务器方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WebView2"><span class="toc-number">22.2.</span> <span class="toc-text">WebView2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E7%9B%B8%E5%85%B3-1"><span class="toc-number">22.2.1.</span> <span class="toc-text">显示相关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E5%88%B0JS%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92"><span class="toc-number">22.2.2.</span> <span class="toc-text">C#到JS数据传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JS%E8%B0%83%E7%94%A8C-%E6%96%B9%E6%B3%95"><span class="toc-number">22.2.3.</span> <span class="toc-text">JS调用C#方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">22.2.3.1.</span> <span class="toc-text">获取返回值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E9%A1%B5%E5%8A%A0%E8%BD%BD%E6%97%B6-JavaScript-%E4%BB%A3%E7%A0%81"><span class="toc-number">22.2.4.</span> <span class="toc-text">网页加载时 JavaScript 代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CefSharp"><span class="toc-number">22.3.</span> <span class="toc-text">CefSharp</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">22.3.1.</span> <span class="toc-text">使用方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E7%9B%B8%E5%85%B3-2"><span class="toc-number">22.3.2.</span> <span class="toc-text">显示相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E5%A4%96%E9%83%A8%E9%93%BE%E6%8E%A5"><span class="toc-number">22.3.2.1.</span> <span class="toc-text">显示外部链接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E6%9C%AC%E5%9C%B0html%E6%96%87%E4%BB%B6"><span class="toc-number">22.3.2.2.</span> <span class="toc-text">显示本地html文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E8%B0%83%E7%94%A8JS%E6%96%B9%E6%B3%95-1"><span class="toc-number">22.3.3.</span> <span class="toc-text">C#调用JS方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E6%8E%A7%E5%88%B6%E5%8F%B0"><span class="toc-number">22.3.3.1.</span> <span class="toc-text">显示控制台</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JS%E8%B0%83%E7%94%A8C-%E6%96%B9%E6%B3%95-1"><span class="toc-number">22.3.4.</span> <span class="toc-text">JS调用C#方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%96%B9%E6%A1%88"><span class="toc-number">22.3.4.1.</span> <span class="toc-text">第一个方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E4%B8%AA%E6%96%B9%E6%A1%88"><span class="toc-number">22.3.4.2.</span> <span class="toc-text">第二个方案</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%B0%E6%9C%89%E7%A8%8B%E5%BA%8F%E8%BF%81%E7%A7%BB%E5%88%B0WEB%E7%AB%AF"><span class="toc-number">22.4.</span> <span class="toc-text">现有程序迁移到WEB端</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#wpf%E4%B8%8Ewinform%E6%8E%A7%E4%BB%B6%E4%BA%92%E7%9B%B8%E4%BD%BF%E7%94%A8"><span class="toc-number">23.</span> <span class="toc-text">wpf与winform控件互相使用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8D%95%E8%8E%B7%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8"><span class="toc-number">24.</span> <span class="toc-text">捕获全局异常</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E6%B3%95%E5%85%A8%E5%B1%80%E6%8D%95%E8%8E%B7%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="toc-number">24.1.</span> <span class="toc-text">无法全局捕获的异常</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BF%AB%E6%8D%B7%E9%94%AE%E7%9B%B8%E5%85%B3"><span class="toc-number">25.</span> <span class="toc-text">快捷键相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%86%85%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="toc-number">25.1.</span> <span class="toc-text">程序内快捷键</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%80%BC%E5%BE%97%E8%AE%B0%E5%BD%95%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">26.</span> <span class="toc-text">值得记录的代码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TextBox%E5%88%87%E6%8D%A2%E8%BE%93%E5%85%A5%E4%B8%8E%E7%BB%91%E5%AE%9A%E6%A8%A1%E5%BC%8F"><span class="toc-number">26.1.</span> <span class="toc-text">TextBox切换输入与绑定模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">26.1.1.</span> <span class="toc-text">更好的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%99%E7%A7%8D%E6%96%B9%E6%B3%95%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-number">26.1.2.</span> <span class="toc-text">这种方法的优点：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E6%8A%80%E5%B7%A7%E7%9B%98%E7%82%B9"><span class="toc-number">27.</span> <span class="toc-text">一些技巧盘点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B7%B7%E6%B7%86%E5%B7%A5%E5%85%B7-1"><span class="toc-number">28.</span> <span class="toc-text">混淆工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#obfuscar"><span class="toc-number">28.1.</span> <span class="toc-text">obfuscar</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85"><span class="toc-number">28.1.1.</span> <span class="toc-text">安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-1"><span class="toc-number">28.1.2.</span> <span class="toc-text">使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%AF%E8%A2%AB%E8%A7%82%E5%AF%9F%E5%AE%B9%E5%99%A8"><span class="toc-number">29.</span> <span class="toc-text">自定义可被观察容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ObservableDictionary"><span class="toc-number">29.1.</span> <span class="toc-text">ObservableDictionary</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="toc-number">29.1.1.</span> <span class="toc-text">实现思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-number">29.1.2.</span> <span class="toc-text">代码</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/%E5%B7%A5%E4%B8%9A%E7%9B%B8%E5%85%B3/" title="工业相关">工业相关</a><time datetime="2025-02-14T03:04:40.761Z" title="发表于 2025-02-14 11:04:40">2025-02-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/" title="操作系统">操作系统</a><time datetime="2024-12-16T01:38:01.470Z" title="发表于 2024-12-16 09:38:01">2024-12-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/%E8%AE%A1%E7%BB%84/" title="计算机组成原理">计算机组成原理</a><time datetime="2024-12-16T01:38:01.470Z" title="发表于 2024-12-16 09:38:01">2024-12-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/" title="网络架构">网络架构</a><time datetime="2024-11-18T06:17:01.282Z" title="发表于 2024-11-18 14:17:01">2024-11-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/avalonia/" title="avalonia">avalonia</a><time datetime="2024-09-11T14:51:13.000Z" title="发表于 2024-09-11 22:51:13">2024-09-11</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2025 By <a class="footer-bar-link" href="/" title="ZEROKO14" target="_blank">ZEROKO14</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu"></a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">50</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">6</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size: 0.88rem;">C#<sup>3</sup></a><a href="/tags/C/" style="font-size: 0.88rem;">C++<sup>5</sup></a><a href="/tags/CSS/" style="font-size: 0.88rem;">CSS<sup>1</sup></a><a href="/tags/CSharp/" style="font-size: 0.88rem;">CSharp<sup>1</sup></a><a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 0.88rem;">C语言<sup>1</sup></a><a href="/tags/FPS/" style="font-size: 0.88rem;">FPS<sup>1</sup></a><a href="/tags/HTML/" style="font-size: 0.88rem;">HTML<sup>1</sup></a><a href="/tags/JavaScript/" style="font-size: 0.88rem;">JavaScript<sup>1</sup></a><a href="/tags/MFC/" style="font-size: 0.88rem;">MFC<sup>1</sup></a><a href="/tags/PE/" style="font-size: 0.88rem;">PE<sup>1</sup></a><a href="/tags/QT/" style="font-size: 0.88rem;">QT<sup>1</sup></a><a href="/tags/WPF/" style="font-size: 0.88rem;">WPF<sup>3</sup></a><a href="/tags/ai/" style="font-size: 0.88rem;">ai<sup>1</sup></a><a href="/tags/cmake/" style="font-size: 0.88rem;">cmake<sup>1</sup></a><a href="/tags/doxygen/" style="font-size: 0.88rem;">doxygen<sup>1</sup></a><a href="/tags/git/" style="font-size: 0.88rem;">git<sup>1</sup></a><a href="/tags/json/" style="font-size: 0.88rem;">json<sup>1</sup></a><a href="/tags/linux/" style="font-size: 0.88rem;">linux<sup>1</sup></a><a href="/tags/nas/" style="font-size: 0.88rem;">nas<sup>1</sup></a><a href="/tags/next/" style="font-size: 0.88rem;">next<sup>1</sup></a><a href="/tags/ppt/" style="font-size: 0.88rem;">ppt<sup>1</sup></a><a href="/tags/slidev/" style="font-size: 0.88rem;">slidev<sup>1</sup></a><a href="/tags/vue/" style="font-size: 0.88rem;">vue<sup>1</sup></a><a href="/tags/xml/" style="font-size: 0.88rem;">xml<sup>1</sup></a><a href="/tags/yaml/" style="font-size: 0.88rem;">yaml<sup>1</sup></a><a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 0.88rem;">代码规范<sup>1</sup></a><a href="/tags/%E5%86%85%E6%A0%B8/" style="font-size: 0.88rem;">内核<sup>2</sup></a><a href="/tags/%E5%86%85%E6%A0%B8%E7%9B%B8%E5%85%B3/" style="font-size: 0.88rem;">内核相关<sup>5</sup></a><a href="/tags/%E5%8A%A0%E8%A7%A3%E5%AF%86/" style="font-size: 0.88rem;">加解密<sup>1</sup></a><a href="/tags/%E5%9F%BA%E7%A1%80/" style="font-size: 0.88rem;">基础<sup>3</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 0.88rem;">多线程<sup>1</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F/" style="font-size: 0.88rem;">并发模式<sup>1</sup></a><a href="/tags/%E5%BC%80%E5%8F%91/" style="font-size: 0.88rem;">开发<sup>4</sup></a><a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 0.88rem;">数学<sup>1</sup></a><a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 0.88rem;">正则表达式<sup>1</sup></a><a href="/tags/%E7%9B%91%E6%8E%A7/" style="font-size: 0.88rem;">监控<sup>1</sup></a><a href="/tags/%E7%A1%AC%E7%BC%96%E7%A0%81/" style="font-size: 0.88rem;">硬编码<sup>1</sup></a><a href="/tags/%E7%AE%A1%E7%90%86/" style="font-size: 0.88rem;">管理<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 0.88rem;">网络<sup>3</sup></a><a href="/tags/%E9%80%86%E5%90%91/" style="font-size: 0.88rem;">逆向<sup>2</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.cbd.int/mathjax@3.2.2/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.cbd.int/mermaid@10.2.4/dist/mermaid.min.js').then(runMermaid)
  }

  anzhiyu.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>