<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>QT入门 | ZEROKO14的个人博客</title><meta name="keywords" content="QT"><meta name="author" content="ZEROKO14"><meta name="copyright" content="ZEROKO14"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#18171d"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="QT入门"><meta name="application-name" content="QT入门"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#18171d"><meta property="og:type" content="article"><meta property="og:title" content="QT入门"><meta property="og:url" content="https://che77a38.github.io/posts/QT/index.html"><meta property="og:site_name" content="ZEROKO14的个人博客"><meta property="og:description" content="Qt概述什么是QtQt是一个跨平台的C++图形用户界面应用程序框架。它为应用程序开发者提供建立艺术级图形界面所需的所有功能。它是完全面向对象的，很容易扩展，并且允许真正的组件编程。   Qt的发展史1991年 Qt最早由奇趣科技开发 1996年 进入商业领域，它也是目前流行的Linux桌面环境KDE"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4"><meta property="article:author" content="ZEROKO14"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4"><meta name="description" content="Qt概述什么是QtQt是一个跨平台的C++图形用户界面应用程序框架。它为应用程序开发者提供建立艺术级图形界面所需的所有功能。它是完全面向对象的，很容易扩展，并且允许真正的组件编程。   Qt的发展史1991年 Qt最早由奇趣科技开发 1996年 进入商业领域，它也是目前流行的Linux桌面环境KDE"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://che77a38.github.io/posts/QT/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2024/07/27/125766904/ba62475f396df9de3316a08ed9e65d86_5680958632268053399..png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":true,"limitCount":50,"languages":{"author":"作者: ZEROKO14","link":"链接: ","source":"来源: ZEROKO14的个人博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'ZEROKO14的个人博客',
  title: 'QT入门',
  postAI: '',
  pageFillDescription: 'Qt概述, 什么是Qt, Qt的发展史, 支持的平台, Qt版本, Qt的下载与安装, 下载地址：, Linux Host, OS X Host, Windows Host, 安装, Qt的优点, 成功案例, QT中常用默认快捷键, 创建Qt项目, 使用向导创建, 手动创建, .pro文件, 一个最简单的Qt应用程序, 命名规范和QT的快捷键, 第一个QT（对象模型和坐标系）, 按钮的创建, 对象模型（对象树）, Qt窗口坐标体系, 信号和槽机制, 系统自带的信号和槽, 自定义信号和槽, 信号和槽原理, QMetaObject类, 信号槽的拓展, 【注意】给label设置鼠标事件穿透案例, 【注意】信号和槽传递自定义类型需要先注册该类型, Qt4版本的信号槽写法, connect中的Lambda表达式, 三参数版本的信号与槽, QMainWindow, 菜单栏, 工具栏, 状态栏, 铆接部件, 核心部件（中心部件）, 资源文件, 对话框QDialog, 基本概念, 标准对话框, 自定义对话框, 模态对话框, 非模态对话框, 消息对话框, 标准文件对话框, 标准颜色对话框, 标准字体对话框, 布局管理器, 系统提供的布局控件, 利用widget做布局, 常用控件, QLabel控件使用, 显示文字 （普通文本、html）, 显示图片, 显示动画, QLineEdit, 设置x2F获取内容, 设置显示模式, QToolButton, QRadioButton, QCheckBox, QListWidget, QTreeWidget, QTableWidget, 其他控件, 自定义控件, 根据控件名找控件案例, Qt消息机制和事件, 事件（内含定时器）, 9.1.1 部分鼠标事件, 9.1.2 定时器, event（）事件分发器, 事件过滤器, 总结, 自定义事件, 自定义事件的类型, 事件的发送方式, 自定义事件处理函数, 绘图和绘图设备, QPainter, 绘图设备, QPixmap、QBitmap、QImage, QPicture, 文件系统, 基本文件操作, 二进制文件读写, 文本文件读写, QT简单的动画效果, QT添加音效, 优化细节, qt setData()和data(), 简述, 常见接口, QT多线程, 线程类 QThread, 第一种创建子线程, 操作步骤, 示例代码, 第二种创建子线程的方式, 操作步骤, 示例代码, QT线程池, 线程池的原理, QRunnable, QThreadPool, 示例代码, 接受windows原生消息处理, 添加图标, QT 添加DLL, QT以管理员启动, QT编码, QT json, QT的base64编码, QT中的类型转换, QT中的编码转换, gbk转utf8, QT数据库开发, oracle数据库, mysql开发, 加载数据库驱动, 设置账号密码, 打开数据库, 关闭数据库, 操作数据库, 执行select查询操作, 执行语句, 结果集记录数和字段数, 查询字段数, 查询记录数, 遍历结果集, 执行insert操作, 直接插入, 占位符插入, 执行update操作, 直接update, 占位符update, 执行delete操作, 直接delete, 占位符delete, 事务处理, sqlite开发, QT中的http, Qt中http的使用, QNetworkAccessManager, QNetworkRequest, QNetworkReply, 示例程序, 打包发布, QT的一些问题, 中文图片资源问题, mac安装qt概述什么是是一个跨平台的图形用户界面应用程序框架它为应用程序开发者提供建立艺术级图形界面所需的所有功能它是完全面向对象的很容易扩展并且允许真正的组件编程的发展史年最早由奇趣科技开发年进入商业领域它也是目前流行的桌面环境的基础年奇趣科技被诺基亚公司收购称为诺基亚旗下的编程语言年又被公司收购年月跨平台的集成开发环境发布同年月日配发了正式版至此实现了对等各平台的全面支持当前最新版本为现在已经不是了支持的平台和其他很多平台有帧缓冲支持的嵌入式平台版本按照不同的版本发行分为商业版和开源版商业版为商业软件提供开发他们提供传统商业软件发行版并且提供在商业有效期内的免费升级和技术支持服务开源的版本为了开发自有而设计的开放源码软件它提供了和商业版本同样的功能在通用公共许可下它是免费的的下载与安装由于从开始主要采用授权而明确禁止封闭嵌入式设备分发授权的软件所以在嵌入式下不能使用以及以上的版本进行商用当然以及以下的版本还是可以下载地址安装默认安装建议组件全部选中对不同的平台提供了不同版本的安装包可根据实际情况自行下载安装本文档使用版本进行讲解编码中文不会乱码的优点跨平台几乎支持所有的平台接口简单容易上手学习框架对学习其他框架有参考意义一定程度上简化了内存回收机制开发效率高能够快速的构建应用程序有很好的社区氛围市场份额在缓慢上升可以进行嵌入式开发成功案例桌面环境办公软件网络电话谷歌地图多媒体播放器虚拟机软件中常用默认快捷键快捷键功能格式化选中代码创建项目使用向导创建打开界面选择或者选择菜单栏文件新建文件或项目菜单项弹出对话框选择选择按钮弹出如下对话框设置项目名称和路径按照向导进行下一步选择编译套件向导会默认添加一个继承自的类可以在此修改类的名字和基类默认的基类有以及三个我们可以选择类似于空窗口这里我们可以先创建一个不带的界面继续下一步系统会默认给我们添加和一个项目文件点击完成即可创建出一个桌面程序手动创建添加一个空项目选择进行下一步设置项目名称和路径选择编译套件修改类信息完成步骤同上生成一个空项目在空项目中添加文件在项目名称上单击鼠标右键弹出右键菜单选择添加新文件弹出新建文件对话框在此对话框中选择要添加的类或者文件根据向导完成文件的添加文件在使用向导生成的应用程序文件格式如下包含的模块大于版本才包含模块应用程序名生成的程序名称模板类型应用程序模板源文件头文件就是工程文件它是自动生成的用于生产的配置文件文件的写法如下注释从开始到这一行结束模板变量告诉为这个应用程序生成哪种下面是可供使用的选择建立一个应用程序的这是默认值所以如果模板没有被指定这个将被使用建立一个库的建立一个应用程序的项目文件建立一个库的项目文件这是一个特殊的模板它可以创建一个能够进入特定目录并且为一个项目文件生成并且为它调用的指定生成的应用程序名工程中包含的头文件工程中包含的设计文件工程中包含的源文件工程中包含的资源文件这条语句的含义是如果大于也就是当前使用的及更高版本需要增加模块如果项目仅需支持也可以直接添加一句不过为了保持代码兼容最好还是按照生成的语句编写模块模块配置信息用来告诉关于应用程序的配置信息使用的特性在这里使用是因为我们添加我们的配置选项到任何一个已经存在中这样做比使用那样替换已经指定的所有选项更安全一个最简单的应用程序入口函数中解释系统提供的标准类名声明头文件没有后缀一个类对应一个头文件类名就是头文件名应用程序类管理图形用户界面应用程序的控制流和主要设置是的整个后台管理的命脉它包含主事件循环在其中来自窗口系统和其它资源的所有事件处理和调度它也处理应用程序的初始化和结束并且提供对话管理对于任何一个使用的图形用户界面应用程序都正好存在一个对象而不论这个应用程序在同一时间内是不是有或更多个窗口程序进入消息循环等待对用户输入进行响应这里把控制权转交给完成事件处理工作当应用程序退出的时候的值就会返回在中接受并处理用户和系统的事件并且把它们传递给适当的窗口部件命名规范和的快捷键自动创建类的定义第一个对象模型和坐标系按钮的创建在程序中最常用的控件之一就是按钮了首先我们来看下如何创建一个按钮头文件设置父亲设置文字德玛西亚移动位置第二种创建孙悟空重新指定窗口大小设置窗口标题第一个项目限制窗口大小上面代码中一个按钮其实就是一个类下的对象如果只是创建出对象是无法显示到窗口中的独立显示到一个窗口中所以我们需要依赖一个父窗口也就是指定一个父亲利用函数即可如果想设置按钮上显示的文字利用移动按钮位置用对于窗口而言我们可以修改左上角窗口的标题重新指定窗口大小或者设置固定的窗口大小对象模型对象树在中创建对象的时候会提供一个对象指针下面来解释这个到底是干什么的是以对象树的形式组织起来的当你创建一个对象时会看到的构造函数接收一个指针作为参数这个参数就是也就是父对象指针这相当于在创建对象时可以提供一个其父对象我们创建的这个对象会自动添加到其父对象的列表当父对象析构的时候这个列表中的所有对象也会被析构注意这里的父对象并不是继承意义上的父类这种机制在程序设计中相当有用例如一个按钮有一个快捷键对象作为其子对象当我们删除按钮的时候这个快捷键理应被删除这是合理的是能够在屏幕上显示的一切组件的父类继承自因此也继承了这种对象树关系一个孩子自动地成为父组件的一个子组件因此它会显示在父组件的坐标系统中被父组件的边界剪裁例如当用户关闭一个对话框的时候应用程序将其删除那么我们希望属于这个对话框的按钮图标等应该一起被删除事实就是如此因为这些都是对话框的子组件当然我们也可以自己删除子对象它们会自动从其父对象列表中删除比如当我们删除了一个工具栏时其所在的主窗口会自动将该工具栏从其子对象列表中删除并且自动调整屏幕显示引入对象树的概念在一定程度上解决了内存问题当一个对象在堆上创建的时候会同时为其创建一个对象树不过对象树中对象的顺序是没有定义的这意味着销毁这些对象的顺序也是未定义的任何对象树中的对象的时候如果这个对象有则自动将其从的列表中删除如果有孩子则自动每一个孩子保证没有会被两次这是由析构顺序决定的如果在栈上创建保持同样的行为正常情况下这也不会发生什么问题来看下下面的代码片段作为父组件的和作为子组件的都是的子类事实上它们都是的子类而是的子类这段代码是正确的的析构函数不会被调用两次因为标准要求局部对象的析构顺序应该按照其创建顺序的相反过程因此这段代码在超出作用域时会先调用的析构函数将其从父对象的子对象列表中删除然后才会再调用的析构函数但是如果我们使用下面的代码注意重点情况又有所不同析构顺序就有了问题我们看到在上面的代码中作为父对象的会首先被析构因为它是最后一个创建的对象在析构过程中它会调用子对象列表中每一个对象的析构函数也就是说此时就被析构了然后代码继续执行在析构之后也会被析构因为也是一个局部变量在超出作用域的时候当然也需要析构但是这时候已经是第二次调用的析构函数了不允许调用两次析构函数因此程序崩溃了由此我们看到的对象树机制虽然帮助我们在一定程度上解决了内存问题但是也引入了一些值得注意的事情这些细节在今后的开发过程中很可能时不时跳出来烦扰一下所以我们最好从开始就养成良好习惯在中尽量在构造的时候就指定对象并且大胆在堆上创建对象树的意义简化了内存回收机制内存自动释放有两个前提条件必须是的派生类必须指定了对象其构造与析构顺序如下图重难点析构函数内代码与真正析构释放过程相反注意和继承于的类的析构中分别添加输出输出如下重点由此可知析构函数内代码的运行是由上至下而真正的析构释放过程是由下至上的窗口坐标体系坐标体系以左上角为原点向右增加向下增加对于嵌套窗口其坐标是相对于父窗口来说的信号和槽机制信号和槽是对象间的一种通信机制信号槽是框架引以为豪的机制之一所谓信号槽实际就是观察者模式当某个事件发生之后比如按钮检测到自己被点击了一下它就会发出一个信号这种发出是没有目的的类似广播如果有对象对这个信号感兴趣它就会使用连接函数意思是将想要处理的信号和自己的一个函数称为槽绑定来处理这个信号也就是说当信号发出时被连接的槽函数会自动被回调这就类似观察者模式当发生了感兴趣的事件某一个操作就会被自动触发一图流系统自带的信号和槽下面我们完成一个小功能上面我们已经学习了按钮的创建但是还没有体现出按钮的功能按钮最大的功能也就是点击后触发一些事情比如我们点击按钮就把当前的窗口给关闭掉那么在中这样的功能如何实现呢其实无法两行代码就可以搞定了我们看下面的代码关闭窗口第一行是创建一个关闭按钮这个之前已经学过第二行就是核心了也就是信号槽的使用方式函数最常用的一般形式参数解释发出信号的对象发送对象发出的信号接收信号的对象接收对象在接收到信号之后所需要调用的函数槽函数那么系统自带的信号和槽通常如何查找呢这个就需要利用帮助文档了在帮助文档中比如我们上面的按钮的点击信号在帮助文档中输入首先我们可以在中寻找关键字信号的意思但是我们发现并没有找到这时候我们应该想到也许这个信号的被父类继承下来的因此我们去他的父类中就可以找到该关键字点击索引到系统自带的信号有如下几个这里的就是我们要找到槽函数的寻找方式和信号一样只不过他的关键字是自定义信号和槽使用可以让我们连接系统提供的信号和槽但是的信号槽机制并不仅仅是使用系统提供的那部分还会允许我们自己设计自己的信号和槽下面我们看看使用的信号槽首先定义一个学生类和老师类老师类中声明信号饿了学生类中声明槽请客在窗口中声明一个公共方法下课这个方法的调用会触发老师饿了这个信号而响应槽函数学生请客发送信号学生响应了槽函数并且打印信息自定义槽函数实现该吃饭了在窗口中连接信号槽并且调用下课函数测试打印出该吃饭了下面是重载版的信号和槽自定义的信号带参数需要提供重载的自定义信号和自定义槽自定义信号自定义槽但是由于有两个重名的自定义信号和自定义的槽直接连接会报错所以需要利用函数指针来指向函数地址然后再再做连接转是先转为类型再转为类型自定义信号槽需要注意的事项发送者和接收者都需要是的子类当然槽函数是全局函数表达式等无需接收者的时候除外信号和槽函数返回值是信号只需要声明不需要实现槽函数需要声明也需要实现槽函数是普通的成员函数作为成员函数会受到的影响使用在恰当的位置发送信号使用函数连接信号和槽任何成员函数函数全局函数和表达式都可以作为槽函数以上才可以必须写到下信号槽要求信号和槽的参数一致所谓一致是参数类型一致如果信号和槽的参数不一致允许的情况是槽函数的参数可以比信号的少即便如此槽函数存在的那些参数的顺序也必须和信号的前面几个一致起来这是因为你可以在槽函数中选择忽略信号传来的数据也就是槽函数的参数比信号的少信号和槽原理本质上是在编译的时候做了其他处理归根溯源宏实际上就是空宏实际上就是的用到的和宏实际上就是字符串最前面加了或者版版表示字符串拼接宏其实就是加了文件名和行号等一些调试信息是一些成员变量和函数类该类中的数据部分如下未完待续信号槽的拓展一个信号可以和多个槽相连如果是这种情况这些槽会一个接一个的被调用但是它们的调用顺序是不确定的多个信号可以连接到一个槽只要任意一个信号发出这个槽就会被调用一个信号可以连接到另外的一个信号当第一个信号发出时第二个信号被发出除此之外这种信号信号的形式和信号槽的形式没有什么区别槽可以被取消链接这种情况并不经常出现因为当一个对象之后自动取消所有连接到这个对象上面的槽信号槽可以断开利用关键字是可以断开信号槽的使用表达式在使用的时候能够支持的编译器都是支持表达式的在连接信号和槽的时候槽函数可以使用表达式的方式进行处理后面我们会详细介绍什么是表达式注意给设置鼠标事件穿透案例注意信号和槽传递自定义类型需要先注册该类型如果是自己定义的类型如果想使用来传递的话则没有这么简单直接使用的话会产生下面这种错误原因当一个被放到队列中时它的参数也会被一起一起放到队列中起来这就意味着参数在被传送到之前需要被拷贝存储在队列中中为了能够在队列中存储这些参数需要去这些对象而为了让知道怎样去作这些事情参数的类型需要使用来注册例如版本的信号槽写法这里使用了和这两个宏将两个函数名转换成了字符串注意到函数的和都是接受字符串一旦出现连接不成功的情况是没有编译错误的因为一切都是字符串编译期是不检查字符串是否匹配而是在运行时给出错误这无疑会增加程序的不稳定性写法优势参数直观劣势参数类型不做匹配检测在语法上完全兼容而反之是不可以的中的表达式与表达式表达式详解跳转注意和信号与槽重点当进行信号和槽连接的时候控件内部会进入一个锁的状态因此不可以用表达式的引用传递来调用已连接的组件而应该用表达式的值传递函数中如果槽函数用的是表达式那么信号的接受者可以省略三参数版本的信号与槽是一个为用户提供主窗口程序的类包含一个菜单栏多个工具栏多个锚接部件一个状态栏及一个中心部件是许多应用程序的基础如文本编辑器图片编辑器等菜单栏一个主窗口最多只有一个菜单栏位于主窗口顶部主窗口标题栏下面创建菜单栏通过类的函数获取主窗口菜单栏指针创建菜单调用的成员函数来添加菜单创建菜单项调用的成员函数来添加菜单项并没有专门的菜单项类只是使用一个类抽象出公共的动作当我们把对象添加到菜单就显示成一个菜单项添加到工具栏就显示成一个工具按钮用户可以通过点击菜单项点击工具栏按钮点击快捷键来激活这个动作在中直接生成的只能输入英文因为会自动生成输入英文的对象名但可以在属性表中手动改成中文内容为界面添加右键菜单设置目录策略否则右键无反应然后在编辑界面中右击选择添加函数定义一个右键弹出菜单往菜单内添加该在前面用设计器定义了添加分割线弹出右键菜单菜单位置为光标位置右键菜单点击跳转工具栏主窗口的工具栏上可以有多个工具条通常采用一个菜单对应一个工具条的的方式也可根据需要进行工具条的划分直接调用类的函数获取主窗口的工具条对象每增加一个工具条都需要调用一次该函数插入属于工具条的动作即在工具条上添加操作通过类的函数添加工具条是一个可移动的窗口它的停靠区域由的决定包括停靠在左侧停靠在右侧停靠在顶部停靠在底部以上四个位置都可停靠使用函数指定停靠区域使用函数设定工具栏的可移动性工具条不可移动只能停靠在初始化的位置上即不能操作位置状态栏派生自类使用方法与类似类常用成员函数状态栏也只能最多有一个状态栏无法通过文件拉拽放入控件添加小部件左侧开始右侧开始添加小部件插入小部件删除小部件铆接部件铆接部件也称浮动窗口可以有多个标题设置区域范围他的位置是相对核心部件而言的核心部件中心部件除了以上几个部件中心显示的部件都可以作为核心部件例如一个记事本文件可以利用做核心部件资源文件资源系统是一个跨平台的资源机制用于将程序运行时所需要的资源以二进制的形式存储于可执行文件内部如果你的程序需要加载特定的资源图标文本翻译等那么将其放置在资源文件中就再也不需要担心这些文件的丢失也就是说如果你将资源以资源文件形式存储它是会编译到可执行文件内部使用可以很方便地创建资源文件我们可以在工程上点右键选择添加新文件可以在分类下找到资源文件点击选择按钮打开新建资源文件对话框在这里我们输入资源文件的名字和路径点击下一步选择所需要的版本控制系统然后直接选择完成我们可以在的左侧文件列表中看到资源文件一项也就是我们新创建的资源文件右键点击用编辑的方式打开右侧的编辑区有个添加我们首先需要添加前缀比如我们将前缀取名为然后选中这个前缀继续点击添加文件可以找到我们所需添加的文件这里我们选择文件当我们完成操作之后应该是这样子的接下来我们还可以添加另外的前缀或者另外的文件这取决于你的需要当我们添加完成之后我们可以像前面一章讲解的那样通过使用开头的路径来找到这个文件比如我们的前缀是文件是那么就可以使用找到这个文件使用规则为前缀名文件名这么做带来的一个问题是如果以后我们要更改文件名比如将改成那么所有使用了这个名字的路径都需要修改所以更好的办法是我们给这个文件去一个别名以后就以这个别名来引用这个文件具体做法是选中这个文件添加别名信息这样我们可以直接使用引用到这个资源无需关心图片的真实文件名如果我们使用文本编辑器打开文件就会看到一下内容我们可以对比一下看看帮我们生成的是怎样的文件当我们编译工程之后我们可以在构建目录中找到文件这就是将我们的资源编译成了代码对话框基本概念对话框是程序中不可或缺的组成部分很多不能或者不适合放入主窗口的功能组件都必须放在对话框中设置对话框通常会是一个顶层窗口出现在程序最上层用于实现短期任务或者简洁的用户交互中使用类实现对话框就像主窗口一样我们通常会设计一个类继承及其子类以及所有类型的类的对于其指针都有额外的解释如果为则该对话框会作为一个顶层窗口否则则作为其父组件的子对话框此时其默认出现的位置是的中心顶层窗口与非顶层窗口的区别在于顶层窗口在任务栏会有自己的位置而非顶层窗口则会共享其父组件的位置对话框分为模态对话框和非模态对话框模态对话框就是会阻塞同一应用程序中其它窗口的输入模态对话框很常见比如打开文件功能你可以尝试一下记事本的打开文件当打开文件对话框出现时我们是不能对除此对话框之外的窗口部分进行操作的与此相反的是非模态对话框例如查找对话框我们可以在显示着查找对话框的同时继续对记事本的内容进行编辑标准对话框所谓标准对话框是内置的一系列对话框用于简化开发事实上有很多对话框都是通用的比如打开文件设置颜色打印设置等这些对话框在所有程序中几乎相同因此没有必要在每一个程序中都自己实现这么一个对话框的内置对话框大致分为以下几类选择颜色选择文件或者目录选择字体允许用户输入一个值并将其值返回模态对话框用于显示信息询问问题等为打印机提供纸张相关的选项打印机配置打印预览显示操作过程自定义对话框支持模态对话框和非模态对话框模态与非模态的实现使用实现应用程序级别的模态对话框使用实现窗口级别的模态对话框使用实现非模态对话框模态对话框有两种级别的模态对话框应用程序级别的模态当该种模态的对话框出现时用户必须首先对对话框进行交互直到关闭对话框然后才能访问程序中其他的窗口窗口级别的模态该模态仅仅阻塞与对话框关联的窗口但是依然允许用户与程序中其它窗口交互窗口级别的模态尤其适用于多窗口模式一般默认是应用程序级别的模态在下面的示例中我们调用了将对话框显示出来因此这就是一个模态对话框当对话框出现时我们不能与主窗口进行任何交互直到我们关闭了该对话框非模态对话框下面我们试着将修改为看看非模态对话框是不是事与愿违对话框竟然一闪而过这是因为函数不会阻塞当前线程对话框会显示出来然后函数立即返回代码继续执行注意是建立在栈上的函数返回函数结束超出作用域被析构因此对话框消失了知道了原因就好改了我们将改成堆上建立当然就没有这个问题了如果你足够细心应该发现上面的代码是有问题的存在内存泄露使用在堆上分配空间却一直没有解决方案也很简单将的指针赋给即可还记得我们前面说过的的对象系统吗不过这样做有一个问题如果我们的对话框不是在一个界面类中出现呢由于的必须是指针那就限制了我们不能将一个普通的类指针传给对话框另外如果对内存占用有严格限制的话当我们将主窗口作为时主窗口不关闭对话框就不会被销毁所以会一直占用内存在这种情景下我们可以设置的函数设置对话框关闭时自动销毁对话框消息对话框用于显示消息提示我们一般会使用其提供的几个函数显示关于对话框这是一个最简单的对话框其标题是内容是父窗口是对话框只有一个按钮显示关于对话框该对话框用于显示有关的信息显示严重错误对话框这个对话框将显示一个红色的错误符号我们可以通过参数指明其显示的按钮默认情况下只有一个按钮我们可以使用类型指定多种按钮与类似不同之处在于这个对话框提供一个普通信息图标与类似不同之处在于这个对话框提供一个问号图标并且其显示的按钮是是和否与类似不同之处在于这个对话框提供一个黄色叹号图标我们可以通过下面的代码来演示下如何使用我们使用来询问一个问题这个对话框的父窗口是是的子类这意味着它的初始显示位置将会是在窗口的中央第二个参数是对话框的标题第三个参数是我们想要显示的内容第四个参数是关联的按键类型我们可以使用或运算符指定对话框应该出现的按钮比如我们希望是一个和一个最后一个参数指定默认选择的按钮这个函数有一个返回值用于确定用户点击的是哪一个按钮按照我们的写法应该很容易的看出这是一个模态对话框因此我们可以直接获取其返回值类的函数优点是方便使用缺点也很明显非常不灵活我们只能使用简单的几种形式为了能够定制细节我们必须使用的属性设置如果我们希望制作一个询问是否保存的对话框我们可以使用如下的代码是一个建立在栈上的实例我们设置其主要文本信息为则是会在对话框中显示的简单说明文字下面我们使用了一个也就是详细信息当我们点击了详细信息按钮时对话框可以自动显示更多信息我们自己定义的对话框的按钮有三个保存丢弃和取消然后我们使用了是其成为一个模态对话框根据其返回值进行相应的操作标准文件对话框也就是文件对话框在本节中我们将尝试编写一个简单的文本文件编辑器我们将使用来打开一个文本文件并将修改过的文件保存到硬盘首先我们需要创建一个带有文本编辑功能的窗口借用我们前面的程序代码应该可以很方便地完成我们在菜单和工具栏添加了两个动作打开和保存接下来是一个类这个类用于显示富文本文件也就是说它不仅仅用于显示文本还可以显示图片表格等等不过我们现在只用它显示纯文本文件有一个函数可以将一个组件作为窗口的中心组件放在窗口中央显示区显然在一个文本编辑器中文本编辑区就是这个中心组件因此我们将作为这种组件我们使用函数为这两个对象添加响应的动作下面是最主要的和这两个函数的代码打开文件保存文件在函数中我们使用来获取需要打开的文件的路径这个函数原型如下不过注意它的所有参数都是可选的因此在一定程度上说这个函数也是简单的这六个参数分别是父窗口的标准对话框提供静态函数用于返回一个模态对话框对话框标题对话框打开时的默认目录代表程序运行目录代表当前盘符的根目录特指平台平台当然就是根目录这个参数也可以是平台相关的比如等过滤器我们使用文件对话框可以浏览很多类型的文件但是很多时候我们仅希望打开特定类型的文件比如文本编辑器希望打开文本文件图片浏览器希望打开图片文件过滤器就是用于过滤特定的后缀名如果我们使用则只能显示后缀名是或者的文件如果需要多个过滤器使用分割比如默认选择的过滤器对话框的一些参数设定比如只显示文件夹等等它的取值是每个选项可以使用运算组合起来返回值是选择的文件路径我们将其赋值给通过判断是否为空可以确定用户是否选择了某一文件只有当用户选择了一个文件时我们才执行下面的操作在中使用的也是类似的使用这种静态函数在上面都是直接调用本地对话框但是上则是自己的模拟这暗示了如果你不使用这些静态函数而是直接使用进行设置那么得到的对话框很可能与系统对话框的外观不一致这一点是需要注意的标准颜色对话框默认选择红色标准字体对话框华文彩云返回是否获取成功字体字号是否加粗是否倾斜在工具选项文本编辑器行为中设置了文本编码的默认编码为在工具选项文本编辑器显示勾选了在编码区域右上角会显示文件编码格式此时输出中文信息用调试输出框会乱码但用直接运行则不会不会影响程序发布布局管理器所谓界面归根结底就是一堆组件的叠加我们创建一个窗口把按钮放上面把图标放上面这样就成了一个界面在放置时组件的位置尤其重要我们必须要指定组件放在哪里以便窗口能够按照我们需要的方式进行渲染这就涉及到组件定位的机制提供了两种组件定位机制绝对定位和布局定位绝对定位就是一种最原始的定位方法给出这个组件的坐标和长宽值这样就知道该把组件放在哪里以及如何设置组件的大小但是这样做带来的一个问题是如果用户改变了窗口大小比如点击最大化按钮或者使用鼠标拖动窗口边缘采用绝对定位的组件是不会有任何响应的这也很自然因为你并没有告诉在窗口变化时组件是否要更新自己以及如何更新或者还有更简单的方法禁止用户改变窗口大小但这总不是长远之计布局定位你只要把组件放入某一种布局布局由专门的布局管理器进行管理当需要调整大小或者位置的时候使用对应的布局管理器进行调整布局定位完美的解决了使用绝对定位的缺陷提供的布局中以下三种是我们最常用的按照水平方向从左到右布局按照竖直方向从上到下布局在一个网格中进行布局类似于的系统提供的布局控件这个为系统给我们提供的布局的控件但是使用起来不是非常的灵活这里就不详细介绍了利用做布局第二种布局方式是利用控件里的来做布局在中在中的控件可以进行水平垂直栅格布局等操作比较灵活再布局的同时我们需要灵活运用弹簧的特性让我们的布局更加的美观下面是一个登陆窗口利用可以搭建出如下登陆界面常用控件为我们应用程序界面开发提供的一系列的控件下面我们介绍两种最常用一些控件所有控件的使用方法我们都可以通过帮助文档获取控件使用是我们最常用的控件之一其功能很强大我们可以用来显示文本图片和动画等显示文字普通文本通过类的函数设置显示的内容可以显示普通文本字符串设置字体华文新魏设置位置和大小移动到什么位置可以显示格式的字符串比如显示一个链接百度一下其中函数是用来设置用户点击链接之后是否自动打开链接如果参数指定为则会自动打开显示图片可以使用的成员函数设置图片首先定义对象然后加载图片最后将图片设置到中显示动画可以使用的成员函数加载动画可以播放格式的文件首先定义对象并初始化播放加载的动画将动画设置到中提供的单行文本编辑框设置获取内容获取编辑框内容使用函数声明如下设置编辑框内容设置显示模式使用类的函数设置文本的显示模式函数声明是一个枚举类型一共定义了四种显示模式模式显示方式按照输入的内容显示不显示任何内容此模式下无法看到用户的输入密码模式输入的字符会根据平台转换为特殊字符编辑时显示字符否则显示字符作为密码另外我们再使用显示文本的时候希望在左侧留出一段空白的区域那么就可以使用给我们提供的函数用此函数可以指定显示的文本与输入框上下左右边界的间隔的像素数功能工具按钮常用于显示图片设置显示图片和文件的模式设置透明凸起效果功能单选按钮设置默认选中用区分单选区间功能复选按钮信号参数类型未选中半选中选中功能列表控件按列表显示东西创建项锄禾日当午将项加载到列表控件中设置对齐方式可以一次性放入所有内容等同于锄禾日当午汗滴禾下土谁知盘中餐粒粒皆辛苦功能树控件按树形显示东西设置头英雄英雄简介创建根项目力量将根项目添加到树控件中挂载子项目到根项目中张飞力大无比中通过的来访问嵌套在中的控件功能表格控件按表格显示东西设置列数设置水平表头姓名性别年龄设置行数设置正文行列字符串设置表格选中单个单元格的方式双击修改单个选中和多个选中的设置隐藏列表头先获取字体字体设置为粗体设置每一列的标题字体为粗体隔行变色设置隔行变色的颜色灰色设置字体大小设置初始无焦点防止一开始焦点为第一行导致按删除直接删除第一行必须一关一开才能实现实时变化其他控件栈控件切换栈显示内容下拉框奔驰设置选中拖拉机可以设置绑定值微软读取当前选中绑定值还有许多中控件的使用方法可参考提供的帮助文档自定义控件在搭建窗口界面的时候在一个项目中很多窗口或者是窗口中的某个模块会被经常性的重复使用一般遇到这种情况我们都会将这个窗口或者模块拿出来做成一个独立的窗口类以备以后重复使用在使用的文件搭建界面的时候工具栏栏中只为我们提供了标准的窗口控件如果我们想使用自定义控件怎么办右键项目添加新文件选择中的设计师界面类在文件中设计自定义控件也可以用代码的形式如下例如我们从派生出一个类实现了一个自定窗口创建布局对象将控件添加到布局中将布局设置到窗口中添加消息响应因为有重载版本所以要强转为对应重载版本的指针那么这个可以作为独立的窗口显示也可以作为一个控件来使用打开的文件因为是派生自类所以需要在文件中先放入一个控件然后再上边鼠标右键弹出提升窗口部件对话框添加要提升的类的名字然后选择添加添加之后类名会显示到上边的列表框中然后单击提升按钮完成操作我们可以看到这个窗口对应的类从原来的变成了再次运行程序这个中就能显示出我们自定义的窗口了根据控件名找控件案例根据的名字找到该控件的指针就可以操作他了消息机制和事件事件内含定时器事件是由系统或者本身在不同的时刻发出的当用户按下鼠标敲下键盘或者是窗口需要重新绘制的时候都会发出一个相应的事件一些事件在对用户操作做出响应时发出如键盘事件等另一些事件则是由系统自动发出如计时器事件在前面我们也曾经简单提到程序需要在函数创建一个对象然后调用它的函数这个函数就是开始的事件循环在执行函数之后程序将进入事件循环来监听应用程序的事件当事件发生时将创建一个事件对象中所有事件类都继承于在事件对象创建完毕后将这个事件对象传递给的函数函数并不直接处理事件而是按照事件对象的类型分派给特定的事件处理函数关于这一点会在后边详细说明部分鼠标事件在所有组件的父类中定义了很多事件处理的回调函数如等这些函数都是的也就是说我们可以在子类中重新实现这些函数下面来看一个例子获取鼠标坐标使用对象的和函数继承了覆盖了和三个函数我们并没有添加什么功能只是在鼠标按下鼠标移动和鼠标释放的时候把当前鼠标的坐标值显示在这个上面由于是支持代码的因此我们直接使用了代码来格式化文字的函数可以自动替换掉中出现的占位符其占位符以开始后面是占位符的位置例如这种语句将会使用替换替换因此生成的为在函数中我们使用了另外一种的构造方法我们使用类似风格的格式化函数来构造运行上面的代码当我们点击了一下鼠标之后上将显示鼠标当前坐标值为什么要点击鼠标之后才能在函数中显示鼠标坐标值这是因为中有一个属性该属性用于设置是否追踪鼠标只有鼠标被追踪时才会发出如果是默认即是组件在至少一次鼠标点击之后才能够被追踪也就是能够发出事件如果为则直接可以被发出知道了这一点我们就可以在函数中添加如下代码在运行程序就没有这个问题了定时器定时器使用方法主要有两种定时器事件启动定时器毫秒判断具体定时器标志定时器事件每隔秒让数字每隔秒让数字通过定时器类实现类创建定时器对象开启定时器毫秒每隔毫秒会抛出一个信号出来连接信号处理逻辑暂停定时器创建定时器对象只触发一次的定时器表示谁来执行定时器毫秒后只发送一次该信号这里填入要做什么事件分发器事件对象创建完毕后将这个事件对象传递给的函数函数并不直接处理事件而是将这些事件对象按照它们不同的类型分发给不同的事件处理器如上所述函数主要用于事件的分发所以如果你希望在事件分发之前做一些操作就可以重写这个函数了例如我们希望在一个组件中监听键的按下那么就可以继承并重写它的函数来达到这个目的是一个普通的子类我们重写了它的函数这个函数有一个对象作为参数也就是需要转发的事件对象函数返回值是类型如果传入的事件已被识别并且处理则需要返回否则返回如果返回值是那么会认为这个事件已经处理完毕不会再将这个事件发送给其它对象而是会继续处理事件队列中的下一事件在函数中调用事件对象的和函数是没有作用的不会影响到事件的传播我们可以通过使用函数可以检查事件的实际类型其返回值是类型的枚举我们处理过自己感兴趣的事件之后可以直接返回表示我们已经对此事件进行了处理对于其它我们不关心的事件则需要调用父类的函数继续转发否则这个组件就只能处理我们定义的事件了为了测试这一种情况我们可以尝试下面的代码是的一个子类我们重写了其函数却没有调用父类的同名函数这样我们的组件就只能处理键再也无法输入任何文本也不能响应其它事件比如鼠标点击之后也不会有光标出现这是因为我们只处理的类型的事件并且如果不是事件则直接返回鼠标事件根本不会被转发也就没有了鼠标事件通过查看的实现我们可以理解函数同前面的章节中我们所说的事件处理器有什么联系这是中函数的源代码的版本也是类似的我们可以看到同前面我们所说的一样也是使用判断事件类型然后调用了特定的事件处理器比如如果返回值是则调用函数可以想象中一定会有如下的代码事实也的确如此和这样的函数就是我们前面章节所说的事件处理器也就是说函数中实际是通过事件处理器来响应一个具体的事件这相当于函数将具体事件的处理委托给具体的事件处理器而这些事件处理器是的因此我们重写了某一个事件处理器即可让调用我们自己实现的版本由此可以见是一个集中处理不同类型的事件的地方如果你不想重写一大堆事件处理器就可以重写这个函数通过判断不同的事件鉴于重写函数需要十分小心注意父类的同名函数的调用一不留神就可能出现问题所以一般还是建议只重写事件处理器当然也必须记得是不是应该调用父类的同名处理器这其实暗示了函数的另外一个作用屏蔽掉某些不需要的事件处理器正如我们前面的例子看到的那样我们创建了一个只能响应键的组件这种作用是重写事件处理器所不能实现的事件过滤器有时候对象需要查看甚至要拦截发送到另外对象的事件例如对话框可能想要拦截按键事件不让别的组件接收到或者要修改回车键的默认处理通过前面的章节我们已经知道创建了事件对象之后会调用的函数处理事件的分发显然我们可以在函数中实现拦截的操作由于函数是的因此需要继承已有类如果组件很多就需要重写很多个函数这当然相当麻烦更不用说重写函数还得小心一堆问题好在提供了另外一种机制来达到这一目的事件过滤器有一个函数用于建立事件过滤器函数原型如下这个函数正如其名字显示的那样是一个事件过滤器所谓事件过滤器可以理解成一种过滤代码事件过滤器会检查接收到的事件如果这个事件是我们感兴趣的类型就进行我们自己的处理如果不是就继续转发这个函数返回一个类型如果你想将参数过滤出来比如不想让它继续转发就返回否则返回事件过滤器的调用时间是目标对象也就是参数里面的对象接收到事件对象之前也就是说如果你在事件过滤器中停止了某个事件那么对象以及以后所有的事件过滤器根本不会知道这么一个事件我们来看一段简单的代码区分哪个控件区分事件是我们定义的一个类我们重写了它的函数为了过滤特定组件上的事件首先需要判断这个对象是不是我们感兴趣的组件然后判断这个事件的类型在上面的代码中我们不想让组件处理键盘按下的事件所以首先我们找到这个组件如果这个事件是键盘事件则直接返回也就是过滤掉了这个事件其他事件还是要继续处理所以返回对于其它的组件我们并不保证是不是还有过滤器于是最保险的办法是调用父类的函数函数相当于创建了过滤器然后我们需要安装这个过滤器安装过滤器需要调用函数函数的原型如下这个函数接受一个类型的参数记得刚刚我们说的函数是的一个成员函数因此任意都可以作为事件过滤器问题在于如果你没有重写函数这个事件过滤器是没有任何作用的因为默认什么都不会过滤已经存在的过滤器则可以通过函数移除我们可以向一个对象上面安装多个事件处理器只要调用多次函数如果一个对象存在多个事件过滤器那么最后一个安装的会第一个执行也就是后进先执行的顺序还记得我们前面的那个例子吗我们使用函数处理了键现在我们可以给出一个使用事件过滤器的版本事件过滤器的强大之处在于我们可以为整个应用程序添加一个事件过滤器记得函数是的函数或者对象都是的子类因此我们可以向或者添加事件过滤器这种全局的事件过滤器将会在所有其它特性对象的事件过滤器之前调用尽管很强大但这种行为会严重降低整个应用程序的事件分发效率因此除非是不得不使用的情况否则的话我们不应该这么做注意事件过滤器和被安装过滤器的组件必须在同一线程否则过滤器将不起作用另外如果在安装过滤器之后这两个组件到了不同的线程那么只有等到二者重新回到同一线程的时候过滤器才会有效总结的事件是整个框架的核心机制之一也比较复杂说它复杂更多是因为它涉及到的函数众多而处理方法也很多有时候让人难以选择现在我们简单总结一下中的事件机制中有很多种事件鼠标事件键盘事件大小改变的事件位置移动的事件等等如何处理这些事件实际有两种选择所有事件对应一个事件处理函数在这个事件处理函数中用一个很大的分支语句进行选择其代表作就是的函数在这个函数中我们需要使用语句选择参数的类型进行处理典型代码是每一种事件对应一个事件处理函数就是使用的这么一种机制具有这么多种事件处理函数肯定有一个地方对其进行分发否则怎么知道哪一种事件调用哪一个事件处理函数呢这个分发的函数就是显然当产生之后函数将其分发给事件处理器进行处理函数会有两个问题函数是一个的函数这意味着我们要想重写必须继承一个已有的类试想我的程序根本不想要鼠标事件程序中所有组件都不允许处理鼠标事件是不是我得继承所有组件一一重写其函数函数带来的另外一个问题是如果我基于第三方库进行开发而对方没有提供源代码只有一个链接库其它都是封装好的我怎么去继承这种库中的组件呢函数的确有一定的控制不过有时候我的需求更严格一些我希望那些组件根本看不到这种事件函数虽然可以拦截但其实也是接收到了对象我连让它收都收不到这样做的好处是模拟一种系统根本没有那个事件的效果所以其它组件根本不会收到这个事件也就无需修改自己的事件处理函数这种需求怎么办呢这两个问题是函数无法处理的于是提供了另外一种解决方案事件过滤器事件过滤器给我们一种能力让我们能够完全移除某种事件事件过滤器可以安装到任意类型上面并且可以安装多个如果要实现全局的事件过滤器则可以安装到或者上面这里需要注意的是如果使用函数给一个对象安装事件过滤器那么该事件过滤器只对该对象有效只有这个对象的事件需要先传递给事件过滤器的函数进行过滤其它对象不受影响如果给对象安装事件过滤器那么该过滤器对程序中的每一个对象都有效任何对象的事件都是先传给函数事件过滤器可以解决刚刚我们提出的函数的两点不足首先事件过滤器不是的因此我们可以向任何子类安装事件过滤器其次事件过滤器在目标对象接收到事件之前进行处理如果我们将事件过滤掉目标对象根本不会见到这个事件事实上还有一种方法我们没有介绍事件的调用最终都会追溯到函数因此最大的控制权实际上是重写这个函数的声明是该函数会将发送给也就是调用其返回值就是来自的事件处理器注意这个函数为任意线程的任意对象的任意事件调用因此它不存在事件过滤器的线程的问题不过我们并不推荐这么做因为函数只有一个而事件过滤器要灵活得多现在我们可以总结一下的事件处理实际上是有五个层次重写等事件处理函数这是最普通最简单的形式同时功能也最简单重写函数函数是所有对象的事件入口和中的实现默认是把事件传递给特定的事件处理函数在特定对象上面安装事件过滤器该过滤器仅过滤该对象接收到的事件在上面安装事件过滤器该过滤器将过滤所有对象的所有事件因此和函数一样强大但是它更灵活因为可以安装多个过滤器全局的事件过滤器可以看到组件上面发出的鼠标事件全局过滤器有一个问题只能用在主线程重写函数这是最强大的和全局事件过滤器一样提供完全控制并且不受线程的限制但是全局范围内只能有一个被使用因为是单例的自定义事件事件的分发既可以是同步的又可以是异步的而信号槽的回调总是同步的并且事件可以使用过滤器自定义事件的类型自定义事件需要继承提供一个类型的参数作为自定义事件的类型值是定义的一个枚举需要注意的是自定义事件类型不能和已经存在的值重复否则会有不可预料的错误发生因为系统会将新增加的自定义事件当做系统事件进行派发和调用中系统保留的值自定义事件的要大于定义了两个边界值和自定义事件的应该在两个值的范围之间其中的值是的值是通过这两个枚举值可以保证自定义的事件类型不会覆盖系统定义的事件类型但并不能保证自定义事件相互之间不会被覆盖为了避免自定义事件间的相互覆盖提供了一个函数用于自定义事件的注册函数是的可以使用类直接调用函数返回值是向系统注册的新的类型的值如果是合法的即不会发生任何覆盖系统的以及其它自定义事件的则会直接返回这个值否则系统会自动分配一个合法值并返回使用函数即可完成值的指定函数是线程安全的不必另外添加同步事件的发送方式可以在自定义事件中添加所需要的数据然后进行事件的发送提供了两种事件发送方式非阻塞式发送直接将事件发送给接收者使用的是函数函数返回值就是事件处理函数的返回值在事件被发送的时候对象并不会被销毁通常会在栈上创建对象例如阻塞式发送将事件及其接收者一同追加到事件队列中函数立即返回因为事件队列会持有事件对象并且在其的时候将其掉因此必须在堆上创建对象当对象被发送之后再试图访问对象就会出现问题因为后对象就会被当控制权返回到主线程循环时保存在事件队列中的所有事件都通过函数发送出去事件会根据的顺序进行处理如果想要改变事件的处理顺序可以考虑为其指定一个优先级默认的优先级是函数是线程安全的函数的作用是将事件队列中的接收者为事件类似为的所有事件立即发送给进行处理需要注意的是来自窗口系统的事件并不由函数进行处理而是自定义事件处理函数自定义事件的处理既可以定义一个自定义事件处理函数也可以在函数中直接处理绘图和绘图设备的绘图系统允许使用相同的在屏幕和其它打印设备上进行绘制整个绘图系统基于和三个类用来执行绘制的操作是一个二维空间的抽象这个二维空间允许在其上面进行绘制也就是工作的空间提供了画笔在不同的设备上进行绘制的统一的接口类应用于和之间通常对开发人员是透明的除非你需要自定义一个设备否则你是不需要关心这个类的我们可以把理解成画笔把理解成使用画笔的地方比如纸张屏幕等而对于纸张屏幕而言肯定要使用不同的画笔绘制为了统一使用一种画笔我们设计了类这个类让不同的纸张屏幕都能使用一种画笔下图给出了这三个类之间的层次结构上面的示意图告诉我们的绘图系统实际上是使用在上进行绘制它们之间使用进行通讯也就是翻译的指令下面我们通过一个实例来介绍的使用绘图事件注意我们重写了的函数接下来就是的源代码在构造函数中我们仅仅设置了窗口的大小和标题而函数则是绘制的代码首先我们在栈上创建了一个对象也就是说每次运行函数的时候都会重建这个对象注意这一点可能会引发某些细节问题由于我们每次重建因此第一次运行时所设置的画笔颜色状态等第二次再进入这个函数时就会全部丢失有时候我们希望保存画笔状态就必须自己保存数据否则的话则需要将作为类的成员变量接收一个指针作为参数有很多子类比如以及注意回忆一下可以理解成要在哪里去绘制而现在我们希望画在这个组件因此传入的是指针有很多以开头的函数用于各种图形的绘制比如这里的以及等当绘制轮廓线时使用的属性比如我们调用了将设置为红色则下面绘制的矩形具有红色的轮廓线接下来我们将修改为绿色像素宽又设置了画刷为蓝色这时候再调用函数则是具有绿色像素宽轮廓线蓝色填充的椭圆高级设置设置抗锯齿移动起始点本来默认是左上角保存起始点起始点位置取出起始点起始点位置手动调用绘图事件中和的区别方法这种方法其实是将重绘的事件加入到的事件列表中不一定马上就会重绘得出你想要的效果在同一时刻你要是多次调用会将它们自动合并为一个这样的好处是不会产生闪烁方法这个方法是立即重绘但是不建议经常使用只需要在需要的特效区域调用即可绘图设备绘图设备是指继承的子类提供了很多这样的类例如和其中专门为图像在屏幕上的显示做了优化是的一个子类它的色深限定为可以使用的函数来确定这个是不是一个专门为图像的像素级访问做了优化则可以记录和重现的各条命令此并非图片而是类似记录和还原一个绘图流程继承了因此你可以使用直接在上面绘制图形也可以接受一个字符串作为一个文件的路径来显示这个文件比如你想在程序之中打开之类的文件就可以使用使用的函数可以把这个文件绘制到一个或者其他的设备上面是针对屏幕进行特殊优化的因此它与实际的底层显示设备息息相关注意这里说的显示设备并不是硬件而是操作系统提供的原生的绘图引擎所以在不同的操作系统平台下的显示可能会有所差别继承自因此具有的所有特性提供单色图像的色深始终为色深这个概念来自计算机图形学是指用于表现颜色的二进制的位数我们知道计算机里面的数据都是使用二进制表示的为了表示一种颜色我们也会使用二进制比如我们要表示种颜色需要用个二进制位这时我们就说色深是因此所谓色深为也就是使用个二进制位表示颜色个位只有两种状态和因此它所表示的颜色就有两种黑和白所以说实际上是只有黑白两色的图像数据由于色深小因此只占用很少的存储空间所以适合做光标文件和笔刷下面我们来看同一个图像文件在和下的不同表现这里我们给出了两张图片是没有透明色的纯白背景而是具有透明色的背景我们分别使用和来加载它们注意看它们的区别白色的背景在中消失了而透明色在中转换成了黑色其他颜色则是使用点的疏密程度来体现的使用底层平台的绘制系统进行绘制无法提供像素级别的操作而则是使用独立于硬件的绘制系统实际上是自己绘制自己因此提供了像素级别的操作并且能够在不同系统之上提供一个一致的显示形式我们声明了一个对象大小是颜色模式是即使用位数值表示一个颜色的值也就是说每种颜色使用位然后我们对每个像素进行颜色赋值从而构成了这个图像我们可以把想象成一个颜色的二维数组记录了每一像素的颜色将图片背景填充为白色改变指定区域的像素点的值红色将图片绘制到窗口中与的区别主要是用于绘图针对屏幕显示而最佳化设计主要是为图像图片访问和像素修改而设计的依赖于所在的平台的绘图引擎故例如反锯齿等一些效果在不同的平台上可能会有不同的显示效果使用自身的绘图引擎可在不同平台上具有相同的显示效果由于是独立于硬件的也是一种因此我们可以在另一个线程中对其进行绘制而不需要在线程中处理使用这一方式可以很大幅度提高响应速度可通过和等方法直接存取指定的像素与之间的转换转使用的静态成员函数转使用类的成员函数最后一个需要说明的是这是一个可以记录和重现命令的绘图设备将的命令序列化到一个设备保存为一个平台独立的文件格式这种格式有时候会是元文件的这种格式是二进制的不同于某些本地的元文件的文件没有内容上的限制只要是能够被绘制的元素不论是字体还是或者是变换都可以保存进一个中是平台无关的因此它可以使用在多种设备之上比如打印机或者屏幕回忆下我们这里所说的实际上是说可以有绘制的对象使用系统的分辨率并且可以调整来消除不同设备之间的显示差异如果我们要记录下的命令首先要使用函数将实例作为参数传递进去以便告诉系统开始记录记录完毕后使用命令终止代码示例如下将图像绘制到中并保存到文件后缀是什么都可以将保存的绘图动作重新绘制到设备上文件系统文件操作是应用程序必不可少的部分作为一个通用开发库提供了跨平台的文件操作能力通过提供了对设备的抽象这些设备具有读写字节块的能力下面是设备的类图所有设备类的父类提供了字节块读写的通用操作以及基本接口新增加的类提供了有关文件操作的通用实现访问本地文件或者嵌入资源创建和访问本地文件系统的临时文件读写内存文件运行外部程序处理进程间通讯所有套接字类的父类协议网络数据传输传输报文使用传输数据文件系统分类顺序访问设备是指它们的数据只能访问一遍从头走到尾从第一个字节开始访问直到最后一个字节中途不能返回去读取上一个字节这其中和是顺序访问设备随机访问设备可以访问任意位置任意次数还可以使用函数来重新定位文件访问位置指针和是随机访问设备基本文件操作文件操作是应用程序必不可少的部分作为一个通用开发库提供了跨平台的文件操作能力在所有的设备中文件是最重要的部分之一因为我们大多数的程序依旧需要首先访问本地文件当然在云计算大行其道的将来这一观点可能改变提供了从文件中读取和写入数据的能力我们通常会将文件路径作为参数传给的构造函数不过也可以在创建好对象最后使用来修改需要使用作为文件分隔符不过它会自动将其转换成操作系统所需要的形式例如这样的路径在平台下同样是可以的主要提供了有关文件的各种操作比如打开文件关闭文件刷新文件等我们可以使用或类来读写文件也可以使用类提供的以及这样的函数值得注意的是有关文件本身的信息比如文件名文件所在目录的名字等则是通过获取而不是自己分析文件路径字符串下面我们使用一段代码来看看的有关操作下面可以直接用取代循环判断文件是否读到末尾读出来的类型是类型关闭文件对象我们首先使用创建了一个文件对象这个文件名字是如果你不知道应该把它放在哪里可以使用来获得应用程序执行时的当前路径只要将这个文件放在与当前路径一致的目录下即可使用函数打开这个文件打开形式是只读方式文本格式这个类似于的这样的参数函数返回一个类型如果打开失败我们在控制台输出一段提示然后程序退出否则我们利用循环将每一行读到的内容输出可以使用文件路径获取有关该文件的信息有很多类型的函数我们只举出一些例子比如检查该文件是否是目录检查该文件是否是可执行文件等可以直接获得文件名获取完整的文件名则直接获取文件后缀名获取完整的文件后缀文件大小文件名文件路径创建日期返回值为需要使用函数转为自己指定的输出格式修改日期返回值为需要使用函数转为自己指定的输出格式我们可以由下面的示例看到和以及和的区别注意类型可以转换字符编码格式如下将格式的类型对象转换为编码格式二进制文件读写提供了基于的二进制数据的序列化数据流是一种二进制流这种流完全不依赖于底层操作系统或者字节顺序大端或小端例如在安装了平台的上面写入的一个数据流可以不经过任何处理直接拿到运行了的机器上读取由于数据流就是二进制流因此我们也可以直接读写没有编码的二进制数据例如图像视频音频等既能够存取基本类型如等也可以存取复杂的数据类型例如自定义的类实际上对于类的存储是将复杂的类分割为很多基本单元实现的结合可以很方便地对文件网络套接字等进行读写操作我们从代码开始看起在这段代码中我们首先打开一个名为的文件注意我们为简单起见并没有检查文件打开是否成功这在正式程序中是不允许的然后我们将刚刚创建的对象的指针传递给一个实例类似于标准输出流也重载了输出重定向运算符后面的代码就很简单了将和数字输出到数据流由于我们的对象建立在之上因此相当于将问题和答案写入需要指出一点最好使用整型来进行读写比如程序中的这保证了在任意平台和任意编译器都能够有相同的行为如果你直接运行这段代码你会得到一个空白的并没有写入任何数据这是因为我们的没有正常关闭为性能起见数据只有在文件关闭时才会真正写入因此我们必须在最后添加一行代码如果不想关闭文件可以使用接下来我们将存储到文件中的答案取出来唯一需要注意的是你必须按照写入的顺序将数据读取出来顺序颠倒的话程序行为是不确定的严重时会直接造成程序崩溃那么既然提供了之类的函数为什么还要有呢同有什么区别区别在于提供流的形式性能上一般比直接调用原始更好一些我们通过下面一段代码看看什么是流的形式文本文件读写上一节我们介绍了有关二进制文件的读写二进制文件比较小巧却不是人可读的格式而文本文件是一种人可读的文件为了操作这种文件我们需要使用类和的使用类似只不过它是操作纯文本文件的会自动将编码同操作系统的编码进行转换这一操作对开发人员是透明的它也会将换行符进行转换同样不需要自己处理使用位的作为基础的数据存储单位同样它也支持标准类型如等实际上这是将这种标准类型与字符串进行了相互转换同的使用基本一致例如下面的代码将把写入到文件中这里我们在函数中增加了打开方式我们可以从下表中看到这些打开方式的区别枚举值描述未打开以只读方式打开以只写方式打开以读写方式打开以追加的方式打开新增加的内容将被追加到文件末尾以重写的方式打开在写入新的数据时会将原有数据全部清除游标设置在文件开头在读取时将行结束符转换成在写入时将行结束符转换成本地格式例如平台上是忽略缓存我们在这里使用了也就是以只写并且覆盖已有内容的形式操作文件注意会直接将文件内容清空虽然的写入内容与一致但是读取时却会有些困难在使用的时候这样的代码很方便但是使用了时却有所不同读出的时候里面将是是这是因为当使用写入的时候实际上会在要写入的内容前面额外添加一个这段内容的长度值而以文本形式写入数据是没有数据之间的分隔的因此使用文本文件时很少会将其分割开来读取而是使用诸如使用读取一行读取所有文本这种函数之后再对获得的对象进行处理默认情况下的编码格式是不是如果我们需要使用另外的编码可以使用这样的函数进行设置简单的动画效果创建动画对象设置动画时间间隔设置起始位置设置结束位置设置弹起效果意思是设置移动轨迹帮助文档中查让动画执行参数为设置动画停止后释放动画对象帧动画参考添加音效使用前提头文件模块文件首先类似图片添加进资源文件夹音效在资源中的路径可以设置重复多少次设置表示重复无限次开始音效优化细节可复用的各场景间转移通过和来进行如果要毁灭只用一次的场景直接各场景之间的场景转移同步位置设置到前一个场景的同一个位置和简述在开发中往往需要在界面中存储一些有用的数据这些数据可以来自配置文件注册表数据库或者是无论来自哪里这些数据对于用户来说都是至关重要的它们在交互过程中大部分都会被用到例如单击一个用户头像显示该用户的详细信息等级昵称姓名个人说明常见接口中可以通过绝大部分已有的接口来存数数据获取数据例如存储数据获取数据多线程在进行桌面应用程序开发的时候假设应用程序在某些情况下需要处理比较复杂的逻辑如果只有一个线程去处理就会导致窗口卡顿无法处理用户的相关操作这种情况下就需要使用多线程其中一个线程处理窗口事件其他线程进行逻辑运算多个线程各司其职不仅可以提高用户体验还可以提升程序的执行效率在中使用了多线程有些事项是需要额外注意的默认的线程在中称之为窗口线程也叫主线程负责窗口事件处理或者窗口控件数据的更新子线程负责后台的业务逻辑处理子线程中不能对窗口对象做任何操作这些事情需要交给窗口线程处理主线程和子线程之间如果要进行数据的传递需要使用中的信号槽机制线程类中提供了一个线程类通过这个类就可以创建子线程了中一共提供了两种创建子线程的方式后边会依次介绍其使用方式先来看一下这个类中提供的一些常用函数常用共用成员函数类常用构造函数判断线程中的任务是不是处理完毕了判断子线程是不是在执行任务中的线程可以设置优先级得到当前线程的优先级优先级最低的优先级最高的优先级默认是这个退出线程停止底层的事件循环退出线程的工作函数调用线程退出函数之后线程不会马上退出因为当前任务有可能还没有完成调回用这个函数是等待任务完成然后退出线程一般情况下会在后边调用这个函数信号槽和调用效果是一样的代用这个函数之后再调用函数启动子线程线程退出可能是会马上终止线程一般情况下不使用这个函数线程中执行的任务完成了发出该信号任务函数中的处理逻辑执行完毕了开始工作之前发出这个信号一般不使用静态函数返回一个指向管理当前执行线程的的指针返回可以在系统上运行的理想线程数和当前电脑的核心数相同线程休眠函数单位毫秒单位秒单位微秒任务处理函数子线程要处理什么任务需要写到中这个是一个虚函数如果想让创建的子线程执行某个任务需要写一个子类让其继承并且在子类中重写父类的方法函数体就是对应的任务处理流程另外这个函数是一个受保护的成员函数不能够在类的外部调用如果想要让线程执行这个函数中的业务流程需要通过当前线程对象调用槽函数启动子线程当子线程被启动这个函数也就在线程内部被调用了出来的对象的释放等同于第一种创建子线程操作步骤需要创建一个线程类的子类让其继承中的线程类比如重写父类的方法在该函数内部编写子线程要处理的具体的业务流程在主线程中创建子线程对象一个就可以了启动子线程调用方法不能在类的外部调用方法启动子线程在外部调用相当于让开始运行当子线程别创建出来之后父子线程之间的通信可以通过信号槽的方式注意事项在中在子线程中不要操作程序中的窗口类型对象不允许如果操作了程序就挂了只有主线程才能操作程序中的窗口对象默认的线程就是主线程自己创建的就是子线程示例代码举一个简单的数数的例子假如只有一个线程让其一直数数会发现数字并不会在窗口中时时更新并且这时候如果用户使用鼠标拖动窗口就会出现无响应的情况使用多线程就不会出现这样的现象了在下面的窗口中点击按钮开始在子线程中数数让后通过信号槽机制将数据传递给线程通过线程将数据更新到窗口中自定义信号传递数据当前线程对象的地址执行完毕子线程退出主线程对象地址创建子线程启动子线程这种在程序中添加子线程的方式是非常简单的但是也有弊端假设要在一个子线程中处理多个任务所有的处理逻辑都需要写到函数中这样该函数中的处理逻辑就会变得非常混乱不太容易维护第二种创建子线程的方式操作步骤提供的第二种线程的创建方式弥补了第一种方式的缺点用起来更加灵活但是这种方式写起来会相对复杂一些其具体操作步骤如下创建一个新的类让这个类从派生在这个类中添加一个公共的成员函数函数体就是我们要子线程中执行的业务逻辑函数名自己指定叫什么都可以参数可以根据实际需求添加在主线程中创建一个对象这就是子线程的对象在主线程中创建工作的类对象千万不要指定给创建的对象指定父对象将对象移动到创建的子线程对象中需要调用类提供的方法如果给指定了父对象这个函数调用就失败了提示移动到子线程中工作启动子线程调用这时候线程启动了但是移动到线程中的对象并没有工作调用类对象的工作函数让这个函数开始执行这时候是在移动到的那个子线程中运行的示例代码假设函数处理上面在程序中数数的这个需求具体的处理代码如下工作函数当前线程对象的地址执行完毕子线程退出主线程对象的地址创建线程对象创建工作的类对象千万不要指定给创建的对象指定父对象如果指定了将工作的类对象移动到创建的子线程对象中启动线程让工作的对象开始工作点击开始按钮开始工作显示数据使用这种多线程方式假设有多个不相关的业务流程需要被处理那么就可以创建多个类似于的类将业务流程放多类的公共成员函数中然后将这个业务类的实例对象移动到对应的子线程中就可以了这样可以让编写的程序更加灵活可读性更强更易于维护线程池线程池的原理我们使用线程的时候就去创建一个线程这样实现起来非常简便但是就会有一个问题如果并发的线程数量很多并且每个线程都是执行一个时间很短的任务就结束了这样频繁创建线程就会大大降低系统的效率因为频繁创建线程和销毁线程需要时间那么有没有一种办法使得线程可以复用就是执行完一个任务并不被销毁而是可以继续执行其他的任务呢线程池是一种多线程处理形式处理过程中将任务添加到队列然后在创建线程后自动启动这些任务线程池线程都是后台线程每个线程都使用默认的堆栈大小以默认的优先级运行并处于多线程单元中如果某个线程在托管代码中空闲如正在等待某个事件则线程池将插入另一个辅助线程来使所有处理器保持繁忙如果所有线程池线程都始终保持繁忙但队列中包含挂起的工作则线程池将在一段时间后创建另一个辅助线程但线程的数目永远不会超过最大值超过最大值的线程可以排队但他们要等到其他线程完成后才启动在各个编程语言的语种中都有线程池的概念并且很多语言中直接提供了线程池作为程序猿直接使用就可以了下面给大家介绍一下线程池的实现原理线程池的组成主要分为个部分这三部分配合工作就可以得到一个完整的线程池任务队列存储需要处理的任务由工作的线程来处理这些任务通过线程池提供的函数将一个待处理的任务添加到任务队列或者从任务队列中删除已处理的任务会被从任务队列中删除线程池的使用者也就是调用线程池函数往任务队列中添加任务的线程就是生产者线程工作的线程任务队列任务的消费者个线程池中维护了一定数量的工作线程他们的作用是是不停的读任务队列从里边取出任务并处理工作的线程相当于是任务队列的消费者角色如果任务队列为空工作的线程将会被阻塞使用条件变量信号量阻塞如果阻塞之后有了新的任务由生产者将阻塞解除工作线程开始工作管理者线程不处理任务队列中的任务个它的任务是周期性的对任务队列中的任务数量以及处于忙状态的工作线程个数进行检测当任务过多的时候可以适当的创建一些新的工作线程当任务过少的时候可以适当的销毁一些工作的线程在中使用线程池需要先创建任务添加到线程池中的每一个任务都需要是一个类型因此在程序中需要创建子类继承这个类然后重写方法在这个函数中编写要在线程池中执行的任务并将这个子类对象传递给线程池这样任务就可以被线程池中的某个工作的线程处理掉了类常用函数不多主要是设置任务对象传给线程池后是否需要自动析构在子类中必须要重写的函数里边是任务的处理流程参数设置为这个任务对象在线程池中的线程中处理完毕这个任务对象就会自动销毁参数设置为这个任务对象在线程池中的线程中处理完毕对象需要程序猿手动销毁获取当然任务对象的析构方式返回自动析构返回手动析构创建一个要添加到线程池中的任务类处理方式如下任务执行完毕该对象自动销毁在上面的示例中类是一个多重继承如果需要在这个任务中使用的信号槽机制进行数据的传递就必须继承这个类如果不使用信号槽传递数据就可以不继承了只继承即可任务执行完毕该对象自动销毁中的类管理了一组里边还维护了一个任务队列管理和回收各个对象以帮助减少使用线程的程序中的线程创建成本每个应用程序都有一个全局对象可以通过调用来访问它也可以单独创建一个对象使用线程池常用的函数如下获取和设置线程中的最大线程个数给线程池添加任务任务是一个类型的对象如果线程池中没有空闲的线程了任务会放到任务队列中等待线程处理如果线程池中没有空闲的线程了直接返回值任务添加失败任务不会添加到任务队列中线程池中被激活的线程的个数正在工作的线程个数尝试性的将某一个任务从线程池的任务队列中删除如果任务已经开始执行就无法删除了将线程池中的任务队列里边没有开始处理的所有任务删除如果已经开始处理了就无法通过该函数删除了在每个应用程序中都有一个全局的线程池对象通过这个函数直接访问这个对象一般情况下我们不需要在程序中创建线程池对象直接使用为每个应用程序提供的线程池全局对象即可得到线程池对象之后调用方法就可以将一个任务添加到线程池中这个任务就可以被线程池内部的线程池处理掉了使用线程池比自己创建线程的这种多种多线程方式更加简单和易于维护示例代码任务执行完毕该对象自动销毁业务处理代码线程池初始化设置最大线程池数添加任务因为设置了自动释放所以无需自己释放接受原生消息处理重写函数头文件中源文件中类型转换此处的结构也可用来代替自定义消息举例收到目标消息返回值为表示该事件还会继续向上传递被其他捕获添加图标如果使用来生成文件只需要在中添加是图标名添加有多种方式可以实现动态链接方式实现创建头文件为创建一个头文件声明所有需要导入的函数定义结构体物理内存大小物理地址映射后的线性地址物理内存句柄定义函数指针类型修改确保项目能够找到并链接到添加目录加这个复制和文件动态获取想要使用的函数直接使用错误无法加载错误代码获取函数地址错误无法获取函数地址错误代码以管理员启动修改添加清单文件的配置在中添加清单文件添加清单文件清单文件添加创建清单文件用于声明应用程序的各种属性和要求这里指定程序需要管理员权限添加用于将文件嵌入到可执行文件中修改添加资源编译命令编码用到的头文件磁盘上有格式的文件读到内存字符串数组对象文档对象写入磁盘写入的字符串解析数组解析对象将支持的数据类型进行了封装得到一个完整案例写到文件将转换为讲对象转换为对象文件操作将写入文件读文件到读取文件到解析格式将转换为递归解析打印打印将对象转换为对象创建一个对象子子对象插入子对象插入数组写入磁盘读取磁盘文件打印对象的编码加解密相关编码何为编码使用类编码解码要解码的字符串中的类型转换西欧编码不支持中文编码格式跟随操作系统编码不能直接转通过中的编码转换转转换平台运行时的编码的中文字符串为格式转换平台运行时的编码的中文字符串为格式如下将格式的类型对象转换为编码格式数据库开发数据库数据库数据笔记跳转使用打开根目录目录下面的修改文件之后再重新编译就会发现编译通过了这时候我们在安装的根目录下面去找会发现里面有一个文件夹将其复制到的下面即可开发将库放到下面的目录下根目录头文件用到的头文件头文件包含下面头文件加载数据库驱动查看支持的驱动输出结果为加载数据库驱动设置账号密码设置账号和密码信息使用类的成员函数使用方法如下所示设置主机的地址设置数据库名设置用户名设置密码其实上面这几步就类似于登录数据库需要的关键信息打开数据库函数原型详情查看帮助手册使用方法如下所示数据库操作失败关闭数据库操作数据库数据库操作错误打印执行查询操作类的构造函数该构造函数都有默认值构造的时候可以不指定执行语句两种方法查询失败结果集记录数和字段数查询字段数字段数就是查询列数方法先调用类的方法然后在调用类的方法查询结果字段总数为查询记录数记录数就是查询行数方法调用类的方法查询结果记录总数为遍历结果集获取每一条记录通过列的索引位置获取列的值列的索引从开始通过列名获取列的值移动指向结果集的位置指针为编号如移动到结果集的开始位置每次都会使记录指针移动一次可以使用函数重置指针位置类似于文件指针执行操作直接插入插入失败直接调用并将语句作为参数也可以直接插入插入失败占位符插入使用带有占位符的语句该语句不是一个完整的语句需要调用函数给占位符设置值给字段设置值字段位置索引从开始插入失败注意占位符操作如果函数第二个传参传单引号不会报错但插入的内容会变成一串数字执行操作直接直接调用并将语句作为参数执行占位符使用带有占位符占位符的语句执行操作直接直接调用并将语句作为参数执行占位符使用带有占位符的语句事务处理开启事务设置自动提交和手动提交默认情况下是自动提交的手动提交自动提交事务的提交和回滚操作提交回滚测试案例测试方法先开启一个新的事务并设置为手动提交然后插入数据最后回滚看数据是否已经插入到数据库中然后在修改为提交查看数据是否已经插入到数据库中手动提交回滚事务提交事务开发是一款开源轻量级的数据库软件不需要不支持远程连接可以集成在其他软件中非常适合嵌入式系统的小型数据库以上版本可以直接使用自带驱动中开发环境仅需要头文件就可以直接进行开发文件中添加可以很轻易创建出数据库每个数据库以一个文件方式存在电脑上连接该数据库时使用指定文件路径连接文件对应的数据库查询案例数据库操作失败数据库连接成功更多相关代码可参考此处中的涉及到三个主要的类类允许应用程序发送网络请求和接受网络应答都是围绕着一个对象构造的这个对象包含着发送请求的一些通用配置和设置它包含着代理和缓存的配置以及和这些事物相关的一些信号并且应答信号可以作为我们检测一个网络操作的进度一个对于一整个应用程序来说已经足够了类是的一部分这个类包含着在网络上发送请求的必要信息一旦一个对象被创建了那么应用程序就可以使用它在网络上发送请求它提供了一组标准的函数可以承载网络请求和一些可选的数据并且每一个请求返回一个对象该返回的对象包含着返回的请求应带的所有数据中的使用使用这个类进行请求的发送连接服务器相关的信息返回值通过类接受服务器发送回来的数据连接服务器相关的信息文件指针需要让该指针打开一个设备内的数据作为请求体传递给服务器这里的参数是一个指向的指针是中所有设备的基类包括文件内存缓冲区网络连接等这意味着你可以使用任何从派生的类如等作为数据源当你调用这个版本的函数时会从提供的读取数据并将这些数据作为请求的主体发送到服务器这对于发送大量数据或者从网络流中直接读取数据非常有用连接服务器相关的信息作为请求体传递给服务器的数据在中你可以使用等处理的来创建一个对象然后使用方法将对象转换为然后你可以将这个作为参数传递给函数连接服务器相关的信息带分界线的数据块对应协议中的网络编程中的详解跳转网络编程协议跳转参考协议详解储存连接服务器相关的信息包含服务器和端口信息请求数据对应的指令指定发送的数据块的格式设置的函数连接如因为方式提交请求请求数据也在中如指定发送的数据块的格式标准请求头请求头的数据类型数据长度重定向身份标识请求头的值指定发送的数据块的格式自定义请求头基本同上这个对象会帮助检测服务器是否有数据会发如果有就发送信号它继承自类使用它内部的函数对即服务器返回的数据进行读写类似于读文件如相关信号示例程序发起请求接收数据根据字符串格式进行解析得到原始数据业务上的逻辑判断打包发布切成版本进行运行将版本生成的放在待发布文件夹中的中打开对应文件夹通过命令打包的绝对路径发布成功此时可通过第三方工具例如再进一步封装成安装包设置图标方法点击跳转的对应地址版本编译器名下可以把要打包的应用程序直接拖拽到可执行文件上省去输入命令的步骤实测使用套件构建的项目直接运行会有问题的一些问题中文图片资源问题报错原因资源文件中包含中文命名的图片文件将含有中文命名的图片文件从资源文件中移除执行在重新添加有中文图片的文件再重新编译就不会出错了注意如果添加含有中文命名的图片文件再执行重新构建会报错即此时必须直接构建安装参考',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-12-13 11:56:16',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://th.bing.com/th/id/OIP.wtmjepfWPBvn26uz7s18dgHaHa?rs=1&amp;pid=ImgDetMain"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">ZEROKO14的个人博客</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size: 1.05rem;">C#<sup>2</sup></a><a href="/tags/C/" style="font-size: 1.05rem;">C++<sup>5</sup></a><a href="/tags/CSS/" style="font-size: 1.05rem;">CSS<sup>1</sup></a><a href="/tags/CSharp/" style="font-size: 1.05rem;">CSharp<sup>1</sup></a><a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 1.05rem;">C语言<sup>1</sup></a><a href="/tags/FPS/" style="font-size: 1.05rem;">FPS<sup>1</sup></a><a href="/tags/HTML/" style="font-size: 1.05rem;">HTML<sup>1</sup></a><a href="/tags/JavaScript/" style="font-size: 1.05rem;">JavaScript<sup>1</sup></a><a href="/tags/MFC/" style="font-size: 1.05rem;">MFC<sup>1</sup></a><a href="/tags/PE/" style="font-size: 1.05rem;">PE<sup>1</sup></a><a href="/tags/QT/" style="font-size: 1.05rem;">QT<sup>1</sup></a><a href="/tags/WPF/" style="font-size: 1.05rem;">WPF<sup>2</sup></a><a href="/tags/ai/" style="font-size: 1.05rem;">ai<sup>1</sup></a><a href="/tags/cmake/" style="font-size: 1.05rem;">cmake<sup>1</sup></a><a href="/tags/doxygen/" style="font-size: 1.05rem;">doxygen<sup>1</sup></a><a href="/tags/git/" style="font-size: 1.05rem;">git<sup>1</sup></a><a href="/tags/json/" style="font-size: 1.05rem;">json<sup>1</sup></a><a href="/tags/linux/" style="font-size: 1.05rem;">linux<sup>1</sup></a><a href="/tags/nas/" style="font-size: 1.05rem;">nas<sup>1</sup></a><a href="/tags/next/" style="font-size: 1.05rem;">next<sup>1</sup></a><a href="/tags/ppt/" style="font-size: 1.05rem;">ppt<sup>1</sup></a><a href="/tags/slidev/" style="font-size: 1.05rem;">slidev<sup>1</sup></a><a href="/tags/vue/" style="font-size: 1.05rem;">vue<sup>1</sup></a><a href="/tags/xml/" style="font-size: 1.05rem;">xml<sup>1</sup></a><a href="/tags/yaml/" style="font-size: 1.05rem;">yaml<sup>1</sup></a><a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 1.05rem;">代码规范<sup>1</sup></a><a href="/tags/%E5%86%85%E6%A0%B8/" style="font-size: 1.05rem;">内核<sup>2</sup></a><a href="/tags/%E5%86%85%E6%A0%B8%E7%9B%B8%E5%85%B3/" style="font-size: 1.05rem;">内核相关<sup>5</sup></a><a href="/tags/%E5%8A%A0%E8%A7%A3%E5%AF%86/" style="font-size: 1.05rem;">加解密<sup>1</sup></a><a href="/tags/%E5%9F%BA%E7%A1%80/" style="font-size: 1.05rem;">基础<sup>2</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 1.05rem;">多线程<sup>1</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F/" style="font-size: 1.05rem;">并发模式<sup>1</sup></a><a href="/tags/%E5%BC%80%E5%8F%91/" style="font-size: 1.05rem;">开发<sup>4</sup></a><a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 1.05rem;">数学<sup>1</sup></a><a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 1.05rem;">正则表达式<sup>1</sup></a><a href="/tags/%E7%9B%91%E6%8E%A7/" style="font-size: 1.05rem;">监控<sup>1</sup></a><a href="/tags/%E7%A1%AC%E7%BC%96%E7%A0%81/" style="font-size: 1.05rem;">硬编码<sup>1</sup></a><a href="/tags/%E7%AE%A1%E7%90%86/" style="font-size: 1.05rem;">管理<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 1.05rem;">网络<sup>3</sup></a><a href="/tags/%E9%80%86%E5%90%91/" style="font-size: 1.05rem;">逆向<sup>2</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/02/"><span class="card-archive-list-date">二月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/12/"><span class="card-archive-list-date">十二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/11/"><span class="card-archive-list-date">十一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/09/"><span class="card-archive-list-date">九月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">七月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">14</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/06/"><span class="card-archive-list-date">六月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/04/"><span class="card-archive-list-date">四月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">十一月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">27</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url">技术</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/QT/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>QT</span></a></span></div></div><h1 class="post-title" itemprop="name headline">QT入门</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-11-24T02:51:09.098Z" title="发表于 2023-11-24 10:51:09">2023-11-24</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-12-13T03:56:16.129Z" title="更新于 2024-12-13 11:56:16">2024-12-13</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="QT入门"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为新加坡"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>新加坡</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://che77a38.github.io/posts/QT/"><header><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url">技术</a><a href="/tags/QT/" tabindex="-1" itemprop="url">QT</a><h1 id="CrawlerTitle" itemprop="name headline">QT入门</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">ZEROKO14</span><time itemprop="dateCreated datePublished" datetime="2023-11-24T02:51:09.098Z" title="发表于 2023-11-24 10:51:09">2023-11-24</time><time itemprop="dateCreated datePublished" datetime="2024-12-13T03:56:16.129Z" title="更新于 2024-12-13 11:56:16">2024-12-13</time></header><h1 id="Qt概述"><a href="#Qt概述" class="headerlink" title="Qt概述"></a>Qt概述</h1><h2 id="什么是Qt"><a href="#什么是Qt" class="headerlink" title="什么是Qt"></a>什么是Qt</h2><p>Qt是一个<strong>跨平台</strong>的C++<strong>图形用户界面应用程序框架</strong>。它为应用程序开发者提供建立艺术级图形界面所需的所有功能。它是完全面向对象的，很容易扩展，并且允许真正的组件编程。</p>
<span id="more"></span>

<h2 id="Qt的发展史"><a href="#Qt的发展史" class="headerlink" title="Qt的发展史"></a>Qt的发展史</h2><p>1991年 Qt最早由奇趣科技开发</p>
<p>1996年 进入商业领域，它也是目前流行的Linux桌面环境KDE的基础</p>
<p>2008年 奇趣科技被诺基亚公司收购，Qt称为诺基亚旗下的编程语言</p>
<p>2012年 Qt又被Digia公司收购</p>
<p>2014年4月 跨平台的集成开发环境Qt Creator3.1.0发布，同年5月20日配发了Qt5.3正式版，至此Qt实现了对iOS、Android、WP等各平台的全面支持。</p>
<p>当前Qt最新版本为 5.9.0(现在已经不是了)</p>
<h2 id="支持的平台"><a href="#支持的平台" class="headerlink" title="支持的平台"></a>支持的平台</h2><ul>
<li><p>Windows – XP、Vista、Win7、Win8、Win2008、Win10</p>
</li>
<li><p>Uinux&#x2F;X11 – Linux、Sun Solaris、HP-UX、Compaq Tru64 UNIX、IBM AIX、SGI IRIX、FreeBSD、BSD&#x2F;OS、和其他很多X11平台</p>
</li>
<li><p>Macintosh – Mac OS X</p>
</li>
<li><p>Embedded – 有帧缓冲支持的嵌入式Linux平台，Windows CE</p>
</li>
</ul>
<h2 id="Qt版本"><a href="#Qt版本" class="headerlink" title="Qt版本"></a>Qt版本</h2><p>Qt按照不同的版本发行，分为商业版和开源版</p>
<ul>
<li>商业版</li>
</ul>
<blockquote>
<p>为商业软件提供开发，他们提供传统商业软件发行版，并且提供在商业有效期内的免费升级和技术支持服务。</p>
</blockquote>
<ul>
<li>开源的LGPL版本：</li>
</ul>
<blockquote>
<p>为了开发自有而设计的开放源码软件，它提供了和商业版本同样的功能，在GNU通用公共许可下，它是免费的。</p>
</blockquote>
<h2 id="Qt的下载与安装"><a href="#Qt的下载与安装" class="headerlink" title="Qt的下载与安装"></a>Qt的下载与安装</h2><blockquote>
<p>由于从 5.4 开始 Qt 主要采用 LGPL v3 授权，而 LGPLv3 明确禁止封闭嵌入式设备分发 LGPLv3 授权的软件，所以在嵌入式下不能使用 Qt 5.4 以及以上的版本进行商用，当然 Qt 5.3 以及以下的版本还是可以。</p>
</blockquote>
<h3 id="下载地址："><a href="#下载地址：" class="headerlink" title="下载地址："></a>下载地址：</h3><p><a target="_blank" rel="noopener" href="http://www.qt.io/download-open-source/">http://www.qt.io/download-open-source/</a></p>
<h4 id="Linux-Host"><a href="#Linux-Host" class="headerlink" title="Linux Host"></a>Linux Host</h4><ul>
<li><p><a target="_blank" rel="noopener" href="http://download.qt.io/official_releases/qt/5.5/5.5.0/qt-opensource-linux-x86-5.5.0.run">Qt 5.5.0 for Linux 32-bit (535 MB)    (info)</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://download.qt.io/official_releases/qt/5.5/5.5.0/qt-opensource-linux-x64-5.5.0-2.run">Qt 5.5.0 for Linux 64-bit (532 MB)    (info)</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://download.qt.io/official_releases/qt/5.5/5.5.0/qt-opensource-linux-x64-android-5.5.0-2.run">Qt 5.5.0 for Android (Linux 64-bit, 605 MB)    (info)</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://download.qt.io/official_releases/qt/5.5/5.5.0/qt-opensource-linux-x86-android-5.5.0.run">Qt 5.5.0 for Android (Linux 32-bit, 608 MB)    (info)</a></p>
</li>
</ul>
<h4 id="OS-X-Host"><a href="#OS-X-Host" class="headerlink" title="OS X Host"></a>OS X Host</h4><ul>
<li><p><a target="_blank" rel="noopener" href="http://download.qt.io/official_releases/qt/5.5/5.5.0/qt-opensource-mac-x64-clang-5.5.0.dmg.mirrorlist">Qt 5.5.0 for Mac (588 MB)    (info)</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://download.qt.io/official_releases/qt/5.5/5.5.0/qt-opensource-mac-x64-android-5.5.0.dmg">Qt 5.5.0 for Android (Mac, 652 MB)    (info)</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://download.qt.io/official_releases/qt/5.5/5.5.0/qt-opensource-mac-x64-android-ios-5.5.0.dmg">Qt 5.5.0 for Android and iOS (Mac, 1.7 GB)    (info)</a></p>
</li>
</ul>
<h4 id="Windows-Host"><a href="#Windows-Host" class="headerlink" title="Windows Host"></a>Windows Host</h4><ul>
<li><a target="_blank" rel="noopener" href="http://download.qt.io/official_releases/qt/5.5/5.5.0/qt-opensource-windows-x86-msvc2013_64-5.5.0.exe">Qt 5.5.0 for Windows 64-bit (VS 2013, 650 MB)    (info)</a></li>
<li><a target="_blank" rel="noopener" href="http://download.qt.io/official_releases/qt/5.5/5.5.0/qt-opensource-windows-x86-msvc2013-5.5.0.exe">Qt 5.5.0 for Windows 32-bit (VS 2013, 633 MB)    (info)</a></li>
<li><a target="_blank" rel="noopener" href="http://download.qt.io/official_releases/qt/5.5/5.5.0/qt-opensource-windows-x86-msvc2012-5.5.0.exe">Qt 5.5.0 for Windows 32-bit (VS 2012, 587 MB)    (info)</a></li>
<li><a target="_blank" rel="noopener" href="http://download.qt.io/official_releases/qt/5.5/5.5.0/qt-opensource-windows-x86-msvc2010-5.5.0.exe">Qt 5.5.0 for Windows 32-bit (VS 2010, 585 MB)    (info)</a></li>
<li><a target="_blank" rel="noopener" href="http://download.qt.io/official_releases/qt/5.5/5.5.0/qt-opensource-windows-x86-mingw492-5.5.0.exe">Qt 5.5.0 for Windows 32-bit (MinGW 4.9.2, 959 MB)    (info)</a></li>
<li><a target="_blank" rel="noopener" href="http://download.qt.io/official_releases/qt/5.5/5.5.0/qt-opensource-windows-x86-android-5.5.0.exe">Qt 5.5.0 for Android (Windows 32-bit, 1.0 GB)    (info)</a></li>
<li><a target="_blank" rel="noopener" href="http://download.qt.io/official_releases/qt/5.5/5.5.0/qt-opensource-windows-x86-winrt-5.5.0.exe">Qt 5.5.0 for Windows RT 32-bit (621 MB)    (info)</a></li>
</ul>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>默认安装（建议组件全部选中）</p>
<ul>
<li>Qt对不同的平台提供了不同版本的安装包，可根据实际情况自行下载安装，本文档使用<strong>qt-opensource-windows-x86-mingw482_opengl-5.3.1</strong> 版本进行讲解(mingw482<br>：UTF-8编码，中文不会乱码)</li>
</ul>
<h2 id="Qt的优点"><a href="#Qt的优点" class="headerlink" title="Qt的优点"></a>Qt的优点</h2><ul>
<li><p>跨平台，几乎支持所有的平台</p>
</li>
<li><p>接口简单，容易上手，学习QT框架对学习其他框架有参考意义。</p>
</li>
<li><p>一定程度上简化了内存回收机制</p>
</li>
<li><p>开发效率高，能够快速的构建应用程序。</p>
</li>
<li><p>有很好的社区氛围，市场份额在缓慢上升。</p>
</li>
<li><p>可以进行嵌入式开发。</p>
</li>
</ul>
<h2 id="成功案例"><a href="#成功案例" class="headerlink" title="成功案例"></a>成功案例</h2><ul>
<li>Linux桌面环境KDE</li>
<li>WPS Office 办公软件</li>
<li>Skype 网络电话</li>
<li>Google Earth 谷歌地图</li>
<li>VLC多媒体播放器</li>
<li>VirtualBox虚拟机软件</li>
<li>…</li>
</ul>
<h2 id="QT中常用默认快捷键"><a href="#QT中常用默认快捷键" class="headerlink" title="QT中常用默认快捷键"></a>QT中常用默认快捷键</h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>ctrl+i</td>
<td>格式化选中代码</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="创建Qt项目"><a href="#创建Qt项目" class="headerlink" title="创建Qt项目"></a>创建Qt项目</h1><h2 id="使用向导创建"><a href="#使用向导创建" class="headerlink" title="使用向导创建"></a>使用向导创建</h2><p>打开Qt Creator 界面选择 New Project或者选择菜单栏 【文件】-【新建文件或项目】菜单项</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps37.jpg" alt="img"></p>
<p>弹出New Project对话框，选择Qt Widgets Application，</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps56.jpg" alt="img"></p>
<p>选择【Choose】按钮，弹出如下对话框</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps82.jpg" alt="img"></p>
<p>设置项目名称和路径，按照向导进行下一步，</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps125.jpg" alt="img"></p>
<p>选择编译套件</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps145.jpg" alt="img"></p>
<p>向导会默认添加一个继承自CMainWindow的类，可以在此修改类的名字和基类。默认的基类有QMainWindow、QWidget以及QDialog三个，我们可以选择QWidget（类似于空窗口），这里我们可以先创建一个不带UI的界面，继续下一步</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps169.jpg" alt="img"></p>
<p>系统会默认给我们添加main.cpp、mywidget.cpp、 mywidget.h和一个.pro项目文件，点击完成，即可创建出一个Qt桌面程序。</p>
<h2 id="手动创建"><a href="#手动创建" class="headerlink" title="手动创建"></a>手动创建</h2><p>添加一个空项目</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps188.jpg" alt="img"></p>
<p>选择【choose】进行下一步。设置项目名称和路径 —&gt; 选择编译套件 –&gt; 修改类信息 –&gt; 完成（步骤同上），生成一个空项目。在空项目中添加文件：在项目名称上单击鼠标右键弹出右键菜单，选择【添加新文件】</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps201.jpg" alt="img"></p>
<p>弹出新建文件对话框</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps235.jpg" alt="img"></p>
<p>在此对话框中选择要添加的类或者文件，根据向导完成文件的添加。</p>
<h2 id="pro文件"><a href="#pro文件" class="headerlink" title=".pro文件"></a>.pro文件</h2><p>在使用Qt向导生成的应用程序.pro文件格式如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#包含的模块</span></span><br><span class="line">QT += core gui </span><br><span class="line"></span><br><span class="line"><span class="comment">#大于Qt4版本 才包含widget模块</span></span><br><span class="line">greaterThan(QT_MAJOR_VERSION, 4): QT += widgets </span><br><span class="line"></span><br><span class="line"><span class="comment">#应用程序名 生成的.exe程序名称</span></span><br><span class="line">TARGET = QtFirst </span><br><span class="line"></span><br><span class="line"><span class="comment">#模板类型 应用程序模板</span></span><br><span class="line">TEMPLATE = app </span><br><span class="line"></span><br><span class="line"><span class="comment">#源文件</span></span><br><span class="line">SOURCES += main.cpp\ </span><br><span class="line"></span><br><span class="line">mywidget.cpp</span><br><span class="line"></span><br><span class="line"><span class="comment">#头文件</span></span><br><span class="line">HEADERS += mywidget.h </span><br></pre></td></tr></table></figure>

<p><strong>.pro就是工程文件(project)，它是qmake自动生成的用于生产makefile的配置文件</strong>。.pro文件的写法如下：</p>
<ul>
<li><p>注释</p>
<p>从”#”开始，到这一行结束。</p>
</li>
<li><p>模板变量告诉qmake为这个应用程序生成哪种makefile。下面是可供使用的选择：<strong>TEMPLATE</strong> &#x3D; app</p>
</li>
<li><p>app -建立一个应用程序的makefile。这是默认值，所以如果模板没有被指定，这个将被使用。</p>
</li>
<li><p>lib - 建立一个库的makefile。</p>
</li>
<li><p>vcapp - 建立一个应用程序的VisualStudio项目文件。</p>
</li>
<li><p>vclib - 建立一个库的VisualStudio项目文件。</p>
</li>
<li><p>subdirs -这是一个特殊的模板，它可以创建一个能够进入特定目录并且为一个项目文件生成makefile并且为它调用make的makefile。</p>
</li>
<li><p>#指定生成的应用程序名：</p>
<p><strong>TARGET</strong> &#x3D; QtDemo</p>
</li>
<li><p>#工程中包含的头文件</p>
<p><strong>HEADERS</strong> +&#x3D; include&#x2F;painter.h</p>
</li>
<li><p>#工程中包含的.ui设计文件</p>
<p><strong>FORMS</strong> +&#x3D; forms&#x2F;painter.ui</p>
</li>
<li><p>#工程中包含的源文件</p>
<p><strong>SOURCES</strong> +&#x3D; sources&#x2F;main.cpp sources</p>
</li>
<li><p>#工程中包含的资源文件</p>
<p><strong>RESOURCES</strong> +&#x3D; qrc&#x2F;painter.qrc</p>
</li>
<li><p><strong>greaterThan(QT_MAJOR_VERSION, 4): QT +&#x3D; widgets</strong></p>
<p><strong>这条语句的含义是，如果QT_MAJOR_VERSION大于4（也就是当前使用的Qt5及更高版本）需要增加widgets模块。如果项目仅需支持Qt5，也可以直接添加”QT +&#x3D; widgets”一句。不过为了保持代码兼容，最好还是按照QtCreator生成的语句编写。</strong></p>
<p>![Qt5 模块](<a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/che77a38/blogImage/Qt5">https://cdn.jsdelivr.net/gh/che77a38/blogImage/Qt5</a> 模块.png)</p>
</li>
<li><p>#配置信息</p>
<p>CONFIG用来告诉qmake关于应用程序的配置信息。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG += c+<span class="number">+11</span> <span class="comment">//使用c++11的特性</span></span><br></pre></td></tr></table></figure>

<p>在这里使用”+&#x3D;”，是因为我们添加我们的配置选项到任何一个已经存在中。这样做比使用”&#x3D;”那样替换已经指定的所有选项更安全。</p>
</li>
</ul>
<h2 id="一个最简单的Qt应用程序"><a href="#一个最简单的Qt应用程序" class="headerlink" title="一个最简单的Qt应用程序"></a>一个最简单的Qt应用程序</h2><p>main入口函数中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">	Widget w;</span><br><span class="line">	w.<span class="built_in">show</span>();</span><br><span class="line">	<span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/%E6%8D%95%E8%8E%B7.PNG" alt="捕获"></p>
<p>解释：</p>
<ul>
<li><p>Qt系统提供的标准类名声明头文件没有.h后缀</p>
</li>
<li><p>Qt一个类对应一个头文件，类名就是头文件名</p>
</li>
<li><p>QApplication应用程序类</p>
<ul>
<li><p>管理图形用户界面应用程序的控制流和主要设置。</p>
</li>
<li><p>是Qt的整个后台管理的命脉它<strong>包含主事件循环</strong>，在其中来自窗口系统和其它资源的<strong>所有事件处理和调度</strong>。它也处理<strong>应用程序的初始化和结束</strong>，并且<strong>提供对话管理</strong>。</p>
</li>
<li><p>对于任何一个使用Qt的图形用户界面应用程序，都正好存在一个QApplication 对象，而不论这个应用程序在同一时间内是不是有0、1、2或更多个窗口。</p>
</li>
</ul>
</li>
<li><p>a.exec()</p>
<p><strong>程序进入消息循环</strong>，等待对用户输入进行响应。这里main()把控制权转交给Qt，Qt完成事件处理工作，当应用程序退出的时候exec()的值就会返回。<strong>在exec()中，Qt接受并处理用户和系统的事件并且把它们传递给适当的窗口部件。</strong></p>
</li>
</ul>
<h1 id="命名规范和QT的快捷键"><a href="#命名规范和QT的快捷键" class="headerlink" title="命名规范和QT的快捷键"></a>命名规范和QT的快捷键</h1><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210425133943997.png" alt="image-20210425133943997"></p>
<ul>
<li><code>alt +enter</code> &#x2F;&#x2F; 自动创建类的定义</li>
</ul>
<h1 id="第一个QT（对象模型和坐标系）"><a href="#第一个QT（对象模型和坐标系）" class="headerlink" title="第一个QT（对象模型和坐标系）"></a>第一个QT（对象模型和坐标系）</h1><h2 id="按钮的创建"><a href="#按钮的创建" class="headerlink" title="按钮的创建"></a>按钮的创建</h2><p>在Qt程序中，最常用的控件之一就是按钮了，首先我们来看下如何创建一个按钮</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">QPushButton * btn = <span class="keyword">new</span> QPushButton; <span class="comment">//头文件 #include &lt;QPushButton&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置父亲</span></span><br><span class="line">btn-&gt;<span class="built_in">setParent</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置文字</span></span><br><span class="line">btn-&gt;<span class="built_in">setText</span>(<span class="string">&quot;德玛西亚&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//移动位置</span></span><br><span class="line">btn-&gt;<span class="built_in">move</span>(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种创建</span></span><br><span class="line">QPushButton * btn2 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;孙悟空&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//重新指定窗口大小</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">resize</span>(<span class="number">600</span>,<span class="number">400</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置窗口标题</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setWindowTitle</span>(<span class="string">&quot;第一个项目&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//限制窗口大小</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setFixedSize</span>(<span class="number">600</span>,<span class="number">400</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，一个按钮其实就是一个QPushButton类下的对象，如果只是创建出对象，是无法显示到窗口中的(独立显示到一个窗口中)，所以我们需要依赖一个父窗口，也就是指定一个父亲利用setParent函数即可，如果想设置按钮上显示的文字利用setText，移动按钮位置用move</p>
<p>对于窗口而言，我们可以修改左上角窗口的标题setWindowTitle，重新指定窗口大小：resize，或者设置固定的窗口大小setFixedSize；</p>
<h2 id="对象模型（对象树）"><a href="#对象模型（对象树）" class="headerlink" title="对象模型（对象树）"></a>对象模型（对象树）</h2><p>在Qt中创建对象的时候会提供一个Parent对象指针，下面来解释这个parent到底是干什么的。</p>
<ul>
<li><p>QObject是以对象树的形式组织起来的。</p>
<ul>
<li>当你创建一个QObject对象时，会看到QObject的构造函数接收一个QObject指针作为参数，这个参数就是 parent，也就是父对象指针。</li>
</ul>
</li>
</ul>
<blockquote>
<p>这相当于，<strong>在创建QObject对象时，可以提供一个其父对象，我们创建的这个QObject对象会自动添加到其父对象的children()列表。</strong></p>
</blockquote>
<ul>
<li><strong>当父对象析构的时候，这个列表中的所有对象也会被析构。（注意，这里的父对象并不是继承意义上的父类！）</strong></li>
</ul>
<blockquote>
<p>这种机制在 GUI 程序设计中相当有用。例如，一个按钮有一个QShortcut（快捷键）对象作为其子对象。当我们删除按钮的时候，这个快捷键理应被删除。这是合理的。</p>
</blockquote>
<ul>
<li><p>QWidget是能够在屏幕上显示的一切组件的父类。</p>
<ul>
<li><p><strong>QWidget继承自QObject，因此也继承了这种对象树关系。一个孩子自动地成为父组件的一个子组件</strong>。因此，它会显示在父组件的坐标系统中，被父组件的边界剪裁。例如，当用户关闭一个对话框的时候，应用程序将其删除，那么，我们希望属于这个对话框的按钮、图标等应该一起被删除。事实就是如此，因为这些都是对话框的子组件。</p>
</li>
<li><p>当然，<strong>我们也可以自己删除子对象，它们会自动从其父对象列表中删除。</strong>比如，当我们删除了一个工具栏时，其所在的主窗口会自动将该工具栏从其子对象列表中删除，并且自动调整屏幕显示。</p>
</li>
</ul>
</li>
</ul>
<p>Qt 引入对象树的概念，在一定程度上解决了内存问题。</p>
<ul>
<li><p>当一个QObject对象在堆上创建的时候，Qt 会同时为其创建一个对象树。不过，<strong>对象树中对象的顺序是没有定义</strong>的。这意味着，销毁这些对象的顺序也是未定义的。</p>
</li>
<li><p>任何对象树中的 QObject对象 delete 的时候，如果这个对象有 parent，则自动将其从 parent 的children()列表中删除；如果有孩子，则自动 delete 每一个孩子。Qt 保证没有QObject会被 delete 两次，这是由析构顺序决定的。</p>
</li>
</ul>
<p>如果QObject在栈上创建，Qt 保持同样的行为。正常情况下，这也不会发生什么问题。来看下下面的代码片段：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	QWidget window;</span><br><span class="line">	<span class="function">QPushButton <span class="title">quit</span><span class="params">(<span class="string">&quot;Quit&quot;</span>, &amp;window)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作为父组件的 window 和作为子组件的 quit 都是QObject的子类（事实上，它们都是QWidget的子类，而QWidget是QObject的子类）。这段代码是正确的，quit 的析构函数不会被调用两次，因为标准 C++要求，<strong>局部对象的析构顺序应该按照其创建顺序的相反过程</strong>。因此，这段代码在超出作用域时，会先调用 quit 的析构函数，将其从父对象 window 的子对象列表中删除，然后才会再调用 window 的析构函数。</p>
<p>但是，如果我们使用下面的代码：（注意：重点）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="function">QPushButton <span class="title">quit</span><span class="params">(<span class="string">&quot;Quit&quot;</span>)</span></span>;</span><br><span class="line">	QWidget window;</span><br><span class="line">	quit.<span class="built_in">setParent</span>(&amp;window);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>情况又有所不同，析构顺序就有了问题。我们看到，在上面的代码中，作为父对象的 window 会首先被析构，因为它是最后一个创建的对象。在析构过程中，它会调用子对象列表中每一个对象的析构函数，也就是说， quit 此时就被析构了。然后，代码继续执行，在 window 析构之后，quit 也会被析构，因为 quit 也是一个局部变量，在超出作用域的时候当然也需要析构。但是，这时候已经是<strong>第二次调用 quit 的析构函数</strong>了，C++ 不允许调用两次析构函数，因此，<strong>程序崩溃了</strong>。</p>
<p>由此我们看到，Qt 的对象树机制虽然帮助我们在一定程度上解决了内存问题，但是也引入了一些值得注意的事情。这些细节在今后的开发过程中很可能时不时跳出来烦扰一下，所以，我们最好从开始就养成良好习惯，<strong>在 Qt 中，尽量在构造的时候就指定 parent 对象</strong>，并且大胆在堆上创建。</p>
<p>QT对象树的意义：<strong>简化了内存回收机制</strong></p>
<p><em>Qt</em>内存自动释放有两个前提条件: 1. 必须是QObject的派生类 2. 必须指定了parent对象</p>
<hr>
<p>其<strong>构造与析构顺序</strong>如下图（重难点）（析构函数内代码与真正析构释放过程相反）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/Qt%E5%AF%B9%E8%B1%A1%E6%A0%91.png" alt="Qt对象树"></p>
<p><strong>【注意】</strong>widget和继承于QPushButton的mypushbutton类的析构中分别添加输出</p>
<p>widget.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mypushbutton.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    mypushbutton* a=<span class="keyword">new</span> <span class="built_in">mypushbutton</span>();</span><br><span class="line">    a-&gt;<span class="built_in">setParent</span>(<span class="keyword">this</span>);</span><br><span class="line">    a-&gt;<span class="built_in">setText</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget::~<span class="built_in">Widget</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;~widget&quot;</span>;<span class="comment">//！！！！！！！！！！！！！！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mypushbutton.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mypushbutton.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line">mypushbutton::<span class="built_in">mypushbutton</span>(QWidget *parent) : <span class="built_in">QPushButton</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">mypushbutton::~<span class="built_in">mypushbutton</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;~mypushbutton&quot;</span>;<span class="comment">//！！！！！！！！！！！！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210425210702298.png" alt="image-20210425210702298"></p>
<p><strong>【重点】</strong>由此可知：<strong>析构函数内代码的运行，是由上至下，而真正的析构释放过程是由下至上的。</strong></p>
<h2 id="Qt窗口坐标体系"><a href="#Qt窗口坐标体系" class="headerlink" title="Qt窗口坐标体系"></a>Qt窗口坐标体系</h2><p>坐标体系：</p>
<p>以左上角为原点（0,0），X向右增加，Y向下增加。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps16.jpg" alt="img"></p>
<p>对于嵌套窗口，其坐标是<strong>相对于父窗口</strong>来说的。</p>
<h1 id="信号和槽机制"><a href="#信号和槽机制" class="headerlink" title="信号和槽机制"></a>信号和槽机制</h1><blockquote>
<p>信号和槽是对象间的一种通信机制</p>
</blockquote>
<p>信号槽是 Qt 框架引以为豪的机制之一。所谓信号槽，实际就是观察者模式。<strong>当某个事件发生之后</strong>，比如，按钮检测到自己被点击了一下，<strong>它就会发出一个信号（signal）</strong>。这种发出是没有目的的，类似广播。<strong>如果有对象对这个信号感兴趣，它就会使用连接（connect）函数</strong>，意思是，<strong>将想要处理的信号和自己的一个函数（称为槽（slot））绑定来处理这个信号</strong>。也就是说，<strong>当信号发出时，被连接的槽函数会自动被回调</strong>。这就类似观察者模式：当发生了感兴趣的事件，某一个操作就会被自动触发。</p>
<p>一图流：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/Qt%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD%20.png" alt="Qt信号和槽 "></p>
<h2 id="系统自带的信号和槽"><a href="#系统自带的信号和槽" class="headerlink" title="系统自带的信号和槽"></a>系统自带的信号和槽</h2><p>下面我们完成一个小功能，上面我们已经学习了按钮的创建，但是还没有体现出按钮的功能，按钮最大的功能也就是点击后触发一些事情，比如我们点击按钮，就把当前的窗口给关闭掉，那么在Qt中，这样的功能如何实现呢？</p>
<p>其实无法两行代码就可以搞定了，我们看下面的代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QPushButton * quitBtn = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;关闭窗口&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line"><span class="built_in">connect</span>(quitBtn,&amp;QPushButton::clicked,<span class="keyword">this</span>,&amp;MyWidget::close);</span><br></pre></td></tr></table></figure>

<p>第一行是创建一个关闭按钮，这个之前已经学过，第二行就是核心了，也就是信号槽的使用方式</p>
<p>connect()函数最常用的一般形式：<br>$$<br>connect(sender, signal, receiver, slot);<br>$$<br>参数解释：</p>
<ul>
<li><p>sender：发出信号的对象</p>
</li>
<li><p>signal：发送对象发出的信号</p>
</li>
<li><p>receiver：接收信号的对象</p>
</li>
<li><p>slot：接收对象在接收到信号之后所需要调用的函数（槽函数）</p>
</li>
</ul>
<p>那么系统自带的信号和槽通常如何查找呢，这个就需要利用帮助文档了，在帮助文档中比如我们上面的按钮的点击信号，在帮助文档中输入QPushButton，首先我们可以在Contents中寻找关键字 signals，信号的意思，但是我们发现并没有找到，这时候我们应该想到也许这个信号的被父类继承下来的，因此我们去他的父类QAbstractButton中就可以找到该关键字，点击signals索引到系统自带的信号有如下几个</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps39.jpg" alt="img"></p>
<p>这里的clicked就是我们要找到，槽函数的寻找方式和信号一样，只不过他的关键字是slot。</p>
<h2 id="自定义信号和槽"><a href="#自定义信号和槽" class="headerlink" title="自定义信号和槽"></a>自定义信号和槽</h2><p>使用connect()可以让我们连接系统提供的信号和槽。但是，Qt 的信号槽机制并不仅仅是使用系统提供的那部分，还会允许我们自己设计自己的信号和槽。</p>
<p>下面我们看看使用 Qt 的信号槽：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先定义一个学生类和老师类：</span></span><br><span class="line"><span class="comment">//老师类中声明信号 饿了 hungry</span></span><br><span class="line">signals:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hungury</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//学生类中声明槽 请客 treat</span></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">treat</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//在窗口中声明一个公共方法下课，这个方法的调用会触发老师饿了这个信号，而响应槽函数学生请客</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyWidget::ClassIsOver</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//发送信号</span></span><br><span class="line">	emit teacher-&gt;<span class="built_in">hungury</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//学生响应了槽函数，并且打印信息</span></span><br><span class="line"><span class="comment">//自定义槽函数 实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::eat</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;该吃饭了！&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在窗口中连接信号槽</span></span><br><span class="line">teacher = <span class="keyword">new</span> <span class="built_in">Teacher</span>(<span class="keyword">this</span>);</span><br><span class="line">student = <span class="keyword">new</span> <span class="built_in">Student</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="built_in">connect</span>(teacher,&amp;Teacher::hungury,student,&amp;Student::treat);</span><br><span class="line"><span class="comment">//并且调用下课函数，测试打印出 &quot;该吃饭了&quot;</span></span><br><span class="line"><span class="comment">//================下面是重载版的信号和槽=============================</span></span><br><span class="line"><span class="comment">//自定义的信号 hungry带参数，需要提供重载的自定义信号和 自定义槽</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hungury</span><span class="params">(QString name)</span></span>; <span class="comment">//自定义信号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">treat</span><span class="params">(QString name )</span></span>; <span class="comment">//自定义槽</span></span><br><span class="line"><span class="comment">//但是由于有两个重名的自定义信号和自定义的槽，直接连接会报错，所以需要利用函数指针来指向函数地址， 然后再再做连接</span></span><br><span class="line"><span class="built_in">void</span> (Teacher:: * teacherSingal)(QString) = &amp;Teacher::hungury;</span><br><span class="line"><span class="built_in">void</span> (Student:: * studentSlot)(QString) = &amp;Student::treat;</span><br><span class="line"><span class="built_in">connect</span>(teacher,teacherSingal,student,studentSlot);</span><br><span class="line"><span class="comment">//p.s.QString转char*是先.toUtf8()转为QByteArray类型，再.data()转为char*类型</span></span><br></pre></td></tr></table></figure>

<p><strong>自定义信号槽需要注意的事项：</strong></p>
<ul>
<li><strong>发送者和接收者都需要是QObject的子类（当然，槽函数是全局函数、Lambda 表达式等无需接收者的时候除外）；</strong></li>
<li><strong>信号和槽函数返回值是 void</strong></li>
<li><strong>信号只需要声明，不需要实现</strong></li>
<li><strong>槽函数需要声明也需要实现</strong></li>
<li><strong>槽函数是普通的成员函数，作为成员函数，会受到 public、private、protected 的影响；</strong></li>
<li><strong>使用 emit 在恰当的位置发送信号；</strong></li>
<li><strong>使用connect()函数连接信号和槽。</strong></li>
<li><strong>任何成员函数、static 函数、全局函数和 Lambda 表达式都可以作为槽函数（QT5以上才可以，QT4必须写到private slots:下）</strong></li>
<li><strong>信号槽要求信号和槽的参数一致，所谓一致，是参数类型一致。</strong></li>
<li><strong>如果信号和槽的参数不一致，允许的情况是，槽函数的参数可以比信号的少，即便如此，槽函数存在的那些参数的顺序也必须和信号的前面几个一致起来。这是因为，你可以在槽函数中选择忽略信号传来的数据（也就是槽函数的参数比信号的少）。</strong></li>
</ul>
<h2 id="信号和槽原理"><a href="#信号和槽原理" class="headerlink" title="信号和槽原理"></a>信号和槽原理</h2><p>本质上是在编译的时候做了其他处理</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//归根溯源</span></span><br><span class="line"><span class="comment">//slots宏实际上就是空</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> slots</span></span><br><span class="line"><span class="comment">//signal宏实际上就是public</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> signal public</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//QT4的connect用到的SLOT和SIGNAL宏实际上就是字符串最前面加了1或者2</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> QT_NO_DEBUG   <span class="comment">//debug版</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SLOT(a) qFlagLocation(<span class="string">&quot;1&quot;</span>#a QLOCATION)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGNAL(a) qFlagLocation(<span class="string">&quot;2&quot;</span>#a QLOCATION)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span>   <span class="comment">//release版</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SLOT(a) <span class="string">&quot;1&quot;</span>#a</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGNAL(a) <span class="string">&quot;2&quot;</span>#a </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">//&#x27;#&#x27;表示字符串拼接</span></span><br><span class="line">		<span class="comment">//QLOCATION宏:其实就是加了文件名和行号等一些调试信息</span></span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> QLOCATION <span class="string">&quot;\0&quot;</span> __FILE__ <span class="string">&quot;:&quot;</span> QT_STRINGIFY(__LINE__)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Q_OBJECT是一些成员变量和函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Q_OBJECT \</span></span><br><span class="line"><span class="meta">public: \</span></span><br><span class="line"><span class="meta">    QT_WARNING_PUSH \</span></span><br><span class="line"><span class="meta">    Q_OBJECT_NO_OVERRIDE_WARNING \</span></span><br><span class="line"><span class="meta">    static const QMetaObject staticMetaObject; \</span></span><br><span class="line"><span class="meta">    virtual const QMetaObject *metaObject() const; \</span></span><br><span class="line"><span class="meta">    virtual void *qt_metacast(const char *); \</span></span><br><span class="line"><span class="meta">    virtual int qt_metacall(QMetaObject::Call, int, void **); \</span></span><br><span class="line"><span class="meta">    QT_TR_FUNCTIONS \</span></span><br><span class="line"><span class="meta">private: \</span></span><br><span class="line"><span class="meta">    Q_OBJECT_NO_ATTRIBUTES_WARNING \</span></span><br><span class="line"><span class="meta">    Q_DECL_HIDDEN_STATIC_METACALL static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); \</span></span><br><span class="line"><span class="meta">    QT_WARNING_POP \</span></span><br><span class="line"><span class="meta">    struct QPrivateSignal &#123; explicit QPrivateSignal() = default; &#125;; \</span></span><br><span class="line"><span class="meta">    QT_ANNOTATE_CLASS(qt_qobject, <span class="string">&quot;&quot;</span>)</span></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2//202311221503259.png" alt="image-20231122150258584"></p>
<h3 id="QMetaObject类"><a href="#QMetaObject类" class="headerlink" title="QMetaObject类"></a>QMetaObject类</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该类中的数据部分如下:</span></span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">Data</span> &#123; <span class="comment">// private data</span></span><br><span class="line">        SuperData superdata;</span><br><span class="line">        <span class="type">const</span> uint *stringdata;</span><br><span class="line">        <span class="type">const</span> uint *data;</span><br><span class="line">        <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*StaticMetacallFunction)</span><span class="params">(QObject *, QMetaObject::Call, <span class="type">int</span>, <span class="type">void</span> **)</span></span>;</span><br><span class="line">        StaticMetacallFunction static_metacall;</span><br><span class="line">        <span class="type">const</span> SuperData *relatedMetaObjects;</span><br><span class="line">        <span class="type">const</span> QtPrivate::QMetaTypeInterface *<span class="type">const</span> *metaTypes;</span><br><span class="line">        <span class="type">void</span> *extradata; <span class="comment">//reserved for future use</span></span><br><span class="line">    &#125; d;</span><br></pre></td></tr></table></figure>

<p>未完待续</p>
<h2 id="信号槽的拓展"><a href="#信号槽的拓展" class="headerlink" title="信号槽的拓展"></a>信号槽的拓展</h2><ul>
<li>一个信号可以和多个槽相连</li>
</ul>
<blockquote>
<p><strong>如果是这种情况，这些槽会一个接一个的被调用，但是它们的调用顺序是不确定的。</strong></p>
</blockquote>
<ul>
<li>多个信号可以连接到一个槽</li>
</ul>
<blockquote>
<p><strong>只要任意一个信号发出，这个槽就会被调用</strong>。</p>
</blockquote>
<ul>
<li>一个信号可以连接到另外的一个信号</li>
</ul>
<blockquote>
<p><strong>当第一个信号发出时，第二个信号被发出。除此之外，这种信号-信号的形式和信号-槽的形式没有什么区别。</strong></p>
</blockquote>
<ul>
<li>槽可以被取消链接</li>
</ul>
<blockquote>
<p>这种情况并不经常出现，因为<strong>当一个对象delete之后，Qt自动取消所有连接到这个对象上面的槽</strong>。</p>
</blockquote>
<ul>
<li>信号槽可以断开</li>
</ul>
<blockquote>
<p>利用<strong>disconnect</strong>关键字是可以断开信号槽的</p>
</blockquote>
<ul>
<li>使用Lambda 表达式</li>
</ul>
<blockquote>
<p>在使用 Qt 5 的时候，能够支持 Qt 5 的编译器都是支持 Lambda 表达式的。</p>
</blockquote>
<p>在连接信号和槽的时候，槽函数可以使用Lambda表达式的方式进行处理。后面我们会详细介绍什么是Lambda表达式</p>
<h3 id="【注意】给label设置鼠标事件穿透案例"><a href="#【注意】给label设置鼠标事件穿透案例" class="headerlink" title="【注意】给label设置鼠标事件穿透案例"></a>【注意】给label设置鼠标事件穿透案例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ui-&gt;label.<span class="built_in">setAttribute</span>(Qt::WA_TransparentForMouseEvents);</span><br></pre></td></tr></table></figure>

<h3 id="【注意】信号和槽传递自定义类型需要先注册该类型"><a href="#【注意】信号和槽传递自定义类型需要先注册该类型" class="headerlink" title="【注意】信号和槽传递自定义类型需要先注册该类型"></a>【注意】信号和槽传递自定义类型需要先注册该类型</h3><p>如果是自己定义的类型如果想使用signal&#x2F;slot来传递的话，则没有这么简单。直接使用的话，会产生下面这种错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QObject::connect: Cannot queue arguments of type &#x27;TextAndNumber&#x27; (Make sure &#x27;TextAndNumber&#x27; is registed using qRegisterMetaType().)</span><br></pre></td></tr></table></figure>

<p>原因：当一个signal被放到队列中（queued）时，它的参数(arguments)也会被一起一起放到队列中（queued起来），这就意味着参数在被传送到slot之前需要被拷贝、存储在队列中（queue）中；为了能够在队列中存储这些参数(argument)，Qt需要去construct、destruct、copy这些对象，而为了让Qt知道怎样去作这些事情，参数的类型需要使用qRegisterMetaType来注册</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">qRegisterMetaType</span>&lt;MyStruct&gt;(<span class="string">&quot;MyStruct&quot;</span>);</span><br><span class="line"><span class="comment">//例如：</span></span><br><span class="line">qRegisterMetaType&lt;QMap&lt;QString,QMap&lt;QString,QString&gt;&gt;&gt;(<span class="string">&quot;QMap&lt;QString,QMap&lt;QString,QString&gt;&gt;&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="Qt4版本的信号槽写法"><a href="#Qt4版本的信号槽写法" class="headerlink" title="Qt4版本的信号槽写法"></a>Qt4版本的信号槽写法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(zt,<span class="built_in">SIGNAL</span>(<span class="built_in">hungury</span>(QString)),st,<span class="built_in">SLOT</span>(<span class="built_in">treat</span>(QString)));</span><br></pre></td></tr></table></figure>

<p>这里使用了<strong>SIGNAL和SLOT这两个宏，将两个函数名转换成了字符串</strong>。注意到connect()函数的 signal 和 slot 都是接受字符串，一旦出现连接不成功的情况，Qt4是没有编译错误的（因为一切都是字符串，编译期是不检查字符串是否匹配），而是在运行时给出错误。这无疑会增加程序的不稳定性。</p>
<p>QT4写法</p>
<ul>
<li>优势：参数直观</li>
<li>劣势：参数类型不做匹配检测</li>
</ul>
<p>Qt5在语法上完全兼容Qt4，而反之是不可以的。</p>
<h2 id="connect中的Lambda表达式"><a href="#connect中的Lambda表达式" class="headerlink" title="connect中的Lambda表达式"></a>connect中的Lambda表达式</h2><p>[[c++11与14#Lambda表达式|Lambda表达式详解跳转]]</p>
<p> <strong>【注意】Lambda和信号与槽（重点）</strong></p>
<ol>
<li>当进行信号和槽连接的时候，控件内部会进入一个<strong>锁的状态</strong>，因此不可以用Lambda表达式的引用传递来调用已连接的组件，而应该用Lambda表达式的<strong>值传递</strong></li>
<li>connect函数中，如果槽函数用的是lambda表达式，那么<strong>信号的接受者可以省略</strong></li>
</ol>
<h3 id="三参数版本的信号与槽"><a href="#三参数版本的信号与槽" class="headerlink" title="三参数版本的信号与槽"></a>三参数版本的信号与槽</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QObject::<span class="built_in">connect</span>(reply, &amp;QNetworkReply::readyRead,[=]()&#123;</span><br><span class="line">        QByteArray all = reply-&gt;<span class="built_in">readAll</span>();</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="built_in">QString</span>(all);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<h1 id="QMainWindow"><a href="#QMainWindow" class="headerlink" title="QMainWindow"></a>QMainWindow</h1><p>QMainWindow是一个为用户提供主窗口程序的类，包含一个菜单栏（menu bar）、多个工具栏(tool bars)、多个锚接部件(dock widgets)、一个状态栏(status bar)及一个中心部件(central widget)，是许多应用程序的基础，如文本编辑器，图片编辑器等。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps72.jpg" alt="img"></p>
<h2 id="菜单栏"><a href="#菜单栏" class="headerlink" title="菜单栏"></a>菜单栏</h2><p>一个主窗口最多只有一个菜单栏。位于主窗口顶部、主窗口标题栏下面。</p>
<ul>
<li>创建菜单栏，通过QMainWindow类的menubar（）函数获取主窗口菜单栏指针</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QMenuBar * <span class="title">menuBar</span><span class="params">()</span> <span class="type">const</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>创建菜单，调用QMenu的成员函数addMenu来添加菜单</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QAction* <span class="title">addMenu</span><span class="params">(QMenu * menu)</span></span></span><br><span class="line"><span class="function">QMenu* <span class="title">addMenu</span><span class="params">(<span class="type">const</span> QString &amp; title)</span></span></span><br><span class="line"><span class="function">QMenu* <span class="title">addMenu</span><span class="params">(<span class="type">const</span> QIcon &amp; icon, <span class="type">const</span> QString &amp; title)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>创建菜单项，调用QMenu的成员函数addAction来添加菜单项</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QAction* <span class="title">activeAction</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">QAction* <span class="title">addAction</span><span class="params">(<span class="type">const</span> QString &amp; text)</span></span></span><br><span class="line"><span class="function">QAction* <span class="title">addAction</span><span class="params">(<span class="type">const</span> QIcon &amp; icon, <span class="type">const</span> QString &amp; text)</span></span></span><br><span class="line"><span class="function">QAction* <span class="title">addAction</span><span class="params">(<span class="type">const</span> QString &amp; text, <span class="type">const</span> QObject * receiver,<span class="type">const</span> <span class="type">char</span> * member, <span class="type">const</span> QKeySequence &amp; shortcut = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">QAction* <span class="title">addAction</span><span class="params">(<span class="type">const</span> QIcon &amp; icon, <span class="type">const</span> QString &amp; text,<span class="type">const</span> QObject * receiver, <span class="type">const</span> <span class="type">char</span> * member,<span class="type">const</span> QKeySequence &amp; shortcut = <span class="number">0</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>Qt 并没有专门的菜单项类，只是使用一个QAction类，抽象出公共的动作。当我们把QAction对象添加到菜单，就显示成一个菜单项，添加到工具栏，就显示成一个工具按钮。用户可以通过点击菜单项、点击工具栏按钮、点击快捷键来激活这个动作。</p>
<p>在ui中直接生成的action只能输入英文，因为QT会自动生成”action+输入英文”的对象名,但可以在属性表中手动改成中文内容。</p>
<p><strong>为界面添加右键菜单</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> ui-&gt;treeWidget_salaryDistribution-&gt;<span class="built_in">setContextMenuPolicy</span>(Qt::CustomContextMenu);<span class="comment">//设置目录策略，否则右键无反应</span></span><br><span class="line"><span class="comment">//然后在ui编辑界面中，右击QTreeWidget--&gt; Connect Signal--&gt;选择customContextMenuRequested(QPoint)，添加slot函数。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_treeWidget_salaryDistribution_customContextMenuRequested</span><span class="params">(<span class="type">const</span> QPoint &amp;pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QMenu *popMenu =<span class="keyword">new</span> <span class="built_in">QMenu</span>(<span class="keyword">this</span>);<span class="comment">//定义一个右键弹出菜单</span></span><br><span class="line"></span><br><span class="line">           popMenu-&gt;<span class="built_in">addAction</span>(ui-&gt;actionactionFromBankSetGuangFa);<span class="comment">//往菜单内添加QAction   该action在前面用设计器定义了</span></span><br><span class="line">           popMenu-&gt;<span class="built_in">addAction</span>(ui-&gt;actionactionFromBankSetNongYe);</span><br><span class="line">           popMenu-&gt;<span class="built_in">addAction</span>(ui-&gt;actionactionFromBankSetZhaoShang);</span><br><span class="line">           QAction* action=<span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="keyword">this</span>);</span><br><span class="line">           action-&gt;<span class="built_in">setSeparator</span>(<span class="literal">true</span>);<span class="comment">//添加分割线action</span></span><br><span class="line">           popMenu-&gt;<span class="built_in">addAction</span>(action);</span><br><span class="line">           popMenu-&gt;<span class="built_in">addAction</span>(ui-&gt;actionactionToBankSetGuangFa);</span><br><span class="line">           popMenu-&gt;<span class="built_in">addAction</span>(ui-&gt;actionactionToBankSetNongYe);</span><br><span class="line">           popMenu-&gt;<span class="built_in">addAction</span>(ui-&gt;actionactionToBankSetZhaoShang);</span><br><span class="line">           popMenu-&gt;<span class="built_in">exec</span>(QCursor::<span class="built_in">pos</span>());<span class="comment">//弹出右键菜单，菜单位置为光标位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lingluotianya/p/3642605.html">右键菜单点击跳转</a></p>
<h2 id="工具栏"><a href="#工具栏" class="headerlink" title="工具栏"></a>工具栏</h2><p>主窗口的工具栏上可以有多个工具条，通常采用一个菜单对应一个工具条的的方式，也可根据需要进行工具条的划分。</p>
<ul>
<li><p>直接调用QMainWindow类的addToolBar（）函数获取主窗口的工具条对象，每增加一个工具条都需要调用一次该函数。</p>
</li>
<li><p>插入属于工具条的动作，即在工具条上添加操作。</p>
<p>通过QToolBar类的addAction函数添加。</p>
</li>
<li><p>工具条是一个可移动的窗口，它的停靠区域由QToolBar的allowAreas决定，包括：</p>
<ul>
<li><p>Qt::LeftToolBarArea 停靠在左侧</p>
</li>
<li><p>Qt::RightToolBarArea 停靠在右侧</p>
</li>
<li><p>Qt::TopToolBarArea 停靠在顶部</p>
</li>
<li><p>Qt::BottomToolBarArea 停靠在底部</p>
</li>
<li><p>Qt::AllToolBarAreas 以上四个位置都可停靠</p>
</li>
</ul>
</li>
</ul>
<p><strong>使用setAllowedAreas（）函数指定停靠区域：</strong></p>
<p>​	setAllowedAreas（Qt::LeftToolBarArea | Qt::RightToolBarArea）</p>
<p><strong>使用setMoveable（）函数设定工具栏的可移动性：</strong></p>
<p>​	setMoveable（false）&#x2F;&#x2F;工具条不可移动, 只能停靠在初始化的位置上（即不能操作位置）</p>
<h2 id="状态栏"><a href="#状态栏" class="headerlink" title="状态栏"></a>状态栏</h2><ul>
<li>派生自QWidget类，使用方法与QWidget类似，QStatusBar类常用成员函数：</li>
<li>状态栏也只能最多有一个</li>
<li>状态栏无法通过ui文件拉拽放入控件</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加小部件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addWidget</span><span class="params">(QWidget * widget, <span class="type">int</span> stretch = <span class="number">0</span>)</span><span class="comment">//左侧开始</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QStatusBar::addPermanentWidget</span><span class="params">(QWidget *widget, <span class="type">int</span> stretch = <span class="number">0</span>)</span><span class="comment">//右侧开始添加小部件</span></span></span><br><span class="line"><span class="function"><span class="comment">//插入小部件</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">insertWidget</span><span class="params">(<span class="type">int</span> index, QWidget * widget, <span class="type">int</span> stretch = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"><span class="comment">//删除小部件</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">removeWidget</span><span class="params">(QWidget * widget)</span></span></span><br></pre></td></tr></table></figure>

<h2 id="铆接部件"><a href="#铆接部件" class="headerlink" title="铆接部件"></a>铆接部件</h2><p>铆接部件 QDockWidget，也称浮动窗口，可以有多个。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QDockWidget * dock = <span class="keyword">new</span> <span class="built_in">QDockWidget</span>(<span class="string">&quot;标题&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line"><span class="built_in">addDockWidget</span>(Qt::LeftDockWidgetArea,dock);</span><br><span class="line">dock-&gt;<span class="built_in">setAllowedAreas</span>(Qt::LeftDockWidgetArea | Qt::RightDockWidgetArea | Qt::TopDockWidgetArea); <span class="comment">//设置区域范围(他的位置是相对核心部件而言的)</span></span><br></pre></td></tr></table></figure>

<h2 id="核心部件（中心部件）"><a href="#核心部件（中心部件）" class="headerlink" title="核心部件（中心部件）"></a>核心部件（中心部件）</h2><p>除了以上几个部件，中心显示的部件都可以作为核心部件，例如一个记事本文件，可以利用QTextEdit做核心部件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit * edit = <span class="keyword">new</span> <span class="built_in">QTextEdit</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="built_in">setCentralWidget</span>(edit);</span><br></pre></td></tr></table></figure>

<h2 id="资源文件"><a href="#资源文件" class="headerlink" title="资源文件"></a>资源文件</h2><p>Qt 资源系统是一个跨平台的资源机制，用于将程序运行时所需要的资源以二进制的形式存储于可执行文件内部。如果你的程序需要加载特定的资源（图标、文本翻译等），那么，将其放置在资源文件中，就再也不需要担心这些文件的丢失。也就是说，如果你将资源以资源文件形式存储，它是会编译到可执行文件内部。</p>
<p>使用 Qt Creator 可以很方便地创建资源文件。我们可以在工程上点右键，选择”添加新文件…”，可以在 Qt 分类下找到”Qt 资源文件”：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps91.jpg" alt="img"></p>
<p>点击”选择…”按钮，打开”新建 Qt 资源文件”对话框。在这里我们输入资源文件的名字和路径：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps110.jpg" alt="img"></p>
<p>点击下一步，选择所需要的版本控制系统，然后直接选择完成。我们可以在 Qt Creator 的左侧文件列表中看到”资源文件”一项，也就是我们新创建的资源文件。右键res.qrc，点击用编辑的方式打开。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps150.jpg" alt="img"></p>
<p>右侧的编辑区有个”添加”，我们首先需要添加前缀，比如我们将前缀取名为 images。然后选中这个前缀，继续点击添加文件，可以找到我们所需添加的文件。这里，我们选择 document-open.png 文件。当我们完成操作之后，Qt Creator 应该是这样子的：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps219.jpg" alt="img"></p>
<p>接下来，我们还可以添加另外的前缀或者另外的文件。这取决于你的需要。当我们添加完成之后，我们可以像前面一章讲解的那样，通过使用 : 开头的路径来找到这个文件。比如，我们的前缀是 &#x2F;images，文件是 document-open.png，那么就可以使用:&#x2F;images&#x2F;document-open.png找到这个文件。<br>$$<br>使用规则为“     ：+前缀名+（&#x2F;）文件名”<br>$$<br>这么做带来的一个问题是，如果以后我们要更改文件名，比如将 docuemnt-open.png 改成 docopen.png，那么，所有使用了这个名字的路径都需要修改。所以，更好的办法是，我们给这个文件去一个”别名”，以后就以这个别名来引用这个文件。具体做法是，选中这个文件，添加别名信息：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps237.jpg" alt="img"></p>
<p>这样，我们可以直接使用:&#x2F;images&#x2F;doc-open引用到这个资源，无需关心图片的真实文件名。</p>
<p>如果我们使用文本编辑器打开 res.qrc 文件，就会看到一下内容：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RCC</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">qresource</span> <span class="attr">prefix</span>=<span class="string">&quot;/images&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">file</span> <span class="attr">alias</span>=<span class="string">&quot;doc-open&quot;</span>&gt;</span>document-open.png<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">qresource</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">qresource</span> <span class="attr">prefix</span>=<span class="string">&quot;/images/fr&quot;</span> <span class="attr">lang</span>=<span class="string">&quot;fr&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">file</span> <span class="attr">alias</span>=<span class="string">&quot;doc-open&quot;</span>&gt;</span>document-open-fr.png<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">qresource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RCC</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们可以对比一下，看看 Qt Creator 帮我们生成的是怎样的 qrc 文件。当我们编译工程之后，我们可以在构建目录中找到 qrc_res.cpp 文件，这就是 Qt 将我们的资源编译成了 C++ 代码。</p>
<h1 id="对话框QDialog"><a href="#对话框QDialog" class="headerlink" title="对话框QDialog"></a>对话框QDialog</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>对话框是 GUI 程序中不可或缺的组成部分。很多不能或者不适合放入主窗口的功能组件都必须放在对话框中设置。对话框通常会是一个顶层窗口，出现在程序最上层，用于实现短期任务或者简洁的用户交互。</p>
<p>Qt 中使用QDialog类实现对话框。就像主窗口一样，我们通常会设计一个类继承QDialog。QDialog（及其子类，以及所有Qt::Dialog类型的类）的对于其 parent 指针都有额外的解释：<strong>如果 parent 为 NULL，则该对话框会作为一个顶层窗口，否则则作为其父组件的子对话框（此时，其默认出现的位置是 parent 的中心）。顶层窗口与非顶层窗口的区别在于，顶层窗口在任务栏会有自己的位置，而非顶层窗口则会共享其父组件的位置。</strong></p>
<p><strong>对话框分为模态对话框和非模态对话框。</strong></p>
<ul>
<li><p>模态对话框，就是会阻塞同一应用程序中其它窗口的输入。</p>
<p>模态对话框很常见，比如”打开文件”功能。你可以尝试一下记事本的打开文件，当打开文件对话框出现时，我们是不能对除此对话框之外的窗口部分进行操作的。</p>
</li>
<li><p>与此相反的是非模态对话框，例如查找对话框，我们可以在显示着查找对话框的同时，继续对记事本的内容进行编辑。</p>
</li>
</ul>
<h2 id="标准对话框"><a href="#标准对话框" class="headerlink" title="标准对话框"></a>标准对话框</h2><p>所谓标准对话框，是 Qt 内置的一系列对话框，用于简化开发。事实上，有很多对话框都是通用的，比如打开文件、设置颜色、打印设置等。这些对话框在所有程序中几乎相同，因此没有必要在每一个程序中都自己实现这么一个对话框。</p>
<p>Qt 的内置对话框大致分为以下几类：</p>
<ul>
<li><p>QColorDialog： 选择颜色；</p>
</li>
<li><p>QFileDialog： 选择文件或者目录；</p>
</li>
<li><p>QFontDialog： 选择字体；</p>
</li>
<li><p>QInputDialog： 允许用户输入一个值，并将其值返回；</p>
</li>
<li><p>QMessageBox： 模态对话框，用于显示信息、询问问题等；</p>
</li>
<li><p>QPageSetupDialog： 为打印机提供纸张相关的选项；</p>
</li>
<li><p>QPrintDialog： 打印机配置；</p>
</li>
<li><p>QPrintPreviewDialog：打印预览；</p>
</li>
<li><p>QProgressDialog： 显示操作过程。</p>
</li>
</ul>
<h2 id="自定义对话框"><a href="#自定义对话框" class="headerlink" title="自定义对话框"></a>自定义对话框</h2><p>Qt 支持模态对话框和非模态对话框。</p>
<p>模态与非模态的实现：</p>
<ul>
<li><p>使用QDialog::exec()实现应用程序级别的模态对话框</p>
</li>
<li><p>使用QDialog::open()实现窗口级别的模态对话框</p>
</li>
<li><p>使用QDialog::show()实现非模态对话框。</p>
</li>
</ul>
<h4 id="模态对话框"><a href="#模态对话框" class="headerlink" title="模态对话框"></a>模态对话框</h4><ul>
<li><p>Qt 有两种级别的模态对话框：</p>
<ul>
<li>应用程序级别的模态</li>
</ul>
</li>
</ul>
<blockquote>
<p>当该种模态的对话框出现时，用户必须首先对对话框进行交互，直到关闭对话框，然后才能访问程序中其他的窗口。</p>
</blockquote>
<ul>
<li>窗口级别的模态</li>
</ul>
<blockquote>
<p>该模态仅仅阻塞与对话框关联的窗口，但是依然允许用户与程序中其它窗口交互。窗口级别的模态尤其适用于多窗口模式。</p>
</blockquote>
<p>一般默认是应用程序级别的模态。</p>
<p>在下面的示例中，我们调用了exec()将对话框显示出来，因此这就是一个模态对话框。当对话框出现时，我们不能与主窗口进行任何交互，直到我们关闭了该对话框。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QDialog dialog;</span><br><span class="line">dialog.<span class="built_in">setWindowTitle</span>(<span class="built_in">tr</span>(<span class="string">&quot;Hello, dialog!&quot;</span>));</span><br><span class="line"><span class="type">int</span> ret=dialog.<span class="built_in">exec</span>();</span><br><span class="line"><span class="keyword">if</span>(ret==QDialog::Accepted)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="非模态对话框"><a href="#非模态对话框" class="headerlink" title="非模态对话框"></a>非模态对话框</h4><p>下面我们试着将exec()修改为show()，看看非模态对话框：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QDialog <span class="title">dialog</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">dialog.<span class="built_in">setWindowTitle</span>(<span class="built_in">tr</span>(<span class="string">&quot;Hello, dialog!&quot;</span>));</span><br><span class="line">dialog.<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<p>是不是事与愿违？对话框竟然一闪而过！这是因为，<strong>show()函数不会阻塞当前线程，对话框会显示出来，然后函数立即返回，代码继续执行。</strong>注意，dialog 是建立在栈上的，show()函数返回，MainWindow::open()函数结束，dialog 超出作用域被析构，因此对话框消失了。知道了原因就好改了，我们将 dialog 改成堆上建立，当然就没有这个问题了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QDialog *dialog = <span class="keyword">new</span> QDialog;</span><br><span class="line">dialog-&gt;<span class="built_in">setWindowTitle</span>(<span class="built_in">tr</span>(<span class="string">&quot;Hello, dialog!&quot;</span>));</span><br><span class="line">dialog-&gt;<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<p>如果你足够细心，应该发现上面的代码是有问题的：dialog 存在内存泄露！dialog 使用 new 在堆上分配空间，却一直没有 delete。解决方案也很简单：将 MainWindow 的指针赋给 dialog 即可。还记得我们前面说过的 Qt 的对象系统吗？</p>
<p>不过，这样做有一个问题：如果我们的对话框不是在一个界面类中出现呢？由于QWidget的 parent 必须是QWidget指针，那就限制了我们不能将一个普通的 C++ 类指针传给 Qt 对话框。另外，如果对内存占用有严格限制的话，当我们将主窗口作为 parent 时，主窗口不关闭，对话框就不会被销毁，所以会一直占用内存。在这种情景下，我们可以设置 dialog 的<strong>WindowAttribute</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QDialog *dialog = <span class="keyword">new</span> QDialog;</span><br><span class="line">dialog-&gt;<span class="built_in">setAttribute</span>(Qt::WA_DeleteOnClose);</span><br><span class="line">dialog-&gt;<span class="built_in">setWindowTitle</span>(<span class="built_in">tr</span>(<span class="string">&quot;Hello, dialog!&quot;</span>));</span><br><span class="line">dialog-&gt;<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<p><strong>setAttribute()函数设置对话框关闭时，自动销毁对话框。</strong></p>
<h2 id="消息对话框"><a href="#消息对话框" class="headerlink" title="消息对话框"></a>消息对话框</h2><p>QMessageBox用于显示消息提示。我们一般会使用其提供的几个 static 函数：</p>
<ul>
<li>显示关于对话框。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">about</span><span class="params">(QWidget * parent, <span class="type">const</span> QString &amp; title, <span class="type">const</span> QString &amp; text)</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这是一个最简单的对话框，其标题是 title，内容是 text，父窗口是 parent。对话框只有一个 OK 按钮。</p>
</blockquote>
<ul>
<li><p>显示关于 Qt 对话框。该对话框用于显示有关 Qt 的信息。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">aboutQt</span><span class="params">(QWidget * parent, <span class="type">const</span> QString &amp; title = QString())</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>显示严重错误对话框。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StandardButton <span class="title">critical</span><span class="params">(QWidget * parent,<span class="type">const</span> QString &amp; title,<span class="type">const</span> QString &amp; text,StandardButtons buttons = Ok,StandardButton defaultButton = NoButton)</span></span></span><br></pre></td></tr></table></figure>

<p>这个对话框将显示一个红色的错误符号。我们可以通过 buttons 参数指明其显示的按钮。默认情况下只有一个 Ok 按钮，我们可以使用StandardButtons类型指定多种按钮。</p>
</li>
<li><p>与QMessageBox::critical()类似，不同之处在于这个对话框提供一个普通信息图标。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StandardButton <span class="title">information</span><span class="params">(QWidget * parent,<span class="type">const</span> QString &amp; title,<span class="type">const</span> QString &amp; text,StandardButtons buttons = Ok,StandardButton defaultButton = NoButton)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>与QMessageBox::critical ()类似，不同之处在于这个对话框提供一个问号图标，并且其显示的按钮是”是”和”否”。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StandardButton <span class="title">question</span><span class="params">(QWidget * parent,<span class="type">const</span> QString &amp; title,<span class="type">const</span> QString &amp; text,StandardButtons buttons = StandardButtons( Yes | No ),StandardButton defaultButton = NoButton)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>与QMessageBox::critical()类似，不同之处在于这个对话框提供一个黄色叹号图标。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StandardButton <span class="title">warning</span><span class="params">(QWidget * parent,<span class="type">const</span> QString &amp; title,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> QString &amp; text,StandardButtons buttons = Ok,StandardButton defaultButton = NoButton)</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>我们可以通过下面的代码来演示下如何使用QMessageBox。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (QMessageBox::Yes == QMessageBox::<span class="built_in">question</span>(<span class="keyword">this</span>,<span class="built_in">tr</span>(<span class="string">&quot;Question&quot;</span>), <span class="built_in">tr</span>(<span class="string">&quot;Are you OK?&quot;</span>),QMessageBox::Yes | QMessageBox::No,QMessageBox::Yes))</span><br><span class="line">&#123;</span><br><span class="line">	QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>, <span class="built_in">tr</span>(<span class="string">&quot;Hmmm...&quot;</span>),</span><br><span class="line">	<span class="built_in">tr</span>(<span class="string">&quot;I&#x27;m glad to hear that!&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>, <span class="built_in">tr</span>(<span class="string">&quot;Hmmm...&quot;</span>),</span><br><span class="line">	<span class="built_in">tr</span>(<span class="string">&quot;I&#x27;m sorry!&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用QMessageBox::question()来询问一个问题。</p>
<ul>
<li>这个对话框的父窗口是 this。</li>
</ul>
<blockquote>
<p>QMessageBox是QDialog的子类，这意味着它的初始显示位置将会是在 parent 窗口的中央。</p>
</blockquote>
<ul>
<li><p>第二个参数是对话框的标题。</p>
</li>
<li><p>第三个参数是我们想要显示的内容。</p>
</li>
<li><p>第四个参数是关联的按键类型，我们可以使用或运算符（|）指定对话框应该出现的按钮。比如我们希望是一个 Yes 和一个 No。</p>
</li>
<li><p>最后一个参数指定默认选择的按钮。</p>
</li>
</ul>
<p>这个函数有一个返回值，用于确定用户点击的是哪一个按钮。按照我们的写法，应该很容易的看出，这是一个模态对话框，因此我们可以直接获取其返回值。</p>
<p>QMessageBox类的 static 函数优点是方便使用，缺点也很明显：非常不灵活。我们只能使用简单的几种形式。为了能够定制QMessageBox细节，我们必须使用QMessageBox的属性设置 API。如果我们希望制作一个询问是否保存的对话框，我们可以使用如下的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">QMessageBox msgBox;</span><br><span class="line">msgBox.<span class="built_in">setText</span>(<span class="built_in">tr</span>(<span class="string">&quot;The document has been modified.&quot;</span>));</span><br><span class="line">msgBox.<span class="built_in">setInformativeText</span>(<span class="built_in">tr</span>(<span class="string">&quot;Do you want to save your changes?&quot;</span>));</span><br><span class="line">msgBox.<span class="built_in">setDetailedText</span>(<span class="built_in">tr</span>(<span class="string">&quot;Differences here...&quot;</span>));</span><br><span class="line">msgBox.<span class="built_in">setStandardButtons</span>(QMessageBox::Save| QMessageBox::Discard| QMessageBox::Cancel);</span><br><span class="line">msgBox.<span class="built_in">setDefaultButton</span>(QMessageBox::Save);</span><br><span class="line"><span class="type">int</span> ret = msgBox.<span class="built_in">exec</span>();</span><br><span class="line"><span class="keyword">switch</span> (ret)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">case</span> QMessageBox::Save:</span><br><span class="line">	<span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Save document!&quot;</span>;</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> QMessageBox::Discard:</span><br><span class="line">	<span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Discard changes!&quot;</span>;</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> QMessageBox::Cancel:</span><br><span class="line">	<span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Close document!&quot;</span>;</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>msgBox 是一个建立在栈上的QMessageBox实例。我们设置其主要文本信息为”The document has been modified.”，informativeText 则是会在对话框中显示的简单说明文字。下面我们使用了一个detailedText，也就是详细信息，当我们点击了详细信息按钮时，对话框可以自动显示更多信息。我们自己定义的对话框的按钮有三个：保存、丢弃和取消。然后我们使用了exec()是其成为一个模态对话框，根据其返回值进行相应的操作。</p>
<h2 id="标准文件对话框"><a href="#标准文件对话框" class="headerlink" title="标准文件对话框"></a>标准文件对话框</h2><p>QFileDialog，也就是文件对话框。在本节中，我们将尝试编写一个简单的文本文件编辑器，我们将使用QFileDialog来打开一个文本文件，并将修改过的文件保存到硬盘。</p>
<p>首先，我们需要创建一个带有文本编辑功能的窗口。借用我们前面的程序代码，应该可以很方便地完成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">openAction = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;:/images/file-open&quot;</span>),<span class="built_in">tr</span>(<span class="string">&quot;&amp;Open...&quot;</span>), <span class="keyword">this</span>);</span><br><span class="line">openAction-&gt;<span class="built_in">setStatusTip</span>(<span class="built_in">tr</span>(<span class="string">&quot;Open an existing file&quot;</span>));</span><br><span class="line">saveAction = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;:/images/file-save&quot;</span>), <span class="built_in">tr</span>(<span class="string">&quot;&amp;Save...&quot;</span>), <span class="keyword">this</span>);</span><br><span class="line">saveAction-&gt;<span class="built_in">setStatusTip</span>(<span class="built_in">tr</span>(<span class="string">&quot;Save a new file&quot;</span>));</span><br><span class="line">QMenu *file = <span class="built_in">menuBar</span>()-&gt;<span class="built_in">addMenu</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;File&quot;</span>));</span><br><span class="line">file-&gt;<span class="built_in">addAction</span>(openAction);</span><br><span class="line">file-&gt;<span class="built_in">addAction</span>(saveAction);</span><br><span class="line">QToolBar *toolBar = <span class="built_in">addToolBar</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;File&quot;</span>));</span><br><span class="line">toolBar-&gt;<span class="built_in">addAction</span>(openAction);</span><br><span class="line">toolBar-&gt;<span class="built_in">addAction</span>(saveAction);</span><br><span class="line">textEdit = <span class="keyword">new</span> <span class="built_in">QTextEdit</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="built_in">setCentralWidget</span>(textEdit);</span><br></pre></td></tr></table></figure>

<p>我们在菜单和工具栏添加了两个动作：打开和保存。接下来是一个QTextEdit类，这个类用于显示富文本文件。也就是说，它不仅仅用于显示文本，还可以显示图片、表格等等。不过，我们现在只用它显示纯文本文件。QMainWindow有一个setCentralWidget()函数，可以将一个组件作为窗口的中心组件，放在窗口中央显示区。显然，在一个文本编辑器中，文本编辑区就是这个中心组件，因此我们将QTextEdit作为这种组件。</p>
<p>我们使用connect()函数，为这两个QAction对象添加响应的动作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(openAction, &amp;QAction::triggered,<span class="keyword">this</span>, &amp;MainWindow::openFile);</span><br><span class="line"><span class="built_in">connect</span>(saveAction, &amp;QAction::triggered,<span class="keyword">this</span>, &amp;MainWindow::saveFile);</span><br></pre></td></tr></table></figure>

<p>下面是最主要的openFile()和saveFile()这两个函数的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打开文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::openFile</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QString path = QFileDialog::<span class="built_in">getOpenFileName</span>(<span class="keyword">this</span>,<span class="built_in">tr</span>(<span class="string">&quot;Open File&quot;</span>), <span class="string">&quot;.&quot;</span>, <span class="built_in">tr</span>(<span class="string">&quot;Text Files(*.txt)&quot;</span>));</span><br><span class="line">	<span class="keyword">if</span>(!path.<span class="built_in">isEmpty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">QFile <span class="title">file</span><span class="params">(path)</span></span>;</span><br><span class="line">		<span class="keyword">if</span> (!file.<span class="built_in">open</span>(QIODevice::ReadOnly | QIODevice::Text))</span><br><span class="line">		&#123;</span><br><span class="line">			QMessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>, <span class="built_in">tr</span>(<span class="string">&quot;Read File&quot;</span>),<span class="built_in">tr</span>(<span class="string">&quot;Cannot open file:\n%1&quot;</span>).<span class="built_in">arg</span>(path));</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="function">QTextStream <span class="title">in</span><span class="params">(&amp;file)</span></span>;</span><br><span class="line">	textEdit-&gt;<span class="built_in">setText</span>(in.<span class="built_in">readAll</span>());</span><br><span class="line">	file.<span class="built_in">close</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		QMessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>, <span class="built_in">tr</span>(<span class="string">&quot;Path&quot;</span>),<span class="built_in">tr</span>(<span class="string">&quot;You did not select any file.&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//保存文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::saveFile</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QString path = QFileDialog::<span class="built_in">getSaveFileName</span>(<span class="keyword">this</span>,<span class="built_in">tr</span>(<span class="string">&quot;Open File&quot;</span>), <span class="string">&quot;.&quot;</span>,<span class="built_in">tr</span>(<span class="string">&quot;Text Files(*.txt)&quot;</span>));</span><br><span class="line">	<span class="keyword">if</span>(!path.<span class="built_in">isEmpty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">QFile <span class="title">file</span><span class="params">(path)</span></span>;</span><br><span class="line">		<span class="keyword">if</span> (!file.<span class="built_in">open</span>(QIODevice::WriteOnly | QIODevice::Text))</span><br><span class="line">		&#123;</span><br><span class="line">			QMessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>, <span class="built_in">tr</span>(<span class="string">&quot;Write File&quot;</span>),<span class="built_in">tr</span>(<span class="string">&quot;Cannot open file:\n%1&quot;</span>).<span class="built_in">arg</span>(path));</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function">QTextStream <span class="title">out</span><span class="params">(&amp;file)</span></span>;</span><br><span class="line">		out &lt;&lt; textEdit-&gt;<span class="built_in">toPlainText</span>();</span><br><span class="line">		file.<span class="built_in">close</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		QMessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>, <span class="built_in">tr</span>(<span class="string">&quot;Path&quot;</span>),<span class="built_in">tr</span>(<span class="string">&quot;You did not select any file.&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在openFile()函数中，我们使用QFileDialog::getOpenFileName()来获取需要打开的文件的路径。这个函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QString <span class="title">getOpenFileName</span><span class="params">(QWidget * parent = <span class="number">0</span>,<span class="type">const</span> QString &amp; caption = QString(),<span class="type">const</span> QString &amp; dir = QString(),<span class="type">const</span> QString &amp; filter = QString(),QString * selectedFilter = <span class="number">0</span>,Options options = <span class="number">0</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>不过注意，它的所有参数都是可选的，因此在一定程度上说，这个函数也是简单的。这六个参数分别是：</p>
<ul>
<li>parent：父窗口。</li>
</ul>
<blockquote>
<p>Qt 的标准对话框提供静态函数，用于返回一个模态对话框；</p>
</blockquote>
<ul>
<li><p>caption：对话框标题；</p>
</li>
<li><p>dir：对话框打开时的默认目录</p>
<ul>
<li><p>“.” 代表程序运行目录</p>
</li>
<li><p>“&#x2F;“ 代表当前盘符的根目录（特指 Windows 平台；Linux 平台当然就是根目录），这个参数也可以是平台相关的，比如”C:\\“等；</p>
</li>
</ul>
</li>
<li><p>filter：过滤器。</p>
</li>
</ul>
<blockquote>
<p>我们使用文件对话框可以浏览很多类型的文件，但是，很多时候我们仅希望打开特定类型的文件。比如，文本编辑器希望打开文本文件，图片浏览器希望打开图片文件。<strong>过滤器就是用于过滤特定的后缀名</strong>。如果我们使用”Image Files(<em>.jpg <em>.png)”，则只能显示后缀名是 jpg 或者 png 的文件。<strong>如果需要多个过滤器，使用”;;”分割</strong>，比如”JPEG Files(</em>.jpg);;PNG Files(</em>.png)”；</p>
</blockquote>
<ul>
<li><p>selectedFilter：默认选择的过滤器；</p>
</li>
<li><p>options：对话框的一些参数设定</p>
</li>
</ul>
<blockquote>
<p>比如只显示文件夹等等，它的取值是enum QFileDialog::Option，每个选项可以使用 | 运算组合起来。</p>
</blockquote>
<p><strong>QFileDialog::getOpenFileName()返回值是选择的文件路径。</strong>我们将其赋值给 path。通过判断 path 是否为空，可以确定用户是否选择了某一文件。只有当用户选择了一个文件时，我们才执行下面的操作。</p>
<p>在saveFile()中使用的QFileDialog::getSaveFileName()也是类似的。使用这种静态函数，在 Windows、Mac OS 上面都是直接调用本地对话框，但是 Linux 上则是QFileDialog自己的模拟。这暗示了，如果你不使用这些静态函数，而是直接使用QFileDialog进行设置，那么得到的对话框很可能与系统对话框的外观不一致。这一点是需要注意的。</p>
<h2 id="标准颜色对话框"><a href="#标准颜色对话框" class="headerlink" title="标准颜色对话框"></a>标准颜色对话框</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QColor color=QColorDialog::<span class="built_in">getColor</span>(QT::red);<span class="comment">//默认选择红色</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; color.<span class="built_in">red</span>() &lt;&lt; color.<span class="built_in">green</span>() &lt;&lt; color.<span class="built_in">blue</span>();</span><br></pre></td></tr></table></figure>

<h2 id="标准字体对话框"><a href="#标准字体对话框" class="headerlink" title="标准字体对话框"></a>标准字体对话框</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QFont font=QFontDialog::<span class="built_in">getFont</span>(&amp;flag,<span class="built_in">QFont</span>(<span class="string">&quot;华文彩云&quot;</span>,<span class="number">36</span>));<span class="comment">//flag返回是否获取成功</span></span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;字体:&quot;</span>&lt;&lt;font.<span class="built_in">family</span>().<span class="built_in">toUtf8</span>().<span class="built_in">data</span>()&lt;&lt;<span class="string">&quot; 字号:&quot;</span>&lt;&lt;font.<span class="built_in">pointSize</span>()&lt;&lt;<span class="string">&quot; 是否加粗：&quot;</span>&lt;&lt;font.<span class="built_in">bold</span>()&lt;&lt;<span class="string">&quot; 是否倾斜:&quot;</span>&lt;&lt;font.<span class="built_in">italic</span>();</span><br></pre></td></tr></table></figure>

<p>p.s.QT在工具-选项-文本编辑器-行为中，设置了文本编码的默认编码为UTF-8。在工具-选项-文本编辑器-显示勾选了Display file encoding，在编码区域右上角会显示文件编码格式。此时qdebug输出中文信息，用F5调试输出框会乱码，但用ctrl+F5直接运行则不会，不会影响程序发布</p>
<h1 id="布局管理器"><a href="#布局管理器" class="headerlink" title="布局管理器"></a>布局管理器</h1><p>所谓 GUI 界面，归根结底，就是一堆组件的叠加。我们创建一个窗口，把按钮放上面，把图标放上面，这样就成了一个界面。在放置时，组件的位置尤其重要。我们必须要指定组件放在哪里，以便窗口能够按照我们需要的方式进行渲染。这就涉及到组件定位的机制。</p>
<p><strong>Qt 提供了两种组件定位机制：绝对定位和布局定位。</strong></p>
<ul>
<li>绝对定位就是一种最原始的定位方法：给出这个组件的坐标和长宽值。</li>
</ul>
<blockquote>
<p>这样，Qt 就知道该把组件放在哪里以及如何设置组件的大小。但是这样做带来的一个问题是，如果用户改变了窗口大小，比如点击最大化按钮或者使用鼠标拖动窗口边缘，采用绝对定位的组件是不会有任何响应的。这也很自然，因为你并没有告诉 Qt，在窗口变化时，组件是否要更新自己以及如何更新。或者，还有更简单的方法：禁止用户改变窗口大小。但这总不是长远之计。</p>
</blockquote>
<ul>
<li>布局定位：你只要把组件放入某一种布局，布局由专门的布局管理器进行管理。当需要调整大小或者位置的时候，Qt 使用对应的布局管理器进行调整。</li>
</ul>
<p>布局定位完美的解决了使用绝对定位的缺陷。</p>
<p>Qt 提供的布局中以下三种是我们最常用的：</p>
<ul>
<li><p>QHBoxLayout：按照水平方向从左到右布局；</p>
</li>
<li><p>QVBoxLayout：按照竖直方向从上到下布局；</p>
</li>
<li><p>QGridLayout：在一个网格中进行布局，类似于 HTML 的 table；</p>
</li>
</ul>
<h2 id="系统提供的布局控件"><a href="#系统提供的布局控件" class="headerlink" title="系统提供的布局控件"></a>系统提供的布局控件</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps61.jpg" alt="img"></p>
<p>这4个为系统给我们提供的布局的控件，但是使用起来不是非常的灵活，这里就不详细介绍了。</p>
<h2 id="利用widget做布局"><a href="#利用widget做布局" class="headerlink" title="利用widget做布局"></a>利用widget做布局</h2><p>第二种布局方式是利用控件里的widget来做布局，在Containers中</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps78.jpg" alt="img"></p>
<p>在widget中的控件可以进行水平、垂直、栅格布局等操作，比较灵活。</p>
<p>再布局的同时我们需要灵活运用<strong>弹簧</strong>的特性让我们的布局更加的美观，下面是一个登陆窗口，利用widget可以搭建出如下登陆界面：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps101.jpg" alt="img"></p>
<h1 id="常用控件"><a href="#常用控件" class="headerlink" title="常用控件"></a>常用控件</h1><p>Qt为我们应用程序界面开发提供的一系列的控件，下面我们介绍两种最常用一些控件，所有控件的使用方法我们都可以通过帮助文档获取。</p>
<h2 id="QLabel控件使用"><a href="#QLabel控件使用" class="headerlink" title="QLabel控件使用"></a>QLabel控件使用</h2><p>QLabel是我们最常用的控件之一，其功能很强大，我们可以用来显示文本，图片和动画等。</p>
<h3 id="显示文字-（普通文本、html）"><a href="#显示文字-（普通文本、html）" class="headerlink" title="显示文字 （普通文本、html）"></a>显示文字 （普通文本、html）</h3><p>通过QLabel类的setText函数设置显示的内容:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setText</span><span class="params">(<span class="type">const</span> QString &amp;)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>可以显示普通文本字符串</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">QLable *label = <span class="keyword">new</span> QLable;</span><br><span class="line"><span class="comment">//设置字体</span></span><br><span class="line">QFont font;</span><br><span class="line">font.<span class="built_in">setFamily</span>(<span class="string">&quot;华文新魏&quot;</span>);</span><br><span class="line">font.<span class="built_in">setPointSize</span>(<span class="number">20</span>);</span><br><span class="line">label-&gt;<span class="built_in">setFont</span>(font);</span><br><span class="line">label-&gt;<span class="built_in">setText</span>(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line"><span class="comment">//设置位置和大小</span></span><br><span class="line">label-&gt;<span class="built_in">setGrometry</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line"><span class="comment">//移动到什么位置</span></span><br><span class="line">label-&gt;<span class="built_in">move</span>(<span class="number">60</span>,<span class="number">60</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>可以显示HTML格式的字符串</li>
</ul>
<blockquote>
<p>比如显示一个链接:</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QLabel * label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="keyword">this</span>);</span><br><span class="line">label -&gt;<span class="built_in">setText</span>(<span class="string">&quot;Hello, World&quot;</span>);</span><br><span class="line">label -&gt;<span class="built_in">setText</span>(<span class="string">&quot;&lt;h1&gt;&lt;a href=\&quot;https://www.baidu.com\&quot;&gt;百度一下&lt;/a&gt;&lt;/h1&gt;&quot;</span>);</span><br><span class="line">label -&gt;<span class="built_in">setOpenExternalLinks</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其中setOpenExternalLinks()函数是用来设置用户点击链接之后是否自动打开链接，如果参数指定为true则会自动打开。</p>
</blockquote>
<h3 id="显示图片"><a href="#显示图片" class="headerlink" title="显示图片"></a>显示图片</h3><p>可以使用QLabel的成员函数setPixmap设置图片</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setPixmap</span><span class="params">(<span class="type">const</span> QPixmap &amp;)</span></span></span><br></pre></td></tr></table></figure>

<p>首先定义QPixmap对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QPixmap pixmap;</span><br></pre></td></tr></table></figure>

<p>然后加载图片</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pixmap.<span class="built_in">load</span>(<span class="string">&quot;:/Image/boat.jpg&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>最后将图片设置到QLabel中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QLabel *label = <span class="keyword">new</span> QLabel;</span><br><span class="line">label.<span class="built_in">setPixmap</span>(pixmap);</span><br></pre></td></tr></table></figure>

<h3 id="显示动画"><a href="#显示动画" class="headerlink" title="显示动画"></a>显示动画</h3><p>可以使用QLabel 的成员函数setMovie加载动画，可以播放gif格式的文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMovie</span><span class="params">(QMovie * movie)</span></span></span><br></pre></td></tr></table></figure>

<p>首先定义QMovied对象，并初始化:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QMovie *movie = <span class="keyword">new</span> <span class="built_in">QMovie</span>(<span class="string">&quot;:/Mario.gif&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>播放加载的动画：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movie-&gt;<span class="built_in">start</span>();</span><br></pre></td></tr></table></figure>

<p>将动画设置到QLabel中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QLabel *label = <span class="keyword">new</span> QLabel；</span><br><span class="line">label-&gt;<span class="built_in">setMovie</span>(movie);</span><br></pre></td></tr></table></figure>

<h2 id="QLineEdit"><a href="#QLineEdit" class="headerlink" title="QLineEdit"></a>QLineEdit</h2><p>Qt提供的单行文本编辑框。</p>
<h4 id="设置-获取内容"><a href="#设置-获取内容" class="headerlink" title="设置&#x2F;获取内容"></a>设置&#x2F;获取内容</h4><ul>
<li><p>获取编辑框内容使用text（），函数声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QString <span class="title">text</span><span class="params">()</span> <span class="type">const</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设置编辑框内容</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setText</span><span class="params">(<span class="type">const</span> QString &amp;)</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="设置显示模式"><a href="#设置显示模式" class="headerlink" title="设置显示模式"></a>设置显示模式</h4><p>使用QLineEdit类的setEchoMode () 函数设置文本的显示模式,函数声明:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setEchoMode</span><span class="params">(EchoMode mode)</span></span></span><br></pre></td></tr></table></figure>

<p>EchoMode是一个枚举类型,一共定义了四种显示模式:</p>
<ul>
<li><p>QLineEdit::Normal 模式显示方式，按照输入的内容显示。</p>
</li>
<li><p>QLineEdit::NoEcho 不显示任何内容，此模式下无法看到用户的输入。</p>
</li>
<li><p>QLineEdit::Password 密码模式，输入的字符会根据平台转换为特殊字符。</p>
</li>
<li><p>QLineEdit::PasswordEchoOnEdit 编辑时显示字符否则显示字符作为密码。</p>
</li>
</ul>
<p>另外，我们再使用QLineEdit显示文本的时候，希望在左侧留出一段空白的区域，那么，就可以使用QLineEdit给我们提供的setTextMargins函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setTextMargins</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> top, <span class="type">int</span> right, <span class="type">int</span> bottom)</span></span></span><br></pre></td></tr></table></figure>

<p>用此函数可以指定显示的文本与输入框上下左右边界的间隔的像素数。</p>
<h2 id="QToolButton"><a href="#QToolButton" class="headerlink" title="QToolButton"></a>QToolButton</h2><p>功能：工具按钮，常用于显示图片</p>
<ul>
<li>toolButtonStyle设置显示图片和文件的模式</li>
<li>autoRaise设置透明凸起效果</li>
</ul>
<h2 id="QRadioButton"><a href="#QRadioButton" class="headerlink" title="QRadioButton"></a>QRadioButton</h2><p>功能：单选按钮</p>
<ul>
<li>setChecked（true）设置默认选中</li>
</ul>
<p>用Group Box区分单选区间</p>
<h2 id="QCheckBox"><a href="#QCheckBox" class="headerlink" title="QCheckBox"></a>QCheckBox</h2><p>功能：复选按钮</p>
<p>信号：stateChanged（int）</p>
<p>参数int类型：</p>
<ol>
<li>0—未选中</li>
<li>1—半选中</li>
<li>2—选中</li>
</ol>
<h2 id="QListWidget"><a href="#QListWidget" class="headerlink" title="QListWidget"></a>QListWidget</h2><p>功能：列表控件，按列表显示东西</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建项：</span></span><br><span class="line">QListWidgetItem* item=<span class="keyword">new</span> <span class="built_in">QListWidgetItem</span>(<span class="string">&quot;锄禾日当午&quot;</span>);</span><br><span class="line"><span class="comment">//将项加载到列表控件中</span></span><br><span class="line">ui-&gt;listWidget-&gt;<span class="built_in">additem</span>(item);</span><br><span class="line"><span class="comment">//设置对齐方式</span></span><br><span class="line">item-&gt;<span class="built_in">setTextAlignment</span>(QT::AlignHCenter);</span><br><span class="line"><span class="comment">//可以一次性放入所有内容</span></span><br><span class="line">QStringList list;<span class="comment">//QStringList等同于QList&lt;QString&gt;</span></span><br><span class="line">list&lt;&lt;<span class="string">&quot;锄禾日当午&quot;</span>&lt;&lt;<span class="string">&quot;汗滴禾下土&quot;</span>&lt;&lt;<span class="string">&quot;谁知盘中餐&quot;</span>&lt;&lt;<span class="string">&quot;粒粒皆辛苦&quot;</span>;</span><br><span class="line">ui-&gt;listWidget-&gt;<span class="built_in">additems</span>(list);</span><br></pre></td></tr></table></figure>

<h2 id="QTreeWidget"><a href="#QTreeWidget" class="headerlink" title="QTreeWidget"></a>QTreeWidget</h2><p>功能：树控件，按树形显示东西</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置头</span></span><br><span class="line">ui-&gt;treeWidget-&gt;<span class="built_in">setHeaderLabels</span>(<span class="built_in">QStringList</span>()&lt;&lt;<span class="string">&quot;英雄&quot;</span>&lt;&lt;<span class="string">&quot;英雄简介&quot;</span>);</span><br><span class="line"><span class="comment">//创建根项目liItem</span></span><br><span class="line">QTreeWidgetItem* liItem=<span class="keyword">new</span> <span class="built_in">QTreeWidgetItem</span>(<span class="built_in">QStringList</span>()&lt;&lt;<span class="string">&quot;力量&quot;</span>);</span><br><span class="line"><span class="comment">//将根项目添加到树控件中</span></span><br><span class="line">ui-&gt;treeWidget-&gt;<span class="built_in">addTopLevelItem</span>(liItem);</span><br><span class="line"><span class="comment">//挂载子项目到根项目liItem中</span></span><br><span class="line">QTreeWidgetItem* i1=<span class="keyword">new</span> <span class="built_in">QTreeWidgetItem</span>(<span class="built_in">QStringList</span>()&lt;&lt;<span class="string">&quot;张飞&quot;</span>&lt;&lt;<span class="string">&quot;力大无比&quot;</span>);</span><br><span class="line">liItem-&gt;<span class="built_in">addChild</span>(i1);</span><br><span class="line"><span class="comment">//treeWidget中通过treeWidget的itemWidget来访问嵌套在treeWidget中的控件</span></span><br></pre></td></tr></table></figure>

<h2 id="QTableWidget"><a href="#QTableWidget" class="headerlink" title="QTableWidget"></a>QTableWidget</h2><p>功能：表格控件,按表格显示东西</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置列数</span></span><br><span class="line">ui-&gt;tableWidget-&gt;<span class="built_in">setColumnCount</span>(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//设置水平表头</span></span><br><span class="line">ui-&gt;tableWidget-&gt;<span class="built_in">setHorizontaliHeaderLabels</span>(<span class="built_in">QStringList</span>()&lt;&lt;<span class="string">&quot;姓名&quot;</span>&lt;&lt;<span class="string">&quot;性别&quot;</span>&lt;&lt;<span class="string">&quot;年龄&quot;</span>);</span><br><span class="line"><span class="comment">//设置行数</span></span><br><span class="line">ui-&gt;tableWidget-&gt;<span class="built_in">setRowCount</span>(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//设置正文</span></span><br><span class="line">ui-&gt;tableWidget-&gt;<span class="built_in">setItem</span>(行,列,<span class="keyword">new</span> <span class="built_in">QTableWidgetItem</span>(<span class="string">&quot;字符串&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setSelectionBehavior</span>(QAbstractItemView::SelectRows);<span class="comment">//设置表格选中单个单元格的方式</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setEditTriggers</span>(QAbstractItemView::DoubleClicked);<span class="comment">//双击修改</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setSelectionMode</span>(QAbstractItemView::SingleSelection);<span class="comment">//单个选中和多个选中的设置</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">verticalHeader</span>()-&gt;<span class="built_in">setVisible</span>(<span class="literal">false</span>); <span class="comment">//隐藏列表头</span></span><br><span class="line">    QFont font =<span class="keyword">this</span>-&gt;<span class="built_in">horizontalHeader</span>()-&gt;<span class="built_in">font</span>(); <span class="comment">//先获取字体</span></span><br><span class="line">    font.<span class="built_in">setBold</span>(<span class="literal">true</span>); <span class="comment">//字体设置为粗体</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">horizontalHeader</span>()-&gt;<span class="built_in">setFont</span>(font); <span class="comment">//设置每一列的标题字体为粗体</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setAlternatingRowColors</span>(<span class="literal">true</span>); <span class="comment">// 隔行变色</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setPalette</span>(<span class="built_in">QPalette</span>(Qt::gray)); <span class="comment">// 设置隔行变色的颜色  gray灰色</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setFont</span>(<span class="built_in">QFont</span>(<span class="string">&quot;song&quot;</span>, <span class="number">16</span>));<span class="comment">//设置字体大小</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setSortingEnabled</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setFocusPolicy</span>(Qt::NoFocus);<span class="comment">//设置初始无焦点，防止一开始焦点为第一行导致按删除直接删除第一行</span></span><br><span class="line"></span><br><span class="line">ui-&gt;tableWidget_bankInfo-&gt;<span class="built_in">resizeColumnsToContents</span>();</span><br><span class="line">            ui-&gt;tableWidget_bankInfo-&gt;<span class="built_in">resizeRowsToContents</span>();</span><br><span class="line">            ui-&gt;tableWidget_bankInfo-&gt;<span class="built_in">horizontalHeader</span>()-&gt;<span class="built_in">setStretchLastSection</span>(<span class="literal">false</span>);<span class="comment">//必须一关一开才能实现实时变化</span></span><br><span class="line">            ui-&gt;tableWidget_bankInfo-&gt;<span class="built_in">horizontalHeader</span>()-&gt;<span class="built_in">setStretchLastSection</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<h2 id="其他控件"><a href="#其他控件" class="headerlink" title="其他控件"></a>其他控件</h2><p>栈控件QStackedWidget</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ui-&gt;stackedWidget-&gt;<span class="built_in">setCurrentIndex</span>(<span class="number">0</span>);<span class="comment">//切换栈显示内容</span></span><br></pre></td></tr></table></figure>

<p>下拉框QComboBox</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ui-&gt;comboBox-&gt;<span class="built_in">addItem</span>(<span class="string">&quot;奔驰&quot;</span>);</span><br><span class="line"><span class="comment">//设置选中</span></span><br><span class="line">ui-&gt;comboBox-&gt;<span class="built_in">SetCurrentIndex</span>(<span class="number">2</span>);</span><br><span class="line">ui-&gt;comboBox-&gt;<span class="built_in">SetCurrentText</span>(<span class="string">&quot;拖拉机&quot;</span>);</span><br><span class="line"><span class="comment">//可以设置绑定值</span></span><br><span class="line">ui-&gt;comboBox_excelMode-&gt;<span class="built_in">addItem</span>(<span class="string">&quot;微软office&quot;</span>,<span class="number">10000</span>);</span><br><span class="line">ui-&gt;comboBox_excelMode-&gt;<span class="built_in">addItem</span>(<span class="string">&quot;WPS&quot;</span>,<span class="number">10001</span>);</span><br><span class="line"><span class="comment">//读取当前选中绑定值</span></span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;(ui-&gt;comboBox_excelMode-&gt;<span class="built_in">itemData</span>(ui-&gt;comboBox_excelMode-&gt;<span class="built_in">currentIndex</span>(),Qt::UserRole)).<span class="built_in">toInt</span>();</span><br></pre></td></tr></table></figure>

<p>还有许多Qt中控件的使用方法可参考Qt提供的帮助文档。</p>
<h2 id="自定义控件"><a href="#自定义控件" class="headerlink" title="自定义控件"></a>自定义控件</h2><p>在搭建Qt窗口界面的时候，在一个项目中很多窗口，或者是窗口中的某个模块会被经常性的重复使用。一般遇到这种情况我们都会将这个窗口或者模块拿出来做成一个独立的窗口类，以备以后重复使用。</p>
<p>在使用Qt的ui文件搭建界面的时候，工具栏栏中只为我们提供了标准的窗口控件，如果我们想使用自定义控件怎么办？</p>
<p><strong>右键项目–添加新文件—选择Qt中的Qt设计师界面类，在ui文件中设计自定义控件</strong></p>
<p>也可以用代码的形式如下：</p>
<p>例如：我们从QWidget派生出一个类SmallWidget，实现了一个自定窗口，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// smallwidget.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmallWidget</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">	Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">SmallWidget</span><span class="params">(QWidget *parent = <span class="number">0</span>)</span></span>;</span><br><span class="line">signals:</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	QSpinBox* spin;</span><br><span class="line">	QSlider* slider;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// smallwidget.cpp</span></span><br><span class="line">SmallWidget::<span class="built_in">SmallWidget</span>(QWidget *parent) : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">	spin = <span class="keyword">new</span> <span class="built_in">QSpinBox</span>(<span class="keyword">this</span>);</span><br><span class="line">	slider = <span class="keyword">new</span> <span class="built_in">QSlider</span>(Qt::Horizontal, <span class="keyword">this</span>);</span><br><span class="line">	<span class="comment">// 创建布局对象</span></span><br><span class="line">	QHBoxLayout* layout = <span class="keyword">new</span> QHBoxLayout;</span><br><span class="line">	<span class="comment">// 将控件添加到布局中</span></span><br><span class="line">	layout-&gt;<span class="built_in">addWidget</span>(spin);</span><br><span class="line">	layout-&gt;<span class="built_in">addWidget</span>(slider);</span><br><span class="line">	<span class="comment">// 将布局设置到窗口中</span></span><br><span class="line">	<span class="built_in">setLayout</span>(layout);</span><br><span class="line">	<span class="comment">// 添加消息响应</span></span><br><span class="line">	<span class="built_in">connect</span>(spin,<span class="built_in">static_cast</span>&lt;<span class="built_in">void</span> (QSpinBox::*)(<span class="type">int</span>)&gt;(&amp;QSpinBox::valueChanged),slider, &amp;QSlider::setValue);<span class="comment">//因为有重载版本所以要强转为对应重载版本的指针</span></span><br><span class="line">	<span class="built_in">connect</span>(slider, &amp;QSlider::valueChanged,spin, &amp;QSpinBox::setValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps44.jpg" alt="img"></p>
<p>那么这个SmallWidget可以作为独立的窗口显示,也可以作为一个控件来使用：</p>
<p>打开Qt的.ui文件,因为SmallWidget是派生自Qwidget类,所以需要在ui文件中先放入一个QWidget控件, 然后再上边鼠标右键</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps23.jpg" alt="img"></p>
<p>弹出提升窗口部件对话框</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps66.jpg" alt="img"></p>
<p>添加要提升的类的名字,然后选择 添加</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps85.jpg" alt="img"></p>
<p>添加之后,类名会显示到上边的列表框中,然后单击提升按钮,完成操作.</p>
<p>我们可以看到, 这个窗口对应的类从原来的QWidget变成了SmallWidget</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps106.jpg" alt="img"></p>
<p>再次运行程序,这个widget_3中就能显示出我们自定义的窗口了.</p>
<h1 id="根据控件名找控件案例"><a href="#根据控件名找控件案例" class="headerlink" title="根据控件名找控件案例"></a>根据控件名找控件案例</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据label的名字找到该控件的指针,就可以操作他了 </span></span><br><span class="line">QLabel* label = <span class="keyword">this</span>-&gt;<span class="built_in">findChild</span>&lt;QLabel*&gt;(<span class="string">&quot;label&quot;</span>);</span><br><span class="line">label-&gt;<span class="built_in">setText</span>(arg1);</span><br></pre></td></tr></table></figure>

<h1 id="Qt消息机制和事件"><a href="#Qt消息机制和事件" class="headerlink" title="Qt消息机制和事件"></a>Qt消息机制和事件</h1><h2 id="事件（内含定时器）"><a href="#事件（内含定时器）" class="headerlink" title="事件（内含定时器）"></a>事件（内含定时器）</h2><p>事件（event）是由系统或者 Qt 本身在不同的时刻发出的。当用户按下鼠标、敲下键盘，或者是窗口需要重新绘制的时候，都会发出一个相应的事件。一些事件在对用户操作做出响应时发出，如键盘事件等；另一些事件则是由系统自动发出，如计时器事件。</p>
<p>在前面我们也曾经简单提到，<strong>Qt 程序</strong>需要在main()函数创建一个QApplication对象，然后调用它的exec()函数。这个函数就是开始 Qt 的事件循环。在执行exec()函数之后，程序将进入事件循环来监听应用程序的事件。当事件发生时，Qt 将创建一个事件对象。<strong>Qt 中所有事件类都继承于QEvent</strong>。在事件对象创建完毕后，Qt 将这个事件对象传递给QObject的event()函数。<strong>event()函数并不直接处理事件，而是按照事件对象的类型分派给特定的事件处理函数</strong>（event handler），关于这一点，会在后边详细说明。</p>
<h3 id="9-1-1-部分鼠标事件"><a href="#9-1-1-部分鼠标事件" class="headerlink" title="9.1.1 部分鼠标事件"></a>9.1.1 部分鼠标事件</h3><p>在所有组件的父类QWidget中，定义了很多事件处理的回调函数，如</p>
<ul>
<li>keyPressEvent()</li>
<li>keyReleaseEvent()</li>
<li>EnterEvent()</li>
<li>LeaveEvent()</li>
<li>mouseDoubleClickEvent()</li>
<li>mouseMoveEvent()</li>
<li>mousePressEvent()</li>
<li>mouseReleaseEvent() 等。</li>
</ul>
<p>这些函数都是 protected virtual 的，也就是说，我们可以在子类中重新实现这些函数。下面来看一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventLabel</span> : <span class="keyword">public</span> QLabel</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">mouseMoveEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">mouseReleaseEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLabel::mouseMoveEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取鼠标xy坐标，使用QMouseEvent对象的x()和y()函数</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">setText</span>(<span class="built_in">QString</span>(<span class="string">&quot;&lt;center&gt;&lt;h1&gt;Move: (%1, %2)&lt;/h1&gt;&lt;/center&gt;&quot;</span>).<span class="built_in">arg</span>(QString::<span class="built_in">number</span>(event-&gt;<span class="built_in">x</span>()),QString::<span class="built_in">number</span>(event-&gt;<span class="built_in">y</span>())));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLabel::mousePressEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">setText</span>(<span class="built_in">QString</span>(<span class="string">&quot;&lt;center&gt;&lt;h1\&gt;Press:(%1, %2)&lt;/h1&gt;&lt;/center&gt;&quot;</span>).<span class="built_in">arg</span>(QString::<span class="built_in">number</span>(event-&gt;<span class="built_in">x</span>()),QString::<span class="built_in">number</span>(event-&gt;<span class="built_in">y</span>())));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLabel::mouseReleaseEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QString msg;</span><br><span class="line">	msg.<span class="built_in">sprintf</span>(<span class="string">&quot;&lt;center&gt;&lt;h1&gt;Release: (%d, %d)&lt;/h1&gt;&lt;/center&gt;&quot;</span>,</span><br><span class="line">	event-&gt;<span class="built_in">x</span>(), event-&gt;<span class="built_in">y</span>());</span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">setText</span>(msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">	EventLabel *label = <span class="keyword">new</span> EventLabel;</span><br><span class="line">	label-&gt;<span class="built_in">setWindowTitle</span>(<span class="string">&quot;MouseEvent Demo&quot;</span>);</span><br><span class="line">	label-&gt;<span class="built_in">resize</span>(<span class="number">300</span>, <span class="number">200</span>);</span><br><span class="line">	label-&gt;<span class="built_in">show</span>();</span><br><span class="line">	<span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>EventLabel继承了QLabel，覆盖了mousePressEvent()、mouseMoveEvent()和MouseReleaseEvent()三个函数。我们并没有添加什么功能，只是在鼠标按下（press）、鼠标移动（move）和鼠标释放（release）的时候，把当前鼠标的坐标值显示在这个Label上面。由于QLabel是支持 HTML 代码的，因此我们直接使用了 HTML 代码来格式化文字。</p>
</li>
<li><p>QString的arg()函数可以自动替换掉QString中出现的占位符。其占位符以 % 开始，后面是占位符的位置，例如 %1，%2 这种。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">QString</span>(<span class="string">&quot;[%1, %2]&quot;</span>).<span class="built_in">arg</span>(x).<span class="built_in">arg</span>(y);</span><br></pre></td></tr></table></figure>

<p>语句将会使用x替换 %1，y替换 %2，因此，生成的QString为[x, y]。</p>
<ul>
<li>在mouseReleaseEvent()函数中，我们使用了另外一种QString的构造方法。我们使用类似 C 风格的格式化函数sprintf()来构造QString。</li>
</ul>
<p>运行上面的代码，当我们点击了一下鼠标之后，label 上将显示鼠标当前坐标值。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps130.jpg" alt="img"></p>
<p>为什么要点击鼠标之后才能在mouseMoveEvent()函数中显示鼠标坐标值？</p>
<p><strong>这是因为QWidget中有一个mouseTracking属性，该属性用于设置是否追踪鼠标。只有鼠标被追踪时，mouseMoveEvent()才会发出。如果mouseTracking是 false（默认即是），组件在至少一次鼠标点击之后，才能够被追踪，也就是能够发出mouseMoveEvent()事件。如果mouseTracking为 true，则mouseMoveEvent()直接可以被发出。</strong></p>
<p>知道了这一点，我们就可以在main()函数中添加如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label-&gt;<span class="built_in">setMouseTracking</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>在运行程序就没有这个问题了。</p>
<h3 id="9-1-2-定时器"><a href="#9-1-2-定时器" class="headerlink" title="9.1.2 定时器"></a>9.1.2 定时器</h3><p>定时器使用方法主要有两种</p>
<ol>
<li><p>定时器事件 void timerEvent(QTimerEvent *e)</p>
<p>启动定时器 id1&#x3D;startTimer(毫秒)</p>
<p>判断具体定时器标志 e-&gt;timerId()&#x3D;&#x3D;id1</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">id1=<span class="built_in">startTimer</span>(<span class="number">1000</span>);</span><br><span class="line">id2=<span class="built_in">startTimer</span>(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//定时器事件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::timerEvent</span><span class="params">(QTimerEvent *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(e-&gt;<span class="built_in">timerId</span>()==id1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//每隔1秒让label_1数字++</span></span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> num=<span class="number">1</span>;</span><br><span class="line">        ui-&gt;label_1-&gt;<span class="built_in">setText</span>(QString::<span class="built_in">number</span>(num++));</span><br><span class="line">	&#125;</span><br><span class="line">     <span class="keyword">if</span>(e-&gt;<span class="built_in">timerId</span>()==id2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//每隔2秒让label_2数字++</span></span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> num2=<span class="number">1</span>;</span><br><span class="line">        ui-&gt;label_2-&gt;<span class="built_in">setText</span>(QString::<span class="built_in">number</span>(num2++));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过定时器类实现  QTimer类</p>
</li>
</ol>
<p>   创建定时器对象 Qtimer* timer1&#x3D;new QTimer(this);</p>
<p>   开启定时器  timer1-&gt;start(x毫秒)  每隔x毫秒会抛出一个timeout信号出来</p>
<p>   connect连接信号处理逻辑</p>
<p>   暂停定时器 timer1-&gt;stop（）</p>
   <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建定时器对象</span></span><br><span class="line">QTimer* timer1=<span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);</span><br><span class="line">timer1-&gt;<span class="built_in">start</span>(<span class="number">500</span>);</span><br><span class="line"><span class="built_in">connect</span>(timer1,&amp;QTimer::timeout,[=]()&#123;</span><br><span class="line">   ui-&gt;label_1-&gt;<span class="built_in">setText</span>(QString::<span class="built_in">number</span>(num++)); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>只触发一次的定时器</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QTimer::<span class="built_in">singleShot</span>(<span class="number">500</span>,<span class="keyword">this</span>,[=]()&#123;<span class="comment">//this表示谁来执行</span></span><br><span class="line">   <span class="comment">//定时器500毫秒后只发送一次该信号，这里填入要做什么</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="event（）事件分发器"><a href="#event（）事件分发器" class="headerlink" title="event（）事件分发器"></a>event（）事件分发器</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E5%99%A8%E5%92%8C%E4%BA%8B%E4%BB%B6%E8%BF%87%E6%BB%A4%E5%99%A8.png" alt="事件分发器和事件过滤器"></p>
<p>事件对象创建完毕后，Qt 将这个事件对象传递给QObject的event()函数。event()函数并不直接处理事件，而是将这些事件对象按照它们不同的类型，分发给不同的事件处理器（event handler）。</p>
<p>如上所述，<strong>event()函数主要用于事件的分发</strong>。所以，如果你希望在事件分发之前做一些操作，就可以重写这个event()函数了。例如，我们希望在一个QWidget组件中监听 tab 键的按下，那么就可以继承QWidget，并重写它的event()函数，来达到这个目的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CustomWidget::event</span><span class="params">(QEvent *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (e-&gt;<span class="built_in">type</span>() == QEvent::KeyPress) &#123;</span><br><span class="line">		QKeyEvent *keyEvent = <span class="built_in">static_cast</span>&lt;QKeyEvent *&gt;(e);</span><br><span class="line">		<span class="keyword">if</span> (keyEvent-&gt;<span class="built_in">key</span>() == Qt::Key_Tab) &#123;</span><br><span class="line">			<span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;You press tab.&quot;</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> QWidget::<span class="built_in">event</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CustomWidget是一个普通的QWidget子类。我们重写了它的event()函数，这个函数有一个QEvent对象作为参数，也就是需要转发的事件对象。函数返回值是 bool 类型。</p>
<ul>
<li><p><strong>如果传入的事件已被识别并且处理，则需要返回 true，否则返回 false。如果返回值是 true，那么 Qt 会认为这个事件已经处理完毕，不会再将这个事件发送给其它对象，而是会继续处理事件队列中的下一事件。</strong></p>
</li>
<li><p><strong>在event()函数中，调用事件对象的accept()和ignore()函数是没有作用的，不会影响到事件的传播</strong>。</p>
</li>
</ul>
<p>我们可以通过使用QEvent::type()函数可以检查事件的实际类型，其返回值是QEvent::Type类型的枚举。我们处理过自己感兴趣的事件之后，可以直接返回 true，表示我们已经对此事件进行了处理；对于其它我们不关心的事件，则需要调用父类的event()函数继续转发，否则这个组件就只能处理我们定义的事件了。为了测试这一种情况，我们可以尝试下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CustomTextEdit::event</span><span class="params">(QEvent *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (e-&gt;<span class="built_in">type</span>() == QEvent::KeyPress)</span><br><span class="line">	&#123;</span><br><span class="line">		QKeyEvent *keyEvent = <span class="built_in">static_cast</span>&lt;QKeyEvent *&gt;(e);</span><br><span class="line">		<span class="keyword">if</span> (keyEvent-&gt;<span class="built_in">key</span>() == Qt::Key_Tab)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;You press tab.&quot;</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CustomTextEdit是QTextEdit的一个子类。我们重写了其event()函数，却没有调用父类的同名函数。这样，我们的组件就只能处理 Tab 键，再也无法输入任何文本，也不能响应其它事件，比如鼠标点击之后也不会有光标出现。这是因为我们只处理的KeyPress类型的事件，并且如果不是KeyPress事件，则直接返回 false，鼠标事件根本不会被转发，也就没有了鼠标事件。</p>
<p>通过查看QObject::event()的实现，我们可以理解，event()函数同前面的章节中我们所说的事件处理器有什么联系：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//!!! Qt5</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QObject::event</span><span class="params">(QEvent *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (e-&gt;<span class="built_in">type</span>()) &#123;</span><br><span class="line">		<span class="keyword">case</span> QEvent::Timer:</span><br><span class="line">			<span class="built_in">timerEvent</span>((QTimerEvent*)e);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> QEvent::ChildAdded:</span><br><span class="line">		<span class="keyword">case</span> QEvent::ChildPolished:</span><br><span class="line">		<span class="keyword">case</span> QEvent::ChildRemoved:</span><br><span class="line">			<span class="built_in">childEvent</span>((QChildEvent*)e);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">if</span> (e-&gt;<span class="built_in">type</span>() &gt;= QEvent::User) &#123;</span><br><span class="line">				<span class="built_in">customEvent</span>(e);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是 Qt 5 中QObject::event()函数的源代码（Qt 4 的版本也是类似的）。我们可以看到，同前面我们所说的一样，Qt 也是使用QEvent::type()判断事件类型，然后调用了特定的事件处理器。比如，如果event-&gt;type()返回值是QEvent::Timer，则调用timerEvent()函数。可以想象，QWidget::event()中一定会有如下的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (event-&gt;<span class="built_in">type</span>()) &#123;</span><br><span class="line">	<span class="keyword">case</span> QEvent::MouseMove:</span><br><span class="line">		<span class="built_in">mouseMoveEvent</span>((QMouseEvent*)event);</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事实也的确如此。timerEvent()和mouseMoveEvent()这样的函数，就是我们前面章节所说的事件处理器 event handler。也就是说，<strong>event()函数中实际是通过事件处理器来响应一个具体的事件。这相当于event()函数将具体事件的处理”委托”给具体的事件处理器。而这些事件处理器是 protected virtual 的，因此，我们重写了某一个事件处理器，即可让 Qt 调用我们自己实现的版本。</strong></p>
<p>由此可以见，event()是一个集中处理不同类型的事件的地方。如果你不想重写一大堆事件处理器，就可以重写这个event()函数，通过QEvent::type()判断不同的事件。鉴于重写event()函数需要十分小心注意父类的同名函数的调用，一不留神就可能出现问题，所以<strong>一般还是建议只重写事件处理器</strong>（当然，也必须记得是不是应该调用父类的同名处理器）。这其实暗示了event()函数的另外一个作用：屏蔽掉某些不需要的事件处理器。正如我们前面的CustomTextEdit例子看到的那样，我们创建了一个只能响应 tab 键的组件。这种作用是重写事件处理器所不能实现的。</p>
<h2 id="事件过滤器"><a href="#事件过滤器" class="headerlink" title="事件过滤器"></a>事件过滤器</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E5%99%A8%E5%92%8C%E4%BA%8B%E4%BB%B6%E8%BF%87%E6%BB%A4%E5%99%A8.png" alt="事件分发器和事件过滤器"></p>
<p>有时候，对象需要查看、甚至要拦截发送到另外对象的事件。例如，对话框可能想要拦截按键事件，不让别的组件接收到；或者要修改回车键的默认处理。</p>
<p>通过前面的章节，我们已经知道，Qt 创建了QEvent事件对象之后，会调用QObject的event()函数处理事件的分发。显然，我们可以在event()函数中实现拦截的操作。由于event()函数是 protected 的，因此，需要继承已有类。如果组件很多，就需要重写很多个event()函数。这当然相当麻烦，更不用说重写event()函数还得小心一堆问题。好在 Qt 提供了另外一种机制来达到这一目的：事件过滤器。</p>
<p>QObject有一个eventFilter()函数，用于建立事件过滤器。函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">QObject::eventFilter</span> <span class="params">( QObject * watched, QEvent * event )</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个函数正如其名字显示的那样，是一个”事件过滤器”。所谓事件过滤器，可以理解成一种过滤代码。事件过滤器会检查接收到的事件。如果这个事件是我们感兴趣的类型，就进行我们自己的处理；如果不是，就继续转发。这个函数返回一个 bool 类型，如果你想将参数 event 过滤出来，比如，<strong>不想让它继续转发，就返回 true，否则返回 false。</strong>事件过滤器的调用时间是目标对象（也就是参数里面的watched对象）接收到事件对象之前。也就是说，如果你在事件过滤器中停止了某个事件，那么，watched对象以及以后所有的事件过滤器根本不会知道这么一个事件。</p>
<p>我们来看一段简单的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MainWindow</span>();</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">eventFilter</span><span class="params">(QObject *obj, QEvent *event)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	QTextEdit *textEdit;</span><br><span class="line">&#125;;</span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">	textEdit = <span class="keyword">new</span> QTextEdit;</span><br><span class="line">	<span class="built_in">setCentralWidget</span>(textEdit);</span><br><span class="line">	textEdit-&gt;<span class="built_in">installEventFilter</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MainWindow::eventFilter</span><span class="params">(QObject *obj, QEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (obj == textEdit) &#123;<span class="comment">//区分哪个控件</span></span><br><span class="line">		<span class="keyword">if</span> (event-&gt;<span class="built_in">type</span>() == QEvent::KeyPress) &#123;<span class="comment">//区分事件</span></span><br><span class="line">			QKeyEvent *keyEvent = <span class="built_in">static_cast</span>&lt;QKeyEvent *&gt;(event);</span><br><span class="line">			<span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Ate key press&quot;</span> &lt;&lt; keyEvent-&gt;<span class="built_in">key</span>();</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// pass the event on to the parent class</span></span><br><span class="line">		<span class="keyword">return</span> QMainWindow::<span class="built_in">eventFilter</span>(obj, event);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>MainWindow是我们定义的一个类。我们重写了它的eventFilter()函数。为了过滤特定组件上的事件，首先需要判断这个对象是不是我们感兴趣的组件，然后判断这个事件的类型。在上面的代码中，我们不想让textEdit组件处理键盘按下的事件。所以，首先我们找到这个组件，如果这个事件是键盘事件，则直接返回 true，也就是过滤掉了这个事件，其他事件还是要继续处理，所以返回 false。对于其它的组件，我们并不保证是不是还有过滤器，于是最保险的办法是调用父类的函数。</p>
</li>
<li><p>eventFilter()函数相当于创建了过滤器，然后我们需要安装这个过滤器。安装过滤器需要调用QObject::installEventFilter()函数。函数的原型如下：</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QObject::installEventFilter</span> <span class="params">( QObject * filterObj )</span></span></span><br></pre></td></tr></table></figure>

<p>这个函数接受一个QObject *类型的参数。记得刚刚我们说的，eventFilter()函数是QObject的一个成员函数，因此，任意QObject都可以作为事件过滤器（问题在于，如果你没有重写eventFilter()函数，这个事件过滤器是没有任何作用的，因为默认什么都不会过滤）。已经存在的过滤器则可以通过QObject::removeEventFilter()函数移除。</p>
<ul>
<li>我们可以向一个对象上面安装多个事件处理器，只要调用多次installEventFilter()函数。如果一个对象存在多个事件过滤器，那么，<strong>最后一个安装的会第一个执行，也就是后进先执行</strong>的顺序。</li>
</ul>
<p>还记得我们前面的那个例子吗？我们使用event()函数处理了 Tab 键：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CustomWidget::event</span><span class="params">(QEvent *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (e-&gt;<span class="built_in">type</span>() == QEvent::KeyPress) &#123;</span><br><span class="line">		QKeyEvent *keyEvent = <span class="built_in">static_cast</span>&lt;QKeyEvent *&gt;(e);</span><br><span class="line">		<span class="keyword">if</span> (keyEvent-&gt;<span class="built_in">key</span>() == Qt::Key_Tab) &#123;</span><br><span class="line">			<span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;You press tab.&quot;</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">		<span class="keyword">return</span> QWidget::<span class="built_in">event</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们可以给出一个使用事件过滤器的版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">FilterObject::eventFilter</span><span class="params">(QObject *object, QEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (object == target &amp;&amp; event-&gt;<span class="built_in">type</span>() == QEvent::KeyPress)</span><br><span class="line">	&#123;</span><br><span class="line">		QKeyEvent *keyEvent = <span class="built_in">static_cast</span>&lt;QKeyEvent *&gt;(event);</span><br><span class="line">		<span class="keyword">if</span> (keyEvent-&gt;<span class="built_in">key</span>() == Qt::Key_Tab) &#123;</span><br><span class="line">			<span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;You press tab.&quot;</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事件过滤器的强大之处在于，我们可以为整个应用程序添加一个事件过滤器。记得，installEventFilter()函数是QObject的函数，QApplication或者QCoreApplication对象都是QObject的子类，因此，我们可以向QApplication或者QCoreApplication添加事件过滤器。<strong>这种全局的事件过滤器将会在所有其它特性对象的事件过滤器之前调用。尽管很强大，但这种行为会严重降低整个应用程序的事件分发效率。</strong>因此，除非是不得不使用的情况，否则的话我们不应该这么做。</p>
<p><strong>注意，</strong></p>
<p><strong>事件过滤器和被安装过滤器的组件必须在同一线程，否则，过滤器将不起作用。另外，如果在安装过滤器之后，这两个组件到了不同的线程，那么，只有等到二者重新回到同一线程的时候过滤器才会有效。</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Qt 的事件是整个 Qt 框架的核心机制之一，也比较复杂。说它复杂，更多是因为它涉及到的函数众多，而处理方法也很多，有时候让人难以选择。现在我们简单总结一下 Qt 中的事件机制。</p>
<p>Qt 中有很多种事件：鼠标事件、键盘事件、大小改变的事件、位置移动的事件等等。如何处理这些事件，实际有两种选择：</p>
<ul>
<li>所有事件对应一个事件处理函数，在这个事件处理函数中用一个很大的分支语句进行选择，其代表作就是 win32 API 的WndProc()函数：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hWnd,</span></span></span><br><span class="line"><span class="params"><span class="function">                         UINT message,</span></span></span><br><span class="line"><span class="params"><span class="function">                         WPARAM wParam,</span></span></span><br><span class="line"><span class="params"><span class="function">                         LPARAM lParam)</span></span></span><br></pre></td></tr></table></figure>

<p>在这个函数中，我们需要使用switch语句，选择message参数的类型进行处理，典型代码是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(message)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> WM_PAINT:</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>每一种事件对应一个事件处理函数。Qt 就是使用的这么一种机制：</p>
<ul>
<li><p>mouseEvent()</p>
</li>
<li><p>keyPressEvent()</p>
</li>
<li><p>…</p>
</li>
</ul>
</li>
</ul>
<p>Qt 具有这么多种事件处理函数，肯定有一个地方对其进行分发，否则，Qt 怎么知道哪一种事件调用哪一个事件处理函数呢？**这个分发的函数，就是event()**。显然，当QMouseEvent产生之后，event()函数将其分发给mouseEvent()事件处理器进行处理。</p>
<p>event()函数会有两个问题：</p>
<ul>
<li><p>event()函数是一个 protected 的函数，这意味着我们要想重写event()，必须继承一个已有的类。试想，<strong>我的程序根本不想要鼠标事件，程序中所有组件都不允许处理鼠标事件，是不是我得继承所有组件</strong>，一一重写其event()函数？protected 函数带来的另外一个问题是，如果我基于第三方库进行开发，而对方<strong>没有提供源代码，只有一个链接库，其它都是封装好的。我怎么去继承这种库中的组件呢？</strong></p>
</li>
<li><p>event()函数的确有一定的控制，不过有时候我的需求更严格一些：我<strong>希望那些组件根本看不到这种事件</strong>。event()函数虽然可以拦截，但其实也是接收到了QMouseEvent对象。我连让它收都收不到。这样做的好处是，模拟一种系统根本没有那个事件的效果，所以其它组件根本不会收到这个事件，也就无需修改自己的事件处理函数。这种需求怎么办呢？</p>
</li>
</ul>
<p>这两个问题是event()函数无法处理的。于是，Qt 提供了另外一种解决方案：事件过滤器。事件过滤器给我们一种能力，让我们能够完全移除某种事件。<strong>事件过滤器可以安装到任意QObject类型上面，并且可以安装多个</strong>。如果要实现全局的事件过滤器，则可以安装到QApplication或者QCoreApplication上面。这里需要注意的是，如果使用installEventFilter()函数给一个对象安装事件过滤器，那么该事件过滤器只对该对象有效，只有这个对象的事件需要先传递给事件过滤器的eventFilter()函数进行过滤，其它对象不受影响。如果给QApplication对象安装事件过滤器，那么该过滤器对程序中的每一个对象都有效，任何对象的事件都是先传给eventFilter()函数。</p>
<p><strong>事件过滤器可以解决刚刚我们提出的event()函数的两点不足：</strong></p>
<ul>
<li><p><strong>首先，事件过滤器不是 protected 的，因此我们可以向任何QObject子类安装事件过滤器；</strong></p>
</li>
<li><p><strong>其次，事件过滤器在目标对象接收到事件之前进行处理，如果我们将事件过滤掉，目标对象根本不会见到这个事件。</strong></p>
</li>
</ul>
<p>事实上，还有一种方法，我们没有介绍。Qt 事件的调用最终都会追溯到QCoreApplication::notify()函数，因此，最大的控制权实际上是重写QCoreApplication::notify()。这个函数的声明是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">QCoreApplication::notify</span> <span class="params">( QObject * receiver,QEvent * event )</span></span>;</span><br></pre></td></tr></table></figure>

<p>该函数会将event发送给receiver，也就是调用receiver-&gt;event(event)，其返回值就是来自receiver的事件处理器。注意，这个函数为任意线程的任意对象的任意事件调用，因此，它不存在事件过滤器的线程的问题。不过我们并不推荐这么做，因为notify()函数只有一个，而事件过滤器要灵活得多。</p>
<p><strong>现在我们可以总结一下 Qt 的事件处理，实际上是有五个层次：</strong></p>
<ul>
<li><p>重写paintEvent()、mousePressEvent()等事件处理函数。这是最普通、最简单的形式，同时功能也最简单。</p>
</li>
<li><p>重写event()函数。event()函数是所有对象的事件入口，QObject和QWidget中的实现，默认是把事件传递给特定的事件处理函数。</p>
</li>
<li><p>在特定对象上面安装事件过滤器。该过滤器仅过滤该对象接收到的事件。</p>
</li>
<li><p>在QCoreApplication::instance()上面安装事件过滤器。该过滤器将过滤所有对象的所有事件，因此和notify()函数一样强大，但是它更灵活，因为可以安装多个过滤器。全局的事件过滤器可以看到 disabled 组件上面发出的鼠标事件。全局过滤器有一个问题：只能用在主线程。</p>
</li>
<li><p>重写QCoreApplication::notify()函数。这是最强大的，和全局事件过滤器一样提供完全控制，并且不受线程的限制。但是全局范围内只能有一个被使用（因为QCoreApplication是单例的）。</p>
</li>
</ul>
<h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a><strong>自定义事件</strong></h2><p>事件的分发既可以是同步的，又可以是异步的，而信号槽的回调总是同步的。并且事件可以使用过滤器</p>
<h3 id="自定义事件的类型"><a href="#自定义事件的类型" class="headerlink" title="自定义事件的类型"></a><strong>自定义事件的类型</strong></h3><p>QT自定义事件需要继承QEvent。QEvent提供一个QEvent::Type类型的参数，作为自定义事件的类型值。</p>
<p>QEvent::Type是QEvent定义的一个枚举。需要注意的是自定义事件类型不能和已经存在的type值重复，否则会有不可预料的错误发生，因为系统会将新增加的自定义事件当做系统事件进行派发和调用。QT中，系统保留0 – 999的值，自定义事件的type要大于 999。QT定义了两个边界值：QEvent::User和QEvent::MaxUser，自定义事件的type应该在两个值的范围之间。其中，QEvent::User的值是1000，QEvent::MaxUser的值是65535。通过这两个枚举值，可以保证自定义的事件类型不会覆盖系统定义的事件类型。但并不能保证自定义事件相互之间不会被覆盖。为了避免自定义事件间的相互覆盖，QT提供了一个函数：registerEventType()，用于自定义事件的注册。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">QEvent::registerEventType</span> <span class="params">( <span class="type">int</span> hint = <span class="number">-1</span> )</span></span>;</span><br></pre></td></tr></table></figure>

<p>registerEventType函数是static的，可以使用QEvent类直接调用。函数返回值是向系统注册的新的Type类型的值。如果hint是合法的，即hint不会发生任何覆盖（系统的以及其它自定义事件的），则会直接返回这个值；否则，系统会自动分配一个合法值并返回。使用registerEventType函数即可完成type 值的指定。registerEventType函数是线程安全的，不必另外添加同步。</p>
<h3 id="事件的发送方式"><a href="#事件的发送方式" class="headerlink" title="事件的发送方式"></a><strong>事件的发送方式</strong></h3><p>可以在自定义事件中添加所需要的数据，然后进行事件的发送。</p>
<p>QT提供了两种事件发送方式：</p>
<p>A、非阻塞式发送</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">QCoreApplication::sendEvent</span><span class="params">(QObject *receiver,QEvent *event)</span></span>;</span><br></pre></td></tr></table></figure>

<p>直接将event事件发送给receiver接收者，使用的是QCoreApplication::notify()函数。函数返回值就是事件处理函数的返回值。在事件被发送的时候，event对象并不会被销毁。通常会在栈上创建event对象，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QMouseEvent <span class="title">event</span><span class="params">(QEvent::MouseButtonPress, pos, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">QApplication::<span class="built_in">sendEvent</span>(receiver, &amp;event);</span><br></pre></td></tr></table></figure>

<p>B、阻塞式发送</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">QCoreApplication::postEvent</span><span class="params">(QObject *receiver,QEvent *event)</span></span>;</span><br></pre></td></tr></table></figure>

<p>将event事件及其接收者receiver一同追加到事件队列中，函数立即返回。</p>
<p><strong>因为post事件队列会持有事件对象，并且在其post的时候将其delete掉，因此，必须在堆上创建event对象。当对象被发送之后，再试图访问event对象就会出现问题（因为post后，event对象就会被delete）。</strong></p>
<p>当控制权返回到主线程循环时，保存在事件队列中的所有事件都通过notify()函数发送出去。</p>
<p>事件会根据post的顺序进行处理。如果想要改变事件的处理顺序，可以考虑为其指定一个优先级。默认的优先级是Qt::NormalEventPriority。</p>
<p>postEvent函数是线程安全的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">QCoreApplication::sendPostedEvents</span><span class="params">(QObject *receiver,<span class="type">int</span> event_type)</span></span>;</span><br></pre></td></tr></table></figure>

<p>sendPostedEvents函数的作用是将事件队列中的接收者为receiver，事件类似为event_type的所有事件立即发送给receiver进行处理。需要注意的是，来自窗口系统的事件并不由sendPostedEvents函数进行处理，而是processEvent()。</p>
<h3 id="自定义事件处理函数"><a href="#自定义事件处理函数" class="headerlink" title="自定义事件处理函数"></a>自定义事件处理函数</h3><p>​    自定义事件的处理既可以定义一个自定义事件处理函数，也可以在event()函数中直接处理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CustomWidget::customEvent</span><span class="params">(QEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CustomEvent *customEvent = <span class="built_in">static_cast</span>&lt;CustomEvent *&gt;(event);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CustomWidget::event</span><span class="params">(QEvent *event)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event-&gt;<span class="built_in">type</span>() == CustomEventType) </span><br><span class="line">    &#123;</span><br><span class="line">        CustomEvent *myEvent = <span class="built_in">static_cast</span>&lt;CustomEvent *&gt;(event);</span><br><span class="line">        <span class="comment">// processing...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> QWidget::<span class="built_in">event</span>(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="绘图和绘图设备"><a href="#绘图和绘图设备" class="headerlink" title="绘图和绘图设备"></a>绘图和绘图设备</h1><h2 id="QPainter"><a href="#QPainter" class="headerlink" title="QPainter"></a>QPainter</h2><p>Qt 的绘图系统允许使用相同的 API 在屏幕和其它打印设备上进行绘制。整个绘图系统基于QPainter，QPainterDevice和QPaintEngine三个类。</p>
<p><strong>QPainter</strong>用来执行绘制的操作；<strong>QPaintDevice</strong>是一个二维空间的抽象，这个二维空间允许QPainter在其上面进行绘制，也就是QPainter工作的空间；<strong>QPaintEngine</strong>提供了画笔（QPainter）在不同的设备上进行绘制的统一的接口。QPaintEngine类应用于QPainter和QPaintDevice之间，通常对开发人员是透明的。除非你需要自定义一个设备，否则你是不需要关心QPaintEngine这个类的。我们可以把QPainter理解成画笔；把QPaintDevice理解成使用画笔的地方，比如纸张、屏幕等；而对于纸张、屏幕而言，肯定要使用不同的画笔绘制，为了统一使用一种画笔，我们设计了QPaintEngine类，这个类让不同的纸张、屏幕都能使用一种画笔。</p>
<p>下图给出了这三个类之间的层次结构:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210505145620325.png" alt="image-20210505145620325"></p>
<p>上面的示意图告诉我们，<strong>Qt 的绘图系统实际上是，使用QPainter在QPainterDevice上进行绘制，它们之间使用QPaintEngine进行通讯（也就是翻译QPainter的指令）。</strong></p>
<p>下面我们通过一个实例来介绍QPainter的使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PaintedWidget</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">	Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">PaintedWidget</span>(QWidget *parent = <span class="number">0</span>);</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent *)</span></span>;<span class="comment">//绘图事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意我们重写了QWidget的paintEvent()函数。接下来就是PaintedWidget的源代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PaintedWidget::<span class="built_in">PaintedWidget</span>(QWidget *parent) :<span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">resize</span>(<span class="number">800</span>, <span class="number">600</span>);</span><br><span class="line">	<span class="built_in">setWindowTitle</span>(<span class="built_in">tr</span>(<span class="string">&quot;Paint Demo\&quot;));</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">void PaintedWidget::paintEvent(QPaintEvent *)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">	QPainter painter(this);</span></span><br><span class="line"><span class="string">	painter.drawLine(80, 100, 650, 500);</span></span><br><span class="line"><span class="string">	painter.setPen(Qt::red);</span></span><br><span class="line"><span class="string">	painter.drawRect(10, 10, 100, 400);</span></span><br><span class="line"><span class="string">	painter.setPen(QPen(Qt::green, 5));</span></span><br><span class="line"><span class="string">	painter.setBrush(Qt::blue);</span></span><br><span class="line"><span class="string">	painter.drawEllipse(50, 150, 400, 200);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>在构造函数中，我们仅仅设置了窗口的大小和标题。而paintEvent()函数则是绘制的代码。首先，我们在栈上创建了一个QPainter对象，也就是说，每次运行paintEvent()函数的时候，都会重建这个QPainter对象。注意，<strong>这一点可能会引发某些细节问题</strong>：由于我们每次重建QPainter，因此第一次运行时所设置的画笔颜色、状态等，第二次再进入这个函数时就会全部丢失。有时候我们希望保存画笔状态，就必须自己保存数据，否则的话则需要将QPainter作为类的成员变量。</p>
<p>QPainter接收一个QPaintDevice指针作为参数。QPaintDevice有很多子类，比如QImage，以及QWidget。注意回忆一下，QPaintDevice可以理解成要在哪里去绘制，而现在我们希望画在这个组件，因此传入的是 this 指针。</p>
<p>QPainter有很多以 draw 开头的函数，用于各种图形的绘制，比如这里的drawLine()，drawRect()以及drawEllipse()等。当绘制轮廓线时，使用QPainter的pen()属性。比如，我们调用了painter.setPen(Qt::red)将 pen 设置为红色，则下面绘制的矩形具有红色的轮廓线。接下来，我们将 pen 修改为绿色，5 像素宽（painter.setPen(QPen(Qt::green, 5))），又设置了画刷为蓝色。这时候再调用 draw 函数，则是具有绿色 5 像素宽轮廓线、蓝色填充的椭圆。</p>
<p>QPainter高级设置：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置抗锯齿</span></span><br><span class="line">painter.<span class="built_in">setRenderHint</span>(QPainter::Antialiasing);</span><br><span class="line"><span class="comment">//移动QPaint起始点（本来默认是左上角）</span></span><br><span class="line">painter.<span class="built_in">translate</span>(<span class="number">100</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//保存QPaint起始点起始点位置</span></span><br><span class="line">painter.<span class="built_in">save</span>();</span><br><span class="line"><span class="comment">//取出QPaint起始点起始点位置、</span></span><br><span class="line">painter.<span class="built_in">restore</span>();</span><br><span class="line"><span class="comment">//手动调用绘图事件</span></span><br><span class="line"><span class="built_in">update</span>();</span><br></pre></td></tr></table></figure>

<p><strong>Qt 中update()和repaint()的区别</strong></p>
<ul>
<li><strong>update()方法</strong></li>
</ul>
<p>这种方法其实是将重绘的事件加入到Qt的事件列表中，不一定马上就会重绘得出你想要的效果。在同一时刻你要是多次调用update()，Qt会将它们自动合并为一个update()。这样的好处是不会产生闪烁。</p>
<ul>
<li><strong>repaint()方法</strong></li>
</ul>
<p>这个方法是立即重绘！但是不建议经常使用，只需要在需要的特效区域调用即可。</p>
<h2 id="绘图设备"><a href="#绘图设备" class="headerlink" title="绘图设备"></a>绘图设备</h2><p><strong>绘图设备是指继承QPainterDevice的子类。</strong>Qt提供了很多这样的类，例如QPixmap、QBitmap、QImage和 QPicture。其中，</p>
<ul>
<li><p>QPixmap专门为图像在屏幕上的显示做了优化</p>
</li>
<li><p>QBitmap是QPixmap的一个子类，它的色深限定为1，可以使用 QPixmap的isQBitmap()函数来确定这个QPixmap是不是一个QBitmap。</p>
</li>
<li><p>QImage专门为图像的像素级访问做了优化。</p>
</li>
<li><p>QPicture则可以记录和重现QPainter的各条命令。(此QPicture并非图片，而是类似记录和还原一个绘图流程)</p>
</li>
</ul>
<h3 id="QPixmap、QBitmap、QImage"><a href="#QPixmap、QBitmap、QImage" class="headerlink" title="QPixmap、QBitmap、QImage"></a>QPixmap、QBitmap、QImage</h3><p>QPixmap继承了QPaintDevice，因此，你可以使用QPainter直接在上面绘制图形。QPixmap也可以接受一个字符串作为一个文件的路径来显示这个文件，比如你想在程序之中打开png、jpeg之类的文件，就可以使用 QPixmap。使用QPainter的drawPixmap()函数可以把这个文件绘制到一个QLabel、QPushButton或者其他的设备上面。<strong>QPixmap是针对屏幕进行特殊优化的，因此，它与实际的底层显示设备息息相关。</strong>注意，这里说的显示设备并不是硬件，而是操作系统提供的原生的绘图引擎。所以，在不同的操作系统平台下，QPixmap的显示可能会有所差别。</p>
<p><strong>QBitmap继承自QPixmap，因此具有QPixmap的所有特性，提供单色图像</strong>。QBitmap的色深始终为1. 色深这个概念来自计算机图形学，是指用于表现颜色的二进制的位数。我们知道，计算机里面的数据都是使用二进制表示的。为了表示一种颜色，我们也会使用二进制。比如我们要表示8种颜色，需要用3个二进制位，这时我们就说色深是3. 因此，所谓色深为1，也就是使用1个二进制位表示颜色。1个位只有两种状态：0和1，因此它所表示的颜色就有两种，黑和白。所以说，<strong>QBitmap实际上是只有黑白两色的图像数据。</strong></p>
<p><strong>由于QBitmap色深小，因此只占用很少的存储空间，所以适合做光标文件和笔刷。</strong></p>
<p>下面我们来看同一个图像文件在QPixmap和QBitmap下的不同表现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PaintWidget::paintEvent</span><span class="params">(QPaintEvent *)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">QPixmap <span class="title">pixmap</span><span class="params">(<span class="string">&quot;:/Image/butterfly.png&quot;</span>)</span></span>;</span><br><span class="line">	<span class="function">QPixmap <span class="title">pixmap1</span><span class="params">(<span class="string">&quot;:/Image/butterfly1.png&quot;</span>)</span></span>;</span><br><span class="line">	<span class="function">QBitmap <span class="title">bitmap</span><span class="params">(<span class="string">&quot;:/Image/butterfly.png&quot;</span>)</span></span>;</span><br><span class="line">	<span class="function">QBitmap <span class="title">bitmap1</span><span class="params">(<span class="string">&quot;:/Image/butterfly1.png&quot;</span>)</span></span>;</span><br><span class="line">	<span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">	painter.<span class="built_in">drawPixmap</span>(<span class="number">0</span>, <span class="number">0</span>, pixmap);</span><br><span class="line">	painter.<span class="built_in">drawPixmap</span>(<span class="number">200</span>, <span class="number">0</span>, pixmap1);</span><br><span class="line">	painter.<span class="built_in">drawPixmap</span>(<span class="number">0</span>, <span class="number">130</span>, bitmap);</span><br><span class="line">	painter.<span class="built_in">drawPixmap</span>(<span class="number">200</span>, <span class="number">130</span>, bitmap1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/clip_image001.png" alt="img"></p>
<p>这里我们给出了两张png图片。butterfly1.png是没有透明色的纯白背景，而butterfly.png是具有透明色的背景。我们分别使用QPixmap和QBitmap来加载它们。注意看它们的区别：白色的背景在QBitmap中消失了，而透明色在QBitmap中转换成了黑色；其他颜色则是使用点的疏密程度来体现的。</p>
<p>QPixmap使用底层平台的绘制系统进行绘制，无法提供像素级别的操作，而<strong>QImage则是使用独立于硬件的绘制系统，实际上是自己绘制自己，因此提供了像素级别的操作，并且能够在不同系统之上提供一个一致的显示形式。</strong></p>
<p>我们声明了一个QImage对象，大小是300 x 300，颜色模式是RGB32，即使用32位数值表示一个颜色的RGB值，也就是说每种颜色使用8位。然后我们对每个像素进行颜色赋值，从而构成了这个图像。我们可以把QImage想象成一个RGB颜色的二维数组，记录了每一像素的颜色。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PaintWidget::paintEvent</span><span class="params">(QPaintEvent *)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">	<span class="function">QImage <span class="title">image</span><span class="params">(<span class="number">300</span>, <span class="number">300</span>, QImage::Format_RGB32)</span></span>;</span><br><span class="line">	QRgb value;</span><br><span class="line">	<span class="comment">//将图片背景填充为白色</span></span><br><span class="line">	image.<span class="built_in">fill</span>(Qt::white);</span><br><span class="line">	<span class="comment">//改变指定区域的像素点的值</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">50</span>; i&lt;<span class="number">100</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">50</span>; j&lt;<span class="number">100</span>; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			value = <span class="built_in">qRgb</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 红色</span></span><br><span class="line">			image.<span class="built_in">setPixel</span>(i, j, value);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将图片绘制到窗口中</span></span><br><span class="line">	painter.<span class="built_in">drawImage</span>(<span class="built_in">QPoint</span>(<span class="number">0</span>, <span class="number">0</span>), image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210505200953174.png" alt="image-20210505200953174"></p>
<p>QImage与QPixmap的区别</p>
<ul>
<li><p>QPixmap主要是用于绘图，<strong>针对屏幕显示而最佳化设计</strong>，QImage主要是为图像I&#x2F;O、图片访问和像素修改而设计的</p>
</li>
<li><p>QPixmap依赖于所在的平台的绘图引擎，故例如反锯齿等一些效果在不同的平台上可能会有不同的显示效果，QImage使用Qt自身的绘图引擎，可在不同平台上具有相同的显示效果</p>
</li>
<li><p>由于QImage是独立于硬件的，也是一种QPaintDevice，因此我们可以在另一个线程中对其进行绘制，而不需要在GUI线程中处理，使用这一方式可以很<strong>大幅度提高UI响应速度</strong>。</p>
</li>
<li><p>QImage可通过setPixpel()和pixel()等方法直接存取指定的像素。</p>
</li>
</ul>
<p>QImage与QPixmap之间的转换:</p>
<ul>
<li>QImage转QPixmap</li>
</ul>
<p>使用QPixmap的静态成员函数: fromImage()</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QPixmap <span class="title">fromImage</span><span class="params">(<span class="type">const</span> QImage &amp; image,Qt::ImageConversionFlags flags = Qt::AutoColor)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>QPixmap转QImage:</li>
</ul>
<p>使用QPixmap类的成员函数: toImage()</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QImage <span class="title">toImage</span><span class="params">()</span> <span class="type">const</span></span></span><br></pre></td></tr></table></figure>

<h3 id="QPicture"><a href="#QPicture" class="headerlink" title="QPicture"></a>QPicture</h3><p>最后一个需要说明的是QPicture。<strong>这是一个可以记录和重现QPainter命令的绘图设备。</strong> <strong>QPicture将QPainter的命令序列化到一个IO设备，保存为一个平台独立的文件格式。</strong>这种格式有时候会是”元文件(meta- files)”。Qt的这种格式是二进制的，不同于某些本地的元文件，Qt的pictures文件没有内容上的限制，只要是能够被QPainter绘制的元素，不论是字体还是pixmap，或者是变换，都可以保存进一个picture中。</p>
<p><strong>QPicture是平台无关的</strong>，因此它可以使用在多种设备之上，比如svg、pdf、ps、打印机或者屏幕。回忆下我们这里所说的QPaintDevice，实际上是说可以有QPainter绘制的对象。QPicture使用系统的分辨率，并且可以调整 QPainter来消除不同设备之间的显示差异。</p>
<p>如果我们要记录下QPainter的命令，首先要使用QPainter::begin()函数，将QPicture实例作为参数传递进去，以便告诉系统开始记录，记录完毕后使用QPainter::end()命令终止。代码示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PaintWidget::paintEvent</span><span class="params">(QPaintEvent *)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QPicture pic;</span><br><span class="line">	QPainter painter;</span><br><span class="line">	<span class="comment">//将图像绘制到QPicture中,并保存到文件</span></span><br><span class="line">	painter.<span class="built_in">begin</span>(&amp;pic);</span><br><span class="line">	painter.<span class="built_in">drawEllipse</span>(<span class="number">20</span>, <span class="number">20</span>, <span class="number">100</span>, <span class="number">50</span>);</span><br><span class="line">	painter.<span class="built_in">fillRect</span>(<span class="number">20</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, Qt::red);</span><br><span class="line">	painter.<span class="built_in">end</span>();</span><br><span class="line">	pic.<span class="built_in">save</span>(<span class="string">&quot;D:\\drawing.pic&quot;</span>);<span class="comment">//后缀是什么都可以</span></span><br><span class="line">	<span class="comment">//将保存的绘图动作重新绘制到设备上</span></span><br><span class="line">	pic.<span class="built_in">load</span>(<span class="string">&quot;D:\\drawing.pic&quot;</span>);</span><br><span class="line">	painter.<span class="built_in">begin</span>(<span class="keyword">this</span>);</span><br><span class="line">	painter.<span class="built_in">drawPicture</span>(<span class="number">200</span>, <span class="number">200</span>, pic);</span><br><span class="line">	painter.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><p>文件操作是应用程序必不可少的部分。Qt 作为一个通用开发库，提供了跨平台的文件操作能力。Qt 通过QIODevice提供了对 I&#x2F;O 设备的抽象，这些设备具有读写字节块的能力。下面是 I&#x2F;O 设备的类图（Qt5）：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/clip_image002.png" alt="img"></p>
<ul>
<li><p>QIODevice：所有 I&#x2F;O 设备类的父类，提供了字节块读写的通用操作以及基本接口；</p>
</li>
<li><p>QFileDevice：Qt5新增加的类，提供了有关文件操作的通用实现。</p>
</li>
<li><p>QFlie：访问本地文件或者嵌入资源；</p>
</li>
<li><p>QTemporaryFile：创建和访问本地文件系统的临时文件；</p>
</li>
<li><p>QBuffer：读写QbyteArray, 内存文件；</p>
</li>
<li><p>QProcess：运行外部程序，处理进程间通讯；</p>
</li>
<li><p>QAbstractSocket：所有套接字类的父类；</p>
</li>
<li><p>QTcpSocket：TCP协议网络数据传输；</p>
</li>
<li><p>QUdpSocket：传输 UDP 报文；</p>
</li>
<li><p>QSslSocket：使用 SSL&#x2F;TLS 传输数据；</p>
</li>
</ul>
<p><strong>文件系统分类:</strong></p>
<ul>
<li>顺序访问设备:</li>
</ul>
<blockquote>
<p>是指它们的数据只能访问一遍：从头走到尾，从第一个字节开始访问，直到最后一个字节，中途不能返回去读取上一个字节，这其中，QProcess、QTcpSocket、QUdpSoctet和QSslSocket是顺序访问设备。</p>
</blockquote>
<ul>
<li>随机访问设备:</li>
</ul>
<blockquote>
<p>可以访问任意位置任意次数，还可以使用QIODevice::seek()函数来重新定位文件访问位置指针，QFile、QTemporaryFile和QBuffer是随机访问设备，</p>
</blockquote>
<h2 id="基本文件操作"><a href="#基本文件操作" class="headerlink" title="基本文件操作"></a>基本文件操作</h2><p>文件操作是应用程序必不可少的部分。Qt 作为一个通用开发库，提供了跨平台的文件操作能力。在所有的 I&#x2F;O 设备中，文件 I&#x2F;O 是最重要的部分之一。因为我们大多数的程序依旧需要首先访问本地文件（当然，在云计算大行其道的将来，这一观点可能改变）。<strong>QFile提供了从文件中读取和写入数据的能力。</strong></p>
<p><strong>我们通常会将文件路径作为参数传给QFile的构造函数。不过也可以在创建好对象最后，使用setFileName()来修改</strong>。QFile需要使用 &#x2F; 作为文件分隔符，不过，它会自动将其转换成操作系统所需要的形式。例如 C:&#x2F;windows 这样的路径在 Windows 平台下同样是可以的。</p>
<p>QFile主要提供了有关文件的各种操作，比如打开文件、关闭文件、刷新文件等。<strong>我们可以使用QDataStream或QTextStream类来读写文件，也可以使用QIODevice类提供的read()、readLine()、readAll()以及write()这样的函数。</strong>值得注意的是，<strong>有关文件本身的信息，比如文件名、文件所在目录的名字等，则是通过QFileInfo获取</strong>，而不是自己分析文件路径字符串。</p>
<p>下面我们使用一段代码来看看QFile的有关操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">	<span class="function">QFile <span class="title">file</span><span class="params">(<span class="string">&quot;in.txt\&quot;);</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">	if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) &#123;</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">		qDebug() &lt;&lt; &quot;</span>Open file failed.<span class="string">&quot;;</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">		return -1;</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">	&#125; else &#123;</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">        //下面可以直接用readAll取代循环readLine</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">		while (!file.atEnd()) &#123;//判断文件是否读到末尾</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">			qDebug() &lt;&lt; file.readLine();//读出来的类型是QByteArray类型</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">		&#125;</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">	&#125;</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">	QFileInfo info(file);</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">	qDebug() &lt;&lt; info.isDir();</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">	qDebug() &lt;&lt; info.isExecutable();</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">	qDebug() &lt;&lt; info.baseName();</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">	qDebug() &lt;&lt; info.completeBaseName();</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">	qDebug() &lt;&lt; info.suffix();</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">	qDebug() &lt;&lt; info.completeSuffix();</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">    file.close();//关闭文件对象</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">	return app.exec();</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">&#125;</span></span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>我们首先使用QFile创建了一个文件对象。</li>
</ul>
<blockquote>
<p>这个文件名字是 in.txt。如果你不知道应该把它放在哪里，可以使用QDir::currentPath()来获得应用程序执行时的当前路径。只要将这个文件放在与当前路径一致的目录下即可。</p>
</blockquote>
<ul>
<li>使用open()函数打开这个文件，打开形式是只读方式，文本格式。</li>
</ul>
<blockquote>
<p>这个类似于fopen()的 r 这样的参数。open()函数返回一个 bool 类型，如果打开失败，我们在控制台输出一段提示然后程序退出。否则，我们利用 while 循环，将每一行读到的内容输出。</p>
</blockquote>
<ul>
<li>可以使用QFileInfo info(文件路径)获取有关该文件的信息。</li>
</ul>
<blockquote>
<p>QFileInfo有很多类型的函数，我们只举出一些例子。比如：</p>
</blockquote>
<ul>
<li>info.isDir()检查该文件是否是目录；</li>
<li>info.isExecutable() 检查该文件是否是可执行文件等。</li>
<li>info.baseName() 可以直接获得文件名；</li>
<li>info.completeBaseName() 获取完整的文件名</li>
<li>info.suffix() 则直接获取文件后缀名。</li>
<li>info.completeSuffix() 获取完整的文件后缀</li>
<li>info.size()文件大小</li>
<li>info.filename()文件名</li>
<li>info.filePath()文件路径</li>
<li>info.created()创建日期（返回值为QDateTime，需要使用toString函数转为自己指定的输出格式）</li>
<li>info.lastModify()修改日期（返回值为QDateTime，需要使用toString函数转为自己指定的输出格式）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info.<span class="built_in">lastModify</span>().<span class="built_in">toString</span>(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>我们可以由下面的示例看到，baseName()和completeBaseName()，以及suffix()和completeSuffix()的区别：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QFileInfo <span class="title">fi</span><span class="params">(<span class="string">&quot;/tmp/archive.tar.gz&quot;</span>)</span></span>;</span><br><span class="line">QString base = fi.<span class="built_in">baseName</span>(); <span class="comment">// base = &quot;archive&quot;</span></span><br><span class="line">QString base = fi.<span class="built_in">completeBaseName</span>(); <span class="comment">// base = &quot;archive.tar&quot;</span></span><br><span class="line">QString ext = fi.<span class="built_in">suffix</span>(); <span class="comment">// ext = &quot;gz&quot;</span></span><br><span class="line">QString ext = fi.<span class="built_in">completeSuffix</span>(); <span class="comment">// ext = &quot;tar.gz&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>【注意】</strong></p>
<p>QByteArray类型可以转换字符编码格式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如下将gbk格式的QByteArray类型对象array转换为unicode编码格式</span></span><br><span class="line">QTextCodec* codec=TextCodec::<span class="built_in">codecForName</span>(<span class="string">&quot;gbk&quot;</span>);</span><br><span class="line">codec-&gt;<span class="built_in">toUnicode</span>(array);</span><br></pre></td></tr></table></figure>

<h2 id="二进制文件读写"><a href="#二进制文件读写" class="headerlink" title="二进制文件读写"></a>二进制文件读写</h2><p><strong>QDataStream</strong>提供了基于QIODevice的二进制数据的序列化。数据流是一种二进制流，这种流<strong>完全不依赖</strong>于底层操作系统、CPU 或者字节顺序（大端或小端）。例如，在安装了 Windows 平台的 PC 上面写入的一个数据流，可以不经过任何处理，直接拿到运行了 Solaris 的 SPARC 机器上读取。由于数据流就是二进制流，因此我们也可以<strong>直接读写没有编码的二进制数据，例如图像、视频、音频</strong>等。</p>
<p><strong>QDataStream既能够存取 C++ 基本类型，如 int、char、short 等，也可以存取复杂的数据类型，例如自定义的类。实际上，QDataStream对于类的存储，是将复杂的类分割为很多基本单元实现的。</strong></p>
<p>结合QIODevice，QDataStream可以很方便地对文件、网络套接字等进行读写操作。我们从代码开始看起：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QFile <span class="title">file</span><span class="params">(<span class="string">&quot;file.dat&quot;</span>)</span></span>;</span><br><span class="line">file.<span class="built_in">open</span>(QIODevice::WriteOnly);</span><br><span class="line"><span class="function">QDataStream <span class="title">out</span><span class="params">(&amp;file)</span></span>;</span><br><span class="line">out &lt;&lt; <span class="built_in">QString</span>(<span class="string">&quot;the answer is&quot;</span>);</span><br><span class="line">out &lt;&lt; (qint32)<span class="number">42</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在这段代码中，我们首先打开一个名为 file.dat 的文件（注意，我们为简单起见，并没有检查文件打开是否成功，这在正式程序中是不允许的）。然后，我们将刚刚创建的file对象的指针传递给一个QDataStream实例out。类似于std::cout标准输出流，QDataStream也重载了输出重定向&lt;&lt;运算符。后面的代码就很简单了：将”the answer is”和数字 42 输出到数据流。由于我们的 out 对象建立在file之上，因此相当于将问题和答案写入file。</p>
</li>
<li><p>需要指出一点：最好使用 Qt 整型来进行读写，比如程序中的qint32。这保证了在任意平台和任意编译器都能够有相同的行为。</p>
</li>
</ul>
<p>如果你直接运行这段代码，你会得到一个空白的 file.dat，并没有写入任何数据。这是因为我们的file没有正常关闭。<strong>为性能起见，数据只有在文件关闭时才会真正写入</strong>。因此，我们必须在最后添加一行代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file.<span class="built_in">close</span>(); <span class="comment">// 如果不想关闭文件，可以使用 file.flush();</span></span><br></pre></td></tr></table></figure>

<p>接下来我们将存储到文件中的答案取出来</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QFile <span class="title">file</span><span class="params">(<span class="string">&quot;file.dat&quot;</span>)</span></span>;</span><br><span class="line">file.<span class="built_in">open</span>(QIODevice::ReadOnly);</span><br><span class="line"><span class="function">QDataStream <span class="title">in</span><span class="params">(&amp;file)</span></span>;</span><br><span class="line">QString str;</span><br><span class="line">qint32 a;</span><br><span class="line">in &gt;&gt; str &gt;&gt; a;</span><br></pre></td></tr></table></figure>

<p><strong>唯一需要注意的是，你必须按照写入的顺序，将数据读取出来。顺序颠倒的话，程序行为是不确定的，严重时会直接造成程序崩溃。</strong></p>
<p>那么，既然QIODevice提供了read()、readLine()之类的函数，为什么还要有QDataStream呢？QDataStream同QIODevice有什么区别？区别在于，<strong>QDataStream提供流的形式，性能上一般比直接调用原始 API 更好一些。</strong>我们通过下面一段代码看看什么是流的形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QFile <span class="title">file</span><span class="params">(<span class="string">&quot;file.dat&quot;</span>)</span></span>;</span><br><span class="line">file.<span class="built_in">open</span>(QIODevice::ReadWrite);</span><br><span class="line"><span class="function">QDataStream <span class="title">stream</span><span class="params">(&amp;file)</span></span>;</span><br><span class="line">QString str = <span class="string">&quot;the answer is 42&quot;</span>;</span><br><span class="line">stream &lt;&lt; str;</span><br></pre></td></tr></table></figure>

<h2 id="文本文件读写"><a href="#文本文件读写" class="headerlink" title="文本文件读写"></a>文本文件读写</h2><p>上一节我们介绍了有关二进制文件的读写。二进制文件比较小巧，却不是人可读的格式。而文本文件是一种人可读的文件。为了操作这种文件，我们需要使用QTextStream类。QTextStream和QDataStream的使用类似，只不过它是操作纯文本文件的。</p>
<p>QTextStream会自动将 Unicode 编码同操作系统的编码进行转换，这一操作对开发人员是透明的。它也会将换行符进行转换，同样不需要自己处理。<strong>QTextStream使用16位的QChar作为基础的数据存储单位，同样，它也支持C++标准类型，如int等。实际上，这是将这种标准类型与字符串进行了相互转换。</strong></p>
<p>QTextStream同QDataStream的使用基本一致，例如下面的代码将把”The answer is 42”写入到 file.txt 文件中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QFile <span class="title">data</span><span class="params">(<span class="string">&quot;file.txt&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (data.<span class="built_in">open</span>(QFile::WriteOnly | QIODevice::Truncate))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">QTextStream <span class="title">out</span><span class="params">(&amp;data)</span></span>;</span><br><span class="line">	out &lt;&lt; <span class="string">&quot;The answer is &quot;</span> &lt;&lt; <span class="number">42</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，我们在open()函数中增加了QIODevice::Truncate打开方式。我们可以从下表中看到这些打开方式的区别：</p>
<p>枚举值 描述</p>
<ul>
<li><p>QIODevice::NotOpen 未打开</p>
</li>
<li><p>QIODevice::ReadOnly 以只读方式打开</p>
</li>
<li><p>QIODevice::WriteOnly 以只写方式打开</p>
</li>
<li><p>QIODevice::ReadWrite 以读写方式打开</p>
</li>
<li><p>QIODevice::Append 以追加的方式打开，</p>
</li>
</ul>
<blockquote>
<p>新增加的内容将被追加到文件末尾</p>
</blockquote>
<ul>
<li>QIODevice::Truncate 以重写的方式打开，在写入新的数据时会将原有</li>
</ul>
<blockquote>
<p>数据全部清除，游标设置在文件开头。</p>
</blockquote>
<ul>
<li>QIODevice::Text 在读取时，将行结束符转换成 \n；在写入时，</li>
</ul>
<blockquote>
<p>将行结束符转换成本地格式，例如 Win32 平台</p>
<p>上是 \r\n</p>
</blockquote>
<ul>
<li>QIODevice::Unbuffered 忽略缓存</li>
</ul>
<p>我们在这里使用了QFile::WriteOnly | QIODevice::Truncate，也就是以只写并且覆盖已有内容的形式操作文件。注意，QIODevice::Truncate会直接将文件内容清空。</p>
<p>虽然QTextStream的写入内容与QDataStream一致，但是读取时却会有些困难：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QFile <span class="title">data</span><span class="params">(<span class="string">&quot;file.txt&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (data.<span class="built_in">open</span>(QFile::ReadOnly))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">QTextStream <span class="title">in</span><span class="params">(&amp;data)</span></span>;</span><br><span class="line">	QString str;</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	in &gt;&gt; str &gt;&gt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用QDataStream的时候，这样的代码很方便，但是使用了QTextStream时却有所不同：读出的时候，str 里面将是 The answer is 42，ans 是 0。这是因为<strong>当使用QDataStream写入的时候，实际上会在要写入的内容前面，额外添加一个这段内容的长度值。而以文本形式写入数据，是没有数据之间的分隔的。</strong>因此，使用文本文件时，很少会将其分割开来读取，而是使用诸如使用：</p>
<ul>
<li><p>QTextStream::readLine() 读取一行</p>
</li>
<li><p>QTextStream::readAll()读取所有文本</p>
</li>
</ul>
<p>这种函数之后再对获得的QString对象进行处理。</p>
<p>默认情况下，QTextStream的编码格式是 Unicode（不是UTF-8），如果我们需要使用另外的编码，可以使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream.<span class="built_in">setCodec</span>(<span class="string">&quot;UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这样的函数进行设置。</p>
<h1 id="QT简单的动画效果"><a href="#QT简单的动画效果" class="headerlink" title="QT简单的动画效果"></a>QT简单的动画效果</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建动画对象</span></span><br><span class="line">QPropertyAnimation *animation=<span class="keyword">new</span> <span class="built_in">QPropertyAnimation</span>(<span class="keyword">this</span>,<span class="string">&quot;geometry&quot;</span>);</span><br><span class="line"><span class="comment">//设置动画时间间隔</span></span><br><span class="line">animation-&gt;<span class="built_in">setDuration</span>(<span class="number">200</span>);</span><br><span class="line"><span class="comment">//设置起始位置</span></span><br><span class="line">animation-&gt;<span class="built_in">setStartValue</span>(<span class="built_in">QRect</span>(<span class="keyword">this</span>-&gt;<span class="built_in">x</span>(),<span class="keyword">this</span>-&gt;<span class="built_in">y</span>()<span class="number">+10</span>,<span class="keyword">this</span>-&gt;<span class="built_in">width</span>(),<span class="keyword">this</span>-&gt;<span class="built_in">height</span>()));</span><br><span class="line"><span class="comment">//设置结束位置</span></span><br><span class="line">animation-&gt;<span class="built_in">setEndValue</span>(<span class="built_in">QRect</span>(<span class="keyword">this</span>-&gt;<span class="built_in">x</span>(),<span class="keyword">this</span>-&gt;<span class="built_in">y</span>(),<span class="keyword">this</span>-&gt;<span class="built_in">width</span>(),<span class="keyword">this</span>-&gt;<span class="built_in">height</span>()));</span><br><span class="line"><span class="comment">//设置弹起效果//意思是设置移动轨迹（帮助文档中查setEasingCurve）</span></span><br><span class="line">animation-&gt;<span class="built_in">setEasingCurve</span>(QEasingCurve::OutBounce);</span><br><span class="line"><span class="comment">//让动画执行（参数为设置动画停止后释放动画对象）</span></span><br><span class="line">animation-&gt;<span class="built_in">start</span>(QAbstractAnimation::DeleteWhenStopped);</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/CSND_Ayo/article/details/70175385">帧动画参考</a></p>
<h1 id="QT添加音效"><a href="#QT添加音效" class="headerlink" title="QT添加音效"></a>QT添加音效</h1><p>使用前提：</p>
<ol>
<li>头文件：<code>#include &lt;QSound&gt;</code></li>
<li>模块文件：QT+&#x3D;multimedia</li>
</ol>
<p>首先，类似图片添加进资源文件夹</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QSound* mySound=<span class="keyword">new</span> <span class="built_in">QSound</span>(<span class="string">&quot;:/res/xxx.wav&quot;</span>,<span class="keyword">this</span>);<span class="comment">//音效在资源中的路径</span></span><br><span class="line">mySound-&gt;<span class="built_in">setLoops</span>(<span class="number">5</span>);<span class="comment">//可以设置重复多少次，设置-1表示重复无限次</span></span><br><span class="line">mySound-&gt;<span class="built_in">play</span>();<span class="comment">//开始音效</span></span><br></pre></td></tr></table></figure>

<h1 id="优化细节"><a href="#优化细节" class="headerlink" title="优化细节"></a>优化细节</h1><p>可复用的各场景间转移通过show和hide来进行，如果要毁灭只用一次的场景直接delete</p>
<p>各场景之间的场景转移同步位置</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setGeometry</span>(chooseScene-&gt;<span class="built_in">geometry</span>());<span class="comment">//设置到前一个场景的同一个位置</span></span><br></pre></td></tr></table></figure>

<h1 id="qt-setData-和data"><a href="#qt-setData-和data" class="headerlink" title="qt setData()和data()"></a>qt setData()和data()</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>在GUI开发中，往往需要在界面中存储一些有用的数据，这些数据可以来自配置文件、注册表、[[数据库]]、或者是Server。</p>
<p>无论来自哪里，这些数据对于用户来说都是至关重要的，它们在交互过程中大部分都会被用到，例如：单击一个用户头像，显示该用户的详细信息（等级、昵称、姓名、个人说明）。</p>
<h2 id="常见接口"><a href="#常见接口" class="headerlink" title="常见接口"></a>常见接口</h2><p>Qt中，可以通过绝大部分已有的接口来存数数据、获取数据。例如：</p>
<ul>
<li>存储数据<ul>
<li>setData()</li>
<li>setItemData()</li>
<li>setUserData()</li>
</ul>
</li>
<li>获取数据：<ul>
<li>data()</li>
<li>itemData()</li>
<li>userData()</li>
</ul>
</li>
</ul>
<h1 id="QT多线程"><a href="#QT多线程" class="headerlink" title="QT多线程"></a>QT多线程</h1><p>在进行桌面应用程序开发的时候， 假设应用程序在某些情况下需要处理比较复杂的逻辑， 如果只有一个线程去处理，就会导致窗口卡顿，无法处理用户的相关操作。这种情况下就需要使用多线程，其中一个线程处理窗口事件，其他线程进行逻辑运算，多个线程各司其职，不仅可以提高用户体验还可以提升程序的执行效率。</p>
<p>在 qt 中使用了多线程，有些事项是需要额外注意的：</p>
<ul>
<li>默认的线程在Qt中称之为窗口线程，也叫主线程，负责窗口事件处理或者窗口控件数据的更新</li>
<li>子线程负责后台的业务逻辑处理，子线程中不能对窗口对象做任何操作，这些事情需要交给窗口线程处理</li>
<li>主线程和子线程之间如果要进行数据的传递，需要使用Qt中的信号槽机制</li>
</ul>
<h2 id="线程类-QThread"><a href="#线程类-QThread" class="headerlink" title="线程类 QThread"></a>线程类 QThread</h2><p>Qt 中提供了一个线程类，通过这个类就可以创建子线程了，Qt 中一共提供了<strong>两种创建子线程</strong>的方式，后边会依次介绍其使用方式。先来看一下这个类中提供的一些常用 API 函数：</p>
<p>常用共用成员函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// QThread 类常用 API</span></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">QThread::<span class="built_in">QThread</span>(QObject *parent = Q_NULLPTR);</span><br><span class="line"><span class="comment">// 判断线程中的任务是不是处理完毕了</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QThread::isFinished</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 判断子线程是不是在执行任务</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QThread::isRunning</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Qt中的线程可以设置优先级</span></span><br><span class="line"><span class="comment">// 得到当前线程的优先级</span></span><br><span class="line"><span class="function">Priority <span class="title">QThread::priority</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QThread::setPriority</span><span class="params">(Priority priority)</span></span>;</span><br><span class="line">优先级:</span><br><span class="line">    QThread::IdlePriority		--&gt; 最低的优先级</span><br><span class="line">    QThread::LowestPriority</span><br><span class="line">    QThread::LowPriority</span><br><span class="line">    QThread::NormalPriority</span><br><span class="line">    QThread::HighPriority</span><br><span class="line">    QThread::HighestPriority</span><br><span class="line">    QThread::TimeCriticalPriority</span><br><span class="line">    QThread::InheritPriority    --&gt; 最高的优先级, 默认是这个</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 退出线程, 停止底层的事件循环</span></span><br><span class="line"><span class="comment">// 退出线程的工作函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QThread::exit</span><span class="params">(<span class="type">int</span> returnCode = <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="comment">// 调用线程退出函数之后, 线程不会马上退出因为当前任务有可能还没有完成, 调回用这个函数是</span></span><br><span class="line"><span class="comment">// 等待任务完成, 然后退出线程, 一般情况下会在 exit() 后边调用这个函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QThread::wait</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> time = ULONG_MAX)</span></span>;</span><br></pre></td></tr></table></figure>

<p>信号槽</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 和调用 exit() 效果是一样的</span></span><br><span class="line"><span class="comment">// 代用这个函数之后, 再调用 wait() 函数</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QThread::quit</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 启动子线程</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QThread::start</span><span class="params">(Priority priority = InheritPriority)</span></span>;</span><br><span class="line"><span class="comment">// 线程退出, 可能是会马上终止线程, 一般情况下不使用这个函数</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">QThread::terminate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程中执行的任务完成了, 发出该信号</span></span><br><span class="line"><span class="comment">// 任务函数中的处理逻辑执行完毕了</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QThread::finished</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 开始工作之前发出这个信号, 一般不使用</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QThread::started</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>静态函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个指向管理当前执行线程的QThread的指针</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QThread *<span class="title">QThread::currentThread</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 返回可以在系统上运行的理想线程数 == 和当前电脑的 CPU 核心数相同</span></span><br><span class="line">[<span class="type">static</span>] <span class="function"><span class="type">int</span> <span class="title">QThread::idealThreadCount</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 线程休眠函数</span></span><br><span class="line">[<span class="type">static</span>] <span class="function"><span class="type">void</span> <span class="title">QThread::msleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> msecs)</span></span>;	<span class="comment">// 单位: 毫秒</span></span><br><span class="line">[<span class="type">static</span>] <span class="function"><span class="type">void</span> <span class="title">QThread::sleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> secs)</span></span>;	<span class="comment">// 单位: 秒</span></span><br><span class="line">[<span class="type">static</span>] <span class="function"><span class="type">void</span> <span class="title">QThread::usleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> usecs)</span></span>;	<span class="comment">// 单位: 微秒</span></span><br></pre></td></tr></table></figure>

<p>任务处理函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子线程要处理什么任务, 需要写到 run() 中</span></span><br><span class="line">[<span class="keyword">virtual</span> <span class="keyword">protected</span>] <span class="function"><span class="type">void</span> <span class="title">QThread::run</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个 run() 是一个虚函数，如果想让创建的子线程执行某个任务，需要写一个子类让其继承 QThread，并且在子类中重写父类的 run() 方法，函数体就是对应的任务处理流程。另外，这个函数是一个受保护的成员函数，不能够在类的外部调用，如果想要让线程执行这个函数中的业务流程，需要通过当前线程对象调用槽函数 start() 启动子线程，当子线程被启动，这个 run() 函数也就在线程内部被调用了。</p>
<p><strong>QThread new出来的对象的释放</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QThread* t1=<span class="keyword">new</span> QThread;</span><br><span class="line">t1-&gt;<span class="built_in">quit</span>();</span><br><span class="line">t1-&gt;<span class="built_in">wait</span>();</span><br><span class="line">t1-&gt;<span class="built_in">deletelater</span>();<span class="comment">//等同于delete t1;</span></span><br></pre></td></tr></table></figure>

<h2 id="第一种创建子线程"><a href="#第一种创建子线程" class="headerlink" title="第一种创建子线程"></a>第一种创建子线程</h2><h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><ol>
<li><p>需要创建一个线程类的子类，让其继承 QT 中的线程类 QThread，比如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span>:<span class="keyword">public</span> QThread</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重写父类的 run () 方法，在该函数内部编写子线程要处理的具体的业务流程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span>:<span class="keyword">public</span> QThread</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ........</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在主线程中创建子线程对象，new 一个就可以了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyThread * subThread = <span class="keyword">new</span> MyThread;</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动子线程，调用 start () 方法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subThread-&gt;<span class="built_in">start</span>();</span><br></pre></td></tr></table></figure></li>
</ol>
<p><code>不能在类的外部调用 run () 方法启动子线程，在外部调用 start () 相当于让 run () 开始运行</code></p>
<p>当子线程别创建出来之后，父子线程之间的通信可以通过信号槽的方式，<strong>注意事项</strong>:</p>
<ul>
<li>在 Qt 中在<strong>子线程中不要操作程序中的窗口类型对象</strong>，不允许，如果操作了程序就挂了</li>
<li><strong>只有主线程才能操作程序中的窗口对象</strong>，默认的线程就是主线程，自己创建的就是子线程</li>
</ul>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>举一个简单的数数的例子，假如只有一个线程，让其一直数数，会发现数字并不会在窗口中时时更新，并且这时候如果用户使用鼠标拖动窗口，就会出现无响应的情况，使用多线程就不会出现这样的现象了。</p>
<p>在下面的窗口中，点击按钮开始在子线程中数数，让后通过信号槽机制将数据传递给 UI 线程，通过 UI 线程将数据更新到窗口中。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/1.gif" alt="1"></p>
<p>mythread.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYTHREAD_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYTHREAD_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QThread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> : <span class="keyword">public</span> QThread</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyThread</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="comment">// 自定义信号, 传递数据</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">curNumber</span><span class="params">(<span class="type">int</span> num)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MYTHREAD_H</span></span></span><br></pre></td></tr></table></figure>

<p>mythread.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mythread.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line">MyThread::<span class="built_in">MyThread</span>(QObject *parent) : <span class="built_in">QThread</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyThread::run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;当前线程对象的地址: &quot;</span> &lt;&lt; QThread::<span class="built_in">currentThread</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">emit <span class="title">curNumber</span><span class="params">(num++)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">10000000</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        QThread::<span class="built_in">usleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;run() 执行完毕, 子线程退出...&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mainwindow.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mythread.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">QMainWindow</span>(parent),</span><br><span class="line">    <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;主线程对象地址:  &quot;</span> &lt;&lt; QThread::<span class="built_in">currentThread</span>();</span><br><span class="line">    <span class="comment">// 创建子线程</span></span><br><span class="line">    MyThread* subThread = <span class="keyword">new</span> MyThread;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(subThread, &amp;MyThread::curNumber, <span class="keyword">this</span>, [=](<span class="type">int</span> num)</span><br><span class="line">    &#123;</span><br><span class="line">        ui-&gt;label-&gt;<span class="built_in">setNum</span>(num);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;startBtn, &amp;QPushButton::clicked, <span class="keyword">this</span>, [=]()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 启动子线程</span></span><br><span class="line">        subThread-&gt;<span class="built_in">start</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种在程序中添加子线程的方式是非常简单的，但是也有弊端，假设要在一个子线程中处理多个任务，所有的处理逻辑都需要写到run()函数中，这样该函数中的处理逻辑就会变得非常混乱，不太容易维护。</p>
<h2 id="第二种创建子线程的方式"><a href="#第二种创建子线程的方式" class="headerlink" title="第二种创建子线程的方式"></a>第二种创建子线程的方式</h2><h3 id="操作步骤-1"><a href="#操作步骤-1" class="headerlink" title="操作步骤"></a>操作步骤</h3><p>Qt 提供的第二种线程的创建方式弥补了第一种方式的缺点，用起来更加灵活，但是这种方式写起来会相对复杂一些，其具体操作步骤如下：</p>
<ol>
<li><p>创建一个新的类，让这个类从 QObject 派生</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyWork</span>:<span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在这个类中添加一个公共的成员函数，函数体就是我们要子线程中执行的业务逻辑</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyWork</span>:<span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    .......</span><br><span class="line">    <span class="comment">// 函数名自己指定, 叫什么都可以, 参数可以根据实际需求添加</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">working</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在主线程中创建一个 QThread 对象，这就是子线程的对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QThread* sub = <span class="keyword">new</span> QThread;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在主线程中创建工作的类对象（<strong>千万不要指定给创建的对象指定父对象</strong>）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyWork* work = <span class="keyword">new</span> <span class="built_in">MyWork</span>(<span class="keyword">this</span>);    <span class="comment">// error</span></span><br><span class="line">MyWork* work = <span class="keyword">new</span> MyWork;          <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将 MyWork 对象移动到创建的子线程对象中，需要调用 QObject 类提供的 moveToThread() 方法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// void QObject::moveToThread(QThread *targetThread);</span></span><br><span class="line"><span class="comment">// 如果给work指定了父对象, 这个函数调用就失败了</span></span><br><span class="line"><span class="comment">// 提示： QObject::moveToThread: Cannot move objects with a parent</span></span><br><span class="line">work-&gt;<span class="built_in">moveToThread</span>(sub);	<span class="comment">// 移动到子线程中工作</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>启动子线程，调用 start(), 这时候线程启动了，但是移动到线程中的对象并没有工作</p>
</li>
<li><p>调用 MyWork 类对象的工作函数，让这个函数开始执行，这时候是在移动到的那个子线程中运行的</p>
</li>
</ol>
<h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><p>假设函数处理上面在程序中数数的这个需求，具体的处理代码如下：</p>
<p>mywork.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYWORK_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYWORK_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QObject&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyWork</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyWork</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 工作函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">working</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">curNumber</span><span class="params">(<span class="type">int</span> num)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MYWORK_H</span></span></span><br></pre></td></tr></table></figure>

<p>mywork.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mywork.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QThread&gt;</span></span></span><br><span class="line"></span><br><span class="line">MyWork::<span class="built_in">MyWork</span>(QObject *parent) : <span class="built_in">QObject</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyWork::working</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;当前线程对象的地址: &quot;</span> &lt;&lt; QThread::<span class="built_in">currentThread</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">emit <span class="title">curNumber</span><span class="params">(num++)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">10000000</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        QThread::<span class="built_in">usleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;run() 执行完毕, 子线程退出...&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mainwindow.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QThread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mywork.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">QMainWindow</span>(parent),</span><br><span class="line">    <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;主线程对象的地址: &quot;</span> &lt;&lt; QThread::<span class="built_in">currentThread</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程对象</span></span><br><span class="line">    QThread* sub = <span class="keyword">new</span> QThread;</span><br><span class="line">    <span class="comment">// 创建工作的类对象</span></span><br><span class="line">    <span class="comment">// 千万不要指定给创建的对象指定父对象</span></span><br><span class="line">    <span class="comment">// 如果指定了: QObject::moveToThread: Cannot move objects with a parent</span></span><br><span class="line">    MyWork* work = <span class="keyword">new</span> MyWork;</span><br><span class="line">    <span class="comment">// 将工作的类对象移动到创建的子线程对象中</span></span><br><span class="line">    work-&gt;<span class="built_in">moveToThread</span>(sub);</span><br><span class="line">    <span class="comment">// 启动线程</span></span><br><span class="line">    sub-&gt;<span class="built_in">start</span>();</span><br><span class="line">    <span class="comment">// 让工作的对象开始工作, 点击开始按钮, 开始工作</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;startBtn, &amp;QPushButton::clicked, work, &amp;MyWork::working);</span><br><span class="line">    <span class="comment">// 显示数据</span></span><br><span class="line">    <span class="built_in">connect</span>(work, &amp;MyWork::curNumber, <span class="keyword">this</span>, [=](<span class="type">int</span> num)</span><br><span class="line">    &#123;</span><br><span class="line">        ui-&gt;label-&gt;<span class="built_in">setNum</span>(num);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用这种多线程方式，假设有多个不相关的业务流程需要被处理，那么就可以创建多个类似于 MyWork 的类，将业务流程放多类的公共成员函数中，然后将这个业务类的实例对象移动到对应的子线程中 moveToThread() 就可以了，这样可以让编写的程序更加灵活，可读性更强，更易于维护。</p>
<h2 id="QT线程池"><a href="#QT线程池" class="headerlink" title="QT线程池"></a>QT线程池</h2><h3 id="线程池的原理"><a href="#线程池的原理" class="headerlink" title="线程池的原理"></a>线程池的原理</h3><p>我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题：如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。</p>
<p>那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务呢？</p>
<p>线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。线程池线程都是后台线程。每个线程都使用默认的堆栈大小，以默认的优先级运行，并处于多线程单元中。如果某个线程在托管代码中空闲（如正在等待某个事件）, 则线程池将插入另一个辅助线程来使所有处理器保持繁忙。如果所有线程池线程都始终保持繁忙，但队列中包含挂起的工作，则线程池将在一段时间后创建另一个辅助线程但线程的数目永远不会超过最大值。超过最大值的线程可以排队，但他们要等到其他线程完成后才启动。</p>
<p>在各个编程语言的语种中都有线程池的概念，并且很多语言中直接提供了线程池，作为程序猿直接使用就可以了，下面给大家介绍一下线程池的实现原理：</p>
<p>线程池的组成主要分为 3 个部分，这三部分配合工作就可以得到一个完整的线程池：</p>
<p>（1）任务队列，存储需要处理的任务，由工作的线程来处理这些任务</p>
<ul>
<li>通过线程池提供的 API 函数，将一个待处理的任务添加到任务队列，或者从任务队列中删除</li>
<li>已处理的任务会被从任务队列中删除</li>
<li>线程池的使用者，也就是调用线程池函数往任务队列中添加任务的线程就是生产者线程</li>
</ul>
<p>（2）工作的线程（任务队列任务的消费者） ，N 个</p>
<ul>
<li>线程池中维护了一定数量的工作线程，他们的作用是是不停的读任务队列，从里边取出任务并处理</li>
<li>工作的线程相当于是任务队列的消费者角色，</li>
<li>如果任务队列为空，工作的线程将会被阻塞 (使用条件变量 &#x2F; 信号量阻塞)</li>
<li>如果阻塞之后有了新的任务，由生产者将阻塞解除，工作线程开始工作</li>
</ul>
<p>（3）管理者线程（不处理任务队列中的任务），1 个</p>
<ul>
<li>它的任务是周期性的对任务队列中的任务数量以及处于忙状态的工作线程个数进行检测</li>
<li>当任务过多的时候，可以适当的创建一些新的工作线程</li>
<li>当任务过少的时候，可以适当的销毁一些工作的线程</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/R9c00030b842edb1ae3d6a2b286e53916.jpg" alt="R9c00030b842edb1ae3d6a2b286e53916"></p>
<h3 id="QRunnable"><a href="#QRunnable" class="headerlink" title="QRunnable"></a>QRunnable</h3><p>在 Qt 中使用线程池需要先创建任务，添加到线程池中的每一个任务都需要是一个 QRunnable 类型，因此在程序中需要创建子类继承 QRunnable 这个类，然后重写 run() 方法，在这个函数中编写要在线程池中执行的任务，并将这个子类对象传递给线程池，这样任务就可以被线程池中的某个工作的线程处理掉了。</p>
<p>QRunnable 类 常用函数不多，主要是设置任务对象传给线程池后，是否需要自动析构。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在子类中必须要重写的函数, 里边是任务的处理流程</span></span><br><span class="line">[pure <span class="keyword">virtual</span>] <span class="function"><span class="type">void</span> <span class="title">QRunnable::run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数设置为 true: 这个任务对象在线程池中的线程中处理完毕, 这个任务对象就会自动销毁</span></span><br><span class="line"><span class="comment">// 参数设置为 false: 这个任务对象在线程池中的线程中处理完毕, 对象需要程序猿手动销毁</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QRunnable::setAutoDelete</span><span class="params">(<span class="type">bool</span> autoDelete)</span></span>;</span><br><span class="line"><span class="comment">// 获取当然任务对象的析构方式,返回true-&gt;自动析构, 返回false-&gt;手动析构</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QRunnable::autoDelete</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>

<p>创建一个要添加到线程池中的任务类，处理方式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyWork</span> : <span class="keyword">public</span> QObject, <span class="keyword">public</span> QRunnable</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyWork</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 任务执行完毕,该对象自动销毁</span></span><br><span class="line">        <span class="built_in">setAutoDelete</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MyWork</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中 MyWork 类是一个多重继承，如果需要在这个任务中使用 Qt 的信号槽机制进行数据的传递就必须继承 QObject 这个类，如果不使用信号槽传递数据就可以不继承了，只继承 QRunnable 即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyWork</span> :<span class="keyword">public</span> QRunnable</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyWork</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 任务执行完毕,该对象自动销毁</span></span><br><span class="line">        <span class="built_in">setAutoDelete</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MyWork</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="QThreadPool"><a href="#QThreadPool" class="headerlink" title="QThreadPool"></a>QThreadPool</h3><p>Qt 中的 QThreadPool 类管理了一组 QThreads, 里边还维护了一个任务队列。QThreadPool 管理和回收各个 QThread 对象，以帮助减少使用线程的程序中的线程创建成本。每个Qt应用程序都有一个全局 QThreadPool 对象，可以通过调用 globalInstance() 来访问它。也可以单独创建一个 QThreadPool 对象使用。</p>
<p>线程池常用的 API 函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取和设置线程中的最大线程个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxThreadCount</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMaxThreadCount</span><span class="params">(<span class="type">int</span> maxThreadCount)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给线程池添加任务, 任务是一个 QRunnable 类型的对象</span></span><br><span class="line"><span class="comment">// 如果线程池中没有空闲的线程了, 任务会放到任务队列中, 等待线程处理</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QThreadPool::start</span><span class="params">(QRunnable * runnable, <span class="type">int</span> priority = <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="comment">// 如果线程池中没有空闲的线程了, 直接返回值, 任务添加失败, 任务不会添加到任务队列中</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QThreadPool::tryStart</span><span class="params">(QRunnable * runnable)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池中被激活的线程的个数(正在工作的线程个数)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QThreadPool::activeThreadCount</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试性的将某一个任务从线程池的任务队列中删除, 如果任务已经开始执行就无法删除了</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QThreadPool::tryTake</span><span class="params">(QRunnable *runnable)</span></span>;</span><br><span class="line"><span class="comment">// 将线程池中的任务队列里边没有开始处理的所有任务删除, 如果已经开始处理了就无法通过该函数删除了</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QThreadPool::clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在每个Qt应用程序中都有一个全局的线程池对象, 通过这个函数直接访问这个对象</span></span><br><span class="line"><span class="function"><span class="type">static</span> QThreadPool * <span class="title">QThreadPool::globalInstance</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>一般情况下，我们不需要在 Qt 程序中创建线程池对象，直接使用 Qt 为每个应用程序提供的线程池全局对象即可。得到线程池对象之后，调用 start() 方法就可以将一个任务添加到线程池中，这个任务就可以被线程池内部的线程池处理掉了，<strong>使用线程池比自己创建线程的这种多种多线程方式更加简单和易于维护。</strong></p>
<h3 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h3><p>mywork.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyWork</span> :<span class="keyword">public</span> QRunnable</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyWork</span><span class="params">()</span></span>;</span><br><span class="line">    ~<span class="built_in">MyWork</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mywork.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MyWork::<span class="built_in">MyWork</span>() : <span class="built_in">QRunnable</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 任务执行完毕,该对象自动销毁</span></span><br><span class="line">    <span class="built_in">setAutoDelete</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyWork::run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 业务处理代码</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mainwindow.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">QMainWindow</span>(parent),</span><br><span class="line">    <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程池初始化，设置最大线程池数</span></span><br><span class="line">    QThreadPool::<span class="built_in">globalInstance</span>()-&gt;<span class="built_in">setMaxThreadCount</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="comment">// 添加任务</span></span><br><span class="line">    MyWork* task = <span class="keyword">new</span> MyWork;<span class="comment">//因为设置了自动释放，所以无需自己释放</span></span><br><span class="line">    QThreadPool::<span class="built_in">globalInstance</span>()-&gt;<span class="built_in">start</span>(task);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="接受windows原生消息处理"><a href="#接受windows原生消息处理" class="headerlink" title="接受windows原生消息处理"></a>接受windows原生消息处理</h1><p>重写nativeEvent函数</p>
<p>头文件中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">nativeEvent</span><span class="params">(<span class="type">const</span> QByteArray &amp;eventType, <span class="type">void</span> *message, <span class="type">long</span> *result)</span></span>;</span><br></pre></td></tr></table></figure>

<p>源文件中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MY_CLOSE_MSG  WM_USER+1</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Dialog::nativeEvent</span><span class="params">(<span class="type">const</span> QByteArray &amp;eventType, <span class="type">void</span> *message, <span class="type">long</span> *result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Q_UNUSED</span>(eventType);</span><br><span class="line">         MSG *msg = <span class="built_in">static_cast</span>&lt;MSG*&gt;(message);  <span class="comment">//类型转换</span></span><br><span class="line">         <span class="comment">/*此处的结构也可用switch来代替*/</span></span><br><span class="line">         <span class="keyword">if</span>(msg-&gt;message ==MY_CLOSE_MSG )<span class="comment">//自定义消息举例</span></span><br><span class="line">         &#123;</span><br><span class="line">             <span class="comment">//dosomething...</span></span><br><span class="line">            <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;收到目标消息&quot;</span>;</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//返回值为false表示该事件还会继续向上传递，被其他捕获</span></span><br><span class="line">         &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="添加图标"><a href="#添加图标" class="headerlink" title="添加图标"></a>添加图标</h1><p>如果使用qmake来生成makefile文件，只需要在.pro中添加：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RC_ICONS = logo.ico//logo.ico是图标名</span><br></pre></td></tr></table></figure>
<h1 id="QT-添加DLL"><a href="#QT-添加DLL" class="headerlink" title="QT 添加DLL"></a>QT 添加DLL</h1><p>有多种方式可以实现</p>
<p>动态链接方式实现</p>
<ol>
<li><p>创建头文件: 为winio.dll创建一个头文件,声明所有需要导入的函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> WINIO_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WINIO_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义 tagPhysStruct 结构体</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">tagPhysStruct</span></span><br><span class="line">    &#123;</span><br><span class="line">        DWORD dwPhysMemSizeInBytes;  <span class="comment">// 物理内存大小</span></span><br><span class="line">        DWORD dwPhysAddress;         <span class="comment">// 物理地址</span></span><br><span class="line">        PBYTE pvPhysMemLin;          <span class="comment">// 映射后的线性地址</span></span><br><span class="line">        HANDLE PhysicalMemoryHandle; <span class="comment">// 物理内存句柄</span></span><br><span class="line">    &#125; PHYSSTRUCT, *PPHYSSTRUCT;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 定义函数指针类型</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">BOOL</span> <span class="params">(*InitializeWinIoType)</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*ShutdownWinIoType)</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">PBYTE</span> <span class="params">(*MapPhysToLinType)</span><span class="params">(PHYSSTRUCT &amp;PhysStruct)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">BOOL</span> <span class="params">(*UnmapPhysicalMemoryType)</span><span class="params">(PHYSSTRUCT &amp;PhysStruct)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">BOOL</span> <span class="params">(*GetPhysLongType)</span><span class="params">(PBYTE pbPhysAddr, PDWORD pdwPhysVal)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">BOOL</span> <span class="params">(*SetPhysLongType)</span><span class="params">(PBYTE pbPhysAddr, DWORD dwPhysVal)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">BOOL</span> <span class="params">(*GetPortValType)</span><span class="params">(WORD wPortAddr, PDWORD pdwPortVal, BYTE bSize)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">BOOL</span> <span class="params">(*SetPortValType)</span><span class="params">(WORD wPortAddr, DWORD dwPortVal, BYTE bSize)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// WINIO_H</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改CMakeLists.txt,确保项目能够找到并链接到winio.dll</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#添加lib目录</span></span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR)/lib)</span></span><br><span class="line"><span class="variable"></span></span><br><span class="line"><span class="variable">set(</span></span><br><span class="line"><span class="variable">	PROJECT _SOURCES</span></span><br><span class="line"><span class="variable">	main.cpp</span></span><br><span class="line"><span class="variable">	mainwinodw.cpp</span></span><br><span class="line"><span class="variable">	winio.h   #加这个</span></span><br><span class="line"><span class="variable">)</span></span><br><span class="line"><span class="variable"></span></span><br><span class="line"><span class="variable"># 复制 dll 和 sys 文件</span></span><br><span class="line"><span class="variable">add_custom_command(TARGET qtTestLoop POST_BUILD</span></span><br><span class="line"><span class="variable">    COMMAND $&#123;CMAKE_COMMAND&#125;</span> -E copy_if_different</span><br><span class="line">    <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/lib/WinIo.dll&quot;</span></span><br><span class="line">    <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/lib/WinIo.sys&quot;</span></span><br><span class="line">    $&lt;TARGET_FILE_DIR:qtTestLoop&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>动态获取想要使用的函数,直接使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!hWinIo)</span><br><span class="line">    &#123;</span><br><span class="line">        hWinIo = <span class="built_in">LoadLibraryA</span>(<span class="string">&quot;WinIo.dll&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!hWinIo)</span><br><span class="line">        &#123;</span><br><span class="line">            DWORD error = <span class="built_in">GetLastError</span>();</span><br><span class="line">            QMessageBox::<span class="built_in">critical</span>(<span class="keyword">this</span>, <span class="string">&quot;错误&quot;</span>, <span class="built_in">QString</span>(<span class="string">&quot;无法加载 WinIo.dll，错误代码: %1&quot;</span>).<span class="built_in">arg</span>(error));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取函数地址</span></span><br><span class="line">        InitializeWinIo = (InitializeWinIoType)<span class="built_in">GetProcAddress</span>(hWinIo, <span class="string">&quot;InitializeWinIo&quot;</span>);</span><br><span class="line">        ShutdownWinIo = (ShutdownWinIoType)<span class="built_in">GetProcAddress</span>(hWinIo, <span class="string">&quot;ShutdownWinIo&quot;</span>);</span><br><span class="line">        MapPhysToLin = (MapPhysToLinType)<span class="built_in">GetProcAddress</span>(hWinIo, <span class="string">&quot;MapPhysToLin&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!InitializeWinIo || !ShutdownWinIo || !MapPhysToLin)</span><br><span class="line">        &#123;</span><br><span class="line">            DWORD error = <span class="built_in">GetLastError</span>();</span><br><span class="line">            QMessageBox::<span class="built_in">critical</span>(<span class="keyword">this</span>, <span class="string">&quot;错误&quot;</span>, <span class="built_in">QString</span>(<span class="string">&quot;无法获取函数地址，错误代码: %1&quot;</span>).<span class="built_in">arg</span>(error));</span><br><span class="line">            <span class="built_in">FreeLibrary</span>(hWinIo);</span><br><span class="line">            hWinIo = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li></li>
</ol>
<h1 id="QT以管理员启动"><a href="#QT以管理员启动" class="headerlink" title="QT以管理员启动"></a>QT以管理员启动</h1><ol>
<li><p>修改CMakeLists.txt,添加清单文件的配置:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 PROJECT_SOURCES 中添加清单文件</span></span><br><span class="line"><span class="keyword">set</span>(PROJECT_SOURCES</span><br><span class="line">    main.cpp</span><br><span class="line">    mainwindow.cpp</span><br><span class="line">    mainwindow.h</span><br><span class="line">    mainwindow.ui</span><br><span class="line">    app.manifest  <span class="comment">#添加清单文件</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(qtTestLoop</span><br><span class="line">    <span class="variable">$&#123;PROJECT_SOURCES&#125;</span></span><br><span class="line">    lib/WinIo.dll lib/WinIo.sys lib/WINIO.VXD</span><br><span class="line">    app.manifest  <span class="comment">#清单文件</span></span><br><span class="line">    app.rc   <span class="comment">#添加app.rc</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建清单文件 app.manifest(用于声明应用程序的各种属性和要求):</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> standalone=<span class="string">&quot;yes&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">assembly</span> <span class="attr">xmlns</span>=<span class="string">&quot;urn:schemas-microsoft-com:asm.v1&quot;</span> <span class="attr">manifestVersion</span>=<span class="string">&quot;1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">assemblyIdentity</span> <span class="attr">version</span>=<span class="string">&quot;1.0.0.0&quot;</span> <span class="attr">processorArchitecture</span>=<span class="string">&quot;X86&quot;</span> <span class="attr">name</span>=<span class="string">&quot;qtTestLoop&quot;</span> <span class="attr">type</span>=<span class="string">&quot;win32&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">trustInfo</span> <span class="attr">xmlns</span>=<span class="string">&quot;urn:schemas-microsoft-com:asm.v3&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">security</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">requestedPrivileges</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 这里指定程序需要管理员权限 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">requestedExecutionLevel</span> <span class="attr">level</span>=<span class="string">&quot;requireAdministrator&quot;</span> <span class="attr">uiAccess</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">requestedPrivileges</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">security</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">trustInfo</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">assembly</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>添加app.rc(用于将 manifest 文件嵌入到可执行文件中)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;windows.h&gt;</span><br><span class="line"></span><br><span class="line">1 RT_MANIFEST &quot;app.manifest&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改CMakeLists.txt,添加资源编译命令</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(WIN32)</span><br><span class="line">    <span class="built_in">enable_language</span>(RC)</span><br><span class="line">    <span class="built_in">set</span>(CMAKE_RC_COMPILER_INIT windres)</span><br><span class="line">    <span class="built_in">set</span>(CMAKE_RC_COMPILE_OBJECT <span class="string">&quot;&lt;CMAKE_RC_COMPILER&gt; &lt;FLAGS&gt; -O coff &lt;DEFINES&gt; -i &lt;SOURCE&gt; -o &lt;OBJECT&gt;&quot;</span>)</span><br><span class="line"><span class="built_in">endif</span>()</span><br></pre></td></tr></table></figure>
</li>
<li></li>
</ol>
<h1 id="QT编码"><a href="#QT编码" class="headerlink" title="QT编码"></a>QT编码</h1><h2 id="QT-json"><a href="#QT-json" class="headerlink" title="QT json"></a>QT json</h2><p>用到的头文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QJsonDocument&gt;</span></span></span><br><span class="line"><span class="comment">//磁盘上有json格式的文件 -&gt; 读到内存(字符串) </span></span><br><span class="line"><span class="comment">//json数组/json对象 -&gt; json文档对象 -&gt;写入磁盘(写入的字符串)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QJsonArray&gt;</span><span class="comment">//解析json数组</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QJsonObject&gt;</span><span class="comment">//解析json对象</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QByteArray&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QJsonValue&gt;</span><span class="comment">//将json支持的数据类型进行了封装, 得到一个QJsonValue</span></span></span><br></pre></td></tr></table></figure>

<p>完整案例:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLocale&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTranslator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QJsonDocument&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QJsonArray&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QJsonObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QByteArray&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QJsonValue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QFile&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写QJsonObject到文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writeJson2File</span><span class="params">(QJsonObject json,QString filePath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//将QJsonObject转换为QJsonDocument</span></span><br><span class="line">    <span class="function">QJsonDocument <span class="title">doc</span><span class="params">(json)</span></span>;</span><br><span class="line">    <span class="comment">//讲QJsonDocument对象转换为QByteArray对象</span></span><br><span class="line">    QByteArray byteArray = doc.<span class="built_in">toJson</span>();</span><br><span class="line">    <span class="comment">//文件操作--将byteArray写入文件</span></span><br><span class="line">    <span class="function">QFile <span class="title">file</span><span class="params">(filePath)</span></span>;</span><br><span class="line">    file.<span class="built_in">open</span>(QFile::WriteOnly);</span><br><span class="line">    file.<span class="built_in">write</span>(byteArray);</span><br><span class="line">    file.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读文件到QJsonDocument</span></span><br><span class="line"><span class="function">QJsonDocument <span class="title">readFile2Json</span><span class="params">(QString filePath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//读取json文件到解析json格式</span></span><br><span class="line">    QFile file;</span><br><span class="line">    file.<span class="built_in">setFileName</span>(filePath);</span><br><span class="line">    file.<span class="built_in">open</span>(QFile::ReadOnly);</span><br><span class="line">    QByteArray byteArrayR = file.<span class="built_in">readAll</span>();</span><br><span class="line">    <span class="comment">//将QByteArray转换为QJsonDocument</span></span><br><span class="line">    QJsonDocument jsonDoc = QJsonDocument::<span class="built_in">fromJson</span>(byteArrayR);</span><br><span class="line">    <span class="keyword">return</span> jsonDoc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归解析打印QJsonValue</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showJsonValue</span><span class="params">(QString key,QJsonValue value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(value.<span class="built_in">isArray</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        QJsonArray array = value.<span class="built_in">toArray</span>();</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;key&lt;&lt;<span class="string">&quot;:[&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;array.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i].<span class="built_in">isBool</span>())</span><br><span class="line">                <span class="built_in">qDebug</span>()&lt;&lt;array[i].<span class="built_in">toBool</span>();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(array[i].<span class="built_in">isDouble</span>())</span><br><span class="line">                <span class="built_in">qDebug</span>()&lt;&lt;array[i].<span class="built_in">toDouble</span>();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(array[i].<span class="built_in">isString</span>())</span><br><span class="line">                <span class="built_in">qDebug</span>()&lt;&lt;array[i].<span class="built_in">toString</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(value.<span class="built_in">isBool</span>())</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;key&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;value.<span class="built_in">toBool</span>();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(value.<span class="built_in">isDouble</span>())</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;key&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;value.<span class="built_in">toDouble</span>();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(value.<span class="built_in">isString</span>())</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;key&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;value.<span class="built_in">toString</span>();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(value.<span class="built_in">isObject</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        QJsonObject obj = value.<span class="built_in">toObject</span>();</span><br><span class="line">        QStringList keyLists = obj.<span class="built_in">keys</span>();</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;key&lt;&lt;<span class="string">&quot;:&#123;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;keyLists.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">showJsonValue</span>(keyLists[i],obj[keyLists[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印QJsonDocument</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showJsonDocuemnt</span><span class="params">(QJsonDocument jsonDoc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(jsonDoc.<span class="built_in">isObject</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将QJsonDocument对象转换为json对象</span></span><br><span class="line">        QJsonObject obj = jsonDoc.<span class="built_in">object</span>();</span><br><span class="line">        QStringList keyLists = obj.<span class="built_in">keys</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;keyLists.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            QJsonValue value = obj[keyLists[i]];</span><br><span class="line">            <span class="built_in">showJsonValue</span>(keyLists[i],value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(jsonDoc.<span class="built_in">isArray</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        QJsonArray array = jsonDoc.<span class="built_in">array</span>();</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;[&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;array.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">qDebug</span>()&lt;&lt;array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;]&quot;</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QTranslator translator;</span><br><span class="line">    <span class="type">const</span> QStringList uiLanguages = QLocale::<span class="built_in">system</span>().<span class="built_in">uiLanguages</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> QString &amp;locale : uiLanguages) &#123;</span><br><span class="line">        <span class="type">const</span> QString baseName = <span class="string">&quot;test_&quot;</span> + <span class="built_in">QLocale</span>(locale).<span class="built_in">name</span>();</span><br><span class="line">        <span class="keyword">if</span> (translator.<span class="built_in">load</span>(<span class="string">&quot;:/i18n/&quot;</span> + baseName)) &#123;</span><br><span class="line">            a.<span class="built_in">installTranslator</span>(&amp;translator);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个json对象</span></span><br><span class="line">    QJsonObject json;</span><br><span class="line">    json.<span class="built_in">insert</span>(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;xiaowu&quot;</span>);</span><br><span class="line">    json.<span class="built_in">insert</span>(<span class="string">&quot;age&quot;</span>,<span class="number">21</span>);</span><br><span class="line">    json.<span class="built_in">insert</span>(<span class="string">&quot;sex&quot;</span>,<span class="string">&quot;male&quot;</span>);</span><br><span class="line">    <span class="comment">//子子对象</span></span><br><span class="line">    QJsonObject subSubJson;</span><br><span class="line">    subSubJson.<span class="built_in">insert</span>(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    <span class="comment">//插入子对象</span></span><br><span class="line">    QJsonObject subJson;</span><br><span class="line">    subJson.<span class="built_in">insert</span>(<span class="string">&quot;father&quot;</span>,<span class="string">&quot;longji&quot;</span>);</span><br><span class="line">    subJson.<span class="built_in">insert</span>(<span class="string">&quot;sister&quot;</span>,<span class="string">&quot;wangjin&quot;</span>);</span><br><span class="line">    subJson.<span class="built_in">insert</span>(<span class="string">&quot;mather&quot;</span>,<span class="string">&quot;liwei&quot;</span>);</span><br><span class="line">    subJson.<span class="built_in">insert</span>(<span class="string">&quot;begin&quot;</span>,subSubJson);</span><br><span class="line">    json.<span class="built_in">insert</span>(<span class="string">&quot;family&quot;</span>,subJson);</span><br><span class="line">    <span class="comment">//插入数组</span></span><br><span class="line">    QJsonArray jsonArray;</span><br><span class="line">    jsonArray.<span class="built_in">append</span>(<span class="number">10</span>);</span><br><span class="line">    jsonArray.<span class="built_in">append</span>(<span class="string">&quot;chengdu&quot;</span>);</span><br><span class="line">    jsonArray.<span class="built_in">append</span>(<span class="number">10.7</span>);</span><br><span class="line">    jsonArray.<span class="built_in">append</span>(<span class="literal">true</span>);</span><br><span class="line">    json.<span class="built_in">insert</span>(<span class="string">&quot;like&quot;</span>,jsonArray);</span><br><span class="line">    <span class="comment">//写入磁盘</span></span><br><span class="line">    <span class="built_in">writeJson2File</span>(json,<span class="string">&quot;test.json&quot;</span>);</span><br><span class="line">    <span class="comment">//读取磁盘json文件</span></span><br><span class="line">    QJsonDocument jsonDoc = <span class="built_in">readFile2Json</span>(<span class="string">&quot;test.json&quot;</span>);</span><br><span class="line">    <span class="comment">//打印jsonDoc对象</span></span><br><span class="line">    <span class="built_in">showJsonDocuemnt</span>(jsonDoc);</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="QT的base64编码"><a href="#QT的base64编码" class="headerlink" title="QT的base64编码"></a>QT的base64编码</h2><p>[[加解密相关#base64编码|何为base64编码]]</p>
<p>使用 QByteArray 类</p>
<ul>
<li><strong>编码</strong><br> <code>QByteArray QByteArray::toBase64() const</code></li>
<li><strong>解码</strong><br> <code> QByteArray QByteArray::fromBase64(const QByteArray &amp;base64);</code>   <ul>
<li><code>base64</code>: 要解码的字符串</li>
</ul>
</li>
</ul>
<h1 id="QT中的类型转换"><a href="#QT中的类型转换" class="headerlink" title="QT中的类型转换"></a>QT中的类型转换</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//QString -&gt; QByteArray</span></span><br><span class="line"><span class="function">QByteArray <span class="title">QString::toLatin1</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">//西欧编码 iso-8859-1,不支持中文</span></span><br><span class="line"><span class="function">QByteArray <span class="title">QString::toLocal8Bit</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">//编码格式跟随操作系统</span></span><br><span class="line"><span class="function">QByteArray <span class="title">QString::toUtf8</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">//utf8编码</span></span><br><span class="line"><span class="comment">//QByteArray-&gt;QString</span></span><br><span class="line">QString::<span class="built_in">QString</span>(<span class="type">const</span> QByteArray &amp;ba);</span><br><span class="line"><span class="comment">//char*-&gt;QByteArray</span></span><br><span class="line">QByteArray::<span class="built_in">QByteArray</span>(<span class="type">const</span> <span class="type">char</span>* data,<span class="type">int</span> size=<span class="number">-1</span>);</span><br><span class="line"><span class="comment">//QByteArray -&gt; char*</span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">QByteArray::data</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//QString-&gt; char*</span></span></span><br><span class="line"><span class="function">不能直接转</span></span><br><span class="line"><span class="function">通过QString-&gt;QByteArray-&gt;<span class="type">char</span>* </span></span><br></pre></td></tr></table></figure>

<h1 id="QT中的编码转换"><a href="#QT中的编码转换" class="headerlink" title="QT中的编码转换"></a>QT中的编码转换</h1><h2 id="gbk转utf8"><a href="#gbk转utf8" class="headerlink" title="gbk转utf8"></a>gbk转utf8</h2><p>转换 Windows 平台运行时的 gbk 编码的中文字符串为 utf-8 格式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string sgbk;</span><br><span class="line">std::string sutf8 = QString::<span class="built_in">fromLocal8Bit</span>(sgbk.<span class="built_in">data</span>()).<span class="built_in">toUtf8</span>().<span class="built_in">data</span>());</span><br></pre></td></tr></table></figure>

<p>转换 Linux 平台运行时的 gbk 编码的中文字符串为 utf-8 格式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如下将gbk格式的QByteArray类型对象array转换为unicode编码格式</span></span><br><span class="line">QTextCodec* codec=TextCodec::<span class="built_in">codecForName</span>(<span class="string">&quot;gbk&quot;</span>);</span><br><span class="line">codec-&gt;<span class="built_in">toUnicode</span>(array);</span><br></pre></td></tr></table></figure>

<h1 id="QT数据库开发"><a href="#QT数据库开发" class="headerlink" title="QT数据库开发"></a>QT数据库开发</h1><h2 id="oracle数据库"><a href="#oracle数据库" class="headerlink" title="oracle数据库"></a>oracle数据库</h2><p>[[数据库#oracle|oracle数据笔记跳转]]</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202304201149758.png" alt="image-20230420114847356"></p>
<p>使用QtCreator打开<code>QT根目录\Qt5.9.0\5.9\Src\qtbase\src\plugins\sqldrivers\oci\</code>目录下面的oci.pro</p>
<p>修改oci.pro文件:</p>
<figure class="highlight qt"><figcaption><span>pro</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">TARGET = qsqloci</span><br><span class="line"></span><br><span class="line">HEADERS += $$PWD/qsql_oci_p.h</span><br><span class="line">SOURCES += $$PWD/qsql_oci.cpp $$PWD/main.cpp</span><br><span class="line"></span><br><span class="line">#QMAKE_USE += oci</span><br><span class="line">QMAKE_LFLAGS += <span class="attribute">G</span>:\\oracleInstall\\bin\\oci.dll</span><br><span class="line">INCLUDEPATH += <span class="attribute">G</span>:\\oracleInstall\\oci\\include</span><br><span class="line">LIBPATH += <span class="attribute">G</span>:\\oracleInstall\\oci\\lib\\msvc</span><br><span class="line"></span><br><span class="line"><span class="attribute">darwin</span>:<span class="attribute">QMAKE_LFLAGS += -Wl,-flat_namespace,-U,_environ</span></span><br><span class="line"><span class="attribute"></span></span><br><span class="line"><span class="attribute">OTHER_FILES += oci.json</span></span><br><span class="line"><span class="attribute"></span></span><br><span class="line"><span class="attribute">PLUGIN_CLASS_NAME = QOCIDriverPlugin</span></span><br><span class="line"><span class="attribute">include(../qsqldriverbase.pri)</span></span><br></pre></td></tr></table></figure>

<p>之后再重新编译，就会发现编译通过了，这时候我们在Qt安装的根目录下面去找 “:\plugins”会发现里面有一个“ sqldrivers ”文件夹，将其复制到Qt的<code>c:\Qt\Qt5.9.0\5.9\mingw53_32\plugins</code>下<br>面即可</p>
<h2 id="mysql开发"><a href="#mysql开发" class="headerlink" title="mysql开发"></a>mysql开发</h2><p>将<code>libmysql.dll</code>库放到下面的目录下**<code>Qt5.12.0(QT根目录)\5.12.0\mingw73_64\bin</code>**</p>
<p>头文件: <strong><code>#include &lt;QtSql&gt;</code></strong></p>
<p>qmake:<code>QT+=sql</code></p>
<p><strong>用到的头文件</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;qDebug&gt;</span></span></span><br><span class="line"><span class="comment">//QtSql头文件包含下面头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSqlDatabase&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSqlQuery&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSqlRecord&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSqlError&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="加载数据库驱动"><a href="#加载数据库驱动" class="headerlink" title="加载数据库驱动"></a>加载数据库驱动</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"><span class="comment">//查看QT支持的驱动</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; QSqlDatabase::<span class="built_in">drivers</span>();</span><br><span class="line"><span class="comment">//输出结果为:</span></span><br><span class="line"><span class="comment">//(&quot;QSQLITE&quot;, &quot;QMYSQL&quot;, &quot;QMYSQL3&quot;, &quot;QOCI&quot;, &quot;QOCI8&quot;, &quot;QODBC&quot;, &quot;QODBC3&quot;, &quot;QPSQL&quot;, &quot;QPSQL7&quot;)</span></span><br><span class="line"><span class="comment">//加载数据库驱动</span></span><br><span class="line">QSqlDatabase db = QSqlDatabase::<span class="built_in">addDatabase</span>(<span class="string">&quot;QMYSQL&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="设置账号密码"><a href="#设置账号密码" class="headerlink" title="设置账号密码"></a>设置账号密码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置账号和密码信息使用QSqlDatabase类的成员函数:</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setHostName</span><span class="params">(<span class="type">const</span> QString &amp;host)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setPassword</span><span class="params">(<span class="type">const</span> QString &amp;password)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setPort</span><span class="params">(<span class="type">int</span> port)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setUserName</span><span class="params">(<span class="type">const</span> QString &amp;name)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setDatabaseName</span><span class="params">(<span class="type">const</span> QString &amp;name)</span></span></span><br><span class="line"><span class="function"><span class="comment">//使用方法, 如下所示</span></span></span><br><span class="line"><span class="function">db.<span class="title">setHostName</span><span class="params">(<span class="string">&quot;192.168.10.145&quot;</span>)</span></span>; <span class="comment">//设置mysql主机的IP地址</span></span><br><span class="line">db.<span class="built_in">setDatabaseName</span>(<span class="string">&quot;scott&quot;</span>); <span class="comment">//设置数据库名</span></span><br><span class="line">db.<span class="built_in">setUserName</span>(<span class="string">&quot;root&quot;</span>); <span class="comment">//设置用户名</span></span><br><span class="line">db.<span class="built_in">setPassword</span>(<span class="string">&quot;123456&quot;</span>); <span class="comment">//设置密码</span></span><br><span class="line"><span class="comment">//其实上面这几步就类似于登录mysql数据库需要的关键信息:</span></span><br><span class="line">mysql -h<span class="number">192.168</span><span class="number">.10</span><span class="number">.145</span> -uroot -p123456 scott</span><br></pre></td></tr></table></figure>

<h3 id="打开数据库"><a href="#打开数据库" class="headerlink" title="打开数据库"></a>打开数据库</h3><p>函数原型<br><code>bool QSqlDatabase::open();</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//详情查看QT帮助手册</span></span><br><span class="line"><span class="comment">//使用方法, 如下所示:</span></span><br><span class="line"><span class="keyword">if</span>(!db.<span class="built_in">open</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;数据库操作失败&quot;</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关闭数据库"><a href="#关闭数据库" class="headerlink" title="关闭数据库"></a>关闭数据库</h3><p><code>db.close();</code></p>
<h3 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h3><p>数据库操作错误打印</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QSqlError lastError = query.<span class="built_in">lastError</span>();</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; lastError.<span class="built_in">driverText</span>() &lt;&lt; lastError.<span class="built_in">databaseText</span>();</span><br></pre></td></tr></table></figure>

<h4 id="执行select查询操作"><a href="#执行select查询操作" class="headerlink" title="执行select查询操作"></a>执行select查询操作</h4><p>QSqlQuery类的构造函数:<br><code>QSqlQuery(const QString &amp;query = QString(), QSqlDatabase db = QSqlDatabase())</code></p>
<p>该构造函数都有默认值, 构造的时候可以不指定</p>
<h5 id="执行语句"><a href="#执行语句" class="headerlink" title="执行语句"></a>执行语句</h5><p>两种方法</p>
<ol>
<li><pre><code class="cpp">QSqlQuery query;
query.exec(&quot;select * from dept&quot;);
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. ```cpp</span><br><span class="line">   QSqlQuery query;</span><br><span class="line">   bool success;</span><br><span class="line">   query.prepare(&quot;select * from dept&quot;);</span><br><span class="line">   success = query.exec();</span><br><span class="line">   if(!success)</span><br><span class="line">   &#123;</span><br><span class="line">   qDebug() &lt;&lt; &quot;查询失败&quot;;</span><br><span class="line">   return;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<h5 id="结果集记录数和字段数"><a href="#结果集记录数和字段数" class="headerlink" title="结果集记录数和字段数"></a>结果集记录数和字段数</h5><h6 id="查询字段数"><a href="#查询字段数" class="headerlink" title="查询字段数"></a>查询字段数</h6><p>字段数就是查询列数</p>
<p>record方法</p>
<p>先调用QSqlQuery类的record方法:<br><code>QSqlRecord record() const;</code><br>然后在调用QSqlRecord类的count方法<br><code>int QSqlRecord::count() const</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QSqlRecord rec = query.<span class="built_in">record</span>();</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;查询结果字段总数为：&quot;</span> &lt;&lt; rec.<span class="built_in">count</span>();</span><br></pre></td></tr></table></figure>

<h6 id="查询记录数"><a href="#查询记录数" class="headerlink" title="查询记录数"></a>查询记录数</h6><p>记录数就是查询行数</p>
<p>size方法</p>
<p>调用QSqlQuery类的size方法:<br><code>int size() const</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;查询结果记录总数为&quot;</span> &lt;&lt; query.<span class="built_in">size</span>()</span><br></pre></td></tr></table></figure>

<h5 id="遍历结果集"><a href="#遍历结果集" class="headerlink" title="遍历结果集"></a>遍历结果集</h5><p>获取每一条记录<br><code>bool QSqlQuery::next()</code><br>通过列的索引位置获取列的值—列的索引从0开始<br><code>QVariant QSqlQuery::value(int index) const</code><br>通过列名获取列的值<br><code>QVariant value(const QString &amp;name) const</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(query.<span class="built_in">next</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//qDebug() &lt;&lt; query.value(0).toInt() &lt;&lt; query.value(1).toString() &lt;&lt; query.value(2).toString();</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; query.<span class="built_in">value</span>(<span class="string">&quot;deptno&quot;</span>).<span class="built_in">toInt</span>() &lt;&lt; query.<span class="built_in">value</span>(<span class="string">&quot;dname&quot;</span>).<span class="built_in">toString</span>() &lt;&lt;</span><br><span class="line">query.<span class="built_in">value</span>(<span class="string">&quot;loc&quot;</span>).<span class="built_in">toString</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>移动指向结果集的位置指针:</p>
<p><code>bool QSqlQuery::seek(int index, bool relative = false)</code></p>
<p>index为编号,如<code>query.seek(-1);</code> 移动到结果集的开始位置</p>
<p>每次next都会使记录指针移动一次, 可以使用seek函数重置指针位置,类似于文件指针</p>
<h4 id="执行insert操作"><a href="#执行insert操作" class="headerlink" title="执行insert操作"></a>执行insert操作</h4><h5 id="直接插入"><a href="#直接插入" class="headerlink" title="直接插入"></a>直接插入</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">query.<span class="built_in">prepare</span>(<span class="string">&quot;insert into dept values(77, &#x27;sports&#x27;, &#x27;xiuzheng&#x27;)&quot;</span>);</span><br><span class="line">success = query.<span class="built_in">exec</span>();</span><br><span class="line"><span class="keyword">if</span>(!success)</span><br><span class="line">&#123;</span><br><span class="line">QSqlError lastError = query.<span class="built_in">lastError</span>();</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;插入失败：&quot;</span> &lt;&lt; lastError.<span class="built_in">driverText</span>() &lt;&lt; lastError.<span class="built_in">databaseText</span>();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接调用exec并将sql语句作为参数也可以直接插入</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">success = query.<span class="built_in">exec</span>(<span class="string">&quot;insert into dept values(66, &#x27;SALES&#x27;, &#x27;SHANGHAI&#x27;)&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!success)</span><br><span class="line">&#123;</span><br><span class="line">QSqlError lastError = query.<span class="built_in">lastError</span>();</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;插入失败：&quot;</span> &lt;&lt; lastError.<span class="built_in">driverText</span>() &lt;&lt; lastError.<span class="built_in">databaseText</span>();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="占位符插入"><a href="#占位符插入" class="headerlink" title="占位符插入"></a>占位符插入</h5><p>使用带有占位符的sql语句, 该语句不是一个完整的sql语句,需要调用bindValue函数给占位符设置值.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">query.<span class="built_in">prepare</span>(<span class="string">&quot;insert into dept values(?, ?, ?)&quot;</span>);</span><br><span class="line"><span class="comment">//给字段设置值,字段位置索引从0开始</span></span><br><span class="line">query.<span class="built_in">bindValue</span>(<span class="number">0</span>, <span class="number">99</span>);</span><br><span class="line">query.<span class="built_in">bindValue</span>(<span class="number">1</span>, <span class="string">&quot;SPORTS&quot;</span>);</span><br><span class="line">query.<span class="built_in">bindValue</span>(<span class="number">2</span>, <span class="string">&quot;BEIJING&quot;</span>);</span><br><span class="line">success = query.<span class="built_in">exec</span>();</span><br><span class="line"><span class="keyword">if</span>(!success)</span><br><span class="line">&#123;</span><br><span class="line">QSqlError lastError = query.<span class="built_in">lastError</span>();</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;插入失败：&quot;</span> &lt;&lt; lastError.<span class="built_in">driverText</span>() &lt;&lt; lastError.<span class="built_in">databaseText</span>();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意占位符操作,如果bindValue函数第二个传参传单引号,不会报错,但插入的内容会变成一串数字.</p>
<h4 id="执行update操作"><a href="#执行update操作" class="headerlink" title="执行update操作"></a>执行update操作</h4><h5 id="直接update"><a href="#直接update" class="headerlink" title="直接update"></a>直接update</h5><p>直接调用execl并将sql语句作为参数执行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">success = query.<span class="built_in">exec</span>(<span class="string">&quot;update dept set loc=&#x27;MEIGUO&#x27; where deptno=99&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!success)</span><br><span class="line">&#123;</span><br><span class="line">QSqlError lastError = query.<span class="built_in">lastError</span>();</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;update failed&quot;</span> &lt;&lt; lastError.<span class="built_in">driverText</span>() &lt;&lt; lastError.<span class="built_in">databaseText</span>();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="占位符update"><a href="#占位符update" class="headerlink" title="占位符update"></a>占位符update</h5><p>使用带有占位符占位符的sql语句</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">query.<span class="built_in">prepare</span>(<span class="string">&quot;update dept set loc=? where deptno=?&quot;</span>);</span><br><span class="line">query.<span class="built_in">bindValue</span>(<span class="number">0</span>, <span class="string">&quot;JAPAN&quot;</span>);</span><br><span class="line">query.<span class="built_in">bindValue</span>(<span class="number">1</span>, <span class="number">77</span>);</span><br><span class="line">success = query.<span class="built_in">exec</span>();</span><br><span class="line"><span class="keyword">if</span>(!success)</span><br><span class="line">&#123;</span><br><span class="line">QSqlError lastError = query.<span class="built_in">lastError</span>();</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;update failed&quot;</span> &lt;&lt; lastError.<span class="built_in">driverText</span>() &lt;&lt; lastError.<span class="built_in">databaseText</span>();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="执行delete操作"><a href="#执行delete操作" class="headerlink" title="执行delete操作"></a>执行delete操作</h4><h5 id="直接delete"><a href="#直接delete" class="headerlink" title="直接delete"></a>直接delete</h5><p>直接调用execl并将sql语句作为参数执行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query.<span class="built_in">exec</span>(<span class="string">&quot;delete from dept where deptno=99&quot;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="占位符delete"><a href="#占位符delete" class="headerlink" title="占位符delete"></a>占位符delete</h5><p>使用带有占位符的sql语句</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">query.<span class="built_in">prepare</span>(<span class="string">&quot;delete from dept where deptno=? or loc=?&quot;</span>);</span><br><span class="line">query.<span class="built_in">bindValue</span>(<span class="number">0</span>, <span class="number">77</span>);</span><br><span class="line">query.<span class="built_in">bindValue</span>(<span class="number">1</span>, <span class="string">&quot;SHANGHAI&quot;</span>);</span><br><span class="line">success = query.<span class="built_in">exec</span>();</span><br><span class="line"><span class="keyword">if</span>(!success)</span><br><span class="line">&#123;</span><br><span class="line">QSqlError lastError = query.<span class="built_in">lastError</span>();</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;update failed&quot;</span> &lt;&lt; lastError.<span class="built_in">driverText</span>() &lt;&lt; lastError.<span class="built_in">databaseText</span>();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h3><ul>
<li><p>开启事务</p>
<p><code>query.exec(&quot;START TRANSACTION&quot;);</code></p>
</li>
<li><p>设置自动提交和手动提交—-&gt;默认情况下mysql是自动提交的</p>
<p><code>query.exec(&quot;SET AUTOCOMMIT=0&quot;);</code> 手动提交</p>
<p><code>query.exec(&quot;SET AUTOCOMMIT=1&quot;);</code> 自动提交</p>
</li>
<li><p>事务的提交和回滚操作</p>
<p><code>query.exec(&quot;COMMIT&quot;);</code>   提交<br><code>query.exec(&quot;ROLLBACK&quot;);</code>  回滚</p>
</li>
</ul>
<p><strong>测试案例</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试方法: 先开启一个新的事务, 并设置为手动提交, 然后插入数据, 最后回滚, 看数据是否已经插入到数据库中;然后在修改为提交, 查看数据是否已经插入到数据库中.</span></span><br><span class="line">query.<span class="built_in">exec</span>(<span class="string">&quot;START TRANSACTION&quot;</span>);</span><br><span class="line">query.<span class="built_in">exec</span>(<span class="string">&quot;SET AUTOCOMMIT=0&quot;</span>); <span class="comment">//手动提交</span></span><br><span class="line">success = query.<span class="built_in">exec</span>(<span class="string">&quot;insert into dept values(99, &#x27;SALES&#x27;, &#x27;SHANGHAI&#x27;)&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!success)</span><br><span class="line">&#123;</span><br><span class="line">QSqlError lastError = query.<span class="built_in">lastError</span>();</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;update failed&quot;</span> &lt;&lt; lastError.<span class="built_in">driverText</span>() &lt;&lt; lastError.<span class="built_in">databaseText</span>();</span><br><span class="line"><span class="comment">//回滚事务</span></span><br><span class="line">query.<span class="built_in">exec</span>(<span class="string">&quot;ROLLBACK&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//提交事务</span></span><br><span class="line">query.<span class="built_in">exec</span>(<span class="string">&quot;COMMIT&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="sqlite开发"><a href="#sqlite开发" class="headerlink" title="sqlite开发"></a>sqlite开发</h2><p>SQLite（sql）是一款开源轻量级的数据库软件，不需要server(不支持远程连接)，可以集成在其他软件中，非常适合嵌入式系统的小型数据库。<br>Qt5以上版本可以直接使用SQLite（Qt自带驱动）。</p>
<p>qt中开发环境仅需要</p>
<ul>
<li>头文件就可以直接进行开发<code>&lt;QtSql&gt;</code>.</li>
<li>pro文件中添加<code>QT += sql</code></li>
</ul>
<p><code>navicat</code>可以很轻易创建出sqllite数据库,每个sqllite数据库以一个文件方式存在电脑上,连接该数据库时使用<code>db.setDatabaseName()</code>指定文件路径连接文件对应的数据库</p>
<p><strong>查询案例</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">QSqlDatabase db ;</span><br><span class="line">        <span class="keyword">if</span>(QSqlDatabase::<span class="built_in">contains</span>(<span class="string">&quot;qt_sql_default_connection&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            db = QSqlDatabase::<span class="built_in">database</span>(<span class="string">&quot;qt_sql_default_connection&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            db = QSqlDatabase::<span class="built_in">addDatabase</span>(<span class="string">&quot;QSQLITE&quot;</span>);</span><br><span class="line">            db.<span class="built_in">setDatabaseName</span>(<span class="string">&quot;/Users/zeroko/Documents/mysqllite&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!db.<span class="built_in">open</span>())</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;数据库操作失败&quot;</span>;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;数据库连接成功&quot;</span>;</span><br><span class="line">        QSqlQuery sqlquery;</span><br><span class="line">        <span class="type">bool</span> isSuccess =sqlquery.<span class="built_in">exec</span>(<span class="string">&quot;select * from student&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!isSuccess)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">qDebug</span>()&lt;&lt;sqlquery.<span class="built_in">lastError</span>();</span><br><span class="line">            db.<span class="built_in">close</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(sqlquery.<span class="built_in">next</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> id = sqlquery.<span class="built_in">value</span>(<span class="number">1</span>).<span class="built_in">toInt</span>();</span><br><span class="line">            QString name = sqlquery.<span class="built_in">value</span>(<span class="number">0</span>).<span class="built_in">toString</span>();</span><br><span class="line">            <span class="built_in">qDebug</span>()&lt;&lt;<span class="built_in">QString</span>(<span class="string">&quot;id:%1 name:%2&quot;</span>).<span class="built_in">arg</span>(id).<span class="built_in">arg</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        db.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure>

<p>更多相关代码可参考<a target="_blank" rel="noopener" href="https://www.cnblogs.com/xia-weiwen/archive/2017/05/04/6806709.html">此处</a></p>
<h1 id="QT中的http"><a href="#QT中的http" class="headerlink" title="QT中的http"></a>QT中的http</h1><p>涉及到三个主要的类</p>
<ul>
<li><a href="#QNetworkAccessManager"><strong><code>QNetworkAccessManager</code></strong></a></li>
<li><a href="#QNetworkRequest"><strong><code>QNetworkRequest</code></strong></a></li>
<li><a href="#QNetworkReply"><strong><code>QNetworkReply</code></strong></a></li>
</ul>
<blockquote>
<ul>
<li><p>**<code>QNetworkAccessManager</code>**类允许应用程序发送网络请求和接受网络应答</p>
<p>Network Access API都是围绕着一个QNetworkAccessManager对象构造的,这个对象包含着发送请求的一些通用配置和设置.它包含着代理和缓存的配置,以及和这些事物相关的一些信号,并且应答信号可以作为我们检测一个网络操作的进度.</p>
<p>一个QNetworkAccessManager对于一整个Qt应用程序来说已经足够了</p>
</li>
<li><p>**<code>QNetworkRequest</code>**类是Network Access API的一部分,这个类包含着在网络上发送请求的必要信息.</p>
</li>
<li><p>一旦一个QNetworkAccessManager对象被创建了,那么应用程序就可以使用它在网络上发送请求.它提供了一组标准的函数,可以承载网络请求和一些可选的数据,并且每一个请求返回一个**<code>QNetworkReply</code>**对象.该返回的对象包含着返回的请求应带的所有数据.</p>
</li>
</ul>
</blockquote>
<h2 id="Qt中http的使用"><a href="#Qt中http的使用" class="headerlink" title="Qt中http的使用"></a>Qt中http的使用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QT += network</span><br></pre></td></tr></table></figure>

<h3 id="QNetworkAccessManager"><a href="#QNetworkAccessManager" class="headerlink" title="QNetworkAccessManager"></a>QNetworkAccessManager</h3><p><code>#include &lt;QNetworkAccessManager&gt;</code></p>
<p>使用这个类进行请求的发送:get&#x2F;post</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --- get ---</span></span><br><span class="line"><span class="function">QNetworkReply *<span class="title">QNetworkAccessManager::get</span><span class="params">(<span class="type">const</span> QNetworkRequest &amp;request)</span></span>;</span><br><span class="line"><span class="comment">//	-	request:连接服务器相关的信息</span></span><br><span class="line"><span class="comment">//	-	返回值:通过QNetworkReply类接受服务器发送回来的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// --- post ---</span></span><br><span class="line"><span class="function">QNetworkReply *<span class="title">QNetworkAccessManager::post</span><span class="params">(<span class="type">const</span> QNetworkRequest &amp;request, QIODevice *data)</span></span></span><br><span class="line"><span class="function"><span class="comment">//	-	request:连接服务器相关的信息</span></span></span><br><span class="line"><span class="function"><span class="comment">//	-	data:文件指针,需要让该指针打开一个I/O设备内的数据作为请求体传递给服务器</span></span></span><br><span class="line"><span class="function"><span class="comment">//	这里的data参数是一个指向QIODevice的指针。QIODevice是QT中所有I/O设备的基类，包括文件、内存缓冲区、网络连接等。这意味着你可以使用任何从QIODevice派生的类（如QFile, QBuffer, QTcpSocket等）作为数据源。当你调用这个版本的post函数时，QNetworkAccessManager会从提供的QIODevice读取数据，并将这些数据作为HTTP POST请求的主体发送到服务器。这对于发送大量数据或者从网络流中直接读取数据非常有用</span></span></span><br><span class="line"><span class="function">QNetworkReply *<span class="title">QNetworkAccessManager::post</span><span class="params">(<span class="type">const</span> QNetworkRequest &amp;request, <span class="type">const</span> QByteArray &amp;data)</span></span></span><br><span class="line"><span class="function"><span class="comment">//	-	request:连接服务器相关的信息</span></span></span><br><span class="line"><span class="function"><span class="comment">//	-	data:作为请求体传递给服务器的数据</span></span></span><br><span class="line"><span class="function"><span class="comment">//	在QT中，你可以使用QJsonDocument, QJsonObject, QJsonArray等处理json的api来创建一个JSON对象，然后使用QJsonDocument::toJson()方法将JSON对象转换为QByteArray。然后，你可以将这个QByteArray作为data参数传递给post函数</span></span></span><br><span class="line"><span class="function">QNetworkReply *<span class="title">QNetworkAccessManager::post</span><span class="params">(<span class="type">const</span> QNetworkRequest &amp;request, QHttpMultiPart *multiPart)</span></span></span><br><span class="line"><span class="function"><span class="comment">//	-	request:连接服务器相关的信息</span></span></span><br><span class="line"><span class="function"><span class="comment">//	-	multiPart:带分界线的数据块(对应http协议中的multipart/form-data)</span></span></span><br></pre></td></tr></table></figure>

<p>[[网络编程#Content-Type|Content-Type中的multipart&#x2F;form-data详解跳转]]</p>
<h3 id="QNetworkRequest"><a href="#QNetworkRequest" class="headerlink" title="QNetworkRequest"></a>QNetworkRequest</h3><p>[[网络编程#http协议|跳转参考http协议详解]]</p>
<p>储存连接服务器相关的信息,包含</p>
<ul>
<li>服务器ip和端口信息</li>
<li>请求数据对应的指令</li>
<li>指定发送的post数据块的格式</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置url的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QNetworkRequest::setUrl</span><span class="params">(<span class="type">const</span> QUrl &amp;url)</span></span>;</span><br><span class="line"><span class="comment">//	-	url:连接,如:http://192.168.1.100:80/login/login.html</span></span><br><span class="line"><span class="comment">//因为get方式提交请求,请求数据也在url中,如:http://192.168.1.100:80/login?userName=zhang3&amp;passwd=123456</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指定发送的post数据块的格式 - 标准请求头</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QNetworkRequest::setHeader</span><span class="params">(QNetworkRequest::KnownHeaders header, <span class="type">const</span> QVariant &amp;value)</span></span></span><br><span class="line"><span class="function"><span class="comment">//	-	header: 请求头的key</span></span></span><br><span class="line"><span class="function"><span class="comment">//			QNetworkRequest::ContentTypeHeader  数据类型</span></span></span><br><span class="line"><span class="function"><span class="comment">//			QNetworkRequest::ContentLengthHeader	数据长度</span></span></span><br><span class="line"><span class="function"><span class="comment">//			QNetworkRequest::LocationHeader	重定向</span></span></span><br><span class="line"><span class="function"><span class="comment">//			QNetworkRequest::UserAgentHeader  身份标识</span></span></span><br><span class="line"><span class="function"><span class="comment">//			......</span></span></span><br><span class="line"><span class="function"><span class="comment">//	-	value: 请求头的值</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="comment">//指定发送的post数据块的格式 - 自定义请求头</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QNetworkRequest::setRawHeader</span><span class="params">(<span class="type">const</span> QByteArray &amp;headerName, <span class="type">const</span> QByteArray &amp;headerValue)</span></span></span><br><span class="line"><span class="function"><span class="comment">//基本同上</span></span></span><br></pre></td></tr></table></figure>

<h3 id="QNetworkReply"><a href="#QNetworkReply" class="headerlink" title="QNetworkReply"></a>QNetworkReply</h3><p><code>#include &lt;QNetworkReply&gt;</code></p>
<blockquote>
<p>这个对象会帮助检测服务器是否有数据会发,如果有就发送信号</p>
<p>它继承自QIODevice类,使用它内部的函数对QNetworkReply即服务器返回的数据进行读写,类似于读文件,如:<code>QByteArray QIODevice::readAll();</code></p>
</blockquote>
<p>相关信号:</p>
<ul>
<li><code>[signal] void QNetworkReply::finished()</code></li>
<li><code>[signal] void QNetworkReply::error(QNetworkReply::NetworkError code)</code></li>
<li><code>[signal] void QIODevice::readyRead()</code></li>
<li>…</li>
</ul>
<h2 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">QNetworkAccessManager manager;</span><br><span class="line">    <span class="function">QNetworkRequest <span class="title">request</span><span class="params">(QUrl(<span class="string">&quot;http://127.0.0.1:8080&quot;</span>))</span></span>;</span><br><span class="line">    <span class="comment">//发起请求</span></span><br><span class="line">    QNetworkReply *reply = manager.<span class="built_in">get</span>(request);</span><br><span class="line">    <span class="comment">//QNetworkReply *reply = manager.post(request,&quot;&#123;\&quot;userName\&quot;:\&quot;zhang3\&quot;,\&quot;passwd\&quot;:\&quot;123456\&quot;&#125;&quot;);</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(reply, &amp;QNetworkReply::readyRead,[=]()&#123;</span><br><span class="line">        <span class="comment">//接收数据</span></span><br><span class="line">        QByteArray all = reply-&gt;<span class="built_in">readAll</span>();</span><br><span class="line">        <span class="comment">//根据字符串格式进行解析,得到原始数据</span></span><br><span class="line">        <span class="comment">//业务上的逻辑判断</span></span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="built_in">QString</span>(all);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>





<h1 id="打包发布"><a href="#打包发布" class="headerlink" title="打包发布"></a>打包发布</h1><ol>
<li><p>切成release版本进行运行</p>
</li>
<li><p>将release版本生成的exe放在待发布文件夹中</p>
</li>
<li><p>QT的cmd中打开对应文件夹通过命令打包</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">windeployqt coinFilp.<span class="property">exe</span>的绝对路径</span><br></pre></td></tr></table></figure>
</li>
<li><p>发布成功，此时可通过第三方工具（例如：nis edit）再进一步封装成安装包</p>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u014546553/article/details/78741277">设置图标方法点击跳转</a></p>
<p>windeployqt的对应地址: <code>C:\Qt\&lt;Qt版本&gt;\编译器名\bin</code>下</p>
<p>可以把要打包的应用程序直接拖拽到windeployqt可执行文件上,省去输入命令的步骤</p>
<p>实测使用MinGW套件构建的项目直接运行会有问题</p>
<h1 id="QT的一些问题"><a href="#QT的一些问题" class="headerlink" title="QT的一些问题"></a>QT的一些问题</h1><h2 id="中文图片资源问题"><a href="#中文图片资源问题" class="headerlink" title="中文图片资源问题"></a>中文图片资源问题</h2><ul>
<li><strong>报错：</strong> <code>No rule to make target ‘/??. png’, needed by ‘debug/qrc_Icon. Cpp’. Stop.</code></li>
<li><strong>原因：</strong> 资源文件中包含中文命名的图片文件。</li>
</ul>
<p>将含有中文命名的图片文件从资源文件中移除，执行 qmake，在重新添加有中文图片的文件，再重新编译就不会出错了。<br>注意如果添加含有中文命名的图片文件再<strong>执行 qmake</strong>，重新构建会报错。(即此时<strong>必须直接构建</strong>)</p>
<h2 id="mac安装qt"><a href="#mac安装qt" class="headerlink" title="mac安装qt"></a>mac安装qt</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/643302036">参考</a></p>
<p>​	</p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4" title="头像" alt="头像"></a><div class="post-copyright__author_name">ZEROKO14</div><div class="post-copyright__author_desc">zeroko14's blog</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://che77a38.github.io/posts/QT/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://che77a38.github.io/posts/QT/')">QT入门</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://che77a38.github.io/posts/QT/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=QT入门&amp;url=https://che77a38.github.io/posts/QT/&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://che77a38.github.io" target="_blank">ZEROKO14的个人博客</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/QT/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>QT<span class="tagsPageCount">1</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/32%E4%BD%8D%E9%80%86%E5%90%91/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">32位逆向</div></div></a></div><div class="next-post pull-right"><a href="/posts/nginx/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">nginx</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description">欢迎来到ZEROKO14的个人博客</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">ZEROKO14</h1><div class="author-info__desc">zeroko14's blog</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/che77a38" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Qt%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">Qt概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFQt"><span class="toc-number">1.1.</span> <span class="toc-text">什么是Qt</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Qt%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2"><span class="toc-number">1.2.</span> <span class="toc-text">Qt的发展史</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E7%9A%84%E5%B9%B3%E5%8F%B0"><span class="toc-number">1.3.</span> <span class="toc-text">支持的平台</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Qt%E7%89%88%E6%9C%AC"><span class="toc-number">1.4.</span> <span class="toc-text">Qt版本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Qt%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85"><span class="toc-number">1.5.</span> <span class="toc-text">Qt的下载与安装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80%EF%BC%9A"><span class="toc-number">1.5.1.</span> <span class="toc-text">下载地址：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux-Host"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">Linux Host</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OS-X-Host"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">OS X Host</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Windows-Host"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">Windows Host</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85"><span class="toc-number">1.5.2.</span> <span class="toc-text">安装</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Qt%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">1.6.</span> <span class="toc-text">Qt的优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%8A%9F%E6%A1%88%E4%BE%8B"><span class="toc-number">1.7.</span> <span class="toc-text">成功案例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QT%E4%B8%AD%E5%B8%B8%E7%94%A8%E9%BB%98%E8%AE%A4%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="toc-number">1.8.</span> <span class="toc-text">QT中常用默认快捷键</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAQt%E9%A1%B9%E7%9B%AE"><span class="toc-number">2.</span> <span class="toc-text">创建Qt项目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%90%91%E5%AF%BC%E5%88%9B%E5%BB%BA"><span class="toc-number">2.1.</span> <span class="toc-text">使用向导创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E5%88%9B%E5%BB%BA"><span class="toc-number">2.2.</span> <span class="toc-text">手动创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pro%E6%96%87%E4%BB%B6"><span class="toc-number">2.3.</span> <span class="toc-text">.pro文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84Qt%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.4.</span> <span class="toc-text">一个最简单的Qt应用程序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%E5%92%8CQT%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="toc-number">3.</span> <span class="toc-text">命名规范和QT的快捷键</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AAQT%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%9D%90%E6%A0%87%E7%B3%BB%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">第一个QT（对象模型和坐标系）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%89%E9%92%AE%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">4.1.</span> <span class="toc-text">按钮的创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%A0%91%EF%BC%89"><span class="toc-number">4.2.</span> <span class="toc-text">对象模型（对象树）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Qt%E7%AA%97%E5%8F%A3%E5%9D%90%E6%A0%87%E4%BD%93%E7%B3%BB"><span class="toc-number">4.3.</span> <span class="toc-text">Qt窗口坐标体系</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD%E6%9C%BA%E5%88%B6"><span class="toc-number">5.</span> <span class="toc-text">信号和槽机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%87%AA%E5%B8%A6%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD"><span class="toc-number">5.1.</span> <span class="toc-text">系统自带的信号和槽</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD"><span class="toc-number">5.2.</span> <span class="toc-text">自定义信号和槽</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD%E5%8E%9F%E7%90%86"><span class="toc-number">5.3.</span> <span class="toc-text">信号和槽原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#QMetaObject%E7%B1%BB"><span class="toc-number">5.3.1.</span> <span class="toc-text">QMetaObject类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E6%A7%BD%E7%9A%84%E6%8B%93%E5%B1%95"><span class="toc-number">5.4.</span> <span class="toc-text">信号槽的拓展</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E6%B3%A8%E6%84%8F%E3%80%91%E7%BB%99label%E8%AE%BE%E7%BD%AE%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%E7%A9%BF%E9%80%8F%E6%A1%88%E4%BE%8B"><span class="toc-number">5.4.1.</span> <span class="toc-text">【注意】给label设置鼠标事件穿透案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E6%B3%A8%E6%84%8F%E3%80%91%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD%E4%BC%A0%E9%80%92%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E9%9C%80%E8%A6%81%E5%85%88%E6%B3%A8%E5%86%8C%E8%AF%A5%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.4.2.</span> <span class="toc-text">【注意】信号和槽传递自定义类型需要先注册该类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Qt4%E7%89%88%E6%9C%AC%E7%9A%84%E4%BF%A1%E5%8F%B7%E6%A7%BD%E5%86%99%E6%B3%95"><span class="toc-number">5.5.</span> <span class="toc-text">Qt4版本的信号槽写法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#connect%E4%B8%AD%E7%9A%84Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">5.6.</span> <span class="toc-text">connect中的Lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E5%8F%82%E6%95%B0%E7%89%88%E6%9C%AC%E7%9A%84%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD"><span class="toc-number">5.6.1.</span> <span class="toc-text">三参数版本的信号与槽</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#QMainWindow"><span class="toc-number">6.</span> <span class="toc-text">QMainWindow</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8F%9C%E5%8D%95%E6%A0%8F"><span class="toc-number">6.1.</span> <span class="toc-text">菜单栏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7%E6%A0%8F"><span class="toc-number">6.2.</span> <span class="toc-text">工具栏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%A0%8F"><span class="toc-number">6.3.</span> <span class="toc-text">状态栏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%86%E6%8E%A5%E9%83%A8%E4%BB%B6"><span class="toc-number">6.4.</span> <span class="toc-text">铆接部件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E9%83%A8%E4%BB%B6%EF%BC%88%E4%B8%AD%E5%BF%83%E9%83%A8%E4%BB%B6%EF%BC%89"><span class="toc-number">6.5.</span> <span class="toc-text">核心部件（中心部件）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6"><span class="toc-number">6.6.</span> <span class="toc-text">资源文件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E8%AF%9D%E6%A1%86QDialog"><span class="toc-number">7.</span> <span class="toc-text">对话框QDialog</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">7.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%AF%B9%E8%AF%9D%E6%A1%86"><span class="toc-number">7.2.</span> <span class="toc-text">标准对话框</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%AF%9D%E6%A1%86"><span class="toc-number">7.3.</span> <span class="toc-text">自定义对话框</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%80%81%E5%AF%B9%E8%AF%9D%E6%A1%86"><span class="toc-number">7.3.0.1.</span> <span class="toc-text">模态对话框</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E6%A8%A1%E6%80%81%E5%AF%B9%E8%AF%9D%E6%A1%86"><span class="toc-number">7.3.0.2.</span> <span class="toc-text">非模态对话框</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%AF%B9%E8%AF%9D%E6%A1%86"><span class="toc-number">7.4.</span> <span class="toc-text">消息对话框</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E6%96%87%E4%BB%B6%E5%AF%B9%E8%AF%9D%E6%A1%86"><span class="toc-number">7.5.</span> <span class="toc-text">标准文件对话框</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E9%A2%9C%E8%89%B2%E5%AF%B9%E8%AF%9D%E6%A1%86"><span class="toc-number">7.6.</span> <span class="toc-text">标准颜色对话框</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%AD%97%E4%BD%93%E5%AF%B9%E8%AF%9D%E6%A1%86"><span class="toc-number">7.7.</span> <span class="toc-text">标准字体对话框</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">8.</span> <span class="toc-text">布局管理器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%8F%90%E4%BE%9B%E7%9A%84%E5%B8%83%E5%B1%80%E6%8E%A7%E4%BB%B6"><span class="toc-number">8.1.</span> <span class="toc-text">系统提供的布局控件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8widget%E5%81%9A%E5%B8%83%E5%B1%80"><span class="toc-number">8.2.</span> <span class="toc-text">利用widget做布局</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6"><span class="toc-number">9.</span> <span class="toc-text">常用控件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#QLabel%E6%8E%A7%E4%BB%B6%E4%BD%BF%E7%94%A8"><span class="toc-number">9.1.</span> <span class="toc-text">QLabel控件使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E6%96%87%E5%AD%97-%EF%BC%88%E6%99%AE%E9%80%9A%E6%96%87%E6%9C%AC%E3%80%81html%EF%BC%89"><span class="toc-number">9.1.1.</span> <span class="toc-text">显示文字 （普通文本、html）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87"><span class="toc-number">9.1.2.</span> <span class="toc-text">显示图片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E5%8A%A8%E7%94%BB"><span class="toc-number">9.1.3.</span> <span class="toc-text">显示动画</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QLineEdit"><span class="toc-number">9.2.</span> <span class="toc-text">QLineEdit</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE-%E8%8E%B7%E5%8F%96%E5%86%85%E5%AE%B9"><span class="toc-number">9.2.0.1.</span> <span class="toc-text">设置&#x2F;获取内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%98%BE%E7%A4%BA%E6%A8%A1%E5%BC%8F"><span class="toc-number">9.2.0.2.</span> <span class="toc-text">设置显示模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QToolButton"><span class="toc-number">9.3.</span> <span class="toc-text">QToolButton</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QRadioButton"><span class="toc-number">9.4.</span> <span class="toc-text">QRadioButton</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QCheckBox"><span class="toc-number">9.5.</span> <span class="toc-text">QCheckBox</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QListWidget"><span class="toc-number">9.6.</span> <span class="toc-text">QListWidget</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QTreeWidget"><span class="toc-number">9.7.</span> <span class="toc-text">QTreeWidget</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QTableWidget"><span class="toc-number">9.8.</span> <span class="toc-text">QTableWidget</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%8E%A7%E4%BB%B6"><span class="toc-number">9.9.</span> <span class="toc-text">其他控件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6"><span class="toc-number">9.10.</span> <span class="toc-text">自定义控件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E6%8E%A7%E4%BB%B6%E5%90%8D%E6%89%BE%E6%8E%A7%E4%BB%B6%E6%A1%88%E4%BE%8B"><span class="toc-number">10.</span> <span class="toc-text">根据控件名找控件案例</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Qt%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E5%92%8C%E4%BA%8B%E4%BB%B6"><span class="toc-number">11.</span> <span class="toc-text">Qt消息机制和事件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%EF%BC%88%E5%86%85%E5%90%AB%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%89"><span class="toc-number">11.1.</span> <span class="toc-text">事件（内含定时器）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-1-%E9%83%A8%E5%88%86%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6"><span class="toc-number">11.1.1.</span> <span class="toc-text">9.1.1 部分鼠标事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-2-%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">11.1.2.</span> <span class="toc-text">9.1.2 定时器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#event%EF%BC%88%EF%BC%89%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E5%99%A8"><span class="toc-number">11.2.</span> <span class="toc-text">event（）事件分发器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">11.3.</span> <span class="toc-text">事件过滤器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">11.4.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6"><span class="toc-number">11.5.</span> <span class="toc-text">自定义事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">11.5.1.</span> <span class="toc-text">自定义事件的类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%8F%91%E9%80%81%E6%96%B9%E5%BC%8F"><span class="toc-number">11.5.2.</span> <span class="toc-text">事件的发送方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-number">11.5.3.</span> <span class="toc-text">自定义事件处理函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%98%E5%9B%BE%E5%92%8C%E7%BB%98%E5%9B%BE%E8%AE%BE%E5%A4%87"><span class="toc-number">12.</span> <span class="toc-text">绘图和绘图设备</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#QPainter"><span class="toc-number">12.1.</span> <span class="toc-text">QPainter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%98%E5%9B%BE%E8%AE%BE%E5%A4%87"><span class="toc-number">12.2.</span> <span class="toc-text">绘图设备</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#QPixmap%E3%80%81QBitmap%E3%80%81QImage"><span class="toc-number">12.2.1.</span> <span class="toc-text">QPixmap、QBitmap、QImage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#QPicture"><span class="toc-number">12.2.2.</span> <span class="toc-text">QPicture</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">13.</span> <span class="toc-text">文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">13.1.</span> <span class="toc-text">基本文件操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99"><span class="toc-number">13.2.</span> <span class="toc-text">二进制文件读写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99"><span class="toc-number">13.3.</span> <span class="toc-text">文本文件读写</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#QT%E7%AE%80%E5%8D%95%E7%9A%84%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C"><span class="toc-number">14.</span> <span class="toc-text">QT简单的动画效果</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#QT%E6%B7%BB%E5%8A%A0%E9%9F%B3%E6%95%88"><span class="toc-number">15.</span> <span class="toc-text">QT添加音效</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E7%BB%86%E8%8A%82"><span class="toc-number">16.</span> <span class="toc-text">优化细节</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#qt-setData-%E5%92%8Cdata"><span class="toc-number">17.</span> <span class="toc-text">qt setData()和data()</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0"><span class="toc-number">17.1.</span> <span class="toc-text">简述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%8E%A5%E5%8F%A3"><span class="toc-number">17.2.</span> <span class="toc-text">常见接口</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#QT%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">18.</span> <span class="toc-text">QT多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%B1%BB-QThread"><span class="toc-number">18.1.</span> <span class="toc-text">线程类 QThread</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%A7%8D%E5%88%9B%E5%BB%BA%E5%AD%90%E7%BA%BF%E7%A8%8B"><span class="toc-number">18.2.</span> <span class="toc-text">第一种创建子线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4"><span class="toc-number">18.2.1.</span> <span class="toc-text">操作步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-number">18.2.2.</span> <span class="toc-text">示例代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%A7%8D%E5%88%9B%E5%BB%BA%E5%AD%90%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">18.3.</span> <span class="toc-text">第二种创建子线程的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4-1"><span class="toc-number">18.3.1.</span> <span class="toc-text">操作步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-1"><span class="toc-number">18.3.2.</span> <span class="toc-text">示例代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QT%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">18.4.</span> <span class="toc-text">QT线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">18.4.1.</span> <span class="toc-text">线程池的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#QRunnable"><span class="toc-number">18.4.2.</span> <span class="toc-text">QRunnable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#QThreadPool"><span class="toc-number">18.4.3.</span> <span class="toc-text">QThreadPool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-2"><span class="toc-number">18.4.4.</span> <span class="toc-text">示例代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A5%E5%8F%97windows%E5%8E%9F%E7%94%9F%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86"><span class="toc-number">19.</span> <span class="toc-text">接受windows原生消息处理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E5%9B%BE%E6%A0%87"><span class="toc-number">20.</span> <span class="toc-text">添加图标</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#QT-%E6%B7%BB%E5%8A%A0DLL"><span class="toc-number">21.</span> <span class="toc-text">QT 添加DLL</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#QT%E4%BB%A5%E7%AE%A1%E7%90%86%E5%91%98%E5%90%AF%E5%8A%A8"><span class="toc-number">22.</span> <span class="toc-text">QT以管理员启动</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#QT%E7%BC%96%E7%A0%81"><span class="toc-number">23.</span> <span class="toc-text">QT编码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#QT-json"><span class="toc-number">23.1.</span> <span class="toc-text">QT json</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QT%E7%9A%84base64%E7%BC%96%E7%A0%81"><span class="toc-number">23.2.</span> <span class="toc-text">QT的base64编码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#QT%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">24.</span> <span class="toc-text">QT中的类型转换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#QT%E4%B8%AD%E7%9A%84%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2"><span class="toc-number">25.</span> <span class="toc-text">QT中的编码转换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#gbk%E8%BD%ACutf8"><span class="toc-number">25.1.</span> <span class="toc-text">gbk转utf8</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#QT%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91"><span class="toc-number">26.</span> <span class="toc-text">QT数据库开发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#oracle%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">26.1.</span> <span class="toc-text">oracle数据库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mysql%E5%BC%80%E5%8F%91"><span class="toc-number">26.2.</span> <span class="toc-text">mysql开发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E6%95%B0%E6%8D%AE%E5%BA%93%E9%A9%B1%E5%8A%A8"><span class="toc-number">26.2.1.</span> <span class="toc-text">加载数据库驱动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81"><span class="toc-number">26.2.2.</span> <span class="toc-text">设置账号密码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%BC%80%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">26.2.3.</span> <span class="toc-text">打开数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">26.2.4.</span> <span class="toc-text">关闭数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">26.2.5.</span> <span class="toc-text">操作数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8Cselect%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C"><span class="toc-number">26.2.5.1.</span> <span class="toc-text">执行select查询操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E8%AF%AD%E5%8F%A5"><span class="toc-number">26.2.5.1.1.</span> <span class="toc-text">执行语句</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E6%9E%9C%E9%9B%86%E8%AE%B0%E5%BD%95%E6%95%B0%E5%92%8C%E5%AD%97%E6%AE%B5%E6%95%B0"><span class="toc-number">26.2.5.1.2.</span> <span class="toc-text">结果集记录数和字段数</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E5%AD%97%E6%AE%B5%E6%95%B0"><span class="toc-number">26.2.5.1.2.1.</span> <span class="toc-text">查询字段数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E8%AE%B0%E5%BD%95%E6%95%B0"><span class="toc-number">26.2.5.1.2.2.</span> <span class="toc-text">查询记录数</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E7%BB%93%E6%9E%9C%E9%9B%86"><span class="toc-number">26.2.5.1.3.</span> <span class="toc-text">遍历结果集</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8Cinsert%E6%93%8D%E4%BD%9C"><span class="toc-number">26.2.5.2.</span> <span class="toc-text">执行insert操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5"><span class="toc-number">26.2.5.2.1.</span> <span class="toc-text">直接插入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%A0%E4%BD%8D%E7%AC%A6%E6%8F%92%E5%85%A5"><span class="toc-number">26.2.5.2.2.</span> <span class="toc-text">占位符插入</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8Cupdate%E6%93%8D%E4%BD%9C"><span class="toc-number">26.2.5.3.</span> <span class="toc-text">执行update操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5update"><span class="toc-number">26.2.5.3.1.</span> <span class="toc-text">直接update</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%A0%E4%BD%8D%E7%AC%A6update"><span class="toc-number">26.2.5.3.2.</span> <span class="toc-text">占位符update</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8Cdelete%E6%93%8D%E4%BD%9C"><span class="toc-number">26.2.5.4.</span> <span class="toc-text">执行delete操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5delete"><span class="toc-number">26.2.5.4.1.</span> <span class="toc-text">直接delete</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%A0%E4%BD%8D%E7%AC%A6delete"><span class="toc-number">26.2.5.4.2.</span> <span class="toc-text">占位符delete</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86"><span class="toc-number">26.2.6.</span> <span class="toc-text">事务处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sqlite%E5%BC%80%E5%8F%91"><span class="toc-number">26.3.</span> <span class="toc-text">sqlite开发</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#QT%E4%B8%AD%E7%9A%84http"><span class="toc-number">27.</span> <span class="toc-text">QT中的http</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Qt%E4%B8%ADhttp%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">27.1.</span> <span class="toc-text">Qt中http的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#QNetworkAccessManager"><span class="toc-number">27.1.1.</span> <span class="toc-text">QNetworkAccessManager</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#QNetworkRequest"><span class="toc-number">27.1.2.</span> <span class="toc-text">QNetworkRequest</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#QNetworkReply"><span class="toc-number">27.1.3.</span> <span class="toc-text">QNetworkReply</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F"><span class="toc-number">27.2.</span> <span class="toc-text">示例程序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%93%E5%8C%85%E5%8F%91%E5%B8%83"><span class="toc-number">28.</span> <span class="toc-text">打包发布</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#QT%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98"><span class="toc-number">29.</span> <span class="toc-text">QT的一些问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%87%E5%9B%BE%E7%89%87%E8%B5%84%E6%BA%90%E9%97%AE%E9%A2%98"><span class="toc-number">29.1.</span> <span class="toc-text">中文图片资源问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mac%E5%AE%89%E8%A3%85qt"><span class="toc-number">29.2.</span> <span class="toc-text">mac安装qt</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/%E5%B7%A5%E4%B8%9A%E7%9B%B8%E5%85%B3/" title="工业相关">工业相关</a><time datetime="2025-02-14T03:04:40.761Z" title="发表于 2025-02-14 11:04:40">2025-02-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/%E8%AE%A1%E7%BB%84/" title="计算机组成原理">计算机组成原理</a><time datetime="2024-12-16T01:38:01.470Z" title="发表于 2024-12-16 09:38:01">2024-12-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/" title="网络架构">网络架构</a><time datetime="2024-11-18T06:17:01.282Z" title="发表于 2024-11-18 14:17:01">2024-11-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/avalonia/" title="avalonia">avalonia</a><time datetime="2024-09-11T14:51:13.000Z" title="发表于 2024-09-11 22:51:13">2024-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/%E8%A7%86%E9%A2%91%E6%95%88%E6%9E%9C/" title="PR">PR</a><time datetime="2024-07-18T07:06:08.330Z" title="发表于 2024-07-18 15:06:08">2024-07-18</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2025 By <a class="footer-bar-link" href="/" title="ZEROKO14" target="_blank">ZEROKO14</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu"></a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">60</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">50</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">6</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size: 0.88rem;">C#<sup>2</sup></a><a href="/tags/C/" style="font-size: 0.88rem;">C++<sup>5</sup></a><a href="/tags/CSS/" style="font-size: 0.88rem;">CSS<sup>1</sup></a><a href="/tags/CSharp/" style="font-size: 0.88rem;">CSharp<sup>1</sup></a><a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 0.88rem;">C语言<sup>1</sup></a><a href="/tags/FPS/" style="font-size: 0.88rem;">FPS<sup>1</sup></a><a href="/tags/HTML/" style="font-size: 0.88rem;">HTML<sup>1</sup></a><a href="/tags/JavaScript/" style="font-size: 0.88rem;">JavaScript<sup>1</sup></a><a href="/tags/MFC/" style="font-size: 0.88rem;">MFC<sup>1</sup></a><a href="/tags/PE/" style="font-size: 0.88rem;">PE<sup>1</sup></a><a href="/tags/QT/" style="font-size: 0.88rem;">QT<sup>1</sup></a><a href="/tags/WPF/" style="font-size: 0.88rem;">WPF<sup>2</sup></a><a href="/tags/ai/" style="font-size: 0.88rem;">ai<sup>1</sup></a><a href="/tags/cmake/" style="font-size: 0.88rem;">cmake<sup>1</sup></a><a href="/tags/doxygen/" style="font-size: 0.88rem;">doxygen<sup>1</sup></a><a href="/tags/git/" style="font-size: 0.88rem;">git<sup>1</sup></a><a href="/tags/json/" style="font-size: 0.88rem;">json<sup>1</sup></a><a href="/tags/linux/" style="font-size: 0.88rem;">linux<sup>1</sup></a><a href="/tags/nas/" style="font-size: 0.88rem;">nas<sup>1</sup></a><a href="/tags/next/" style="font-size: 0.88rem;">next<sup>1</sup></a><a href="/tags/ppt/" style="font-size: 0.88rem;">ppt<sup>1</sup></a><a href="/tags/slidev/" style="font-size: 0.88rem;">slidev<sup>1</sup></a><a href="/tags/vue/" style="font-size: 0.88rem;">vue<sup>1</sup></a><a href="/tags/xml/" style="font-size: 0.88rem;">xml<sup>1</sup></a><a href="/tags/yaml/" style="font-size: 0.88rem;">yaml<sup>1</sup></a><a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 0.88rem;">代码规范<sup>1</sup></a><a href="/tags/%E5%86%85%E6%A0%B8/" style="font-size: 0.88rem;">内核<sup>2</sup></a><a href="/tags/%E5%86%85%E6%A0%B8%E7%9B%B8%E5%85%B3/" style="font-size: 0.88rem;">内核相关<sup>5</sup></a><a href="/tags/%E5%8A%A0%E8%A7%A3%E5%AF%86/" style="font-size: 0.88rem;">加解密<sup>1</sup></a><a href="/tags/%E5%9F%BA%E7%A1%80/" style="font-size: 0.88rem;">基础<sup>2</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 0.88rem;">多线程<sup>1</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F/" style="font-size: 0.88rem;">并发模式<sup>1</sup></a><a href="/tags/%E5%BC%80%E5%8F%91/" style="font-size: 0.88rem;">开发<sup>4</sup></a><a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 0.88rem;">数学<sup>1</sup></a><a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 0.88rem;">正则表达式<sup>1</sup></a><a href="/tags/%E7%9B%91%E6%8E%A7/" style="font-size: 0.88rem;">监控<sup>1</sup></a><a href="/tags/%E7%A1%AC%E7%BC%96%E7%A0%81/" style="font-size: 0.88rem;">硬编码<sup>1</sup></a><a href="/tags/%E7%AE%A1%E7%90%86/" style="font-size: 0.88rem;">管理<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 0.88rem;">网络<sup>3</sup></a><a href="/tags/%E9%80%86%E5%90%91/" style="font-size: 0.88rem;">逆向<sup>2</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.cbd.int/mathjax@3.2.2/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.cbd.int/mermaid@10.2.4/dist/mermaid.min.js').then(runMermaid)
  }

  anzhiyu.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>