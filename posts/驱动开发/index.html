<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>驱动开发 | ZEROKO14的个人博客</title><meta name="keywords" content="内核相关"><meta name="author" content="ZEROKO14"><meta name="copyright" content="ZEROKO14"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#18171d"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="驱动开发"><meta name="application-name" content="驱动开发"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#18171d"><meta property="og:type" content="article"><meta property="og:title" content="驱动开发"><meta property="og:url" content="https://che77a38.github.io/posts/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/index.html"><meta property="og:site_name" content="ZEROKO14的个人博客"><meta property="og:description" content="驱动开发理解  SDK   software development kits(软件开发包)   如Visual Studio 2019(v142) WDK  windows driver development kits(驱动开发包)  如WindowsKernelModeDriver10.0"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4"><meta property="article:author" content="ZEROKO14"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4"><meta name="description" content="驱动开发理解  SDK   software development kits(软件开发包)   如Visual Studio 2019(v142) WDK  windows driver development kits(驱动开发包)  如WindowsKernelModeDriver10.0"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://che77a38.github.io/posts/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2024/07/27/125766904/ba62475f396df9de3316a08ed9e65d86_5680958632268053399..png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":true,"limitCount":50,"languages":{"author":"作者: ZEROKO14","link":"链接: ","source":"来源: ZEROKO14的个人博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'ZEROKO14的个人博客',
  title: '驱动开发',
  postAI: '',
  pageFillDescription: '驱动开发, 准备工作, 设置双机调试步骤, 设置windbg连接哪个串口, 设置符号, windbg调试蓝屏dump文件, 操作系统设置dump文件生成步骤, PDB（Program Debug Database）, 第一个驱动程序, 头文件Wdm.h、Ntddk.h 和 Ntifs.h 的组织结构, 内核编程基础, 内核API的使用, 未导出函数的使用, 基本数据类型, 返回值, 内核函数中的异常处理, 常用的内核内存函数, 内核字符串种类, 常用的其他内核API函数, IRQL中断请求级别, 驱动内核框架, Windows的驱动开发模型变迁, 内核编程的主要调用源：, 函数的多线程安全性, 代码的中断级, WDK中出现的特殊代码, IN和OUT, , 内核空间与内核模块, 内核空间, 内核模块, DRIVER_OBJECT结构体, _LDR_DATA_TABLE_ENTRY结构体, 遍历内核模块并断链作业, 避免断链蓝屏MiProcessLoaderEntry, 驱动键鼠过滤, 驱动开发中的链表, 零环与三环通信(常规方式), , 设备对象结构, IoCreateDevice, 删除设备对象, 设置交互数据的方式, 创建与卸载符号链接, IRP与派遣函数, IRP类型, IRP结构, IO_STACK_LOCATION结构, 派遣函数, 派遣函数在哪里注册呢？, 注册派遣函数, 派遣函数的格式, IRP_MJ_DEVICE_CONTROL的派遣函数, CTL操作码, IRP_MJ_DEVICE_CONTROL的派遣函数编写, 三环写法, IRP_MJ_DEVICE_CONTROL交互数据实验, R0代码：, R3代码：, 驱动加载, 驱动注册x2F安装, , 创建服务, 驱动启动, 打开服务, 开始服务, 停止驱动, 控制服务, 卸载驱动, 驱动加载x2F启动x2F停止x2F卸载案例, 全局监听API实验, R0代码, R3代码, 重难点, Inline Hook, 注册系统回调保护进程, 核心函数ObRegisterCallbacks, OB_CALLBACK_REGISTRATION结构, _OB_OPERATION_REGISTRATION结构体, 自定义回调函数, 注册系统回调案例, 补充, 进程有哪些权限, 驱动中通过进程对象结构体首地址获取进程名, 进程id获取进程名, 另一种实现方式, 驱动中设置断点, 代码的方式下断点, windbg直接下断点, 远程读写绕过系统回调保护, 进程挂靠的方式实现, 读进程, 写进程, MDL方式, 读内存, 写内存, CR0方式写只读内存, 物理内存读写内存方法, 核心函数, ZwMapViewOfSection, 完整代码, 最外层的读写内存接口, 获取最大物理地址函数, 获取物理地址的值函数, 物理内存读写函数, 针对对象回调钩子的操作, 遍历进程x2F线程对象钩子, 需要用的自定义结构和变量, 遍历回调需要用到的自定义子函数(包含依赖关系), 遍历回调函数, 完美过掉对象保护钩子, 需要用到的结构, 需要用到的自定义子函数以及全局变量, 接口函数, 句柄表遍历相关, R3句柄遍历, NtQuerySystemInformation函数, 完整项目参考, 一些名词理解, 签名相关, 签名工具使用, 64位16进制字符串操作, 设定驱动和用户层相接数据结构, R3用到的内核相关结构体大整合驱动开发理解软件开发包如驱动开发包如设置他们的位置在属性配置属性常规平台工具集但实际上无需手动设置因为新建什么项目时都帮你自动配置好了准备工作环境配置参考创建项目生成的文件中的后缀文件可以直接删除在源文件中添加的必须是后缀的语言文件项目配置中属性中将警告视为错误选项设置为否属性链接器中将链接器警告视为错误设为否由于使用的是作为开发环境所以要针对进行项目配置参考链接开发各平台驱动的设置参考如果建立的是项目的话除了上述步骤还可以将属性中选项设置为否制作不同系统的驱动要设置属性设置为对应操作系统属性设置为驱动的开发流程编写代码生成文件部署启动停止卸载驱动程序的测试最好在虚拟机中测试因为一出问题就蓝屏软件监视选项中要选上监视核心驱动开发的调试双机调试操作系统调试驱动需要打开测试模式关闭驱动数字证书检测打开测试模式一秒之后重启系统无论是还是版本的驱动都会带一个测试的签名测试的签名只在测试模式下有效非测试模式下等于没有签名无法加载驱动虚拟机设置防止待机过长屏幕自动关闭时虚拟机出现问题右键显示设置电源和随眠屏幕定时关闭调成从不设置双机调试步骤虚拟机设置中添加串行端口红色线虽然显示是串行端口但实际上由于当前只有一个串行端口所以在虚拟机系统中设置的引导的调试端口应该是然后如下到操作系统中添加调试引导项操作系统打开双机调试模式操作系统添加新引导管理员启动新建引导选项新引导的名字随意取手动到运行输入回车选到新建的引导高级选项打开调试模式设置调试端口为多少可以到虚拟机中设别管理器的串行端口查看不要受几的名字影响顺序是第几个就是几设置连接哪个串口两种方式图形化操作下面主要介绍的是这种方式快捷方式设置参数管道名打开后点击打开的窗口中选择设置为虚拟机中给串行端口设置的命名管道名字并且勾选表示是命名管道和设置符号设置添加系统环境变量的值为强制加载符号命令使用可以看到已加载的符号信息调试蓝屏文件可用于查看蓝屏的文件文件默认位置在中在中选择打开蓝屏的文件分析命令该命令可以看到蓝屏的时候的调用栈查看堆栈命令往往是通过调用栈查看问题出在哪里操作系统设置文件生成步骤此电脑右键属性高级系统设置启动和故障恢复处的设置按钮在该界面做如下修改勾选将事件写入系统日志写入调试信息设置为核心内存转储此处也可以设置转储文件的保存位置补充修复虚拟机花屏重新安装选择修改去除驱动核显驱动然后重新在虚拟机中安装显卡驱动什么是文件文件是在我们编译工程的时候产生的它是和对应的模块或一起生成出来的每个模块编译的时候都可以生成自己的文件比如等等文件对应上了位置和函数名如何找到文件上面可以在后面添加继续添加本地地址比如是本地路径是网络路径让重新加载错误此项目需要缓解了漏洞的库在属性常规输出目录宏中搜索确定需要的是版本的单个组件中搜索将黄标全部勾选点击修改问题解决第一个驱动程序驱动开发用此头文件开发除了的其他系统卸载函数停止运行了入口函数相当于函数驱动程序的入口设置一个卸载函数用于退出中可以使用命令查看对应数据结构的数据头文件驱动开发用此头文件开发头文件和的组织结构在版本的之前用于驱动程序开发的主要头文件为和它们包含很多重复声明从版本的开始和将按层次结构来组织并且不包含重复信息上层的文件将包含下层的文件每个函数和结构声明仅出现一次包含而又包含内核编程基础内核的使用在应用层编程我们可以使用提供的各种函数只要导入头文件就可以了但是在内核编程的时候我们不能像那样直接使用微软为内核提供了专门的只要在程序中包含相应的头文件就可以使用了如假设你已经正确安装了在应用层编程的时候我们通过来了解函数的详细信息在内核编程的时候要使用自己的帮助文档未导出函数的使用内核函数有三种有一些是文档有写也导出了的函数有一些是文档没写但导出了的函数还有一些是文档没写也没导出的函数通过自己特征码定位的位置手动调用说明文档只包含了内核模块导出的函数对于未导出的函数则不能直接使用如果要使用未导出的函数只要自己定义一个函数指针并且为函数指针提供正确的函数地址就可以使用了有两种办法都可以获取为导出的函数地址特征码搜索解析内核文件基本数据类型在内核编程的时候强烈建议大家遵守的编码习惯不要这么写习惯使用自己的类型的类型含义返回值大部分内核函数的返回值都是类型如这个值能说明函数执行的结果比如返回宏代表数值含义成功参数无效这个错误出现往往代表出现了很多错误因此不代表任何意义缓冲区长度不够不能算作一个错误只是文件传输请求未决异步资源调用错误当你调用的内核函数如果返回的结果不是就说明函数执行中遇到了问题具体是什么问题可以在文件中查看内核函数中的异常处理意义不大该蓝屏还是蓝屏在内核中一个小小的错误就可能导致蓝屏比如读写一个无效的内存地址为了让自己的内核程序更加健壮强烈建议大家在编写内核程序时使用异常处提供了机构化异常处理机制一般的编译器都是支持的如下可能出错的代码出错时要执行的代码出现异常时可根据的值来决定程序该如何执行当的值为含义代码进入块不处理异常由上一层调用函数处理回去继续执行错误处的代码基本用不到常用的内核内存函数对内核的使用主要就是申请设置拷贝以及释放语言内核中内核可用内核可用非重叠复制非重叠复制内核可用重叠复制重叠复制已被淘汰取而代之的是后又在版本中被弃用并已被取代内核字符串种类字符串当前字符串的长度最大长度指针字符串要放在全局内核中字符串尽量用字符串和字符串通过这种方法能避免使用结尾读字符串的时候读个字符就可以了防止访问蓝屏内核字符串常用函数字符串字符串含义创建字符串复制字符串比较字符串字符串转换字符串拼接销毁字符串转换成大写字符串是否相等打印字符串符号格式说明符类型字符宽字符十进制有符号整数十进制十六进制的终止的字符串终止的宽字符串字符串字符串十进制的小写字符十六进制的大写字符十六进制的指针位根据上说明格式只能在时才能使用常用的其他内核函数函数含义获取一个快速互斥体用于多线程环境下的同步快速释放一个互斥体抛出一个异常带有一个值的代码很深的地方直接报错创建文件写入文件读取文件查询目录文件创建设备文件创建注册表的键创建注册表的键值创建文件比更加底层创建设备发送一个请求实际上这个函数可能是由别名完成请求将当前请求的栈空间拷贝到下一个栈空间跳过当前栈空间获得当前栈空间指针中断请求级别处理器在一个上执行线程代码是帮助决定线程如何被中断的在同一处理器上线程只能被更高级别的线程能中断每个处理器都有自己的中断我们经常遇见的有四种级别将会在被调用无中断最低级别没有被屏蔽的中断在这个级别上线程执行用户模式可以访问分页内存等分发函数都处于这个级别我们创建的线程也是这个级别软中断在这个级别上只有级别的中断被屏蔽可以访问分页内存当有发生时处理器提升到级别这样就屏蔽掉其它为了和执行一些同步驱动程序可以手动提升到这个级别比如如果提升到这个级别就不能调用在这个级别被禁止了导致禁止一些完成所以有一些不能调用阻止响应任何而且线程不能被挂起为什么不能被挂起因为操作系统实现线程挂起的方式就是递交软中断这个级别延迟过程和更低的中断被屏蔽不能访问分页内存所有的被访问的内存不能分页因为只能处理分页内存所以在这个级别能够访问的大大减少硬中断通常处于高层次的驱动程序不会使用这个等级在这个等级上所有的中断都会被忽略这是的最高等级通常使用这个来判断设备的优先级一般的更高级的驱动在这个级别上不处理但是几乎所有的中断被屏蔽这实际上是的一个范围这是一个决定某个驱动有更高的优先级的方法驱动内核框架的驱动开发模型变迁再之后进一步原有基础上封装了一套更简单的现在内核编程的主要调用源入口函数和卸载函数单线程环境各种分发函数多线程环境可以和并发无法和并发处理请求时设置的完成函数多线程环境其他回调函数网络相关多线程环境函数的多线程安全性可能运行于多线程环境的函数必须是多线程安全的只运行于单线程环境的函数则不需要多线程安全性如果函数的所有调用源只运行于同一单线程环境则函数也是只运行在单线程环境下如果函数的其中一个调用源是可能运行在多线程环境下的或者多个调用源可能运行于不同的可并发的多线程环境而且调用路径上没有采取多线程序列化成单线程的强制措施则函数也是可能运行在多线程环境的如果函数所有可能运行于多线程环境的调用路径上都有多线程序列化成单线程的强制措施则函数是运行于单线程环境的只使用函数内部资源的完全不使用全局变量静态变量或其他全局性资源的函数是多线程安全的如果对某个全局变量或者静态变量的所有访问都被强制的同步手段限制为同一时刻只有一个线程访问则即使使用了这些全局变量或静态变量对函数的多线程安全性也是没有影响的调用源运行环境原因单线程这两个函数由系统集成的单一线程调用不会出现多线程同时调用的情况各种分发函数多线程没有任何文档保证分发函数是不会被多线程同时调用的此外分发函数是不会和并发但可能和并发完成函数多线程完成函数随时可能被未知的线程调用各种回调函数多线程同上代码的中断级编程是没有中断级这个概念的但是在内核编程中是有中断级的概念的我们的程序好像是并发的但其实是有优先级的就是中断级规则如果在调用路径上没有特殊情况导致中断级的提高或降低则一个函数执行时的中断和它的调用源的中断级相同如果在调用路径上有获取自旋锁则中断级随之升高如果调用路径上有释放自旋锁则中断级随之下降调用源一般运行中断级级各种分发函数级完成函数级各种回调函数级中出现的特殊代码和空定义只是作为提示函数中参数时输入还是输出的有时驱动程序的某些部分必须驻留内存而另一些可以被分页这就需要一种能控制代码和数据是否分页的方法通过指导编译器的段分配可以实现这个目的把驱动程序的单独例程放到特定段中使编译器把代码放到特定段的传统方法是使用编译指示但不是每种编译器都支持这个编译指示表示函数和都运行在分页内存中就是有可能被交换到分页池中程序中一些高等级例如级别的代码当然不能运行在分页内存这样往往出现如果没有上述指令则默认位于这个节即不会把内存放入硬盘使用注意该编译指示必须跟在函数声明后面而不能在前面你可以把驱动程序中的所有函数集中到一个头文件中并在包含该头文件的源文件中在语句的后面使用该编译指示仅能用于有连接形式的函数即它不能用于类成员函数或源文件中未用声明的函数某些代码在驱动程序完成初始化后不再需要可以直接把它插入到段内核空间与内核模块内核空间内核空间中的地址在各个进程中都是一样的内核模块定义全局变量可在不同进程中查看进入对应进程的进程空间罗列出来的进程信息枚举将后接的地址放入下面的命令上面获取到的地址转到了对应进程的内存空间内核模块硬件种类繁多不可能做一个兼容所有硬件的内核所以微软提供规定的接口格式让硬件驱动人员按照规定的格式编写驱动程序这些驱动程序每一个都是一个模块称为内核模块都可以加载到内核中都遵守结构本质上讲任意一个文件与内核文件没有区别结构体定义在中每个内核模块都有一个对应的结构体来描述这个模块在内核中的各种信息位置大小名称等等类型大小设备对象这里实际上是一个设备对象的链表的开始因为中有相关链表信息驱动被加载到什么地方了即内核模块的起始地址该驱动内核模块的大小指向当前驱动的结构体的指针热拔插会用到的相关信息驱动的名字注册表某派遣函数快速分发函数初始化派遣函数某派遣函数驱动卸载派遣函数包含个派遣函数地址编号的对应的派遣函数的地址就存在的位置热拔插驱动相关的等等因为他们是固有特征尽可能隐藏特征因为内核文件已经加载到内存里了所以即使修改了也不影响正常运行结构体完整版定义见的所有内核模块的双向链表初始化顺序双向链表内核模块的起始地址内核模块的大小完整的内核模块名实际上就是全路径只有内核模块名如校验和版符号结构通杀和版这里字节对齐要采用默认不要按对齐这样才符合位和位结构体结构可以通过找到记录所有内核模块简单信息的双向链表但双向链表没法找回结构因此即使是在双向链表中将目标驱动断链了对于也依然能找到内核对象原因是因为是通过特征码直接索引到结构来遍历所有内核模块而非通过该双向链表遍历内核模块并断链作业驱动对象遍历模块隐藏断链保存原卸载函数恢复原链和原恢复原恢复原链停止运行了内核对象链表遍历内核对象链表断链修正原中的指向前一个链表入口函数相当于函数驱动程序的入口断链前断链后设置一个卸载函数用于退出打印如下断链前断链后停止运行了由上面打印可知成功被隐藏但依然可以查找到我们的驱动驱动模块断链会导致蓝屏驱动隐藏特征码抹除无法找到卸载的了开始执行抹除特征执行结束驱动被加载上面代码可让也找不到驱动但此代码只做了抹特征隐藏却并未恢复特征或手动调用函数卸载驱动停止驱动的时候会因为信息缺失直接蓝屏需要一个时间点做恢复特征不可以在中因为是还没到该函数就蓝屏了位下不能直接断链的原因避免断链蓝屏函数讲解跳转第一个参数是当前链表第二个参数表示卸载表示插入该函数模块从链表上移除了但没有释放内存位用这个函数不会触发不会蓝屏可以理解成就是保护全局变量不被直接修改方式断链代码参考跳转和的区别把宏替换成什么也没有即如下两句在模式下含义相同但在模式下不会打印驱动键鼠过滤绑定设备生成的设备对象目标串口设备名称返回被绑定设备指针的指针使用驱动开发中的链表常用函数判断链表是否为空初始化双向链表头插入链表头部插入链表尾部移除头部节点移除尾部节点移除当前节点链表在驱动中需要处理同步因为链表涉及到指针操作一不小心就可能导致蓝屏因此驱动开发中数组可以不需要同步处理多线程写入同一个位置一样可能有问题但概率没那么大但链表必须做同步处理零环与三环通信常规方式常规方式表示微软提供的正常通信方式还有非常规通信正常通信方式受到一定限制设备对象我们在开发窗口程序的时候消息被封装成一个结构体在内核开发时消息被封装成另外一个结构体输入输出请求包在窗口程序中能够接受消息的只能是窗口对象在内核中能够接收消息的只能是设备对象驱动对象生成多个设备对象设备对象可以是硬件硬盘等也可以是软件比如文件系统它们都属于设备对象创建设备对象设备对象结构类型大小引用计数指向驱动程序中驱动对象的指针设备所属的驱动对象指向下一个设备对象的指针下一个设备对象在一个驱动对象中有个设备这些设备用这个指针连接起来作为一个单向的链表当前结构设备对象的特性标志指向设备扩展对象的指针指明设备类型堆栈的最小层数栈的大小用于存放参数的内存对齐下列成员用于支持文件系统的互斥操作以便对文件系统处理线程使用设备的计数保持跟踪驱动对象指针指定要为设备对象的设备扩展分配的驱动程序确定的字节数设备扩展内存的大小你可以在这申请一块非分页内存只要设备还在就都可以用可以用它代替全局变量可选地指向一个缓冲区该缓冲区包含一个以空字符结尾的字符串用于命名设备对象该字符串必须是完整路径名一般用基本就是填代表设备是独占的代表该设备是共享的独享可以防止前面的驱动拦截后面的驱动的派遣函数处理二级指针目的是返回设备对象指针给某个设备发送请求实例创建设备名称尽量不要改为了让驱动文件同一个树结构下方便统一该名字是给零环用的三环通过这个名字是找不到该设备对象的设备对象指针用于接受创建设备当前设备所属的驱动对象设备对象的名称不知道什么类型设备对象指针微软提供的实际上就是判断是否大于等于创建设备失败删除设备对象删除设备设置交互数据的方式如果前面创建设备对象成功就设置交互数据的方式缓冲区方式读写操作系统将应用程序提供缓冲区的数据复制到内核模式下的地址中效率不高适合小规模数据直接方式读写操作系统会将用户模式下的缓冲区锁住然后操作系统将这段缓冲区在内核模式地址再次映射一遍这样用户模式的缓冲区和内核模式的缓冲区指向的是同一区域的物理内存缺点就是要单独占用物理页面适合大规模数据比较浪费物理页其他方式读写在调用创建设备后对即不设置也不设置此时就是其他方式在使用其他方式读写设备时派遣函数直接读写应用程序提供的缓冲区地址在驱动程序中直接操作应用程序的缓冲区地址是很危险的这种方法须要注意的是可能把空指针地址或者非法地址传递给驱动程序因此驱动程序使用用户模式地址前须要检查是否可读或者可写只有驱动程序与应用程序运行在相同线程上下文的情况下才能使用这种方式读写方式不一样则读写的位置不一样缓冲区方式读写直接方式读写其他方式读写和方式通信的内核缓冲区长度在和中创建与卸载符号链接就是设置一个名字让三环可以通过这个名字找到设备对象来操作他创建符号链接名称两个问号代表根目录用打开设备时用实际上就是地址要开始但是要转义所以为创建符号链接创建符号链接失败删除设备卸载符号链接特别说明设备名称的作用是给内核对象用的如果要在访问必须要有符号链接其实就是一个别名没有这个别名在不可见内核模式下符号链接是以开头的如盘就是用户模式下则是以开头的如盘就是创建设备对象并设置符号链接驱动字符串用于存放设备对象驱动设备对象创建成功创建符号链接成功创建符号链接失败驱动对象创建失败删除设备与派遣函数驱动程序与管理器通信使用的是即请求包类型当应用层通过等函数打开从设备读取数据向设备写入数据关闭设备的时候会使操作系统分别产生出等不同的其他类型的类型来源函数会产生此在操作系统处理电源信息时产生此关闭系统前会产生此生成请求查询请求关闭请求设置请求从设备得到数据传送数据到设备还有很多是我们用的最多的一种方式比较灵活可以拿到三环传过来的消息码自己设定怎么处理通过消息码确定每个都对应一个输入输出结构是一个的指针当内核层和用户层采用共享内存的结构传递数据的时候这个就代表共享的内存信息共享物理内存通过映射这个成员生效的标记为或者每个对应一个结构通过下面的函数可以获取到此对应的结构返回一个指向结构的指针该结构包含驱动程序的堆栈位置上图为方式读写如果是用方式读写应参考设置交互数据的方式注意设置不正确案例中仅传一个整形数据时候设置到导致蓝屏吃了大亏结构派遣函数派遣函数在哪里注册呢卸载函数派遣函数编号的对应的派遣函数的地址就存在的位置编号的对应的派遣函数的地址就存在的位置注册派遣函数设置卸载函数卸载函数设置派遣函数派遣函数一般都处理对应用户层派遣函数一般都处理对应用户层派遣函数派遣函数派遣函数派遣函数派遣函数一般都处理对应用户层派遣函数派遣函数派遣函数可以全都一个函数函数名在函数内做区分处理派遣函数的最大值宏派遣函数的格式为报文数据结构指针处理自己的业务设置返回状态返回状态如果不设置返回的是失败三环得到的就是这个值返回给环多少个字节的数据没有填表示调用方已完成所有请求处理操作并将给定的返回给管理器将往下派发一个派遣函数处理所有情况获取应用层传来的参数用户调用了用户调用了用户调用了返回给中的倒数第二个参数调用方已完成所有请求处理操作并且不增加优先级返回成功结构详解的派遣函数操作码用到的操作码是个复合数据微软提供了一个宏来组合这个复合数据如下定义方式该宏的定义是个宏按照函数讲解每个参数驱动种类一般是提供一个数值标识其独特性交互数据的方式要与前面设定的一致或或或权限表示全部权限或或定义实例的派遣函数编写获取应用层传来的参数获取派遣过来的操作码获取缓存地址输入输出都靠这个地址获取输入长度获取输出长度根据不同的操作码做不同的处理注意是以三环视角来看其含义三环想要读执行想做的事情表示调用方已完成所有请求处理操作并将给定的返回给管理器将往下派发详解结构详解三环写法函数结构设备句柄操作码三环给零环的数据的地址三环给零环多少字节数据零环给三环的数据到的地址零环给三环多少字节数据零环给三环实际多少字节数据异步相关一般填略内核通信需要头文件并且必须定义到的后面基本上都是用这种方式打开设备打开设备对象句柄关闭设备发送环常规通信框架卸载函数停止运行了为报文数据结构指针处理自己的业务三环连接成功设置返回状态返回状态如果不设置返回的是失败三环得到的就是这个值返回给环多少个字节的数据没有填表示调用方已完成所有请求处理操作并将给定的返回给管理器将往下派发为报文数据结构指针处理自己的业务三环断开连接成功设置返回状态返回状态如果不设置返回的是失败三环得到的就是这个值返回给环多少个字节的数据没有填表示调用方已完成所有请求处理操作并将给定的返回给管理器将往下派发获取派遣过来的操作码获取缓存地址输入输出都靠这个地址获取输入长度获取输出长度根据不同的操作码做不同的处理注意是以三环视角来看其含义初始化三环想要反初始化表示调用方已完成所有请求处理操作并将给定的返回给管理器将往下派发入口函数相当于函数设置一个卸载函数用于退出创建设备名称设备对象指针用于接受创建设备微软提供的实际上就是判断是否大于等于创建设备失败如果前面创建设备对象成功就设置交互数据的方式创建符号链接名称创建符号链接失败删除设备设置派遣函数交互数据实验代码卸载函数删除设备对象设备对象已挂载在中停止运行了为报文数据结构指针处理自己的业务三环连接成功设置返回状态返回状态如果不设置返回的是失败三环得到的就是这个值返回给环多少个字节的数据没有填表示调用方已完成所有请求处理操作并将给定的返回给管理器将往下派发为报文数据结构指针处理自己的业务三环断开连接成功设置返回状态返回状态如果不设置返回的是失败三环得到的就是这个值返回给环多少个字节的数据没有填表示调用方已完成所有请求处理操作并将给定的返回给管理器将往下派发获取派遣过来的操作码获取缓存地址输入输出都靠这个地址获取输入长度获取输出长度根据不同的操作码做不同的处理注意是以三环视角来看其含义三环想要读把传给三环读把零环写入的长度传给三环打印三环写入的信息派遣函数三环传入的信息表示调用方已完成所有请求处理操作并且不增加优先级并将给定的返回给管理器将往下派发入口函数相当于函数设置一个卸载函数用于退出创建设备名称设备对象指针用于接受创建设备微软提供的实际上就是判断是否大于等于创建设备失败如果前面创建设备对象成功就设置交互数据的方式其实此代码可以不设置因为项目未使用和来通信而是使用创建符号链接名称创建符号链接失败删除设备设置派遣函数代码打开设备打开设备对象句柄发送打开设备对象失败写数据给读数据读到写数据结果如图将写数据给代码注释放开读数据的代码结果如图驱动加载需要头文件加载驱动过程用打开服务控制管理器用创建对应服务如果驱动服务已经创建过则用打开服务用加载启动驱动服务用获得服务的当前状态用停止暂停恢复服务用卸载驱动清理工作用关闭释放句柄驱动注册安装函数如果函数成功则返回值是指定服务控制管理器数据库的句柄如果函数失败则返回值为打开服务管理器目标计算机的名称如果指针为或指向空字符串则该函数连接到本地计算机上的服务控制管理器服务控制管理器数据库的名称此参数应设置为如果为则打开活动数据库数据库权限表示所有权限还有诸如创建服务枚举服务权限等创建服务函数如果函数成功则返回值是服务的句柄如果函数失败则返回值为服务管理器句柄一般从的返回值获取这个服务在注册表中的名字名字唯一性服务唯一标识一般取的是可执行文件名不带后缀注册表驱动程序的值显示给别人看的名字名字不唯一服务的访问权限表示所有权限创建什么类型的服务表示内核驱动服务即表示加载的服务是驱动程序创建服务的启动类型开机启动服务自动启动服务按需启动即当进程调用函数时由服务控制管理器启动的服务注册表服务的错误控制如果此服务无法启动则错误的严重性以及采取的措施表示启动程序在事件日志中记录错误但继续启动操作服务对应的可执行程序的全路径如驱动服务可用函数以及可执行文件名获取后面都为就可以了服务所在分组的名字分组内该服务的启动顺序需要依赖其他服务名的列表加上下面哪个表示以什么身份启动服务函数执行后如果为则调用关闭服务句柄为某服务的句柄也可以直接调用还是会调用驱动启动打开服务函数服务管理器句柄服务名字根据这个服务名字找服务权限表示所有权限开始服务函数如果函数成功则返回值非零如果函数失败则返回值为零服务句柄服务函数的参数相关参数字节数没有填如果没有参数则此参数可以为停止驱动后控制服务函数如果函数成功则返回值非零如果函数失败则返回值为零服务句柄控制码可以停止暂停恢复服务其中表示停止服务的控制码指向结构的指针该结构接收最新的服务状态信息返回的信息反映了服务向服务控制管理器报告的最新状态仅当返回以下错误代码之一时服务控制管理器才会填充结构或否则不填充结构卸载驱动后删除服务函数如果函数成功则返回值非零如果函数失败则返回值为零服务句柄驱动加载启动停止卸载案例加载驱动封装函数是不带后缀的服务唯一标识是带后缀的驱动文件名用于保存的全路径名得到完整的驱动路径加载驱动的全路径名失败驱动在注册表中的名字注册表驱动程序的值加载驱动程序的访问权限或者表示加载的服务是驱动程序注册表驱动程序的值指定当进程调用函数时由服务控制管理器启动的服务注册表驱动程序的值注册表驱动程序的全路径如通过函数获取服务已经存在的话直接打开该服务此处可以用查询服务状态来判断是否需要开启服务可能已经开启了卸载驱动封装函数管理器的句柄驱动程序的服务句柄打开失败打开失败停止服务停止失败卸载服务卸载失败上面两个函数依赖的调试信息输出函数加上本人输出头特征编码转换加载驱动函数使用案例卸载驱动函数使用案例全局监听实验自己加载驱动写拷贝段页知识通信写写拷贝的本来流程当写一个内存的时候先判断到内存是否可写位是否为若为则表示该内存不可写进入异常在异常中通过进一步判断其到底是写拷贝还是只读如果是只读报错如果是写拷贝则映射一份新物理页将原内容复制过来直接写到新物理页上不影响原物理页因此你了一个只影响你自己的进程而无法影响别的进程是因为别的进程还是原物理页并未被你修改解决方法很简单找到要的地方将位置根本不进异常直接原物理页规避触发写拷贝下面代码针对分页并且事后未复原代码卸载函数删除设备对象设备对象已挂载在中停止运行了为报文数据结构指针处理自己的业务三环连接成功设置返回状态返回状态如果不设置返回的是失败三环得到的就是这个值返回给环多少个字节的数据没有填表示调用方已完成所有请求处理操作并将给定的返回给管理器将往下派发为报文数据结构指针处理自己的业务三环断开连接成功设置返回状态返回状态如果不设置返回的是失败三环得到的就是这个值返回给环多少个字节的数据没有填表示调用方已完成所有请求处理操作并将给定的返回给管理器将往下派发写到这里通过获取的参数获取三环跳过的返回地址获取四个参数填入全局数组中为了防止打印重复获取派遣过来的操作码获取缓存地址输入输出都靠这个地址获取输入长度获取输出长度根据不同的操作码做不同的处理注意是以三环视角来看其含义初始化填充中断门描述符地址为中断门描述符填充调用门获取三环传过来的要跳转的函数地址调用门描述符下面代码想在驱动中修改却发现是改变所在的物理页属性为判断中是否有内容获取三环传过来的函数地址地址为读取为读取为三环想要反初始化恢复原样表示调用方已完成所有请求处理操作并将给定的返回给管理器将往下派发入口函数相当于函数设置一个卸载函数用于退出创建设备名称设备对象指针用于接受创建设备微软提供的实际上就是判断是否大于等于创建设备失败如果前面创建设备对象成功就设置交互数据的方式创建符号链接名称创建符号链接失败删除设备设置派遣函数代码打开设备打开设备对象句柄发送挂物理页不这样操作的可能是无效的打开设备对象失败成功监听结果别人的代码参考重难点跟界面相关的永远都是懒加载的即没调用不加载物理页不会挂上去但是这种他自己事先就加载好了挂上了物理页与的完全一样位置的选择指令至少占用个字节绕开全局变量每次的全局变量位置是不确定因为模块加载的顺序不一致根据业务来决定在哪里过滤参数修改返回结果思考正在的瞬间如何保证多核切换的稳定性如何绕过硬编码校验检测内联注册系统回调保护进程不可用替代的官方手段回调函数位未过不能的替代方案注册系统回调最需要注意的一点就是一定要防止回调发生死循环核心函数可以为线程进程和桌面句柄操作注册回调函数返回该系统回调的句柄卸载时用得上的返回值为表示成功否则失败破解函数的使用限制驱动程序必须有数字签名才能使用此函数通过逆向找到了破解这个限制的方法经研究内核通过验证此回调是否合法但此函数只是简单的验证了一下的值是不是包含在驱动的入口函数中添加代码需要自己定义即可破解该使用限制想要使用函数成功必须在编译器的链接器命令行行中添加指定必须在加载时检查二进制映像的签名关于详细信息该函数第一个参数指向下面结构结构一般为注册回调函数的个数决定加载顺序越大的越早被执行自定义数据没有填空指向结构可见成员又指向结构体结构体针对进程还是线程还是桌面句柄针对什么行为回调前设置自定义的回调函数后设置自定义的回调函数上述函数第三个参数指向一个自定的回调函数如下自定义回调函数自己起名字注册回调时传入的自定义数据想要的操作结构打开句柄的目标对象结构体首地址对象种类指向包含操作特定信息的的指针结构包含特定于正在打开的句柄的信息的结构结构一个值它指定要为句柄授予的访问权限默认情况下此成员等于但例程可以修改此值以限制授予的访问权限一个值它指定为句柄请求的原始访问权限此结构可用于控制句柄权限注册系统回调案例解锁使用限制安装系统回调钩子代码如下安装内存保护用来存放返回的句柄以方便卸载对应功能初始化加载顺序自定义数据版本注册回调函数的个数接下来初始化针对什么行为回调行为发生之后的钩子行为发生之前的钩子这个函数是自定义的函数注册回调函数安装进程保护卸载系统回调钩子代码如下卸载进程保护卸载进程保护自定义的回调函数内核层用户层只针对指定目标进程保护获取目标进程目标获取原始赋予的权限去除某些权限去除终止进程权限去除跨进程读进程权限去除跨进程写进程权限更改要赋予的权限为我们处理过的权限补充进程有哪些权限即使是任务管理器对进程进行操作也需要获取对应进程权限才可以操作进程因此如果用回调函数拦截了目标进程相应句柄的权限则任务管理器也会无权限操作目标进程进程权限如下终止进程任务管理器中如果在详细信息中对进程右键选择终止进程就需要用到此权限创建线程跨进程读目标进程跨进程写目标进程复制目标进程的句柄创建进程设置一些进程的信息查询进程的详细信息进程挂起和恢复驱动中通过进程对象结构体首地址获取进程名下面两个均只能获取到小于字节的进程名是想获取的目标进程结构体首地址只知道可用不能针对所有操作系统在部分版本系统可能不正确可能是未导出的函数需要如下声明即可以获取当前进程名最多显示个字节获取当前进程函数在系统回调中获取目标进程进程获取进程名核心函数成对使用另一种实现方式这种方式在注册系统回调函数中使用会蓝屏打开进程获取句柄如果在注册系统回调中使用此函数就会陷入循环无限调用的情况导致堆栈溢出打开进程出错得到结构结构中取进程名和对应的函数地址实际上是同一个只是符号不同如果在注册系统回调中使用此函数就会陷入无限递归的死循环最终导致堆栈溢出蓝屏驱动中设置断点代码的方式下断点使用方式或者直接下断点模块名函数名例如远程读写绕过系统回调保护远程读写效率怎么都比不上内部读写进程挂靠的方式实现用到的核心函数进程挂靠直接修改应该也可以解除进程挂靠此处为内核申请一个过渡的内核内存来临时存放要读的数据读进程通过读取目标内存返回实际读到的字节数用到自定义的函数根据获取方式系统回调保护读内存是要读的进程结构体指针是要读的地址是要读的长度存放读到哪里不借助于内核层和三环层的常规通信方式申请内核空间在所有进程间通用实际上可以不申请空间如果是零环与三环通信的时候直接把那个通信缓冲区拿来用就可以了内核空间申请失败也可以改把进程地址空间映射到内核驱动空间中转内存地址中的内容因为后原来的进程在目标地址里不存在但如果是直接似乎内核内存实际上不需要这一步进入目标进程内存空间附加到目标进程判断目标地址是否可以访问把要读的目标进程中地址对应的内容拷到内核空间中分离目标进程空间恢复环境分离目标进程内核内存复制回原进程内存释放作为中转站的内核内存方式系统回调保护读内存是要读的进程结构体指针是要读的地址是要读的长度存放读到哪里借助于内核层和三环层的常规通信方式也可以改把进程地址空间映射到内核驱动空间进入目标进程内存空间附加到目标进程判断目标地址是否可以访问把要读的目标进程中地址对应的内容拷到内核空间中分离目标进程空间恢复环境分离目标进程内核内存复制回原进程内存写进程下面函数不能写只读内存远程写不可以写只读内存将用户传过来的内容的地址写入进程的地址内容长度为申请内核空间在所有进程间通用内核空间申请失败真正的写操作附加要写的目标进程写入内存真正的写操作通过远程写用到了自定义的函数对进程的地址写长度为的在地址的内存根据获取直接写入只读内存会蓝屏下面有写只读内存的方式方式优势对于大内存远程读取写入有速度优势上述过渡的内核内存可以使用映射方式替代用到的核心函数申请映射内存描述信息释放映射内存描述信息把内存标记为非分页内存防止数据因为内存不足而被迁移到硬盘上锁定内存映射解除内存映射锁定当不再需要描述的页的时请调用将它们解除锁定然后调用来释放它们读内存可以不借助于内核层和三环层的常规通信方式为创建内存描述创建来读取内存标记为非分页内存避免置换到硬盘上锁定映射用户内存到内核内存指向地址指向的同一个物理内存映射失败判断目标地址是否可访问此处实际上已经拷贝到想要的地址中去了写内存只需要调换此处的和清理工作释放相关资源写内存三环是通过或函数来修改页面属性来达到写只读内存的目的修改器就是采取这套方式下面是可以用于写只读内存的驱动实现方式核心点是将可以用于写只读内存将用户传过来的内容的地址写入进程的地址内容长度为进程挂靠为创建内存描述标记为非分页内存设置标志位锁定映射关系映射成功后退出挂靠环境恢复环境方式写只读内存内存类型可以被置换到硬盘中一般存储数据不能被置换到硬盘中驻留在内存中一般用来存储代码如果执行代码到的内存中很有可能蓝屏在内核空间中所有内存都是可读可写可执行的故没有类似用户态下的改变内存属性的函数但是并不意味着可以随意执行和改写内存中的代码要满足个条件关闭内存写保护通过操作寄存器实现提升级别防止执行出错使用和实现函数需要头文件关闭内存写保护和提升不提高中断等级无法写还原开启内存写保护内存操作放到二者之间就可以正常操作内存了物理内存读写内存方法物理内存读写内存速度比较慢不建议用于频繁地读写内存一般用于注入代码核心函数把物理地址映射到当前进程取消映射虚拟地址转换为物理地址映射后返回出来的虚拟地址想要映射的字节大小要映射的物理地址实际映射的字节大小完整代码最外层的读写内存接口读中的地址中长的值搭配地址中获取到的物理地址为将地址中长的值写到中的地址获取到的物理地址为获取最大物理地址函数利用取出物理地址获取最大的物理地址四个整数的数组包含在和中返回的有关支持的功能的信息只有的前位和至们有用后边个全保留获取物理地址的值函数将目标进程中的虚拟地址转为物理地址的进程对象实际上就是字节关键地方附加到指定进程把虚拟地址转换为物理地址返回物理地址失败返回物理内存读写函数读函数对于分页内存来说调用以及来锁定内存页以防止被出去对于非分页内存而言调用映射到物理内存上本身就是物理地址读取物理地址的值读到地址中读长度用于映射后的虚地址供访问要读的物理地址为最大物理地址为校验是否超过最大物理内存初始化映射物理内存需要用到的数据要访问物理内存需要用到该设备描述物理内存地址映射物理内存地址到当前进程的虚地址空间映射产生的虚拟地址要映射的物理地址映射成功的话实际映射的长度大于要写入的内容长度真正的读操作解除映射关闭节对象写函数写物理地址函数将地址的长度为的内存写到物理地址中用于映射后的虚地址供访问校验是否超过最大物理内存初始化映射物理内存需要用到的数据要访问物理内存需要用到该设备描述物理内存地址映射物理内存地址到当前进程的虚地址空间映射产生的虚拟地址要映射的物理地址映射成功的话实际映射的长度大于要写入的内容长度真正的写操作解除映射关闭节对象针对对象回调钩子的操作遍历进程线程对象钩子兼容需要用的自定义结构和变量下面开始遍历系统回调钩子需要用到的自定义结构该成员决定执行顺序越大越早被执行跟上面开头的那个一样存储下一个存储详细的数据版本号也就是本身节点注销时也使用这个注意是指针链表结构该结构指向上面的结构前回调函数后回调函数的该偏移与有差异导出的内部版本号地址遍历回调需要用到的自定义子函数包含依赖关系获取模块链表头通过函数名获取未文档化的函数地址通过地址获取对应模块的模块名上面子函数具备通用性的有文字描述获取版本和对应的硬编码函数需要用到的子函数获取未文档化的函数获取函数链表头需要用到的函数用到的子函数获取函数链表头需要用到的函数用到的子函数函数偏移向上跳转获取模块链表头地址函数需要用到的子函数为什么不使用去枚举呢主要是这玩意导出了追随步伐啊哈哈直接就导出了导出未导出相对麻烦通过某地址获得该地址所处的模块对应的模块名主要用于判断回调函数地址属于哪个模块函数需要用到的子函数获取模块链表头开始遍历模块链表遍历模块地址判断地址是处于哪个模块循环链表如果下一个指针再次指向首节点则遍历结束遍历回调函数遍历所有进程线程注册的回调回调个数计数和是导出的直接使用和需要自己计算出来获取进程链表头获取线程链表头遍历进程回调进程对象回调遍历所有进程回调前函数并且打印所属驱动名遍历线程回调线程对象回调遍历部分输出如下进程对象回调线程对象回调遍历结果中越大的越早被执行完美过掉对象保护钩子绕过回调保护思路借助于越大越早被执行的规则可以通过最早执行的回调钩子记录权限再配合最晚执行的回调钩子恢复所有权限以此对抗权限保护前面的注册系统回调做的是让其他进程都没办法以想要保护的进程为目标打开进程而此处做的是让指定进程打开进程时不会受到系统回调保护的限制所以在自定义回调函数中前者是通过来判断打开进程的目标进程后者是通过获取自身来判断是不是我们想要绕过保护的进程需要用到互斥提同步相关函数初始化快速互斥体请求使用快速互斥体要同步的代码在上下之间释放代码如下需要用到的结构这里字节对齐要采用默认不要按对齐这样才符合位和位结构体自定义的记录对象信息的链表结构需要用到的自定义子函数以及全局变量内核获得系统启动计数还原原权限自定义回调函数记录原权限的自定义回调函数导出的是一个指向进程的全局变量其他在注册系统回调时需要用到的结构体申请空间的标签链表用于记录所有被触发回调的进程或线程信息给链表加的同步手段互斥体内核获取系统启动计数返回滴答数频率下方的宏的原型是否自己目标的进程可以过保护暂时写死最后一个自定义回调函数用于恢复权限获取同步所有权原权限新权限原权限新权限恢复权限恢复权限请求恢复权限请求移出结点释放空间释放同步所有权第一个自定义回调做记录信息工作方便最后的回调恢复导出的是一个指向进程的如果是他则跳过如果是线程回调的话跳过判断打开进程是否为目标进程申请空间记录数据保存请求的权限防止被保护回调修改表示全部权限实际上就已经是全部全新了同步快速互斥体获取所有权回调的各种数据插入链表保存节点保存权限原权限保存同步快速互斥体释放所有权避免未使用参数的警告可有可无记录系统回调的句柄用于卸载和是自定义回调函数进程的线程的进程的线程的回调码回调码回调码高的低的接口函数安装系统回调的卸载系统回调的解锁使用限制添加参数初始化链表头初始化快速互斥体针对进程回调新添加的针对线程回调新添加的针对进程回调新添加的针对线程回调新添加的安装过保护后遍历系统回调如下刚开始可以读取但是过了一会儿又不能访问了很可能有遍历句柄表找谁打开了自己的句柄就释放掉句柄表遍历相关相关句柄表遍历跳出到句柄表文章句柄遍历遍历句柄句柄转获取句柄信息类型名字把目标进程的句柄复制到当前进程类似于内存映射遍历句柄微软讲解跳转中有一个函数叫用它可以将指定类型的进程信息拷贝到某个缓冲其原型如下进程句柄信息类型缓冲指针以字节为单位的缓冲大小写入缓冲的字节数函数中枚举的值之一指示要检索的系统信息的类型指向接收请求信息的缓冲区的指针此信息的大小和结构因参数的值而异参数指向的缓冲区的大小以字节为单位指向函数写入所请求信息的实际大小的位置的可选指针如果该大小小于或等于参数函数将信息复制到缓冲区中否则它会返回错误代码并在中返回接收请求的信息所需的缓冲区大小返回值返回成功或错误代码实现句柄遍历代码下面需要用到的数据结构包含在该头文件中点击跳转完整项目参考一些名词理解过过内核越狱免签加载驱动名词理解内核补丁保护详见基本可以认为和是一个意思正名相当于哨兵它的功能是不定时地巡逻检查重要的内核数据结构有没有被篡改发现篡改就立刻触发蓝屏也就是过让无法工作或工作无效方法基本分为两类动态无需重启重启后失效和静态需要重启重启后一直生效数字签名强制全名可以简单理解为驱动文件必须包含正确的交叉签名相当于守门员在驱动加载前检查数字签名是否有效无效则拒绝加载进内核过让机制无法工作或工作无效方法基本分为两类动态无需重启重启后失效和静态需要重启重启后一直生效免签加载驱动就是加载一个无签名或签名无效的驱动内核越狱可以简单理解为过过关于是的所有的包括都不被限制里对关键模块包括但不限于等以及一些关键的表包括但不限于等的任何修改都不被所允许要加载驱动需要先掉进了内核以后再看情况考虑要不要干掉不重启禁用绕过的方法不支持重启的方法在内存中修改全局变量也就是所谓的需要一个有任意内存读写执行漏洞的有合法签名的驱动先被加载进内核然后可以利用漏洞完成修改修改完就被关闭了也有带合法签名的驱动直接实现了这个功能比如这个小工具就有关闭的功能缺点修改会被不定时运行的检测到一旦被检测到就会立刻蓝屏可以在要加载驱动时先修改来禁用然后抓紧时间加载驱动加载完成后再立刻把改回去这样可以大大降低蓝屏的概率不使用正常的驱动加载途径使用自己编写的加载同样需要一个有合法签名的驱动先被加载然后利用这个驱动可能是利用也可能是驱动自己实现的功能来完成无签名驱动的加载这个方法的优点是不会触发但缺点也很明显被加载的驱动需要被特殊设计加载后不支持卸载不支持函数导入不正常限制很多过保护更多了解技术过驱动开发小技巧用于判断返回值驱动层真正完美的隐藏内存签名相关位操作系统上驱动签名不是强制要求的所以可以加载未签名的驱动但在位系统上默认情况下无法加载未签名驱动不过可以通过禁用驱动签名强制例如通过测试模式来安装未签名驱动无签名加载驱动知识点参考利用漏洞加载驱动支持目前默认的证书签名算法都是通过申请的证书可以使用工具进行双签名给应用程序或驱动签名的摘要算法就是和但签发的证书本身签名算法是可以通过所以在旧版的操作系统中会出现驱动类文件不兼容目前在旧版操作系统的内核驱动签名不支持单证书双签名普通应用程序则支持单证书双签名对于内核驱动签名如果要实现双签名例如同时在和上运行则要求使用的签名算法创建签名但是的内核驱动签名则需要使用来实现也就是说对于内核驱动的签名需要同时购买代码签名证书和标准签名证书来实现内核驱动的双签名对于普通的应用程序可以使用一张证书来双签名实现兼容性签名工具使用先添加签名规则再给文件签名签名证书原理运行中输入后启动点击开始分析完后在高级中查看日志可以验证系统所有驱动的签名情况位进制字符串操作十六进制字符串转十六进制数字上面的是类型的的位进制输出格式为表示用填充空白位置表示个字符表示位表示输出进制数设定驱动和用户层相接数据结构类似如下方式统一内存对齐最稳妥当然也可以按照位默认的字节对齐但用户层和内存层都必须是位用到的内核相关结构体大整合',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-29 14:56:58',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://th.bing.com/th/id/OIP.wtmjepfWPBvn26uz7s18dgHaHa?rs=1&amp;pid=ImgDetMain"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">ZEROKO14的个人博客</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size: 1.05rem;">C#<sup>3</sup></a><a href="/tags/C/" style="font-size: 1.05rem;">C++<sup>5</sup></a><a href="/tags/CSS/" style="font-size: 1.05rem;">CSS<sup>1</sup></a><a href="/tags/CSharp/" style="font-size: 1.05rem;">CSharp<sup>1</sup></a><a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 1.05rem;">C语言<sup>1</sup></a><a href="/tags/FPS/" style="font-size: 1.05rem;">FPS<sup>1</sup></a><a href="/tags/HTML/" style="font-size: 1.05rem;">HTML<sup>1</sup></a><a href="/tags/JavaScript/" style="font-size: 1.05rem;">JavaScript<sup>1</sup></a><a href="/tags/MFC/" style="font-size: 1.05rem;">MFC<sup>1</sup></a><a href="/tags/PE/" style="font-size: 1.05rem;">PE<sup>1</sup></a><a href="/tags/QT/" style="font-size: 1.05rem;">QT<sup>1</sup></a><a href="/tags/WPF/" style="font-size: 1.05rem;">WPF<sup>3</sup></a><a href="/tags/ai/" style="font-size: 1.05rem;">ai<sup>1</sup></a><a href="/tags/cmake/" style="font-size: 1.05rem;">cmake<sup>1</sup></a><a href="/tags/doxygen/" style="font-size: 1.05rem;">doxygen<sup>1</sup></a><a href="/tags/git/" style="font-size: 1.05rem;">git<sup>1</sup></a><a href="/tags/json/" style="font-size: 1.05rem;">json<sup>1</sup></a><a href="/tags/linux/" style="font-size: 1.05rem;">linux<sup>1</sup></a><a href="/tags/next/" style="font-size: 1.05rem;">next<sup>1</sup></a><a href="/tags/ppt/" style="font-size: 1.05rem;">ppt<sup>1</sup></a><a href="/tags/slidev/" style="font-size: 1.05rem;">slidev<sup>1</sup></a><a href="/tags/vue/" style="font-size: 1.05rem;">vue<sup>1</sup></a><a href="/tags/xml/" style="font-size: 1.05rem;">xml<sup>1</sup></a><a href="/tags/yaml/" style="font-size: 1.05rem;">yaml<sup>1</sup></a><a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 1.05rem;">代码规范<sup>1</sup></a><a href="/tags/%E5%86%85%E6%A0%B8/" style="font-size: 1.05rem;">内核<sup>2</sup></a><a href="/tags/%E5%86%85%E6%A0%B8%E7%9B%B8%E5%85%B3/" style="font-size: 1.05rem;">内核相关<sup>5</sup></a><a href="/tags/%E5%8A%A0%E8%A7%A3%E5%AF%86/" style="font-size: 1.05rem;">加解密<sup>1</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 1.05rem;">多线程<sup>1</sup></a><a href="/tags/%E5%BC%80%E5%8F%91/" style="font-size: 1.05rem;">开发<sup>4</sup></a><a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 1.05rem;">数学<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 1.05rem;">数据库<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 1.05rem;">数据结构<sup>1</sup></a><a href="/tags/%E6%9E%B6%E6%9E%84/" style="font-size: 1.05rem;">架构<sup>1</sup></a><a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 1.05rem;">正则表达式<sup>1</sup></a><a href="/tags/%E7%9B%91%E6%8E%A7/" style="font-size: 1.05rem;">监控<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 1.05rem;">算法<sup>1</sup></a><a href="/tags/%E7%AE%A1%E7%90%86/" style="font-size: 1.05rem;">管理<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 1.05rem;">网络<sup>2</sup></a><a href="/tags/%E9%80%86%E5%90%91/" style="font-size: 1.05rem;">逆向<sup>2</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/09/"><span class="card-archive-list-date">九月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">七月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">13</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/06/"><span class="card-archive-list-date">六月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/04/"><span class="card-archive-list-date">四月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">十一月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">27</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/12/"><span class="card-archive-list-date">十二月 2022</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/10/"><span class="card-archive-list-date">十月 2021</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2020/12/"><span class="card-archive-list-date">十二月 2020</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url">技术</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E5%86%85%E6%A0%B8%E7%9B%B8%E5%85%B3/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>内核相关</span></a></span></div></div><h1 class="post-title" itemprop="name headline">驱动开发</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-11-24T02:49:02.215Z" title="发表于 2023-11-24 10:49:02">2023-11-24</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-10-29T06:56:58.272Z" title="更新于 2024-10-29 14:56:58">2024-10-29</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="驱动开发"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为新加坡"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>新加坡</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://che77a38.github.io/posts/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"><header><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url">技术</a><a href="/tags/%E5%86%85%E6%A0%B8%E7%9B%B8%E5%85%B3/" tabindex="-1" itemprop="url">内核相关</a><h1 id="CrawlerTitle" itemprop="name headline">驱动开发</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">ZEROKO14</span><time itemprop="dateCreated datePublished" datetime="2023-11-24T02:49:02.215Z" title="发表于 2023-11-24 10:49:02">2023-11-24</time><time itemprop="dateCreated datePublished" datetime="2024-10-29T06:56:58.272Z" title="更新于 2024-10-29 14:56:58">2024-10-29</time></header><h1 id="驱动开发"><a href="#驱动开发" class="headerlink" title="驱动开发"></a>驱动开发</h1><p><strong>理解</strong></p>
<ul>
<li>SDK   software development kits(软件开发包)   如Visual Studio 2019(v142)</li>
<li>WDK  windows driver development kits(驱动开发包)  如WindowsKernelModeDriver10.0</li>
</ul>
<span id="more"></span>

<p>设置他们的位置在属性-配置属性-常规-平台工具集,但实际上无需手动设置,因为新建什么项目时vs都帮你自动配置好了</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/newnewman80/article/details/90754999">环境配置参考</a></p>
<p>创建<strong>Empty WDM Driver</strong>项目，生成的Driver Files文件中的<strong>inf后缀文件</strong>可以直接删除</p>
<p>在源文件中添加的必须是.c后缀的C语言文件。</p>
<p>项目配置中：</p>
<ol>
<li>属性-C&#x2F;C++中<code>将警告视为错误</code>选项设置为否</li>
<li>属性-链接器中<code>将链接器警告视为错误</code>设为否</li>
</ol>
<p>由于使用的是windowsXP作为开发环境，所以要<strong>针对windowsXP进行项目配置，参考链接</strong>：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Kwansy/article/details/111051265">开发各平台驱动的设置参考</a></p>
<p>如果建立的是KMDF项目的话,除了上述步骤,还可以将属性-Inf2Cat中<code>Run Inf2Cat</code>选项设置为否</p>
<p><strong>制作不同系统的驱动,要设置属性-Driver Settings-Target OS Version设置为对应操作系统</strong></p>
<p>属性-Driver Settings-Target Platform设置为Desktop</p>
<p><strong>驱动的开发流程：</strong></p>
<p>编写代码-&gt;生成.sys文件-&gt;部署-&gt;启动-&gt;停止-&gt;卸载</p>
<p>驱动程序的测试最好在<strong>虚拟机中</strong>测试，因为一出问题就蓝屏</p>
<p><strong>DebugView</strong>软件监视选项中要选上<strong>监视核心</strong></p>
<p>驱动开发的调试：双机调试</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//操作系统调试驱动需要打开测试模式</span></span><br><span class="line">bcdedit /<span class="built_in">set</span> nointegritychecks on<span class="comment">//关闭驱动数字证书检测</span></span><br><span class="line">bcdedit /<span class="built_in">set</span> testsigning on<span class="comment">//打开测试模式</span></span><br><span class="line">pause</span><br><span class="line">shutdown -r -t <span class="number">1000</span><span class="comment">//一秒之后重启系统</span></span><br></pre></td></tr></table></figure>

<p>无论是debug还是release版本的驱动都会带一个测试的签名,测试的签名 只在测试模式下有效.非测试模式下等于没有签名无法加载驱动.</p>
<p>虚拟机设置(防止待机过长屏幕自动关闭时虚拟机出现问题)</p>
<p>右键-显示设置-电源和随眠-屏幕定时关闭调成从不</p>
<h3 id="设置双机调试步骤"><a href="#设置双机调试步骤" class="headerlink" title="设置双机调试步骤"></a>设置双机调试步骤</h3><p>虚拟机设置中添加串行端口</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202205161418079.jpeg" alt="xvniji2"></p>
<p><strong>红色线虽然显示是串行端口2,但实际上由于当前只有一个串行端口,所以在虚拟机系统中设置的引导的调试端口应该是com1</strong></p>
<p>然后如下,到操作系统中添加调试引导项</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//操作系统打开双机调试模式</span></span><br><span class="line"><span class="comment">//操作系统添加新引导(管理员启动)</span></span><br><span class="line">bcdedit /copy &#123;current&#125; /d <span class="string">&quot;win10 x64 debug for windbg&quot;</span><span class="comment">//新建引导选项,新引导的名字随意取</span></span><br><span class="line">pause</span><br><span class="line"><span class="comment">//手动到运行(win+r)输入msconfig回车-选到新建的引导-高级选项-打开调试模式,设置调试端口为多少(可以到虚拟机中设别管理器的串行端口查看,不要受com几的名字影响,顺序是第几个就是com几)</span></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202205161420348.jpeg" alt="xvniji3"></p>
<h3 id="设置windbg连接哪个串口"><a href="#设置windbg连接哪个串口" class="headerlink" title="设置windbg连接哪个串口"></a>设置windbg连接哪个串口</h3><p>两种方式,1.图形化操作(下面主要介绍的是这种方式)    2.快捷方式设置参数 <code>-b -k com:pipe,port=\\.\pipe\管道名,resets=0,reconnect -y</code></p>
<p>windbg打开后,点击File-Kernel Debug,打开的窗口中选择COM,Port设置为虚拟机中给串行端口设置的命名管道名字,并且勾选Pipe(表示是命名管道)和Reconnect</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202205161420283.jpeg" alt="xvniji1"></p>
<h3 id="设置符号"><a href="#设置符号" class="headerlink" title="设置符号"></a>设置符号</h3><p>设置添加系统环境变量_NT_SYMBOL_PATH的值为: <code>srv*c:\symbols*http://msdl.microsoft.com/download/symbols</code></p>
<p>强制加载符号命令: <code>.reload /f</code>               使用 <code>lm</code>可以看到已加载的符号信息</p>
<h3 id="windbg调试蓝屏dump文件"><a href="#windbg调试蓝屏dump文件" class="headerlink" title="windbg调试蓝屏dump文件"></a>windbg调试蓝屏dump文件</h3><p>windbg可用于查看蓝屏的dump文件,dump文件默认位置在 <code>C:\\Windows\Minidump\</code>中</p>
<p>在windbg中选择File-Open source file打开蓝屏的dump文件</p>
<p>分析命令: <code>!analyze -v</code> (该命令可以看到蓝屏的时候的调用栈)               查看堆栈命令: <code>kv</code></p>
<p>往往是通过调用栈查看问题出在哪里</p>
<h4 id="操作系统设置dump文件生成步骤"><a href="#操作系统设置dump文件生成步骤" class="headerlink" title="操作系统设置dump文件生成步骤"></a>操作系统设置dump文件生成步骤</h4><p>此电脑右键属性-高级系统设置-启动和故障恢复处的设置按钮,在该界面做如下修改</p>
<ul>
<li>勾选 <code>将事件写入系统日志</code></li>
<li>[写入调试信息] 设置为 <code>核心内存转储</code></li>
<li>此处也可以设置转储文件的保存位置</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202205171721503.jpeg" alt="dump"></p>
<p>补充</p>
<p>p.s.修复虚拟机花屏:vmtool重新安装,选择修改,去除SVGA驱动(核显驱动),然后重新在虚拟机中安装显卡驱动.</p>
<h2 id="PDB（Program-Debug-Database）"><a href="#PDB（Program-Debug-Database）" class="headerlink" title="PDB（Program Debug Database）"></a>PDB（Program Debug Database）</h2><p>什么是PDB文件？</p>
<ol>
<li>PDB文件是在我们编译工程的时候产生的，它是和对应的模块(exe或dll)一起生成出来的。</li>
<li>每个模块编译的时候都可以生成自己的PDB文件。比如.exe&#x2F;.dll&#x2F;.sys等等。</li>
</ol>
<p>PDB文件对应上了位置和函数名。</p>
<p><strong>windbg如何找到PDB文件？</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SRV*D:\Symbols\XP*http://msdl.microsoft.com/download/symbols</span><br><span class="line">;上面可以在后面添加;继续添加本地地址，比如SRV*D:\Symbols\XP*http://msdl.microsoft.com/download/symbols；D:\Symbols</span><br><span class="line">;D:\Symbols\XP是本地路径，</span><br><span class="line">;http://msdl.microsoft.com/download/symbols是网络路径</span><br><span class="line">kd&gt;.reload</span><br><span class="line">;让windbg重新加载PDB</span><br></pre></td></tr></table></figure>

<p><strong>MSB8040错误</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error MSB8040: 此项目需要缓解了 Spectre 漏洞的库。</span><br></pre></td></tr></table></figure>

<p>在属性-常规-输出目录-宏中搜索14：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210825204301335.png" alt="image-20210825204301335"></p>
<p>确定需要的是14.29版本</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210825204450485.png" alt="image-20210825204450485"></p>
<p>Visual Studio Installer的单个组件中搜索14.29，将黄标全部勾选，点击修改。问题解决！</p>
<h2 id="第一个驱动程序"><a href="#第一个驱动程序" class="headerlink" title="第一个驱动程序"></a>第一个驱动程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span><span class="comment">//winXP驱动开发用此头文件</span></span></span><br><span class="line"><span class="comment">//#include &lt;ntifs.h&gt;//wdk开发(除了winXP的其他系统)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//卸载函数</span></span><br><span class="line">VOID <span class="title function_">DriverUnload</span><span class="params">(PDRIVER_OBJECT driver)</span></span><br><span class="line">&#123;</span><br><span class="line">	DbgPrint(<span class="string">&quot;停止运行了\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入口函数，相当于main函数</span></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT pdriver, PUNICODE_STRING pReg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//驱动程序的入口</span></span><br><span class="line">	DbgPrint(<span class="string">&quot;hello world!\n&quot;</span>);</span><br><span class="line">	DbgPrint(<span class="string">&quot;pdriver:%wZ\r\n&quot;</span>,pReg);</span><br><span class="line">	DbgPrint(<span class="string">&quot;pReg:%X\r\n&quot;</span>,pdriver);</span><br><span class="line">	<span class="comment">//设置一个卸载函数，用于退出</span></span><br><span class="line">	pdriver-&gt;DriverUnload = DriverUnload;</span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210825212547927.png" alt="image-20210825212547927"></p>
<p>windbg中可以使用dt命令查看对应数据结构的数据</p>
<p>头文件</p>
<ul>
<li><code>#include &lt;ntddk.h&gt;</code>     winXP驱动开发用此头文件</li>
<li><code>#include &lt;ntifs.h&gt;</code>     wdk开发</li>
</ul>
<h3 id="头文件Wdm-h、Ntddk-h-和-Ntifs-h-的组织结构"><a href="#头文件Wdm-h、Ntddk-h-和-Ntifs-h-的组织结构" class="headerlink" title="头文件Wdm.h、Ntddk.h 和 Ntifs.h 的组织结构"></a>头文件Wdm.h、Ntddk.h 和 Ntifs.h 的组织结构</h3><p>在 Windows Vista 版本的 WDK 之前，用于驱动程序开发的主要头文件为 Wdm.h、Ntddk.h 和 Ntifs.h，它们包含很多重复声明。</p>
<p>从 Windows Vista 版本的 WDK 开始，Wdm.h、Ntddk.h 和 Ntifs.h 将按层次结构来组织并且不包含重复信息。上层的文件将包含下层的文件。每个函数和结构声明仅出现一次。</p>
<p><strong><code>Ntifs.h</code> 包含 <code>Ntddk.h</code>，而 <code>Ntddk.h</code> 又包含 <code>Wdm.h</code>。</strong></p>
<h2 id="内核编程基础"><a href="#内核编程基础" class="headerlink" title="内核编程基础"></a>内核编程基础</h2><h3 id="内核API的使用"><a href="#内核API的使用" class="headerlink" title="内核API的使用"></a>内核API的使用</h3><ol>
<li>在应用层编程我们可以使用WINDOWS提供的各种API函数，只要导入头文件&lt;windows.h&gt;就可以了，但是在内核编程的时候，我们不能像Ring3那样直接使用。微软为内核提供了专门的API，只要在程序中包含相应的头文件就可以使用了，如：#include&lt;ntddk.h&gt;(假设你已经正确安装了WDK)</li>
<li>在应用层编程的时候，我们通过MSDN来了解函数的详细信息，在内核编程的时候，要使用WDK自己的帮助文档。</li>
</ol>
<h3 id="未导出函数的使用"><a href="#未导出函数的使用" class="headerlink" title="未导出函数的使用"></a>未导出函数的使用</h3><p>内核函数有三种</p>
<ol>
<li>有一些是文档有写，也导出了的函数</li>
<li>有一些是文档没写，但导出了的函数</li>
<li>还有一些是文档没写，也没导出的函数，通过自己特征码定位CALL的位置，手动调用</li>
</ol>
<p>WDK说明文档只包含了内核模块导出的函数，对于未导出的函数，则不能直接使用</p>
<p>如果要使用未导出的函数，只要自己定义一个函数指针，并且为函数指针提供正确的函数地址就可以使用了。有两种办法都可以获取为导出的函数地址：</p>
<ol>
<li>特征码搜索</li>
<li>解析内核PDB文件</li>
</ol>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>在内核编程的时候，强烈建议大家遵守WDK的编码习惯，不要这么写：unsigned long length；</p>
<p>习惯使用WDK自己的类型：</p>
<table>
<thead>
<tr>
<th>WDK的类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ULONG</td>
<td>unsigned long</td>
</tr>
<tr>
<td>PULONG</td>
<td>unsigned long*</td>
</tr>
<tr>
<td>UCHAR</td>
<td>unsigned char</td>
</tr>
<tr>
<td>PUCHAR</td>
<td>unsigned char*</td>
</tr>
<tr>
<td>UINT</td>
<td>unsigned int</td>
</tr>
<tr>
<td>PUNIT</td>
<td>unsigned int*</td>
</tr>
<tr>
<td>VOID</td>
<td>void</td>
</tr>
<tr>
<td>PVOID</td>
<td>void*</td>
</tr>
</tbody></table>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>大部分内核函数的返回值都是NTSTATUS类型，如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">PsCreateSystemThread</span><span class="params">()</span>;</span><br><span class="line">NTSTATUS <span class="title function_">ZwOpenProcess</span><span class="params">()</span>;</span><br><span class="line">NTSTATUS <span class="title function_">ZwOpenEvent</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>这个值能说明函数执行的结果，比如：</p>
<table>
<thead>
<tr>
<th>返回宏</th>
<th>代表数值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>STATUS_SUCCESS</td>
<td>0x00000000</td>
<td>成功</td>
</tr>
<tr>
<td>STATUS_INVALID_PARAMETER</td>
<td>0xC000000D</td>
<td>参数无效(这个错误出现往往代表出现了很多错误，因此不代表任何意义)</td>
</tr>
<tr>
<td>STATUS_BUFFER_OVERFLOW</td>
<td>0x80000005</td>
<td>缓冲区长度不够</td>
</tr>
<tr>
<td>STATUS_PENDING</td>
<td></td>
<td>不能算作一个错误，只是文件传输请求未决(异步)</td>
</tr>
<tr>
<td>STATUS_INSUFFICIENT_RESOURCES</td>
<td></td>
<td>资源调用错误</td>
</tr>
</tbody></table>
<p>当你调用的内核函数，如果返回的结果不是STATUS_SUCCESS，就说明函数执行中遇到了问题，具体是什么问题，可以在ntstatus.h文件中查看。</p>
<h3 id="内核函数中的异常处理"><a href="#内核函数中的异常处理" class="headerlink" title="内核函数中的异常处理"></a>内核函数中的异常处理</h3><p><strong>意义不大，该蓝屏还是蓝屏</strong></p>
<p>在内核中，一个小小的错误就可能导致蓝屏，比如：读写一个无效的内存地址。为了让自己的内核程序更加健壮，强烈建议大家在编写内核程序时，使用异常处。</p>
<p>Windows提供了机构化异常处理机制，一般的编译器都是支持的，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__try&#123;</span><br><span class="line">    <span class="comment">//可能出错的代码</span></span><br><span class="line">&#125;</span><br><span class="line">__except(filter_value)&#123;</span><br><span class="line">    <span class="comment">//出错时要执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>出现异常时，可根据filter_value的值来决定程序该如何执行，当filter_value的值为：</p>
<table>
<thead>
<tr>
<th>filter_value</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>EXCEPTION_EXECUTE_HANDLER(1)</td>
<td>代码进入except块</td>
</tr>
<tr>
<td>EXCEPTION_CONTINUE_SEARCH(0)</td>
<td>不处理异常，由上一层调用函数处理</td>
</tr>
<tr>
<td>EXCEPTION_CONTINUE_EXECUTION(-1)</td>
<td>回去继续执行错误处的代码(基本用不到)</td>
</tr>
</tbody></table>
<h3 id="常用的内核内存函数"><a href="#常用的内核内存函数" class="headerlink" title="常用的内核内存函数"></a>常用的内核内存函数</h3><p>对内核的使用，主要就是：申请，设置，拷贝以及释放。</p>
<table>
<thead>
<tr>
<th>C语言</th>
<th>内核中</th>
</tr>
</thead>
<tbody><tr>
<td>malloc</td>
<td>ExAllocatePool</td>
</tr>
<tr>
<td>memset(内核可用)</td>
<td>RtlFillMemory</td>
</tr>
<tr>
<td>memcpy(内核可用)(非重叠复制)</td>
<td>RtlCopyMemory(非重叠复制)</td>
</tr>
<tr>
<td>memmove(内核可用)(重叠复制)</td>
<td>RtlMoveMemory(重叠复制)</td>
</tr>
<tr>
<td>free</td>
<td>ExFreePool</td>
</tr>
</tbody></table>
<p>ExAllocatePool已被淘汰，取而代之的是<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/nf-wdm-exallocatepoolwithtag">ExAllocatePoolWithTag</a></p>
<p>后又在 Windows 10 版本 2004 中被弃用，并已被<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/nf-wdm-exallocatepool2">ExAllocatePool2</a>取代</p>
<h3 id="内核字符串种类"><a href="#内核字符串种类" class="headerlink" title="内核字符串种类"></a>内核字符串种类</h3><ul>
<li>CHAR（char）</li>
<li>WCHAR（wchar_t）</li>
<li>ANSI_STRING</li>
<li>UNICODE_STRING</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ANSI_STRING字符串：</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">STRING</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    USHORT Length;<span class="comment">//当前字符串的长度</span></span><br><span class="line">    USHORT MaximumLength;<span class="comment">//最大长度</span></span><br><span class="line">    PCHAR Buffer;<span class="comment">//指针</span></span><br><span class="line">&#125;STRING;</span><br><span class="line"></span><br><span class="line"><span class="comment">//UNICODE_STRING字符串：</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    USHORT Length;</span><br><span class="line">    USHORT MaximumLength;</span><br><span class="line">    PWCHAR Buffer;</span><br><span class="line">&#125;UNICODE_STRING;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">UNICODE_STRING abc=RTL_CONSTANT_STRING(<span class="string">L&quot;Hello World!&quot;</span>);<span class="comment">//要放在全局</span></span><br><span class="line">DbgPrint(<span class="string">&quot;%wZ&quot;</span>,&amp;abc);</span><br></pre></td></tr></table></figure>

<p>内核中字符串尽量用ANSI_STRING字符串和UNICODE_STRING字符串，通过这种方法能避免使用0结尾，读字符串的时候读Length个字符就可以了，防止访问0蓝屏。</p>
<p>内核字符串常用函数</p>
<table>
<thead>
<tr>
<th>ANSI_STRING字符串</th>
<th>UNICODE_STRING字符串</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>RtlInitAnsiString</td>
<td>RtlInitUnicodeString</td>
<td>创建字符串</td>
</tr>
<tr>
<td>RtlCopyString</td>
<td>RtlCopyUnicodeString</td>
<td>复制字符串</td>
</tr>
<tr>
<td>RtlCpmpareString</td>
<td>RtlCpmpareUnicodeString</td>
<td>比较字符串</td>
</tr>
<tr>
<td>RtlAnsiStringToUnicodeString</td>
<td>RtlUnicodeStringToAnsiString</td>
<td>字符串转换</td>
</tr>
<tr>
<td>RtlAppendStringToString</td>
<td>RtlAppendUnicodeToString&#x2F;RtlAppendUnicodeStringToString</td>
<td>字符串拼接</td>
</tr>
<tr>
<td>RtlFreeAnsiString</td>
<td>RtlFreeUnicodeString</td>
<td>销毁字符串</td>
</tr>
<tr>
<td>RtlUpperString</td>
<td>RtlUpcaseUnicodeString</td>
<td>转换成大写</td>
</tr>
<tr>
<td>RtlEqualString</td>
<td>RtlEqualUnicodeString</td>
<td>字符串是否相等</td>
</tr>
</tbody></table>
<p>DbgPrint,KdPrint打印字符串：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>格式说明符</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>%c, %lc</td>
<td>ANSI字符</td>
<td>char</td>
</tr>
<tr>
<td>%C, %wc</td>
<td>宽字符</td>
<td>wchar_t</td>
</tr>
<tr>
<td>%d, %i</td>
<td>十进制有符号整数</td>
<td>int</td>
</tr>
<tr>
<td>%D</td>
<td>十进制_int64</td>
<td>_int64</td>
</tr>
<tr>
<td>%L</td>
<td>十六进制的LARGE_INTEGER</td>
<td>LARGE_INTEGER</td>
</tr>
<tr>
<td>%s, %ls</td>
<td>NULL终止的ANSI字符串</td>
<td>char*</td>
</tr>
<tr>
<td>%S, %ws</td>
<td>NULL终止的宽字符串</td>
<td>wchar_t*</td>
</tr>
<tr>
<td>%Z</td>
<td>ANSI_STRING字符串</td>
<td></td>
</tr>
<tr>
<td>%wZ</td>
<td>UNICODE_STRING字符串</td>
<td></td>
</tr>
<tr>
<td>%u</td>
<td>十进制的ULONG</td>
<td>ULONG</td>
</tr>
<tr>
<td>%x</td>
<td>小写字符十六进制的ULONG</td>
<td>ULONG</td>
</tr>
<tr>
<td>%X</td>
<td>大写字符十六进制的ULONG</td>
<td>ULONG</td>
</tr>
<tr>
<td>%p</td>
<td>指针Pointer 32&#x2F;64位</td>
<td></td>
</tr>
</tbody></table>
<p>根据DDK上说明,Unicode格式(%C, %S, %lc, %ls, %wc, %ws, and %wZ)只能在 IRQL &#x3D; PASSIVE_LEVEL时才能使用.</p>
<h3 id="常用的其他内核API函数"><a href="#常用的其他内核API函数" class="headerlink" title="常用的其他内核API函数"></a>常用的其他内核API函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ExAcquireFastMutex</td>
<td>获取一个快速互斥体，用于多线程环境下的同步</td>
</tr>
<tr>
<td>ExReleaseFastMutex</td>
<td>快速释放一个互斥体</td>
</tr>
<tr>
<td>ExRaiseStatus</td>
<td>抛出一个异常，带有一个status值的，代码很深的地方直接报错</td>
</tr>
<tr>
<td>ZwCreateFile</td>
<td>创建文件</td>
</tr>
<tr>
<td>ZwWriteFile</td>
<td>写入文件</td>
</tr>
<tr>
<td>ZwReadFile</td>
<td>读取文件</td>
</tr>
<tr>
<td>ZwQueryDirctory</td>
<td>查询目录文件</td>
</tr>
<tr>
<td>ZwDeviceIoControlFile</td>
<td>创建设备io文件</td>
</tr>
<tr>
<td>ZwCreateKey</td>
<td>创建注册表的键</td>
</tr>
<tr>
<td>ZwQueryValueKey</td>
<td>创建注册表的键值</td>
</tr>
<tr>
<td>IoCreateFile</td>
<td>创建文件，比ZwCreateFile更加底层</td>
</tr>
<tr>
<td>IoCreateDevice</td>
<td>创建设备</td>
</tr>
<tr>
<td>IoCallDriver</td>
<td>发送一个请求，实际上这个函数可能是由IofCallDriver别名</td>
</tr>
<tr>
<td>IoCompleteRequest</td>
<td>完成请求</td>
</tr>
<tr>
<td>IoCopyCurrentIrpStackLocationToNext</td>
<td>将当前IRP请求的栈空间拷贝到下一个栈空间</td>
</tr>
<tr>
<td>IoSkipCurrentIrpStackLocationToNext</td>
<td>跳过当前IRP栈空间</td>
</tr>
<tr>
<td>IoGetCurrentIrpStackLocation</td>
<td>获得当前IRP栈空间指针</td>
</tr>
</tbody></table>
<h3 id="IRQL中断请求级别"><a href="#IRQL中断请求级别" class="headerlink" title="IRQL中断请求级别"></a>IRQL中断请求级别</h3><p>处理器在一个IRQL上执行线程代码。IRQL是帮助决定线程如何被中断的。<strong>在同一处理器上，线程只能被更高级别IRQL的线程能中断</strong>。每个处理器都有自己的中断IRQL。我们经常遇见的有四种IRQL级别。“Passive”, “APC”, “Dispatch” and “DIRQL”.</p>
<p>“DriverEntry”将会在PASSIVE_LEVEL被调用。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20211109133128464.png" alt="image-20211109133128464"></p>
<ul>
<li><p><strong>PASSIVE_LEVEL</strong>   无中断</p>
<p>IRQL最低级别,没有被屏蔽的中断，在这个级别上，线程执行用户模式，可以访问分页内存。DriverEntry、DriverUnload、DispatchRead…等分发函数都处于这个级别,我们创建的线程也是这个级别</p>
</li>
<li><p><strong>APC_LEVEL</strong>   软中断</p>
<p>在这个级别上,只有APC级别的中断被屏蔽，可以访问分页内存。当有APC发生时，处理器提升到APC级别，这样，就屏蔽掉其它APC，为了和APC执行 一些同步，驱动程序可以手动提升到这个级别。比如，如果提升到这个级别，APC就不能调用。在这个级别，APC被禁止了，导致禁止一些I&#x2F;O完成APC， 所以有一些API不能调用。</p>
<p><strong>阻止响应任何APC，而且线程不能被挂起（suspend），为什么不能被挂起？因为操作系统实现线程挂起的方式，就是递交 APC</strong></p>
</li>
<li><p><strong>DISPATCH_LEVEL</strong>  软中断</p>
<p>这个级别，DPC(延迟过程) 和更低的中断被屏蔽，不能访问分页内存，所有的被访问的内存不能分页。因为只能处理分页内存，所以在这个级别，能够访问的Api大大减少。</p>
</li>
<li><p><strong>DIRQL (Device IRQL)</strong>  硬中断</p>
<p>通常处于高层次的驱动程序不会使用这个IRQL等级，在这个等级上所有的中断都会被忽略。这是IRQL的最高等级。通常使用这个来判断设备的优先级。<br>一般的，更高级的驱动在这个级别上不处理IRQL，但是几乎所有的中断被屏蔽，这实际上是IRQL的一个范围，这是一个决定某个驱动有更高的优先级的方法。</p>
</li>
</ul>
<h3 id="驱动内核框架"><a href="#驱动内核框架" class="headerlink" title="驱动内核框架"></a>驱动内核框架</h3><h4 id="Windows的驱动开发模型变迁"><a href="#Windows的驱动开发模型变迁" class="headerlink" title="Windows的驱动开发模型变迁"></a>Windows的驱动开发模型变迁</h4><ul>
<li>vxd(windows98)</li>
<li>kdm(windows98~windows2000)</li>
<li>wdm(再之后)</li>
<li>wdf(进一步原有基础上封装了一套更简单的API，现在)</li>
</ul>
<h4 id="内核编程的主要调用源："><a href="#内核编程的主要调用源：" class="headerlink" title="内核编程的主要调用源："></a>内核编程的主要调用源：</h4><ol>
<li>入口函数 DriverEntry 和 卸载函数 DriverUnload（单线程环境）</li>
<li>各种分发函数（多线程环境，可以和DriverUnload并发，无法和DriverEntry并发）</li>
<li>处理请求时设置的完成函数（多线程环境）</li>
<li>其他回调函数  ndis（网络相关）（多线程环境）</li>
</ol>
<h4 id="函数的多线程安全性"><a href="#函数的多线程安全性" class="headerlink" title="函数的多线程安全性"></a>函数的多线程安全性</h4><ol>
<li>可能运行于多线程环境的函数，必须是多线程安全的，只运行于单线程环境的函数，则不需要多线程安全性</li>
<li>如果函数A的所有调用源只运行于同一单线程环境，则函数A也是只运行在单线程环境下。</li>
<li>如果函数A的其中一个调用源是可能运行在多线程环境下的，或者多个调用源可能运行于不同的可并发的多线程环境，而且调用路径上没有采取多线程序列化成单线程的强制措施，则函数A也是可能运行在多线程环境的。</li>
<li>如果函数A所有可能运行于多线程环境的调用路径上，都有多线程序列化成单线程的强制措施，则函数A是运行于单线程环境的。</li>
<li>只使用函数内部资源的，完全不使用全局变量，静态变量或其他全局性资源的函数是多线程安全的。</li>
<li>如果对某个全局变量或者静态变量的所有访问都被强制的同步手段限制为同一时刻只有一个线程访问，则即使使用了这些全局变量或静态变量，对函数的多线程安全性也是没有影响的。</li>
</ol>
<table>
<thead>
<tr>
<th>调用源</th>
<th>运行环境</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td>DriverEntry&#x2F;DriverUnload</td>
<td>单线程</td>
<td>这两个函数由系统集成的单一线程调用。不会出现多线程同时调用的情况</td>
</tr>
<tr>
<td>各种分发函数</td>
<td>多线程</td>
<td>没有任何文档保证分发函数是不会被多线程同时调用的。此外，分发函数是不会和DriverEntry并发，但可能和DriverUnload并发</td>
</tr>
<tr>
<td>完成函数</td>
<td>多线程</td>
<td>完成函数随时可能被未知的线程调用</td>
</tr>
<tr>
<td>各种NDIS回调函数</td>
<td>多线程</td>
<td>同上</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="代码的中断级"><a href="#代码的中断级" class="headerlink" title="代码的中断级"></a>代码的中断级</h4><p>win32编程是没有中断级这个概念的，但是在内核编程中是有中断级的概念的，我们的程序好像是并发的，但其实是有优先级的，就是中断级</p>
<ul>
<li>passive</li>
<li>dispatch</li>
</ul>
<p>规则：</p>
<ol>
<li>如果在调用路径上没有特殊情况（导致中断级的提高或降低），则一个函数执行时的中断和它的调用源的中断级相同</li>
<li>如果在调用路径上有获取自旋锁，则中断级随之升高；如果调用路径上有释放自旋锁，则中断级随之下降。</li>
</ol>
<table>
<thead>
<tr>
<th>调用源</th>
<th>一般运行中断级</th>
</tr>
</thead>
<tbody><tr>
<td>DriverUnload&#x2F;DriverEntry</td>
<td>Passive级</td>
</tr>
<tr>
<td>各种分发函数</td>
<td>Passive级</td>
</tr>
<tr>
<td>完成函数</td>
<td>Dispatch级</td>
</tr>
<tr>
<td>各种NDIS回调函数</td>
<td>Dispatch级</td>
</tr>
</tbody></table>
<h4 id="WDK中出现的特殊代码"><a href="#WDK中出现的特殊代码" class="headerlink" title="WDK中出现的特殊代码"></a>WDK中出现的特殊代码</h4><h5 id="IN和OUT"><a href="#IN和OUT" class="headerlink" title="IN和OUT"></a>IN和OUT</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IN</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OUT</span></span><br></pre></td></tr></table></figure>

<p>空定义，只是作为提示函数中参数时输入还是输出的</p>
<h5 id="pragma-alloc-text"><a href="#pragma-alloc-text" class="headerlink" title="#pragma alloc_text"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/analogous_love/article/details/47274559">#pragma alloc_text</a></h5><p>有时，驱动程序的某些部分必须驻留内存而另一些可以被分页，这就需要一种能控制代码和数据是否分页的方法。通过指导编译器的段分配可以实现这个目的。</p>
<p>#pragma alloc_text：<strong>把驱动程序的单独例程放到特定段中。</strong></p>
<p>使编译器把代码放到特定段的传统方法是使用alloc_text编译指示。但不是每种编译器都支持这个编译指示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> alloc_text(PAGE, a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> alloc_text(PAGE, b)</span></span><br><span class="line"><span class="comment">//表示函数a和b都运行在分页内存中，就是有可能被交换到分页池中，程序中一些高等级，例如dispatch 级别的代码当然不能运行在分页内存，这样往往出现BSOD</span></span><br><span class="line"><span class="comment">//如果没有上述指令，则默认位于PAGELK这个节，即不会把内存放入硬盘。</span></span><br></pre></td></tr></table></figure>

<p><strong>#pragma alloc_text使用注意</strong></p>
<ol>
<li>该编译指示必须跟在函数声明后面而不能在前面。你可以把驱动程序中的所有函数集中到一个头文件中，并在包含该头文件的源文件中，在#include语句的后面使用alloc_text。</li>
<li>该编译指示仅能用于有C连接形式的函数。即，它不能用于类成员函数或 C++源文件中未用extern “C”声明的函数。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> alloc_text(INIT,DriverEntry)<span class="comment">//某些代码在驱动程序完成初始化后不再需要，可以直接把它插入到INIT段。</span></span></span><br></pre></td></tr></table></figure>









<h2 id="内核空间与内核模块"><a href="#内核空间与内核模块" class="headerlink" title="内核空间与内核模块"></a>内核空间与内核模块</h2><h3 id="内核空间"><a href="#内核空间" class="headerlink" title="内核空间"></a>内核空间</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210826200052881.png" alt="image-20210826200041917"></p>
<p><strong>内核空间中的地址在各个进程中都是一样的。</strong></p>
<p>内核模块定义全局变量：可在不同进程中查看</p>
<p><strong>windbg进入对应进程的进程空间</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kd&gt;!process <span class="number">0</span> <span class="number">0</span><span class="comment">//罗列出来的进程信息枚举，将PROCESS后接的地址放入下面的命令</span></span><br><span class="line">kd&gt;.process <span class="title function_">XXXXXXXX</span><span class="params">(上面获取到的地址)</span></span><br><span class="line"><span class="comment">//转到了对应进程的内存空间</span></span><br></pre></td></tr></table></figure>

<h3 id="内核模块"><a href="#内核模块" class="headerlink" title="内核模块"></a>内核模块</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210826200052881.png" alt="image-20210826200052881"></p>
<ol>
<li>硬件种类繁多，不可能做一个兼容所有硬件的内核，所以，微软提供规定的接口格式，让硬件驱动人员按照规定的格式编写“驱动程序”。</li>
<li>这些驱动程序每一个都是一个模块，称为“内核模块”，都可以加载到内核中，<strong>都遵守[[PE]]结构</strong>。本质上讲，任意一个.sys文件与内核文件没有区别。</li>
</ol>
<h4 id="DRIVER-OBJECT结构体"><a href="#DRIVER-OBJECT结构体" class="headerlink" title="DRIVER_OBJECT结构体"></a>DRIVER_OBJECT结构体</h4><p>定义在wdm.h中。</p>
<p>每个内核模块都有一个对应的结构体，来描述这个模块在内核中的各种信息：位置、大小、名称等等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _DRIVER_OBJECT</span><br><span class="line">nt!_DRIVER_OBJECT</span><br><span class="line">   +<span class="number">0x000</span> Type             : Int2B<span class="comment">//类型</span></span><br><span class="line">   +<span class="number">0x002</span> Size             : Int2B<span class="comment">//大小</span></span><br><span class="line">   +<span class="number">0x004</span> DeviceObject     : Ptr32 _DEVICE_OBJECT<span class="comment">//设备对象，这里实际上是一个设备对象的链表的开始。因为DeviceObject中有相关链表信息</span></span><br><span class="line">   +<span class="number">0x008</span> Flags            : Uint4B</span><br><span class="line">   +<span class="number">0x00c</span> DriverStart      : Ptr32 Void<span class="comment">//驱动被加载到什么地方了，即内核模块的起始地址</span></span><br><span class="line">   +<span class="number">0x010</span> DriverSize       : Uint4B<span class="comment">//该驱动内核模块的大小</span></span><br><span class="line">   +<span class="number">0x014</span> DriverSection    : Ptr32 Void<span class="comment">//指向当前驱动的_LDR_DATA_TABLE_ENTRY结构体的指针</span></span><br><span class="line">   +<span class="number">0x018</span> DriverExtension  : Ptr32 _DRIVER_EXTENSION<span class="comment">//热拔插会用到的相关信息</span></span><br><span class="line">   +<span class="number">0x01c</span> DriverName       : _UNICODE_STRING<span class="comment">//驱动的名字</span></span><br><span class="line">   +<span class="number">0x024</span> HardwareDatabase : Ptr32 _UNICODE_STRING<span class="comment">//注册表</span></span><br><span class="line">   +<span class="number">0x028</span> FastIoDispatch   : Ptr32 _FAST_IO_DISPATCH<span class="comment">//某派遣函数，快速IO分发函数</span></span><br><span class="line">   +<span class="number">0x02c</span> DriverInit       : Ptr32     <span class="type">long</span> <span class="comment">//初始化派遣函数</span></span><br><span class="line">   +<span class="number">0x030</span> DriverStartIo    : Ptr32     <span class="type">void</span> <span class="comment">//某派遣函数</span></span><br><span class="line">   +<span class="number">0x034</span> DriverUnload     : Ptr32     <span class="type">void</span> <span class="comment">//驱动卸载派遣函数</span></span><br><span class="line">   +<span class="number">0x038</span> MajorFunction    : [<span class="number">28</span>] Ptr32     <span class="type">long</span> <span class="comment">//包含28个派遣函数地址</span></span><br><span class="line">       <span class="comment">//0编号的IRP对应的派遣函数的地址就存在MajorFunction[0]的位置。</span></span><br><span class="line"><span class="comment">////////////////////////////////_DRIVER_EXTENSION///////////////////////////</span></span><br><span class="line">ntdll!_DRIVER_EXTENSION<span class="comment">//热拔插驱动相关的</span></span><br><span class="line">   +<span class="number">0x000</span> DriverObject     : Ptr32 _DRIVER_OBJECT</span><br><span class="line">   +<span class="number">0x004</span> AddDevice        : Ptr32     <span class="type">long</span> </span><br><span class="line">   +<span class="number">0x008</span> Count            : Uint4B</span><br><span class="line">   +<span class="number">0x00c</span> ServiceKeyName   : _UNICODE_STRING</span><br><span class="line">   +<span class="number">0x014</span> ClientDriverExtension : Ptr32 _IO_CLIENT_EXTENSION</span><br><span class="line">   +<span class="number">0x018</span> FsFilterCallbacks : Ptr32 _FS_FILTER_CALLBACKS</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210828154104796.png" alt="image-20210828154104796"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210828154124934.png" alt="image-20210828154124934"></p>
<p>Type，Flags，MajorFunction等等，因为他们是固有特征，尽可能隐藏特征，因为内核文件已经加载到内存里了，所以即使修改了，也不影响正常运行。</p>
<h4 id="LDR-DATA-TABLE-ENTRY结构体"><a href="#LDR-DATA-TABLE-ENTRY结构体" class="headerlink" title="_LDR_DATA_TABLE_ENTRY结构体"></a>_LDR_DATA_TABLE_ENTRY结构体</h4><p>完整版定义见WRK的_KLDR_DATA_TABLE_ENTRY</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//所有内核模块的双向链表</span></span><br><span class="line">kd&gt; dt _LDR_DATA_TABLE_ENTRY</span><br><span class="line">nt!_LDR_DATA_TABLE_ENTRY</span><br><span class="line">   +<span class="number">0x000</span> InLoadOrderLinks : _LIST_ENTRY<span class="comment">//初始化顺序双向链表</span></span><br><span class="line">   +<span class="number">0x008</span> InMemoryOrderLinks : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x010</span> InInitializationOrderLinks : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x018</span> DllBase          : Ptr32 Void<span class="comment">//内核模块的起始地址</span></span><br><span class="line">   +<span class="number">0x01c</span> EntryPoint       : Ptr32 Void</span><br><span class="line">   +<span class="number">0x020</span> SizeOfImage      : Uint4B<span class="comment">//内核模块的大小</span></span><br><span class="line">   +<span class="number">0x024</span> FullDllName      : _UNICODE_STRING<span class="comment">//完整的内核模块名，实际上就是全路径</span></span><br><span class="line">   +<span class="number">0x02c</span> BaseDllName      : _UNICODE_STRING<span class="comment">//只有内核模块名，如：xxx.sys</span></span><br><span class="line">   +<span class="number">0x034</span> Flags            : Uint4B</span><br><span class="line">   +<span class="number">0x038</span> LoadCount        : Uint2B</span><br><span class="line">   +<span class="number">0x03a</span> TlsIndex         : Uint2B</span><br><span class="line">   +<span class="number">0x03c</span> HashLinks        : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x03c</span> SectionPointer   : Ptr32 Void</span><br><span class="line">   +<span class="number">0x040</span> CheckSum         : Uint4B<span class="comment">//校验和</span></span><br><span class="line">   +<span class="number">0x044</span> TimeDateStamp    : Uint4B</span><br><span class="line">   +<span class="number">0x044</span> LoadedImports    : Ptr32 Void</span><br><span class="line">   +<span class="number">0x048</span> EntryPointActivationContext : Ptr32 Void</span><br><span class="line">   +<span class="number">0x04c</span> PatchInformation : Ptr32 Void</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//wrk版符号结构</span></span><br><span class="line">     <span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KLDR_DATA_TABLE_ENTRY</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        LIST_ENTRY listEntry;</span><br><span class="line">        ULONG64 __Undefined1;</span><br><span class="line">        ULONG64 __Undefined2;</span><br><span class="line">        ULONG64 __Undefined3;</span><br><span class="line">        ULONG64 NonPagedDebugInfo;</span><br><span class="line">        ULONG64 DllBase;</span><br><span class="line">        ULONG64 EntryPoint;</span><br><span class="line">        ULONG SizeOfImage;</span><br><span class="line">        UNICODE_STRING path;</span><br><span class="line">        UNICODE_STRING name;</span><br><span class="line">        ULONG   Flags;</span><br><span class="line">        USHORT  LoadCount;</span><br><span class="line">        USHORT  __Undefined5;</span><br><span class="line">        ULONG64 __Undefined6;</span><br><span class="line">        ULONG   CheckSum;</span><br><span class="line">        ULONG   __padding1;</span><br><span class="line">        ULONG   TimeDateStamp;</span><br><span class="line">        ULONG   __padding2;</span><br><span class="line">    &#125; KLDR_DATA_TABLE_ENTRY, *PKLDR_DATA_TABLE_ENTRY;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KLDR_DATA_TABLE_ENTRY</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        LIST_ENTRY listEntry;</span><br><span class="line">        ULONG unknown1;</span><br><span class="line">        ULONG unknown2;</span><br><span class="line">        ULONG unknown3;</span><br><span class="line">        ULONG unknown4;</span><br><span class="line">        ULONG unknown5;</span><br><span class="line">        ULONG unknown6;</span><br><span class="line">        ULONG unknown7;</span><br><span class="line">        UNICODE_STRING path;</span><br><span class="line">        UNICODE_STRING name;</span><br><span class="line">        ULONG   Flags;</span><br><span class="line">    &#125; KLDR_DATA_TABLE_ENTRY, *PKLDR_DATA_TABLE_ENTRY;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通杀x32和x64版</span></span><br><span class="line"><span class="comment">//这里字节对齐要采用默认，不要按1对齐，这样才符合32位和64位结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LDR_DATA_TABLE_ENTRY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	LIST_ENTRY InLoadOrderLinks;</span><br><span class="line">	LIST_ENTRY InMemoryOrderLinks;</span><br><span class="line">	LIST_ENTRY InInitializationOrderLinks;</span><br><span class="line">	PVOID DllBase;</span><br><span class="line">	PVOID EntryPoint;</span><br><span class="line">	ULONG SizeOfImage;</span><br><span class="line">	UNICODE_STRING FullDllName;</span><br><span class="line">	UNICODE_STRING BaseDllName;</span><br><span class="line">	ULONG Flags;</span><br><span class="line">	USHORT LoadCount;</span><br><span class="line">	USHORT TlsIndex;</span><br><span class="line">	<span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		LIST_ENTRY HashLinks;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">		&#123;</span></span><br><span class="line">			PVOID SectionPointer;</span><br><span class="line">			ULONG CheckSum;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">		&#123;</span></span><br><span class="line">			ULONG TimeDateStamp;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">		&#123;</span></span><br><span class="line">			PVOID LoadedImports;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">ACTIVATION_CONTEXT</span> * <span class="title">EntryPointActivationContext</span>;</span></span><br><span class="line">	PVOID PatchInformation;</span><br><span class="line">&#125; LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210828154334924.png" alt="image-20210828154334924"></p>
<p>_DRIVER_OBJECT结构可以通过DriverSection找到记录所有内核模块简单信息的双向链表，但双向链表没法找回_DRIVER_OBJECT结构。因此即使是在双向链表中将目标驱动断链了，对于pchunter也依然能找到内核对象，原因是因为pchunter是通过特征码直接索引到_DRIVER_OBJECT结构来遍历所有内核模块，而非通过该双向链表</p>
<h3 id="遍历内核模块并断链作业"><a href="#遍历内核模块并断链作业" class="headerlink" title="遍历内核模块并断链作业"></a>遍历内核模块并断链作业</h3><p><strong>驱动对象遍历，模块隐藏（断链）</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> OldDriverSection= <span class="number">0</span>;<span class="comment">//保存原DriverSection</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//卸载函数</span></span><br><span class="line">VOID <span class="title function_">DriverUnload</span><span class="params">(PDRIVER_OBJECT driver)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//恢复原链和原DriverSection</span></span><br><span class="line">	<span class="keyword">if</span> (OldDriverSection != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//恢复原DriverSection</span></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> DriverSectionAddr = (<span class="type">unsigned</span> <span class="type">int</span>)driver + <span class="number">0x014</span>;</span><br><span class="line">		*(<span class="type">unsigned</span> <span class="type">int</span>*)DriverSectionAddr = OldDriverSection;</span><br><span class="line">		<span class="comment">//恢复原链</span></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> currentIndex = *(<span class="type">unsigned</span> <span class="type">int</span>*)DriverSectionAddr;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> lastIndex = *(<span class="type">unsigned</span> <span class="type">int</span>*)(currentIndex + <span class="number">0x4</span>);</span><br><span class="line">		*(<span class="type">unsigned</span> <span class="type">int</span>*)lastIndex = currentIndex;</span><br><span class="line">		*(<span class="type">unsigned</span> <span class="type">int</span>*)(*(<span class="type">unsigned</span> <span class="type">int</span>*)(currentIndex)+<span class="number">0x4</span>) = currentIndex;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	DbgPrint(<span class="string">&quot;停止运行了\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内核对象链表遍历</span></span><br><span class="line">VOID <span class="title function_">forEachDriverChain</span><span class="params">(PDRIVER_OBJECT pdriver)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> DriverSection = (<span class="type">unsigned</span> <span class="type">int</span>)pdriver + <span class="number">0x014</span>;</span><br><span class="line">	<span class="comment">//DbgPrint(&quot;DriverSection:%X\n&quot;, DriverSection);</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> beginIndex = *(<span class="type">unsigned</span> <span class="type">int</span>*)DriverSection;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> currentIndex = beginIndex;</span><br><span class="line">	DbgPrint(<span class="string">&quot;----------------------------------------\r\n&quot;</span>);</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		PUNICODE_STRING BaseDllName = (PUNICODE_STRING)(currentIndex + <span class="number">0x02c</span>);</span><br><span class="line">		DbgPrint(<span class="string">&quot;%wZ\r\n&quot;</span>, BaseDllName);</span><br><span class="line">		currentIndex=*(<span class="type">unsigned</span> <span class="type">int</span>*)currentIndex;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">while</span> (currentIndex != beginIndex);</span><br><span class="line">	DbgPrint(<span class="string">&quot;----------------------------------------\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//内核对象链表断链</span></span><br><span class="line">VOID <span class="title function_">BreakDriverChain</span><span class="params">(PDRIVER_OBJECT pdriver)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> DriverSectionAddr = (<span class="type">unsigned</span> <span class="type">int</span>)pdriver + <span class="number">0x014</span>;</span><br><span class="line">	<span class="comment">//DbgPrint(&quot;DriverSection:%X\n&quot;, DriverSection);</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> currentIndex = *(<span class="type">unsigned</span> <span class="type">int</span>*)DriverSectionAddr;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> lastIndex = *(<span class="type">unsigned</span> <span class="type">int</span>*)(currentIndex +<span class="number">0x4</span>);</span><br><span class="line">	*(<span class="type">unsigned</span> <span class="type">int</span>*)lastIndex = *(<span class="type">unsigned</span> <span class="type">int</span>*)(currentIndex);</span><br><span class="line">	*(<span class="type">unsigned</span> <span class="type">int</span>*)(*(<span class="type">unsigned</span> <span class="type">int</span>*)(currentIndex)+<span class="number">0x4</span>) = lastIndex;</span><br><span class="line">	<span class="comment">//修正原PDRIVER_OBJECT中的DriverSection指向前一个链表</span></span><br><span class="line">	OldDriverSection = *(<span class="type">unsigned</span> <span class="type">int</span>*)DriverSectionAddr;</span><br><span class="line">	*(<span class="type">unsigned</span> <span class="type">int</span>*)DriverSectionAddr = lastIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入口函数，相当于main函数</span></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT pdriver, PUNICODE_STRING pReg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//驱动程序的入口</span></span><br><span class="line">	DbgPrint(<span class="string">&quot;hello world!\n&quot;</span>);</span><br><span class="line">	DbgPrint(<span class="string">&quot;pdriver:%wZ\r\n&quot;</span>,pReg);</span><br><span class="line">	DbgPrint(<span class="string">&quot;pReg:%p\r\n&quot;</span>,pdriver);</span><br><span class="line">	DbgPrint(<span class="string">&quot;hello world!\n&quot;</span>);</span><br><span class="line">	DbgPrint(<span class="string">&quot;===============断链前==============\n&quot;</span>);</span><br><span class="line">	forEachDriverChain(pdriver);</span><br><span class="line">	BreakDriverChain(pdriver);</span><br><span class="line">	DbgPrint(<span class="string">&quot;===============断链后==============\n&quot;</span>);</span><br><span class="line">	forEachDriverChain(pdriver);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置一个卸载函数，用于退出</span></span><br><span class="line">	pdriver-&gt;DriverUnload = DriverUnload;</span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br></pre></td><td class="code"><pre><span class="line">hello world!</span><br><span class="line">pdriver:\REGISTRY\MACHINE\SYSTEM\ControlSet002\Services\HelloWorld</span><br><span class="line">pReg:<span class="number">81</span>DDCD18</span><br><span class="line">hello world!</span><br><span class="line">===============断链前==============</span><br><span class="line">----------------------------------------</span><br><span class="line">HelloWorld.sys</span><br><span class="line">(null)</span><br><span class="line">ntoskrnl.exe</span><br><span class="line">hal.dll</span><br><span class="line">kdcom.dll</span><br><span class="line">BOOTVID.dll</span><br><span class="line">ACPI.sys</span><br><span class="line">WMILIB.SYS</span><br><span class="line">pci.sys</span><br><span class="line">isapnp.sys</span><br><span class="line">compbatt.sys</span><br><span class="line">BATTC.SYS</span><br><span class="line">intelide.sys</span><br><span class="line">PCIIDEX.SYS</span><br><span class="line">MountMgr.sys</span><br><span class="line">ftdisk.sys</span><br><span class="line">dmload.sys</span><br><span class="line">dmio.sys</span><br><span class="line">PartMgr.sys</span><br><span class="line">vmci.sys</span><br><span class="line">VolSnap.sys</span><br><span class="line">vsock.sys</span><br><span class="line">atapi.sys</span><br><span class="line">disk.sys</span><br><span class="line">CLASSPNP.SYS</span><br><span class="line">fltMgr.sys</span><br><span class="line">sr.sys</span><br><span class="line">KSecDD.sys</span><br><span class="line">Ntfs.sys</span><br><span class="line">NDIS.sys</span><br><span class="line">Mup.sys</span><br><span class="line">agp440.sys</span><br><span class="line">i8042prt.sys</span><br><span class="line">kbdclass.sys</span><br><span class="line">vmmouse.sys</span><br><span class="line">mouclass.sys</span><br><span class="line">serial.sys</span><br><span class="line">serenum.sys</span><br><span class="line">imapi.sys</span><br><span class="line">cdrom.sys</span><br><span class="line">redbook.sys</span><br><span class="line">ks.sys</span><br><span class="line">vmx_svga.sys</span><br><span class="line">VIDEOPRT.SYS</span><br><span class="line">usbuhci.sys</span><br><span class="line">USBPORT.SYS</span><br><span class="line">vmxnet.sys</span><br><span class="line">es1371mp.sys</span><br><span class="line">portcls.sys</span><br><span class="line">drmk.sys</span><br><span class="line">usbehci.sys</span><br><span class="line">CmBatt.sys</span><br><span class="line">intelppm.sys</span><br><span class="line">fsvga.sys</span><br><span class="line">audstub.sys</span><br><span class="line">rasl2tp.sys</span><br><span class="line">ndistapi.sys</span><br><span class="line">ndiswan.sys</span><br><span class="line">raspppoe.sys</span><br><span class="line">raspptp.sys</span><br><span class="line">TDI.SYS</span><br><span class="line">psched.sys</span><br><span class="line">msgpc.sys</span><br><span class="line">ptilink.sys</span><br><span class="line">raspti.sys</span><br><span class="line">rdpdr.sys</span><br><span class="line">termdd.sys</span><br><span class="line">swenum.sys</span><br><span class="line">update.sys</span><br><span class="line">mssmbios.sys</span><br><span class="line">NDProxy.SYS</span><br><span class="line">usbhub.sys</span><br><span class="line">USBD.SYS</span><br><span class="line">gameenum.sys</span><br><span class="line">Fs_Rec.SYS</span><br><span class="line">Null.SYS</span><br><span class="line">Beep.SYS</span><br><span class="line">vga.sys</span><br><span class="line">mnmdd.SYS</span><br><span class="line">RDPCDD.sys</span><br><span class="line">Msfs.SYS</span><br><span class="line">Npfs.SYS</span><br><span class="line">rasacd.sys</span><br><span class="line">ipsec.sys</span><br><span class="line">tcpip.sys</span><br><span class="line">netbt.sys</span><br><span class="line">ws2ifsl.sys</span><br><span class="line">afd.sys</span><br><span class="line">netbios.sys</span><br><span class="line">vmhgfs.sys</span><br><span class="line">rdbss.sys</span><br><span class="line">mrxsmb.sys</span><br><span class="line">Fips.SYS</span><br><span class="line">ipnat.sys</span><br><span class="line">Cdfs.SYS</span><br><span class="line">wanarp.sys</span><br><span class="line">usbccgp.sys</span><br><span class="line">hidusb.sys</span><br><span class="line">HIDCLASS.SYS</span><br><span class="line">HIDPARSE.SYS</span><br><span class="line">BTHUSB.sys</span><br><span class="line">bthport.sys</span><br><span class="line">mouhid.sys</span><br><span class="line">vmusbmouse.sys</span><br><span class="line">dump_atapi.sys</span><br><span class="line">dump_WMILIB.SYS</span><br><span class="line">win32k.sys</span><br><span class="line">Dxapi.sys</span><br><span class="line">watchdog.sys</span><br><span class="line">dxg.sys</span><br><span class="line">dxgthk.sys</span><br><span class="line">vmx_fb.dll</span><br><span class="line">rfcomm.sys</span><br><span class="line">BthEnum.sys</span><br><span class="line">bthpan.sys</span><br><span class="line">ndisuio.sys</span><br><span class="line">wdmaud.sys</span><br><span class="line">sysaudio.sys</span><br><span class="line">mrxdav.sys</span><br><span class="line">vmmemctl.sys</span><br><span class="line">srv.sys</span><br><span class="line">HTTP.sys</span><br><span class="line">Dbgv.sys</span><br><span class="line">----------------------------------------</span><br><span class="line">===============断链后==============</span><br><span class="line">----------------------------------------</span><br><span class="line">Dbgv.sys</span><br><span class="line">(null)</span><br><span class="line">ntoskrnl.exe</span><br><span class="line">hal.dll</span><br><span class="line">kdcom.dll</span><br><span class="line">BOOTVID.dll</span><br><span class="line">ACPI.sys</span><br><span class="line">WMILIB.SYS</span><br><span class="line">pci.sys</span><br><span class="line">isapnp.sys</span><br><span class="line">compbatt.sys</span><br><span class="line">BATTC.SYS</span><br><span class="line">intelide.sys</span><br><span class="line">PCIIDEX.SYS</span><br><span class="line">MountMgr.sys</span><br><span class="line">ftdisk.sys</span><br><span class="line">dmload.sys</span><br><span class="line">dmio.sys</span><br><span class="line">PartMgr.sys</span><br><span class="line">vmci.sys</span><br><span class="line">VolSnap.sys</span><br><span class="line">vsock.sys</span><br><span class="line">atapi.sys</span><br><span class="line">disk.sys</span><br><span class="line">CLASSPNP.SYS</span><br><span class="line">fltMgr.sys</span><br><span class="line">sr.sys</span><br><span class="line">KSecDD.sys</span><br><span class="line">Ntfs.sys</span><br><span class="line">NDIS.sys</span><br><span class="line">Mup.sys</span><br><span class="line">agp440.sys</span><br><span class="line">i8042prt.sys</span><br><span class="line">kbdclass.sys</span><br><span class="line">vmmouse.sys</span><br><span class="line">mouclass.sys</span><br><span class="line">serial.sys</span><br><span class="line">serenum.sys</span><br><span class="line">imapi.sys</span><br><span class="line">cdrom.sys</span><br><span class="line">redbook.sys</span><br><span class="line">ks.sys</span><br><span class="line">vmx_svga.sys</span><br><span class="line">VIDEOPRT.SYS</span><br><span class="line">usbuhci.sys</span><br><span class="line">USBPORT.SYS</span><br><span class="line">vmxnet.sys</span><br><span class="line">es1371mp.sys</span><br><span class="line">portcls.sys</span><br><span class="line">drmk.sys</span><br><span class="line">usbehci.sys</span><br><span class="line">CmBatt.sys</span><br><span class="line">intelppm.sys</span><br><span class="line">fsvga.sys</span><br><span class="line">audstub.sys</span><br><span class="line">rasl2tp.sys</span><br><span class="line">ndistapi.sys</span><br><span class="line">ndiswan.sys</span><br><span class="line">raspppoe.sys</span><br><span class="line">raspptp.sys</span><br><span class="line">TDI.SYS</span><br><span class="line">psched.sys</span><br><span class="line">msgpc.sys</span><br><span class="line">ptilink.sys</span><br><span class="line">raspti.sys</span><br><span class="line">rdpdr.sys</span><br><span class="line">termdd.sys</span><br><span class="line">swenum.sys</span><br><span class="line">update.sys</span><br><span class="line">mssmbios.sys</span><br><span class="line">NDProxy.SYS</span><br><span class="line">usbhub.sys</span><br><span class="line">USBD.SYS</span><br><span class="line">gameenum.sys</span><br><span class="line">Fs_Rec.SYS</span><br><span class="line">Null.SYS</span><br><span class="line">Beep.SYS</span><br><span class="line">vga.sys</span><br><span class="line">mnmdd.SYS</span><br><span class="line">RDPCDD.sys</span><br><span class="line">Msfs.SYS</span><br><span class="line">Npfs.SYS</span><br><span class="line">rasacd.sys</span><br><span class="line">ipsec.sys</span><br><span class="line">tcpip.sys</span><br><span class="line">netbt.sys</span><br><span class="line">ws2ifsl.sys</span><br><span class="line">afd.sys</span><br><span class="line">netbios.sys</span><br><span class="line">vmhgfs.sys</span><br><span class="line">rdbss.sys</span><br><span class="line">mrxsmb.sys</span><br><span class="line">Fips.SYS</span><br><span class="line">ipnat.sys</span><br><span class="line">Cdfs.SYS</span><br><span class="line">wanarp.sys</span><br><span class="line">usbccgp.sys</span><br><span class="line">hidusb.sys</span><br><span class="line">HIDCLASS.SYS</span><br><span class="line">HIDPARSE.SYS</span><br><span class="line">BTHUSB.sys</span><br><span class="line">bthport.sys</span><br><span class="line">mouhid.sys</span><br><span class="line">vmusbmouse.sys</span><br><span class="line">dump_atapi.sys</span><br><span class="line">dump_WMILIB.SYS</span><br><span class="line">win32k.sys</span><br><span class="line">Dxapi.sys</span><br><span class="line">watchdog.sys</span><br><span class="line">dxg.sys</span><br><span class="line">dxgthk.sys</span><br><span class="line">vmx_fb.dll</span><br><span class="line">rfcomm.sys</span><br><span class="line">BthEnum.sys</span><br><span class="line">bthpan.sys</span><br><span class="line">ndisuio.sys</span><br><span class="line">wdmaud.sys</span><br><span class="line">sysaudio.sys</span><br><span class="line">mrxdav.sys</span><br><span class="line">vmmemctl.sys</span><br><span class="line">srv.sys</span><br><span class="line">HTTP.sys</span><br><span class="line">----------------------------------------</span><br><span class="line">停止运行了</span><br></pre></td></tr></table></figure>

<p>由上面打印可知HelloWorld.sys成功被隐藏，但pchunter依然可以查找到我们的驱动</p>
<p>驱动模块断链会导致PG,蓝屏</p>
<p><strong>驱动隐藏特征码抹除（pchunter无法找到）</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LDR_DATA_TABLE_ENTRY</span> &#123;</span></span><br><span class="line">	LIST_ENTRY InLoadOrderLinks;</span><br><span class="line">	LIST_ENTRY InMemoryOrderLinks;</span><br><span class="line">	LIST_ENTRY InInitializationOrderLinks;</span><br><span class="line">	PVOID DllBase;</span><br><span class="line">	PVOID EntryPoint;</span><br><span class="line">	ULONG SizeOfImage;</span><br><span class="line">	UNICODE_STRING FullDllName;</span><br><span class="line">	UNICODE_STRING BaseDllName;</span><br><span class="line">	ULONG Flags;</span><br><span class="line">	USHORT LoadCount;</span><br><span class="line">	USHORT TlsIndex;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		LIST_ENTRY HashLinks;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			PVOID SectionPointer;</span><br><span class="line">			ULONG CheckSum;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			ULONG TimeDateStamp;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			PVOID LoadedImports;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">ACTIVATION_CONTEXT</span> * <span class="title">EntryPointActivationContext</span>;</span></span><br><span class="line"></span><br><span class="line">	PVOID PatchInformation;</span><br><span class="line"></span><br><span class="line">&#125; LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;</span><br><span class="line"></span><br><span class="line">HANDLE hThread;</span><br><span class="line"></span><br><span class="line">VOID <span class="title function_">DriverUnload</span><span class="params">(PDRIVER_OBJECT pDriver)</span></span><br><span class="line">&#123;</span><br><span class="line">	KdPrint((<span class="string">&quot;卸载的了&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VOID <span class="title function_">threadRun</span><span class="params">(_In_ PVOID StartContext)</span></span><br><span class="line">&#123;</span><br><span class="line">	KdPrint((<span class="string">&quot;开始执行1\n&quot;</span>));</span><br><span class="line">	LARGE_INTEGER times;</span><br><span class="line">	times.QuadPart = <span class="number">-30</span> * <span class="number">1000</span> * <span class="number">1000</span>;</span><br><span class="line">	KeDelayExecutionThread(KernelMode, FALSE, &amp;times);</span><br><span class="line">	PDRIVER_OBJECT pDriver = (PDRIVER_OBJECT)StartContext;</span><br><span class="line">	<span class="comment">//抹除特征</span></span><br><span class="line">    pDriver-&gt;DriverSize = <span class="number">0</span>;</span><br><span class="line">	pDriver-&gt;DriverSection = <span class="literal">NULL</span>;</span><br><span class="line">	pDriver-&gt;DriverExtension = <span class="literal">NULL</span>;</span><br><span class="line">	pDriver-&gt;DriverStart = <span class="literal">NULL</span>;</span><br><span class="line">	pDriver-&gt;DriverInit = <span class="literal">NULL</span>;</span><br><span class="line">	pDriver-&gt;FastIoDispatch = <span class="literal">NULL</span>;</span><br><span class="line">	pDriver-&gt;DriverStartIo = <span class="literal">NULL</span>;</span><br><span class="line">	ZwClose(hThread);</span><br><span class="line">	KdPrint((<span class="string">&quot;执行结束1\n&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT pDriver, PUNICODE_STRING pReg)</span></span><br><span class="line">&#123;</span><br><span class="line">	KdPrint((<span class="string">&quot;驱动被加载\n&quot;</span>));</span><br><span class="line">	PLDR_DATA_TABLE_ENTRY pList = (PLDR_DATA_TABLE_ENTRY)pDriver-&gt;DriverSection;</span><br><span class="line">	PLDR_DATA_TABLE_ENTRY pCur = pList;</span><br><span class="line">	pList = pList-&gt;InLoadOrderLinks.Flink;</span><br><span class="line"></span><br><span class="line">	pList-&gt;InLoadOrderLinks.Blink = pCur-&gt;InLoadOrderLinks.Blink;</span><br><span class="line">	pCur-&gt;InLoadOrderLinks.Flink = pList;</span><br><span class="line"></span><br><span class="line">	pDriver-&gt;DriverUnload = DriverUnload;</span><br><span class="line"></span><br><span class="line">	PsCreateSystemThread(&amp;hThread, GENERIC_ALL, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, threadRun, pDriver);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码可让pchunter也找不到驱动，但此代码只做了抹特征隐藏，却并未恢复特征或手动调用函数卸载驱动。停止驱动的时候会因为信息缺失直接蓝屏。需要一个时间点做恢复特征（不可以在DriverUnload中，因为是还没到该函数就蓝屏了）。</p>
<p>64位下<strong>不能直接断链(PG的原因)</strong></p>
<h4 id="避免断链蓝屏MiProcessLoaderEntry"><a href="#避免断链蓝屏MiProcessLoaderEntry" class="headerlink" title="避免断链蓝屏MiProcessLoaderEntry"></a>避免断链蓝屏MiProcessLoaderEntry</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhuhuibeishadiao/article/details/75658816">MiProcessLoaderEntry函数讲解跳转</a>，第一个参数是当前链表，第二个参数false表示卸载，true表示插入。该函数模块从链表上移除了，但没有释放内存。</p>
<p>64位用这个函数不会触发PG，不会蓝屏。PG可以理解成就是保护全局变量不被直接修改。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lyshark_csdn/article/details/127499849">MiProcessLoaderEntry方式断链代码参考跳转</a></p>
<p><strong>KdPrint和DbgPrint的区别：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> DBG</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> KdPrint(_x_) DbgPrint _x_</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> KdPrint(_x_)<span class="comment">//把KdPrint(_x_)宏替换成什么也没有</span></span></span><br><span class="line"><span class="comment">//即如下两句在debug模式下含义相同:</span></span><br><span class="line">KdPrint((<span class="string">&quot;hello World!\n&quot;</span>));</span><br><span class="line">DbgPrint(<span class="string">&quot;hello World!\n&quot;</span>);</span><br><span class="line"><span class="comment">//但在release模式下，KdPrint不会打印。</span></span><br></pre></td></tr></table></figure>

<h3 id="驱动键鼠过滤"><a href="#驱动键鼠过滤" class="headerlink" title="驱动键鼠过滤"></a>驱动键鼠过滤</h3><p>IoAttachDevice绑定设备</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">IoAttachDevice</span><span class="params">(</span></span><br><span class="line"><span class="params">IN PDEVICE_OBJECT SourceDevice,<span class="comment">//生成的设备对象</span></span></span><br><span class="line"><span class="params">IN PUNICODE_STRING TargetDevice,<span class="comment">//目标串口设备名称</span></span></span><br><span class="line"><span class="params">OUT PDEVICE_OBJECT *AttachedDevice<span class="comment">//【返回被绑定设备指针】的指针</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UNICODE_STRING com_name = RLT_CONSTANT_STRING(<span class="string">L&quot;\\Device\\Serial0&quot;</span>);</span><br><span class="line">NTSTATUS status = IoAttachDevice(com_filter_device,&amp;com_device_name,&amp;attached_device);</span><br></pre></td></tr></table></figure>

<h2 id="驱动开发中的链表"><a href="#驱动开发中的链表" class="headerlink" title="驱动开发中的链表"></a>驱动开发中的链表</h2><p><strong>常用函数</strong></p>
<ul>
<li>IsListEmpty          判断链表是否为空  </li>
<li>InitializeListHead  初始化双向链表头  </li>
<li>InsertHeadList      插入链表头部   </li>
<li>InsertTailList         插入链表尾部   </li>
<li>RemoveHeadList  移除头部节点   </li>
<li>RemoveTailList     移除尾部节点  </li>
<li>RemoveEntryList  移除当前节点</li>
</ul>
<p>链表在驱动中需要处理同步,因为链表涉及到指针操作,一不小心就可能导致蓝屏.</p>
<p>因此驱动开发中数组可以不需要同步处理(多线程写入同一个位置一样可能有问题,但概率没那么大),但链表必须做<a href="#%E5%AE%8C%E7%BE%8E%E8%BF%87%E6%8E%89%E5%AF%B9%E8%B1%A1%E4%BF%9D%E6%8A%A4%E9%92%A9%E5%AD%90">同步处理</a></p>
<h2 id="零环与三环通信-常规方式"><a href="#零环与三环通信-常规方式" class="headerlink" title="零环与三环通信(常规方式)"></a>零环与三环通信(常规方式)</h2><p>常规方式表示微软提供的正常通信方式，还有非常规通信。正常通信方式受到一定限制。</p>
<p><strong>设备对象</strong></p>
<p>我们在开发窗口程序的时候，消息被封装成一个结构体：MSG，<strong>在内核开发时，消息被封装成另外一个结构体：IRP</strong>（I&#x2F;O Request Package输入输出请求包）</p>
<p>在窗口程序中，能够接受消息的只能是窗口对象。在内核中，能够接收IRP消息的只能是设备对象</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210827111116147.png" alt="image-20210827111116147"></p>
<ul>
<li><strong>驱动对象</strong>（DRIVER_OBJECT）生成多个设备对象，</li>
<li><strong>设备对象</strong>（DEVICE_OBJECT）可以是硬件（硬盘等），也可以是软件，比如NTFS文件系统。它们都属于设备对象。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210829163134914.png" alt="image-20210829163134914"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/sdsad.jpeg" alt="sdsad"></p>
<h3 id="创建设备对象"><a href="#创建设备对象" class="headerlink" title="创建设备对象"></a><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/nf-wdm-iocreatedevice">创建设备对象</a></h3><h4 id="设备对象结构"><a href="#设备对象结构" class="headerlink" title="设备对象结构"></a>设备对象结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title function_">DECLSPEC_ALIGN</span><span class="params">(MEMORY_ALLOCATION_ALIGNMENT)</span> _DEVICE_OBJECT</span><br><span class="line">&#123;</span><br><span class="line">    CSHORT Type;<span class="comment">//类型</span></span><br><span class="line">    USHORT Size;<span class="comment">//大小</span></span><br><span class="line">    LONG ReferenceCount;<span class="comment">//引用计数</span></span><br><span class="line">    <span class="comment">/*指向驱动程序中驱动对象的指针*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">DRIVER_OBJECT</span> *<span class="title">DriverObject</span>;</span><span class="comment">//设备所属的驱动对象</span></span><br><span class="line">    <span class="comment">/*指向下一个设备对象的指针*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">DEVICE_OBJECT</span> *<span class="title">NextDevice</span>;</span><span class="comment">//下一个设备对象，在一个驱动对象中有N个设备，这些设备用这个指针连接起来作为一个单向的链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">DEVICE_OBJECT</span> *<span class="title">AttachedDevice</span>;</span></span><br><span class="line">    <span class="comment">/*当前IRP结构*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IRP</span> *<span class="title">CurrentIrp</span>;</span></span><br><span class="line">    PIO_TIMER Timer;</span><br><span class="line">    <span class="comment">/*设备对象的特性标志*/</span></span><br><span class="line">    ULONG Flags;</span><br><span class="line">    ULONG Characteristics;</span><br><span class="line">    _volatile PVPB Vpb;</span><br><span class="line">    <span class="comment">/*指向设备扩展对象的指针*/</span></span><br><span class="line">    PVOID DeviceExtension;</span><br><span class="line">    <span class="comment">/*指明设备类型*/</span></span><br><span class="line">    DEVICE_TYPE DeviceType;</span><br><span class="line">    <span class="comment">/*堆栈的最小层数*/</span></span><br><span class="line">    CCHAR StackSize;<span class="comment">//IRP栈的大小,用于存放参数的</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        LIST_ENTRY ListEntry;</span><br><span class="line">        WAIT_CONTEXT_BLOCK Wcb;</span><br><span class="line">    &#125; Queue;</span><br><span class="line">    <span class="comment">/*内存对齐*/</span></span><br><span class="line">    ULONG AlignmentRequirement;</span><br><span class="line">    KDEVICE_QUEUE DeviceQueue;</span><br><span class="line">    KDPC Dpc;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *下列成员用于支持文件系统的互斥操作</span></span><br><span class="line"><span class="comment">    *以便对文件系统处理线程使用设备的计数保持跟踪</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    ULONG ActiveThreadCount;</span><br><span class="line">    PSECURITY_DESCRIPTOR SecurityDescriptor;</span><br><span class="line">    KEVENT DeviceLock;</span><br><span class="line"> </span><br><span class="line">    USHORT SectorSize;</span><br><span class="line">    USHORT Spare1;</span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">DEVOBJ_EXTENSION</span>  *<span class="title">DeviceObjectExtension</span>;</span></span><br><span class="line">    PVOID  Reserved;</span><br><span class="line"> </span><br><span class="line">&#125; DEVICE_OBJECT;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DEVICE_OBJECT</span> *<span class="title">PDEVICE_OBJECT</span>;</span></span><br></pre></td></tr></table></figure>

<h4 id="IoCreateDevice"><a href="#IoCreateDevice" class="headerlink" title="IoCreateDevice"></a>IoCreateDevice</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">IoCreateDevice</span><span class="params">(</span></span><br><span class="line"><span class="params">  PDRIVER_OBJECT  DriverObject,<span class="comment">//驱动对象指针</span></span></span><br><span class="line"><span class="params">  ULONG           DeviceExtensionSize,<span class="comment">//指定要为设备对象的设备扩展分配的驱动程序确定的字节数；设备扩展内存的大小，你可以在这申请一块非分页内存，只要设备还在，就都可以用，可以用它代替全局变量。</span></span></span><br><span class="line"><span class="params">  PUNICODE_STRING DeviceName,<span class="comment">//可选地指向一个缓冲区，该缓冲区包含一个以空字符结尾的 Unicode 字符串，用于命名设备对象。该字符串必须是完整路径名。</span></span></span><br><span class="line"><span class="params">  DEVICE_TYPE     DeviceType,<span class="comment">//一般用FILE_DEVICE_UNKNOWN，#define FILE_DEVICE_UNKNOWN             0x00000022</span></span></span><br><span class="line"><span class="params">  ULONG           DeviceCharacteristics,<span class="comment">//基本就是填FILE_DEVICE_SECURE_OPEN</span></span></span><br><span class="line"><span class="params">  BOOLEAN         Exclusive,<span class="comment">//TRUE代表设备是独占的，FALSE代表该设备是共享的；独享可以防止前面的驱动拦截后面的驱动的派遣函数处理</span></span></span><br><span class="line"><span class="params">  PDEVICE_OBJECT  *DeviceObject<span class="comment">//【out】二级指针，目的是返回设备对象指针</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给某个设备发送IRP请求</span></span><br><span class="line">NTSTATUS <span class="title function_">MyDispath</span><span class="params">(PDEVICE_OBJECT device,PIRP irp)</span>;</span><br></pre></td></tr></table></figure>

<p>实例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建设备名称</span></span><br><span class="line">UNICODE_STRING Devicename;</span><br><span class="line">RtlInitUnicodeString(&amp;Devicename,<span class="string">L&quot;\\Device\\MyDevice&quot;</span>);<span class="comment">//\\Device尽量不要改，为了让驱动文件同一个树结构下，方便统一。该名字是给零环用的，三环通过这个名字是找不到该设备对象的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设备对象指针，用于接受</span></span><br><span class="line">PDEVICE_OBJECT pDeviceObj = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//创建设备</span></span><br><span class="line">status = IoCreateDevice(</span><br><span class="line">pDriver,				<span class="comment">//当前设备所属的驱动对象</span></span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">&amp;Devicename,			<span class="comment">//设备对象的名称</span></span><br><span class="line">FILE_DEVICE_UNKNOWN,<span class="comment">//不知道什么类型</span></span><br><span class="line">FILE_DEVICE_SECURE_OPEN,</span><br><span class="line">TRUE,</span><br><span class="line">&amp;pDeviceObj			<span class="comment">//【out】设备对象指针</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">if</span>(!NT_SUCCESS(status))<span class="comment">//NT_SUCCESS,微软提供的，实际上就是判断status是否大于等于0</span></span><br><span class="line">&#123;</span><br><span class="line">    DbgPrint(<span class="string">&quot;创建设备失败!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除设备对象"><a href="#删除设备对象" class="headerlink" title="删除设备对象"></a>删除设备对象</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IoDeleteDevice(pDeviceObj);<span class="comment">//删除设备</span></span><br></pre></td></tr></table></figure>

<h3 id="设置交互数据的方式"><a href="#设置交互数据的方式" class="headerlink" title="设置交互数据的方式"></a>设置交互数据的方式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果前面创建设备对象成功，就设置交互数据的方式</span></span><br><span class="line">pDeviceObj-&gt;Flags |= DO_BUFFERED_IO;</span><br></pre></td></tr></table></figure>

<ul>
<li>**缓冲区方式读写(DO_BUFFERED_IO)**：操作系统将应用程序提供缓冲区的数据复制到内核模式下的地址中。(效率不高，适合小规模数据)</li>
<li>**直接方式读写(DO_DIRECT_IO)**：操作系统会将用户模式下的缓冲区锁住。然后操作系统将这段缓冲区在内核模式地址再次映射一遍。这样，用户模式的缓冲区和内核模式的缓冲区指向的是同一区域的物理内存。缺点就是要单独占用物理页面。(适合大规模数据，比较浪费物理页)</li>
<li><strong>其他方式读写</strong>(在调用IoCreateDevice创建设备后对pDevObj-&gt;Flags即不设置DO_BUFFERED_IO，也不设置DO_DIRECT_IO，此时就是其他方式)：在使用其他方式读写设备时，派遣函数直接读写应用程序提供的缓冲区地址。在驱动程序中，直接操作应用程序的缓冲区地址是很危险的**(这种方法须要注意的是ReadFile可能把空指针地址或者非法地址传递给驱动程序，因此驱动程序使用用户模式地址前须要检查是否可读或者可写)<strong>。</strong>只有驱动程序与应用程序运行在相同线程上下文的情况下，才能使用这种方式**。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读写方式不一样,则读写的位置不一样</span></span><br><span class="line"><span class="keyword">if</span>(DeviceObject-&gt;Flags&amp;DO_BUFFERED_IO)<span class="comment">//缓冲区方式读写</span></span><br><span class="line">	&#123;</span><br><span class="line">		KdPrint((<span class="string">&quot;Flags:DO_BUFFER_IO\n&quot;</span>));</span><br><span class="line">		pBuffer=Irp-&gt;AssociatedIrp.SystemBuffer;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(DeviceObject-&gt;Flags&amp;DO_DIRECT_IO)<span class="comment">//直接方式读写</span></span><br><span class="line">	&#123;</span><br><span class="line">		KdPrint((<span class="string">&quot;Flags:DO_DIRECT_IO\n&quot;</span>));</span><br><span class="line">		pBuffer=MmGetSystemAddressForMdl(Irp-&gt;MdlAddress);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span><span class="comment">//其他方式读写</span></span><br><span class="line">	&#123;</span><br><span class="line">		KdPrint((<span class="string">&quot;Flags:Neither\n&quot;</span>));</span><br><span class="line">		pBuffer=Irp-&gt;UserBuffer;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//ReadFile和WriteFile方式通信的内核缓冲区长度在IrpStack-&gt;Parameters.Read.Length和IrpStack-&gt;Parameters.Write.Length中</span></span><br></pre></td></tr></table></figure>

<h3 id="创建与卸载符号链接"><a href="#创建与卸载符号链接" class="headerlink" title="创建与卸载符号链接"></a>创建与卸载符号链接</h3><p>就是设置一个名字，让三环可以通过这个名字找到设备对象来操作他。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建符号链接名称</span></span><br><span class="line">UNICODE_STRING SymbolicLinkName;</span><br><span class="line">RtlInitUnicodeString(&amp;SymbolicLinkName,<span class="string">L&quot;\\??\\MyTestDriver&quot;</span>);</span><br><span class="line"><span class="comment">//两个问号代表根目录</span></span><br><span class="line"><span class="comment">//Ring3用CreateFile打开设备时，用&quot;\\\\.\\MyTestDriver&quot;(实际上就是地址要\\.\开始，但是要转义，所以为\\\\.\\)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建符号链接</span></span><br><span class="line">status = IoCreateSymbolicLink(&amp;SymbolicLinkName,&amp;Devicename);</span><br><span class="line"><span class="keyword">if</span>(status!=STATUS_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">    DbgPrint(<span class="string">&quot;创建符号链接失败!\n&quot;</span>);</span><br><span class="line">    IoDeleteDevice(pDeviceObj);<span class="comment">//删除设备</span></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//卸载符号链接</span></span><br><span class="line">IoDeleteSymbolicLink(&amp;SymbolicLinkName);</span><br></pre></td></tr></table></figure>

<p>特别说明：</p>
<ol>
<li>设备名称的作用是给内核对象用的，如果要在Ring3访问，必须要有符号链接，其实就是一个别名，没有这个别名，在Ring3不可见</li>
<li><strong>内核模式下，符号链接是以”??&quot;开头的，如C盘就是”??\C:”</strong></li>
<li><strong>用户模式下，则是以”\\.\&quot;开头的，如C盘就是”\\.\C:”</strong></li>
</ol>
<p>创建设备对象并设置符号链接</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _LINK_NAME <span class="string">L&quot;\\??\\MyDriver&quot;</span></span></span><br><span class="line">NTSTATUS <span class="title function_">CreateDevice</span><span class="params">(PDRIVER_OBJECT driver)</span></span><br><span class="line">&#123;</span><br><span class="line">    NTSTATUS status;</span><br><span class="line">    UNICODE_STRING MyDriver;<span class="comment">//驱动字符串</span></span><br><span class="line">    PDEVICE_OBJECT device = <span class="literal">NULL</span>;<span class="comment">//用于存放设备对象</span></span><br><span class="line">    RtlInitUnicodeString(&amp;MyDriver, <span class="string">L&quot;\\DEVICE\\MyDriver&quot;</span>);</span><br><span class="line">    status = IoCreateDevice(driver,</span><br><span class="line">        <span class="keyword">sizeof</span>(driver-&gt;DriverExtension),</span><br><span class="line">        &amp;MyDriver,</span><br><span class="line">        FILE_DEVICE_UNKNOWN,</span><br><span class="line">        FILE_DEVICE_SECURE_OPEN,</span><br><span class="line">        FALSE,</span><br><span class="line">        &amp;device</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (status==STATUS_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        KdPrint((<span class="string">&quot;zeroko14:kernel:驱动设备对象创建成功\n&quot;</span>));</span><br><span class="line">        UNICODE_STRING uzSymbolName;</span><br><span class="line">        RtlInitUnicodeString(&amp;uzSymbolName, _LINK_NAME);</span><br><span class="line">        status = IoCreateSymbolicLink(&amp;uzSymbolName, &amp;MyDriver);</span><br><span class="line">        <span class="keyword">if</span> (status == STATUS_SUCCESS)</span><br><span class="line">        &#123;</span><br><span class="line">            KdPrint((<span class="string">&quot;zeroko14:kernel:创建符号链接%wZ成功\n&quot;</span>, &amp;uzSymbolName));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            KdPrint((<span class="string">&quot;zeroko14:kernel:创建符号链接%wZ失败  status:%X\n&quot;</span>, &amp;uzSymbolName,status));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        KdPrint((<span class="string">&quot;zeroko14:kernel:驱动对象创建失败,删除设备\n&quot;</span>));</span><br><span class="line">        IoDeleteDevice(device);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="IRP与派遣函数"><a href="#IRP与派遣函数" class="headerlink" title="IRP与派遣函数"></a>IRP与派遣函数</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210827114410752.png" alt="image-20210827114410752"></p>
<p>驱动程序与I&#x2F;O管理器通信，使用的是IRP，即<strong>I&#x2F;O请求包</strong>。</p>
<h4 id="IRP类型"><a href="#IRP类型" class="headerlink" title="IRP类型"></a>IRP类型</h4><ol>
<li><p>当应用层通过CreateFile，ReadFile，WriteFile，CloseHandle等函数打开，从设备读取数据，向设备写入数据，关闭设备的时候，会使操作系统分别产生出IRP_MJ_CREATE,IRP_MJ_READ,IRP_MJ_WRITE,IRP_MJ_CLOSE等不同的IRP。</p>
</li>
<li><p>其他类型的IRP</p>
<table>
<thead>
<tr>
<th>IRP类型</th>
<th>来源</th>
</tr>
</thead>
<tbody><tr>
<td><strong>IRP_MJ_DEVICE_CONTROL</strong></td>
<td>DeviceIoControl函数会产生此IRP</td>
</tr>
<tr>
<td>IRP_MJ_POWER</td>
<td>在操作系统处理电源信息时，产生此IRP</td>
</tr>
<tr>
<td>IRP_MJ_SHUTDOWN</td>
<td>关闭系统前会产生此IRP</td>
</tr>
<tr>
<td>IRP_MJ_CREATE</td>
<td>生成请求 CreateFile</td>
</tr>
<tr>
<td>IRP_MJ_QUERY_INFORMATION</td>
<td>查询请求</td>
</tr>
<tr>
<td>IRP_MJ_CLOSE</td>
<td>关闭请求 CloseHandle</td>
</tr>
<tr>
<td>IRP_MJ_SET_INFORMATION</td>
<td>设置请求</td>
</tr>
<tr>
<td>IRP_MJ_READ</td>
<td>从设备得到数据 ReadFile</td>
</tr>
<tr>
<td>IRP_MJ_WRITE</td>
<td>传送数据到设备 WriteFile</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/irp-major-function-codes">还有很多。。。</a></td>
<td>。。。</td>
</tr>
</tbody></table>
<p>IRP_MJ_DEVICE_CONTROL是我们用的最多的一种方式，比较灵活。可以拿到三环传过来的消息码，自己设定怎么处理(通过消息码确定)。</p>
</li>
<li><p>每个IRP都对应一个输入输出</p>
</li>
</ol>
<h5 id="IRP结构"><a href="#IRP结构" class="headerlink" title="IRP结构"></a>IRP结构</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IRP</span> &#123;</span></span><br><span class="line">	PMDL              MdlAddress;<span class="comment">//是一个MDL的指针，当内核层和用户层采用共享内存的结构传递数据的时候，这个MDL就代表共享的内存信息（共享物理内存，通过MDL映射）。这个成员生效的标记为：DO_DIRECT_IO, METHOD_IN_DIRECT 或者METHOD_OUT_DIRECT.</span></span><br><span class="line">	ULONG             Flags;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> _<span class="title">IRP</span>*   <span class="title">MasterIrp</span>;</span></span><br><span class="line">		PVOID          SystemBuffer;</span><br><span class="line">	&#125; AssociatedIrp;</span><br><span class="line">	IO_STATUS_BLOCK   IoStatus;</span><br><span class="line">	KPROCESSOR_MODE   RequestorMode;</span><br><span class="line">	BOOLEAN           PendingReturned;</span><br><span class="line">	BOOLEAN           Cancel;</span><br><span class="line">	KIRQL             CancelIrql;</span><br><span class="line">	PDRIVER_CANCEL    CancelRoutine;</span><br><span class="line">	PVOID             UserBuffer;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">				KDEVICE_QUEUE_ENTRY DeviceQueueEntry;</span><br><span class="line">				<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">					PVOID    DriverContext[<span class="number">4</span>];</span><br><span class="line">				&#125;;</span><br><span class="line">			&#125;;</span><br><span class="line">			PETHREAD     Thread;</span><br><span class="line">			LIST_ENTRY   ListEntry;</span><br><span class="line">		&#125; Overlay;</span><br><span class="line">	&#125; Tail;</span><br><span class="line">&#125; IRP, *PIRP;</span><br><span class="line"></span><br><span class="line">kd&gt; dt nt!_IRP</span><br><span class="line">   +<span class="number">0x000</span> Type             : Int2B</span><br><span class="line">   +<span class="number">0x002</span> Size             : Uint2B</span><br><span class="line">   +<span class="number">0x004</span> MdlAddress       : Ptr32 _MDL</span><br><span class="line">   +<span class="number">0x008</span> Flags            : Uint4B</span><br><span class="line">   +<span class="number">0x00c</span> AssociatedIrp    : &lt;unnamed-tag&gt;</span><br><span class="line">   +<span class="number">0x010</span> ThreadListEntry  : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x018</span> IoStatus         : _IO_STATUS_BLOCK</span><br><span class="line">   +<span class="number">0x020</span> RequestorMode    : Char</span><br><span class="line">   +<span class="number">0x021</span> PendingReturned  : UChar</span><br><span class="line">   +<span class="number">0x022</span> StackCount       : Char</span><br><span class="line">   +<span class="number">0x023</span> CurrentLocation  : Char</span><br><span class="line">   +<span class="number">0x024</span> Cancel           : UChar</span><br><span class="line">   +<span class="number">0x025</span> CancelIrql       : UChar</span><br><span class="line">   +<span class="number">0x026</span> ApcEnvironment   : Char</span><br><span class="line">   +<span class="number">0x027</span> AllocationFlags  : UChar</span><br><span class="line">   +<span class="number">0x028</span> UserIosb         : Ptr32 _IO_STATUS_BLOCK</span><br><span class="line">   +<span class="number">0x02c</span> UserEvent        : Ptr32 _KEVENT</span><br><span class="line">   +<span class="number">0x030</span> Overlay          : &lt;unnamed-tag&gt;</span><br><span class="line">   +<span class="number">0x038</span> CancelRoutine    : Ptr32     <span class="type">void</span> </span><br><span class="line">   +<span class="number">0x03c</span> UserBuffer       : Ptr32 Void</span><br><span class="line">   +<span class="number">0x040</span> Tail             : &lt;unnamed-tag&gt;</span><br></pre></td></tr></table></figure>

<p>每个IRP对应一个<code>IO_STACK_LOCATION结构</code>,通过下面的函数可以获取到此IRP对应的<code>IO_STACK_LOCATION结构</code></p>
<p><code>IoGetCurrentIrpStackLocation</code>返回一个指向IO_STACK_LOCATION结构的指针，该结构包含驱动程序的 I&#x2F;O 堆栈位置</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202204241910209.jpeg" alt="IRP"></p>
<p><strong>上图为DeviceIoControl方式读写</strong>,如果是用ReadFile&#x2F;WriteFile方式读写,应参考<a href="#%E8%AE%BE%E7%BD%AE%E4%BA%A4%E4%BA%92%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E5%BC%8F">设置交互数据的方式</a></p>
<p>注意information设置不正确.案例中,仅传一个整形数据时候,设置到99,导致蓝屏(吃了大亏)</p>
<h5 id="IO-STACK-LOCATION结构"><a href="#IO-STACK-LOCATION结构" class="headerlink" title="IO_STACK_LOCATION结构"></a>IO_STACK_LOCATION结构</h5><h4 id="派遣函数"><a href="#派遣函数" class="headerlink" title="派遣函数"></a>派遣函数</h4><h5 id="派遣函数在哪里注册呢？"><a href="#派遣函数在哪里注册呢？" class="headerlink" title="派遣函数在哪里注册呢？"></a>派遣函数在哪里注册呢？</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _DRIVER_OBJECT</span><br><span class="line">nt!_DRIVER_OBJECT</span><br><span class="line">   +<span class="number">0x000</span> Type             : Int2B</span><br><span class="line">   +<span class="number">0x002</span> Size             : Int2B</span><br><span class="line">   +<span class="number">0x004</span> DeviceObject     : Ptr32 _DEVICE_OBJECT</span><br><span class="line">   +<span class="number">0x008</span> Flags            : Uint4B</span><br><span class="line">   +<span class="number">0x00c</span> DriverStart      : Ptr32 Void</span><br><span class="line">   +<span class="number">0x010</span> DriverSize       : Uint4B</span><br><span class="line">....</span><br><span class="line">   +<span class="number">0x030</span> DriverStartIo    : Ptr32     <span class="type">void</span> </span><br><span class="line">   +<span class="number">0x034</span> DriverUnload     : Ptr32     <span class="type">void</span> 		<span class="comment">//卸载函数</span></span><br><span class="line">   +<span class="number">0x038</span> MajorFunction    : [<span class="number">28</span>] Ptr32     <span class="type">long</span> 	<span class="comment">//派遣函数</span></span><br><span class="line">   <span class="comment">//0编号的IRP对应的派遣函数的地址就存在MajorFunction[0]的位置。</span></span><br></pre></td></tr></table></figure>

<p>0编号的IRP对应的派遣函数的地址就存在MajorFunction[0]的位置。</p>
<h5 id="注册派遣函数"><a href="#注册派遣函数" class="headerlink" title="注册派遣函数"></a>注册派遣函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT pDriverObject, PUNICODE_STRING pReg)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">//设置卸载函数   </span></span><br><span class="line">    pDriverObject-&gt;DriverUnload = 卸载函数;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//设置派遣函数   </span></span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_CREATE] 	= 派遣函数<span class="number">1</span>; <span class="comment">//一般都处理 对应用户层CreateFile</span></span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_CLOSE] 	= 派遣函数<span class="number">2</span>;  <span class="comment">//一般都处理  对应用户层CloseHandle</span></span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_WRITE] 	= 派遣函数<span class="number">3</span>;  </span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_READ] 	= 派遣函数<span class="number">4</span>;  </span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_CLEANUP] 	= 派遣函数<span class="number">5</span>;  </span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_SET_INFORMATION] 	= 派遣函数<span class="number">6</span>;  </span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] 	= 派遣函数<span class="number">7</span>;  <span class="comment">//一般都处理   对应用户层DeviceIoControl</span></span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_SHUTDOWN] 		= 派遣函数<span class="number">8</span>;  </span><br><span class="line">    pDriverObject-&gt;MajorFunction[IRP_MJ_SYSTEM_CONTROL] 	= 派遣函数<span class="number">9</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//派遣函数1~9可以全都一个函数  NTSTATUS 函数名(PDEVICE_OBJECT pDevObj, PIRP pIrp) ,在函数内做区分处理</span></span><br></pre></td></tr></table></figure>

<p>IRP_MJ_MAXIMUM_FUNCTION  派遣函数的最大值宏</p>
<h4 id="派遣函数的格式"><a href="#派遣函数的格式" class="headerlink" title="派遣函数的格式"></a>派遣函数的格式</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">MyDispatchFunction</span><span class="params">(PDEVICE_OBJECT pDevObj, PIRP pIrp)</span><span class="comment">//PIRP为IRP报文数据结构指针</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//处理自己的业务...</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置返回状态,返回状态如果不设置，Ring3返回的是失败</span></span><br><span class="line">	pIrp-&gt;IoStatus.Status = STATUS_SUCCESS;	<span class="comment">//  三环getlasterror()得到的就是这个值</span></span><br><span class="line">	pIrp-&gt;IoStatus.Information = <span class="number">0</span>;		<span class="comment">//  返回给3环多少个字节的数据 没有填0</span></span><br><span class="line">	IoCompleteRequest(pIrp, IO_NO_INCREMENT);<span class="comment">//表示调用方已完成所有I/O请求处理操作，并将给定的 IRP 返回给 I/O 管理器。将IRP往下派发</span></span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//一个派遣函数处理所有情况:</span></span><br><span class="line">NTSTATUS <span class="title function_">DeviceIrpCtl</span><span class="params">(PDEVICE_OBJECT pDevObj, PIRP pIrp)</span></span><br><span class="line">&#123;</span><br><span class="line">  PIO_STACK_LOCATION irpStackL;</span><br><span class="line">  ULONG CtlCode;</span><br><span class="line">  ULONG InputBuffLength;</span><br><span class="line">  irpStackL=IoGetCurrentIrpStackLocation(pIrp);<span class="comment">//获取应用层传来的参数</span></span><br><span class="line">  <span class="keyword">switch</span>(irpStackL-&gt;MajorFunction)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> IRP_MJ_DEVICE_CONTROL:</span><br><span class="line">      DbgPrint(<span class="string">&quot;用户调用了DeviceIoControl!\n&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> IRP_MJ_CREATE:</span><br><span class="line">      DbgPrint(<span class="string">&quot;用户调用了CreateFile!\n&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> IRP_MJ_CLOSE;</span><br><span class="line">      DbgPrint(<span class="string">&quot;用户调用了CloseHandle!\n&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  pIrp-&gt;IoStatus.Status = STATUS_SUCCESS;</span><br><span class="line">  pIrp-&gt;IoStatus.Information = <span class="number">4</span>;<span class="comment">//返回给DeviceIoControl中的倒数第二个参数lpButesReturned</span></span><br><span class="line">  IoCompleteRequest(pIrp,IO_NO_INCREMENT);<span class="comment">//调用方已完成所有I/O请求处理操作,并且不增加优先级</span></span><br><span class="line">  <span class="keyword">return</span> STATUS_SUCCESS;<span class="comment">//返回成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ns-wdm-_irp">IRP结构详解</a></p>
<h5 id="IRP-MJ-DEVICE-CONTROL的派遣函数"><a href="#IRP-MJ-DEVICE-CONTROL的派遣函数" class="headerlink" title="IRP_MJ_DEVICE_CONTROL的派遣函数"></a><strong>IRP_MJ_DEVICE_CONTROL的派遣函数</strong></h5><h6 id="CTL操作码"><a href="#CTL操作码" class="headerlink" title="CTL操作码"></a>CTL操作码</h6><p>IRP_MJ_DEVICE_CONTROL用到的操作码是个复合数据，微软提供了一个<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/d4drvif/nf-d4drvif-ctl_code">宏CTL_CODE</a>来组合这个复合数据，如下定义方式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该宏的定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CTL_CODE( DeviceType, Function, Method, Access ) (                 \</span></span><br><span class="line"><span class="meta">    ((DeviceType) &lt;&lt; 16) | ((Access) &lt;&lt; 14) | ((Function) &lt;&lt; 2) | (Method) \</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="comment">//是个宏，按照函数讲解每个参数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CTL_CODE</span><span class="params">(</span></span><br><span class="line"><span class="params">   DeviceType,<span class="comment">//驱动种类，一般是FILE_DEVICE_UNKNOWN</span></span></span><br><span class="line"><span class="params">   Function,<span class="comment">//提供一个数值，标识其独特性</span></span></span><br><span class="line"><span class="params">   Method,<span class="comment">//交互数据的方式(要与前面设定的一致)，METHOD_BUFFERED或METHOD_IN_DIRECT或METHOD_OUT_DIRECT或METHOD_NEITHER</span></span></span><br><span class="line"><span class="params">   Access<span class="comment">//权限，FILE_ANY_ACCESS表示全部权限，或FILE_READ_ACCESS或FILE_WRITE_ACCESS</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"><span class="comment">//定义实例：</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CODE_READ CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,METHOD_BUFFERED,FILE_ANY_ACCESS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CODE_WRITE CTL_CODE(FILE_DEVICE_UNKNOWN,0x900,METHOD_BUFFERED,FILE_ANY_ACCESS)</span></span><br></pre></td></tr></table></figure>

<h6 id="IRP-MJ-DEVICE-CONTROL的派遣函数编写"><a href="#IRP-MJ-DEVICE-CONTROL的派遣函数编写" class="headerlink" title="IRP_MJ_DEVICE_CONTROL的派遣函数编写"></a>IRP_MJ_DEVICE_CONTROL的派遣函数编写</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">ControlCallBack</span><span class="params">(PDEVICE_OBJECT pDevObj, PIRP pIrp)</span></span><br><span class="line">&#123;</span><br><span class="line">    PIO_STACK_LOCATION psl = IoGetCurrentIrpStackLocation(pIrp);<span class="comment">//获取应用层传来的参数</span></span><br><span class="line">    ULONG code = psl-&gt;Parameters.DeviceIoControl.IoControlCode;<span class="comment">//获取派遣过来的CTL操作码</span></span><br><span class="line">    PVOID systemBuf = pIrp-&gt;AssociatedIrp.SystemBuffer;<span class="comment">//获取缓存地址(输入输出都靠这个地址)</span></span><br><span class="line">    ULONG inLen = psl-&gt;Parameters.DeviceIoControl.InputBufferLength;<span class="comment">//获取输入长度</span></span><br><span class="line">    ULONG outLen = psl-&gt;Parameters.DeviceIoControl.OutputBufferLength;<span class="comment">//获取输出长度</span></span><br><span class="line">    <span class="comment">//根据不同的CTL操作码做不同的处理</span></span><br><span class="line">    <span class="keyword">switch</span>(code)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> CODE_READ:<span class="comment">//注意是以三环视角来看其含义，三环想要读</span></span><br><span class="line">            <span class="comment">//执行想做的事情</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> CODE_WRITE:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    IoCompleteRequest(pIrp, IO_NO_INCREMENT);<span class="comment">//表示调用方已完成所有I/O请求处理操作，并将给定的 IRP 返回给 I/O 管理器。将IRP往下派发</span></span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-iogetcurrentirpstacklocation">IoGetCurrentIrpStackLocation详解</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ns-wdm-_io_stack_location">PIO_STACK_LOCATION结构详解</a></li>
</ul>
<h6 id="三环写法"><a href="#三环写法" class="headerlink" title="三环写法"></a>三环写法</h6><p><strong><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a>函数结构</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">DeviceIoControl</span><span class="params">(</span></span><br><span class="line"><span class="params">  HANDLE       hDevice,<span class="comment">//设备句柄</span></span></span><br><span class="line"><span class="params">  DWORD        dwIoControlCode,<span class="comment">//CTL操作码</span></span></span><br><span class="line"><span class="params">  LPVOID       lpInBuffer,<span class="comment">//三环给零环的数据的地址</span></span></span><br><span class="line"><span class="params">  DWORD        nInBufferSize,<span class="comment">//三环给零环多少字节数据</span></span></span><br><span class="line"><span class="params">  LPVOID       lpOutBuffer,<span class="comment">//零环给三环的数据到的地址</span></span></span><br><span class="line"><span class="params">  DWORD        nOutBufferSize,<span class="comment">//零环给三环多少字节数据</span></span></span><br><span class="line"><span class="params">  LPDWORD      lpBytesReturned,<span class="comment">//零环给三环实际多少字节数据</span></span></span><br><span class="line"><span class="params">  LPOVERLAPPED lpOverlapped<span class="comment">//异步相关，一般填NULL，略</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>内核通信，需要头文件<code>#include &lt;WinIoCtl.h&gt;</code></p>
<p>并且<strong>WinIoCtl.h必须定义到Windows.h的后面</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CODE_READ CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,METHOD_BUFFERED,FILE_ANY_ACCESS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CODE_WRITE CTL_CODE(FILE_DEVICE_UNKNOWN,0x900,METHOD_BUFFERED,FILE_ANY_ACCESS)<span class="comment">//基本上都是用METHOD_BUFFERED这种方式</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打开设备</span></span><br><span class="line">BOOLEAN <span class="title function_">openDevice</span><span class="params">(HANDLE *handle)</span></span><br><span class="line">&#123;</span><br><span class="line">    HANDLE _handle = CreateFileA(<span class="string">&quot;\\\\.\\MyTestDriver&quot;</span>,GENERIC_READ|GENERIC_WRITE,<span class="number">0</span>,<span class="literal">NULL</span>,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,<span class="literal">NULL</span>);<span class="comment">//打开设备对象句柄</span></span><br><span class="line">    *handle=_handle;</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">int</span>)_handle&gt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭设备</span></span><br><span class="line">CloseHandle(handle);</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送IRP_MJ_DEVICE_CONTROL</span></span><br><span class="line">BOOLEAN <span class="title function_">sendCode</span><span class="params">(HANDLE hDevice,DWORD code,PVOID inData,ULONG Inlen,PVOID outData,ULONG outLen,LPDWORD resultLen)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> DeviceIoControl(hDevice,code,inData,Inlen,outData,outLen,resultLen,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>0-3环常规通信框架：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CODE_CHANGE CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,METHOD_BUFFERED,FILE_ANY_ACCESS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CODE_RESUME CTL_CODE(FILE_DEVICE_UNKNOWN,0x900,METHOD_BUFFERED,FILE_ANY_ACCESS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CODE_READ CTL_CODE(FILE_DEVICE_UNKNOWN,0x1000,METHOD_BUFFERED,FILE_ANY_ACCESS)</span></span><br><span class="line">UNICODE_STRING SymbolicLinkName;</span><br><span class="line"></span><br><span class="line"><span class="comment">//卸载函数</span></span><br><span class="line">VOID <span class="title function_">DriverUnload</span><span class="params">(PDRIVER_OBJECT driver)</span></span><br><span class="line">&#123;</span><br><span class="line">	DbgPrint(<span class="string">&quot;停止运行了\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">MyCreateDispatchFunction</span><span class="params">(PDEVICE_OBJECT pDevObj, PIRP pIrp)</span><span class="comment">//PIRP为IRP报文数据结构指针</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//处理自己的业务...</span></span><br><span class="line">	DbgPrint(<span class="string">&quot;三环连接成功\n&quot;</span>);</span><br><span class="line">	<span class="comment">//设置返回状态,返回状态如果不设置，Ring3返回的是失败</span></span><br><span class="line">	pIrp-&gt;IoStatus.Status = STATUS_SUCCESS;	<span class="comment">//  三环getlasterror()得到的就是这个值</span></span><br><span class="line">	pIrp-&gt;IoStatus.Information = <span class="number">0</span>;		<span class="comment">//  返回给3环多少个字节的数据 没有填0</span></span><br><span class="line">	IoCompleteRequest(pIrp, IO_NO_INCREMENT);<span class="comment">//表示调用方已完成所有I/O请求处理操作，并将给定的 IRP 返回给 I/O 管理器。将IRP往下派发</span></span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line">NTSTATUS <span class="title function_">MyCloseDispatchFunction</span><span class="params">(PDEVICE_OBJECT pDevObj, PIRP pIrp)</span><span class="comment">//PIRP为IRP报文数据结构指针</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//处理自己的业务...</span></span><br><span class="line">	DbgPrint(<span class="string">&quot;三环断开连接成功\n&quot;</span>);</span><br><span class="line">	<span class="comment">//设置返回状态,返回状态如果不设置，Ring3返回的是失败</span></span><br><span class="line">	pIrp-&gt;IoStatus.Status = STATUS_SUCCESS;	<span class="comment">//  三环getlasterror()得到的就是这个值</span></span><br><span class="line">	pIrp-&gt;IoStatus.Information = <span class="number">0</span>;		<span class="comment">//  返回给3环多少个字节的数据 没有填0</span></span><br><span class="line">	IoCompleteRequest(pIrp, IO_NO_INCREMENT);<span class="comment">//表示调用方已完成所有I/O请求处理操作，并将给定的 IRP 返回给 I/O 管理器。将IRP往下派发</span></span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ULONG current = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">ControlCallBack</span><span class="params">(PDEVICE_OBJECT pDevObj, PIRP pIrp)</span></span><br><span class="line">&#123;</span><br><span class="line">	PIO_STACK_LOCATION psl = IoGetCurrentIrpStackLocation(pIrp);</span><br><span class="line">	ULONG code = psl-&gt;Parameters.DeviceIoControl.IoControlCode;<span class="comment">//获取派遣过来的CTL操作码</span></span><br><span class="line">	PVOID systemBuf = pIrp-&gt;AssociatedIrp.SystemBuffer;<span class="comment">//获取缓存地址(输入输出都靠这个地址)</span></span><br><span class="line">	ULONG inLen = psl-&gt;Parameters.DeviceIoControl.InputBufferLength;<span class="comment">//获取输入长度</span></span><br><span class="line">	ULONG outLen = psl-&gt;Parameters.DeviceIoControl.OutputBufferLength;<span class="comment">//获取输出长度</span></span><br><span class="line">	<span class="comment">//根据不同的CTL操作码做不同的处理</span></span><br><span class="line">	<span class="keyword">switch</span> (code)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> CODE_CHANGE:<span class="comment">//注意是以三环视角来看其含义，初始化</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> CODE_RESUME:<span class="comment">//三环想要反初始化</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> CODE_READ:</span><br><span class="line"></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	IoCompleteRequest(pIrp, IO_NO_INCREMENT);<span class="comment">//表示调用方已完成所有I/O请求处理操作，并将给定的 IRP 返回给 I/O 管理器。将IRP往下派发</span></span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//入口函数，相当于main函数</span></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT pdriver, PUNICODE_STRING pReg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//设置一个卸载函数，用于退出</span></span><br><span class="line">	pdriver-&gt;DriverUnload = DriverUnload;</span><br><span class="line">	<span class="comment">//创建设备名称</span></span><br><span class="line">	UNICODE_STRING Devicename;</span><br><span class="line">	RtlInitUnicodeString(&amp;Devicename, <span class="string">L&quot;\\Device\\MyDevice&quot;</span>);</span><br><span class="line">	<span class="comment">//设备对象指针，用于接受</span></span><br><span class="line">	PDEVICE_OBJECT pDeviceObj = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//创建设备</span></span><br><span class="line">	NTSTATUS status = IoCreateDevice(pdriver,<span class="number">0</span>,&amp;Devicename,FILE_DEVICE_UNKNOWN,FILE_DEVICE_SECURE_OPEN,TRUE,&amp;pDeviceObj	);</span><br><span class="line">	<span class="keyword">if</span> (!NT_SUCCESS(status))<span class="comment">//NT_SUCCESS,微软提供的，实际上就是判断status是否大于等于0</span></span><br><span class="line">	&#123;</span><br><span class="line">		DbgPrint(<span class="string">&quot;创建设备失败!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> status;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果前面创建设备对象成功，就设置交互数据的方式</span></span><br><span class="line">	pDeviceObj-&gt;Flags |= DO_BUFFERED_IO;</span><br><span class="line">	<span class="comment">//创建符号链接名称</span></span><br><span class="line">	RtlInitUnicodeString(&amp;SymbolicLinkName, <span class="string">L&quot;\\??\\MyTestDriver&quot;</span>);</span><br><span class="line">	status = IoCreateSymbolicLink(&amp;SymbolicLinkName, &amp;Devicename);</span><br><span class="line">	<span class="keyword">if</span> (!NT_SUCCESS(status))</span><br><span class="line">	&#123;</span><br><span class="line">		DbgPrint(<span class="string">&quot;创建符号链接失败!\n&quot;</span>);</span><br><span class="line">		IoDeleteDevice(pDeviceObj);<span class="comment">//删除设备</span></span><br><span class="line">		<span class="keyword">return</span> status;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置派遣函数   </span></span><br><span class="line">	pdriver-&gt;MajorFunction[IRP_MJ_CREATE] = MyCreateDispatchFunction;</span><br><span class="line">	pdriver-&gt;MajorFunction[IRP_MJ_CLOSE] = MyCloseDispatchFunction;</span><br><span class="line">	pdriver-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = ControlCallBack;</span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="IRP-MJ-DEVICE-CONTROL交互数据实验"><a href="#IRP-MJ-DEVICE-CONTROL交互数据实验" class="headerlink" title="IRP_MJ_DEVICE_CONTROL交互数据实验"></a>IRP_MJ_DEVICE_CONTROL交互数据实验</h3><h4 id="R0代码："><a href="#R0代码：" class="headerlink" title="R0代码："></a>R0代码：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CODE_READ CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,METHOD_BUFFERED,FILE_ANY_ACCESS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CODE_WRITE CTL_CODE(FILE_DEVICE_UNKNOWN,0x900,METHOD_BUFFERED,FILE_ANY_ACCESS)</span></span><br><span class="line">UNICODE_STRING SymbolicLinkName;</span><br><span class="line"></span><br><span class="line"><span class="comment">//卸载函数</span></span><br><span class="line">VOID <span class="title function_">DriverUnload</span><span class="params">(PDRIVER_OBJECT driver)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//删除设备对象</span></span><br><span class="line">	<span class="keyword">if</span> (driver-&gt;DeviceObject)</span><br><span class="line">	&#123;</span><br><span class="line">		IoDeleteDevice(driver-&gt;DeviceObject);<span class="comment">//设备对象已挂载在driver中</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (SymbolicLinkName.Length&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		IoDeleteSymbolicLink(&amp;SymbolicLinkName);</span><br><span class="line">	&#125;</span><br><span class="line">	DbgPrint(<span class="string">&quot;停止运行了\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">MyCreateDispatchFunction</span><span class="params">(PDEVICE_OBJECT pDevObj, PIRP pIrp)</span><span class="comment">//PIRP为IRP报文数据结构指针</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//处理自己的业务...</span></span><br><span class="line">	DbgPrint(<span class="string">&quot;三环连接成功\n&quot;</span>);</span><br><span class="line">	<span class="comment">//设置返回状态,返回状态如果不设置，Ring3返回的是失败</span></span><br><span class="line">	pIrp-&gt;IoStatus.Status = STATUS_SUCCESS;	<span class="comment">//  三环getlasterror()得到的就是这个值</span></span><br><span class="line">	pIrp-&gt;IoStatus.Information = <span class="number">0</span>;		<span class="comment">//  返回给3环多少个字节的数据 没有填0</span></span><br><span class="line">	IoCompleteRequest(pIrp, IO_NO_INCREMENT);<span class="comment">//表示调用方已完成所有I/O请求处理操作，并将给定的 IRP 返回给 I/O 管理器。将IRP往下派发</span></span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line">NTSTATUS <span class="title function_">MyCloseDispatchFunction</span><span class="params">(PDEVICE_OBJECT pDevObj, PIRP pIrp)</span><span class="comment">//PIRP为IRP报文数据结构指针</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//处理自己的业务...</span></span><br><span class="line">	DbgPrint(<span class="string">&quot;三环断开连接成功\n&quot;</span>);</span><br><span class="line">	<span class="comment">//设置返回状态,返回状态如果不设置，Ring3返回的是失败</span></span><br><span class="line">	pIrp-&gt;IoStatus.Status = STATUS_SUCCESS;	<span class="comment">//  三环getlasterror()得到的就是这个值</span></span><br><span class="line">	pIrp-&gt;IoStatus.Information = <span class="number">0</span>;		<span class="comment">//  返回给3环多少个字节的数据 没有填0</span></span><br><span class="line">	IoCompleteRequest(pIrp, IO_NO_INCREMENT);<span class="comment">//表示调用方已完成所有I/O请求处理操作，并将给定的 IRP 返回给 I/O 管理器。将IRP往下派发</span></span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">ControlCallBack</span><span class="params">(PDEVICE_OBJECT pDevObj, PIRP pIrp)</span></span><br><span class="line">&#123;</span><br><span class="line">	PIO_STACK_LOCATION psl = IoGetCurrentIrpStackLocation(pIrp);</span><br><span class="line">	ULONG code = psl-&gt;Parameters.DeviceIoControl.IoControlCode;<span class="comment">//获取派遣过来的CTL操作码</span></span><br><span class="line">	PVOID systemBuf = pIrp-&gt;AssociatedIrp.SystemBuffer;<span class="comment">//获取缓存地址(输入输出都靠这个地址)</span></span><br><span class="line">	ULONG inLen = psl-&gt;Parameters.DeviceIoControl.InputBufferLength;<span class="comment">//获取输入长度</span></span><br><span class="line">	ULONG outLen = psl-&gt;Parameters.DeviceIoControl.OutputBufferLength;<span class="comment">//获取输出长度</span></span><br><span class="line">	<span class="comment">//根据不同的CTL操作码做不同的处理</span></span><br><span class="line">	<span class="keyword">switch</span> (code)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> CODE_READ:<span class="comment">//注意是以三环视角来看其含义，三环想要读</span></span><br><span class="line">		<span class="comment">//把1234567传给三环读</span></span><br><span class="line">		<span class="built_in">memcpy</span>(systemBuf, <span class="string">&quot;1234567&quot;</span>, <span class="keyword">sizeof</span>(<span class="string">&quot;1234567&quot;</span>));</span><br><span class="line">		<span class="comment">//把零环写入的长度传给三环</span></span><br><span class="line">		pIrp-&gt;IoStatus.Information = <span class="keyword">sizeof</span>(<span class="string">&quot;1234567&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> CODE_WRITE:</span><br><span class="line">		<span class="comment">//打印三环写入的信息</span></span><br><span class="line">		DbgPrint(<span class="string">&quot;派遣函数:三环传入的信息：%s\n&quot;</span>,<span class="comment">/*(char*)*/</span>systemBuf);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	IoCompleteRequest(pIrp, IO_NO_INCREMENT);<span class="comment">//表示调用方已完成所有I/O请求处理操作，并且不增加优先级,并将给定的 IRP 返回给 I/O 管理器。将IRP往下派发</span></span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入口函数，相当于main函数</span></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT pdriver, PUNICODE_STRING pReg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//设置一个卸载函数，用于退出</span></span><br><span class="line">	pdriver-&gt;DriverUnload = DriverUnload;</span><br><span class="line">	<span class="comment">//创建设备名称</span></span><br><span class="line">	UNICODE_STRING Devicename;</span><br><span class="line">	RtlInitUnicodeString(&amp;Devicename, <span class="string">L&quot;\\Device\\MyDevice&quot;</span>);</span><br><span class="line">	<span class="comment">//设备对象指针，用于接受</span></span><br><span class="line">	PDEVICE_OBJECT pDeviceObj = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//创建设备</span></span><br><span class="line">	NTSTATUS status = IoCreateDevice(pdriver,<span class="number">0</span>,&amp;Devicename,FILE_DEVICE_UNKNOWN,FILE_DEVICE_SECURE_OPEN,TRUE,&amp;pDeviceObj	);</span><br><span class="line">	<span class="keyword">if</span> (!NT_SUCCESS(status))<span class="comment">//NT_SUCCESS,微软提供的，实际上就是判断status是否大于等于0</span></span><br><span class="line">	&#123;</span><br><span class="line">		DbgPrint(<span class="string">&quot;创建设备失败!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> status;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果前面创建设备对象成功，就设置交互数据的方式.其实此代码可以不设置,因为项目未使用ReadFile和WriteFile来通信,而是使用DeviceIoControl.</span></span><br><span class="line">	pDeviceObj-&gt;Flags |= DO_BUFFERED_IO;</span><br><span class="line">	<span class="comment">//创建符号链接名称</span></span><br><span class="line">	RtlInitUnicodeString(&amp;SymbolicLinkName, <span class="string">L&quot;\\??\\MyTestDriver&quot;</span>);</span><br><span class="line">	status = IoCreateSymbolicLink(&amp;SymbolicLinkName, &amp;Devicename);</span><br><span class="line">	<span class="keyword">if</span> (!NT_SUCCESS(status))</span><br><span class="line">	&#123;</span><br><span class="line">		DbgPrint(<span class="string">&quot;创建符号链接失败!\n&quot;</span>);</span><br><span class="line">		IoDeleteDevice(pDeviceObj);<span class="comment">//删除设备</span></span><br><span class="line">		<span class="keyword">return</span> status;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置派遣函数   </span></span><br><span class="line">	pdriver-&gt;MajorFunction[IRP_MJ_CREATE] = MyCreateDispatchFunction;</span><br><span class="line">	pdriver-&gt;MajorFunction[IRP_MJ_CLOSE] = MyCloseDispatchFunction;</span><br><span class="line">	pdriver-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = ControlCallBack;</span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="R3代码："><a href="#R3代码：" class="headerlink" title="R3代码："></a>R3代码：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinIoCtl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CODE_READ CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,METHOD_BUFFERED,FILE_ANY_ACCESS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CODE_WRITE CTL_CODE(FILE_DEVICE_UNKNOWN,0x900,METHOD_BUFFERED,FILE_ANY_ACCESS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打开设备</span></span><br><span class="line">BOOLEAN <span class="title function_">openDevice</span><span class="params">(HANDLE *handle)</span></span><br><span class="line">&#123;</span><br><span class="line">	HANDLE _handle = CreateFileA(<span class="string">&quot;\\\\.\\MyTestDriver&quot;</span>, GENERIC_READ | GENERIC_WRITE, <span class="number">0</span>, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);<span class="comment">//打开设备对象句柄</span></span><br><span class="line">	*handle = _handle;</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">int</span>)_handle &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//发送IRP_MJ_DEVICE_CONTROL</span></span><br><span class="line">BOOLEAN <span class="title function_">sendCode</span><span class="params">(HANDLE hDevice, DWORD code, PVOID inData, ULONG Inlen, PVOID outData, ULONG outLen, LPDWORD resultLen)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> DeviceIoControl(hDevice, code, inData, Inlen, outData, outLen, resultLen, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	HANDLE hDevice;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">30</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	DWORD realReaded = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!openDevice(&amp;hDevice))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;打开设备对象失败!\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//写数据给R0！！！！！！！！！！！！！！！！！！！！！！</span></span><br><span class="line">	<span class="built_in">memcpy</span>(buf,<span class="string">&quot;i am R3&quot;</span>,<span class="keyword">sizeof</span>(<span class="string">&quot;i am R3&quot;</span>));</span><br><span class="line">	sendCode(hDevice, CODE_WRITE, buf, <span class="number">30</span>, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;realReaded);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//读R0数据	！！！！！！！！！！！！！！！！！！！！！！</span></span><br><span class="line">	<span class="comment">//sendCode(hDevice, CODE_READ, NULL, 0, buf, 30, &amp;realReaded);</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;读到：%s\r\n&quot;</span>, buf);</span><br><span class="line">	CloseHandle(hDevice);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写数据结果如图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210829212010210.png" alt="image-20210829212010210"></p>
<p>将<code>写数据给R0</code>代码注释，放开<code>读R0数据</code>的代码，结果如图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210829212159461.png" alt="image-20210829212159461"></p>
<h2 id="驱动加载"><a href="#驱动加载" class="headerlink" title="驱动加载"></a>驱动加载</h2><p>需要头文件 <code>#include &lt;winsvc.h&gt;</code></p>
<p><strong>加载驱动过程</strong></p>
<ol>
<li>用OpenSCManager打开服务控制管理器</li>
<li>用CreateService创建对应服务</li>
<li>如果驱动服务已经创建过,则用OpenService打开服务</li>
<li>用StartService加载启动驱动服务</li>
<li>用QueryServiceStatus获得服务的当前状态</li>
<li>用ControlService停止,暂停,恢复服务</li>
<li>用DeleteService卸载驱动</li>
<li>清理工作,用CloseServiceHandle关闭释放句柄</li>
</ol>
<h3 id="驱动注册-安装"><a href="#驱动注册-安装" class="headerlink" title="驱动注册&#x2F;安装"></a>驱动注册&#x2F;安装</h3><h4 id="OpenSCManagerA函数"><a href="#OpenSCManagerA函数" class="headerlink" title="OpenSCManagerA函数"></a><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/win32/api/winsvc/nf-winsvc-openscmanagera">OpenSCManagerA函数</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果函数成功，则返回值是指定服务控制管理器数据库的句柄。</span></span><br><span class="line"><span class="comment">//如果函数失败，则返回值为 NULL。</span></span><br><span class="line"><span class="comment">//打开服务管理器</span></span><br><span class="line">SC_HANDLE <span class="title function_">OpenSCManagerA</span><span class="params">(</span></span><br><span class="line"><span class="params">  LPCSTR lpMachineName,<span class="comment">//目标计算机的名称。如果指针为 NULL 或指向空字符串，则该函数连接到本地计算机上的服务控制管理器。</span></span></span><br><span class="line"><span class="params">  LPCSTR lpDatabaseName,<span class="comment">//服务控制管理器数据库的名称。此参数应设置为 SERVICES_ACTIVE_DATABASE。如果为 NULL，则打开活动数据库 SERVICES_ACTIVE_DATABASE 数据库。</span></span></span><br><span class="line"><span class="params">  DWORD  dwDesiredAccess<span class="comment">//权限，SC_MANAGER_ALL_ACCESS 表示所有权限;还有诸如创建服务,枚举服务权限等</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="创建服务CreateServiceA函数"><a href="#创建服务CreateServiceA函数" class="headerlink" title="创建服务CreateServiceA函数"></a>创建服务<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/win32/api/winsvc/nf-winsvc-createservicea">CreateServiceA函数</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果函数成功，则返回值是服务的句柄。</span></span><br><span class="line"><span class="comment">//如果函数失败，则返回值为 NULL。</span></span><br><span class="line">SC_HANDLE <span class="title function_">CreateServiceA</span><span class="params">(</span></span><br><span class="line"><span class="params">  SC_HANDLE hSCManager,<span class="comment">//服务管理器句柄,一般从OpenSCManagerA的返回值获取</span></span></span><br><span class="line"><span class="params">  LPCSTR    lpServiceName,<span class="comment">//这个服务在注册表中的名字(名字唯一性);服务唯一标识,一般取的是可执行文件名(不带后缀)</span></span></span><br><span class="line"><span class="params">  LPCSTR    lpDisplayName,<span class="comment">//注册表驱动程序的DisplayName值,显示给别人看的名字(名字不唯一)</span></span></span><br><span class="line"><span class="params">  DWORD     dwDesiredAccess,<span class="comment">//服务的访问权限，SERVICE_ALL_ACCESS表示所有权限</span></span></span><br><span class="line"><span class="params">  DWORD     dwServiceType,<span class="comment">//创建什么类型的服务，SERVICE_KERNEL_DRIVER表示内核驱动服务,即表示加载的服务是驱动程序</span></span></span><br><span class="line"><span class="params">  DWORD     dwStartType,<span class="comment">//创建服务的启动类型，SERVICE_BOOT_START开机启动服务，SERVICE_AUTO_START自动启动服务，SERVICE_DEMAND_START按需启动，即当进程调用StartService函数时由服务控制管理器启动的服务 。</span></span></span><br><span class="line"><span class="params">  DWORD     dwErrorControl,<span class="comment">//注册表服务的ErrorControl(错误控制).如果此服务无法启动，则错误的严重性以及采取的措施。SERVICE_ERROR_NORMAL表示启动程序在事件日志中记录错误，但继续启动操作。</span></span></span><br><span class="line"><span class="params">  LPCSTR    lpBinaryPathName,<span class="comment">//服务对应的可执行程序的全路径  如驱动服务:C:\\222\1.sys)。可用GetFullPathNameA函数以及可执行文件名获取</span></span></span><br><span class="line"><span class="params">    <span class="comment">//后面都为NULL就可以了</span></span></span><br><span class="line"><span class="params">  LPCSTR    lpLoadOrderGroup,<span class="comment">//服务所在分组的名字</span></span></span><br><span class="line"><span class="params">  LPDWORD   lpdwTagId,<span class="comment">//分组内该服务的启动顺序</span></span></span><br><span class="line"><span class="params">  LPCSTR    lpDependencies,<span class="comment">//需要依赖其他服务名的列表</span></span></span><br><span class="line"><span class="params">  LPCSTR    lpServiceStartName,<span class="comment">//加上下面哪个,表示以什么身份启动服务</span></span></span><br><span class="line"><span class="params">  LPCSTR    lpPassword</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p><code>CreateServiceA</code>函数执行后,<code>GetLastError()</code>如果为<code>ERROR_SERVICE_EXISTS</code>,则调用<code>OpenService</code></p>
<p><strong>关闭服务句柄</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CloseServiceHandle(serviceHandle);<span class="comment">//serviceHandle为某服务的句柄</span></span><br><span class="line"><span class="comment">//也可以直接调用CloseHandle(serviceHandle);CloseServiceHandle还是会调用CloseHandle</span></span><br></pre></td></tr></table></figure>

<h3 id="驱动启动"><a href="#驱动启动" class="headerlink" title="驱动启动"></a>驱动启动</h3><h4 id="打开服务OpenServiceA函数"><a href="#打开服务OpenServiceA函数" class="headerlink" title="打开服务OpenServiceA函数"></a>打开服务<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/win32/api/winsvc/nf-winsvc-openservicea">OpenServiceA函数</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SC_HANDLE <span class="title function_">OpenServiceA</span><span class="params">(</span></span><br><span class="line"><span class="params">  SC_HANDLE hSCManager,<span class="comment">//服务管理器句柄</span></span></span><br><span class="line"><span class="params">  LPCSTR    lpServiceName,<span class="comment">//服务名字，根据这个服务名字找服务</span></span></span><br><span class="line"><span class="params">  DWORD     dwDesiredAccess<span class="comment">//权限，SC_MANAGER_ALL_ACCESS表示所有权限</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="开始服务StartServiceA函数"><a href="#开始服务StartServiceA函数" class="headerlink" title="开始服务StartServiceA函数"></a>开始服务<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/winsvc/nf-winsvc-startservicea">StartServiceA函数</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果函数成功，则返回值非零。</span></span><br><span class="line"><span class="comment">//如果函数失败，则返回值为零。</span></span><br><span class="line">BOOL <span class="title function_">StartServiceA</span><span class="params">(</span></span><br><span class="line"><span class="params">  SC_HANDLE hService,<span class="comment">//服务句柄</span></span></span><br><span class="line"><span class="params">    <span class="comment">//服务函数的参数相关</span></span></span><br><span class="line"><span class="params">  DWORD     dwNumServiceArgs,<span class="comment">//参数字节数，没有填0</span></span></span><br><span class="line"><span class="params">  LPCSTR    *lpServiceArgVectors<span class="comment">//如果没有参数，则此参数可以为 NULL。</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="停止驱动"><a href="#停止驱动" class="headerlink" title="停止驱动"></a>停止驱动</h3><p>OpenServiceA后ControlService</p>
<h4 id="控制服务ControlService函数"><a href="#控制服务ControlService函数" class="headerlink" title="控制服务ControlService函数"></a>控制服务<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/winsvc/nf-winsvc-controlservice">ControlService函数</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果函数成功，则返回值非零。</span></span><br><span class="line"><span class="comment">//如果函数失败，则返回值为零。</span></span><br><span class="line">BOOL <span class="title function_">ControlService</span><span class="params">(</span></span><br><span class="line"><span class="params">  SC_HANDLE        hService,<span class="comment">//服务句柄</span></span></span><br><span class="line"><span class="params">  DWORD            dwControl,<span class="comment">//控制码,可以停止/暂停/恢复服务，其中SERVICE_CONTROL_STOP表示停止服务的控制码</span></span></span><br><span class="line"><span class="params">  LPSERVICE_STATUS lpServiceStatus<span class="comment">//指向SERVICE_STATUS结构的指针，该结构接收最新的服务状态信息。返回的信息反映了服务向服务控制管理器报告的最新状态。仅当GetLastError返回以下错误代码之一时，服务控制管理器才会填充结构 ：NO_ERROR、ERROR_INVALID_SERVICE_CONTROL、 ERROR_SERVICE_CANNOT_ACCEPT_CTRL或 ERROR_SERVICE_NOT_ACTIVE。否则，不填充结构。</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="卸载驱动"><a href="#卸载驱动" class="headerlink" title="卸载驱动"></a>卸载驱动</h3><p>OpenServiceA后DeleteService</p>
<p>删除服务<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/winsvc/nf-winsvc-deleteservice">DeleteService函数</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果函数成功，则返回值非零。</span></span><br><span class="line"><span class="comment">//如果函数失败，则返回值为零。</span></span><br><span class="line">BOOL <span class="title function_">DeleteService</span><span class="params">(</span></span><br><span class="line"><span class="params">  SC_HANDLE hService<span class="comment">//服务句柄</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="驱动加载-启动-停止-卸载案例"><a href="#驱动加载-启动-停止-卸载案例" class="headerlink" title="驱动加载&#x2F;启动&#x2F;停止&#x2F;卸载案例"></a>驱动加载&#x2F;启动&#x2F;停止&#x2F;卸载案例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载驱动封装函数   lpszDriverName是不带后缀的服务唯一标识,sysFileName是带后缀的驱动文件名</span></span><br><span class="line">BOOL <span class="title function_">loadDriver</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* lpszDriverName, <span class="type">const</span> <span class="type">char</span>* sysFileName)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//用于保存.sys的全路径名,得到完整的驱动路径</span></span><br><span class="line">	<span class="type">char</span> szDriverImagePath[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	GetFullPathNameA(sysFileName, <span class="number">256</span>, szDriverImagePath, <span class="literal">NULL</span>);</span><br><span class="line">	myOutPutDebug(<span class="string">&quot;加载驱动的全路径名:%s&quot;</span>, szDriverImagePath);</span><br><span class="line">	SC_HANDLE hMgr = OpenSCManagerA(<span class="literal">NULL</span>, <span class="literal">NULL</span>, SC_MANAGER_ALL_ACCESS);</span><br><span class="line">	<span class="keyword">if</span> (!hMgr)</span><br><span class="line">	&#123;</span><br><span class="line">		myOutPutDebug(<span class="string">&quot;OpenSCManagerA失败 ERROR:%d&quot;</span>,GetLastError());</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	SC_HANDLE hSve = CreateServiceA(hMgr,</span><br><span class="line">		lpszDriverName,<span class="comment">//驱动在注册表中的名字</span></span><br><span class="line">		lpszDriverName,<span class="comment">//注册表驱动程序的DisplayName值</span></span><br><span class="line">		SERVICE_START,<span class="comment">//加载驱动程序的访问权限,SERVICE_START 或者 SERVICE_ALL_ACCESS</span></span><br><span class="line">		SERVICE_KERNEL_DRIVER,<span class="comment">//表示加载的服务是驱动程序</span></span><br><span class="line">		SERVICE_DEMAND_START,<span class="comment">//注册表驱动程序的Start值   //指定当进程调用StartService函数时由服务控制管理器启动的服务</span></span><br><span class="line">		SERVICE_ERROR_NORMAL,<span class="comment">//SERVICE_ERROR_IGNORE   //注册表驱动程序的ErrorControl值</span></span><br><span class="line">		szDriverImagePath,<span class="comment">//szDriverImagePath注册表驱动程序的全路径  如:C:\\222\1.sys   通过GetFullPathNameA函数获取</span></span><br><span class="line">		<span class="literal">NULL</span>,<span class="comment">//GroupOrder HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\GroupOrderList</span></span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		<span class="literal">NULL</span></span><br><span class="line">	);</span><br><span class="line">	<span class="keyword">if</span> (GetLastError()==ERROR_SERVICE_EXISTS)<span class="comment">//服务已经存在的话,直接打开该服务</span></span><br><span class="line">	&#123;</span><br><span class="line">		hSve = OpenServiceA(hMgr, lpszDriverName, SERVICE_START);</span><br><span class="line">	&#125;</span><br><span class="line">	myOutPutDebug(<span class="string">&quot;hSve:%X&quot;</span>, hSve);</span><br><span class="line">	<span class="comment">//此处可以用QueryServiceStatus查询服务状态,来判断是否需要开启服务,可能已经开启了</span></span><br><span class="line">	<span class="type">bool</span> bRet = StartServiceW(hSve, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (hSve)</span><br><span class="line">	&#123;</span><br><span class="line">		CloseServiceHandle(hSve);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(hMgr)</span><br><span class="line">	&#123;</span><br><span class="line">		CloseServiceHandle(hMgr);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//卸载驱动封装函数</span></span><br><span class="line">BOOL <span class="title function_">UnloadDriver</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* lpszDriverName)</span></span><br><span class="line">&#123;</span><br><span class="line">	BOOL bRet = FALSE;</span><br><span class="line">	SC_HANDLE hMgr = <span class="literal">NULL</span>;<span class="comment">//SCM管理器的句柄</span></span><br><span class="line">	SC_HANDLE hSve = <span class="literal">NULL</span>;<span class="comment">//NT驱动程序的服务句柄</span></span><br><span class="line">	SERVICE_STATUS SveSta;</span><br><span class="line">	hMgr = OpenSCManagerA(<span class="literal">NULL</span>, <span class="literal">NULL</span>, SC_MANAGER_ALL_ACCESS);</span><br><span class="line">	<span class="keyword">if</span> (!hMgr)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//打开失败</span></span><br><span class="line">		bRet = FALSE;</span><br><span class="line">		<span class="keyword">goto</span> BeforeLeave;</span><br><span class="line">	&#125;</span><br><span class="line">	hSve = OpenServiceA(hMgr, lpszDriverName, SERVICE_ALL_ACCESS);</span><br><span class="line">	<span class="keyword">if</span> (!hSve)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//打开失败</span></span><br><span class="line">		bRet = FALSE;</span><br><span class="line">		<span class="keyword">goto</span> BeforeLeave;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//停止服务</span></span><br><span class="line">	<span class="keyword">if</span> (!ControlService(hSve,SERVICE_CONTROL_STOP,&amp;SveSta))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 停止失败</span></span><br><span class="line">		bRet = FALSE;</span><br><span class="line">		<span class="keyword">goto</span> BeforeLeave;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//卸载服务</span></span><br><span class="line">	<span class="keyword">if</span> (!DeleteService(hSve))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 卸载失败</span></span><br><span class="line">		bRet = FALSE;</span><br><span class="line">		<span class="keyword">goto</span> BeforeLeave;</span><br><span class="line">	&#125;</span><br><span class="line">	bRet = TRUE;</span><br><span class="line">BeforeLeave:</span><br><span class="line">	<span class="keyword">if</span> (hSve)</span><br><span class="line">	&#123;</span><br><span class="line">		CloseServiceHandle(hSve);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (hMgr)</span><br><span class="line">	&#123;</span><br><span class="line">		CloseServiceHandle(hMgr);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面两个函数依赖的调试信息输出函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">myOutPutDebug</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pszFormat, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> szbufFormat[<span class="number">0x1000</span>];</span><br><span class="line">	<span class="type">char</span> szbufFormat_withHead[<span class="number">0x1100</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	va_list argList;</span><br><span class="line">	va_start(argList, pszFormat);</span><br><span class="line">	vsprintf_s(szbufFormat, pszFormat, argList);</span><br><span class="line">	strcat_s(szbufFormat_withHead, <span class="string">&quot;zeroko: &quot;</span>);<span class="comment">// 加上本人输出头特征</span></span><br><span class="line">	strcat_s(szbufFormat_withHead, szbufFormat);</span><br><span class="line">	OutputDebugStringA(szbufFormat_withHead);<span class="comment">// 编码转换</span></span><br><span class="line">	va_end(argList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载驱动函数使用案例:</span></span><br><span class="line">loadDriver(<span class="string">&quot;driverKMDFempty&quot;</span>, <span class="string">&quot;driverKMDFempty.sys&quot;</span>);</span><br><span class="line"><span class="comment">//卸载驱动函数使用案例:</span></span><br><span class="line">UnloadDriver(<span class="string">&quot;driverKMDFempty&quot;</span>);</span><br></pre></td></tr></table></figure>





<h2 id="全局监听API实验"><a href="#全局监听API实验" class="headerlink" title="全局监听API实验"></a>全局监听API实验</h2><ol>
<li>自己加载驱动</li>
<li>写拷贝(段页知识)</li>
<li>R3,R0通信</li>
<li>写HOOK</li>
<li>ShellCode</li>
</ol>
<p>写拷贝的本来流程：</p>
<blockquote>
<p>当写一个内存的时候先判断到内存是否可写(R&#x2F;W位是否为1)，若为0，则表示该内存不可写，进入异常，在异常中通过VAD进一步判断其到底是写拷贝还是只读，如果是只读报错；如果是写拷贝，则映射一份新物理页将原内容复制过来，直接写到新物理页上，不影响原物理页。因此你HOOK了一个API只影响你自己的进程，而无法影响别的进程是因为别的进程还是原物理页，并未被你修改。解决方法很简单，找到要hook API的地方将R&#x2F;W位置1，根本不进异常直接hook原物理页，规避触发写拷贝。</p>
</blockquote>
<p>下面代码针对2-9-9-12分页，并且事后未复原。</p>
<h3 id="R0代码"><a href="#R0代码" class="headerlink" title="R0代码"></a>R0代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CODE_CHANGE CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,METHOD_BUFFERED,FILE_ANY_ACCESS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CODE_RESUME CTL_CODE(FILE_DEVICE_UNKNOWN,0x900,METHOD_BUFFERED,FILE_ANY_ACCESS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CODE_READ CTL_CODE(FILE_DEVICE_UNKNOWN,0x1000,METHOD_BUFFERED,FILE_ANY_ACCESS)</span></span><br><span class="line">UNICODE_STRING SymbolicLinkName;</span><br><span class="line"></span><br><span class="line"><span class="comment">//卸载函数</span></span><br><span class="line">VOID <span class="title function_">DriverUnload</span><span class="params">(PDRIVER_OBJECT driver)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//删除设备对象</span></span><br><span class="line">	<span class="keyword">if</span> (driver-&gt;DeviceObject)</span><br><span class="line">	&#123;</span><br><span class="line">		IoDeleteDevice(driver-&gt;DeviceObject);<span class="comment">//设备对象已挂载在driver中</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (SymbolicLinkName.Length&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		IoDeleteSymbolicLink(&amp;SymbolicLinkName);</span><br><span class="line">	&#125;</span><br><span class="line">	DbgPrint(<span class="string">&quot;停止运行了\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">MyCreateDispatchFunction</span><span class="params">(PDEVICE_OBJECT pDevObj, PIRP pIrp)</span><span class="comment">//PIRP为IRP报文数据结构指针</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//处理自己的业务...</span></span><br><span class="line">	DbgPrint(<span class="string">&quot;三环连接成功\n&quot;</span>);</span><br><span class="line">	<span class="comment">//设置返回状态,返回状态如果不设置，Ring3返回的是失败</span></span><br><span class="line">	pIrp-&gt;IoStatus.Status = STATUS_SUCCESS;	<span class="comment">//  三环getlasterror()得到的就是这个值</span></span><br><span class="line">	pIrp-&gt;IoStatus.Information = <span class="number">0</span>;		<span class="comment">//  返回给3环多少个字节的数据 没有填0</span></span><br><span class="line">	IoCompleteRequest(pIrp, IO_NO_INCREMENT);<span class="comment">//表示调用方已完成所有I/O请求处理操作，并将给定的 IRP 返回给 I/O 管理器。将IRP往下派发</span></span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line">NTSTATUS <span class="title function_">MyCloseDispatchFunction</span><span class="params">(PDEVICE_OBJECT pDevObj, PIRP pIrp)</span><span class="comment">//PIRP为IRP报文数据结构指针</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//处理自己的业务...</span></span><br><span class="line">	DbgPrint(<span class="string">&quot;三环断开连接成功\n&quot;</span>);</span><br><span class="line">	<span class="comment">//设置返回状态,返回状态如果不设置，Ring3返回的是失败</span></span><br><span class="line">	pIrp-&gt;IoStatus.Status = STATUS_SUCCESS;	<span class="comment">//  三环getlasterror()得到的就是这个值</span></span><br><span class="line">	pIrp-&gt;IoStatus.Information = <span class="number">0</span>;		<span class="comment">//  返回给3环多少个字节的数据 没有填0</span></span><br><span class="line">	IoCompleteRequest(pIrp, IO_NO_INCREMENT);<span class="comment">//表示调用方已完成所有I/O请求处理操作，并将给定的 IRP 返回给 I/O 管理器。将IRP往下派发</span></span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ULONG param[<span class="number">5</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//ULONG getESP = 0;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//shellcode写到这里</span></span><br><span class="line"><span class="type">void</span> __declspec(naked) interruptGate()</span><br><span class="line">&#123;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//通过ESP获取MessageBoxA的参数</span></span><br><span class="line">		pushfd;</span><br><span class="line">		pushad;</span><br><span class="line">		mov eax, dword ptr ds : [esp + <span class="number">0x24</span> + <span class="number">0xC</span>] ;<span class="comment">//获取三环esp</span></span><br><span class="line">		<span class="comment">//mov dword ptr ds : [getESP] , eax;</span></span><br><span class="line">		lea ecx, param;</span><br><span class="line">		add eax, <span class="number">4</span>;<span class="comment">//跳过call的返回地址</span></span><br><span class="line">		<span class="comment">//获取四个参数填入param全局数组中。</span></span><br><span class="line">		mov ebx, dword ptr ds : [eax] ;</span><br><span class="line">		mov dword ptr ds : [ecx] , ebx;</span><br><span class="line">		mov ebx, dword ptr ds : [eax+<span class="number">4</span>] ;</span><br><span class="line">		mov dword ptr ds : [ecx+<span class="number">4</span>] , ebx;</span><br><span class="line">		mov ebx, dword ptr ds : [eax+<span class="number">8</span>] ;</span><br><span class="line">		mov dword ptr ds : [ecx+<span class="number">8</span>] , ebx;</span><br><span class="line">		mov ebx, dword ptr ds : [eax + <span class="number">0xC</span>] ;</span><br><span class="line">		mov dword ptr ds : [ecx + <span class="number">0xC</span>] , ebx;</span><br><span class="line">		add dword ptr ds : [ecx + <span class="number">0x10</span>],<span class="number">1</span></span><br><span class="line">		popad;</span><br><span class="line">		popfd;</span><br><span class="line">		iretd;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ULONG current = <span class="number">0</span>;<span class="comment">//为了防止打印重复</span></span><br><span class="line">NTSTATUS <span class="title function_">ControlCallBack</span><span class="params">(PDEVICE_OBJECT pDevObj, PIRP pIrp)</span></span><br><span class="line">&#123;</span><br><span class="line">	PIO_STACK_LOCATION psl = IoGetCurrentIrpStackLocation(pIrp);</span><br><span class="line">	ULONG code = psl-&gt;Parameters.DeviceIoControl.IoControlCode;<span class="comment">//获取派遣过来的CTL操作码</span></span><br><span class="line">	PVOID systemBuf = pIrp-&gt;AssociatedIrp.SystemBuffer;<span class="comment">//获取缓存地址(输入输出都靠这个地址)</span></span><br><span class="line">	ULONG inLen = psl-&gt;Parameters.DeviceIoControl.InputBufferLength;<span class="comment">//获取输入长度</span></span><br><span class="line">	ULONG outLen = psl-&gt;Parameters.DeviceIoControl.OutputBufferLength;<span class="comment">//获取输出长度</span></span><br><span class="line">	UCHAR IDT[<span class="number">6</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	UCHAR GDT[<span class="number">6</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	ULONG IDT_BASE = <span class="number">0</span>;</span><br><span class="line">	ULONG GDT_BASE = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//根据不同的CTL操作码做不同的处理</span></span><br><span class="line">	<span class="keyword">switch</span> (code)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> CODE_CHANGE:<span class="comment">//注意是以三环视角来看其含义，初始化</span></span><br><span class="line">		<span class="comment">//填充中断门描述符</span></span><br><span class="line">		__asm sidt IDT;</span><br><span class="line">		IDT_BASE = *(PULONG)(&amp;IDT[<span class="number">2</span>]); </span><br><span class="line">		DbgPrint(<span class="string">&quot;shellCode地址为:%p\n&quot;</span>, interruptGate);</span><br><span class="line">		ULONG firstPart = (((ULONG)interruptGate) &amp; <span class="number">0xFFFF0000</span>) | <span class="number">0x0000EE00</span>;</span><br><span class="line">		ULONG secondPart = (((ULONG)interruptGate) &amp; <span class="number">0x0000FFFF</span>) | <span class="number">0x00080000</span>;</span><br><span class="line">		DbgPrint(<span class="string">&quot;中断门描述符:%p`%p\n&quot;</span>, firstPart, secondPart);</span><br><span class="line">		*(PULONG)(IDT_BASE + <span class="number">32</span> * <span class="number">8</span>) = secondPart;</span><br><span class="line">		*(PULONG)(IDT_BASE + <span class="number">32</span> * <span class="number">8</span> + <span class="number">4</span>) = firstPart;</span><br><span class="line">		<span class="comment">//填充调用门</span></span><br><span class="line">		__asm sgdt GDT;</span><br><span class="line">		GDT_BASE = *(PULONG)(&amp;GDT[<span class="number">2</span>]);</span><br><span class="line">		ULONG targetAddress = *(ULONG*)systemBuf;<span class="comment">//获取三环传过来的要跳转的函数地址</span></span><br><span class="line">		DbgPrint(<span class="string">&quot;targetAddress:%p\n&quot;</span>, targetAddress);</span><br><span class="line">		ULONG firstPart_gdt = (((ULONG)targetAddress) &amp; <span class="number">0xFFFF0000</span>) | <span class="number">0x0000EC00</span>;</span><br><span class="line">		ULONG secondPart_gdt = (((ULONG)targetAddress) &amp; <span class="number">0x0000FFFF</span>) | <span class="number">0x00080000</span>;</span><br><span class="line">		DbgPrint(<span class="string">&quot;调用门描述符:%p`%p\n&quot;</span>, firstPart_gdt, secondPart_gdt);</span><br><span class="line">		*(PULONG)(GDT_BASE + <span class="number">9</span> * <span class="number">8</span>) = secondPart_gdt;</span><br><span class="line">		*(PULONG)(GDT_BASE + <span class="number">9</span> * <span class="number">8</span> + <span class="number">4</span>) = firstPart_gdt;</span><br><span class="line"><span class="comment">//下面代码想在驱动中修改PTE却发现PTE是0。</span></span><br><span class="line">		<span class="comment">//改变messageBox所在的物理页属性R/W为1</span></span><br><span class="line">		<span class="comment">//判断systemBuf中是否有内容</span></span><br><span class="line">		<span class="comment">//ULONG targetAddress = *(ULONG*)systemBuf;//获取三环传过来的函数地址</span></span><br><span class="line">		<span class="comment">//DbgPrint(&quot;MessageBoxA地址为:%p\n&quot;, messageBoxAAddr);</span></span><br><span class="line">		<span class="comment">//ULONG PDI = (messageBoxAAddr &gt;&gt; 21) &amp; 0x1FF;</span></span><br><span class="line">		<span class="comment">////读取PDE</span></span><br><span class="line">		<span class="comment">//ULONG lowPDE = *(ULONG*)(0xC0601000 + 8 * PDI);</span></span><br><span class="line">		<span class="comment">//ULONG highPDE = *(ULONG*)(0xC0601000 + 8 * PDI +4);</span></span><br><span class="line">		<span class="comment">//DbgPrint(&quot;PDE为:%p`%p\n&quot;, highPDE,lowPDE);</span></span><br><span class="line">		<span class="comment">////读取PTE</span></span><br><span class="line">		<span class="comment">//ULONG PTI= (messageBoxAAddr &gt;&gt; 12)&amp; 0x1FF;</span></span><br><span class="line">		<span class="comment">//ULONG lowPTE = *(ULONG*)(0xC0000000 + 0x1000 * PDI + PTI * 8);</span></span><br><span class="line">		<span class="comment">//ULONG highPTE = *(ULONG*)(0xC0000000+ 0x1000 * PDI + PTI * 8 + 4);</span></span><br><span class="line">		<span class="comment">//DbgPrint(&quot;PTE为:%p`%p\n&quot;, highPTE, lowPTE);</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> CODE_RESUME:<span class="comment">//三环想要反初始化</span></span><br><span class="line">		<span class="comment">//恢复原样</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> CODE_READ:</span><br><span class="line">		<span class="comment">/*DbgPrint(&quot;current ESP:%p\n&quot;, getESP);</span></span><br><span class="line"><span class="comment">		DbgPrint(&quot;param:%p,%p,%p,%p,%p\n&quot;, param[0], param[1], param[2], param[3], param[4]);*/</span></span><br><span class="line">		<span class="keyword">if</span>(param[<span class="number">4</span>]!= current)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">memcpy</span>(systemBuf, param, <span class="number">20</span>);</span><br><span class="line">			pIrp-&gt;IoStatus.Information = <span class="number">20</span>;</span><br><span class="line">			current++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			pIrp-&gt;IoStatus.Information = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	IoCompleteRequest(pIrp, IO_NO_INCREMENT);<span class="comment">//表示调用方已完成所有I/O请求处理操作，并将给定的 IRP 返回给 I/O 管理器。将IRP往下派发</span></span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//入口函数，相当于main函数</span></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT pdriver, PUNICODE_STRING pReg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//设置一个卸载函数，用于退出</span></span><br><span class="line">	pdriver-&gt;DriverUnload = DriverUnload;</span><br><span class="line">	<span class="comment">//创建设备名称</span></span><br><span class="line">	UNICODE_STRING Devicename;</span><br><span class="line">	RtlInitUnicodeString(&amp;Devicename, <span class="string">L&quot;\\Device\\MyDevice&quot;</span>);</span><br><span class="line">	<span class="comment">//设备对象指针，用于接受</span></span><br><span class="line">	PDEVICE_OBJECT pDeviceObj = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//创建设备</span></span><br><span class="line">	NTSTATUS status = IoCreateDevice(pdriver,<span class="number">0</span>,&amp;Devicename,FILE_DEVICE_UNKNOWN,FILE_DEVICE_SECURE_OPEN,TRUE,&amp;pDeviceObj	);</span><br><span class="line">	<span class="keyword">if</span> (!NT_SUCCESS(status))<span class="comment">//NT_SUCCESS,微软提供的，实际上就是判断status是否大于等于0</span></span><br><span class="line">	&#123;</span><br><span class="line">		DbgPrint(<span class="string">&quot;创建设备失败!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> status;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果前面创建设备对象成功，就设置交互数据的方式</span></span><br><span class="line">	pDeviceObj-&gt;Flags |= DO_BUFFERED_IO;</span><br><span class="line">	<span class="comment">//创建符号链接名称</span></span><br><span class="line">	RtlInitUnicodeString(&amp;SymbolicLinkName, <span class="string">L&quot;\\??\\MyTestDriver&quot;</span>);</span><br><span class="line">	status = IoCreateSymbolicLink(&amp;SymbolicLinkName, &amp;Devicename);</span><br><span class="line">	<span class="keyword">if</span> (!NT_SUCCESS(status))</span><br><span class="line">	&#123;</span><br><span class="line">		DbgPrint(<span class="string">&quot;创建符号链接失败!\n&quot;</span>);</span><br><span class="line">		IoDeleteDevice(pDeviceObj);<span class="comment">//删除设备</span></span><br><span class="line">		<span class="keyword">return</span> status;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置派遣函数   </span></span><br><span class="line">	pdriver-&gt;MajorFunction[IRP_MJ_CREATE] = MyCreateDispatchFunction;</span><br><span class="line">	pdriver-&gt;MajorFunction[IRP_MJ_CLOSE] = MyCloseDispatchFunction;</span><br><span class="line">	pdriver-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = ControlCallBack;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="R3代码"><a href="#R3代码" class="headerlink" title="R3代码"></a>R3代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinIoCtl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CODE_CHANGE CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,METHOD_BUFFERED,FILE_ANY_ACCESS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CODE_RESUME CTL_CODE(FILE_DEVICE_UNKNOWN,0x900,METHOD_BUFFERED,FILE_ANY_ACCESS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CODE_READ CTL_CODE(FILE_DEVICE_UNKNOWN,0x1000,METHOD_BUFFERED,FILE_ANY_ACCESS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打开设备</span></span><br><span class="line">BOOLEAN <span class="title function_">openDevice</span><span class="params">(HANDLE *handle)</span></span><br><span class="line">&#123;</span><br><span class="line">	HANDLE _handle = CreateFileA(<span class="string">&quot;\\\\.\\MyTestDriver&quot;</span>, GENERIC_READ | GENERIC_WRITE, <span class="number">0</span>, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);<span class="comment">//打开设备对象句柄</span></span><br><span class="line">	*handle = _handle;</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">int</span>)_handle &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送IRP_MJ_DEVICE_CONTROL</span></span><br><span class="line">BOOLEAN <span class="title function_">sendCode</span><span class="params">(HANDLE hDevice, DWORD code, PVOID inData, ULONG Inlen, PVOID outData, ULONG outLen, LPDWORD resultLen)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> DeviceIoControl(hDevice, code, inData, Inlen, outData, outLen, resultLen, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DWORD lowPDE,lowPTE;</span><br><span class="line">DWORD highPDE,highPTE;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __declspec(naked) callGate()</span><br><span class="line">&#123;</span><br><span class="line">	_asm</span><br><span class="line">	&#123;</span><br><span class="line">		pushfd;</span><br><span class="line">		pushad;</span><br><span class="line">		mov ecx,dword ptr ds:[MessageBoxA];</span><br><span class="line">		<span class="comment">//get pde</span></span><br><span class="line">		mov eax,ecx;</span><br><span class="line">		shr eax,<span class="number">21</span>;</span><br><span class="line">		and eax,<span class="number">0x1FF</span>;</span><br><span class="line">		shl eax,<span class="number">3</span>;</span><br><span class="line">		mov edx,dword ptr ds:[<span class="number">0xC0601000</span>+eax];</span><br><span class="line">		mov dword ptr ds:[lowPDE],edx;</span><br><span class="line">		mov edx,dword ptr ds:[<span class="number">0xC0601000</span>+eax+<span class="number">4</span>];</span><br><span class="line">		mov dword ptr ds:[highPDE],edx;</span><br><span class="line">		<span class="comment">//get pte</span></span><br><span class="line">		mov eax,ecx;</span><br><span class="line">		shr eax,<span class="number">12</span>;</span><br><span class="line">		and eax,<span class="number">0xFFFFF</span>;</span><br><span class="line">		shl eax,<span class="number">3</span>;</span><br><span class="line">		mov edi,dword ptr ds:[<span class="number">0xC0000000</span>+eax];</span><br><span class="line">		mov dword ptr ds:[lowPTE],edi;</span><br><span class="line">		mov edx,dword ptr ds:[<span class="number">0xC0000000</span>+eax+<span class="number">4</span>];</span><br><span class="line">		mov dword ptr ds:[highPTE],edx;</span><br><span class="line">		<span class="comment">//change R/W in PDE</span></span><br><span class="line">		or edi,<span class="number">0x2</span>;</span><br><span class="line">		mov dword ptr ds:[<span class="number">0xC0000000</span>+eax],edi</span><br><span class="line">		popad;</span><br><span class="line">		popfd;</span><br><span class="line">		retf;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// MessageBoxA 挂物理页，不这样操作，MessageBoxA的PTE可能是无效的</span></span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		mov eax, dword ptr ds:[MessageBoxA];</span><br><span class="line">		mov eax,[eax];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;MessageBoxA address:%p\n&quot;</span>,MessageBoxA);</span><br><span class="line">	HANDLE hDevice;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">30</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	DWORD realReaded = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!openDevice(&amp;hDevice))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;打开设备对象失败!\r\n&quot;</span>);</span><br><span class="line">		system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	*(DWORD*)buf=(DWORD)callGate;</span><br><span class="line">	sendCode(hDevice, CODE_CHANGE, buf, <span class="number">30</span>, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;realReaded);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;callGate address:%p\n&quot;</span>,callGate);</span><br><span class="line">	</span><br><span class="line">	<span class="type">char</span> callCallgate[<span class="number">6</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x48</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	_asm</span><br><span class="line">	&#123;</span><br><span class="line">		call fword ptr[callCallgate];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;PDE:%p`%p\n&quot;</span>,highPDE,lowPDE);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;PTE:%p`%p\n&quot;</span>,highPTE,lowPTE);</span><br><span class="line">	<span class="comment">//hook MessageBoxA</span></span><br><span class="line">	<span class="type">char</span> hookContent[<span class="number">2</span>]=&#123;<span class="number">0xCD</span>,<span class="number">0x20</span>&#125;;</span><br><span class="line">	<span class="built_in">memcpy</span>(MessageBoxA,hookContent,<span class="number">2</span>);</span><br><span class="line">	<span class="comment">//hook succeed!</span></span><br><span class="line">	<span class="comment">//get R0 info from MessageBoxA</span></span><br><span class="line">	DWORD current=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		sendCode(hDevice, CODE_READ, <span class="literal">NULL</span>, <span class="number">0</span>, buf, <span class="number">30</span>, &amp;realReaded);</span><br><span class="line">		DWORD* p=(DWORD*)buf;</span><br><span class="line">		<span class="keyword">if</span>(realReaded&gt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;No.%d MessageBoxA(%p,%p,%p,%p)\n&quot;</span>,p[<span class="number">4</span>],p[<span class="number">0</span>],p[<span class="number">1</span>],p[<span class="number">2</span>],p[<span class="number">3</span>]);</span><br><span class="line">			current++;</span><br><span class="line">		&#125;</span><br><span class="line">		Sleep(<span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	CloseHandle(hDevice);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成功监听MessageBoxA结果：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210830211435935.png" alt="image-20210830211435935"></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41875267/article/details/109692389">别人的代码参考</a></p>
<h3 id="重难点"><a href="#重难点" class="headerlink" title="重难点"></a>重难点</h3><ul>
<li>跟界面相关的API永远都是<strong>懒加载</strong>的，即没调用不加载，物理页不会挂上去。</li>
<li>但是OpenProcess这种，他自己事先就加载好了，挂上了物理页。</li>
</ul>
<h2 id="Inline-Hook"><a href="#Inline-Hook" class="headerlink" title="Inline Hook"></a>Inline Hook</h2><p>与R3的Inline Hook完全一样</p>
<p>位置的选择：</p>
<ol>
<li>JMP&#x2F;CALL指令至少占用5个字节</li>
<li>绕开全局变量（每次的全局变量位置是不确定，因为模块加载的顺序不一致）</li>
<li>根据业务来决定在哪里HOOK，过滤参数？修改返回结果？</li>
</ol>
<p>思考：</p>
<ol>
<li>正在hook的瞬间，如何保证多核切换的稳定性</li>
<li>如何绕过[[硬编码]]校验检测内联HOOK</li>
</ol>
<h2 id="注册系统回调保护进程"><a href="#注册系统回调保护进程" class="headerlink" title="注册系统回调保护进程"></a>注册系统回调保护进程</h2><p>xp不可用</p>
<p><strong>替代hook的官方手段:回调函数</strong>  (64位未过pg不能inline hook的替代方案)</p>
<p><strong>注册系统回调最需要注意的一点就是: 一定要防止回调发生死循环</strong></p>
<h3 id="核心函数ObRegisterCallbacks"><a href="#核心函数ObRegisterCallbacks" class="headerlink" title="核心函数ObRegisterCallbacks"></a>核心函数ObRegisterCallbacks</h3><p><strong>可以为线程、进程和桌面句柄操作注册回调函数</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202205291945467.jpeg" alt="regsyscallback"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS </span><br><span class="line">  <span class="title function_">ObRegisterCallbacks</span><span class="params">(</span></span><br><span class="line"><span class="params">    IN POB_CALLBACK_REGISTRATION  CallBackRegistration,</span></span><br><span class="line"><span class="params">    OUT PVOID  *RegistrationHandle)</span>;<span class="comment">////返回该系统回调的句柄,卸载时用得上</span></span><br><span class="line"><span class="comment">//NT_SUCCESS(ObRegisterCallbacks的返回值)为1表示成功,否则失败</span></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202205041101739.jpeg" alt="v2-e07e93bb06ba604bbe332d3bfbc0183a_1440w"></p>
<blockquote>
<p><strong>破解ObRegisterCallbacks函数的使用限制</strong> : 驱动程序必须有数字签名才能使用此函数,通过逆向ObRegisterCallbacks,找到了破解这个限制的方法.经研究,内核通过MmVerifyCallbackFunction验证此回调是否合法,但此函数只是简单的验证了一下DriverObject-&gt;DriverSection-&gt;Flags的值是不是包含0x20.在驱动的入口函数中添加代码: <code>PLDR_DATA_TABLE_ENTRY  pobj = (PLDR_DATA_TABLE_ENTRY)DriverObject-&gt;DriverSection;DriverObject-&gt;Flags |= 0x20; </code> (PLDR_DATA_TABLE_ENTRY需要自己定义),即可破解该使用限制</p>
<p>想要使用ObRegisterCallbacks函数成功,必须在编译器的 <strong>链接器-命令行行中添加</strong><code>/INTEGRITYCHECK</code>   (指定必须在加载时检查二进制映像的签名)</p>
<p>关于&#x2F;INTEGRITYCHECK详细信息 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/cpp/build/reference/integritycheck-require-signature-check?view=msvc-160">https://docs.microsoft.com/zh-cn/cpp/build/reference/integritycheck-require-signature-check?view=msvc-160</a> </p>
</blockquote>
<p>该函数第一个参数指向下面结构</p>
<h4 id="OB-CALLBACK-REGISTRATION结构"><a href="#OB-CALLBACK-REGISTRATION结构" class="headerlink" title="OB_CALLBACK_REGISTRATION结构"></a>OB_CALLBACK_REGISTRATION结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OB_CALLBACK_REGISTRATION</span> &#123;</span></span><br><span class="line">  __in USHORT  Version;<span class="comment">//一般为OB_FLT_REGISTRATION_VERSION</span></span><br><span class="line">  __in USHORT  OperationRegistrationCount;<span class="comment">//注册回调函数的个数</span></span><br><span class="line">  __in UNICODE_STRING  Altitude;<span class="comment">//决定加载顺序(越大的越早被执行)</span></span><br><span class="line">  __in PVOID  RegistrationContext;<span class="comment">//自定义数据,没有填空</span></span><br><span class="line">  __in OB_OPERATION_REGISTRATION  *OperationRegistration;<span class="comment">//指向_OB_OPERATION_REGISTRATION结构</span></span><br><span class="line">&#125; OB_CALLBACK_REGISTRATION, *POB_CALLBACK_REGISTRATION;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202205041103204.jpeg" alt="v2-fe188ac7d8bd77ba391df598072daa18_1440w"></p>
<p>可见成员又指向_OB_OPERATION_REGISTRATION结构体</p>
<h4 id="OB-OPERATION-REGISTRATION结构体"><a href="#OB-OPERATION-REGISTRATION结构体" class="headerlink" title="_OB_OPERATION_REGISTRATION结构体"></a>_OB_OPERATION_REGISTRATION结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OB_OPERATION_REGISTRATION</span> &#123;</span></span><br><span class="line">  __in POBJECT_TYPE  *ObjectType;<span class="comment">//针对进程还是线程还是桌面句柄</span></span><br><span class="line">  __in OB_OPERATION  Operations;<span class="comment">//针对什么行为回调</span></span><br><span class="line">  __in POB_PRE_OPERATION_CALLBACK  PreOperation;<span class="comment">//[前]设置自定义的回调函数</span></span><br><span class="line">  __in POB_POST_OPERATION_CALLBACK  PostOperation;<span class="comment">//[后]设置自定义的回调函数</span></span><br><span class="line">&#125; OB_OPERATION_REGISTRATION, *POB_OPERATION_REGISTRATION;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202205041105434.jpeg" alt="v2-29347fc67c90d940d2ba3e58702b5035_1440w"></p>
<p>上述函数第三个参数指向一个自定的回调函数如下</p>
<h4 id="自定义回调函数"><a href="#自定义回调函数" class="headerlink" title="自定义回调函数"></a>自定义回调函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自己起名字</span></span><br><span class="line">OB_PREOP_CALLBACK_STATUS <span class="title function_">my_pre_callback</span><span class="params">(</span></span><br><span class="line"><span class="params">    PVOID RegistrationContext,<span class="comment">//注册回调时传入的自定义数据</span></span></span><br><span class="line"><span class="params">    POB_PRE_OPERATION_INFORMATION OperationInformation</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//想要的操作</span></span><br><span class="line">  <span class="keyword">return</span> OB_PREOP_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>POB_PRE_OPERATION_INFORMATION结构</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OB_PRE_OPERATION_INFORMATION</span> &#123;</span></span><br><span class="line">  OB_OPERATION                 Operation;</span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    ULONG Flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">      ULONG KernelHandle : <span class="number">1</span>;</span><br><span class="line">      ULONG Reserved : <span class="number">31</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  PVOID                        Object;<span class="comment">//打开句柄的目标对象结构体首地址</span></span><br><span class="line">  POBJECT_TYPE                 ObjectType;<span class="comment">//对象种类</span></span><br><span class="line">  PVOID                        CallContext;</span><br><span class="line">  POB_PRE_OPERATION_PARAMETERS Parameters;<span class="comment">//指向包含操作特定信息的OB_PRE_OPERATION_PARAMETERS的指针。</span></span><br><span class="line">&#125; OB_PRE_OPERATION_INFORMATION, *POB_PRE_OPERATION_INFORMATION;</span><br><span class="line"></span><br><span class="line"><span class="comment">//POB_PRE_OPERATION_PARAMETERS结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> _<span class="title">OB_PRE_OPERATION_PARAMETERS</span> &#123;</span></span><br><span class="line">  OB_PRE_CREATE_HANDLE_INFORMATION    CreateHandleInformation;<span class="comment">//包含特定于正在打开的句柄的信息的OB_PRE_CREATE_HANDLE_INFORMATION结构</span></span><br><span class="line">  OB_PRE_DUPLICATE_HANDLE_INFORMATION DuplicateHandleInformation;</span><br><span class="line">&#125; OB_PRE_OPERATION_PARAMETERS, *POB_PRE_OPERATION_PARAMETERS;</span><br><span class="line"></span><br><span class="line"><span class="comment">//OB_PRE_CREATE_HANDLE_INFORMATION结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OB_PRE_CREATE_HANDLE_INFORMATION</span> &#123;</span></span><br><span class="line">  ACCESS_MASK DesiredAccess;<span class="comment">//一个ACCESS_MASK值，它指定要为句柄授予的访问权限。默认情况下，此成员等于OriginalDesiredAccess，但ObjectPreCallback例程可以修改此值以限制授予的访问权限。</span></span><br><span class="line">  ACCESS_MASK OriginalDesiredAccess;<span class="comment">//一个 ACCESS_MASK 值，它指定为句柄请求的原始访问权限。</span></span><br><span class="line">&#125; OB_PRE_CREATE_HANDLE_INFORMATION, *POB_PRE_CREATE_HANDLE_INFORMATION;</span><br><span class="line"><span class="comment">//此结构可用于控制句柄权限</span></span><br></pre></td></tr></table></figure>

<h4 id="注册系统回调案例"><a href="#注册系统回调案例" class="headerlink" title="注册系统回调案例"></a>注册系统回调案例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解锁使用限制</span></span><br><span class="line">    ldr = (PLDR_DATA)pDriverObject-&gt;DriverSection;</span><br><span class="line">    ldr-&gt;Flags |= <span class="number">0x20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//安装系统回调钩子代码如下</span></span><br><span class="line"><span class="comment">//安装内存保护</span></span><br><span class="line">HANDLE gs_HandleCallback = <span class="literal">NULL</span>;<span class="comment">//用来存放返回的句柄,以方便卸载对应功能</span></span><br><span class="line">BOOLEAN <span class="title function_">protectProcessStart</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    OB_CALLBACK_REGISTRATION ob1_callback_reg = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    OB_OPERATION_REGISTRATION ob2_operation = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">//初始化ob1_callback_reg</span></span><br><span class="line">    RtlInitUnicodeString(&amp;ob1_callback_reg.Altitude, <span class="string">L&quot;321000&quot;</span>);<span class="comment">//加载顺序</span></span><br><span class="line">    ob1_callback_reg.RegistrationContext = <span class="literal">NULL</span>;<span class="comment">//自定义数据</span></span><br><span class="line">    ob1_callback_reg.Version = OB_FLT_REGISTRATION_VERSION;<span class="comment">//版本ObGetFilterVersion(); //OB_FLT_REGISTRATION_VERSION</span></span><br><span class="line">    ob1_callback_reg.OperationRegistrationCount = <span class="number">1</span>;<span class="comment">//注册回调函数的个数</span></span><br><span class="line">    ob1_callback_reg.OperationRegistration = &amp;ob2_operation;</span><br><span class="line">    <span class="comment">//接下来初始化ob2_operation</span></span><br><span class="line">    ob2_operation.ObjectType = PsProcessType;<span class="comment">//OpenProcess OpenThread PsThreadType</span></span><br><span class="line">    ob2_operation.Operations = OB_OPERATION_HANDLE_CREATE;<span class="comment">//针对什么行为回调</span></span><br><span class="line">    ob2_operation.PostOperation = <span class="literal">NULL</span>;<span class="comment">//行为发生之后的钩子</span></span><br><span class="line">    ob2_operation.PreOperation = my_pre_callback;<span class="comment">//行为发生之前的钩子,这个函数是自定义的函数</span></span><br><span class="line">    NTSTATUS ntRet = ObRegisterCallbacks(&amp;ob1_callback_reg, &amp;gs_HandleCallback);<span class="comment">//注册回调函数</span></span><br><span class="line">    KdPrint((<span class="string">&quot;zeroko:sys安装进程保护:gs_HandleCallback=%p,ntRet=%x&quot;</span>, gs_HandleCallback,ntRet));</span><br><span class="line">    <span class="keyword">return</span> ntRet == STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//卸载系统回调钩子代码如下</span></span><br><span class="line"><span class="comment">//卸载进程保护</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">protectProcessEnd</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (gs_HandleCallback)</span><br><span class="line">    &#123;</span><br><span class="line">        ObUnRegisterCallbacks(gs_HandleCallback);</span><br><span class="line">        gs_HandleCallback = <span class="literal">NULL</span>;</span><br><span class="line">        KdPrint((<span class="string">&quot;zeroko:sys卸载进程保护&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义的回调函数</span></span><br><span class="line">OB_PREOP_CALLBACK_STATUS <span class="title function_">my_pre_callback</span><span class="params">(</span></span><br><span class="line"><span class="params">    PVOID RegistrationContext,</span></span><br><span class="line"><span class="params">    POB_PRE_OPERATION_INFORMATION OperationInformation</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">//KdPrint((&quot;zeroko:sys pEprocess = %p&quot;, OperationInformation-&gt;Object));</span></span><br><span class="line">    <span class="keyword">if</span> (OperationInformation-&gt;KernelHandle)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//内核层</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//用户层</span></span><br><span class="line">        <span class="comment">//只针对指定目标进程保护</span></span><br><span class="line">        HANDLE dwTargetPId = PsGetProcessId((PEPROCESS)OperationInformation-&gt;Object);<span class="comment">//获取目标进程pid</span></span><br><span class="line">        <span class="comment">//KdPrint((&quot;zeroko:sys: 目标pid:%d&quot;, dwTargetPId));</span></span><br><span class="line">        <span class="keyword">if</span> (isInProtectPidsVec(dwTargetPId))</span><br><span class="line">        &#123;</span><br><span class="line">            ACCESS_MASK newAccess = OperationInformation-&gt;Parameters-&gt;CreateHandleInformation.OriginalDesiredAccess;<span class="comment">//获取原始赋予的权限</span></span><br><span class="line">            <span class="comment">//去除某些权限</span></span><br><span class="line">            <span class="comment">//去除终止进程权限</span></span><br><span class="line">            newAccess &amp;= ~PROCESS_TERMINATE;</span><br><span class="line">            <span class="comment">//去除跨进程读进程权限</span></span><br><span class="line">            newAccess &amp;= ~PROCESS_VM_READ;</span><br><span class="line">            <span class="comment">//去除跨进程写进程权限</span></span><br><span class="line">            newAccess &amp;= ~PROCESS_VM_WRITE;</span><br><span class="line">            OperationInformation-&gt;Parameters-&gt;CreateHandleInformation.DesiredAccess = newAccess;<span class="comment">//更改要赋予的权限为我们处理过的权限</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OB_PREOP_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><h4 id="进程有哪些权限"><a href="#进程有哪些权限" class="headerlink" title="进程有哪些权限"></a><strong>进程有哪些权限</strong></h4><p>即使是任务管理器对进程进行操作,也需要获取对应进程权限才可以操作进程,因此如果用回调函数拦截了目标进程相应句柄的权限,则任务管理器也会无权限操作目标进程.</p>
<p>进程权限如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PROCESS_TERMINATE                  (0x0001)<span class="comment">//终止进程(任务管理器中如果在详细信息中对进程右键选择终止进程就需要用到此权限)  </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCESS_CREATE_THREAD              (0x0002)<span class="comment">//创建线程</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCESS_SET_SESSIONID              (0x0004)  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCESS_VM_OPERATION               (0x0008)  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCESS_VM_READ                    (0x0010)<span class="comment">//跨进程读目标进程 </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCESS_VM_WRITE                   (0x0020)<span class="comment">//跨进程写目标进程  </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCESS_DUP_HANDLE                 (0x0040)<span class="comment">//复制目标进程的句柄</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCESS_CREATE_PROCESS             (0x0080)<span class="comment">//创建进程</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCESS_SET_QUOTA                  (0x0100)<span class="comment">//设置一些进程的信息  </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCESS_SET_INFORMATION            (0x0200)  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCESS_QUERY_INFORMATION          (0x0400)<span class="comment">//查询进程的详细信息  </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCESS_SUSPEND_RESUME             (0x0800)<span class="comment">//进程挂起和恢复  </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCESS_QUERY_LIMITED_INFORMATION  (0x1000)  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCESS_SET_LIMITED_INFORMATION    (0x2000)  </span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (NTDDI_VERSION &gt;= NTDDI_VISTA)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCESS_ALL_ACCESS        (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | \</span></span><br><span class="line"><span class="meta">                                   0xFFFF)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCESS_ALL_ACCESS        (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | \</span></span><br><span class="line"><span class="meta">                                   0xFFF)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h4 id="驱动中通过进程对象结构体首地址获取进程名"><a href="#驱动中通过进程对象结构体首地址获取进程名" class="headerlink" title="驱动中通过进程对象结构体首地址获取进程名"></a>驱动中通过进程对象结构体首地址获取进程名</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面两个均只能获取到小于15字节的进程名    (EProcess是想获取的目标进程结构体首地址)</span></span><br><span class="line"><span class="type">char</span>* processName = (<span class="type">char</span>*)EProcess+<span class="number">0x174</span>;<span class="comment">//只知道win7可用,不能针对所有操作系统,0x174在部分版本windows系统可能不正确(可能!)</span></span><br><span class="line"><span class="type">char</span>* processName2 = PsGetProcessImageFileName(EProcess);</span><br><span class="line"><span class="comment">//PsGetProcessImageFileName是未导出的函数,需要如下声明:</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="title function_">PsGetProcessImageFileName</span><span class="params">(PEPROCESS arg1)</span>;</span><br></pre></td></tr></table></figure>

<p>即可以获取当前进程名(最多显示14个字节)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PsGetProcessImageFileName(PsGetCurrentProcess());</span><br></pre></td></tr></table></figure>

<p>获取当前进程pid函数: <code>PsGetCurrentProcessId</code></p>
<p>在系统回调中获取目标进程id</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HANDLE pid = PsGetProcessId((PEPROCESS)OperationInformation-&gt;OBject);</span><br></pre></td></tr></table></figure>

<h4 id="进程id获取进程名"><a href="#进程id获取进程名" class="headerlink" title="进程id获取进程名"></a>进程id获取进程名</h4><p>核心函数</p>
<ul>
<li>PsLookupProcessByProcessId      ObfDereferenceObject  (成对使用)</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="title function_">GetProcessNameByProcessId</span><span class="params">(HANDLE ProcessId)</span></span><br><span class="line">&#123;</span><br><span class="line">    NTSTATUS st = STATUS_UNSUCCESSFUL;</span><br><span class="line">    PEPROCESS ProcessObj = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* PNameString = <span class="literal">NULL</span>;</span><br><span class="line">    st = PsLookupProcessByProcessId(ProcessId, &amp;ProcessObj);</span><br><span class="line">    <span class="keyword">if</span> (NT_SUCCESS(st))</span><br><span class="line">    &#123;</span><br><span class="line">        PNameString = PsGetProcessImageFileName(ProcessObj);</span><br><span class="line">        ObfDereferenceObject(ProcessObj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> PNameString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="另一种实现方式"><a href="#另一种实现方式" class="headerlink" title="另一种实现方式"></a>另一种实现方式</h5><p>这种方式在注册OpenProcess系统回调函数中使用会蓝屏</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="title function_">GetProcessName</span><span class="params">(ULONG dwPid)</span></span><br><span class="line">&#123;</span><br><span class="line">    HANDLE ProcessHandle;</span><br><span class="line">    NTSTATUS status;</span><br><span class="line">    OBJECT_ATTRIBUTES ObjectAttributes;</span><br><span class="line">    CLIENT_ID myCid;</span><br><span class="line">    PEPROCESS EProcess;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* PsName = <span class="literal">NULL</span>;</span><br><span class="line">    InitializeObjectAttributes(&amp;ObjectAttributes, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    myCid.UniqueProcess = (HANDLE)dwPid;</span><br><span class="line">    myCid.UniqueThread = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//打开进程,获取句柄</span></span><br><span class="line">    status = ZwOpenProcess(&amp;ProcessHandle, PROCESS_ALL_ACCESS, &amp;ObjectAttributes,&amp;myCid);<span class="comment">//如果在注册OpenProcess系统回调中使用此函数,就会陷入循环无限调用的情况导致堆栈溢出</span></span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(status))</span><br><span class="line">    &#123;</span><br><span class="line">        KdPrint((<span class="string">&quot;zeroko:kernel:打开进程出错\n&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//得到EPROCESS结构,结构中取进程名</span></span><br><span class="line">    status = ObReferenceObjectByHandle(ProcessHandle,FILE_READ_DATA,<span class="number">0</span>,KernelMode,&amp;EProcess,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(status))</span><br><span class="line">    &#123;</span><br><span class="line">        PsName = PsGetProcessImageFileName(EProcess);</span><br><span class="line">        KdPrint((<span class="string">&quot;zeroko:kernel:PsName is %s&quot;</span>, PsName));</span><br><span class="line">        ZwClose(ProcessHandle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        KdReint((<span class="string">&quot;zeroko:kernel:Get ProcessName error&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> PsName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NtOpenProcess和ZwOpenProcess对应的函数地址实际上是同一个,只是符号不同.</p>
<p>如果在注册OpenProcess系统回调中使用此函数,就会陷入无限递归的死循环 <code>NtOpenProcess -&gt; my_pre_callback -&gt; GetProcessName -&gt; NtOpenProcess </code>,最终导致堆栈溢出蓝屏</p>
<h4 id="驱动中设置断点"><a href="#驱动中设置断点" class="headerlink" title="驱动中设置断点:"></a>驱动中设置断点:</h4><h5 id="代码的方式下断点"><a href="#代码的方式下断点" class="headerlink" title="代码的方式下断点"></a>代码的方式下断点</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DbgBreakPoint __debugbreak</span></span><br></pre></td></tr></table></figure>

<p>使用方式: <code>DbgBreakPoint();</code>或者 <code>__debugbreak();</code></p>
<h5 id="windbg直接下断点"><a href="#windbg直接下断点" class="headerlink" title="windbg直接下断点"></a>windbg直接下断点</h5><p><code>bu 模块名!函数名</code>   例如:  <code>bu mysys!testFunc</code>    <code>bp mysys!testFunc</code></p>
<h3 id="远程读写绕过系统回调保护"><a href="#远程读写绕过系统回调保护" class="headerlink" title="远程读写绕过系统回调保护"></a>远程读写绕过系统回调保护</h3><p>远程读写效率怎么都比不上内部读写</p>
<h4 id="进程挂靠的方式实现"><a href="#进程挂靠的方式实现" class="headerlink" title="进程挂靠的方式实现"></a>进程挂靠的方式实现</h4><p><strong>用到的核心函数</strong></p>
<ol>
<li>KeStackAttachProcess 进程挂靠  (直接修改CR3应该也可以)</li>
<li>KeUnstackDetachProcess 解除进程挂靠</li>
</ol>
<p>此处为内核申请一个过渡的内核内存,来临时存放要读的数据</p>
<h5 id="读进程"><a href="#读进程" class="headerlink" title="读进程"></a>读进程</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过pid读取目标内存,返回实际读到的字节数(用到自定义的KReadProcessMemory函数)</span></span><br><span class="line">BOOLEAN <span class="title function_">ReadProcessMemoryByPid</span><span class="params">(UINT32 dwPid, PVOID pBase, PVOID lpBuffer, UINT32 nSize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//根据pid获取PEPROCESS OpenProcess</span></span><br><span class="line">    PEPROCESS Seleted_pEPROCESS = <span class="literal">NULL</span>;</span><br><span class="line">    KdPrint((<span class="string">&quot;zeroko:kernel:ReadMemory pid=%d,pBase=%p  lineNo.%d  is in Func:%s\n&quot;</span>,dwPid,pBase,__LINE__,__FUNCDNAME__));</span><br><span class="line">    <span class="keyword">if</span> (PsLookupProcessByProcessId(dwPid,&amp;Seleted_pEPROCESS)==STATUS_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        BOOLEAN br = KReadProcessMemory(Seleted_pEPROCESS, pBase,nSize, lpBuffer);</span><br><span class="line">        ObDereferenceObject(Seleted_pEPROCESS);</span><br><span class="line">        <span class="keyword">if</span> (br)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        KdPrint((<span class="string">&quot;zeroko:kernel:PsLookupProcessByProcessId Fail...\n&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//apc方式系统回调保护读内存(Process 是要读的进程结构体指针,Address是要读的地址,Length是要读的长度,Buffer存放读到哪里)</span></span><br><span class="line"><span class="comment">//不借助于内核层和三环层的常规通信方式</span></span><br><span class="line">BOOLEAN <span class="title function_">KReadProcessMemory2</span><span class="params">(IN PEPROCESS Process, IN PVOID Address, IN UINT32 Length, IN OUT PVOID Buffer)</span></span><br><span class="line">&#123;</span><br><span class="line">    KAPC_STATE apc_state;</span><br><span class="line">    RtlZeroMemory(&amp;apc_state, <span class="keyword">sizeof</span>(KAPC_STATE));</span><br><span class="line">    <span class="comment">//申请内核空间  在所有进程间通用   (实际上可以不申请空间,如果是零环与三环通信的时候,直接把那个通信缓冲区拿来用就可以了)</span></span><br><span class="line">    PVOID tmpBuf_Kernel = ExAllocatePool(NonPagedPool, Length);</span><br><span class="line">    <span class="keyword">if</span> (!tmpBuf_Kernel) &#123;</span><br><span class="line">        KdPrint((<span class="string">&quot;zeroko:kernel:内核空间申请失败\n&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//也可以改MDL把 进程地址空间  映射到  内核驱动空间</span></span><br><span class="line">    <span class="comment">//中转内存地址中的内容,因为KeStackAttachProcess后,原来的进程R3 Buffer在目标地址里不存在(但如果是直接似乎内核内存,实际上不需要这一步)</span></span><br><span class="line">    <span class="comment">//RtlCopyMemory(tmpBuf_Kernel,Buffer,Length);</span></span><br><span class="line">    <span class="comment">//进入目标进程内存空间</span></span><br><span class="line">    KdPrint((<span class="string">&quot;zeroko:kernel:附加到目标进程Address = %p  BUffer=%p\n&quot;</span>,Address,Buffer));</span><br><span class="line">    KeStackAttachProcess((PVOID)Process, &amp;apc_state);</span><br><span class="line">    <span class="comment">//判断目标地址是否可以访问</span></span><br><span class="line">    BOOLEAN dwRet = MmIsAddressValid(Address);</span><br><span class="line">    <span class="keyword">if</span> (dwRet)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把要读的目标进程中地址对应的内容拷到内核空间中</span></span><br><span class="line">        RtlCopyMemory(tmpBuf_Kernel, Address, Length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        KdPrint((<span class="string">&quot;zeroko:kernel:Error Line37\n&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分离目标进程空间,恢复环境</span></span><br><span class="line">    KeUnstackDetachProcess(&amp;apc_state);</span><br><span class="line">    KdPrint((<span class="string">&quot;zeroko:kernel:分离目标进程\n&quot;</span>));</span><br><span class="line">    <span class="comment">//内核内存复制回原进程内存</span></span><br><span class="line">    RtlCopyMemory(Buffer, tmpBuf_Kernel, Length);</span><br><span class="line">    <span class="comment">//释放作为中转站的内核内存</span></span><br><span class="line">    ExFreePool(tmpBuf_Kernel);</span><br><span class="line">    <span class="keyword">return</span> dwRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//apc方式系统回调保护读内存(Process 是要读的进程结构体指针,Address是要读的地址,Length是要读的长度,Buffer存放读到哪里)</span></span><br><span class="line"><span class="comment">//借助于内核层和三环层的常规通信方式</span></span><br><span class="line">BOOLEAN <span class="title function_">KReadProcessMemory</span><span class="params">(IN PEPROCESS Process, IN PVOID Address, IN UINT32 Length, IN OUT PVOID Buffer)</span></span><br><span class="line">&#123;</span><br><span class="line">    KAPC_STATE apc_state;</span><br><span class="line">    RtlZeroMemory(&amp;apc_state, <span class="keyword">sizeof</span>(KAPC_STATE));</span><br><span class="line">    <span class="comment">//也可以改MDL把 进程地址空间  映射到  内核驱动空间</span></span><br><span class="line">    <span class="comment">//进入目标进程内存空间</span></span><br><span class="line">    KdPrint((<span class="string">&quot;zeroko:kernel:附加到目标进程Address = %p  BUffer=%p\n&quot;</span>, Address, Buffer));</span><br><span class="line">    KeStackAttachProcess((PVOID)Process, &amp;apc_state);</span><br><span class="line">    <span class="comment">//判断目标地址是否可以访问</span></span><br><span class="line">    BOOLEAN dwRet = MmIsAddressValid(Address);</span><br><span class="line">    <span class="keyword">if</span> (dwRet)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把要读的目标进程中地址对应的内容拷到内核空间中</span></span><br><span class="line">        RtlCopyMemory(Buffer, Address, Length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        KdPrint((<span class="string">&quot;zeroko:kernel:Error Line37\n&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分离目标进程空间,恢复环境</span></span><br><span class="line">    KeUnstackDetachProcess(&amp;apc_state);</span><br><span class="line">    <span class="comment">//KdPrint((&quot;zeroko:kernel:分离目标进程\n&quot;));</span></span><br><span class="line">    <span class="comment">//内核内存复制回原进程内存</span></span><br><span class="line">    <span class="keyword">return</span> dwRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="写进程"><a href="#写进程" class="headerlink" title="写进程"></a>写进程</h5><p>下面函数<strong>不能写只读内存</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//远程写(不可以写只读内存):将UserBuffer(用户传过来的内容的地址)写入Process进程的Address地址,内容长度为Length</span></span><br><span class="line">BOOLEAN <span class="title function_">KWriteProcessMemory</span><span class="params">(IN PEPROCESS Process, IN PVOID Address, IN UINT32 Length, IN PVOID UserBuffer)</span></span><br><span class="line">&#123;</span><br><span class="line">    KAPC_STATE apc_state;</span><br><span class="line">    RtlZeroMemory(&amp;apc_state, <span class="keyword">sizeof</span>(KAPC_STATE));</span><br><span class="line">    <span class="comment">//申请内核空间  在所有进程间通用   </span></span><br><span class="line">    PVOID tmpBuf_Kernel = ExAllocatePool(NonPagedPool, Length);</span><br><span class="line">    <span class="keyword">if</span> (!tmpBuf_Kernel) &#123;</span><br><span class="line">        KdPrint((<span class="string">&quot;zeroko:kernel:内核空间申请失败\n&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    BOOLEAN dwRet = MmIsAddressValid(UserBuffer);</span><br><span class="line">    <span class="keyword">if</span> (dwRet)</span><br><span class="line">    &#123;</span><br><span class="line">        RtlCopyMemory(tmpBuf_Kernel, UserBuffer, Length);<span class="comment">//真正的写操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        KdPrint((<span class="string">&quot;zeroko:kernel:UserBuffer memory Error Line37\n&quot;</span>));</span><br><span class="line">        ExFreePool(tmpBuf_Kernel);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//附加要写的目标进程</span></span><br><span class="line">    KeStackAttachProcess((PVOID)Process, &amp;apc_state);</span><br><span class="line">    dwRet = MmIsAddressValid(Address);</span><br><span class="line">    <span class="comment">//写入内存</span></span><br><span class="line">    <span class="keyword">if</span> (dwRet)</span><br><span class="line">    &#123;</span><br><span class="line">        RtlCopyMemory(Address, tmpBuf_Kernel, Length);<span class="comment">//真正的写操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        KdPrint((<span class="string">&quot;zeroko:kernel:Error Line37\n&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    KeUnstackDetachProcess(&amp;apc_state);</span><br><span class="line">    ExFreePool(tmpBuf_Kernel);</span><br><span class="line">    <span class="keyword">return</span> dwRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过id远程写,用到了自定义的KWriteProcessMemory函数</span></span><br><span class="line"><span class="comment">//对dwPid进程的pBase地址,写长度为nSize的在lpBuffer地址的内存</span></span><br><span class="line">BOOLEAN <span class="title function_">WriteProcessMemoryByPid</span><span class="params">(UINT32 dwPid, PVOID pBase, PVOID lpBuffer, UINT32 nSize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//根据pid获取PEPROCESS OpenProcess</span></span><br><span class="line">    PEPROCESS Seleted_pEPROCESS = <span class="literal">NULL</span>;</span><br><span class="line">    KdPrint((<span class="string">&quot;zeroko:kernel:WriteMemory pid=%d,pBase=%p  lineNo.%d  is in Func:%s\n&quot;</span>, dwPid, pBase, __LINE__, __FUNCDNAME__));</span><br><span class="line">    <span class="keyword">if</span> (PsLookupProcessByProcessId(dwPid, &amp;Seleted_pEPROCESS) == STATUS_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        BOOLEAN br = KWriteProcessMemory(Seleted_pEPROCESS, pBase, nSize, lpBuffer);</span><br><span class="line">        ObDereferenceObject(Seleted_pEPROCESS);</span><br><span class="line">        <span class="keyword">if</span> (br)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        KdPrint((<span class="string">&quot;zeroko:kernel:PsLookupProcessByProcessId Fail...\n&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接写入只读内存会蓝屏,下面有写只读内存的方式</p>
<h4 id="MDL方式"><a href="#MDL方式" class="headerlink" title="MDL方式"></a>MDL方式</h4><p>优势:对于大内存远程读取写入有速度优势</p>
<p>上述过渡的内核内存,可以使用MDL映射方式替代:</p>
<p><strong>用到的核心函数</strong></p>
<ol>
<li>IoAllocateMdl   申请映射内存描述信息  IoFreeMdl  释放映射内存描述信息</li>
<li>MmBuildMdlForNonPagedPool  把内存标记为非分页内存,防止数据因为内存不足而被迁移到硬盘上</li>
<li>MmMapLockedPages  锁定内存映射  MmUnmapLockedPages 解除内存映射锁定</li>
</ol>
<p>当不再需要 MDL描述的页的时,请调用<code>MmUnlockPages</code>将它们解除锁定,然后调用<code>IoFreeMdl</code> 来释放它们</p>
<h5 id="读内存"><a href="#读内存" class="headerlink" title="读内存"></a>读内存</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以不借助于内核层和三环层的常规通信方式</span></span><br><span class="line">BOOLEAN <span class="title function_">KReadProcessMemory3</span><span class="params">(IN PEPROCESS Process, IN PVOID Address, IN UINT32 Length, IN PVOID UserBuffer)</span></span><br><span class="line">&#123;</span><br><span class="line">    KAPC_STATE apc_state;</span><br><span class="line">    RtlZeroMemory(&amp;apc_state, <span class="keyword">sizeof</span>(KAPC_STATE));</span><br><span class="line">    <span class="comment">//为UserBuffer创建MDL内存描述</span></span><br><span class="line">    <span class="comment">//创建MDL来读取内存</span></span><br><span class="line">    PMDL g_pmdl = IoAllocateMdl(UserBuffer, Length, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!g_pmdl)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//标记为非分页内存,避免置换到硬盘上</span></span><br><span class="line">    MmBuildMdlForNonPagedPool(g_pmdl);</span><br><span class="line">    <span class="comment">//锁定,映射用户内存到内核内存    Mapped指向UserBuffer地址指向的同一个物理内存</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* Mapped = (<span class="type">unsigned</span> <span class="type">char</span>*)MmMapLockedPages(g_pmdl, KernelMode);</span><br><span class="line">    <span class="keyword">if</span> (!Mapped)<span class="comment">//映射失败</span></span><br><span class="line">    &#123;</span><br><span class="line">        IoFreeMdl(g_pmdl);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    KeStackAttachProcess((PVOID)Process, &amp;apc_state);</span><br><span class="line">    <span class="comment">//判断目标地址是否可访问</span></span><br><span class="line">    BOOLEAN dwRet = MmIsAddressValid(Address);</span><br><span class="line">    <span class="keyword">if</span> (dwRet)</span><br><span class="line">    &#123;</span><br><span class="line">        RtlCopyMemory(Mapped, Address, Length);<span class="comment">//此处实际上已经拷贝到想要的地址中去了.  写内存只需要调换此处的Mapped和Address</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        KdPrint((<span class="string">&quot;zeroko:kernel:Error Line37\n&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    KeUnstackDetachProcess(&amp;apc_state);</span><br><span class="line">    IoFreeMdl(g_pmdl);</span><br><span class="line">    <span class="comment">//MDL清理工作</span></span><br><span class="line">    <span class="comment">//释放MDL相关资源</span></span><br><span class="line">    MmUnmapLockedPages((PVOID)Mapped, g_pmdl);</span><br><span class="line">    IoFreeMdl(g_pmdl);</span><br><span class="line">    <span class="keyword">return</span> dwRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="写内存"><a href="#写内存" class="headerlink" title="写内存"></a>写内存</h5><p>三环是通过 <code>VirtualProtectEx</code> 或 <code>VirtualQueryEx</code> 函数来修改页面属性来达到写只读内存的目的(E.g. CE修改器就是采取这套方式)</p>
<p><strong>下面是可以用于写只读内存的驱动实现方式</strong></p>
<p>核心点是: <code>MmProbeAndLockPages</code> 将 <code>MdlFlags = MDL_WRITE_OPERATION | MDL_ALLOCATED_FIXED_SIZE | MDL_PAGES_LOCKED</code> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以用于写只读内存    将UserBuffer(用户传过来的内容的地址)写入Process进程的Address地址,内容长度为Length</span></span><br><span class="line">BOOLEAN <span class="title function_">KWriteProcessMemory</span><span class="params">(IN PEPROCESS Process, IN PVOID Address, IN UINT32 Length, IN PVOID UserBuffer)</span></span><br><span class="line">&#123;</span><br><span class="line">    KAPC_STATE apc_state;</span><br><span class="line">    RtlZeroMemory(&amp;apc_state, <span class="keyword">sizeof</span>(KAPC_STATE));</span><br><span class="line">    <span class="comment">//进程挂靠</span></span><br><span class="line">    KeStackAttachProcess((PVOID)Process, &amp;apc_state);</span><br><span class="line">    BOOLEAN dwRet = MmIsAddressValid(Address);</span><br><span class="line">    <span class="keyword">if</span> (!dwRet)</span><br><span class="line">    &#123;</span><br><span class="line">        KdPrint((<span class="string">&quot;zeroko:kernel: ERROR LINE%d\n&quot;</span>, __LINE__));</span><br><span class="line">        KeUnstackDetachProcess(&amp;apc_state);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//为UserBuffer创建MDL内存描述</span></span><br><span class="line">    PMDL g_pmdl = IoAllocateMdl(Address, Length, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!g_pmdl)</span><br><span class="line">    &#123;</span><br><span class="line">        KdPrint((<span class="string">&quot;zeroko:kernel: ERROR LINE%d\n&quot;</span>, __LINE__));</span><br><span class="line">        KeUnstackDetachProcess(&amp;apc_state);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//标记为非分页内存</span></span><br><span class="line">    MmBuildMdlForNonPagedPool(g_pmdl);</span><br><span class="line">    <span class="comment">//设置标志位</span></span><br><span class="line">    g_pmdl-&gt;MdlFlags = MDL_WRITE_OPERATION | MDL_ALLOCATED_FIXED_SIZE | MDL_PAGES_LOCKED; </span><br><span class="line">    <span class="comment">//锁定映射关系</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* Mapped = (<span class="type">unsigned</span> <span class="type">char</span>*)MmMapLockedPages(g_pmdl, KernelMode);</span><br><span class="line">    <span class="keyword">if</span> (!Mapped)</span><br><span class="line">    &#123;</span><br><span class="line">        KdPrint((<span class="string">&quot;zeroko:kernel: ERROR LINE%d\n&quot;</span>, __LINE__));</span><br><span class="line">        IoFreeMdl(g_pmdl);</span><br><span class="line">        KeUnstackDetachProcess(&amp;apc_state);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//映射成功后,退出挂靠环境</span></span><br><span class="line">    KeUnstackDetachProcess(&amp;apc_state);</span><br><span class="line">    RtlCopyMemory(Mapped, UserBuffer, Length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//恢复环境</span></span><br><span class="line">    MmUnmapLockedPages((PVOID)Mapped, g_pmdl);</span><br><span class="line">    IoFreeMdl(g_pmdl);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CR0方式写只读内存"><a href="#CR0方式写只读内存" class="headerlink" title="CR0方式写只读内存"></a>CR0方式写只读内存</h4><p>内存类型</p>
<ol>
<li>PagedPool   可以被置换到硬盘中,一般存储数据</li>
<li>NonPagedPool 不能被置换到硬盘中,驻留在内存中,一般用来存储代码</li>
</ol>
<p>如果执行代码到PagedPool的内存中很有可能蓝屏</p>
<p>在<strong>内核空间中所有内存都是可读可写可执行的</strong>,故没有类似用户态下的VirtualProtect改变内存属性的函数,但是并<strong>不意味着可以随意执行和改写内存中的代码,要满足2个条件</strong>:</p>
<ol>
<li>关闭内存写保护  通过操作CR0寄存器实现</li>
<li>提升IRQL级别(防止执行出错)     使用 <code>KeRaiseIrqlToDpcLevel</code>和 <code>KeLowerIrql</code> 实现</li>
</ol>
<p><code>__readcr0()函数</code> 需要头文件: <code>#include &lt;intrin.h&gt;</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关闭内存写保护和提升IRQL</span></span><br><span class="line">KIRQL irql = KeRaiseIrqlToDpcLevel();<span class="comment">//不提高中断等级无法写CR0</span></span><br><span class="line">UINT64 cr0 = __readcr0();</span><br><span class="line">cr0 &amp;= <span class="number">0xfffffffffffeffff</span>;</span><br><span class="line">__writecr0(cr0);</span><br><span class="line">_disable();</span><br><span class="line"></span><br><span class="line"><span class="comment">//还原  (开启内存写保护)</span></span><br><span class="line">UINT64 cr0 = __readcr0();</span><br><span class="line">cr0 |= <span class="number">0x10000</span>;</span><br><span class="line">_enable();</span><br><span class="line">KeLowerIrql(irql);</span><br><span class="line"><span class="comment">//内存操作放到二者之间就可以正常操作内存了</span></span><br></pre></td></tr></table></figure>

<h4 id="物理内存读写内存方法"><a href="#物理内存读写内存方法" class="headerlink" title="物理内存读写内存方法"></a>物理内存读写内存方法</h4><p>物理内存读写内存速度比较慢,不建议用于频繁地读写内存,<strong>一般用于注入代码</strong></p>
<h5 id="核心函数"><a href="#核心函数" class="headerlink" title="核心函数"></a><strong>核心函数</strong></h5><ul>
<li><code>ZwMapViewOfSection</code> 把物理地址映射到当前进程 </li>
<li><code>ZeUnmapViewOfSection</code>  取消映射</li>
<li><code>MmGetPhysicalAddress</code> 虚拟地址转换为物理地址</li>
</ul>
<h6 id="ZwMapViewOfSection"><a href="#ZwMapViewOfSection" class="headerlink" title="ZwMapViewOfSection"></a>ZwMapViewOfSection</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NTSYSAPI NTSTATUS <span class="title function_">ZwMapViewOfSection</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]                HANDLE          SectionHandle,</span></span><br><span class="line"><span class="params">  [in]                HANDLE          ProcessHandle,</span></span><br><span class="line"><span class="params">  [in, out]           PVOID           *BaseAddress,<span class="comment">//映射后返回出来的虚拟地址</span></span></span><br><span class="line"><span class="params">  [in]                ULONG_PTR       ZeroBits,</span></span><br><span class="line"><span class="params">  [in]                SIZE_T          CommitSize,<span class="comment">//想要映射的字节大小</span></span></span><br><span class="line"><span class="params">  [in, out, optional] PLARGE_INTEGER  SectionOffset,<span class="comment">//要映射的物理地址</span></span></span><br><span class="line"><span class="params">  [in, out]           PSIZE_T         ViewSize,<span class="comment">//实际映射的字节大小</span></span></span><br><span class="line"><span class="params">  [in]                SECTION_INHERIT InheritDisposition,</span></span><br><span class="line"><span class="params">  [in]                ULONG           AllocationType,</span></span><br><span class="line"><span class="params">  [in]                ULONG           Win32Protect</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<h5 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h5><h6 id="最外层的读写内存接口"><a href="#最外层的读写内存接口" class="headerlink" title="最外层的读写内存接口"></a>最外层的读写内存接口</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读dwPid中的pBase地址中长nSize的值搭配lpBuffer地址中</span></span><br><span class="line">BOOLEAN <span class="title function_">ReadPhysicalMemoryByPid</span><span class="params">(UINT32 dwPid, PVOID pBase, PVOID lpBuffer, UINT32 nSize)</span></span><br><span class="line">&#123;</span><br><span class="line">    PVOID physicalAddress = GetPhysicalAddress(dwPid, pBase);</span><br><span class="line">    KdPrint((<span class="string">&quot;zeroko:kernel:获取到的物理地址为%llx\n&quot;</span>, physicalAddress));</span><br><span class="line">    <span class="keyword">if</span> (physicalAddress)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ReadPhysicalMemory(physicalAddress, nSize, lpBuffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将lpBuffer地址中长nSize的值写到dwPid中的pBase地址</span></span><br><span class="line">BOOLEAN <span class="title function_">WritePhysicalMemoryByPid</span><span class="params">(UINT32 dwPid, PVOID pBase, PVOID lpBuffer, UINT32 nSize)</span></span><br><span class="line">&#123;</span><br><span class="line">    PVOID physicalAddress = GetPhysicalAddress(dwPid, pBase);</span><br><span class="line">    KdPrint((<span class="string">&quot;zeroko:kernel:获取到的物理地址为%llx\n&quot;</span>, physicalAddress));</span><br><span class="line">    <span class="keyword">if</span> (physicalAddress)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> WritePhysicalMemory(physicalAddress, nSize, lpBuffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="获取最大物理地址函数"><a href="#获取最大物理地址函数" class="headerlink" title="获取最大物理地址函数"></a>获取最大物理地址函数</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">UINT64 g_maxPhysAddress = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//利用cpuid取出 物理地址Bits</span></span><br><span class="line"><span class="comment">//获取最大的物理地址</span></span><br><span class="line">UINT64 <span class="title function_">getg_maxPhysAddress</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (g_maxPhysAddress == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> physicalbits;</span><br><span class="line">        UINT32 r[<span class="number">4</span>]; <span class="comment">//四个整数的数组，包含在 EAX、EBX、ECX 和 EDX 中返回的有关 CPU 支持的功能的信息</span></span><br><span class="line">        __cpuid(r, <span class="number">0x80000008</span>); <span class="comment">//只有r[0]的前 8位和 8至15们有用 后边3个 全保留</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//get max physical address</span></span><br><span class="line">        physicalbits = r[<span class="number">0</span>] &amp; <span class="number">0xff</span>;</span><br><span class="line"></span><br><span class="line">        g_maxPhysAddress = <span class="number">0xFFFFFFFFFFFFFFFF</span>ULL;</span><br><span class="line">        g_maxPhysAddress = g_maxPhysAddress &gt;&gt; physicalbits; <span class="comment">//if physicalbits==36 then g_maxPhysAddress=0x000000000fffffff</span></span><br><span class="line">        g_maxPhysAddress = ~(g_maxPhysAddress &lt;&lt; physicalbits); <span class="comment">//&lt;&lt; 36 = 0xfffffff000000000 .  after inverse : 0x0000000fffffffff		</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> g_maxPhysAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="获取物理地址的值函数"><a href="#获取物理地址的值函数" class="headerlink" title="获取物理地址的值函数"></a>获取物理地址的值函数</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将ProcessId目标进程中的虚拟地址转为物理地址</span></span><br><span class="line">PVOID <span class="title function_">GetPhysicalAddress</span><span class="params">(UINT64 ProcessId, PVOID vBaseAddress)</span></span><br><span class="line">&#123;</span><br><span class="line">    PEPROCESS selectedProcess;<span class="comment">//ProcessId的进程对象</span></span><br><span class="line">    PHYSICAL_ADDRESS physical;</span><br><span class="line">    physical.QuadPart = <span class="number">0</span>;<span class="comment">//PHYSICAL_ADDRESS实际上就是INT64 8字节</span></span><br><span class="line">    NTSTATUS ntStatus = STATUS_SUCCESS;</span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (PsLookupProcessByProcessId((PVOID)(ProcessId), &amp;selectedProcess)==STATUS_SUCCESS)</span><br><span class="line">        &#123;</span><br><span class="line">            KAPC_STATE apc_state;</span><br><span class="line">            RtlZeroMemory(&amp;apc_state, <span class="keyword">sizeof</span>(apc_state));</span><br><span class="line">            KeStackAttachProcess((PVOID)selectedProcess, &amp;apc_state);<span class="comment">//关键地方,附加到指定进程</span></span><br><span class="line">            __try</span><br><span class="line">            &#123;</span><br><span class="line">                physical = MmGetPhysicalAddress((PVOID)vBaseAddress);<span class="comment">//把虚拟地址转换为物理地址</span></span><br><span class="line">            &#125;</span><br><span class="line">            __finally</span><br><span class="line">            &#123;</span><br><span class="line">                KeUnstackDetachProcess(&amp;apc_state);</span><br><span class="line">            &#125;</span><br><span class="line">            ObDereferenceObject(selectedProcess);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __except (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ntStatus = STATUS_UNSUCCESSFUL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ntStatus == STATUS_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (PVOID)physical.QuadPart;<span class="comment">//返回物理地址</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">//失败返回NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="物理内存读写函数"><a href="#物理内存读写函数" class="headerlink" title="物理内存读写函数"></a>物理内存读写函数</h6><p><strong>读函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于分页内存来说，调用MmProbeAndLockPages以及MmGetSystemAddressForMdlSafe来锁定内存页，以防止被page out出去；</span></span><br><span class="line"><span class="comment">//对于非分页内存而言，调用MmBuildMdlForNonPagedPool映射到物理内存上。</span></span><br><span class="line"><span class="comment">//__noop((&quot;zeroko:kernel:Too small map&quot;));</span></span><br><span class="line"><span class="comment">//physicalBase本身就是物理地址</span></span><br><span class="line"><span class="comment">//读取物理地址的值physicalBase,读到output地址中,读bytestoread长度</span></span><br><span class="line">BOOLEAN <span class="title function_">ReadPhysicalMemory</span><span class="params">(<span class="type">char</span>* physicalBase, UINT_PTR bytestoread, <span class="type">void</span>* output)</span></span><br><span class="line">&#123;</span><br><span class="line">    UNICODE_STRING	physmemString;</span><br><span class="line">    OBJECT_ATTRIBUTES attributes;</span><br><span class="line">    HANDLE	physmem = <span class="literal">NULL</span>;</span><br><span class="line">    UCHAR* vaddress; <span class="comment">// 用于映射后的虚地址 供访问</span></span><br><span class="line">    KdPrint((<span class="string">&quot;zeroko:kernel:要读的物理地址为%llx  最大物理地址为%llx \n&quot;</span>, physicalBase, getg_maxPhysAddress()));</span><br><span class="line">    <span class="comment">//校验是否超过最大物理内存</span></span><br><span class="line">    <span class="keyword">if</span> (((UINT64)physicalBase &gt; getg_maxPhysAddress()) || ((UINT64)physicalBase + bytestoread &gt; getg_maxPhysAddress()))</span><br><span class="line">    &#123;</span><br><span class="line">        KdPrint((<span class="string">&quot;zeroko:kernel: Invalid physical address\n&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//初始化映射物理内存需要用到的数据</span></span><br><span class="line">        RtlInitUnicodeString(&amp;physmemString, <span class="string">L&quot;\\device\\physicalmemory&quot;</span>);<span class="comment">//要访问物理内存,需要用到该设备描述</span></span><br><span class="line">        InitializeObjectAttributes(&amp;attributes,&amp;physmemString, OBJ_CASE_INSENSITIVE, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        NTSTATUS ntStatus = ZwOpenSection(&amp;physmem, SECTION_ALL_ACCESS, &amp;attributes);</span><br><span class="line">        <span class="keyword">if</span> (ntStatus == STATUS_SUCCESS)</span><br><span class="line">        &#123;</span><br><span class="line">            PHYSICAL_ADDRESS	viewBase;<span class="comment">//物理内存地址</span></span><br><span class="line">            viewBase.QuadPart = (ULONGLONG)(physicalBase);</span><br><span class="line">            KdPrint((<span class="string">&quot;zeroko:kernel:ReadPhysicalMemory:viewBase.QuadPart=%x&quot;</span>, viewBase.QuadPart));</span><br><span class="line">            SIZE_T length = bytestoread;</span><br><span class="line">            <span class="comment">//映射物理内存地址到当前进程的虚地址空间</span></span><br><span class="line">            ntStatus = ZwMapViewOfSection(</span><br><span class="line">                physmem,  <span class="comment">//sectionhandle</span></span><br><span class="line">                NtCurrentProcess(), <span class="comment">//processhandle (should be -1)</span></span><br><span class="line">                &amp;vaddress, <span class="comment">//BaseAddress 映射产生的虚拟地址</span></span><br><span class="line">                <span class="number">0L</span>, <span class="comment">//ZeroBits</span></span><br><span class="line">                length, <span class="comment">//CommitSize</span></span><br><span class="line">                &amp;viewBase, <span class="comment">//SectionOffset  要映射的物理地址</span></span><br><span class="line">                &amp;length, <span class="comment">//ViewSize</span></span><br><span class="line">                ViewShare,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                PAGE_READWRITE);</span><br><span class="line">            <span class="comment">//映射成功的话</span></span><br><span class="line">            <span class="keyword">if</span> (ntStatus == STATUS_SUCCESS &amp;&amp; vaddress != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//实际映射的长度大于要写入的内容长度</span></span><br><span class="line">                <span class="keyword">if</span> (bytestoread &gt; length)</span><br><span class="line">                &#123;</span><br><span class="line">                    KdPrint((<span class="string">&quot;zeroko:kernel:Too small map\n&quot;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//真正的读操作</span></span><br><span class="line">                    RtlCopyMemory(output, vaddress, bytestoread);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//解除映射</span></span><br><span class="line">                ZwUnmapViewOfSection(NtCurrentProcess(), vaddress);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __except (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        KdPrint((<span class="string">&quot;zeroko:kernel:Failure mapping physical memory&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭节对象</span></span><br><span class="line">    ZwClose(physmem);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>写函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写物理地址函数</span></span><br><span class="line"><span class="comment">//将input地址的长度为nSizeWrite的内存写到physicalBase物理地址中</span></span><br><span class="line">BOOLEAN <span class="title function_">WritePhysicalMemory</span><span class="params">(<span class="type">char</span>* physicalBase, IN UINT_PTR nSizeWrite, IN PVOID input)</span></span><br><span class="line">&#123;</span><br><span class="line">    UNICODE_STRING	physmemString;</span><br><span class="line">    OBJECT_ATTRIBUTES attributes;</span><br><span class="line">    HANDLE	physmem = <span class="literal">NULL</span>;</span><br><span class="line">    UCHAR* vaddress; <span class="comment">// 用于映射后的虚地址 供访问</span></span><br><span class="line">    <span class="comment">//校验是否超过最大物理内存</span></span><br><span class="line">    <span class="keyword">if</span> (((UINT64)physicalBase &gt; getg_maxPhysAddress()) || ((UINT64)physicalBase + nSizeWrite &gt; getg_maxPhysAddress()))</span><br><span class="line">    &#123;</span><br><span class="line">        KdPrint((<span class="string">&quot;zeroko:kernel: Invalid physical address\n&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//初始化映射物理内存需要用到的数据</span></span><br><span class="line">        RtlInitUnicodeString(&amp;physmemString, <span class="string">L&quot;\\device\\physicalmemory&quot;</span>);<span class="comment">//要访问物理内存,需要用到该设备描述</span></span><br><span class="line">        InitializeObjectAttributes(&amp;attributes, &amp;physmemString, OBJ_CASE_INSENSITIVE, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        NTSTATUS ntStatus = ZwOpenSection(&amp;physmem, SECTION_ALL_ACCESS, &amp;attributes);</span><br><span class="line">        <span class="keyword">if</span> (ntStatus == STATUS_SUCCESS)</span><br><span class="line">        &#123;</span><br><span class="line">            PHYSICAL_ADDRESS	viewBase;<span class="comment">//物理内存地址</span></span><br><span class="line">            viewBase.QuadPart = (ULONGLONG)(physicalBase);</span><br><span class="line">          KdPrint((<span class="string">&quot;zeroko:kernel:ReadPhysicalMemory:viewBase.QuadPart=%x&quot;</span>, viewBase.QuadPart));</span><br><span class="line">            SIZE_T length = <span class="number">0x2000</span>;</span><br><span class="line">            <span class="comment">//映射物理内存地址到当前进程的虚地址空间</span></span><br><span class="line">            ntStatus = ZwMapViewOfSection(</span><br><span class="line">                physmem,  <span class="comment">//sectionhandle</span></span><br><span class="line">                NtCurrentProcess(), <span class="comment">//processhandle (should be -1)</span></span><br><span class="line">                &amp;vaddress, <span class="comment">//BaseAddress 映射产生的虚拟地址</span></span><br><span class="line">                <span class="number">0L</span>, <span class="comment">//ZeroBits</span></span><br><span class="line">                length, <span class="comment">//CommitSize</span></span><br><span class="line">                &amp;viewBase, <span class="comment">//SectionOffset  要映射的物理地址</span></span><br><span class="line">                &amp;length, <span class="comment">//ViewSize</span></span><br><span class="line">                ViewShare,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                PAGE_READWRITE);</span><br><span class="line">            <span class="comment">//映射成功的话</span></span><br><span class="line">            <span class="keyword">if</span> (ntStatus == STATUS_SUCCESS &amp;&amp; vaddress != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//实际映射的长度大于要写入的内容长度</span></span><br><span class="line">                <span class="keyword">if</span> (nSizeWrite &gt; length)</span><br><span class="line">                &#123;</span><br><span class="line">                    KdPrint((<span class="string">&quot;zeroko:kernel:Too small map\n&quot;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//真正的写操作</span></span><br><span class="line">                    RtlCopyMemory(vaddress, input, nSizeWrite);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//解除映射</span></span><br><span class="line">                ZwUnmapViewOfSection(NtCurrentProcess(), vaddress);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __except (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        KdPrint((<span class="string">&quot;zeroko:kernel:Failure mapping physical memory&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭节对象</span></span><br><span class="line">    ZwClose(physmem);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="针对对象回调钩子的操作"><a href="#针对对象回调钩子的操作" class="headerlink" title="针对对象回调钩子的操作"></a>针对对象回调钩子的操作</h2><h3 id="遍历进程-线程对象钩子"><a href="#遍历进程-线程对象钩子" class="headerlink" title="遍历进程&#x2F;线程对象钩子"></a>遍历进程&#x2F;线程对象钩子</h3><p><strong>兼容win7~win10</strong></p>
<h4 id="需要用的自定义结构和变量"><a href="#需要用的自定义结构和变量" class="headerlink" title="需要用的自定义结构和变量"></a>需要用的自定义结构和变量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//=================================</span></span><br><span class="line"><span class="comment">//下面开始遍历系统回调钩子</span></span><br><span class="line"><span class="comment">//=================================</span></span><br><span class="line"><span class="comment">//需要用到的自定义结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">CALL_BACK_INFO</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ULONG64 Unknow;</span><br><span class="line">    ULONG64 Unknow1;</span><br><span class="line">    UNICODE_STRING AltitudeString;<span class="comment">//该成员决定执行顺序,越大越早被执行</span></span><br><span class="line">    LIST_ENTRY NextEntryItemList; <span class="comment">//(callbacklist) 跟上面开头的那个一样 存储下一个callbacklist</span></span><br><span class="line">    ULONG64 Operations;</span><br><span class="line">    PVOID ObHandle; <span class="comment">//存储详细的数据 版本号 POB_OPERATION_REGISTRATION AltitudeString 也就是本身节点CALL_BACK_INFO 注销时也使用这个 注意是指针 //CALL_BACK_INFO</span></span><br><span class="line">    PVOID ObjectType;</span><br><span class="line">    ULONG64 PreCallbackAddr;</span><br><span class="line">    ULONG64 PostCallbackAddr;</span><br><span class="line">&#125;CALL_BACK_INFO, * PCALL_BACK_INFO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OB_CALLBACK</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    LIST_ENTRY	ListEntry;<span class="comment">//链表结构</span></span><br><span class="line">    ULONG64		Operations;</span><br><span class="line">    PCALL_BACK_INFO		ObHandle;<span class="comment">//该结构指向上面的结构</span></span><br><span class="line">    ULONG64		ObjTypeAddr;</span><br><span class="line">    ULONG64		PreCall;<span class="comment">//前回调函数</span></span><br><span class="line">    ULONG64		PostCall;<span class="comment">//后回调函数</span></span><br><span class="line">&#125; OB_CALLBACK, * POB_CALLBACK;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> ULONG ObjectCallbackListOffset = <span class="number">0</span>;<span class="comment">//win7的该偏移与win10有差异</span></span><br><span class="line"><span class="keyword">extern</span> PSHORT NtBuildNumber;<span class="comment">//导出的内部版本号地址</span></span><br></pre></td></tr></table></figure>

<h4 id="遍历回调需要用到的自定义子函数-包含依赖关系"><a href="#遍历回调需要用到的自定义子函数-包含依赖关系" class="headerlink" title="遍历回调需要用到的自定义子函数(包含依赖关系)"></a>遍历回调需要用到的自定义子函数(包含依赖关系)</h4><ul>
<li><code>GetVersionAndHardCode</code>  </li>
<li><code>GetPsLoadedListModule</code>  获取模块链表头<ul>
<li><code>GetUndocumentFunctionAddress</code>  通过函数名获取未文档化的函数地址</li>
<li><code>GetMovPoint</code></li>
</ul>
</li>
<li><code>ObGetDriverNameByPoint</code>   通过地址,获取对应模块的模块名</li>
</ul>
<p>(上面子函数具备通用性的有文字描述)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取版本和对应的硬编码(EnumObRegisterCallBacks函数需要用到的子函数)</span></span><br><span class="line">BOOLEAN <span class="title function_">GetVersionAndHardCode</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    BOOLEAN b = FALSE;</span><br><span class="line">    <span class="keyword">switch</span> (*NtBuildNumber)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7600</span>:<span class="comment">//win7</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">7601</span>:<span class="comment">//win7</span></span><br><span class="line">    &#123;</span><br><span class="line">        ObjectCallbackListOffset = <span class="number">0xC0</span>;</span><br><span class="line">        b = TRUE;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">9200</span>:<span class="comment">//win8</span></span><br><span class="line">    &#123;</span><br><span class="line">        ObjectCallbackListOffset = <span class="number">0xC8</span>;	<span class="comment">//OBJECT_TYPE.CallbackList</span></span><br><span class="line">        b = TRUE;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">9600</span>:<span class="comment">//win8</span></span><br><span class="line">    &#123;</span><br><span class="line">        ObjectCallbackListOffset = <span class="number">0xC8</span>;	<span class="comment">//OBJECT_TYPE.CallbackList</span></span><br><span class="line">        b = TRUE;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">if</span> (*NtBuildNumber &gt; <span class="number">10000</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ObjectCallbackListOffset = <span class="number">0xc8</span>;</span><br><span class="line">            b = TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取未文档化的函数  </span></span><br><span class="line"><span class="comment">//win7获取函数链表头需要用到的函数(GetPsLoadedListModule用到的子函数)</span></span><br><span class="line">PVOID <span class="title function_">GetUndocumentFunctionAddress</span><span class="params">(IN PUNICODE_STRING pFunName,</span></span><br><span class="line"><span class="params">    IN PUCHAR pStartAddress,</span></span><br><span class="line"><span class="params">    IN UCHAR* pFeatureCode,</span></span><br><span class="line"><span class="params">    IN ULONG FeatureCodeNum,</span></span><br><span class="line"><span class="params">    ULONG SerSize,</span></span><br><span class="line"><span class="params">    UCHAR SegCode,</span></span><br><span class="line"><span class="params">    ULONG AddNum,</span></span><br><span class="line"><span class="params">    BOOLEAN ByName)</span></span><br><span class="line">&#123;</span><br><span class="line">    ULONG dwIndex = <span class="number">0</span>;</span><br><span class="line">    PUCHAR pFunAddress = <span class="literal">NULL</span>;</span><br><span class="line">    ULONG dwCodeNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (pFeatureCode == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (FeatureCodeNum &gt;= <span class="number">15</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (SerSize &gt; <span class="number">0x1024</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (ByName)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pFunName == <span class="literal">NULL</span> || !MmIsAddressValid(pFunName-&gt;Buffer))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        pFunAddress = (PUCHAR)MmGetSystemRoutineAddress(pFunName);</span><br><span class="line">        <span class="keyword">if</span> (pFunAddress == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pStartAddress == <span class="literal">NULL</span> || !MmIsAddressValid(pStartAddress))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        pFunAddress = pStartAddress;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (dwIndex = <span class="number">0</span>; dwIndex &lt; SerSize; dwIndex++)</span><br><span class="line">    &#123;</span><br><span class="line">        __try</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pFunAddress[dwIndex] == pFeatureCode[dwCodeNum] || pFeatureCode[dwCodeNum] == SegCode)</span><br><span class="line">            &#123;</span><br><span class="line">                dwCodeNum++;</span><br><span class="line">                <span class="keyword">if</span> (dwCodeNum == FeatureCodeNum)</span><br><span class="line">                    <span class="keyword">return</span> pFunAddress + dwIndex - dwCodeNum + <span class="number">1</span> + AddNum;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dwCodeNum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        __except (EXCEPTION_EXECUTE_HANDLER)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//win7获取函数链表头需要用到的函数(GetPsLoadedListModule用到的子函数)</span></span><br><span class="line">PVOID <span class="title function_">GetMovPoint</span><span class="params">(PVOID pCallPoint)</span></span><br><span class="line">&#123;</span><br><span class="line">    ULONG dwOffset = <span class="number">0</span>;</span><br><span class="line">    ULONG_PTR returnAddress = <span class="number">0</span>;</span><br><span class="line">    LARGE_INTEGER returnAddressTemp = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    PUCHAR pFunAddress = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pCallPoint == <span class="literal">NULL</span> || !MmIsAddressValid(pCallPoint))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    pFunAddress = pCallPoint;</span><br><span class="line">    <span class="comment">// 函数偏移  </span></span><br><span class="line">    RtlCopyMemory(&amp;dwOffset, (PVOID)(pFunAddress + <span class="number">3</span>), <span class="keyword">sizeof</span>(ULONG));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// JMP向上跳转  </span></span><br><span class="line">    <span class="keyword">if</span> ((dwOffset &amp; <span class="number">0x10000000</span>) == <span class="number">0x10000000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dwOffset = dwOffset + <span class="number">7</span> + pFunAddress;</span><br><span class="line">        returnAddressTemp.QuadPart = (ULONG_PTR)pFunAddress &amp; <span class="number">0xFFFFFFFF00000000</span>;</span><br><span class="line">        returnAddressTemp.LowPart = dwOffset;</span><br><span class="line">        returnAddress = returnAddressTemp.QuadPart;</span><br><span class="line">        <span class="keyword">return</span> (PVOID)returnAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    returnAddress = (ULONG_PTR)dwOffset + <span class="number">7</span> + pFunAddress;</span><br><span class="line">    <span class="keyword">return</span> (PVOID)returnAddress;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取模块链表头地址(ObGetDriverNameByPoint函数需要用到的子函数)</span></span><br><span class="line">PVOID <span class="title function_">GetPsLoadedListModule</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    为什么不使用DriverObject去枚举呢 主要是win10这玩意导出了 追随步伐啊 哈哈</span></span><br><span class="line"><span class="comment">    RtlPcToFileHeader</span></span><br><span class="line"><span class="comment">    text:000000014015D6A3 48 8B 0D 86 50 0E 00                          mov     rcx, qword ptr cs:PsLoadedModuleList</span></span><br><span class="line"><span class="comment">    .text:000000014015D6AA 48 85 C9                                      test    rcx, rcx</span></span><br><span class="line"><span class="comment">    .text:000000014015D6AD 74 28                                         jz      short loc_14015D6D7</span></span><br><span class="line"><span class="comment">    .text:000000014015D6AF 48 8D 15 7A 50 0E 00                          lea     rdx, PsLoadedModuleList</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    UNICODE_STRING usRtlPcToFileHeader = RTL_CONSTANT_STRING(<span class="string">L&quot;RtlPcToFileHeader&quot;</span>);</span><br><span class="line">    UNICODE_STRING usPsLoadedModuleList = RTL_CONSTANT_STRING(<span class="string">L&quot;PsLoadedModuleList&quot;</span>);</span><br><span class="line">    PVOID Point = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">static</span> PVOID PsLoadedListModule = <span class="literal">NULL</span>;</span><br><span class="line">    UCHAR shellcode[<span class="number">11</span>] =</span><br><span class="line">        <span class="string">&quot;\x48\x8b\x0d\x60\x60\x60\x60&quot;</span></span><br><span class="line">        <span class="string">&quot;\x48\x85\xc9&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (PsLoadedListModule)</span><br><span class="line">        <span class="keyword">return</span> PsLoadedListModule;</span><br><span class="line">    <span class="comment">//win10直接就导出了</span></span><br><span class="line">    <span class="keyword">if</span> (*NtBuildNumber &gt; <span class="number">9600</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// win10 PsLoadedModuleList导出</span></span><br><span class="line">        PsLoadedListModule = MmGetSystemRoutineAddress(&amp;usPsLoadedModuleList);</span><br><span class="line">        <span class="keyword">return</span> PsLoadedListModule;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//win7未导出,相对麻烦</span></span><br><span class="line">    Point = GetUndocumentFunctionAddress(&amp;usRtlPcToFileHeader, <span class="literal">NULL</span>, shellcode, <span class="number">10</span>, <span class="number">0xff</span>, <span class="number">0x60</span>, <span class="number">0</span>, TRUE);</span><br><span class="line">    <span class="keyword">if</span> (Point == <span class="literal">NULL</span> || !MmIsAddressValid(Point))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    Point = GetMovPoint(Point);</span><br><span class="line">    <span class="keyword">if</span> (Point == <span class="literal">NULL</span> || !MmIsAddressValid(Point))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    PsLoadedListModule = Point;</span><br><span class="line">    <span class="keyword">return</span> PsLoadedListModule;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过某地址,获得该地址所处的模块对应的模块名(主要用于判断回调函数地址属于哪个模块)</span></span><br><span class="line"><span class="comment">//(EnumObRegisterCallBacks函数需要用到的子函数)</span></span><br><span class="line">BOOLEAN <span class="title function_">ObGetDriverNameByPoint</span><span class="params">(ULONG_PTR Point, OUT WCHAR* szDriverName)</span></span><br><span class="line">&#123;</span><br><span class="line">    PLDR_DATA_TABLE_ENTRY Begin = <span class="literal">NULL</span>;</span><br><span class="line">    PLIST_ENTRY Head = <span class="literal">NULL</span>;</span><br><span class="line">    PLIST_ENTRY Next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取模块链表头</span></span><br><span class="line">    Begin = GetPsLoadedListModule();</span><br><span class="line">    <span class="comment">//开始遍历模块链表</span></span><br><span class="line">    <span class="keyword">if</span> (Begin == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    Head = (PLIST_ENTRY)Begin-&gt;InLoadOrderLinks.Flink;</span><br><span class="line">    Next = Head-&gt;Flink;</span><br><span class="line">    <span class="comment">//遍历模块地址,判断地址是处于哪个模块</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        PLDR_DATA_TABLE_ENTRY Entry = CONTAINING_RECORD(Next, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);</span><br><span class="line">        Next = Next-&gt;Flink;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((ULONG_PTR)Entry-&gt;DllBase &lt;= Point &amp;&amp; Point &lt;= ((ULONG_PTR)Entry-&gt;DllBase + Entry-&gt;SizeOfImage))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (szDriverName == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> FALSE;</span><br><span class="line">            RtlZeroMemory(szDriverName, <span class="number">600</span>);</span><br><span class="line">            RtlCopyMemory(szDriverName, Entry-&gt;BaseDllName.Buffer, Entry-&gt;BaseDllName.Length);</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (Next != Head-&gt;Flink);<span class="comment">//循环链表,如果下一个指针再次指向首节点,则遍历结束</span></span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="遍历回调函数"><a href="#遍历回调函数" class="headerlink" title="遍历回调函数"></a>遍历回调函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历所有 进程  线程  注册的ObRegisterCallBacks回调</span></span><br><span class="line">ULONG <span class="title function_">EnumObRegisterCallBacks</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ULONG c = <span class="number">0</span>;<span class="comment">//回调个数计数</span></span><br><span class="line">    PLIST_ENTRY CurrEntry = <span class="literal">NULL</span>;</span><br><span class="line">    POB_CALLBACK pObCallback;</span><br><span class="line">    ULONG64 ObProcessCallbackListHead = <span class="number">0</span>;</span><br><span class="line">    ULONG64 ObThreadCallbackListHead = <span class="number">0</span>;</span><br><span class="line">    WCHAR* szDriverBaseName = <span class="literal">NULL</span>;</span><br><span class="line">    szDriverBaseName = ExAllocatePool(NonPagedPool, <span class="number">600</span>);</span><br><span class="line">    <span class="keyword">if</span> (szDriverBaseName == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    RtlZeroMemory(szDriverBaseName, <span class="number">600</span>);</span><br><span class="line">    GetVersionAndHardCode();</span><br><span class="line">    <span class="comment">//PsProcessType和PsThreadType是导出的,直接使用   ObjectCallbackListOffset和ObjectCallbackListOffset需要自己计算出来</span></span><br><span class="line">    ObProcessCallbackListHead = *(ULONG64*)PsProcessType + ObjectCallbackListOffset;<span class="comment">//获取进程链表头</span></span><br><span class="line">    ObThreadCallbackListHead = *(ULONG64*)PsThreadType + ObjectCallbackListOffset;<span class="comment">//获取线程链表头</span></span><br><span class="line">    <span class="comment">//遍历进程回调</span></span><br><span class="line">    KdPrint((<span class="string">&quot;zeroko:kernel:进程对象回调:\n&quot;</span>));</span><br><span class="line">    CurrEntry = ((PLIST_ENTRY)ObProcessCallbackListHead)-&gt;Flink;</span><br><span class="line">    <span class="keyword">if</span> (CurrEntry == <span class="literal">NULL</span> || !MmIsAddressValid(CurrEntry))</span><br><span class="line">    &#123;</span><br><span class="line">        ExFreePool(szDriverBaseName);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        pObCallback = (POB_CALLBACK)CurrEntry;</span><br><span class="line">        <span class="keyword">if</span> (pObCallback-&gt;ObHandle != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//遍历所有进程回调前函数,并且打印所属驱动名</span></span><br><span class="line">            <span class="keyword">if</span> (ObGetDriverNameByPoint(pObCallback-&gt;PreCall, szDriverBaseName))</span><br><span class="line">                DbgPrint(<span class="string">&quot;zeroko:kernel:&gt;DriverName=%S ObHandle=%p  Index=%wZ PreCall=%p PostCall=%p \n&quot;</span>,</span><br><span class="line">                    szDriverBaseName,</span><br><span class="line">                    pObCallback-&gt;ObHandle,</span><br><span class="line">                    &amp;pObCallback-&gt;ObHandle-&gt;AltitudeString,</span><br><span class="line">                    pObCallback-&gt;PreCall,</span><br><span class="line">                    pObCallback-&gt;PostCall);</span><br><span class="line">            c++;</span><br><span class="line">        &#125;</span><br><span class="line">        CurrEntry = CurrEntry-&gt;Flink;</span><br><span class="line">    &#125; <span class="keyword">while</span> (CurrEntry != (PLIST_ENTRY)ObProcessCallbackListHead);</span><br><span class="line">    <span class="comment">//遍历线程回调</span></span><br><span class="line">    DbgPrint(<span class="string">&quot;zeroko:kernel:-&gt;线程对象回调:\n&quot;</span>);</span><br><span class="line">    CurrEntry = ((PLIST_ENTRY)ObThreadCallbackListHead)-&gt;Flink;</span><br><span class="line">    <span class="keyword">if</span> (CurrEntry == <span class="literal">NULL</span> || !MmIsAddressValid(CurrEntry))</span><br><span class="line">    &#123;</span><br><span class="line">        ExFreePool(szDriverBaseName);</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        pObCallback = (POB_CALLBACK)CurrEntry;</span><br><span class="line">        <span class="keyword">if</span> (pObCallback-&gt;ObHandle != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (ObGetDriverNameByPoint(pObCallback-&gt;PreCall, szDriverBaseName))</span><br><span class="line">                DbgPrint(<span class="string">&quot;zeroko:kernel:&gt;DriverName=%S ObHandle=%p  Index=%wZ PreCall=%p PostCall=%p \n&quot;</span>,</span><br><span class="line">                    szDriverBaseName,</span><br><span class="line">                    pObCallback-&gt;ObHandle,</span><br><span class="line">                    &amp;pObCallback-&gt;ObHandle-&gt;AltitudeString,</span><br><span class="line">                    pObCallback-&gt;PreCall,</span><br><span class="line">                    pObCallback-&gt;PostCall);</span><br><span class="line">            c++;</span><br><span class="line">        &#125;</span><br><span class="line">        CurrEntry = CurrEntry-&gt;Flink;</span><br><span class="line">    &#125; <span class="keyword">while</span> (CurrEntry != (PLIST_ENTRY)ObThreadCallbackListHead);</span><br><span class="line">    DbgPrint(<span class="string">&quot;zeroko:kernel:ObCallback count: %ld\n&quot;</span>, c);</span><br><span class="line">    ExFreePool(szDriverBaseName);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历部分输出如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">zeroko:kernel:进程对象回调:</span><br><span class="line">zeroko:kernel:&gt;DriverName=<span class="number">360F</span>sFlt.sys ObHandle=FFFFB0837FB8C960  Index=<span class="number">425000</span> PreCall=FFFFF8055984DF30 PostCall=FFFFF8055984DF90 </span><br><span class="line">zeroko:kernel:&gt;DriverName=<span class="number">360B</span>ox64.sys ObHandle=FFFFB0837FB8DE60  Index=<span class="number">382310</span> PreCall=FFFFF8055991BB20 PostCall=FFFFF8055991BB2C </span><br><span class="line">zeroko:kernel:&gt;DriverName=sysdiag.sys ObHandle=FFFFB0837F8D3C90  Index=<span class="number">324600</span> PreCall=FFFFF80559E562B0 PostCall=<span class="number">0000000000000000</span> </span><br><span class="line">zeroko:kernel:-&gt;线程对象回调:</span><br><span class="line">zeroko:kernel:&gt;DriverName=<span class="number">360F</span>sFlt.sys ObHandle=FFFFB0837FB8C960  Index=<span class="number">425000</span> PreCall=FFFFF8055984DF30 PostCall=FFFFF8055984DF90 </span><br><span class="line">zeroko:kernel:&gt;DriverName=<span class="number">360B</span>ox64.sys ObHandle=FFFFB0837FB8DE60  Index=<span class="number">382310</span> PreCall=FFFFF8055991BB20 PostCall=FFFFF8055991BB2C </span><br><span class="line">zeroko:kernel:ObCallback count: <span class="number">5</span></span><br><span class="line"><span class="comment">//遍历结果中Index越大的越早被执行</span></span><br></pre></td></tr></table></figure>

<h3 id="完美过掉对象保护钩子"><a href="#完美过掉对象保护钩子" class="headerlink" title="完美过掉对象保护钩子"></a>完美过掉对象保护钩子</h3><p><strong>[ [绕过回调保护思路] ]</strong>:借助于<code>OB_CALLBACK.CALL_BACK_INFO.AltitudeString</code>越大越早被执行的规则,可以通过最早执行的回调钩子记录权限,再配合最晚执行的回调钩子恢复所有权限,以此对抗权限保护.</p>
<blockquote>
<p>前面的<a href="#%E6%B3%A8%E5%86%8C%E7%B3%BB%E7%BB%9F%E5%9B%9E%E8%B0%83%E6%A1%88%E4%BE%8B">注册系统回调</a>做的是让其他进程都没办法以[想要保护的进程]为目标打开进程,而此处做的是:让指定进程打开进程时,不会受到系统回调保护的限制.所以在自定义回调函数中,前者是通过OB_PRE_OPERATION_INFORMATION.Object来判断打开进程的目标进程;后者是通过PsGetCurrentProcessId获取自身pid来判断是不是我们想要绕过保护的进程.</p>
</blockquote>
<p>需要用到互斥提同步相关函数:</p>
<ul>
<li><code>ExInitializeFastMutex</code> 初始化快速互斥体</li>
<li><code>ExAcquireFastMutex</code> 请求使用快速互斥体</li>
<li>要同步的代码在上下之间</li>
<li><code>ExReleaseFastMutex</code> 释放</li>
</ul>
<p>代码如下:</p>
<h4 id="需要用到的结构"><a href="#需要用到的结构" class="headerlink" title="需要用到的结构"></a>需要用到的结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里字节对齐要采用默认，不要按1对齐，这样才符合32位和64位结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LDR_DATA_TABLE_ENTRY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	LIST_ENTRY InLoadOrderLinks;</span><br><span class="line">	LIST_ENTRY InMemoryOrderLinks;</span><br><span class="line">	LIST_ENTRY InInitializationOrderLinks;</span><br><span class="line">	PVOID DllBase;</span><br><span class="line">	PVOID EntryPoint;</span><br><span class="line">	ULONG SizeOfImage;</span><br><span class="line">	UNICODE_STRING FullDllName;</span><br><span class="line">	UNICODE_STRING BaseDllName;</span><br><span class="line">	ULONG Flags;</span><br><span class="line">	USHORT LoadCount;</span><br><span class="line">	USHORT TlsIndex;</span><br><span class="line">	<span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		LIST_ENTRY HashLinks;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">		&#123;</span></span><br><span class="line">			PVOID SectionPointer;</span><br><span class="line">			ULONG CheckSum;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">		&#123;</span></span><br><span class="line">			ULONG TimeDateStamp;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">		&#123;</span></span><br><span class="line">			PVOID LoadedImports;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">ACTIVATION_CONTEXT</span>* <span class="title">EntryPointActivationContext</span>;</span></span><br><span class="line">	PVOID PatchInformation;</span><br><span class="line">&#125; LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义的记录对象信息的链表结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OPERATION_INFO_ENTRY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	LIST_ENTRY    ListEntry;</span><br><span class="line">	OB_OPERATION  Operation;</span><br><span class="line">	ULONG         Flags;</span><br><span class="line">	PVOID         Object;</span><br><span class="line">	POBJECT_TYPE  ObjectType;</span><br><span class="line">	ACCESS_MASK   AccessMask;</span><br><span class="line">	ULONG32 time;</span><br><span class="line">&#125; OPERATION_INFO_ENTRY, * POPERATION_INFO_ENTRY;</span><br></pre></td></tr></table></figure>

<h4 id="需要用到的自定义子函数以及全局变量"><a href="#需要用到的自定义子函数以及全局变量" class="headerlink" title="需要用到的自定义子函数以及全局变量"></a>需要用到的自定义子函数以及全局变量</h4><ul>
<li><code>MyGetTickCount</code>  内核获得系统启动计数</li>
<li><code>IsMyProcess</code>  </li>
<li><code>Last_CallBack</code> 还原原权限自定义回调函数</li>
<li><code>First_CallBack</code>  记录原权限的自定义回调函数</li>
<li>ntoskrnl.exe导出的PsInitialSystemProcess 是一个指向system进程的EPROCESS全局变量</li>
<li>其他在注册系统回调时需要用到的结构体</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//申请空间的标签</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DRIVER_TAG <span class="string">&#x27;zk14&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//链表用于记录所有被触发回调的进程或线程信息</span></span><br><span class="line">LIST_ENTRY  g_OperationListHead;</span><br><span class="line">FAST_MUTEX  g_OperationListLock;<span class="comment">//给 g_OperationListHead链表  加的同步手段 互斥体</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内核获取系统启动计数</span></span><br><span class="line">ULONG <span class="title function_">MyGetTickCount</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    LARGE_INTEGER la;</span><br><span class="line">    ULONG MyInc;</span><br><span class="line">    MyInc = KeQueryTimeIncrement(); <span class="comment">//返回滴答数频率</span></span><br><span class="line">    <span class="comment">//下方 KeQueryTickCount 的宏的原型.</span></span><br><span class="line">    KeQueryTickCount(&amp;la);</span><br><span class="line">    la.QuadPart *= MyInc;</span><br><span class="line">    la.QuadPart /= <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">return</span> la.LowPart;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否自己目标的进程 可以过保护(暂时写死)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TARGETPROCESSNAME <span class="string">&quot;driverTest.exe&quot;</span></span></span><br><span class="line">BOOLEAN <span class="title function_">IsMyProcess</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    PEPROCESS Process = <span class="literal">NULL</span>;</span><br><span class="line">    Process = PsGetCurrentProcess();</span><br><span class="line">    <span class="comment">//KeQuerySystemTime(1);</span></span><br><span class="line">    <span class="keyword">if</span> (_strnicmp(TARGETPROCESSNAME, PsGetProcessImageFileName(Process), <span class="built_in">strlen</span>(TARGETPROCESSNAME)) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> TRUE;<span class="comment">// OB_PREOP_SUCCESS;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后一个自定义回调函数,用于恢复权限  </span></span><br><span class="line"><span class="comment">//APC_LEVEL=1;</span></span><br><span class="line">OB_PREOP_CALLBACK_STATUS <span class="title function_">Last_CallBack</span><span class="params">(IN PVOID RegistrationContext, IN POB_PRE_OPERATION_INFORMATION OperationInformation)</span></span><br><span class="line">&#123;</span><br><span class="line">    PLIST_ENTRY ListEntry;</span><br><span class="line">    UNREFERENCED_PARAMETER(RegistrationContext);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IsMyProcess())</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        ExAcquireFastMutex(&amp;g_OperationListLock);<span class="comment">//获取同步所有权</span></span><br><span class="line">        <span class="keyword">for</span> (ListEntry = g_OperationListHead.Flink; ListEntry != &amp;g_OperationListHead; ListEntry = ListEntry-&gt;Flink)</span><br><span class="line">        &#123;</span><br><span class="line">            POPERATION_INFO_ENTRY Entry = (POPERATION_INFO_ENTRY)ListEntry;</span><br><span class="line">            <span class="keyword">if</span> (Entry-&gt;Operation == OperationInformation-&gt;Operation &amp;&amp;</span><br><span class="line">                Entry-&gt;Flags == OperationInformation-&gt;Flags &amp;&amp;</span><br><span class="line">                Entry-&gt;Object == OperationInformation-&gt;Object &amp;&amp;</span><br><span class="line">                Entry-&gt;ObjectType == OperationInformation-&gt;ObjectType)</span><br><span class="line">            &#123;</span><br><span class="line">                ULONG32 newAccess = OperationInformation-&gt;Parameters-&gt;CreateHandleInformation.DesiredAccess;</span><br><span class="line">                ULONG32 oldAccess = Entry-&gt;AccessMask;</span><br><span class="line">                KdPrint((<span class="string">&quot;zeroko:kernel: Last_CallBack  PID=%d &lt;原权限=%llX,新权限=%llX&gt;-----&gt;time=%llX line=%d\n&quot;</span>,</span><br><span class="line">                    (ULONG64)PsGetCurrentProcessId(),</span><br><span class="line">                    (ULONG64)(Entry-&gt;AccessMask),<span class="comment">//原权限</span></span><br><span class="line">                    (ULONG64)newAccess,</span><br><span class="line">                    (ULONG64)Entry-&gt;time, (ULONG64)__LINE__)); <span class="comment">//新权限</span></span><br><span class="line">                <span class="comment">//恢复权限</span></span><br><span class="line">                OperationInformation-&gt;Parameters-&gt;CreateHandleInformation.DesiredAccess = Entry-&gt;AccessMask;    <span class="comment">//恢复权限请求OpenProcess</span></span><br><span class="line">                OperationInformation-&gt;Parameters-&gt;DuplicateHandleInformation.DesiredAccess = Entry-&gt;AccessMask; <span class="comment">//恢复权限请求 DuplicateHandle</span></span><br><span class="line">                <span class="comment">//移出结点</span></span><br><span class="line">                RemoveEntryList(&amp;Entry-&gt;ListEntry);</span><br><span class="line">                <span class="comment">//释放空间</span></span><br><span class="line">                ExFreePoolWithTag(Entry, DRIVER_TAG);</span><br><span class="line">                <span class="keyword">goto</span> Release;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    Release:</span><br><span class="line">        ExReleaseFastMutex(&amp;g_OperationListLock);<span class="comment">//释放同步所有权</span></span><br><span class="line">        <span class="comment">//ok</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OB_PREOP_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一个自定义回调,做记录信息工作,方便最后的回调恢复</span></span><br><span class="line">OB_PREOP_CALLBACK_STATUS <span class="title function_">First_CallBack</span><span class="params">(IN PVOID RegistrationContext, IN POB_PRE_OPERATION_INFORMATION OperationInformation)</span></span><br><span class="line">&#123;</span><br><span class="line">    POPERATION_INFO_ENTRY NewEntry = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ntoskrnl.exe导出的PsInitialSystemProcess 是一个指向system进程的EPROCESS,如果是他则跳过</span></span><br><span class="line">    <span class="keyword">if</span> (PsGetCurrentProcess() == PsInitialSystemProcess)</span><br><span class="line">        <span class="keyword">return</span> OB_PREOP_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果是线程回调的话跳过</span></span><br><span class="line">    <span class="keyword">if</span> (OperationInformation-&gt;ObjectType == PsThreadType)</span><br><span class="line">        <span class="keyword">return</span> OB_PREOP_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断打开进程是否为目标进程</span></span><br><span class="line">    <span class="keyword">if</span> (IsMyProcess())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//申请空间</span></span><br><span class="line">        NewEntry = (POPERATION_INFO_ENTRY)ExAllocatePoolWithTag(NonPagedPool, <span class="keyword">sizeof</span>(OPERATION_INFO_ENTRY), DRIVER_TAG);</span><br><span class="line">        <span class="comment">//记录数据</span></span><br><span class="line">        <span class="keyword">if</span> (NewEntry)</span><br><span class="line">        &#123;</span><br><span class="line">            NewEntry-&gt;Operation = OperationInformation-&gt;Operation;</span><br><span class="line">            NewEntry-&gt;Flags = OperationInformation-&gt;Flags;</span><br><span class="line">            NewEntry-&gt;Object = OperationInformation-&gt;Object;</span><br><span class="line">            NewEntry-&gt;ObjectType = OperationInformation-&gt;ObjectType;</span><br><span class="line">            <span class="comment">//保存请求的权限 防止被保护回调 修改 DuplicateHandle OpenProcess</span></span><br><span class="line">            NewEntry-&gt;AccessMask = <span class="number">0x1fffff</span>;<span class="comment">//OperationInformation-&gt;Parameters-&gt;CreateHandleInformation.DesiredAccess; /// Same for duplicate handle   1fffff表示全部权限,实际上FFFF就已经是全部全新了</span></span><br><span class="line">            NewEntry-&gt;time = MyGetTickCount();<span class="comment">// KeQuerySystemTime(1);</span></span><br><span class="line"></span><br><span class="line">            ExAcquireFastMutex(&amp;g_OperationListLock);<span class="comment">//同步快速互斥体 获取所有权</span></span><br><span class="line">            <span class="comment">//回调的各种数据插入链表</span></span><br><span class="line">            InsertTailList(&amp;g_OperationListHead, &amp;NewEntry-&gt;ListEntry);<span class="comment">//保存节点</span></span><br><span class="line">            KdPrint((<span class="string">&quot;zeroko:kernel:First_CallBack   保存权限=%llX PID=%d time=%llX line=%lld\n&quot;</span>,</span><br><span class="line">                (ULONG64)OperationInformation-&gt;Parameters-&gt;CreateHandleInformation.DesiredAccess,<span class="comment">//原权限 保存</span></span><br><span class="line">                (ULONG64)PsGetCurrentProcessId(),</span><br><span class="line">                (ULONG64)NewEntry-&gt;time,</span><br><span class="line">                (ULONG64)__LINE__));</span><br><span class="line">            ExReleaseFastMutex(&amp;g_OperationListLock);<span class="comment">//同步快速互斥体 释放所有权</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    UNREFERENCED_PARAMETER(RegistrationContext);<span class="comment">//避免未使用参数的警告,可有可无</span></span><br><span class="line">    <span class="keyword">return</span> OB_PREOP_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录系统回调的句柄,用于卸载</span></span><br><span class="line">PVOID       g_UpperHandle = <span class="literal">NULL</span>;</span><br><span class="line">PVOID       g_LowerHandle = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Last_CallBack和First_CallBack是自定义回调函数</span></span><br><span class="line">OB_OPERATION_REGISTRATION ObUpperOperationRegistration[] =</span><br><span class="line">&#123;</span><br><span class="line">    &#123; <span class="literal">NULL</span>, OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE, First_CallBack, <span class="literal">NULL</span> &#125;,<span class="comment">//进程的</span></span><br><span class="line">    &#123; <span class="literal">NULL</span>, OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE, First_CallBack, <span class="literal">NULL</span> &#125;,<span class="comment">//线程的</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">OB_OPERATION_REGISTRATION ObLowerOperationRegistration[] =</span><br><span class="line">&#123;</span><br><span class="line">    &#123; <span class="literal">NULL</span>, OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE, Last_CallBack, <span class="literal">NULL</span> &#125;,<span class="comment">//进程的</span></span><br><span class="line">    &#123; <span class="literal">NULL</span>, OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE, Last_CallBack, <span class="literal">NULL</span> &#125;,<span class="comment">//线程的</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// XignCode3 回调码 380800</span></span><br><span class="line"><span class="comment">// EAC       回调码 327530</span></span><br><span class="line"><span class="comment">// BE        回调码 363220</span></span><br><span class="line">OB_CALLBACK_REGISTRATION UpperCallbackRegistration =</span><br><span class="line">&#123;</span><br><span class="line">    OB_FLT_REGISTRATION_VERSION,</span><br><span class="line">    <span class="number">2</span>,</span><br><span class="line">    RTL_CONSTANT_STRING(<span class="string">L&quot;880000&quot;</span>),<span class="comment">//高的</span></span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    ObUpperOperationRegistration</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">OB_CALLBACK_REGISTRATION LowerCallcackRegistration =</span><br><span class="line">&#123;</span><br><span class="line">    OB_FLT_REGISTRATION_VERSION,</span><br><span class="line">    <span class="number">2</span>,</span><br><span class="line">    RTL_CONSTANT_STRING(<span class="string">L&quot;10000&quot;</span>),<span class="comment">//低的</span></span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    ObLowerOperationRegistration</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="接口函数"><a href="#接口函数" class="headerlink" title="接口函数"></a>接口函数</h4><ul>
<li>安装系统回调的 <code>ObRegisterCallBacksInitBreakProtect</code></li>
<li>卸载系统回调的 <code>ObRegisterUnload</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ObRegisterUnload</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != g_LowerHandle)</span><br><span class="line">        ObUnRegisterCallbacks(g_LowerHandle);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != g_UpperHandle)</span><br><span class="line">        ObUnRegisterCallbacks(g_UpperHandle);</span><br><span class="line">    <span class="keyword">while</span> (!IsListEmpty(&amp;g_OperationListHead))</span><br><span class="line">        ExFreePoolWithTag(RemoveHeadList(&amp;g_OperationListHead), DRIVER_TAG);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOLEAN <span class="title function_">ObRegisterCallBacksInitBreakProtect</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">////解锁使用限制  (添加参数PDRIVER_OBJECT pDriverObject)</span></span><br><span class="line">    <span class="comment">// PLDR_DATA ldr;</span></span><br><span class="line">    <span class="comment">//ldr = (PLDR_DATA)pDriverObject-&gt;DriverSection;</span></span><br><span class="line">    <span class="comment">//ldr-&gt;Flags |= 0x20;</span></span><br><span class="line"></span><br><span class="line">    InitializeListHead(&amp;g_OperationListHead);<span class="comment">//初始化链表头</span></span><br><span class="line">    ExInitializeFastMutex(&amp;g_OperationListLock);<span class="comment">//初始化快速互斥体</span></span><br><span class="line"></span><br><span class="line">    ObUpperOperationRegistration[<span class="number">0</span>].ObjectType = PsProcessType;<span class="comment">//针对进程回调</span></span><br><span class="line">    <span class="comment">//新添加的</span></span><br><span class="line">    ObUpperOperationRegistration[<span class="number">0</span>].Operations = OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE;</span><br><span class="line"></span><br><span class="line">    ObUpperOperationRegistration[<span class="number">1</span>].ObjectType = PsThreadType;<span class="comment">//针对线程回调</span></span><br><span class="line">    <span class="comment">//新添加的</span></span><br><span class="line">    ObUpperOperationRegistration[<span class="number">1</span>].Operations = OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE;</span><br><span class="line">    Status = ObRegisterCallbacks(&amp;UpperCallbackRegistration, &amp;g_UpperHandle);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        g_UpperHandle = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">goto</span> Exit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ObLowerOperationRegistration[<span class="number">0</span>].ObjectType = PsProcessType;<span class="comment">//针对进程回调</span></span><br><span class="line">    <span class="comment">//新添加的</span></span><br><span class="line">    ObLowerOperationRegistration[<span class="number">0</span>].Operations = OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE;</span><br><span class="line"></span><br><span class="line">    ObLowerOperationRegistration[<span class="number">1</span>].ObjectType = PsThreadType;<span class="comment">//针对线程回调</span></span><br><span class="line">    <span class="comment">//新添加的</span></span><br><span class="line">    ObLowerOperationRegistration[<span class="number">1</span>].Operations = OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE;</span><br><span class="line">    Status = ObRegisterCallbacks(&amp;LowerCallcackRegistration, &amp;g_LowerHandle);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        g_LowerHandle = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">goto</span> Exit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Exit:</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line">        ObRegisterUnload();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NT_SUCCESS(Status) ? TRUE : FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>安装过保护后,遍历系统回调如下:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202205292047586.jpeg" alt="foreach"></p>
<p>tp刚开始可以读取,但是过了一会儿又不能访问了,很可能tp有遍历[[句柄表]],找谁打开了自己的句柄,就释放掉.</p>
<h2 id="句柄表遍历相关"><a href="#句柄表遍历相关" class="headerlink" title="句柄表遍历相关"></a>句柄表遍历相关</h2><p><a target="_blank" rel="noopener" href="https://zeroko14.gitee.io/blog/2022/05/05/%E5%8F%A5%E6%9F%84%E8%A1%A8/">x86相关句柄表遍历跳出到句柄表文章</a></p>
<h3 id="R3句柄遍历"><a href="#R3句柄遍历" class="headerlink" title="R3句柄遍历"></a>R3句柄遍历</h3><ul>
<li><code>NtQuerySystemInformation</code>   遍历句柄</li>
<li><code>NtQueryInformationProcess</code>   句柄转pid</li>
<li><code>NtQueryObject</code>     获取句柄信息   类型   名字</li>
<li><code>DuplicateHandle</code>   把目标进程的句柄复制到当前进程,类似于内存映射</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntquerysysteminformation">NtQuerySystemInformation遍历句柄微软API讲解跳转</a></p>
<p>NTDLL.DLL中有一个函数叫 NtQueryInformationProcess，用它可以将指定类型的进程信息拷贝到某个缓冲。其原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NTSYSAPI</span><br><span class="line">NTSTATUS</span><br><span class="line">NTAPI</span><br><span class="line"><span class="title function_">NtQueryInformationProcess</span> <span class="params">(</span></span><br><span class="line"><span class="params">IN HANDLE ProcessHandle, <span class="comment">// 进程句柄</span></span></span><br><span class="line"><span class="params">IN PROCESSINFOCLASS InformationClass, <span class="comment">// 信息类型</span></span></span><br><span class="line"><span class="params">OUT PVOID ProcessInformation, <span class="comment">// 缓冲指针</span></span></span><br><span class="line"><span class="params">IN ULONG ProcessInformationLength, <span class="comment">// 以字节为单位的缓冲大小</span></span></span><br><span class="line"><span class="params">OUT PULONG ReturnLength OPTIONAL <span class="comment">// 写入缓冲的字节数</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="NtQuerySystemInformation函数"><a href="#NtQuerySystemInformation函数" class="headerlink" title="NtQuerySystemInformation函数"></a>NtQuerySystemInformation函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__kernel_entry NTSTATUS <span class="title function_">NtQuerySystemInformation</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]            SYSTEM_INFORMATION_CLASS SystemInformationClass,<span class="comment">//SYSTEM_INFORMATION_CLASS中枚举的值之一，指示要检索的系统信息的类型</span></span></span><br><span class="line"><span class="params">  [in, out]       PVOID                    SystemInformation,<span class="comment">//指向接收请求信息的缓冲区的指针。 此信息的大小和结构因 SystemInformationClass 参数的值而异：</span></span></span><br><span class="line"><span class="params">  [in]            ULONG                    SystemInformationLength,<span class="comment">//SystemInformation 参数指向的缓冲区的大小（以字节为单位）</span></span></span><br><span class="line"><span class="params">  [out, optional] PULONG                   ReturnLength<span class="comment">//指向函数写入所请求信息的实际大小的位置的可选指针。 如果该大小小于或等于SystemInformationLength 参数，函数将信息复制到 SystemInformation 缓冲区中;否则，它会返回 NTSTATUS 错误代码，并在 ReturnLength 中返回接收请求的信息所需的缓冲区大小。</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"><span class="comment">//返回值:返回 NTSTATUS 成功或错误代码。</span></span><br></pre></td></tr></table></figure>

<p>实现句柄遍历代码:</p>
<p>下面需要用到的数据结构包含在<a href="#R3%E7%94%A8%E5%88%B0%E7%9A%84%E5%86%85%E6%A0%B8%E7%9B%B8%E5%85%B3%E7%BB%93%E6%9E%84%E4%BD%93%E5%A4%A7%E6%95%B4%E5%90%88">该头文件中(点击跳转)</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>











<h1 id="完整项目参考"><a href="#完整项目参考" class="headerlink" title="完整项目参考"></a>完整项目参考</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="一些名词理解"><a href="#一些名词理解" class="headerlink" title="一些名词理解"></a>一些名词理解</h1><p><strong>PG&#x2F;过PG&#x2F;KPP&#x2F;DSE&#x2F;过DSE&#x2F;内核越狱&#x2F;免签加载驱动&#x2F;API(MSG)HOOK名词理解</strong></p>
<ul>
<li>KPP：内核补丁保护，详见<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Kernel_Patch_Protection">http://en.wikipedia.org/wiki/Kernel_Patch_Protection</a></li>
<li>PG：基本可以认为和KPP是一个意思。PatchGuard（正名Kernel Patch Protection）相当于“哨兵”，它的功能是不定时地“巡逻”，检查重要的内核数据结构有没有被篡改，发现篡改就立刻触发蓝屏（也就是Bugcheck 109，CRITICAL_STRUCTURE_CORRUPTION）。</li>
<li>过PG：让PG无法工作，或工作无效。方法基本分为两类，动态（无需重启，重启后失效）和静态（需要重启，重启后一直生效）。</li>
<li>DSE：数字签名强制。全名driver signature enforcement，可以简单理解为“驱动文件必须包含正确的交叉签名”。DSE（Driver Signature Enforcement）相当于“守门员”，在驱动加载前检查数字签名是否有效，无效则拒绝加载进内核；</li>
<li>过DSE：让DSE机制无法工作，或工作无效。方法基本分为两类，动态（无需重启，重启后失效）和静态（需要重启，重启后一直生效）。</li>
<li>免签加载驱动：就是加载一个无签名，或签名无效的驱动。</li>
<li>内核越狱：可以简单理解为｛过PG+过DSE｝。</li>
<li>关于HOOK：MESSAGE HOOK是RING3的HOOK，所有RING3的HOOK（包括RING3 IAT&#x2F;EAT&#x2F;INLINE HOOK）都不被PG限制。RING0里对关键模块（包括但不限于NTOSKRNL.EXE、HAL.DLL、NDIS.SYS等）以及一些关键的表（包括但不限于SSDT、IDT、PsActiveProcessLinks等）的任何修改，都不被PG所允许。</li>
</ul>
<p>要加载驱动，需要先pass掉DSE，进了内核以后，再看情况考虑要不要干掉PG……</p>
<p><strong>不重启禁用&#x2F;绕过DSE的方法：</strong></p>
<p>不支持重启的方法:</p>
<p>1.在内存中修改全局变量g_CiEnabled（也就是所谓的flag？）</p>
<p><a href="https://link.zhihu.com/?target=http://www.kernelmode.info/forum/viewtopic.php?f=11&t=3322">DSEFix - Defeating x64 Driver Signature Enforcement</a></p>
<p>需要一个有<strong>任意内存读写&#x2F;执行漏洞</strong>的<strong>有合法签名的驱动</strong>先被加载进内核，然后可以利用漏洞完成修改。<strong>修改完DSE就被关闭了。</strong></p>
<p>也有带合法签名的驱动直接实现了这个功能，比如WIN64AST这个小工具就有关闭DSE的功能。</p>
<p>缺点：修改会被不定时运行的<strong>PatchGuard</strong>检测到，<strong>一旦被检测到就会立刻蓝屏</strong>。</p>
<p>可以在要加载驱动时先修改flag来禁用DSE，然后抓紧时间加载驱动，加载完成后再立刻把flag改回去，这样可以大大降低蓝屏的概率。</p>
<p>2.不使用正常的驱动加载途径，使用自己编写的shellcode加载</p>
<p><a href="https://link.zhihu.com/?target=https://github.com/hfiref0x/TDL">hfiref0x&#x2F;TDL</a></p>
<p><strong>同样需要一个有合法签名的驱动先被加载</strong>，然后利用这个驱动（<strong>可能是利用bug，也可能是驱动自己实现的功能</strong>）来完成无签名驱动的加载。</p>
<p>这个方法的优点是<strong>不会触发PatchGuard</strong>，但缺点也很明显：被加载的驱动需要被特殊设计，加载后不支持卸载，不支持SEH，函数导入不正常……<strong>限制很多</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/49451179">过保护更多了解</a></p>
<p><strong>VT技术过PG</strong></p>
<p>驱动开发小技巧:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NT_SUCCESS(Status) (((NTSTATUS)(Status)) &gt;= 0)</span></span><br><span class="line"><span class="comment">//用于判断返回值</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-265189.htm">驱动层真正完美的隐藏内存</a></p>
<h3 id="签名相关"><a href="#签名相关" class="headerlink" title="签名相关"></a>签名相关</h3><p>32位操作系统上,驱动签名不是强制要求的,所以可以加载未签名的驱动</p>
<p>但在64位系统上,默认情况下无法加载未签名驱动,不过可以通过禁用驱动签名强制(例如通过测试模式)来安装未签名驱动</p>
<p><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/paper/281035.html">无签名加载驱动知识点参考</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/zer0condition/GDRVLoader">利用漏洞加载驱动,支持win11</a></p>
<p>目前默认的证书签名算法都是sha-256，通过申请的证书可以使用工具进行双签名，给应用程序或驱动签名的摘要算法就是sha1和sha256，但签发的证书本身签名算法是sha-256，可以通过所以在旧版的操作系统中会出现驱动类文件不兼容。目前在旧版操作系统的内核驱动签名不支持单证书双签名，普通应用程序则支持单证书双签名。</p>
<p>对于内核驱动签名，如果要实现双签名，例如同时在Windows 7 和 Windows 10 上运行，Windows 10则要求使用sha-256的签名算法创建签名，但是Windows 7的内核驱动签名则需要使用sha-1来实现。也就是说<strong>对于内核驱动的签名，需要同时购买EV代码签名证书和标准签名证书来实现内核驱动的双签名</strong>。对于普通的应用程序可以使用一张证书来双签名实现兼容性。</p>
<h4 id="签名工具使用"><a href="#签名工具使用" class="headerlink" title="签名工具使用"></a>签名工具使用</h4><p>先添加签名规则,再给文件签名.</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/403704980">签名证书原理</a></p>
<p>运行中输入<code>sigvierif</code>后启动点击开始,分析完后在高级中查看日志可以验证系统所有驱动的签名情况</p>
<h1 id="64位16进制字符串操作"><a href="#64位16进制字符串操作" class="headerlink" title="64位16进制字符串操作"></a>64位16进制字符串操作</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//十六进制字符串转十六进制数字</span></span><br><span class="line">ULONG_PTR ulModBase  = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(_WIN64)</span></span><br><span class="line">    ulModBase            = _tcstoui64(strParam,<span class="literal">NULL</span>,<span class="number">16</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    ulModBase            = _tcstoul(strParam,<span class="literal">NULL</span>,<span class="number">16</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">//上面的strParam是wchar*类型的</span></span><br></pre></td></tr></table></figure>

<p>**[printf的64位16进制输出格式]**为 <code>%016I64x</code>  0表示用0填充空白位置,16表示16个字符,I64表示64位,%x表示输出16进制数</p>
<h1 id="设定驱动和用户层相接数据结构"><a href="#设定驱动和用户层相接数据结构" class="headerlink" title="设定驱动和用户层相接数据结构"></a>设定驱动和用户层相接数据结构</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类似如下方式,统一内存对齐最稳妥</span></span><br><span class="line"><span class="comment">//当然也可以按照64位默认的8字节对齐,但用户层和内存层都必须是64位</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(push)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(8)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TINPUT_BUF</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	UINT64 dwPid;</span><br><span class="line">  PVOID PBase;</span><br><span class="line">  UINT64 nSize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(pop)</span></span><br></pre></td></tr></table></figure>

<h1 id="R3用到的内核相关结构体大整合"><a href="#R3用到的内核相关结构体大整合" class="headerlink" title="R3用到的内核相关结构体大整合"></a>R3用到的内核相关结构体大整合</h1><p>NtDefs.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;basetsd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">namespace NTDEFS</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IN</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OPTIONAL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NT_SUCCESS(Status) (((NTSTATUS)(Status)) &gt;= 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_STACK_DEPTH 32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXIMUM_NUMA_NODES 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STATUS_SUCCESS                   ((NTSTATUS)0x00000000L)    <span class="comment">// ntsubauth</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WINAPI __stdcall</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> BOOL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> ULONG;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> DWORD;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> WORD;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> UCHAR;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> USHORT;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">long</span> LONG;</span><br><span class="line">	<span class="keyword">typedef</span> LONG NTSTATUS;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">void</span> *PVOID;</span><br><span class="line">	<span class="keyword">typedef</span> ULONG *PULONG;</span><br><span class="line">	<span class="keyword">typedef</span> ULONG_PTR KAFFINITY;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">char</span> CCHAR;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">void</span> * HANDLE;</span><br><span class="line">	<span class="keyword">typedef</span> HANDLE HLOCAL;</span><br><span class="line">	<span class="keyword">typedef</span> HANDLE * LPHANDLE;</span><br><span class="line">	<span class="keyword">typedef</span> UCHAR *PUCHAR;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> UINT;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">void</span> *LPVOID;</span><br><span class="line">	<span class="keyword">typedef</span> SIZE_T SYSINF_PAGE_COUNT;</span><br><span class="line">	<span class="keyword">typedef</span> LONG KPRIORITY;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">wchar_t</span> WCHAR;</span><br><span class="line">	<span class="keyword">typedef</span> WCHAR *NWPSTR, *LPWSTR, *PWSTR;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">char</span> CHAR;</span><br><span class="line">	<span class="keyword">typedef</span> CHAR *PCHAR, *LPCH, *PCH;</span><br><span class="line">	<span class="keyword">typedef</span> DWORD ACCESS_MASK;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> &#123;</span></span><br><span class="line">		USHORT Length;</span><br><span class="line">		USHORT MaximumLength;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MIDL_PASS</span></span><br><span class="line">		[size_is(MaximumLength / <span class="number">2</span>), length_is((Length) / <span class="number">2</span>)] USHORT * Buffer;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">// MIDL_PASS</span></span></span><br><span class="line">		PWSTR  Buffer;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MIDL_PASS</span></span></span><br><span class="line">	&#125; UNICODE_STRING;</span><br><span class="line">	<span class="keyword">typedef</span> UNICODE_STRING *PUNICODE_STRING;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (!defined (_MAC) &amp;&amp; (!defined(MIDL_PASS) || defined(__midl)) &amp;&amp; (!defined(_M_IX86) || (defined(_INTEGRAL_MAX_BITS) &amp;&amp; _INTEGRAL_MAX_BITS &gt;= 64)))</span></span><br><span class="line">	<span class="keyword">typedef</span> __int64 LONGLONG;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">unsigned</span> __int64 ULONGLONG;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLONGLONG                         (0x7fffffffffffffff)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(_MAC) &amp;&amp; defined(_MAC_INT_64)</span></span><br><span class="line">	<span class="keyword">typedef</span> __int64 LONGLONG;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">unsigned</span> __int64 ULONGLONG;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLONGLONG                      (0x7fffffffffffffff)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">double</span> LONGLONG;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">double</span> ULONGLONG;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//_MAC and int64</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(MIDL_PASS)</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LARGE_INTEGER</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">// MIDL_PASS</span></span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> _<span class="title">LARGE_INTEGER</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">		&#123;</span></span><br><span class="line">			DWORD LowPart;</span><br><span class="line">			LONG HighPart;</span><br><span class="line">		&#125; DUMMYSTRUCTNAME;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">		&#123;</span></span><br><span class="line">			DWORD LowPart;</span><br><span class="line">			LONG HighPart;</span><br><span class="line">		&#125; u;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//MIDL_PASS</span></span></span><br><span class="line">		LONGLONG QuadPart;</span><br><span class="line">	&#125; LARGE_INTEGER;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> BYTE;</span><br><span class="line">	<span class="keyword">typedef</span> BYTE BOOLEAN;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLG_STOP_ON_EXCEPTION           0x00000001      <span class="comment">// user and kernel mode</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLG_SHOW_LDR_SNAPS              0x00000002      <span class="comment">// user and kernel mode</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLG_DEBUG_INITIAL_COMMAND       0x00000004      <span class="comment">// kernel mode only up until WINLOGON started</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLG_STOP_ON_HUNG_GUI            0x00000008      <span class="comment">// kernel mode only while running</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLG_HEAP_ENABLE_TAIL_CHECK      0x00000010      <span class="comment">// user mode only</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLG_HEAP_ENABLE_FREE_CHECK      0x00000020      <span class="comment">// user mode only</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLG_HEAP_VALIDATE_PARAMETERS    0x00000040      <span class="comment">// user mode only</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLG_HEAP_VALIDATE_ALL           0x00000080      <span class="comment">// user mode only</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLG_APPLICATION_VERIFIER        0x00000100      <span class="comment">// user mode only</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLG_POOL_ENABLE_TAGGING         0x00000400      <span class="comment">// kernel mode only</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLG_HEAP_ENABLE_TAGGING         0x00000800      <span class="comment">// user mode only</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLG_USER_STACK_TRACE_DB         0x00001000      <span class="comment">// x86 user mode only</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLG_KERNEL_STACK_TRACE_DB       0x00002000      <span class="comment">// x86 kernel mode only at boot time</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLG_MAINTAIN_OBJECT_TYPELIST    0x00004000      <span class="comment">// kernel mode only at boot time</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLG_HEAP_ENABLE_TAG_BY_DLL      0x00008000      <span class="comment">// user mode only</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLG_DISABLE_STACK_EXTENSION     0x00010000      <span class="comment">// user mode only</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLG_ENABLE_CSRDEBUG             0x00020000      <span class="comment">// kernel mode only at boot time</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLG_ENABLE_KDEBUG_SYMBOL_LOAD   0x00040000      <span class="comment">// kernel mode only</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLG_DISABLE_PAGE_KERNEL_STACKS  0x00080000      <span class="comment">// kernel mode only at boot time</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLG_ENABLE_SYSTEM_CRIT_BREAKS   0x00100000      <span class="comment">// user mode only</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLG_HEAP_DISABLE_COALESCING     0x00200000      <span class="comment">// user mode only</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLG_ENABLE_CLOSE_EXCEPTIONS     0x00400000      <span class="comment">// kernel mode only</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLG_ENABLE_EXCEPTION_LOGGING    0x00800000      <span class="comment">// kernel mode only</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLG_ENABLE_HANDLE_TYPE_TAGGING  0x01000000      <span class="comment">// kernel mode only</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLG_HEAP_PAGE_ALLOCS            0x02000000      <span class="comment">// user mode only</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLG_DEBUG_INITIAL_COMMAND_EX    0x04000000      <span class="comment">// kernel mode only up until WINLOGON started</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLG_DISABLE_DBGPRINT            0x08000000      <span class="comment">// kernel mode only</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLG_CRITSEC_EVENT_CREATION      0x10000000      <span class="comment">// user mode only, Force early creation of resource events</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLG_LDR_TOP_DOWN                0x20000000      <span class="comment">// user mode only, win64 only</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLG_ENABLE_HANDLE_EXCEPTIONS    0x40000000      <span class="comment">// kernel mode only</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLG_DISABLE_PROTDLLS            0x80000000      <span class="comment">// user mode only (smss/winlogon)</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCESSOR_ARCHITECTURE_INTEL            0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCESSOR_ARCHITECTURE_MIPS             1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCESSOR_ARCHITECTURE_ALPHA            2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCESSOR_ARCHITECTURE_PPC              3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCESSOR_ARCHITECTURE_SHX              4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCESSOR_ARCHITECTURE_ARM              5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCESSOR_ARCHITECTURE_IA64             6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCESSOR_ARCHITECTURE_ALPHA64          7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCESSOR_ARCHITECTURE_MSIL             8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCESSOR_ARCHITECTURE_AMD64            9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCESSOR_ARCHITECTURE_IA32_ON_WIN64    10</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STATUS_INFO_LENGTH_MISMATCH      ((NTSTATUS)0xC0000004L)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STATUS_INVALID_INFO_CLASS ((NTSTATUS)0xC0000003L) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STATUS_ACCESS_VIOLATION ((DWORD )0xC0000005L)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STATUS_INSUFFICIENT_RESOURCES ((NTSTATUS)0xC000009AL) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STATUS_WORKING_SET_QUOTA ((NTSTATUS)0xC00000A1L)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STATUS_NOT_IMPLEMENTED ((NTSTATUS)0xC0000002L)</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">SYSTEM_INFORMATION_CLASS</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		SystemBasicInformation,</span><br><span class="line">		SystemProcessorInformation,              <span class="comment">// obsolete...delete</span></span><br><span class="line">		SystemPerformanceInformation,</span><br><span class="line">		SystemTimeOfDayInformation,</span><br><span class="line">		SystemPathInformation,</span><br><span class="line">		SystemProcessInformation,                <span class="comment">//ϵͳ������Ϣ</span></span><br><span class="line">		SystemCallCountInformation,</span><br><span class="line">		SystemDeviceInformation,</span><br><span class="line">		SystemProcessorPerformanceInformation,</span><br><span class="line">		SystemFlagsInformation,</span><br><span class="line">		SystemCallTimeInformation,</span><br><span class="line">		SystemModuleInformation,     <span class="comment">//ϵͳģ��</span></span><br><span class="line">		SystemLocksInformation,</span><br><span class="line">		SystemStackTraceInformation,</span><br><span class="line">		SystemPagedPoolInformation,</span><br><span class="line">		SystemNonPagedPoolInformation,</span><br><span class="line">		SystemHandleInformation,</span><br><span class="line">		SystemObjectInformation,</span><br><span class="line">		SystemPageFileInformation,</span><br><span class="line">		SystemVdmInstemulInformation,</span><br><span class="line">		SystemVdmBopInformation,</span><br><span class="line">		SystemFileCacheInformation,</span><br><span class="line">		SystemPoolTagInformation,</span><br><span class="line">		SystemInterruptInformation,</span><br><span class="line">		SystemDpcBehaviorInformation,</span><br><span class="line">		SystemFullMemoryInformation,</span><br><span class="line">		SystemLoadGdiDriverInformation,</span><br><span class="line">		SystemUnloadGdiDriverInformation,</span><br><span class="line">		SystemTimeAdjustmentInformation,</span><br><span class="line">		SystemSummaryMemoryInformation,</span><br><span class="line">		SystemMirrorMemoryInformation,</span><br><span class="line">		SystemPerformanceTraceInformation,</span><br><span class="line">		SystemObsolete0,</span><br><span class="line">		SystemExceptionInformation,</span><br><span class="line">		SystemCrashDumpStateInformation,</span><br><span class="line">		SystemKernelDebuggerInformation,</span><br><span class="line">		SystemContextSwitchInformation,</span><br><span class="line">		SystemRegistryQuotaInformation,</span><br><span class="line">		SystemExtendServiceTableInformation,</span><br><span class="line">		SystemPrioritySeperation,</span><br><span class="line">		SystemVerifierAddDriverInformation,</span><br><span class="line">		SystemVerifierRemoveDriverInformation,</span><br><span class="line">		SystemProcessorIdleInformation,</span><br><span class="line">		SystemLegacyDriverInformation,</span><br><span class="line">		SystemCurrentTimeZoneInformation,</span><br><span class="line">		SystemLookasideInformation,</span><br><span class="line">		SystemTimeSlipNotification,</span><br><span class="line">		SystemSessionCreate,</span><br><span class="line">		SystemSessionDetach,</span><br><span class="line">		SystemSessionInformation,</span><br><span class="line">		SystemRangeStartInformation,</span><br><span class="line">		SystemVerifierInformation,</span><br><span class="line">		SystemVerifierThunkExtend,</span><br><span class="line">		SystemSessionProcessInformation,</span><br><span class="line">		SystemLoadGdiDriverInSystemSpace,</span><br><span class="line">		SystemNumaProcessorMap,</span><br><span class="line">		SystemPrefetcherInformation,</span><br><span class="line">		SystemExtendedProcessInformation,</span><br><span class="line">		SystemRecommendedSharedDataAlignment,</span><br><span class="line">		SystemComPlusPackage,</span><br><span class="line">		SystemNumaAvailableMemory,</span><br><span class="line">		SystemProcessorPowerInformation,</span><br><span class="line">		SystemEmulationBasicInformation,<span class="comment">//=SystemBasicInformation</span></span><br><span class="line">		SystemEmulationProcessorInformation,<span class="comment">//=SystemProcessorInformation</span></span><br><span class="line">		SystemExtendedHandleInformation,</span><br><span class="line">		SystemLostDelayedWriteInformation,</span><br><span class="line">		SystemBigPoolInformation,</span><br><span class="line">		SystemSessionPoolTagInformation,</span><br><span class="line">		SystemSessionMappedViewInformation,</span><br><span class="line">		SystemHotpatchInformation,</span><br><span class="line">		SystemObjectSecurityMode,</span><br><span class="line">		SystemWatchdogTimerHandler,</span><br><span class="line">		SystemWatchdogTimerInformation,</span><br><span class="line">		SystemLogicalProcessorInformation,</span><br><span class="line">		SystemWow64SharedInformation,</span><br><span class="line">		SystemRegisterFirmwareTableInformationHandler,</span><br><span class="line">		SystemFirmwareTableInformation,</span><br><span class="line">		SystemModuleInformationEx,</span><br><span class="line">		SystemVerifierTriageInformation,</span><br><span class="line">		SystemSuperfetchInformation,</span><br><span class="line">		SystemMemoryListInformation,</span><br><span class="line">		SystemFileCacheInformationEx,</span><br><span class="line"></span><br><span class="line">		<span class="comment">//100?</span></span><br><span class="line">		SystemPageMemoryInformation = <span class="number">123</span>,<span class="comment">//�Զ���</span></span><br><span class="line">		SystemPolicyInformation = <span class="number">134</span>,</span><br><span class="line"></span><br><span class="line">	&#125; SYSTEM_INFORMATION_CLASS, *PSYSTEM_INFORMATION_CLASS;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_BASIC_INFORMATION</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		ULONG Reserved;</span><br><span class="line">		ULONG TimerResolution;</span><br><span class="line">		ULONG PageSize;</span><br><span class="line">		SYSINF_PAGE_COUNT NumberOfPhysicalPages;</span><br><span class="line">		SYSINF_PAGE_COUNT LowestPhysicalPageNumber;</span><br><span class="line">		SYSINF_PAGE_COUNT HighestPhysicalPageNumber;</span><br><span class="line">		ULONG AllocationGranularity;</span><br><span class="line">		ULONG_PTR MinimumUserModeAddress;</span><br><span class="line">		ULONG_PTR MaximumUserModeAddress;</span><br><span class="line">		ULONG_PTR ActiveProcessorsAffinityMask;</span><br><span class="line">		CCHAR NumberOfProcessors;</span><br><span class="line">	&#125; SYSTEM_BASIC_INFORMATION, *PSYSTEM_BASIC_INFORMATION;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_PROCESSOR_INFORMATION</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		USHORT ProcessorArchitecture;</span><br><span class="line">		USHORT ProcessorLevel;</span><br><span class="line">		USHORT ProcessorRevision;</span><br><span class="line">		USHORT Reserved;</span><br><span class="line">		ULONG ProcessorFeatureBits;</span><br><span class="line">	&#125; SYSTEM_PROCESSOR_INFORMATION, *PSYSTEM_PROCESSOR_INFORMATION;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_PERFORMANCE_INFORMATION</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		LARGE_INTEGER IdleProcessTime;</span><br><span class="line">		LARGE_INTEGER IoReadTransferCount;</span><br><span class="line">		LARGE_INTEGER IoWriteTransferCount;</span><br><span class="line">		LARGE_INTEGER IoOtherTransferCount;</span><br><span class="line">		ULONG IoReadOperationCount;</span><br><span class="line">		ULONG IoWriteOperationCount;</span><br><span class="line">		ULONG IoOtherOperationCount;</span><br><span class="line">		ULONG AvailablePages;</span><br><span class="line">		SYSINF_PAGE_COUNT CommittedPages;</span><br><span class="line">		SYSINF_PAGE_COUNT CommitLimit;</span><br><span class="line">		SYSINF_PAGE_COUNT PeakCommitment;</span><br><span class="line">		ULONG PageFaultCount;</span><br><span class="line">		ULONG CopyOnWriteCount;</span><br><span class="line">		ULONG TransitionCount;</span><br><span class="line">		ULONG CacheTransitionCount;</span><br><span class="line">		ULONG DemandZeroCount;</span><br><span class="line">		ULONG PageReadCount;</span><br><span class="line">		ULONG PageReadIoCount;</span><br><span class="line">		ULONG CacheReadCount;</span><br><span class="line">		ULONG CacheIoCount;</span><br><span class="line">		ULONG DirtyPagesWriteCount;</span><br><span class="line">		ULONG DirtyWriteIoCount;</span><br><span class="line">		ULONG MappedPagesWriteCount;</span><br><span class="line">		ULONG MappedWriteIoCount;</span><br><span class="line">		ULONG PagedPoolPages;</span><br><span class="line">		ULONG NonPagedPoolPages;</span><br><span class="line">		ULONG PagedPoolAllocs;</span><br><span class="line">		ULONG PagedPoolFrees;</span><br><span class="line">		ULONG NonPagedPoolAllocs;</span><br><span class="line">		ULONG NonPagedPoolFrees;</span><br><span class="line">		ULONG FreeSystemPtes;</span><br><span class="line">		ULONG ResidentSystemCodePage;</span><br><span class="line">		ULONG TotalSystemDriverPages;</span><br><span class="line">		ULONG TotalSystemCodePages;</span><br><span class="line">		ULONG NonPagedPoolLookasideHits;</span><br><span class="line">		ULONG PagedPoolLookasideHits;</span><br><span class="line">		ULONG AvailablePagedPoolPages;</span><br><span class="line">		ULONG ResidentSystemCachePage;</span><br><span class="line">		ULONG ResidentPagedPoolPage;</span><br><span class="line">		ULONG ResidentSystemDriverPage;</span><br><span class="line">		ULONG CcFastReadNoWait;</span><br><span class="line">		ULONG CcFastReadWait;</span><br><span class="line">		ULONG CcFastReadResourceMiss;</span><br><span class="line">		ULONG CcFastReadNotPossible;</span><br><span class="line">		ULONG CcFastMdlReadNoWait;</span><br><span class="line">		ULONG CcFastMdlReadWait;</span><br><span class="line">		ULONG CcFastMdlReadResourceMiss;</span><br><span class="line">		ULONG CcFastMdlReadNotPossible;</span><br><span class="line">		ULONG CcMapDataNoWait;</span><br><span class="line">		ULONG CcMapDataWait;</span><br><span class="line">		ULONG CcMapDataNoWaitMiss;</span><br><span class="line">		ULONG CcMapDataWaitMiss;</span><br><span class="line">		ULONG CcPinMappedDataCount;</span><br><span class="line">		ULONG CcPinReadNoWait;</span><br><span class="line">		ULONG CcPinReadWait;</span><br><span class="line">		ULONG CcPinReadNoWaitMiss;</span><br><span class="line">		ULONG CcPinReadWaitMiss;</span><br><span class="line">		ULONG CcCopyReadNoWait;</span><br><span class="line">		ULONG CcCopyReadWait;</span><br><span class="line">		ULONG CcCopyReadNoWaitMiss;</span><br><span class="line">		ULONG CcCopyReadWaitMiss;</span><br><span class="line">		ULONG CcMdlReadNoWait;</span><br><span class="line">		ULONG CcMdlReadWait;</span><br><span class="line">		ULONG CcMdlReadNoWaitMiss;</span><br><span class="line">		ULONG CcMdlReadWaitMiss;</span><br><span class="line">		ULONG CcReadAheadIos;</span><br><span class="line">		ULONG CcLazyWriteIos;</span><br><span class="line">		ULONG CcLazyWritePages;</span><br><span class="line">		ULONG CcDataFlushes;</span><br><span class="line">		ULONG CcDataPages;</span><br><span class="line">		ULONG ContextSwitches;</span><br><span class="line">		ULONG FirstLevelTbFills;</span><br><span class="line">		ULONG SecondLevelTbFills;</span><br><span class="line">		ULONG SystemCalls;</span><br><span class="line">	&#125; SYSTEM_PERFORMANCE_INFORMATION, *PSYSTEM_PERFORMANCE_INFORMATION;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_TIMEOFDAY_INFORMATION</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		LARGE_INTEGER BootTime;</span><br><span class="line">		LARGE_INTEGER CurrentTime;</span><br><span class="line">		LARGE_INTEGER TimeZoneBias;</span><br><span class="line">		ULONG TimeZoneId;</span><br><span class="line">		ULONG Reserved;</span><br><span class="line">		ULONGLONG BootTimeBias;</span><br><span class="line">		ULONGLONG SleepTimeBias;</span><br><span class="line">	&#125; SYSTEM_TIMEOFDAY_INFORMATION, *PSYSTEM_TIMEOFDAY_INFORMATION;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_PROCESS_INFORMATION</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		ULONG NextEntryOffset;</span><br><span class="line">		ULONG NumberOfThreads;</span><br><span class="line">		LARGE_INTEGER SpareLi1;</span><br><span class="line">		LARGE_INTEGER SpareLi2;</span><br><span class="line">		LARGE_INTEGER SpareLi3;</span><br><span class="line">		LARGE_INTEGER CreateTime;</span><br><span class="line">		LARGE_INTEGER UserTime;</span><br><span class="line">		LARGE_INTEGER KernelTime;</span><br><span class="line">		UNICODE_STRING ImageName;</span><br><span class="line">		KPRIORITY BasePriority;</span><br><span class="line">		HANDLE UniqueProcessId;</span><br><span class="line">		HANDLE InheritedFromUniqueProcessId;</span><br><span class="line">		ULONG HandleCount;</span><br><span class="line">		ULONG SessionId;</span><br><span class="line">		ULONG_PTR PageDirectoryBase;</span><br><span class="line">		SIZE_T PeakVirtualSize;</span><br><span class="line">		SIZE_T VirtualSize;</span><br><span class="line">		ULONG PageFaultCount;</span><br><span class="line">		SIZE_T PeakWorkingSetSize;</span><br><span class="line">		SIZE_T WorkingSetSize;</span><br><span class="line">		SIZE_T QuotaPeakPagedPoolUsage;</span><br><span class="line">		SIZE_T QuotaPagedPoolUsage;</span><br><span class="line">		SIZE_T QuotaPeakNonPagedPoolUsage;</span><br><span class="line">		SIZE_T QuotaNonPagedPoolUsage;</span><br><span class="line">		SIZE_T PagefileUsage;</span><br><span class="line">		SIZE_T PeakPagefileUsage;</span><br><span class="line">		SIZE_T PrivatePageCount;</span><br><span class="line">		LARGE_INTEGER ReadOperationCount;</span><br><span class="line">		LARGE_INTEGER WriteOperationCount;</span><br><span class="line">		LARGE_INTEGER OtherOperationCount;</span><br><span class="line">		LARGE_INTEGER ReadTransferCount;</span><br><span class="line">		LARGE_INTEGER WriteTransferCount;</span><br><span class="line">		LARGE_INTEGER OtherTransferCount;</span><br><span class="line">	&#125; SYSTEM_PROCESS_INFORMATION, *PSYSTEM_PROCESS_INFORMATION;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_CALL_COUNT_INFORMATION</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		ULONG Length;</span><br><span class="line">		ULONG NumberOfTables;</span><br><span class="line">	&#125; SYSTEM_CALL_COUNT_INFORMATION, *PSYSTEM_CALL_COUNT_INFORMATION;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_DEVICE_INFORMATION</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		ULONG NumberOfDisks;</span><br><span class="line">		ULONG NumberOfFloppies;</span><br><span class="line">		ULONG NumberOfCdRoms;</span><br><span class="line">		ULONG NumberOfTapes;</span><br><span class="line">		ULONG NumberOfSerialPorts;</span><br><span class="line">		ULONG NumberOfParallelPorts;</span><br><span class="line">	&#125; SYSTEM_DEVICE_INFORMATION, *PSYSTEM_DEVICE_INFORMATION;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		LARGE_INTEGER IdleTime;</span><br><span class="line">		LARGE_INTEGER KernelTime;</span><br><span class="line">		LARGE_INTEGER UserTime;</span><br><span class="line">		LARGE_INTEGER DpcTime;          <span class="comment">// DEVL only</span></span><br><span class="line">		LARGE_INTEGER InterruptTime;    <span class="comment">// DEVL only</span></span><br><span class="line">		ULONG InterruptCount;</span><br><span class="line">	&#125; SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION, *PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_FLAGS_INFORMATION</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		ULONG Flags;</span><br><span class="line">	&#125; SYSTEM_FLAGS_INFORMATION, *PSYSTEM_FLAGS_INFORMATION;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">RTL_PROCESS_MODULE_INFORMATION</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		HANDLE Section;                 <span class="comment">// Not filled in</span></span><br><span class="line">		PVOID MappedBase;</span><br><span class="line">		PVOID ImageBase;</span><br><span class="line">		ULONG ImageSize;</span><br><span class="line">		ULONG Flags;</span><br><span class="line">		USHORT LoadOrderIndex;</span><br><span class="line">		USHORT InitOrderIndex;</span><br><span class="line">		USHORT LoadCount;</span><br><span class="line">		USHORT OffsetToFileName;</span><br><span class="line">		UCHAR  FullPathName[<span class="number">256</span>];</span><br><span class="line">	&#125; RTL_PROCESS_MODULE_INFORMATION, *PRTL_PROCESS_MODULE_INFORMATION;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">RTL_PROCESS_MODULES</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		ULONG NumberOfModules;</span><br><span class="line">		RTL_PROCESS_MODULE_INFORMATION Modules[<span class="number">1</span>];</span><br><span class="line">	&#125; RTL_PROCESS_MODULES, *PRTL_PROCESS_MODULES;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">RTL_PROCESS_LOCK_INFORMATION</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		PVOID Address;</span><br><span class="line">		USHORT Type;</span><br><span class="line">		USHORT CreatorBackTraceIndex;</span><br><span class="line">		HANDLE OwningThread;        <span class="comment">// from the thread&#x27;s ClientId-&gt;UniqueThread</span></span><br><span class="line">		LONG LockCount;</span><br><span class="line">		ULONG ContentionCount;</span><br><span class="line">		ULONG EntryCount;</span><br><span class="line">		LONG RecursionCount;</span><br><span class="line">		ULONG NumberOfWaitingShared;</span><br><span class="line">		ULONG NumberOfWaitingExclusive;</span><br><span class="line">	&#125; RTL_PROCESS_LOCK_INFORMATION, *PRTL_PROCESS_LOCK_INFORMATION;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">RTL_PROCESS_LOCKS</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		ULONG NumberOfLocks;</span><br><span class="line">		RTL_PROCESS_LOCK_INFORMATION Locks[<span class="number">1</span>];</span><br><span class="line">	&#125; RTL_PROCESS_LOCKS, *PRTL_PROCESS_LOCKS;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">RTL_PROCESS_BACKTRACE_INFORMATION</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		PCHAR SymbolicBackTrace;        <span class="comment">// Not filled in</span></span><br><span class="line">		ULONG TraceCount;</span><br><span class="line">		USHORT Index;</span><br><span class="line">		USHORT Depth;</span><br><span class="line">		PVOID BackTrace[MAX_STACK_DEPTH];</span><br><span class="line">	&#125; RTL_PROCESS_BACKTRACE_INFORMATION, *PRTL_PROCESS_BACKTRACE_INFORMATION;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">RTL_PROCESS_BACKTRACES</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		ULONG CommittedMemory;</span><br><span class="line">		ULONG ReservedMemory;</span><br><span class="line">		ULONG NumberOfBackTraceLookups;</span><br><span class="line">		ULONG NumberOfBackTraces;</span><br><span class="line">		RTL_PROCESS_BACKTRACE_INFORMATION BackTraces[<span class="number">1</span>];</span><br><span class="line">	&#125; RTL_PROCESS_BACKTRACES, *PRTL_PROCESS_BACKTRACES;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_HANDLE_TABLE_ENTRY_INFO</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		USHORT UniqueProcessId;</span><br><span class="line">		USHORT CreatorBackTraceIndex;</span><br><span class="line">		UCHAR ObjectTypeIndex;</span><br><span class="line">		UCHAR HandleAttributes;</span><br><span class="line">		USHORT HandleValue;</span><br><span class="line">		PVOID Object;</span><br><span class="line">		ULONG GrantedAccess;</span><br><span class="line">	&#125; SYSTEM_HANDLE_TABLE_ENTRY_INFO, *PSYSTEM_HANDLE_TABLE_ENTRY_INFO;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_HANDLE_INFORMATION</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		ULONG NumberOfHandles;</span><br><span class="line">		SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[<span class="number">1</span>];</span><br><span class="line">	&#125; SYSTEM_HANDLE_INFORMATION, *PSYSTEM_HANDLE_INFORMATION;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">GENERIC_MAPPING</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		ACCESS_MASK GenericRead;</span><br><span class="line">		ACCESS_MASK GenericWrite;</span><br><span class="line">		ACCESS_MASK GenericExecute;</span><br><span class="line">		ACCESS_MASK GenericAll;</span><br><span class="line">	&#125; GENERIC_MAPPING;</span><br><span class="line">	<span class="keyword">typedef</span> GENERIC_MAPPING *PGENERIC_MAPPING;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_OBJECTTYPE_INFORMATION</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		ULONG NextEntryOffset;</span><br><span class="line">		ULONG NumberOfObjects;</span><br><span class="line">		ULONG NumberOfHandles;</span><br><span class="line">		ULONG TypeIndex;</span><br><span class="line">		ULONG InvalidAttributes;</span><br><span class="line">		GENERIC_MAPPING GenericMapping;</span><br><span class="line">		ULONG ValidAccessMask;</span><br><span class="line">		ULONG PoolType;</span><br><span class="line">		BOOLEAN SecurityRequired;</span><br><span class="line">		BOOLEAN WaitableObject;</span><br><span class="line">		UNICODE_STRING TypeName;</span><br><span class="line">	&#125; SYSTEM_OBJECTTYPE_INFORMATION, *PSYSTEM_OBJECTTYPE_INFORMATION;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OBJECT_NAME_INFORMATION</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		UNICODE_STRING Name;</span><br><span class="line">	&#125; OBJECT_NAME_INFORMATION, *POBJECT_NAME_INFORMATION;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_OBJECT_INFORMATION</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		ULONG NextEntryOffset;</span><br><span class="line">		PVOID Object;</span><br><span class="line">		HANDLE CreatorUniqueProcess;</span><br><span class="line">		USHORT CreatorBackTraceIndex;</span><br><span class="line">		USHORT Flags;</span><br><span class="line">		LONG PointerCount;</span><br><span class="line">		LONG HandleCount;</span><br><span class="line">		ULONG PagedPoolCharge;</span><br><span class="line">		ULONG NonPagedPoolCharge;</span><br><span class="line">		HANDLE ExclusiveProcessId;</span><br><span class="line">		PVOID SecurityDescriptor;</span><br><span class="line">		OBJECT_NAME_INFORMATION NameInfo;</span><br><span class="line">	&#125; SYSTEM_OBJECT_INFORMATION, *PSYSTEM_OBJECT_INFORMATION;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_PAGEFILE_INFORMATION</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		ULONG NextEntryOffset;</span><br><span class="line">		ULONG TotalSize;</span><br><span class="line">		ULONG TotalInUse;</span><br><span class="line">		ULONG PeakUsage;</span><br><span class="line">		UNICODE_STRING PageFileName;</span><br><span class="line">	&#125; SYSTEM_PAGEFILE_INFORMATION, *PSYSTEM_PAGEFILE_INFORMATION;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_VDM_INSTEMUL_INFO</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		ULONG SegmentNotPresent;</span><br><span class="line">		ULONG VdmOpcode0F;</span><br><span class="line">		ULONG OpcodeESPrefix;</span><br><span class="line">		ULONG OpcodeCSPrefix;</span><br><span class="line">		ULONG OpcodeSSPrefix;</span><br><span class="line">		ULONG OpcodeDSPrefix;</span><br><span class="line">		ULONG OpcodeFSPrefix;</span><br><span class="line">		ULONG OpcodeGSPrefix;</span><br><span class="line">		ULONG OpcodeOPER32Prefix;</span><br><span class="line">		ULONG OpcodeADDR32Prefix;</span><br><span class="line">		ULONG OpcodeINSB;</span><br><span class="line">		ULONG OpcodeINSW;</span><br><span class="line">		ULONG OpcodeOUTSB;</span><br><span class="line">		ULONG OpcodeOUTSW;</span><br><span class="line">		ULONG OpcodePUSHF;</span><br><span class="line">		ULONG OpcodePOPF;</span><br><span class="line">		ULONG OpcodeINTnn;</span><br><span class="line">		ULONG OpcodeINTO;</span><br><span class="line">		ULONG OpcodeIRET;</span><br><span class="line">		ULONG OpcodeINBimm;</span><br><span class="line">		ULONG OpcodeINWimm;</span><br><span class="line">		ULONG OpcodeOUTBimm;</span><br><span class="line">		ULONG OpcodeOUTWimm;</span><br><span class="line">		ULONG OpcodeINB;</span><br><span class="line">		ULONG OpcodeINW;</span><br><span class="line">		ULONG OpcodeOUTB;</span><br><span class="line">		ULONG OpcodeOUTW;</span><br><span class="line">		ULONG OpcodeLOCKPrefix;</span><br><span class="line">		ULONG OpcodeREPNEPrefix;</span><br><span class="line">		ULONG OpcodeREPPrefix;</span><br><span class="line">		ULONG OpcodeHLT;</span><br><span class="line">		ULONG OpcodeCLI;</span><br><span class="line">		ULONG OpcodeSTI;</span><br><span class="line">		ULONG BopCount;</span><br><span class="line">	&#125; SYSTEM_VDM_INSTEMUL_INFO, *PSYSTEM_VDM_INSTEMUL_INFO;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_FILECACHE_INFORMATION</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		SIZE_T CurrentSize;</span><br><span class="line">		SIZE_T PeakSize;</span><br><span class="line">		ULONG PageFaultCount;</span><br><span class="line">		SIZE_T MinimumWorkingSet;</span><br><span class="line">		SIZE_T MaximumWorkingSet;</span><br><span class="line">		SIZE_T CurrentSizeIncludingTransitionInPages;</span><br><span class="line">		SIZE_T PeakSizeIncludingTransitionInPages;</span><br><span class="line">		ULONG TransitionRePurposeCount;</span><br><span class="line">		ULONG Flags;</span><br><span class="line">	&#125; SYSTEM_FILECACHE_INFORMATION, *PSYSTEM_FILECACHE_INFORMATION;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_POOLTAG</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">		&#123;</span></span><br><span class="line">			UCHAR Tag[<span class="number">4</span>];</span><br><span class="line">			ULONG TagUlong;</span><br><span class="line">		&#125;;</span><br><span class="line">		ULONG PagedAllocs;</span><br><span class="line">		ULONG PagedFrees;</span><br><span class="line">		SIZE_T PagedUsed;</span><br><span class="line">		ULONG NonPagedAllocs;</span><br><span class="line">		ULONG NonPagedFrees;</span><br><span class="line">		SIZE_T NonPagedUsed;</span><br><span class="line">	&#125; SYSTEM_POOLTAG, *PSYSTEM_POOLTAG;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_POOLTAG_INFORMATION</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		ULONG Count;</span><br><span class="line">		SYSTEM_POOLTAG TagInfo[<span class="number">1</span>];</span><br><span class="line">	&#125; SYSTEM_POOLTAG_INFORMATION, *PSYSTEM_POOLTAG_INFORMATION;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_INTERRUPT_INFORMATION</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		ULONG ContextSwitches;</span><br><span class="line">		ULONG DpcCount;</span><br><span class="line">		ULONG DpcRate;</span><br><span class="line">		ULONG TimeIncrement;</span><br><span class="line">		ULONG DpcBypassCount;</span><br><span class="line">		ULONG ApcBypassCount;</span><br><span class="line">	&#125; SYSTEM_INTERRUPT_INFORMATION, *PSYSTEM_INTERRUPT_INFORMATION;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_DPC_BEHAVIOR_INFORMATION</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		ULONG Spare;</span><br><span class="line">		ULONG DpcQueueDepth;</span><br><span class="line">		ULONG MinimumDpcRate;</span><br><span class="line">		ULONG AdjustDpcThreshold;</span><br><span class="line">		ULONG IdealDpcRate;</span><br><span class="line">	&#125; SYSTEM_DPC_BEHAVIOR_INFORMATION, *PSYSTEM_DPC_BEHAVIOR_INFORMATION;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_MEMORY_INFO</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		PUCHAR StringOffset;</span><br><span class="line">		USHORT ValidCount;</span><br><span class="line">		USHORT TransitionCount;</span><br><span class="line">		USHORT ModifiedCount;</span><br><span class="line">		USHORT PageTableCount;</span><br><span class="line">	&#125; SYSTEM_MEMORY_INFO, *PSYSTEM_MEMORY_INFO;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_MEMORY_INFORMATION</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		ULONG InfoSize;</span><br><span class="line">		ULONG_PTR StringStart;</span><br><span class="line">		SYSTEM_MEMORY_INFO Memory[<span class="number">1</span>];</span><br><span class="line">	&#125; SYSTEM_MEMORY_INFORMATION, *PSYSTEM_MEMORY_INFORMATION;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_EXPORT_DIRECTORY</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		DWORD   Characteristics;</span><br><span class="line">		DWORD   TimeDateStamp;</span><br><span class="line">		WORD    MajorVersion;</span><br><span class="line">		WORD    MinorVersion;</span><br><span class="line">		DWORD   Name;</span><br><span class="line">		DWORD   Base;</span><br><span class="line">		DWORD   NumberOfFunctions;</span><br><span class="line">		DWORD   NumberOfNames;</span><br><span class="line">		DWORD   AddressOfFunctions;     <span class="comment">// RVA from base of image</span></span><br><span class="line">		DWORD   AddressOfNames;         <span class="comment">// RVA from base of image</span></span><br><span class="line">		DWORD   AddressOfNameOrdinals;  <span class="comment">// RVA from base of image</span></span><br><span class="line">	&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_GDI_DRIVER_INFORMATION</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		UNICODE_STRING DriverName;</span><br><span class="line">		PVOID ImageAddress;</span><br><span class="line">		PVOID SectionPointer;</span><br><span class="line">		PVOID EntryPoint;</span><br><span class="line">		PIMAGE_EXPORT_DIRECTORY ExportSectionPointer;</span><br><span class="line">		ULONG ImageLength;</span><br><span class="line">	&#125; SYSTEM_GDI_DRIVER_INFORMATION, *PSYSTEM_GDI_DRIVER_INFORMATION;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_SET_TIME_ADJUST_INFORMATION</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		ULONG TimeAdjustment;</span><br><span class="line">		BOOLEAN Enable;</span><br><span class="line">	&#125; SYSTEM_SET_TIME_ADJUST_INFORMATION, *PSYSTEM_SET_TIME_ADJUST_INFORMATION;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KSERVICE_TABLE_DESCRIPTOR</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		PULONG_PTR Base;</span><br><span class="line">		PULONG Count;</span><br><span class="line">		ULONG Limit;</span><br><span class="line">		PUCHAR Number;</span><br><span class="line">	&#125; KSERVICE_TABLE_DESCRIPTOR, *PKSERVICE_TABLE_DESCRIPTOR;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">CLIENT_ID</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		HANDLE UniqueProcess;</span><br><span class="line">		HANDLE UniqueThread;</span><br><span class="line">	&#125; CLIENT_ID;</span><br><span class="line">	<span class="keyword">typedef</span> CLIENT_ID *PCLIENT_ID;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_THREAD_INFORMATION</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		LARGE_INTEGER KernelTime;</span><br><span class="line">		LARGE_INTEGER UserTime;</span><br><span class="line">		LARGE_INTEGER CreateTime;</span><br><span class="line">		ULONG WaitTime;</span><br><span class="line">		PVOID StartAddress;</span><br><span class="line">		CLIENT_ID ClientId;</span><br><span class="line">		KPRIORITY Priority;</span><br><span class="line">		LONG BasePriority;</span><br><span class="line">		ULONG ContextSwitches;</span><br><span class="line">		ULONG ThreadState;</span><br><span class="line">		ULONG WaitReason;</span><br><span class="line">	&#125; SYSTEM_THREAD_INFORMATION, *PSYSTEM_THREAD_INFORMATION;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_EXTENDED_THREAD_INFORMATION</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		SYSTEM_THREAD_INFORMATION ThreadInfo;</span><br><span class="line">		PVOID StackBase;</span><br><span class="line">		PVOID StackLimit;</span><br><span class="line">		PVOID Win32StartAddress;</span><br><span class="line">		ULONG_PTR Reserved1;</span><br><span class="line">		ULONG_PTR Reserved2;</span><br><span class="line">		ULONG_PTR Reserved3;</span><br><span class="line">		ULONG_PTR Reserved4;</span><br><span class="line">	&#125; SYSTEM_EXTENDED_THREAD_INFORMATION, *PSYSTEM_EXTENDED_THREAD_INFORMATION;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_EXCEPTION_INFORMATION</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		ULONG AlignmentFixupCount;</span><br><span class="line">		ULONG ExceptionDispatchCount;</span><br><span class="line">		ULONG FloatingEmulationCount;</span><br><span class="line">		ULONG ByteWordEmulationCount;</span><br><span class="line">	&#125; SYSTEM_EXCEPTION_INFORMATION, *PSYSTEM_EXCEPTION_INFORMATION;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_KERNEL_DEBUGGER_INFORMATION</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		BOOLEAN KernelDebuggerEnabled;</span><br><span class="line">		BOOLEAN KernelDebuggerNotPresent;</span><br><span class="line">	&#125; SYSTEM_KERNEL_DEBUGGER_INFORMATION, *PSYSTEM_KERNEL_DEBUGGER_INFORMATION;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_CONTEXT_SWITCH_INFORMATION</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		ULONG ContextSwitches;</span><br><span class="line">		ULONG FindAny;</span><br><span class="line">		ULONG FindLast;</span><br><span class="line">		ULONG FindIdeal;</span><br><span class="line">		ULONG IdleAny;</span><br><span class="line">		ULONG IdleCurrent;</span><br><span class="line">		ULONG IdleLast;</span><br><span class="line">		ULONG IdleIdeal;</span><br><span class="line">		ULONG PreemptAny;</span><br><span class="line">		ULONG PreemptCurrent;</span><br><span class="line">		ULONG PreemptLast;</span><br><span class="line">		ULONG SwitchToIdle;</span><br><span class="line">	&#125; SYSTEM_CONTEXT_SWITCH_INFORMATION, *PSYSTEM_CONTEXT_SWITCH_INFORMATION;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_REGISTRY_QUOTA_INFORMATION</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		ULONG  RegistryQuotaAllowed;</span><br><span class="line">		ULONG  RegistryQuotaUsed;</span><br><span class="line">		SIZE_T PagedPoolSize;</span><br><span class="line">	&#125; SYSTEM_REGISTRY_QUOTA_INFORMATION, *PSYSTEM_REGISTRY_QUOTA_INFORMATION;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_PROCESSOR_IDLE_INFORMATION</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		ULONGLONG IdleTime;</span><br><span class="line">		ULONGLONG C1Time;</span><br><span class="line">		ULONGLONG C2Time;</span><br><span class="line">		ULONGLONG C3Time;</span><br><span class="line">		ULONG     C1Transitions;</span><br><span class="line">		ULONG     C2Transitions;</span><br><span class="line">		ULONG     C3Transitions;</span><br><span class="line">		ULONG     Padding;</span><br><span class="line">	&#125; SYSTEM_PROCESSOR_IDLE_INFORMATION, *PSYSTEM_PROCESSOR_IDLE_INFORMATION;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_LEGACY_DRIVER_INFORMATION</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		ULONG VetoType;</span><br><span class="line">		UNICODE_STRING VetoList;</span><br><span class="line">	&#125; SYSTEM_LEGACY_DRIVER_INFORMATION, *PSYSTEM_LEGACY_DRIVER_INFORMATION;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">short</span> CSHORT;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">TIME_FIELDS</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		CSHORT Year;        <span class="comment">// range [1601...]</span></span><br><span class="line">		CSHORT Month;       <span class="comment">// range [1..12]</span></span><br><span class="line">		CSHORT Day;         <span class="comment">// range [1..31]</span></span><br><span class="line">		CSHORT Hour;        <span class="comment">// range [0..23]</span></span><br><span class="line">		CSHORT Minute;      <span class="comment">// range [0..59]</span></span><br><span class="line">		CSHORT Second;      <span class="comment">// range [0..59]</span></span><br><span class="line">		CSHORT Milliseconds;<span class="comment">// range [0..999]</span></span><br><span class="line">		CSHORT Weekday;     <span class="comment">// range [0..6] == [Sunday..Saturday]</span></span><br><span class="line">	&#125; TIME_FIELDS;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">RTL_TIME_ZONE_INFORMATION</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		LONG Bias;</span><br><span class="line">		WCHAR StandardName[<span class="number">32</span>];</span><br><span class="line">		TIME_FIELDS StandardStart;</span><br><span class="line">		LONG StandardBias;</span><br><span class="line">		WCHAR DaylightName[<span class="number">32</span>];</span><br><span class="line">		TIME_FIELDS DaylightStart;</span><br><span class="line">		LONG DaylightBias;</span><br><span class="line">	&#125; RTL_TIME_ZONE_INFORMATION, *PRTL_TIME_ZONE_INFORMATION;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_LOOKASIDE_INFORMATION</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		USHORT CurrentDepth;</span><br><span class="line">		USHORT MaximumDepth;</span><br><span class="line">		ULONG TotalAllocates;</span><br><span class="line">		ULONG AllocateMisses;</span><br><span class="line">		ULONG TotalFrees;</span><br><span class="line">		ULONG FreeMisses;</span><br><span class="line">		ULONG Type;</span><br><span class="line">		ULONG Tag;</span><br><span class="line">		ULONG Size;</span><br><span class="line">	&#125; SYSTEM_LOOKASIDE_INFORMATION, *PSYSTEM_LOOKASIDE_INFORMATION;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_VERIFIER_INFORMATION</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		ULONG NextEntryOffset;</span><br><span class="line">		ULONG Level;</span><br><span class="line">		UNICODE_STRING DriverName;</span><br><span class="line">		ULONG RaiseIrqls;</span><br><span class="line">		ULONG AcquireSpinLocks;</span><br><span class="line">		ULONG SynchronizeExecutions;</span><br><span class="line">		ULONG AllocationsAttempted;</span><br><span class="line">		ULONG AllocationsSucceeded;</span><br><span class="line">		ULONG AllocationsSucceededSpecialPool;</span><br><span class="line">		ULONG AllocationsWithNoTag;</span><br><span class="line">		ULONG TrimRequests;</span><br><span class="line">		ULONG Trims;</span><br><span class="line">		ULONG AllocationsFailed;</span><br><span class="line">		ULONG AllocationsFailedDeliberately;</span><br><span class="line">		ULONG Loads;</span><br><span class="line">		ULONG Unloads;</span><br><span class="line">		ULONG UnTrackedPool;</span><br><span class="line">		ULONG CurrentPagedPoolAllocations;</span><br><span class="line">		ULONG CurrentNonPagedPoolAllocations;</span><br><span class="line">		ULONG PeakPagedPoolAllocations;</span><br><span class="line">		ULONG PeakNonPagedPoolAllocations;</span><br><span class="line">		SIZE_T PagedPoolUsageInBytes;</span><br><span class="line">		SIZE_T NonPagedPoolUsageInBytes;</span><br><span class="line">		SIZE_T PeakPagedPoolUsageInBytes;</span><br><span class="line">		SIZE_T PeakNonPagedPoolUsageInBytes;</span><br><span class="line">	&#125; SYSTEM_VERIFIER_INFORMATION, *PSYSTEM_VERIFIER_INFORMATION;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_SESSION_PROCESS_INFORMATION</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		ULONG SessionId;</span><br><span class="line">		ULONG SizeOfBuf;</span><br><span class="line">		PVOID Buffer;</span><br><span class="line">	&#125; SYSTEM_SESSION_PROCESS_INFORMATION, *PSYSTEM_SESSION_PROCESS_INFORMATION;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_SESSION_POOLTAG_INFORMATION</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		SIZE_T NextEntryOffset;</span><br><span class="line">		ULONG SessionId;</span><br><span class="line">		ULONG Count;</span><br><span class="line">		SYSTEM_POOLTAG TagInfo[<span class="number">1</span>];</span><br><span class="line">	&#125; SYSTEM_SESSION_POOLTAG_INFORMATION, *PSYSTEM_SESSION_POOLTAG_INFORMATION;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_NUMA_INFORMATION</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		ULONG       HighestNodeNumber;</span><br><span class="line">		ULONG       Reserved;</span><br><span class="line">		<span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">		&#123;</span></span><br><span class="line">			ULONGLONG   ActiveProcessorsAffinityMask[MAXIMUM_NUMA_NODES];</span><br><span class="line">			ULONGLONG   AvailableMemory[MAXIMUM_NUMA_NODES];</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125; SYSTEM_NUMA_INFORMATION, *PSYSTEM_NUMA_INFORMATION;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_PROCESSOR_POWER_INFORMATION</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		UCHAR       CurrentFrequency;</span><br><span class="line">		UCHAR       ThermalLimitFrequency;</span><br><span class="line">		UCHAR       ConstantThrottleFrequency;</span><br><span class="line">		UCHAR       DegradedThrottleFrequency;</span><br><span class="line">		UCHAR       LastBusyFrequency;</span><br><span class="line">		UCHAR       LastC3Frequency;</span><br><span class="line">		UCHAR       LastAdjustedBusyFrequency;</span><br><span class="line">		UCHAR       ProcessorMinThrottle;</span><br><span class="line">		UCHAR       ProcessorMaxThrottle;</span><br><span class="line">		ULONG       NumberOfFrequencies;</span><br><span class="line">		ULONG       PromotionCount;</span><br><span class="line">		ULONG       DemotionCount;</span><br><span class="line">		ULONG       ErrorCount;</span><br><span class="line">		ULONG       RetryCount;</span><br><span class="line">		ULONGLONG   CurrentFrequencyTime;</span><br><span class="line">		ULONGLONG   CurrentProcessorTime;</span><br><span class="line">		ULONGLONG   CurrentProcessorIdleTime;</span><br><span class="line">		ULONGLONG   LastProcessorTime;</span><br><span class="line">		ULONGLONG   LastProcessorIdleTime;</span><br><span class="line">	&#125; SYSTEM_PROCESSOR_POWER_INFORMATION, *PSYSTEM_PROCESSOR_POWER_INFORMATION;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		PVOID Object;</span><br><span class="line">		ULONG_PTR UniqueProcessId;</span><br><span class="line">		ULONG_PTR HandleValue;</span><br><span class="line">		ULONG GrantedAccess;</span><br><span class="line">		USHORT CreatorBackTraceIndex;</span><br><span class="line">		USHORT ObjectTypeIndex;</span><br><span class="line">		ULONG  HandleAttributes;</span><br><span class="line">		ULONG  Reserved;</span><br><span class="line">	&#125; SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX, *PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_HANDLE_INFORMATION_EX</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		ULONG_PTR NumberOfHandles;</span><br><span class="line">		ULONG_PTR Reserved;</span><br><span class="line">		SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX Handles[<span class="number">1</span>];</span><br><span class="line">	&#125; SYSTEM_HANDLE_INFORMATION_EX, *PSYSTEM_HANDLE_INFORMATION_EX;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_BIGPOOL_ENTRY</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">		&#123;</span></span><br><span class="line">			PVOID VirtualAddress;</span><br><span class="line">			ULONG_PTR NonPaged : <span class="number">1</span>;     <span class="comment">// Set to 1 if entry is nonpaged.</span></span><br><span class="line">		&#125;;</span><br><span class="line">		SIZE_T SizeInBytes;</span><br><span class="line">		<span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">		&#123;</span></span><br><span class="line">			UCHAR Tag[<span class="number">4</span>];</span><br><span class="line">			ULONG TagUlong;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125; SYSTEM_BIGPOOL_ENTRY, *PSYSTEM_BIGPOOL_ENTRY;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_BIGPOOL_INFORMATION</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		ULONG Count;</span><br><span class="line">		SYSTEM_BIGPOOL_ENTRY AllocatedInfo[<span class="number">1</span>];</span><br><span class="line">	&#125; SYSTEM_BIGPOOL_INFORMATION, *PSYSTEM_BIGPOOL_INFORMATION;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_SESSION_MAPPED_VIEW_INFORMATION</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		SIZE_T NextEntryOffset;</span><br><span class="line">		ULONG SessionId;</span><br><span class="line">		ULONG ViewFailures;</span><br><span class="line">		SIZE_T NumberOfBytesAvailable;</span><br><span class="line">		SIZE_T NumberOfBytesAvailableContiguous;</span><br><span class="line">	&#125; SYSTEM_SESSION_MAPPED_VIEW_INFORMATION, *PSYSTEM_SESSION_MAPPED_VIEW_INFORMATION;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">WATCHDOG_HANDLER_ACTION</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		WdActionSetTimeoutValue,</span><br><span class="line">		WdActionQueryTimeoutValue,</span><br><span class="line">		WdActionResetTimer,</span><br><span class="line">		WdActionStopTimer,</span><br><span class="line">		WdActionStartTimer,</span><br><span class="line">		WdActionSetTriggerAction,</span><br><span class="line">		WdActionQueryTriggerAction,</span><br><span class="line">		WdActionQueryState</span><br><span class="line">	&#125; WATCHDOG_HANDLER_ACTION;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">WATCHDOG_INFORMATION_CLASS</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		WdInfoTimeoutValue,</span><br><span class="line">		WdInfoResetTimer,</span><br><span class="line">		WdInfoStopTimer,</span><br><span class="line">		WdInfoStartTimer,</span><br><span class="line">		WdInfoTriggerAction,</span><br><span class="line">		WdInfoState</span><br><span class="line">	&#125; WATCHDOG_INFORMATION_CLASS;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="title function_">NTSTATUS</span><span class="params">(*PWD_HANDLER)</span><span class="params">(IN WATCHDOG_HANDLER_ACTION Action, IN PVOID Context, IN OUT PULONG DataValue, IN BOOLEAN NoLocks)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_WATCHDOG_HANDLER_INFORMATION</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		PWD_HANDLER WdHandler;</span><br><span class="line">		PVOID       Context;</span><br><span class="line">	&#125; SYSTEM_WATCHDOG_HANDLER_INFORMATION, *PSYSTEM_WATCHDOG_HANDLER_INFORMATION;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_WATCHDOG_TIMER_INFORMATION</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		WATCHDOG_INFORMATION_CLASS  WdInfoClass;</span><br><span class="line">		ULONG                       DataValue;</span><br><span class="line">	&#125; SYSTEM_WATCHDOG_TIMER_INFORMATION, *PSYSTEM_WATCHDOG_TIMER_INFORMATION;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">LOGICAL_PROCESSOR_RELATIONSHIP</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		RelationProcessorCore,</span><br><span class="line">		RelationNumaNode,</span><br><span class="line">		RelationCache,</span><br><span class="line">		RelationProcessorPackage,</span><br><span class="line">		RelationGroup,</span><br><span class="line">		RelationAll = <span class="number">0xffff</span></span><br><span class="line">	&#125; LOGICAL_PROCESSOR_RELATIONSHIP;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">PROCESSOR_CACHE_TYPE</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		CacheUnified,</span><br><span class="line">		CacheInstruction,</span><br><span class="line">		CacheData,</span><br><span class="line">		CacheTrace</span><br><span class="line">	&#125; PROCESSOR_CACHE_TYPE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">CACHE_DESCRIPTOR</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		BYTE   Level;</span><br><span class="line">		BYTE   Associativity;</span><br><span class="line">		WORD   LineSize;</span><br><span class="line">		DWORD  Size;</span><br><span class="line">		PROCESSOR_CACHE_TYPE Type;</span><br><span class="line">	&#125; CACHE_DESCRIPTOR, *PCACHE_DESCRIPTOR;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_LOGICAL_PROCESSOR_INFORMATION</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		ULONG_PTR   ProcessorMask;</span><br><span class="line">		LOGICAL_PROCESSOR_RELATIONSHIP Relationship;</span><br><span class="line">		<span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">		&#123;</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">			&#123;</span></span><br><span class="line">				BYTE  Flags;</span><br><span class="line">			&#125; ProcessorCore;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">			&#123;</span></span><br><span class="line">				DWORD NodeNumber;</span><br><span class="line">			&#125; NumaNode;</span><br><span class="line">			CACHE_DESCRIPTOR Cache;</span><br><span class="line">			ULONGLONG  Reserved[<span class="number">2</span>];</span><br><span class="line">		&#125; DUMMYUNIONNAME;</span><br><span class="line">	&#125; SYSTEM_LOGICAL_PROCESSOR_INFORMATION, *PSYSTEM_LOGICAL_PROCESSOR_INFORMATION;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">SYSTEM_FIRMWARE_TABLE_ACTION</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		SystemFirmwareTable_Enumerate,</span><br><span class="line">		SystemFirmwareTable_Get</span><br><span class="line">	&#125; SYSTEM_FIRMWARE_TABLE_ACTION;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ANYSIZE_ARRAY</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ANYSIZE_ARRAY 1       <span class="comment">// winnt</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_FIRMWARE_TABLE_INFORMATION</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		ULONG                           ProviderSignature;</span><br><span class="line">		SYSTEM_FIRMWARE_TABLE_ACTION    Action;</span><br><span class="line">		ULONG                           TableID;</span><br><span class="line">		ULONG                           TableBufferLength;</span><br><span class="line">		UCHAR                           TableBuffer[ANYSIZE_ARRAY];</span><br><span class="line">	&#125; SYSTEM_FIRMWARE_TABLE_INFORMATION, *PSYSTEM_FIRMWARE_TABLE_INFORMATION;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="title function_">NTSTATUS</span><span class="params">(__cdecl *PFNFTH)</span><span class="params">(PSYSTEM_FIRMWARE_TABLE_INFORMATION)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_FIRMWARE_TABLE_HANDLER</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		ULONG       ProviderSignature;</span><br><span class="line">		BOOLEAN     Register;</span><br><span class="line">		PFNFTH      FirmwareTableHandler;</span><br><span class="line">		PVOID       DriverObject;</span><br><span class="line">	&#125; SYSTEM_FIRMWARE_TABLE_HANDLER, *PSYSTEM_FIRMWARE_TABLE_HANDLER;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>	BOOL WINAPI <span class="title function_">DuplicateHandle</span><span class="params">(</span></span><br><span class="line"><span class="params">		_In_   HANDLE hSourceProcessHandle,</span></span><br><span class="line"><span class="params">		_In_   HANDLE hSourceHandle,</span></span><br><span class="line"><span class="params">		_In_   HANDLE hTargetProcessHandle,</span></span><br><span class="line"><span class="params">		_Out_  LPHANDLE lpTargetHandle,</span></span><br><span class="line"><span class="params">		_In_   DWORD dwDesiredAccess,</span></span><br><span class="line"><span class="params">		_In_   BOOL bInheritHandle,</span></span><br><span class="line"><span class="params">		_In_   DWORD dwOptions</span></span><br><span class="line"><span class="params">	)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">OBJECT_INFORMATION_CLASS</span> &#123;</span></span><br><span class="line">		ObjectBasicInformation,</span><br><span class="line">		ObjectNameInformation,</span><br><span class="line">		ObjectTypeInformation,</span><br><span class="line">		ObjectAllInformation,</span><br><span class="line">		ObjectDataInformation,</span><br><span class="line">	&#125; OBJECT_INFORMATION_CLASS;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//typedef struct _OBJECT_NAME_INFORMATION</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	UNICODE_STRING ObjectName;</span></span><br><span class="line">	<span class="comment">//&#125;OBJECT_NAME_INFORMATION;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>		NTSTATUS WINAPI <span class="title function_">NtQueryObject</span><span class="params">(</span></span><br><span class="line"><span class="params">		_In_opt_   HANDLE Handle,</span></span><br><span class="line"><span class="params">		_In_       OBJECT_INFORMATION_CLASS ObjectInformationClass,</span></span><br><span class="line"><span class="params">		_Out_opt_  PVOID ObjectInformation,</span></span><br><span class="line"><span class="params">		_In_       ULONG ObjectInformationLength,</span></span><br><span class="line"><span class="params">		_Out_opt_  PULONG ReturnLength</span></span><br><span class="line"><span class="params">	)</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">	NTDEFS::KSERVICE_TABLE_DESCRIPTOR* KeServiceDescriptorTableShadow;</span><br><span class="line">	NTSTATUS __stdcall <span class="title function_">NtQuerySystemInformation</span><span class="params">(IN NTDEFS::SYSTEM_INFORMATION_CLASS SystemInformationClass, OUT PVOID SystemInformation, IN ULONG SystemInformationLength, OUT PULONG ReturnLength OPTIONAL)</span>;</span><br><span class="line">	HLOCAL __stdcall <span class="title function_">LocalAlloc</span><span class="params">(IN UINT uFlags, SIZE_T uBytes)</span>;</span><br><span class="line">	LPVOID __stdcall <span class="title function_">LocalLock</span><span class="params">(IN HLOCAL hMem)</span>;</span><br><span class="line">	HLOCAL __stdcall <span class="title function_">LocalFree</span><span class="params">(IN HLOCAL hMem)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> NTSTATUS NTAPI <span class="title function_">NtQueryInformationProcess</span><span class="params">(</span></span><br><span class="line"><span class="params">	IN HANDLE ProcessHandle, <span class="comment">// ���̾��</span></span></span><br><span class="line"><span class="params">	IN UINT InformationClass, <span class="comment">// ��Ϣ����</span></span></span><br><span class="line"><span class="params">	OUT PVOID ProcessInformation, <span class="comment">// ����ָ��</span></span></span><br><span class="line"><span class="params">	IN ULONG ProcessInformationLength, <span class="comment">// ���ֽ�Ϊ��λ�Ļ����С</span></span></span><br><span class="line"><span class="params">	OUT PULONG ReturnLength OPTIONAL <span class="comment">// д�뻺����ֽ���</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> PVOID PPEB;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PROCESS_BASIC_INFORMATION</span> &#123;</span></span><br><span class="line">	PVOID Reserved1;</span><br><span class="line">	PPEB PebBaseAddress;</span><br><span class="line">	PVOID Reserved2[<span class="number">2</span>];</span><br><span class="line">	ULONG_PTR UniqueProcessId;</span><br><span class="line">	PVOID Reserved3;</span><br><span class="line">&#125; PROCESS_BASIC_INFORMATION;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4" title="头像" alt="头像"></a><div class="post-copyright__author_name">ZEROKO14</div><div class="post-copyright__author_desc">zeroko14's blog</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://che77a38.github.io/posts/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://che77a38.github.io/posts/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/')">驱动开发</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://che77a38.github.io/posts/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=驱动开发&amp;url=https://che77a38.github.io/posts/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://che77a38.github.io" target="_blank">ZEROKO14的个人博客</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E5%86%85%E6%A0%B8%E7%9B%B8%E5%85%B3/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>内核相关<span class="tagsPageCount">5</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">待解决问题汇总</div></div></a></div><div class="next-post pull-right"><a href="/posts/32%E4%BD%8D%E9%80%86%E5%90%91/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">32位逆向</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/posts/%E5%8F%A5%E6%9F%84%E8%A1%A8/" title="句柄表"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-11-24</div><div class="title">句柄表</div></div></a></div><div><a href="/posts/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/" title="保护模式"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-11-24</div><div class="title">保护模式</div></div></a></div><div><a href="/posts/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/" title="系统调用"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-11-24</div><div class="title">系统调用</div></div></a></div><div><a href="/posts/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/" title="进程与线程"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-11-24</div><div class="title">进程与线程</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description">欢迎来到ZEROKO14的个人博客</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">ZEROKO14</h1><div class="author-info__desc">zeroko14's blog</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/che77a38" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91"><span class="toc-number">1.</span> <span class="toc-text">驱动开发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="toc-number">1.1.</span> <span class="toc-text">准备工作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%8F%8C%E6%9C%BA%E8%B0%83%E8%AF%95%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.1.1.</span> <span class="toc-text">设置双机调试步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AEwindbg%E8%BF%9E%E6%8E%A5%E5%93%AA%E4%B8%AA%E4%B8%B2%E5%8F%A3"><span class="toc-number">1.1.2.</span> <span class="toc-text">设置windbg连接哪个串口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E7%AC%A6%E5%8F%B7"><span class="toc-number">1.1.3.</span> <span class="toc-text">设置符号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#windbg%E8%B0%83%E8%AF%95%E8%93%9D%E5%B1%8Fdump%E6%96%87%E4%BB%B6"><span class="toc-number">1.1.4.</span> <span class="toc-text">windbg调试蓝屏dump文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AEdump%E6%96%87%E4%BB%B6%E7%94%9F%E6%88%90%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">操作系统设置dump文件生成步骤</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PDB%EF%BC%88Program-Debug-Database%EF%BC%89"><span class="toc-number">1.2.</span> <span class="toc-text">PDB（Program Debug Database）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.3.</span> <span class="toc-text">第一个驱动程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6Wdm-h%E3%80%81Ntddk-h-%E5%92%8C-Ntifs-h-%E7%9A%84%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.1.</span> <span class="toc-text">头文件Wdm.h、Ntddk.h 和 Ntifs.h 的组织结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="toc-number">1.4.</span> <span class="toc-text">内核编程基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8API%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.4.1.</span> <span class="toc-text">内核API的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AA%E5%AF%BC%E5%87%BA%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.4.2.</span> <span class="toc-text">未导出函数的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.3.</span> <span class="toc-text">基本数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">1.4.4.</span> <span class="toc-text">返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">1.4.5.</span> <span class="toc-text">内核函数中的异常处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E5%86%85%E6%A0%B8%E5%86%85%E5%AD%98%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.6.</span> <span class="toc-text">常用的内核内存函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%A7%8D%E7%B1%BB"><span class="toc-number">1.4.7.</span> <span class="toc-text">内核字符串种类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E5%85%B6%E4%BB%96%E5%86%85%E6%A0%B8API%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.8.</span> <span class="toc-text">常用的其他内核API函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IRQL%E4%B8%AD%E6%96%AD%E8%AF%B7%E6%B1%82%E7%BA%A7%E5%88%AB"><span class="toc-number">1.4.9.</span> <span class="toc-text">IRQL中断请求级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8%E5%86%85%E6%A0%B8%E6%A1%86%E6%9E%B6"><span class="toc-number">1.4.10.</span> <span class="toc-text">驱动内核框架</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Windows%E7%9A%84%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B%E5%8F%98%E8%BF%81"><span class="toc-number">1.4.10.1.</span> <span class="toc-text">Windows的驱动开发模型变迁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%BB%E8%A6%81%E8%B0%83%E7%94%A8%E6%BA%90%EF%BC%9A"><span class="toc-number">1.4.10.2.</span> <span class="toc-text">内核编程的主要调用源：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">1.4.10.3.</span> <span class="toc-text">函数的多线程安全性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B8%AD%E6%96%AD%E7%BA%A7"><span class="toc-number">1.4.10.4.</span> <span class="toc-text">代码的中断级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WDK%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E7%89%B9%E6%AE%8A%E4%BB%A3%E7%A0%81"><span class="toc-number">1.4.10.5.</span> <span class="toc-text">WDK中出现的特殊代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#IN%E5%92%8COUT"><span class="toc-number">1.4.10.5.1.</span> <span class="toc-text">IN和OUT</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#pragma-alloc-text"><span class="toc-number">1.4.10.5.2.</span> <span class="toc-text">#pragma alloc_text</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97"><span class="toc-number">1.5.</span> <span class="toc-text">内核空间与内核模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4"><span class="toc-number">1.5.1.</span> <span class="toc-text">内核空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97"><span class="toc-number">1.5.2.</span> <span class="toc-text">内核模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DRIVER-OBJECT%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">DRIVER_OBJECT结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LDR-DATA-TABLE-ENTRY%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">_LDR_DATA_TABLE_ENTRY结构体</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E5%B9%B6%E6%96%AD%E9%93%BE%E4%BD%9C%E4%B8%9A"><span class="toc-number">1.5.3.</span> <span class="toc-text">遍历内核模块并断链作业</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E6%96%AD%E9%93%BE%E8%93%9D%E5%B1%8FMiProcessLoaderEntry"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">避免断链蓝屏MiProcessLoaderEntry</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8%E9%94%AE%E9%BC%A0%E8%BF%87%E6%BB%A4"><span class="toc-number">1.5.4.</span> <span class="toc-text">驱动键鼠过滤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E9%93%BE%E8%A1%A8"><span class="toc-number">1.6.</span> <span class="toc-text">驱动开发中的链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%B6%E7%8E%AF%E4%B8%8E%E4%B8%89%E7%8E%AF%E9%80%9A%E4%BF%A1-%E5%B8%B8%E8%A7%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.7.</span> <span class="toc-text">零环与三环通信(常规方式)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%AE%BE%E5%A4%87%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.7.1.</span> <span class="toc-text">创建设备对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">设备对象结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IoCreateDevice"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">IoCreateDevice</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%AE%BE%E5%A4%87%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.7.2.</span> <span class="toc-text">删除设备对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E4%BA%A4%E4%BA%92%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.7.3.</span> <span class="toc-text">设置交互数据的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%8D%B8%E8%BD%BD%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5"><span class="toc-number">1.7.4.</span> <span class="toc-text">创建与卸载符号链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IRP%E4%B8%8E%E6%B4%BE%E9%81%A3%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.5.</span> <span class="toc-text">IRP与派遣函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IRP%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.7.5.1.</span> <span class="toc-text">IRP类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#IRP%E7%BB%93%E6%9E%84"><span class="toc-number">1.7.5.1.1.</span> <span class="toc-text">IRP结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#IO-STACK-LOCATION%E7%BB%93%E6%9E%84"><span class="toc-number">1.7.5.1.2.</span> <span class="toc-text">IO_STACK_LOCATION结构</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B4%BE%E9%81%A3%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.5.2.</span> <span class="toc-text">派遣函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B4%BE%E9%81%A3%E5%87%BD%E6%95%B0%E5%9C%A8%E5%93%AA%E9%87%8C%E6%B3%A8%E5%86%8C%E5%91%A2%EF%BC%9F"><span class="toc-number">1.7.5.2.1.</span> <span class="toc-text">派遣函数在哪里注册呢？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E6%B4%BE%E9%81%A3%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.5.2.2.</span> <span class="toc-text">注册派遣函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B4%BE%E9%81%A3%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.7.5.3.</span> <span class="toc-text">派遣函数的格式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#IRP-MJ-DEVICE-CONTROL%E7%9A%84%E6%B4%BE%E9%81%A3%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.5.3.1.</span> <span class="toc-text">IRP_MJ_DEVICE_CONTROL的派遣函数</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#CTL%E6%93%8D%E4%BD%9C%E7%A0%81"><span class="toc-number">1.7.5.3.1.1.</span> <span class="toc-text">CTL操作码</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#IRP-MJ-DEVICE-CONTROL%E7%9A%84%E6%B4%BE%E9%81%A3%E5%87%BD%E6%95%B0%E7%BC%96%E5%86%99"><span class="toc-number">1.7.5.3.1.2.</span> <span class="toc-text">IRP_MJ_DEVICE_CONTROL的派遣函数编写</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%89%E7%8E%AF%E5%86%99%E6%B3%95"><span class="toc-number">1.7.5.3.1.3.</span> <span class="toc-text">三环写法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IRP-MJ-DEVICE-CONTROL%E4%BA%A4%E4%BA%92%E6%95%B0%E6%8D%AE%E5%AE%9E%E9%AA%8C"><span class="toc-number">1.7.6.</span> <span class="toc-text">IRP_MJ_DEVICE_CONTROL交互数据实验</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#R0%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="toc-number">1.7.6.1.</span> <span class="toc-text">R0代码：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#R3%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="toc-number">1.7.6.2.</span> <span class="toc-text">R3代码：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.8.</span> <span class="toc-text">驱动加载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8%E6%B3%A8%E5%86%8C-%E5%AE%89%E8%A3%85"><span class="toc-number">1.8.1.</span> <span class="toc-text">驱动注册&#x2F;安装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#OpenSCManagerA%E5%87%BD%E6%95%B0"><span class="toc-number">1.8.1.1.</span> <span class="toc-text">OpenSCManagerA函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%9C%8D%E5%8A%A1CreateServiceA%E5%87%BD%E6%95%B0"><span class="toc-number">1.8.1.2.</span> <span class="toc-text">创建服务CreateServiceA函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8%E5%90%AF%E5%8A%A8"><span class="toc-number">1.8.2.</span> <span class="toc-text">驱动启动</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E5%BC%80%E6%9C%8D%E5%8A%A1OpenServiceA%E5%87%BD%E6%95%B0"><span class="toc-number">1.8.2.1.</span> <span class="toc-text">打开服务OpenServiceA函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E5%A7%8B%E6%9C%8D%E5%8A%A1StartServiceA%E5%87%BD%E6%95%B0"><span class="toc-number">1.8.2.2.</span> <span class="toc-text">开始服务StartServiceA函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%9C%E6%AD%A2%E9%A9%B1%E5%8A%A8"><span class="toc-number">1.8.3.</span> <span class="toc-text">停止驱动</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%9C%8D%E5%8A%A1ControlService%E5%87%BD%E6%95%B0"><span class="toc-number">1.8.3.1.</span> <span class="toc-text">控制服务ControlService函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%B8%E8%BD%BD%E9%A9%B1%E5%8A%A8"><span class="toc-number">1.8.4.</span> <span class="toc-text">卸载驱动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8%E5%8A%A0%E8%BD%BD-%E5%90%AF%E5%8A%A8-%E5%81%9C%E6%AD%A2-%E5%8D%B8%E8%BD%BD%E6%A1%88%E4%BE%8B"><span class="toc-number">1.8.5.</span> <span class="toc-text">驱动加载&#x2F;启动&#x2F;停止&#x2F;卸载案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E7%9B%91%E5%90%ACAPI%E5%AE%9E%E9%AA%8C"><span class="toc-number">1.9.</span> <span class="toc-text">全局监听API实验</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#R0%E4%BB%A3%E7%A0%81"><span class="toc-number">1.9.1.</span> <span class="toc-text">R0代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#R3%E4%BB%A3%E7%A0%81"><span class="toc-number">1.9.2.</span> <span class="toc-text">R3代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E9%9A%BE%E7%82%B9"><span class="toc-number">1.9.3.</span> <span class="toc-text">重难点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Inline-Hook"><span class="toc-number">1.10.</span> <span class="toc-text">Inline Hook</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E7%B3%BB%E7%BB%9F%E5%9B%9E%E8%B0%83%E4%BF%9D%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.11.</span> <span class="toc-text">注册系统回调保护进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0ObRegisterCallbacks"><span class="toc-number">1.11.1.</span> <span class="toc-text">核心函数ObRegisterCallbacks</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#OB-CALLBACK-REGISTRATION%E7%BB%93%E6%9E%84"><span class="toc-number">1.11.1.1.</span> <span class="toc-text">OB_CALLBACK_REGISTRATION结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OB-OPERATION-REGISTRATION%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.11.1.2.</span> <span class="toc-text">_OB_OPERATION_REGISTRATION结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">1.11.1.3.</span> <span class="toc-text">自定义回调函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E7%B3%BB%E7%BB%9F%E5%9B%9E%E8%B0%83%E6%A1%88%E4%BE%8B"><span class="toc-number">1.11.1.4.</span> <span class="toc-text">注册系统回调案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E5%85%85"><span class="toc-number">1.11.2.</span> <span class="toc-text">补充</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E6%9D%83%E9%99%90"><span class="toc-number">1.11.2.1.</span> <span class="toc-text">进程有哪些权限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8%E4%B8%AD%E9%80%9A%E8%BF%87%E8%BF%9B%E7%A8%8B%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84%E4%BD%93%E9%A6%96%E5%9C%B0%E5%9D%80%E8%8E%B7%E5%8F%96%E8%BF%9B%E7%A8%8B%E5%90%8D"><span class="toc-number">1.11.2.2.</span> <span class="toc-text">驱动中通过进程对象结构体首地址获取进程名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8Bid%E8%8E%B7%E5%8F%96%E8%BF%9B%E7%A8%8B%E5%90%8D"><span class="toc-number">1.11.2.3.</span> <span class="toc-text">进程id获取进程名</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">1.11.2.3.1.</span> <span class="toc-text">另一种实现方式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8%E4%B8%AD%E8%AE%BE%E7%BD%AE%E6%96%AD%E7%82%B9"><span class="toc-number">1.11.2.4.</span> <span class="toc-text">驱动中设置断点:</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%9A%84%E6%96%B9%E5%BC%8F%E4%B8%8B%E6%96%AD%E7%82%B9"><span class="toc-number">1.11.2.4.1.</span> <span class="toc-text">代码的方式下断点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#windbg%E7%9B%B4%E6%8E%A5%E4%B8%8B%E6%96%AD%E7%82%B9"><span class="toc-number">1.11.2.4.2.</span> <span class="toc-text">windbg直接下断点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E8%AF%BB%E5%86%99%E7%BB%95%E8%BF%87%E7%B3%BB%E7%BB%9F%E5%9B%9E%E8%B0%83%E4%BF%9D%E6%8A%A4"><span class="toc-number">1.11.3.</span> <span class="toc-text">远程读写绕过系统回调保护</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8C%82%E9%9D%A0%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.11.3.1.</span> <span class="toc-text">进程挂靠的方式实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.11.3.1.1.</span> <span class="toc-text">读进程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%99%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.11.3.1.2.</span> <span class="toc-text">写进程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MDL%E6%96%B9%E5%BC%8F"><span class="toc-number">1.11.3.2.</span> <span class="toc-text">MDL方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E5%86%85%E5%AD%98"><span class="toc-number">1.11.3.2.1.</span> <span class="toc-text">读内存</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%99%E5%86%85%E5%AD%98"><span class="toc-number">1.11.3.2.2.</span> <span class="toc-text">写内存</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CR0%E6%96%B9%E5%BC%8F%E5%86%99%E5%8F%AA%E8%AF%BB%E5%86%85%E5%AD%98"><span class="toc-number">1.11.3.3.</span> <span class="toc-text">CR0方式写只读内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E8%AF%BB%E5%86%99%E5%86%85%E5%AD%98%E6%96%B9%E6%B3%95"><span class="toc-number">1.11.3.4.</span> <span class="toc-text">物理内存读写内存方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0"><span class="toc-number">1.11.3.4.1.</span> <span class="toc-text">核心函数</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#ZwMapViewOfSection"><span class="toc-number">1.11.3.4.1.1.</span> <span class="toc-text">ZwMapViewOfSection</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="toc-number">1.11.3.4.2.</span> <span class="toc-text">完整代码</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9C%80%E5%A4%96%E5%B1%82%E7%9A%84%E8%AF%BB%E5%86%99%E5%86%85%E5%AD%98%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.11.3.4.2.1.</span> <span class="toc-text">最外层的读写内存接口</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%9C%80%E5%A4%A7%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E5%87%BD%E6%95%B0"><span class="toc-number">1.11.3.4.2.2.</span> <span class="toc-text">获取最大物理地址函数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E5%80%BC%E5%87%BD%E6%95%B0"><span class="toc-number">1.11.3.4.2.3.</span> <span class="toc-text">获取物理地址的值函数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E8%AF%BB%E5%86%99%E5%87%BD%E6%95%B0"><span class="toc-number">1.11.3.4.2.4.</span> <span class="toc-text">物理内存读写函数</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%92%88%E5%AF%B9%E5%AF%B9%E8%B1%A1%E5%9B%9E%E8%B0%83%E9%92%A9%E5%AD%90%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">1.12.</span> <span class="toc-text">针对对象回调钩子的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E5%AF%B9%E8%B1%A1%E9%92%A9%E5%AD%90"><span class="toc-number">1.12.1.</span> <span class="toc-text">遍历进程&#x2F;线程对象钩子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E7%94%A8%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%93%E6%9E%84%E5%92%8C%E5%8F%98%E9%87%8F"><span class="toc-number">1.12.1.1.</span> <span class="toc-text">需要用的自定义结构和变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E5%9B%9E%E8%B0%83%E9%9C%80%E8%A6%81%E7%94%A8%E5%88%B0%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%90%E5%87%BD%E6%95%B0-%E5%8C%85%E5%90%AB%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"><span class="toc-number">1.12.1.2.</span> <span class="toc-text">遍历回调需要用到的自定义子函数(包含依赖关系)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">1.12.1.3.</span> <span class="toc-text">遍历回调函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E7%BE%8E%E8%BF%87%E6%8E%89%E5%AF%B9%E8%B1%A1%E4%BF%9D%E6%8A%A4%E9%92%A9%E5%AD%90"><span class="toc-number">1.12.2.</span> <span class="toc-text">完美过掉对象保护钩子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E7%94%A8%E5%88%B0%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">1.12.2.1.</span> <span class="toc-text">需要用到的结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E7%94%A8%E5%88%B0%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%90%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8A%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">1.12.2.2.</span> <span class="toc-text">需要用到的自定义子函数以及全局变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="toc-number">1.12.2.3.</span> <span class="toc-text">接口函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%A5%E6%9F%84%E8%A1%A8%E9%81%8D%E5%8E%86%E7%9B%B8%E5%85%B3"><span class="toc-number">1.13.</span> <span class="toc-text">句柄表遍历相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#R3%E5%8F%A5%E6%9F%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.13.1.</span> <span class="toc-text">R3句柄遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#NtQuerySystemInformation%E5%87%BD%E6%95%B0"><span class="toc-number">1.13.1.1.</span> <span class="toc-text">NtQuerySystemInformation函数</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E9%A1%B9%E7%9B%AE%E5%8F%82%E8%80%83"><span class="toc-number">2.</span> <span class="toc-text">完整项目参考</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E5%90%8D%E8%AF%8D%E7%90%86%E8%A7%A3"><span class="toc-number">3.</span> <span class="toc-text">一些名词理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%BE%E5%90%8D%E7%9B%B8%E5%85%B3"><span class="toc-number">3.0.1.</span> <span class="toc-text">签名相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%BE%E5%90%8D%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8"><span class="toc-number">3.0.1.1.</span> <span class="toc-text">签名工具使用</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#64%E4%BD%8D16%E8%BF%9B%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C"><span class="toc-number">4.</span> <span class="toc-text">64位16进制字符串操作</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E5%AE%9A%E9%A9%B1%E5%8A%A8%E5%92%8C%E7%94%A8%E6%88%B7%E5%B1%82%E7%9B%B8%E6%8E%A5%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">5.</span> <span class="toc-text">设定驱动和用户层相接数据结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#R3%E7%94%A8%E5%88%B0%E7%9A%84%E5%86%85%E6%A0%B8%E7%9B%B8%E5%85%B3%E7%BB%93%E6%9E%84%E4%BD%93%E5%A4%A7%E6%95%B4%E5%90%88"><span class="toc-number">6.</span> <span class="toc-text">R3用到的内核相关结构体大整合</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/avalonia/" title="avalonia">avalonia</a><time datetime="2024-09-11T14:51:13.000Z" title="发表于 2024-09-11 22:51:13">2024-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/%E8%A7%86%E9%A2%91%E6%95%88%E6%9E%9C/" title="PR">PR</a><time datetime="2024-07-18T07:06:08.330Z" title="发表于 2024-07-18 15:06:08">2024-07-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/%E5%89%8D%E7%AB%AF/" title="WEB前端">WEB前端</a><time datetime="2024-07-18T07:06:08.323Z" title="发表于 2024-07-18 15:06:08">2024-07-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/slidev/" title="slidev">slidev</a><time datetime="2024-07-18T07:06:08.319Z" title="发表于 2024-07-18 15:06:08">2024-07-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="C++多线程">C++多线程</a><time datetime="2024-07-18T07:05:59.794Z" title="发表于 2024-07-18 15:05:59">2024-07-18</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2024 By <a class="footer-bar-link" href="/" title="ZEROKO14" target="_blank">ZEROKO14</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu"></a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">57</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">48</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">6</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size: 0.88rem;">C#<sup>3</sup></a><a href="/tags/C/" style="font-size: 0.88rem;">C++<sup>5</sup></a><a href="/tags/CSS/" style="font-size: 0.88rem;">CSS<sup>1</sup></a><a href="/tags/CSharp/" style="font-size: 0.88rem;">CSharp<sup>1</sup></a><a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 0.88rem;">C语言<sup>1</sup></a><a href="/tags/FPS/" style="font-size: 0.88rem;">FPS<sup>1</sup></a><a href="/tags/HTML/" style="font-size: 0.88rem;">HTML<sup>1</sup></a><a href="/tags/JavaScript/" style="font-size: 0.88rem;">JavaScript<sup>1</sup></a><a href="/tags/MFC/" style="font-size: 0.88rem;">MFC<sup>1</sup></a><a href="/tags/PE/" style="font-size: 0.88rem;">PE<sup>1</sup></a><a href="/tags/QT/" style="font-size: 0.88rem;">QT<sup>1</sup></a><a href="/tags/WPF/" style="font-size: 0.88rem;">WPF<sup>3</sup></a><a href="/tags/ai/" style="font-size: 0.88rem;">ai<sup>1</sup></a><a href="/tags/cmake/" style="font-size: 0.88rem;">cmake<sup>1</sup></a><a href="/tags/doxygen/" style="font-size: 0.88rem;">doxygen<sup>1</sup></a><a href="/tags/git/" style="font-size: 0.88rem;">git<sup>1</sup></a><a href="/tags/json/" style="font-size: 0.88rem;">json<sup>1</sup></a><a href="/tags/linux/" style="font-size: 0.88rem;">linux<sup>1</sup></a><a href="/tags/next/" style="font-size: 0.88rem;">next<sup>1</sup></a><a href="/tags/ppt/" style="font-size: 0.88rem;">ppt<sup>1</sup></a><a href="/tags/slidev/" style="font-size: 0.88rem;">slidev<sup>1</sup></a><a href="/tags/vue/" style="font-size: 0.88rem;">vue<sup>1</sup></a><a href="/tags/xml/" style="font-size: 0.88rem;">xml<sup>1</sup></a><a href="/tags/yaml/" style="font-size: 0.88rem;">yaml<sup>1</sup></a><a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 0.88rem;">代码规范<sup>1</sup></a><a href="/tags/%E5%86%85%E6%A0%B8/" style="font-size: 0.88rem;">内核<sup>2</sup></a><a href="/tags/%E5%86%85%E6%A0%B8%E7%9B%B8%E5%85%B3/" style="font-size: 0.88rem;">内核相关<sup>5</sup></a><a href="/tags/%E5%8A%A0%E8%A7%A3%E5%AF%86/" style="font-size: 0.88rem;">加解密<sup>1</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 0.88rem;">多线程<sup>1</sup></a><a href="/tags/%E5%BC%80%E5%8F%91/" style="font-size: 0.88rem;">开发<sup>4</sup></a><a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 0.88rem;">数学<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 0.88rem;">数据库<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 0.88rem;">数据结构<sup>1</sup></a><a href="/tags/%E6%9E%B6%E6%9E%84/" style="font-size: 0.88rem;">架构<sup>1</sup></a><a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 0.88rem;">正则表达式<sup>1</sup></a><a href="/tags/%E7%9B%91%E6%8E%A7/" style="font-size: 0.88rem;">监控<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 0.88rem;">算法<sup>1</sup></a><a href="/tags/%E7%AE%A1%E7%90%86/" style="font-size: 0.88rem;">管理<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 0.88rem;">网络<sup>2</sup></a><a href="/tags/%E9%80%86%E5%90%91/" style="font-size: 0.88rem;">逆向<sup>2</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.cbd.int/mermaid@10.2.4/dist/mermaid.min.js').then(runMermaid)
  }

  anzhiyu.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>