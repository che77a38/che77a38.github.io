<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>保护模式 | ZEROKO14的个人博客</title><meta name="keywords" content="内核相关"><meta name="author" content="ZEROKO14"><meta name="copyright" content="ZEROKO14"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#18171d"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="保护模式"><meta name="application-name" content="保护模式"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#18171d"><meta property="og:type" content="article"><meta property="og:title" content="保护模式"><meta property="og:url" content="https://che77a38.github.io/posts/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/index.html"><meta property="og:site_name" content="ZEROKO14的个人博客"><meta property="og:description" content="Q：什么是保护模式？   A：x86 CPU的3个模式：  实模式 保护模式（虚拟8086模式） 系统管理模式   现在的操作系统大多数都是运行于保护模式下的 保护模式就是指给操作系统添加的保护特性，保护的目标是硬件资源和OS内核。 学习前的环境配置由于本人使用的操作系统是win10 1909，因此"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4"><meta property="article:author" content="ZEROKO14"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4"><meta name="description" content="Q：什么是保护模式？   A：x86 CPU的3个模式：  实模式 保护模式（虚拟8086模式） 系统管理模式   现在的操作系统大多数都是运行于保护模式下的 保护模式就是指给操作系统添加的保护特性，保护的目标是硬件资源和OS内核。 学习前的环境配置由于本人使用的操作系统是win10 1909，因此"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://che77a38.github.io/posts/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2024/07/27/125766904/ba62475f396df9de3316a08ed9e65d86_5680958632268053399..png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":true,"limitCount":50,"languages":{"author":"作者: ZEROKO14","link":"链接: ","source":"来源: ZEROKO14的个人博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'ZEROKO14的个人博客',
  title: '保护模式',
  postAI: '',
  pageFillDescription: '学习前的环境配置, 双机调试配置, 开始双机调试, WinDbg的退出, 保护模式–段, 段寄存器结构, 段寄存器的结构, 段寄存器的读写, 读段寄存器, 写段寄存器, 段寄存器属性探测, 段描述符与段选择子, 段描述符, 段选择子, 加载段描述符到段寄存器, 段描述符的属性, P位和G位, P位, G位, S位和TYPE域, S位, TYPE域, Dx2FB位, AVL属性, 段权限检查（CPLRPLDPL）, 如何查看程序处于几环, 数据段的权限检查, 词汇总结, 代码跨段, 代码间的跳转(段间跳转	非调用门之类的), 执行流程, 【总结】, 【最终总结】, 实验, 长调用与短调用, 短调用, 长调用(跨段不提权), 长调用(跨段并提权), 【总结】, 调用门, 调用门(无参), 门描述符的结构, 调用门指令流程, 【重点】调用门权限相关, 实验, 调用门(有参), 实验, 【总结】, 中断门, 中断指令, 中断门的堆栈和返回, IDT, IDT表的构成, 中断门描述符, 中断门提权实验, 调用门与中断门的区别, 【重点理解】各种返回加深理解, 【实验】在调用门中实现使用IRETD返回在中断门中实现用RETF返回, 中断门用RETF返回, 调用门用iretd 返回, 陷阱门, 任务段TSS(难点非重点), TSS和TR寄存器, TSS的作用, CPU是如何找到TSS的, TSS段描述符, TR寄存器的读写, 修改TR寄存器, CALL FAR或者JMP FAR一个任务段描述符的不同点（重点）, TSS段描述符实验, CALL实验返回, JMP实验返回, JMP实验中test头添加int观察实验, 任务门, 任务门描述符, 任务门的执行过程, 课后练习：实现任务门进1环。, 逆向int 8实验, LDT相关, 自己构建LDT表和其中的数据段描述符实验, 保护模式–页, 10-10-12分页, PDE与PTE, 页目录表PDT基址(线性地址), 页表PTT基址(线性地址), 小实验, 掌握一个进程所有的物理内存读写权限【公式总结】, 实验, 10-10-12内核逆向分析MmIsAddressValid函数, 用IDA, 用windbg, 2-9-9-12分页, 页目录指针表项Page-Dircetory-Point-Table Entry, PDE结构, PTE结构, Xx2FD标志位, 2-9-9-12内核逆向分析MmIsAddressValid函数, 旁路转换缓冲TLB, TLB种类, TLB相关实验, 体验TLB的存在, 全局页的意义, INVLPG指令的意义, 中断与异常, 中断, 异常, 控制寄存器CR, CR0寄存器, CR2寄存器, CR4寄存器, PDEPTE中的PWT和PCD位, 保护模式阶段总结, 第一题, 第二题, 补充知识点, CPU信息查询, MDL？物理页地址映射？什么是保护模式的个模式实模式保护模式虚拟模式系统管理模式现在的操作系统大多数都是运行于保护模式下的保护模式就是指给操作系统添加的保护特性保护的目标是硬件资源和内核学习前的环境配置由于本人使用的操作系统是因此开发当前版本的驱动需要或者版本安装要设置的桌面开发通用平台开发勾选拓展开发完事了也安装版本版本安装链接跳转要注意在单个组件中选上环境配置的参考网址小注意点微软官网下载时有必须等他一段时间弹出下载不要再点重新下载不然重新下载的是而不是下载完毕后再到微软官网下载至此环境就装好了虚拟机和符号表对应下载双机调试配置由于系统调试要下断点下断点后系统将只有调试子系统继续运行因此不能直接调试本机的系统因此需要双机调试配置配置双机调试流程在本机安装上述配环境的时候装里面自带有在虚拟机中修改修改系统启动项盘显示隐藏文件找到打开原内容新内容红线为添加行表示调试模式第一段黄标为名字可以随便起表示指定的调试串口为下图可见原本只有一个串口黄标是为后续步骤虚拟机设置步骤中添加的串口自己添加的启动项如下图黄标设置虚拟机为虚拟机新增一个串口设备添加步骤打印机也会占用一个串口添加好后查看设备管理器黄标为我们刚添加的新串口修改运行参数指向虚拟机的选择简单参考调试机器是位系统就用位位系统就位实则更为复杂用于开发驱动的驱动开发包准备工作做好后开始双机调试必须在下图界面的时候先别按回车本机上打开设置好的显示正在连接再到虚拟机中点击回车系统进入调试模式此时成功断下效果如下此时系统是断下状态因此是类似黑屏此时在命令行中输入表示让系统继续执行之后还想中断的话按下图按钮至此双机调试配置成功保护模式学习的时候尽量虚拟机要设置为单核防止干扰的退出通过或者退出调试并销毁被调试进程通过退出调试但被调试进程继续运行部分使用方式一些细节不支持将数据直接送入寄存器的操作这条指令是非法的想要将送入需要使用一个寄存器进行中转先将送入一个一般的寄存器再将这个寄存器中的内容送入的入栈和出栈操作都是以字为单位进行的栈空的时候指向栈空间最高地址单元的下一个单元如果把这段空间当作栈初始状态栈是空的的时候用或者而不是来将清零的主要原因是前两个在位下的机器码是个字节而的机器码是个字节执行时要进行两步操作先改变后向处传送执行时先读取处的数据然后改变一个栈段最大在环境下因为栈顶的变化范围是如果一直压栈的话栈顶将环绕覆盖原来栈中的内容在汇编源程序中数据不能以字母开头所以要在前面加为什么不直接学习是由推出的一种复杂指令集能够生产支持这种指令集公司主要是和在年的时候拓展了这套指令集称为后改名为也兼容了这个产品称为但和几乎是一样的所以在很多资料中统称为而这套指令集是对的拓展向下兼容的保护模式有什么特点段的机制页的机制通过这两种机制来达到保护系统的一些数据结构还有一些关键的寄存器的目的学习保护模式有什么用真正理解内核是如何运作的参考书白皮书第三卷章白皮书第二卷是查指令的白皮书第三卷是讲保护模式的保护模式段保护模式的种重要机制段页保护模式知识结构总览段的机制非常复杂想了解段的机制要先了解段寄存器为何需要段的机制位系统的寄存器为位二进制只可以寻址的次方除以等于的大小内存左移四位再加一千来索引内存因此出现了段的机制可以解决这个问题由于位系统寄存器是位所以上述功能的功能已经被弱化了仅留下重要的是权限检查机制位以后现在除了寄存器以外其他段寄存器的字段已经全部设置为了段寄存器结构段寄存器有哪些等等代码段寄存器存放当前正在运行的程序代码所在段的段基址表示当前使用的指令代码可以从该段寄存器指定的存储器段中取得相应的偏移量则由提供数据段寄存器指出当前程序使用的数据所存放段的最低地址即存放数据段的段基址堆栈段寄存器指出当前堆栈的底部地址即存放堆栈段的段基址附加段寄存器指出当前程序使用附加数据段的段基址该段是串操作指令中目的串所在的段段寄存器的结构位可见部分段选择子位位位我们能看到的段寄存器的值只有可见部分的位段寄存器中有位是可见部分有八十位是不可见部分一共位可见部分为位的部分位的为这个段寄存器的属性它的意义为表示该段寄存器是可读还是可写还是可执行的位的表示该段是从哪里开始的位的表示整个段的长度有多少段寄存器的读写读段寄存器比如读的时候只能读位的可见部分必须写不能写其他如读写的指令为读写的指令为写段寄存器比如写时是写位段寄存器属性探测段寄存器可读可写可读可执行可读可写可读可写可读可写上图中有这个标记的表示他在不同操作系统的该值不一致在中不使用所以用短横杠填写上图的原因是段寄存器此时实际上是寄存器寄存器不可写把换成就不会报错因为段是可写的上面相当于由于的为所以访问报错写一个段寄存器的时候我们只给了位那么剩下的位来自于哪里呢段描述符与段选择子保护模式下三个重要的系统表和全局描述符表局部描述符表在中没有使用中断描述符表当我们执行类似指令时会查表根据的值来决定查找还是查表的什么位置查出多少数据是一个寄存器位存储的是表的开始位置位和长度位寄存器中存放的是在内存中的基地址和其表长界限前位是保存里面的限长后到位保存的是段基址和有区别存的是段选择子汇编指令和分别用于加载和保存寄存器的内容查看寄存器这样表在哪里表示查看寄存器查看的也是寄存器查看表有多长图中命令罗列出来的就是表剩下的位来自于表表里存储的元素我们叫段描述符段描述符每个段描述符是个字节即位黄色荧光笔标记出来的是图解中的低位是按照字节来分组后接的表示显示组段选择子段选择子是一个位的段描述符该描述符指向了定义该段的段描述符写段寄存器的时候写的就是段选择子请求特权级别查表查表没有使用处理器将索引值乘以再加上表的基址就是要加载的段描述符加载段描述符到段寄存器除了指令我们还可以使用指令修改寄存器表示表示即加载段寄存器不能通过上述的指令进行修改为代码段的改变会导致实际指向的代码的改变要改变必须要保证与一起改后面会讲的使用案例表示个字节高个字节段选择子给低四个字节给提供的数值上才能成功段描述符的属性段寄存器的值是通过段描述符填充的但段描述符只有位如何从位变成位位是位撇去段选择子的位多了位参考下方位的讲解位可见部分段选择子位位位对应的是高字节从第位开始到第位第位开始到位结束共位是高字节的位高四字节的第位低四字节的位共同组成的位是高字节的位低字节的确定了位剩下的位依赖位下有详情位和位位表示段描述符有效表示段描述符无效当我们将一个段描述符加载到段寄存器的时候做的第一件事就是检查位如果为后续的检查就不做了若为后续的检查才做位表示的单位是字节在前面填充补齐位此时的值就是的字节大小表示的单位是的地址为十进制如果是的话在后面填充此时为对应的段描述符比较特殊查分后的值与段寄存器中的值不符合讲到操作系统线程的时候会有解释位和域位当我们将一个段描述符加载到段寄存器的时候做的第一件事就是检查位第二件事就是判断该段描述符是数据或代码段描述符还是系统段描述符代码段或者数据段描述符系统段描述符位为并且位为只有两种情况即要么是全要么全所以可知中下图标黄部如果是二进制或者二进制表示此段是代码段或者数据段描述符域域的含义根据位来变化当时域中的第一位也就是段描述符高字节的第位区分该段到底是代码段还是数据段如果有是则表示代码段如果是表示数据段与都属于数据段这意味着下图标黄的进制位如果大于等于则表示是代码段否则是数据段访问位表示该位最后一次被操作系统清零后该段是否被访问过每当处理器将该段选择符置入某个段寄存器时就将该位置表示一致位一致代码段非一致代码段拓展方向向上拓展向下拓展图中橙色部分表示段所在位置向上拓展是从到的区间而向下拓展是该区间取反的区间当时位位对三种段有影响对段的影响采用位寻址方式采用位寻址方式前缀改变寻址方式方便观察位寻址方式是什么样的对段的影响数据段的段描述符加载到段里他就是段了但本质还是数据段隐式堆栈访问指令如使用位堆栈指针寄存器隐式堆栈访问指令如使用位堆栈指针寄存器向下拓展的数据段向下拓展段上限为向下拓展段上限为红色表示该段的区间表示上图右侧两块红色相加为属性属性占个比特该属性的意义可由操作系统应用程序自行定义保证该位不会被占用作为其他用途段权限检查段选择子加载到段寄存器中要进行段权限检查分级只使用了三环和零环与的理解不能调用的函数但是可以访问的内存空间因此可以把函数拷贝到的内存空间再通过函数指针的方式调用还要切换涉及后续课程知识如何查看程序处于几环当前特权级段选择子后位段选择子后两位为但和的段选择子的后两位比较特殊表示当前环数规定了和的后两位一定是一样的描述符特权级别存储在段描述符中规定了访问该段所需要的特权级别是什么通俗的理解如果你想访问我那么你应该具备什么特权举例说明如果指向的段但当前程序的这行指令是不会成功的因为权限检查的时候通不过请求的特权级别是针对段选择子而言的每个段的选择子都有自己的数据段的权限检查参考如下代码比如当前程序处于环也就是说指向的段描述符的数据段的权限检查流程并且数值上的比较由于上面代码中所以权限检查无法通过注意代码段和系统段描述符中的检查方式并不一样具体参考后面课程上面仅为数据段的权限流程检查词汇总结当前的权限级别如果你想访问我你应该具备什么样的权限用什么权限去访问一个段代码跨段本质就是修改段寄存器段寄存器段寄存器读写除外其他的段寄存器都可以通过指令进行修改为什么不可以直接修改呢代码段的改变意味着的改变改变的同时必须修改所以我们无法使用上面的指令来进行修改代码间的跳转段间跳转非调用门之类的段间跳转有种情况即要跳转的段是一致代码还是非一致代码段同时修改与的指令注意只修改的指令以前这两个指令前者是位后者是位的但现在根据位已经没有区别了默认都是位执行流程如何执行该指令长跳转段间跳转段选择子拆分对应二进制形式查表得到段描述符所以查表所以找到对应的段描述符四种情况的段描述符才可以跳转代码段调用门任务段任务门权限检查如果是非一致代码段要求并且数值上如果是一致代码段要求数值上一致代码段又名共享段的理解这个代码段是提供一些功能让应用层直接可以访问而不破坏内核的代码就用一致代码段来修饰反之不想应用层访问就用非一致代码段修饰加载段描述符通过上面的权限检查后会将段选择子对应的段描述符加载到段寄存器中代码执行将的值写入然后执行处的代码段间跳转结束总结对于一致代码段也就是共享的段特权级高的程序不允许访问特权级低的数据核心态不允许访问用户态的数据特权级低的程序可以访问到特权级高的数据但特权级不会改变用户态还是用户态对于普通代码段也就是非一致代码段只允许同级访问绝对禁止不同级别的访问核心态不能访问用户态用户态不能访问核心态直接对代码段进行或者的操作无论目标是一致代码段还是非一致代码段都不会发生改变如果要提升的权限只能通过调用门最终总结为了对数据进行保护普通代码段是禁止不同级别进行访问的用户态的代码不能访问内核的数据同样内核态的代码也不能访问用户态的数据如果想提供一些通用的功能而且这些功能并不会破坏内核数据那么可以选择一致代码段这些低级别的程序可以在不提升权限等级的情况下既可以访问如果想访问普通代码段只有通过调用门等提升权限才能访问实验黄标表示如何查找表表示往某地址写入某内存虚拟机中系统中的进行测试表示段选择子为二进制索引的段寄存器正是上上图黄标位置的段描述符单步执行看是否可以跳转到地址成功跳转将段描述符的修改为环此时预测权限验证应该会失败修改后再次尝试跳转单步执行按进入了即进入异常模块了和预期的结果一致权限验证失败将对应段描述符修改为一致代码段中执行同一条指令单步执行成功跳转一句话总结实验低权限代码段用零环的权限访问低权限代码段成功因为是一致代码段如果是非一致代码段要求并且如果是一致代码段要求长调用与短调用我们通过可以实现段间的跳转如果要实现跨段的调用就必须要学习也就是长调用比要复杂并不影响堆栈但指令会影响堆栈所以长调用比长跳转要复杂短调用指令格式立即数寄存器内存短是了一个返回地址修改为调用位置发生改变的寄存器和长调用跨段不提权指令格式是废弃的注意长调用的调用地址并不是由决定的而是通过段选择子找到段描述符该段描述符必须是一个调用门算出来的发生改变的寄存器通过长调用执行完代码后是通过长返回返回返回的时候会将上图红色的调用者重新赋值给段寄存器长调用跨段并提权指令格式是废弃的表示当前执行的权限为环堆栈发生了切换右边的堆栈已经不是左边的堆栈了而是一个零环的堆栈了发生改变的寄存器总结跨段调用时一旦有权限切换就会切换堆栈的权限一旦改变的权限也要随着改变与的等级必须一样只能跳转到同级非一致代码段但可以通过调用门提权提升的权限与从哪里来参见段调用门调用门执行六项功能它指定要访问的代码段它为指定代码段中的过程定义了一个入口点它指定尝试访问过程的调用者所需的权限级别如果发生堆栈切换则指定要在堆栈之间复制的可选参数的数量它定义了要推送到目标堆栈上的值的大小位门强制位推送位门强制位推送它指定调用门描述符是否有效调用门无参调用门最大的好处就是提权但提权的方式不仅仅是调用门门描述符的结构门描述符是系统段描述符的一类所以字段必须是域为表示调用门调用门中存储了另一个代码段段的选择子指的就是上图段选择符字段重点调用门真正要调用的地址段选择符中存的段选择子指向的那个段描述符中的上图中的两段段中偏移值拼接而成的值不同门的调用门指令流程为了访问调用门在或指令中提供了一个指向该门的远指针作为目标操作数来自该指针的段选择器标识了调用门还未亲自实验过指针的偏移量下面的是必需的但不被处理器使用或检查偏移量可以设置为任何值指令格式是废弃的执行步骤根据的值查表找到对应的段描述符这个描述符是一个调用门在调用门描述符中存储另一个代码段段的选择子选择子指向的段段偏移地址就是真正要执行的地址重点调用门权限相关调用门的执行流程涉及到的权限当前特权级别调用门的选择器的请求者的特权级别调用门描述符的描述符特权级别目标代码段的段描述符的权限检查规则在和指令之间有所不同如下表所示指令特权检查规则调用门调用门目标一致代码段目标非一致代码段调用门调用门目标一致代码段目标非一致代码段上图说明只有指令可以使用调用门将程序控制转移到更高特权数字特权级别更低的非一致性代码段如果调用更高特权数字特权级别更低的非一致目标代码段则将降低到目标代码段的并发生堆栈切换如果调用或跳转到更高特权的一致目标代码段则不会更改也不会发生堆栈切换实验内并没有使用调用门所以自己构造一个调用门无参提权部分表示还不确定的部分高位为表示该段描述符有效为表示三环否则三环测试连敲门的权限都没有了高位进制低位段选择符指向的段描述符如果是比当前小的的则表示要提权否则表示无需提权低位进制查看段描述符尝试用调用门调用上图黄标的段描述符的零环权限来提权所以构造的调用门低位进制为为指向的正是上图黄标段描述符虚拟机上的系统上执行如下代码断点由于是通过调用门提权为零环该代码段和内核同权限所以会断到中而不是断在下断点随便输入段选择子对应的段描述符为空所以用此位置装手动添加的调用门段描述符在上述代码的下断点处下断点然后执行代码断到此处断点进入反汇编找到裸函数的函数地址上图黄标可知跳转目标地址为所以构造的调用门段描述符为下断点修改中段选择子对应的位置内容为执行代码前的寄存器情况执行代码后成功跳转了裸函数代码中的所以断了下来在地址处因为断了下来发现寄存器窗口为空查明是有解决方案参考命令此时断下查看的寄存器显示与执行前的寄存器比较对应颜色画笔标记为修改了的部分其中从修改为直接从低空间跳转到高内核空间变为是因为我们在调用门描述符中设置为跳转到段选择子对应的段描述符有部分其他寄存器也被改了原因是系统底层代码写死了的部分修改另外还有的干扰此时查看处堆栈到此已验证完毕将代码修改为此代码段的代码有内核权限可以直接访问高内存空间读取高内存指令的含义为读取寄存器读取出个字节的数据两个字节的和个字节的起始地址该指令在三环也能使用注意长返回下断点随便输入段选择子对应的段描述符为空所以用此位置装手动添加的调用门段描述符表的地址表有多长由于代码修改了所以函数的首地址也修改了因此要修改调用门段描述符的段中偏移值构造的调用门段描述符为修改执行代码不能用单步执行的方式执行而是直接不断点按结果如图实验成功提权成功调用门有参调用门有权限切换时堆栈变化堆栈的参数需要手动如果没有手动则堆栈不存在参数堆栈的参数取决于调用门描述符中的参数个数没有手动的话堆栈的参数均为实验用来存传入的参数参数参数读参数赋值给注意堆栈平衡写错直接蓝屏三个参数所以为参数平栈为断点断点处断点查看断点处地址构造调用门段描述符为表示个参数修改第个段描述符修改后执行函数头加个来查看一下堆栈情况地址未变段描述符不需要改直接执行执行到断下此时中查看堆栈情况断下时候的堆栈结构和后的堆栈结构参数此时的相对位置结构总结当通过门权限不变的时候只会两个值和返回地址新的的值由调用门决定当通过门权限改变的时候会四个值返回地址新的的值由调用门决定新的和由提供通过门调用时要执行哪行代码由调用门决定但使用返回时由堆栈中压入的值决定这就是说进门时只能按照指定路线走出门时可以翻墙只要改变堆栈里面的值就可以想去哪去哪可不可以再建个门出去呢当然可以了前门进后门出中断门没有使用调用门但是使用了中断门系统使用了中断门的两种情况系统调用老使用中断门新已经不使用中断门了而是使用快速调用调试软件断点就是用来执行中断门的键盘鼠标显示器等外部设备都是可屏蔽中断电源等是不可屏蔽中断无法操作现在的中断大多都是用的实现编程强一些执行调用门的指令但当执行如下指令表示号中断表示号中断查询的却是另一张表这张表叫中断指令其中是索引的基址就是具体的中断门描述符保护模式下的中断和异常表解释终止就是蓝屏中断门的堆栈和返回在没有权限切换时会向堆栈个值分别是返回地址在有权限切换时会向堆栈个值分别是返回地址在中断门中不能通过返回其实也可以而应该通过指令返回是位而是位裸函数的话必须写部分会自动根据位在中变换即中断描述符表结构同一样也是由一系列描述符组成的每个描述符占个字节但要注意的是表中的第一个元素不是表中存的中断描述符按照中断编号从号开始排序下去在中查看表的基址和长度表的构成表可以包含种门描述符任务门描述符中断门描述符陷阱门描述符中断门描述符高字节的位固定为进制中断门描述符表示中断门提权实验参考流程图提权与否取决于中断门描述符的段选择子指向的段描述符的实验中断门要用这个返回如果不是裸函数的话写也可以因为会根据位调成是后续知道的空位后回来补上的表中的第个中断描述符编号从开始断点断点处断下反汇编查看的函数地址在中找空的位置构造中断门描述符空位如下图构造的中断门描述符中断门的段选择子指向的是为的内核代码段之前的堆栈情况断到上查看寄存器变化有部分其他寄存器也被改了原因是系统底层代码写死了的部分修改另外还有的干扰查看堆栈调用中断门的堆栈没有变化调用门与中断门的区别调用门通过指令执行但中断门通过指令调用门查询表中断门查询表中的是段选择子由部分组成但指令中的只是索引中断门不检查只检查调用门可以有参数但中断门没有参数重点理解各种返回加深理解可以理解为各种返回及其同义词从堆栈中弹出或返回地址并将控制权转移到新地址可选的如果提供了数字二的操作数它们会在弹出返回地址后将堆栈指针再增加位即两个字节字节执行远返回在弹出返回地址后它会弹出然后通过可选参数如果存在递增堆栈指针如果返回到另一个特权级别指令还会在恢复程序执行之前从堆栈中弹出或和最后将参数计数以从指令获得的字节数添加到当前寄存器值将和弹出为每个个字节总共从堆栈中取出个字节如果返回到另一个特权级别指令还会在恢复程序执行之前从堆栈中弹出和将弹出为个字节返回地址再弹出个字节其中前两个被丢弃后两个进入并将也弹出为个字节从堆栈中取出个字节如果返回到另一个特权级别指令还会在恢复程序执行之前从堆栈中弹出和是或的简写具体取决于当时的默认设置实验在调用门中实现使用返回在中断门中实现用返回中断门用返回中断门用返回反其道行之编号对应位置的中断门段描述符为因为在返回后还会再根据调用门用返回调用门用返回反其道行之指向的调用门描述符为陷阱门陷阱门段描述符陷阱门与中断门几乎一样陷阱门与中断门唯一的区别中断门执行时会将位清零但陷阱门不会位下标为的位置的含义标志用于控制处理器对可屏蔽中断请求的响应置以响应可屏蔽中断反之则禁止可屏蔽中断不再接受可屏蔽中断接受可屏蔽中断不可屏蔽中断不受位影响比如说断电就是电源通过电源管理器向发送一个请求这就是一个不可屏蔽中断有电容即使是断电了也能跑一会儿执行一些清理工作通过中断门与陷阱门打印寄存器的值执行前执行中陷阱门中断门任务段难点非重点在调用门中断门与陷阱门中一旦出现权限切换那么就会有堆栈的切换而且由于的发生改变也导致了也必须要切换和的权限级别永远都是一致的切换时会有新的和是由中断门或者调用门指定这个值从哪里来的呢答案任务状态段和寄存器一块大于等于字节的内存结构强调不在中就是内存中权限位图没什么用和硬件是相关的页目录基地址寄存器指向前一个任务段的链接如果不为空的话存的是前一个段的段选择子段选择子会加载到寄存器中中的修改是没用的即使修改了也会变回去因为是系统填写的一个对应一个表描述的是表的地址和大小和从本质上说是相同的只是嵌套在之中记录局部描述符表的起始位置与不同的内容是一个段选择子由于本身同样是一段内存也是一个段所以它也有个描述符描述它这个描述符就存储在中对应这个描述符也会有一个选择子装载的就是这样一个选择子可以在程序中随时改变通过使用指令如上图如果装载的是则指向的是表描述符位以后实际上没有使用因为用不着这么多段了更多关于的内容可以参考此处重点寄存器后续会讲的地址就是段描述符描述的基地址因此我们通过查看其为对于查看段有一个单独的指令的作用层面的任务就是系统层面上的线程设计思想的初衷就是实现任务切换操作系统中也就是线程切换中没有线程的概念操作系统的设计思想的任务切换在操作系统中其实就是同时换掉一堆寄存器与线程切换无关和系统实际上只使用了和本质不要把与线程切换联系到一起的意义仅在于可以同时换掉一堆寄存器是如何找到的任务寄存器位寄存器其内保存的是任务状态段的位段选择子每项任务都配有一个任务状态段用来描述该任务的运行状态就用位的选择子来检索任务状态段总是将当前任务的的选择符放在中而的描述符放在描述符高速缓冲寄存器中就是段描述符除了位的端选择子部分的其他位针对这句话一下说明在保护方式下选择器寄存器的是特权标志为描述符表类型标志高位是选择码指出本段的描述符在由指出的描述符表中的逻辑排序当一个段第一次被访问时首先根据指令给出选择器的位及高位到内存中相应的描述符表内取出相应的描述符位送入对应的描述符高速缓冲寄存器位再从描述符中取出段基址进行逻辑到线性地址的变换以后再访问该段时直接从描述符寄存器位中取地址信息免去从内存中选取描述符的过程实现加速在系统中只有一个所以中存放的是该表入口地址而任务不只一个所以存放的是当前任务的选择符段描述符段描述符是系统段描述符的一种在中的以字节为单位的所以上图高字节的位的代表含义是以字节为单位为和都表示段描述符表示当前的段描述符没有加载到寄存器中表示已经加载了忙碌状态加载前是加载后构造段描述符零环已使用构造段描述符零环未使用构造段描述符三环已使用构造段描述符三环未使用下面实验使用这个才能成功之前的段描述符位都是填段描述符填的是表示按字节为单位段描述符寄存器的读写将段描述符加载到寄存器指令用指令去装载的话仅仅是改变寄存器的值位并没有真正改变指令只能在系统层使用是特权指令权限零环加载后段描述符会状态位发生改变加载完后会从变成读寄存器指令如果用去读的话只读了的位也就是选择子修改寄存器在我们可以通过指令去修改寄存器在我们可以通过或者指令来修改不但改寄存器还会通过改所有的寄存器用去访问一个代码段的时候改变的是和如果是代码段执行后用去访问一个任务段的时候如果是段描述符先修改寄存器再用指向的中的值修改当前的各种寄存器涉及的寄存器或者一个任务段描述符的不同点重点第一个不同点在于调用了段之后会被填入前一个段的段选择子调用了段之后不会被改变第二个不同点在于位的第位调用了段之后位会置一调用了段之后位清位的第位保护模式下的理解时为中断返回会在堆栈中找返回值返回时不是中断返回会找中的返回位有部分位不允许被应用程序所修改注意也会把位清零无法实验证实所以的方式调用任务段跳转到代码后用会导致蓝屏而却可以中断详解对理解有一定帮助段描述符实验不管跳几环中一定要改这三个段寄存器使用和去访问一个任务段并能正确返回实验返回通过工具指令获取用栈空间构造段描述符中的填该数组的首地址也可填照常运行此处要填入跳转位置的地址是因为是往小地址升栈的段选择子决定是否升了权限由于选择子指向的段描述符是环权限所以此处是提权了的如果想使用的话可以自己构造使用在中断下输入指令根据程序名查看放开内核断点控制台输入上图黄标得到的地址长调用之前调试器断下再次断下构造段描述符修改好后确保字符数组首地址不会变的时候不下断点重新运行否则会出现如下图的单步运行异常填入新的单步运行异常是可以用单步调试的状态指令单步走指令查看寄存器输入时的寄存器情况重新运行结果下图左边寄存器为返回后的值再次运行程序在函数头加观察与我们的修改完全一致只是如果在函数头加会导致蓝屏无法正常返回后面的实验发现过去的方式不能在函数头加蓝屏是因为会将位清导致在堆栈中找返回值实则没有所以蓝屏可以在实验中将函数中的用和包裹起来防止修改寄存器避免蓝屏已实验证实可以过去的方式可以加不蓝屏实验返回指令为保存当前的段选择子到中保存跳回来的的目标段选择子和目标地址构造段描述符获取后输入成功执行实验中头添加观察实验和上个实验唯一的区别添加指令为保存当前的段选择子到中保存跳回来的的目标段选择子和目标地址正常执行任务门这里主要介绍如何通过任务门去访问任务段有了任务段为什么还要有任务门答任务门为异常提供了可切换任务的机制是一种被动的机制而单纯的任务段必须被主动调用任务门描述符可以放在和中任务门描述符指向一个段描述符任务门描述符的构造任务门的执行过程查表找到任务门描述符通过中断门描述符查表找到任务段描述符使用段中的值修改寄存器返回任务门描述符不一定在中多个任务门可以指向同一个段描述符如下图课后练习实现任务门进环实验流程图通过工具指令获取用栈空间构造段描述符中的填该数组的首地址必须修改不然会蓝屏不知为何任务段处做的零环实验可以不填此处要填入跳转位置的地址是因为是往小地址升栈的段选择子决定是否升了权限由于选择子指向的段描述符是环权限所以此处是提权了的如果想使用的话可以自己构造使用放入任务门构造任务门放进中第个位置即对应的位置在的位置构造段描述符将原本选择的选择的和选择的三个段描述符复制后到表的空的空间中仅修改为因为目的是要进环在中修改为在中修改为在中修改为修改后的表成功执行逆向实验下图第三题指令这个命令主要用于反汇编某个地址其后面可以跟函数名和地址命令可以看到跳转等的下文更有用实验流程图查看表吗下图黄标为的中断门描述符拆解为为发现指向的是任务门描述符可知段选择子为拆解为位为因此在表中找的位置为段描述符如下图黄标由段描述符可知内存的所在位置为查看内存上图黄标为地址反汇编地址则找到了将执行的目标代码黄标就是蓝屏表示禁止中断发生允许中断发生中找该函数位清零即禁止中断发生改变任务段描述符状态为空闲试图修改段描述符中中的忙位为清不清楚意义何在是表首地址下面几步取内存基址放入中此后是的任务段描述符中的地址似乎无用的任务段描述符中的地址放入当前存地址的地址中循环至上面代码分析不一定正确我取了内核态和用户态的值在内核态在用户态远程执行思路图略未实验相关段描述符结构结构与其他结构的关系自己构建表和其中的数据段描述符实验的作用是装载局部描述符表寄存器的作用是读取局部描述符表寄存器中的内容读取出来并存储的作用是装载全局描述符表寄存器的作用是读取全局描述符表寄存器中的内容读取出来并存储为什么叫局部描述符是因为和程序挂钩也就是用本程序的才能获取到地址所以应该放到三环想看的话只能通过物理地址去看别的程序访问效果如下实验代码如下去掉不影响实验成功去掉不影响实验成功读的首地址所在地址读的首地址开始构造段描述符低字节为的首地址的地址存自己构建的的首地址存到中只取就够了左移位补零为构造好的放进的首地址的地址开始构造段描述符高字节调整为的首地址的地址将存放着自己构建的的地址右移位即只保留高位的位低位放进的首地址的地址放到的首地址的地址的拆解高位放进的首地址的地址段描述符高字节为加载段选择子为的段描述符去掉不影响实验成功去掉不影响实验成功调用门提权返回构造表中的数据段描述符是三环为环去掉不影响实验成功调用门提权用于提权后构造表与其内的数据段描述符去掉不影响实验成功加载表内的数据段描述符尝试读尝试写读的值写入实验图解运行程序为地址可知构造的调用门描述符为运行下图成功将改为了实验成功此时查看表的位置蓝色区域已被修改为段描述符可进一步实验将中的数据段描述符改成改为零环则数据读写失败略已证明保护模式页实模式下访问的内存地址都是物理内存地址保护模式下访问的内存地址都是线性地址物理内存的大小等同于内存条但物理内存不是内存条之间还有映射关系线性地址有效地址物理地址的概念理解如下指令其中是有效地址是线性地址通常有效地址和线性地址是一个值因为为线性地址转换成物理地址的方式在下有两种模式一种是另一种是的形式如果是位的话还有第三种更加复杂的方式类似两个进程都存在的线性地址为什么找到的内容不一样因为每个进程都有各自的一堆表存储着该进程线性地址到物理内存的映射关系分页分页的内核模块是修改分页的方式中的表示分页每个进程都有一个准确来说是中的值本身是一个寄存器一个核只有一套寄存器指向一个物理页所有寄存器中只有存的是物理地址其他寄存器存的都是线性地址一共字节如图将线性地址的位拆分为位位位其中第一个位就代表了第一级内在什么位置查看物理地址指令是找第一级的物理地址低位十六进制清零线性地址第一个十位将里面取得的值的低位进制置为因为低位进制代表的是属性找第二级物理地址上一步取到的值低位十六进制清零线性地址第二个十位再次将取得的值的低位进制置为找到对应物理地址要找的物理地址上一步取到的值低位十六进制清零线性地址第三个位取物理地址里存的值要找的物理地址与页目录表占中每个页目录表项占个字节每个页目录项又指向一个的页表每个页表项占个字节因此每个页表有个页表项无论是还是里面记录的前位的次方后面添加位是物理地址后面位是属性的特点可以没有物理页位为即无效也就是没有物理页且只能对应一个物理页多个可以指向同一个物理页一些细节一个物理页是个字节刚好是的次方个字节所以需要个二进制位索引大小的物理页说明了中最后一个为什么是页表是个页表项即的次方个成员所以需要个二进制位索引说明了的中间的的由来同理页目录项分页决定了当前物理内存的最大值就是同一个进程的两个线性地址只要前位进制是一样的那么他们就一定在一个物理页上因为与都一样而后三位十六进制只决定他们在物理页上的偏移物理页的属性属性属性位功能描述有效位有效无效决定是否存在物理页只读常量区可读可写权限位特权用户环和环普通用户环只对有意义的意思当时表示指向大物理页即不需要拆分了的低位直接是物理页的页内偏移页属性表也是用来控制页属性的但是对有要求是否被访问读或者写过访问过置即使只访问一个字节也会导致置脏位是否被写过没有被写过被写过全局页全局相对只有位等于的时候大页他才有效为零的时候位永远为零全局页不会随进程切换清空有效位没有使用操作系统使用了用来判断缺页寻址的时候发现位为就触发号中断此时操作系统得以发挥在位的有效位判断到底是没分物理页还是缺页将此页挪到文件里了然后再给补上页具体的细节后面会有更详细的解读的部分学完控制寄存器与才能理解此处先略过后面有讲可见分页没有可执行属性但在有个位对这种情况做了补充页有两种小页单位大页单位只有系统里面一部分经常使用的内存才会使用大页两步判断这个线性地址可写判断段描述符是否可写通过的属性判断该物理地址是否可写的线性地址如果不可写直接意味着的线性地址都不可写因为前位进制一致即都在同一个物理页上以上是内核才能访问的原因是位的设置问题如果将内核的某个页设置为就可以在访问了是系统环可以访问系统页和用户页环是特权环环虽然不是特权级环但是是系统环环是用户环可以访问用户页页目录表基址线性地址如果系统要保证某个线性地址是有效的那么必须为其填充正确的与如果我们想填充与那么必须能够访问与那么是谁帮我们填好了与呢操作系统如果进程创建进程那么是进程帮进程填好和在程序中我们是不能直接访问物理页的想要访问物理页必须通过线性地址中存储的是物理地址不能在程序中直接读取的如果想读取也要把的值挂到和中才能访问那么怎么通过线性地址访问和呢拆解线性内存低各个进程几乎不同高各个进程几乎相同的前和后都是没有映射的发现线性地址存储的值就是的基址通过这个线性地址是一定存在的如果它不存在系统也没办法访问这个表找到的物理页就是页目录表这个物理页即是页目录表本身也是页表页目录表是一张特殊的页表每一项指向的不是普通的物理页而是指向其他的页表如果我们要访问低个公式如下中的值该物理地址中存的就是中的值是中的一个如图红色区域就是页表基址线性地址对应的是第一个的基地址对应的是第二个的基地址每个基地址之间隔着物理地址不连续但线性地址是连续的页表被映射到了从到的地址空间在这个表中有一张特殊的表页目录表页表中的第项页目录表被映射到了开始处的地址空间实际上是通过算出来的对应的线性地址把所有页表映射到到这的地址空间中对于这的地址空间也有一个页目录表与之对应不妨设为既然把全部页表都映射到上述的地址空间那么页目录表自然也在其中第一个页表对应的线性地址为即用上述公式应该能找到第一张页表对应的所在线性地址利用公式将带入其中可以求得第一个地址的页表映射了到这的地址空间的物理内存而这地址空间恰恰是页目录表的物理地址所以说对应的地址空间就是页目录拆解线性地址命令要拆解的线性地址小实验掌握一个进程所有的物理内存读写权限公式总结物理页内偏移页目录索引页表索引访问页目录表项地址的公式访问页表项地址的公式的次方的次方拼接部分实验将的物理页挂到线性地址那附近通过的物理页偏移部分的地址调用函数手动修改框架手动修改框架为则跳转去掉地址的最后位物理页偏移取地址前位地址前位乘的对应地址对应的将对应放到线性地址对应的位置中如果线性地址对应的是的话跳转到这里来取第一个位第一个位乘找到对应的地址找到对应将对应放到线性地址对应的位置中就换了所以后面的也就不用换了反正整个表都换了获取地址获取本身的物理页上的偏移修正调用函数调用门手动修正框架手动修正框架调用地址内核逆向分析函数一个用于判断虚拟内存地址是否有效的逆向该函数可以知道操作系统是怎么找和的用可以将内核文件放入分析用尝试逆向要检查的线性地址存入要检查的线性地址右移位相当于右移位再左移位即乘下一句修正后两位要检查的线性地址前位的后两位清零等同于此后为的值检测末尾位是否为位不为就跳判断后位的首位位是否是就跳表示指向大物理页不用拆了要检查的线性地址右移位相当于左移位后右移两位因为要乘下一句修正后两位右移后的线性地址的后两位清零等同于此后是的值判断位位不为就跳判断位位是就跳即为则一定是有效的置因为是默认返回值返回线性地址有效返回或的位检查未通过置因为是默认返回值返回线性地址无效位的处理的线性地址比如说变成比如说变成自己实验中发现地址中为第位和第位必须为内存地址才有效检查未通过等同于详解因为装不下所以会溢出等同于没有分页分页的内核模块是在之前的课程中我们讲解了分页方式在这种分页方式下物理地址最多可达但随着硬件发展的物理地址范围已经无法满足要求在年就已经意识到这个问题了所以设计了新的分页方式也就是我们本节课要讲的分页又称为物理地址拓展分页与位比较相似为什么是先确定了物理页的大小为所以后面的位的功能就确定了当初的物理内存比较小所以个字节的就够了加上页的尺寸是所以一个页能存储个也就是的次方第二个位确定了剩下的位为为什么是物理页的大小是确定的不能随便改所以后面的位确定了如果想增大物理内存的访问范围就需要增大增大多少了呢考虑对齐的因素增加到个字节因为一个物理页就由于由字节变成字节所以项数由项缩小为项而项需要个二进制位进行索引所以是同理也是位的次方最后还差位所以就再做一级叫因为只有两位所以只有个可以最大允许的物理内存为的次方是位的物理地址宽度即对应的线性地址代入第一个的地址可知地址为第个指向了一个表此表的前四项指向了的每一个元素是第一个表的首地址是第二个表的首地址是第三个表的首地址是第四个表的首地址在同一个中相邻两个首地址间隔为通过线性地址读取第四个的第一个内容成功访问页目录表项地址的公式访问页表项地址的公式页目录指针表项设计给操作系统用的操作系统设计者爱用不用位存储的是页目录表的物理基址低位补零共位即页目录表基址存的项也是占用字节结构位功能描述有效位有效无效决定是否存在物理页只读常量区可读可写权限位特权用户环和环普通用户环只对有意义的意思当时表示指向大物理页页属性表也是用来控制页属性的但是对有要求是否被访问读或者写过访问过置即使只访问一个字节也会导致置脏位是否被写过没有被写过被写过全局页全局相对只有位等于的时候大页他才有效为零的时候位永远为零结构下的两种页小页大页和分页的不一样的次方结构小实验地址中存了一个拆分线性地址中确实为标志位在中称为即结构如下段的属性有可读可写和可执行页的属性只有可读可写当执行返回的时候如果我修改堆栈里面的数据指向一个我提前准备好的数据把数据当做代码来执行漏洞都是依赖这点所以就做了硬件保护做了一个不可执行位时那么你的软件溢出了也没关系即使你的蹦到了危险的数据区也是不可以执行的在分页模式下或的最高位为位为表示该内存只可在代码段执行数据段不可执行开头的就是被保护的因为首位二进制为进环了直接改了就是了内核逆向分析函数取到要判断是否有效的线性地址代表后面要用也为要判断是否有效的线性地址右移位与此后为部分此后为线性地址对应的地址为低位为高位高位存进局部变量中为低位要用为的位清零判断的位是否为的位为零则跳的位不是零取的位判断是否大页的位存入局部变量空间清零位为即小页就跳转大页则不用判断百分百跳转到线性地址有效后返回位为为小页则跳转线性地址右移位相当于右移位再左移位后三位置零此后为部分此后为高位此后为低位地址为低位高位部分存入局部变量临时保存要用为低位清零取的位判断的位是否为还原的位是零就跳的位不是零为的位是否为的位存入局部变量清零的位为就跳到函数有效返回部分无用绝对不跳的位为的处理低位地址可能是取低位地址的部分为低位地址清零判断低位地址的第和第位是否均为若有一个不是跳转无用绝对不跳位为零的处理返回线性地址无效返回线性地址有效退出函数旁路转换缓冲每次访问一个物理页查表的过程特别繁琐举个例子分页模式下读一个四字节实际上会读个字节如果跨页读可能更多内部做了一个表来记录这些东西这个表格是内部的不在内存中和寄存器一样快这个表格即旁路转换缓冲或称为页表缓冲说明属性属性是三个属性起来的如果是就是不同的这个表的大小不一样只要变了立马刷新一核一套统计信息记录每个地址的读写情况确定哪个地址访问更频繁存的是线性地址的前位对应物理地址操作系统的高映射基本不变如果改了刷新重建高以上内存很浪费所以和中有个标志位如果位为刷新时将不会刷新的位为的页当满了根据统计信息将不常用的地址废弃最近最常用的保留高两有大量位为的低也有为种类在体系的里的实际应用最早是从的开始的在体系的里边每个核都设有如下组缓存一般页表字节页面的指令页表缓存缓存一般页表字节页面的数据页表缓存缓存大尺寸页表字节页面的指令页表缓存缓存大尺寸页表字节页面的数据页表缓存能区分是读一个内存地址还是执行一个内存地址如果是指令访问的内存放入数据页表缓存读一个内存地址如果是等指令访问的内存放入指令页表缓存执行一个内存地址一种隐藏内存的技术可以用于过代码校验在指令页表缓存中给目标地址修改为新的物理页当执行的时候是到物理页执行可是读的时候读的还是原来的位置即未被修改这种解决方案适合处理零环也有点不稳定而不适合处理三环因为三环内存老是刷新非常不稳定三环有更好的方案挂钩子防止对方检测到无痕相关实验体验的存在给零地址挂物理页可能会蓝屏有可能被用着中给零地址赋值将物理页改了随便改成别的物理页再次读线性地址调用门描述符进程切换后结果被刷新给零地址挂物理页可能会蓝屏给零地址赋值进程切换只要有加载的操作那么就会清除除了的内存将物理页改了随便改成别的物理页再次读线性地址结果中的是因为新物理页中的值就是全局页的意义上面的代码修改为全局页把上述代码中的从修改为因此可知全局页不会随进程切换清空指令的意义手动清空线性地址对应在的一条缓存给零地址挂物理页可能会蓝屏给零地址赋值进程切换将物理页改了随便改成别的物理页再次读线性地址手动清空缓存成功读出新物理页的值中断与异常中断什么是中断中断的本质目的就是改变执行的路线中断通常是由外部的输入输出设备硬件所触发的供外部设备通知有事情需要处理因此又叫中断请求中断请求的目的是希望暂时停止执行当前正在执行的程序转而去执行中断请求所对应的中断处理例程中断处理程序在哪由表决定有两条中断请求线非屏蔽中断线称为可屏蔽中断线称为非可屏蔽中断如何处理当非可屏蔽中断产生时在执行完当前指令后会从里面进入中断处理程序非可屏蔽中断不受寄存器中位的影响一旦发生必须处理非可屏蔽中断处理程序位于表中的号位置可屏蔽中断在硬件级可屏蔽中断是由一块专门的芯片来管理的通常称为中断控制器它负责分配中断资源和管理各个中断源发出的中断请求为了便于标识各个中断请求中断管理器通常用后面加上数字来表示不同的中断比如在中时钟中断即下图的系统计时器的编号为也就是查看大多数操作系统时钟在之间系统为时钟中断只是操作系统进行线程切换的一个机会哪怕是一个无限循环的程序一个单核系统依然有机会线程切换可屏蔽中断如何处理如果自己的程序执行时不希望去处理这些中断用指令清空寄存器中的位用指令设置寄存器中的位硬件中断与表中的对应关系并非固定不变的参见高级可编程中断控制器异常异常通常是在执行指令时检测到的某些错误比如除访问无效页面等中断与异常的区别中断来自于外部设备是中断源比如键盘发起的是被动的异常来自于本身是主动产生的在执行的时候发现错误了虽然被称为软件中断但其本质是异常的位对无效异常处理无论是由硬件设备触发的中断请求还是由产生的异常处理程序都在表常见的异常处理程序如下举例缺页异常缺页异常的产生比如当的时当的属性为只读但程序试图写入的时候一旦发生缺页异常会执行表中的号中断处理程序由操作系统来接管控制寄存器控制寄存器用于控制和确定的操作模式共个保留页目录表基址不同分页模式不一样寄存器位功能描述的位是启用保护标志位保护模式实地址模式该标志仅开启段级保护而并没有启用分页机制若要启用分页机制和标志位都要置位设置该位时即开启了分页机制在开启这个标志位之前必须已经或同时开启标志对于或以上的的位是写保护标志当设置该标志时处理器会禁止超级用户程序例如特权级的程序向用户级只读页面执行写操作只要是写别人的内存不管是干嘛的首先把这个位设置写完了再改回来管理三环下的字节对齐检查设置为的时候用户态当寄存器中的标志为时候是按照段描述的位字节对齐检查的禁止写总开关相当于中的和位的总控且时处理器工作在实地址模式且时处理器工作在没有开启分页机制的保护模式下目前为止没有任何一个操作系统工作在这个模式且时这种情况不存在在没有开启的情况下无法开启且时处理器工作在开启了分页机制的保护模式下当的时候如果可以读写任意用户级物理页只要线性地址有效如果可以读取任意用户即物理页但对于只读的物理页则不可以写寄存器当访问某个无效页面时会产生缺页异常此时会将引起异常的线性地址存放在中里面有这个函数函数非常长的处理流程寄存器位功能描述是分页是分页大页的总开关中的位的总开关只有当为的时候中的位才有意义仅和位都是的时候该指向的物理页才是大页全局页总开关和的位总开关时位才有效把设为进程切换就会刷新全部控制寄存器更多的细节参考白皮书第三卷中的和位缓存缓存是位于与物理内存之间的临时存储器它的容量比内存小的多但是交换速度却比内存要快得多缓存可以做的很大有几几十几百甚至上的也有缓存与存储的东西的区别线性地址物理地址缓存物理地址内容关于的更多细节可以了解因特尔白皮书第三卷时写的时候也要讲数据写入内存中时写的时候只写入时禁止某个页的写入直接写内存比如做页表用的页已经存储在中了可能不需要再缓存了因此他们的都是置的保护模式阶段总结参见因特尔白皮书第三卷的第章到第章保护模式实验两道题第一题给定一个线性地址和长度读取内容要求可以自己指定分页方式页不存在要提示不能报错可以正确读取数据残缺版并未实现所有功能取取读数据此处需要对线性地址做是否跨页的判断决定下面校验几次返回值取决于全局变量构造测试用例内存无效用函数读到改成读取地址第二题申请长度为的的数组且每项用该项的地址初始化把这个数组所在的物理页挂到的地址上定义一个指针指向这个页里的数组所在的地址用这个页的线性地址打印出这数组的值要求数组所在的物理页是同一个页略补充知识点信息查询通过设置的参数此后获取到的值为解读为线性地址位数为物理地址位数支持很多信息查询包括是否支持也通过该指令查找此后的第五位为的话表示支持物理页地址映射',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-24 10:49:02',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://th.bing.com/th/id/OIP.wtmjepfWPBvn26uz7s18dgHaHa?rs=1&amp;pid=ImgDetMain"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">ZEROKO14的个人博客</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size: 1.05rem;">C#<sup>3</sup></a><a href="/tags/C/" style="font-size: 1.05rem;">C++<sup>5</sup></a><a href="/tags/CSS/" style="font-size: 1.05rem;">CSS<sup>1</sup></a><a href="/tags/CSharp/" style="font-size: 1.05rem;">CSharp<sup>1</sup></a><a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 1.05rem;">C语言<sup>1</sup></a><a href="/tags/FPS/" style="font-size: 1.05rem;">FPS<sup>1</sup></a><a href="/tags/HTML/" style="font-size: 1.05rem;">HTML<sup>1</sup></a><a href="/tags/JavaScript/" style="font-size: 1.05rem;">JavaScript<sup>1</sup></a><a href="/tags/MFC/" style="font-size: 1.05rem;">MFC<sup>1</sup></a><a href="/tags/PE/" style="font-size: 1.05rem;">PE<sup>1</sup></a><a href="/tags/QT/" style="font-size: 1.05rem;">QT<sup>1</sup></a><a href="/tags/WPF/" style="font-size: 1.05rem;">WPF<sup>3</sup></a><a href="/tags/ai/" style="font-size: 1.05rem;">ai<sup>1</sup></a><a href="/tags/cmake/" style="font-size: 1.05rem;">cmake<sup>1</sup></a><a href="/tags/doxygen/" style="font-size: 1.05rem;">doxygen<sup>1</sup></a><a href="/tags/git/" style="font-size: 1.05rem;">git<sup>1</sup></a><a href="/tags/json/" style="font-size: 1.05rem;">json<sup>1</sup></a><a href="/tags/linux/" style="font-size: 1.05rem;">linux<sup>1</sup></a><a href="/tags/next/" style="font-size: 1.05rem;">next<sup>1</sup></a><a href="/tags/ppt/" style="font-size: 1.05rem;">ppt<sup>1</sup></a><a href="/tags/slidev/" style="font-size: 1.05rem;">slidev<sup>1</sup></a><a href="/tags/vue/" style="font-size: 1.05rem;">vue<sup>1</sup></a><a href="/tags/xml/" style="font-size: 1.05rem;">xml<sup>1</sup></a><a href="/tags/yaml/" style="font-size: 1.05rem;">yaml<sup>1</sup></a><a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 1.05rem;">代码规范<sup>1</sup></a><a href="/tags/%E5%86%85%E6%A0%B8/" style="font-size: 1.05rem;">内核<sup>2</sup></a><a href="/tags/%E5%86%85%E6%A0%B8%E7%9B%B8%E5%85%B3/" style="font-size: 1.05rem;">内核相关<sup>5</sup></a><a href="/tags/%E5%8A%A0%E8%A7%A3%E5%AF%86/" style="font-size: 1.05rem;">加解密<sup>1</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 1.05rem;">多线程<sup>1</sup></a><a href="/tags/%E5%BC%80%E5%8F%91/" style="font-size: 1.05rem;">开发<sup>4</sup></a><a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 1.05rem;">数学<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 1.05rem;">数据库<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 1.05rem;">数据结构<sup>1</sup></a><a href="/tags/%E6%9E%B6%E6%9E%84/" style="font-size: 1.05rem;">架构<sup>1</sup></a><a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 1.05rem;">正则表达式<sup>1</sup></a><a href="/tags/%E7%9B%91%E6%8E%A7/" style="font-size: 1.05rem;">监控<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 1.05rem;">算法<sup>1</sup></a><a href="/tags/%E7%AE%A1%E7%90%86/" style="font-size: 1.05rem;">管理<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 1.05rem;">网络<sup>2</sup></a><a href="/tags/%E9%80%86%E5%90%91/" style="font-size: 1.05rem;">逆向<sup>2</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/09/"><span class="card-archive-list-date">九月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">七月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">13</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/06/"><span class="card-archive-list-date">六月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/04/"><span class="card-archive-list-date">四月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">十一月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">27</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/12/"><span class="card-archive-list-date">十二月 2022</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/10/"><span class="card-archive-list-date">十月 2021</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2020/12/"><span class="card-archive-list-date">十二月 2020</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url">技术</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E5%86%85%E6%A0%B8%E7%9B%B8%E5%85%B3/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>内核相关</span></a></span></div></div><h1 class="post-title" itemprop="name headline">保护模式</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-11-24T02:49:02.207Z" title="发表于 2023-11-24 10:49:02">2023-11-24</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2023-11-24T02:49:02.208Z" title="更新于 2023-11-24 10:49:02">2023-11-24</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="保护模式"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为新加坡"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>新加坡</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://che77a38.github.io/posts/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/"><header><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url">技术</a><a href="/tags/%E5%86%85%E6%A0%B8%E7%9B%B8%E5%85%B3/" tabindex="-1" itemprop="url">内核相关</a><h1 id="CrawlerTitle" itemprop="name headline">保护模式</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">ZEROKO14</span><time itemprop="dateCreated datePublished" datetime="2023-11-24T02:49:02.207Z" title="发表于 2023-11-24 10:49:02">2023-11-24</time><time itemprop="dateCreated datePublished" datetime="2023-11-24T02:49:02.208Z" title="更新于 2023-11-24 10:49:02">2023-11-24</time></header><p>Q：什么是保护模式？</p>
<span id="more"></span>

<p>A：x86 CPU的3个模式：</p>
<ol>
<li>实模式</li>
<li>保护模式（虚拟8086模式）</li>
<li>系统管理模式</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210803161045133.png" alt="image-20210803161045133"></p>
<p>现在的操作系统大多数都是运行于保护模式下的</p>
<p>保护模式就是指给操作系统添加的保护特性，保护的目标是硬件资源和OS内核。</p>
<h1 id="学习前的环境配置"><a href="#学习前的环境配置" class="headerlink" title="学习前的环境配置"></a><strong>学习前的环境配置</strong></h1><p>由于本人使用的操作系统是win10 1909，因此开发当前版本的驱动需要<code>vs2019+Windows 10 WDK 2004(10.0.19041.1) + Windows 10 SDK 2004(10.0.19041.1)</code></p>
<blockquote>
<p>或者10.0.18362.1版本,vs安装要设置<code>C++的桌面开发</code>,<code>通用Windows平台开发(勾选Windows 10 SDK(10.0.18362.0))</code>,<code>Visual Studio拓展开发</code>,完事了wdk也安装10.0.18362版本</p>
</blockquote>
<p><a href="#https://visualstudio.microsoft.com/zh-hans/thank-you-downloading-visual-studio/?sku=Professional&rel=16">vs2019版本安装链接跳转</a></p>
<p>要注意在单个组件中选上：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210721202744811.png" alt="image-20210721202744811"></p>
<p>环境配置的<a target="_blank" rel="noopener" href="https://blog.csdn.net/psbeond/article/details/108780644">参考网址</a></p>
<p>【小注意点】微软官网下载vs2019时有bug，必须等他一段时间弹出下载，不要再点重新下载，不然重新下载的是vs2017，而不是vs2019</p>
<p>下载完毕后，再到微软官网下载Windows 10 WDK 2004(10.0.19041.1)。</p>
<p>至此<code>vs2019+Windows 10 WDK 2004(10.0.19041.1) + Windows 10 SDK 2004(10.0.19041.1)</code>环境就装好了。</p>
<p><a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-257955.htm">虚拟机和符号表对应下载</a></p>
<h2 id="双机调试配置"><a href="#双机调试配置" class="headerlink" title="双机调试配置"></a><strong>双机调试配置</strong></h2><p>由于系统调试要下断点，下断点后系统将只有调试子系统继续运行，因此不能直接调试本机的系统。因此需要<strong>双机调试配置</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210722134228056.png" alt="image-20210722134228056"></p>
<p>配置双机调试流程</p>
<ol>
<li><p>在本机安装windbg(上述配环境的时候装WDK，里面自带有windbg)</p>
</li>
<li><p>在虚拟机中(WinXP)修改boot.ini（修改系统启动项）</p>
<p>C盘显示隐藏文件，找到boot.ini打开</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210722135330345.png" alt="image-20210722135330345"></p>
<p>原内容：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210722140422465.png" alt="image-20210722140422465"></p>
<p>新内容</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210722145554924.png" alt="image-20210722145554924"></p>
<p>红线为添加行，<code>/debug</code>表示调试模式，第一段黄标为名字，可以随便起；<code>/debugport=com2</code>表示指定的调试串口为com2，下图可见原本只有com1一个串口（黄标）。com2是为后续步骤虚拟机设置步骤中添加的串口</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210722141112675.png" alt="image-20210722141112675"></p>
<p>自己添加的启动项如下图黄标</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210722143157677.png" alt="image-20210722143157677"></p>
</li>
<li><p>设置虚拟机（为虚拟机新增一个串口设备）</p>
<p>添加步骤：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210722142547813.png" alt="image-20210722142547813"></p>
<p>P.s.打印机也会占用一个串口</p>
<p>添加好后查看设备管理器：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210722145936297.png" alt="image-20210722145936297"></p>
<p>黄标为我们刚添加的新串口。</p>
</li>
<li><p>修改Windbg运行参数，指向虚拟机。</p>
<p>Windbg的选择简单参考：调试机器是32位系统就用32位windbg，64位系统就64位windbg(<a target="_blank" rel="noopener" href="https://blog.csdn.net/mergerly/article/details/8602008">实则更为复杂</a>)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210722142840195.png" alt="image-20210722142840195"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210722150950760.png" alt="image-20210722150950760"></p>
</li>
</ol>
<p>p.s.   WDK,Windows Driver Kit,用于开发驱动的驱动开发包</p>
<p><strong>准备工作做好后</strong></p>
<h2 id="开始双机调试"><a href="#开始双机调试" class="headerlink" title="开始双机调试"></a>开始双机调试</h2><p>必须在下图界面的时候先别按回车</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210722143157677.png" alt="image-20210722143157677"></p>
<p>本机上打开设置好的windbg，显示正在连接，再到虚拟机中点击回车系统进入调试模式。</p>
<p>此时成功断下，效果如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210722144832857.png" alt="image-20210722144832857"></p>
<p>此时系统是断下状态，因此是类似黑屏</p>
<p>此时在windbg命令行中输入g，表示让系统继续执行</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210722145152427.png" alt="image-20210722145152427"></p>
<p>之后还想中断的话，按下图按钮。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210722145334493.png" alt="image-20210722145334493"></p>
<p>至此双机调试配置成功！</p>
<p>保护模式学习的时候尽量虚拟机要设置为单核，防止干扰。</p>
<h2 id="WinDbg的退出"><a href="#WinDbg的退出" class="headerlink" title="WinDbg的退出"></a>WinDbg的退出</h2><p>通过 <code>q</code> 或者 <code>ALT + F4</code> 退出调试并销毁被调试进程：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">q</span></span><br></pre></td></tr></table></figure>

<p>通过 <code>qd</code> 退出调试，但被调试进程继续运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">qd</span></span><br></pre></td></tr></table></figure>

<p><strong>部分使用方式</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210820185552204.png" alt="image-20210820185552204"></p>
<p>一些细节：</p>
<ul>
<li>8086CPU不支持将数据直接送入寄存器的操作， <code>mov ds, 1000H</code> 这条指令是非法的。想要将 <code>1000H</code> 送入DS，需要使用一个寄存器进行中转，先将 <code>1000H</code> 送入一个一般的寄存器，再将这个寄存器中的内容送入DS</li>
<li>8086的入栈和出栈操作都是以 <strong>字</strong> 为单位进行的</li>
<li>栈空的时候 <code>SS:SP</code> 指向栈空间最高地址单元的下一个单元，如果把 <code>10000H-1000FH</code> 这段空间当作栈，初始状态栈是空的的时候 <code>SS:SP</code> &#x3D; <code>1000:0010</code></li>
<li>用 <code>xor ax, ax</code> 或者 <code>sub ax, ax</code> 而不是 <code>mov ax, 0</code> 来将 <code>ax</code> 清零的主要原因是前两个（在32位下）的机器码是3个字节，而 <code>mov ax,0</code> 的机器码是4个字节。</li>
<li>执行 <code>push</code> 时，CPU要进行两步操作：先改变 <code>SP</code> ，后向 <code>SS:SP</code> 处传送。执行 <code>POP</code> 时，CPU先读取 <code>SS:SP</code> 处的数据，然后改变 <code>sp</code> 。</li>
<li>一个栈段最大64K（在8086CPU环境下），因为栈顶的变化范围是 <code>0-FFFFH</code> 。如果一直压栈的话栈顶将环绕，覆盖原来栈中的内容</li>
<li><strong>在汇编源程序中，数据不能以字母开头，所以要在前面加0</strong></li>
</ul>
<hr>
<ul>
<li>Q：为什么不直接学习x64</li>
<li>A：x86是由Intel推出的一种复杂指令集，能够生产支持这种指令集。CPU公司主要是Intel和AMD。AMD在1999年的时候，拓展了这套指令集，称为x86-64，后改名为AMD64，Intel也兼容了这个产品，称为Intel 64。但AMD64和Intel64几乎是一样的，所以在很多资料中统称为x64。而这套指令集是对x86的拓展，向下兼容的。</li>
</ul>
<p><strong>保护模式有什么特点？</strong></p>
<ol>
<li>段的机制</li>
<li>页的机制</li>
</ol>
<p>通过这两种机制来达到保护<code>系统的一些数据结构，还有一些关键的寄存器</code>的目的。</p>
<ul>
<li>Q：学习保护模式有什么用？</li>
<li>A：真正理解内核是如何运作的</li>
</ul>
<p>参考书：**&lt;Intel 白皮书第三卷&gt;**，3,4,5,6,7章</p>
<p>p.s.</p>
<ol>
<li>Intel白皮书第二卷是查指令的</li>
<li>Intel 白皮书第三卷是讲保护模式的</li>
</ol>
<h1 id="保护模式–段"><a href="#保护模式–段" class="headerlink" title="保护模式–段"></a>保护模式–段</h1><p>保护模式的2种重要机制：</p>
<ul>
<li>段</li>
<li>页</li>
</ul>
<p>保护模式知识结构总览：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/20140711174502103.jpg" alt="20140711174502103"></p>
<p>段的机制非常复杂，想了解段的机制要先了解段寄存器。</p>
<p>为何需要段的机制？16位系统的寄存器为16位二进制，只可以寻址64KB（2的16次方除以1024等于64）的大小内存，<code>左移四位再加一千来索引1MB内存</code>，因此出现了段的机制可以解决这个问题。</p>
<p>由于32位系统寄存器是32位，所以上述功能（base的功能)已经被弱化了，仅留下重要的是权限检查机制。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210803164459681.png" alt="image-20210803164459681"></p>
<p>32位以后，现在除了FS寄存器以外，其他段寄存器的base字段已经全部设置为0了</p>
<h2 id="段寄存器结构"><a href="#段寄存器结构" class="headerlink" title="段寄存器结构"></a>段寄存器结构</h2><p>段寄存器有哪些</p>
<p>ES CS SS DS FS GS LDTR TR GDTR IDTR等等</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210803145809961.png" alt="image-20210803145809961"></p>
<ul>
<li><p>代码段寄存器CS（Code Segment）</p>
<p>​		存放当前正在运行的程序代码所在段的段基址，表示当前使用的指令代码可以从该段寄存器指定的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E5%99%A8">存储器</a>段中取得，相应的偏移量则由IP提供。</p>
</li>
<li><p>数据段寄存器DS（Data Segment）</p>
<p>​		指出当前程序使用的数据所存放段的最低地址，即存放数据段的段基址。</p>
</li>
<li><p>堆栈段寄存器SS（Stack Segment）</p>
<p>​		指出当前堆栈的底部地址，即存放堆栈段的段基址。</p>
</li>
<li><p>附加段寄存器ES（Extra Segment）</p>
<p>​		指出当前程序使用附加<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E6%AE%B5">数据段</a>的段基址，该段是串操作指令中目的串所在的段。</p>
</li>
</ul>
<h3 id="段寄存器的结构"><a href="#段寄存器的结构" class="headerlink" title="段寄存器的结构"></a>段寄存器的结构</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210816220946809.png" alt="image-20210816220946809"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SegMent</span></span><br><span class="line">&#123;</span><br><span class="line">	WORD Selector;	<span class="comment">//16位Selecter（可见部分），段选择子</span></span><br><span class="line">	WORD Attributes;	<span class="comment">//12位Attribute</span></span><br><span class="line">	DWORD Base;		<span class="comment">//32位Base</span></span><br><span class="line">	DWORD Limit;	<span class="comment">//32位Limit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们能看到的段寄存器的值只有可见部分的16位。</p>
<blockquote>
<p>段寄存器中有16位是可见部分，有八十位是不可见部分，一共92位。<br>可见部分为16位的Selector部分<br>12位的Attribute为这个段寄存器的属性，它的意义为：表示该段寄存器是可读还是可写还是可执行的。<br>32位的Base表示该段是从哪里开始的。<br>32位的Limit表示整个段的长度有多少。</p>
</blockquote>
<h3 id="段寄存器的读写"><a href="#段寄存器的读写" class="headerlink" title="段寄存器的读写"></a>段寄存器的读写</h3><h4 id="读段寄存器"><a href="#读段寄存器" class="headerlink" title="读段寄存器"></a>读段寄存器</h4><p>比如：MOV AX,ES	<strong>读的时候，只能读16位的可见部分（必须写rX,不能写其他如ErX）</strong></p>
<p>读写LDTR的指令为：SLDT&#x2F;LLDT</p>
<p>读写TR的指令为：STR&#x2F;LTR</p>
<h4 id="写段寄存器"><a href="#写段寄存器" class="headerlink" title="写段寄存器"></a>写段寄存器</h4><p>比如：MOV DS,AX	<strong>写时是写92位</strong></p>
<h4 id="段寄存器属性探测"><a href="#段寄存器属性探测" class="headerlink" title="段寄存器属性探测"></a>段寄存器属性探测</h4><table>
<thead>
<tr>
<th>段寄存器</th>
<th>Selector</th>
<th>Attribute</th>
<th>Base</th>
<th>Limit</th>
</tr>
</thead>
<tbody><tr>
<td>ES</td>
<td><em><code>0023</code></em></td>
<td>可读可写</td>
<td>0</td>
<td>0xFFFFFFFF</td>
</tr>
<tr>
<td>CS</td>
<td><em><code>001B</code></em></td>
<td>可读可执行</td>
<td>0</td>
<td>0xFFFFFFFF</td>
</tr>
<tr>
<td>SS</td>
<td><em><code>0023</code></em></td>
<td>可读可写</td>
<td>0</td>
<td>0xFFFFFFFF</td>
</tr>
<tr>
<td>DS</td>
<td><em><code>0023</code></em></td>
<td>可读可写</td>
<td>0</td>
<td>0xFFFFFFFF</td>
</tr>
<tr>
<td>FS</td>
<td><em><code>003B</code></em></td>
<td>可读可写</td>
<td><em><code>0x7FFDE000</code></em></td>
<td>0xFFF</td>
</tr>
<tr>
<td>GS</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<p>上图中有这个*<code>标记</code>*的表示他在不同操作系统的该值不一致</p>
<p>GS在windows中不使用，所以用短横杠填写。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210716115523846.png" alt="image-20210716115523846"></p>
<p>上图的原因是ds段寄存器此时实际上是cs寄存器，cs寄存器不可写。</p>
<p>把cs换成es就不会报错，因为es段是可写的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> var=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm</span><br><span class="line">	&#123;</span><br><span class="line">    	mov ax,fs</span><br><span class="line">    	mov gs,ax</span><br><span class="line">    	mov eax,dword ptr ds:[<span class="number">0x1000</span>]</span><br><span class="line">    	<span class="comment">//上面相当于mov eax,dword ptr fs:[0x1000]</span></span><br><span class="line">    	<span class="comment">//由于fs的limit为0xFFF,0x1000&gt;0xFFF，所以访问报错</span></span><br><span class="line">    	mov dword ptr ds:[var],eax</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写一个段寄存器的时候我们只给了16位，那么剩下的76位来自于哪里呢？</p>
<h3 id="段描述符与段选择子"><a href="#段描述符与段选择子" class="headerlink" title="段描述符与段选择子"></a>段描述符与段选择子</h3><p><strong>保护模式下三个重要的系统表——GDT、LDT和IDT</strong></p>
<ul>
<li>GDT全局描述符表</li>
<li>LDT局部描述符表(在windows中没有使用)</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/davytitan/p/12094857.html">中断描述符表 IDT</a></li>
</ul>
<p>当我们执行类似MOV DS,AX指令时，CPU会查表，根据AX的值来决定查找GDT还是LDT，查表的什么位置，查出多少数据。</p>
<p>gdtr是一个寄存器（48位），存储的是表的开始位置（32位）和长度(16位)</p>
<p>GDTR寄存器中存放的是GDT在内存中的基地址和其表长界限。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/GDTR-300x103.jpg" alt="GDTR-300x103"></p>
<p>前16位是保存GDT里面的限长，后17到42位保存的是段基址</p>
<p>ldtr和gdtr有区别，存的是段选择子。</p>
<p>汇编指令LGDT和SGDT分别用于加载和保存GDTR寄存器的内容。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kd&gt;r gdtr<span class="comment">//查看gdtr寄存器，gdt这样表在哪里。（r表示查看寄存器）</span></span><br><span class="line">gtdr=<span class="number">8003</span>f000</span><br><span class="line">kd&gt;r gdtl<span class="comment">//查看的也是gdtr寄存器，查看gdt表有多长。</span></span><br><span class="line">gdtl=<span class="number">000003</span>FF</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210716151328569.png" alt="image-20210716151328569"></p>
<p>图中dd命令罗列出来的就是GDT表。</p>
<p>剩下的76位来自于GDT表，表里存储的元素我们叫<strong>段描述符</strong></p>
<h4 id="段描述符"><a href="#段描述符" class="headerlink" title="段描述符"></a>段描述符</h4><p>每个段描述符是8个字节，即64位。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/d6ca7bcb0a46f21fbe09bc4ba26d7c600c33874400db.png" alt="d6ca7bcb0a46f21fbe09bc4ba26d7c600c33874400db"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/v2-2664817822c89c64a9e8adc8c34495cc_hd.png" alt="v2-2664817822c89c64a9e8adc8c34495cc_hd"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210716152133226.png" alt="image-20210716152133226"></p>
<p>黄色荧光笔标记出来的是图解中的低32位。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210716152630988.png" alt="image-20210716152630988"></p>
<p>dq是按照qword（8字节）来分组，后接的L40表示显示0x40组。</p>
<h4 id="段选择子"><a href="#段选择子" class="headerlink" title="段选择子"></a>段选择子</h4><p>段选择子是一个16位的段描述符，该描述符指向了定义该段的段描述符。</p>
<p>写段寄存器的时候写的就是段选择子。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/20180914112453186.png" alt="20180914112453186"></p>
<ul>
<li><p>RPL:请求特权级别</p>
</li>
<li><p>TI:</p>
<ul>
<li>TI&#x3D;0查GDT表</li>
<li>TI&#x3D;1查LDT表（Windows没有使用）</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/1226829-20200409145558030-1848157450.png" alt="1226829-20200409145558030-1848157450"></p>
</li>
<li><p>INDEX： 处理器将索引值乘以8再加上GDT表的基址，就是要加载的段描述符</p>
</li>
</ul>
<h5 id="加载段描述符到段寄存器"><a href="#加载段描述符到段寄存器" class="headerlink" title="加载段描述符到段寄存器"></a>加载段描述符到段寄存器</h5><p>除了MOV指令，我们还可以使用LES，LSS，LDS，LFS，LGS指令修改寄存器（L表示load，LES表示load ES即加载ES段寄存器）</p>
<p>CS不能通过上述的指令进行修改，<strong>CS为代码段，CS的改变会导致EIP实际指向的代码的改变</strong>，要改变CS，必须要保证CS与EIP一起改，后面会讲。</p>
<p><strong>LES的使用案例</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buffer[<span class="number">6</span>];</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">    les ecx,fword ptr ds:[buffer]<span class="comment">//fword表示6个字节，高2个字节(段选择子)给es，低四个字节给ecx</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//提供的RPL&lt;=DPL（数值上）,才能成功</span></span><br></pre></td></tr></table></figure>

<h4 id="段描述符的属性"><a href="#段描述符的属性" class="headerlink" title="段描述符的属性"></a>段描述符的属性</h4><p>段寄存器的值是通过<strong>段描述符填充</strong>的</p>
<p>但段描述符只有64位，如何从64位变成76位(76位是92位撇去段选择子的16位)</p>
<p>LIMIT多了12位。(参考下方G位的讲解)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/20180914111021493.png" alt="20180914111021493"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegMent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	WORD Selector;	<span class="comment">//16位Selecter（可见部分），段选择子</span></span><br><span class="line">	WORD Attributes;	<span class="comment">//12位Attribute</span></span><br><span class="line">	DWORD Base;		<span class="comment">//32位Base</span></span><br><span class="line">	DWORD Limit;	<span class="comment">//32位Limit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Attributes</strong>对应的是高4字节从第8位开始到第15位，第20位开始到23位结束共12位。</li>
<li><strong>Base</strong>是【高4字节的24<del>31位】+【高四字节的第0</del>7位】+【低四字节的16~31位】共同组成的32位</li>
<li><strong>Limit</strong>是【高4字节的16<del>19位】+【低4字节的0</del>15】确定了20位，<strong>剩下的12位依赖G位</strong>(下有详情)</li>
</ul>
<h5 id="P位和G位"><a href="#P位和G位" class="headerlink" title="P位和G位"></a>P位和G位</h5><h6 id="P位"><a href="#P位" class="headerlink" title="P位"></a>P位</h6><ul>
<li>P&#x3D;1	表示段描述符有效</li>
<li>P&#x3D;0	表示段描述符无效</li>
</ul>
<p>当我们将一个段描述符加载到段寄存器的时候，CPU做的第一件事就是检查P位，如果P为0，后续的检查就不做了，若P为1，后续的检查才做。</p>
<h6 id="G位"><a href="#G位" class="headerlink" title="G位"></a>G位</h6><ul>
<li>G&#x3D;0	表示limit的单位是字节。<strong>在前面填充0x000</strong>补齐32位，此时LIMIT的值就是0x000XXXXX的字节大小。</li>
<li>G&#x3D;1	表示limit的单位是4Kb，4kb的地址为0~0xFFF(十进制4095)，如果是G&#x3D;1的话，<strong>在后面填充0xFFF</strong>。此时LIMIT为0xXXXXXFFF</li>
</ul>
<p>p.s.  FS对应的段描述符比较特殊，查分后的值与段寄存器中的值不符合，讲到操作系统(线程)的时候会有解释。</p>
<h5 id="S位和TYPE域"><a href="#S位和TYPE域" class="headerlink" title="S位和TYPE域"></a>S位和TYPE域</h5><h6 id="S位"><a href="#S位" class="headerlink" title="S位"></a>S位</h6><p>当我们将一个段描述符加载到段寄存器的时候，CPU做的第一件事就是检查P位，第二件事就是判断该段描述符是<code>[数据或代码段描述符]</code>还是<code>[系统段描述符]</code></p>
<ul>
<li>S&#x3D;1	代码段或者数据段描述符</li>
<li>S&#x3D;0	系统段描述符</li>
</ul>
<p>P位为1，并且S位为1，DPL只有两种情况(即要么是全0，要么全1)，所以可知GDT中，下图标黄部<strong>如果是9(二进制1001)或者F(二进制1111)表示此段是代码段或者数据段描述符</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210719173833659.png" alt="image-20210719173833659"></p>
<h6 id="TYPE域"><a href="#TYPE域" class="headerlink" title="TYPE域"></a>TYPE域</h6><p><strong>type域的含义根据S位来变化</strong></p>
<ol>
<li><strong>当S&#x3D;1时</strong></li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/20200924170933342.png" alt="20200924170933342"></p>
<p>TYPE域中的第一位，也就是段描述符高4字节的第11位，区分该段到底是代码段还是数据段。如果有是1，则表示代码段，如果是0，表示数据段。</p>
<p><strong>SS与FS都属于数据段</strong>。</p>
<p>这意味着下图标黄的16进制位，如果<strong>大于等于8，则表示是代码段，否则是数据段</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210720135717758.png" alt="image-20210720135717758"></p>
<p><strong>A 访问位</strong>：表示该位最后一次被操作系统清零后，该段是否被访问过。每当处理器将该段选择符置入某个段寄存器时，就将该位置1。</p>
<p><strong>C 表示一致位</strong></p>
<ul>
<li>C&#x3D;1	一致代码段</li>
<li>C&#x3D;0	非一致代码段</li>
</ul>
<p><strong>E 拓展方向</strong></p>
<ul>
<li>E&#x3D;0	向上拓展</li>
<li>E&#x3D;1	向下拓展</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210720142837575.png" alt="image-20210720142837575"></p>
<p>图中橙色部分表示段所在位置。向上拓展是从fs.Base到fs.Base+Limit的区间，而向下拓展是该区间取反的区间</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/825979-20180526000445198-633418260.png" alt="825979-20180526000445198-633418260"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/825979-20180526000556126-973886506.png" alt="825979-20180526000556126-973886506"></p>
<ol start="2">
<li><strong>当S&#x3D;0时</strong></li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/20190117135616418_.png" alt="20190117135616418_"></p>
<h5 id="D-B位"><a href="#D-B位" class="headerlink" title="D&#x2F;B位"></a>D&#x2F;B位</h5><p>D&#x2F;B位对三种段有影响。</p>
<ol>
<li><p>对CS段的影响</p>
<p>​	D&#x3D;1	采用32位寻址方式</p>
<p>​	D&#x3D;0	采用16位寻址方式</p>
<p>​	（前缀67	改变寻址方式	方便观察16位寻址方式是什么样的）</p>
</li>
<li><p>对SS段的影响（数据段的段描述符加载到SS段里他就是SS段了，但本质还是数据段）</p>
<p>​	D&#x3D;1	隐式堆栈访问指令(如：PUSH POP CALL)使用32位堆栈指针寄存器ESP</p>
<p>​	D&#x3D;0	隐式堆栈访问指令(如：PUSH POP CALL)使用16位堆栈指针寄存器SP</p>
</li>
<li><p>向下拓展的数据段</p>
<p>​	D&#x3D;1	向下拓展段上限为4GB</p>
<p>​	D&#x3D;0	向下拓展段上限为64KB</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210720150013578.png" alt="image-20210720150013578"></p>
</li>
</ol>
<p>红色表示该段的区间。D&#x3D;0表示上图右侧，两块红色相加为64KB。</p>
<h5 id="AVL属性"><a href="#AVL属性" class="headerlink" title="AVL属性"></a>AVL属性</h5><p>AVL属性占1个比特，该属性的意义可由操作系统、应用程序自行定义。<br>Intel保证该位不会被占用作为其他用途。</p>
<h5 id="段权限检查（CPL，RPL-DPL）"><a href="#段权限检查（CPL，RPL-DPL）" class="headerlink" title="段权限检查（CPL，RPL,DPL）"></a>段权限检查（CPL，RPL,DPL）</h5><p>段选择子加载到段寄存器中，要进行段权限检查。</p>
<p><strong>CPU分级</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210720164312737.png" alt="image-20210720164312737"></p>
<p>windows只使用了三环和零环。</p>
<p><strong>R3与R0的理解</strong></p>
<p>R0不能调用R3的函数，但是R0可以访问R3的内存空间，因此可以把函数拷贝到R0的内存空间再通过函数指针的方式调用，还要切换CR3，涉及后续课程知识。</p>
<h6 id="如何查看程序处于几环"><a href="#如何查看程序处于几环" class="headerlink" title="如何查看程序处于几环"></a>如何查看程序处于几环</h6><p><strong>CPL</strong>（Current Privilege Level）：<strong>当前特权级</strong></p>
<p>段选择子后<strong>2位</strong>(段选择子后两位为RPL，但CS和SS的段选择子的后两位比较特殊，表示CPL)：当前环数。</p>
<p>x86规定了CS和SS的后两位一定是一样的。</p>
<p><strong>DPL</strong>（Descriptor Privilege Level）：<strong>描述符特权级别</strong></p>
<p>DPL存储在段描述符中，规定了访问该段所需要的特权级别是什么</p>
<blockquote>
<p>通俗的理解：</p>
<p>如果你想访问我，那么你应该具备什么特权。</p>
<p>举例说明：</p>
<p>mov DS,AX</p>
<p>如果AX指向的段DPL &#x3D; 0	但当前程序的CPL &#x3D; 3	这行指令是不会成功的（因为权限检查的时候通不过）</p>
</blockquote>
<p><strong>RPL</strong>（Request Privilege Level）：<strong>请求的特权级别</strong></p>
<p>RPL是针对段选择子而言的，每个段的选择子都有自己的RPL</p>
<h6 id="数据段的权限检查"><a href="#数据段的权限检查" class="headerlink" title="数据段的权限检查"></a>数据段的权限检查</h6><p>参考如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比如当前程序处于0环，也就是说CPL=0</span></span><br><span class="line">Mov ax<span class="number">.000</span>B		<span class="comment">//1011	RPL=3</span></span><br><span class="line">Mov ds,ax		<span class="comment">//ax指向的段描述符的DPL=0</span></span><br></pre></td></tr></table></figure>

<p><strong>数据段的权限检查流程</strong><br>$$<br>CPL &lt;&#x3D; DPL	并且	RPL &lt;&#x3D; DPL (数值上的比较)<br>$$<br>由于上面代码中RPL&gt;DPL，所以权限检查无法通过。</p>
<p>注意：</p>
<p>代码段和系统段描述符中的检查方式并不一样，具体参考后面课程。（上面仅为数据段的权限流程检查）</p>
<h6 id="词汇总结"><a href="#词汇总结" class="headerlink" title="词汇总结"></a>词汇总结</h6><ul>
<li>CPL	CPU当前的权限级别</li>
<li>DPL	如果你想访问我，你应该具备什么样的权限</li>
<li>RPL	用什么权限去访问一个段</li>
</ul>
<h2 id="代码跨段"><a href="#代码跨段" class="headerlink" title="代码跨段"></a>代码跨段</h2><p><strong>本质就是修改CS段寄存器</strong></p>
<p>段寄存器：</p>
<p>ES,CS,SS,DS,FS,GS,LDTR,TR</p>
<p>段寄存器读写：除CS，LDTR,TR外，其他的段寄存器都可以通过MOV,LES,LSS,LSD,LFS,LGS指令进行修改。</p>
<p>CS为什么不可以直接修改呢？</p>
<p>CS(代码段)的改变意味着EIP的改变，改变CS的同时必须修改EIP，所以我们无法使用上面的指令来进行修改。</p>
<h3 id="代码间的跳转-段间跳转非调用门之类的"><a href="#代码间的跳转-段间跳转非调用门之类的" class="headerlink" title="代码间的跳转(段间跳转	非调用门之类的)"></a>代码间的跳转(段间跳转	非调用门之类的)</h3><p>段间跳转，有2种情况，即要跳转的段是一致代码还是非一致代码段。</p>
<ul>
<li>同时修改CS与EIP的指令：<code>JMP FAR</code> &#x2F; <code>CALL FAR</code> &#x2F; <code>RETF</code> &#x2F; <code>INT</code> &#x2F; <code>IRETD</code>&#x2F; <code>IRET</code></li>
<li>【注意】只修改EIP的指令：<code>JMP</code> &#x2F; <code>CALL</code> &#x2F; <code>JCC</code> &#x2F; <code>RET</code></li>
</ul>
<p>p.s.以前IRETD<code>/ </code>IRET&#96;这两个指令前者是32位，后者是16位的，但现在根据D&#x2F;B位已经没有区别了，默认都是32位。</p>
<h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JMP 0x20:0x004183D7	--CPU如何执行该指令(长跳转/段间跳转)</span><br></pre></td></tr></table></figure>

<ol>
<li><p>段选择子拆分</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x20</span>	对应二进制形式	<span class="number">0000</span> <span class="number">0000</span> <span class="number">0010</span> <span class="number">0000</span></span><br><span class="line">    RPL=<span class="number">00</span></span><br><span class="line">    TI=<span class="number">0</span></span><br><span class="line">    Index=<span class="number">4</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查表得到段描述符</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)TI=<span class="number">0</span>，所以查GDT表</span><br><span class="line">(<span class="number">2</span>)Index=<span class="number">4</span>，所以找到对应的段描述符（四种情况的段描述符才可以跳转：代码段，调用门，TSS任务段，任务门）</span><br></pre></td></tr></table></figure>
</li>
<li><p>权限检查</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果是非一致代码段，要求：CPL == DPL 并且 RPL &lt;= DPL(数值上)</span><br><span class="line">如果是一致代码段，要求：CPL &gt;= DPL(数值上)</span><br></pre></td></tr></table></figure>

<p>​	一致代码段（又名共享段）的理解：这个代码段是提供一些功能让应用层直接可以访问而不破坏内核的代码，就用一致代码段来修饰。</p>
<p>​	反之不想应用层访问，就用非一致代码段修饰。</p>
</li>
<li><p>加载段描述符</p>
<p>​	通过上面的权限检查后，CPU会将0x20段选择子对应的段描述符加载到CS段寄存器中</p>
</li>
<li><p>代码执行</p>
<p>​	CPU将CS.Base+Offset的值写入EIP，然后执行CS:EIP处的代码，段间跳转结束</p>
</li>
</ol>
<h4 id="【总结】"><a href="#【总结】" class="headerlink" title="【总结】"></a>【总结】</h4><p>对于<strong>一致代码段</strong>，也就是共享的段</p>
<ul>
<li>特权级高的程序不允许访问特权级低的数据：核心态不允许访问用户态的数据</li>
<li>特权级低的程序可以访问到特权级高的数据，但特权级不会改变：用户态还是用户态</li>
</ul>
<p>对于普通代码段，也就是<strong>非一致代码段</strong></p>
<ul>
<li>只允许同级访问</li>
<li>绝对禁止不同级别的访问：核心态不能访问用户态，用户态不能访问核心态。</li>
</ul>
<p>直接对代码段进行JMP或者CALL的操作，无论目标是一致代码段还是非一致代码段，CPL都不会发生改变。如果要提升CPL的权限，只能通过<strong>调用门</strong>。</p>
<h4 id="【最终总结】"><a href="#【最终总结】" class="headerlink" title="【最终总结】"></a>【最终总结】</h4><ol>
<li>为了对数据进行保护，普通代码段是禁止不同级别进行访问的。用户态的代码不能访问内核的数据，同样，内核态的代码也不能访问用户态的数据。</li>
<li>如果想提供一些通用的功能，而且这些功能并不会破坏内核数据，那么可以选择一致代码段，这些低级别的程序可以在不提升CPL权限等级的情况下既可以访问。</li>
<li>如果想访问普通代码段，只有通过“调用门”等提升CPL权限，才能访问。</li>
</ol>
<h4 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210803172413552.png" alt="image-20210803172413552"></p>
<p>黄标表示如何查找gdt表。</p>
<p>eq表示往某地址写入某内存。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210803202153149.png" alt="image-20210803202153149"></p>
<p>虚拟机中xp系统中的OD进行测试</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210803202642190.png" alt="image-20210803202642190"></p>
<p>004B表示段选择子，index为9(二进制1001)，索引的段寄存器正是上上图黄标位置的段描述符。</p>
<p>单步执行看是否可以跳转到44E082地址</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210803203101666.png" alt="image-20210803203101666"></p>
<p>成功跳转。</p>
<p>将段描述符的RPL修改为0环。此时预测权限验证应该会失败。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210803203453670.png" alt="image-20210803203453670"></p>
<p>修改后，再次尝试跳转</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210803203741984.png" alt="image-20210803203741984"></p>
<p>单步执行</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210803204001574.png" alt="image-20210803204001574"></p>
<p>按shift+F7</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210803204042928.png" alt="image-20210803204042928"></p>
<p>进入ntdll了，即进入异常模块了。和预期的结果一致，权限验证失败。</p>
<p>将对应段描述符修改为一致代码段</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210803204413648.png" alt="image-20210803204413648"></p>
<p>od中执行同一条指令：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210803204541096.png" alt="image-20210803204541096"></p>
<p>单步执行</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210803204617396.png" alt="image-20210803204617396"></p>
<p>成功跳转，一句话总结实验：<strong>低权限(CPL&#x3D;3)代码段用零环的权限(RPL&#x3D;0)访问低权限代码段(DPL&#x3D;3)成功</strong>，因为是一致代码段</p>
<blockquote>
<p>如果是非一致代码段，要求：CPL &#x3D;&#x3D; DPL 并且 RPL &lt;&#x3D; DPL<br>如果是一致代码段，要求：CPL &gt;&#x3D; DPL</p>
</blockquote>
<h2 id="长调用与短调用"><a href="#长调用与短调用" class="headerlink" title="长调用与短调用"></a>长调用与短调用</h2><p>我们通过JMP FAR可以实现段间的跳转，如果要实现跨段的调用就必须要学习CALL FAR，也就是长调用。</p>
<p>CALL FAR比JMP FAR要复杂，JMP并不影响堆栈，但CALL指令会影响堆栈，所以长调用比长跳转要复杂。</p>
<h3 id="短调用"><a href="#短调用" class="headerlink" title="短调用"></a>短调用</h3><p>指令格式：CALL 立即数&#x2F;寄存器&#x2F;内存</p>
<p>短CALL是push了一个返回地址，EIP修改为调用位置。</p>
<p>发生改变的寄存器：ESP和EIP。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210804140440130.png" alt="image-20210804140440130"></p>
<h3 id="长调用-跨段不提权"><a href="#长调用-跨段不提权" class="headerlink" title="长调用(跨段不提权)"></a>长调用(跨段不提权)</h3><p>指令格式：CALL CS:EIP(EIP是废弃的)</p>
<p>【注意】：长调用的调用地址并不是由EIP决定的，而是<strong>通过CS段选择子找到段描述符(该段描述符必须是一个调用门)算出来的</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210804140726695.png" alt="image-20210804140726695"></p>
<p>发生改变的寄存器：ESP EIP CS</p>
<p>通过长调用执行完代码后是通过长返回<strong>RETF</strong>返回。返回的时候，会将上图红色的调用者CS重新赋值给CS段寄存器</p>
<h3 id="长调用-跨段并提权"><a href="#长调用-跨段并提权" class="headerlink" title="长调用(跨段并提权)"></a>长调用(跨段并提权)</h3><p>指令格式：CALL CS:EIP(EIP是废弃的)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210804141821855.png" alt="image-20210804141821855"></p>
<p>ESP3表示当前执行的权限为3环。堆栈发生了切换，<strong>右边的堆栈已经不是左边的堆栈了，而是一个零环的堆栈了</strong>。</p>
<p>发生改变的寄存器：ESP EIP CS SS</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210804142949147.png" alt="image-20210804142949147"></p>
<h3 id="【总结】-1"><a href="#【总结】-1" class="headerlink" title="【总结】"></a>【总结】</h3><ol>
<li>跨段调用时，一旦有权限切换，就会切换堆栈</li>
<li>CS的权限一旦改变，SS的权限也要随着改变，CS与SS的等级必须一样</li>
<li>JMP FAR只能跳转到同级非一致代码段，但CALL FAR可以通过调用门提权，提升CPL的权限。</li>
</ol>
<p>SS与ESP从哪里来？参见TSS段。</p>
<h2 id="调用门"><a href="#调用门" class="headerlink" title="调用门"></a>调用门</h2><p>调用门执行六项功能：</p>
<ol>
<li>它指定要访问的代码段。</li>
<li>它为指定代码段中的过程定义了一个入口点。</li>
<li>它指定尝试访问过程的调用者所需的权限级别。</li>
<li>如果发生堆栈切换，则指定要在堆栈之间复制的可选参数的数量。</li>
<li>它定义了要推送到目标堆栈上的值的大小：16 位门强制 16 位推送，32 位门强制 32 位推送。</li>
<li>它指定调用门描述符是否有效。</li>
</ol>
<h3 id="调用门-无参"><a href="#调用门-无参" class="headerlink" title="调用门(无参)"></a>调用门(无参)</h3><p>调用门最大的好处就是提权，但提权的方式不仅仅是调用门</p>
<h4 id="门描述符的结构"><a href="#门描述符的结构" class="headerlink" title="门描述符的结构"></a>门描述符的结构</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/196406-20191230101816343-1359964647.png" alt="196406-20191230101816343-1359964647"></p>
<p>门描述符是系统段描述符的一类，所以S字段必须是0，type域为1100表示调用门。</p>
<p><strong>调用门中存储了另一个代码段段的选择子</strong>指的就是上图<code>段选择符</code>字段</p>
<p><strong>【重点】调用门真正要调用的地址：</strong><code>段选择符</code>中存的段选择子指向的那个段描述符中的base  +  上图中的两段<code>段中偏移值</code>拼接而成的值</p>
<p>不同门的TYPE：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/196406-20191230101855524-2036155359.png" alt="196406-20191230101855524-2036155359"></p>
<h4 id="调用门指令流程"><a href="#调用门指令流程" class="headerlink" title="调用门指令流程"></a>调用门指令流程</h4><p>为了访问调用门，在 CALL 或 JMP 指令中提供了一个指向该门的远指针作为目标操作数。来自该指针的段选择器标识了调用门（JMP还未亲自实验过）；指针的偏移量(下面的EIP)是必需的，但不被处理器使用或检查。（偏移量可以设置为任何值。）</p>
<p>指令格式：JMP&#x2F;CALL CS:EIP(EIP是废弃的)</p>
<p>执行步骤：</p>
<ol>
<li>根据CS的值查GDT表，找到对应的段描述符，这个描述符是一个调用门。</li>
<li>在调用门描述符中存储另一个代码段段的选择子</li>
<li>选择子指向的段   段.Base+偏移地址  就是真正要执行的地址。</li>
</ol>
<h5 id="【重点】调用门权限相关"><a href="#【重点】调用门权限相关" class="headerlink" title="【重点】调用门权限相关"></a>【重点】调用门权限相关</h5><p><strong>调用门的执行流程涉及到的权限</strong></p>
<ul>
<li>CPL（当前特权级别）。</li>
<li>调用门的选择器的 RPL（请求者的特权级别）。</li>
<li>调用门描述符的 DPL（描述符特权级别）。</li>
<li>目标代码段的段描述符的 DPL。</li>
</ul>
<p><strong>权限检查规则在 CALL 和 JMP 指令之间有所不同</strong>，如下表所示。</p>
<table>
<thead>
<tr>
<th><strong>指令</strong></th>
<th><strong>特权检查规则</strong></th>
</tr>
</thead>
<tbody><tr>
<td>CALL</td>
<td>CPL ≤ 调用门 DPL；RPL ≤ 调用门 DPL目标一致代码段 DPL ≤ CPL 目标非一致代码段 DPL ≤ CPL</td>
</tr>
<tr>
<td>JMP</td>
<td>CPL ≤ 调用门 DPL；RPL ≤ 调用门 DPL目标一致代码段 DPL ≤ CPL 目标非一致代码段 DPL &#x3D; CPL</td>
</tr>
</tbody></table>
<p>上图说明，<strong>只有 CALL 指令可以使用调用门将程序控制转移到更高特权（数字特权级别更低）的非一致性代码段</strong></p>
<ul>
<li>如果调用更高特权（数字特权级别更低）的非一致目标代码段，则 CPL 将降低到目标代码段的 DPL 并发生堆栈切换。</li>
<li>如果调用或跳转到更高特权的一致目标代码段，则 CPL 不会更改，也不会发生堆栈切换。</li>
</ul>
<h4 id="实验-1"><a href="#实验-1" class="headerlink" title="实验"></a>实验</h4><p><strong>windows内并没有使用调用门</strong>。</p>
<p>所以自己构造一个调用门（无参，提权）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210804145505767.png" alt="image-20210804145505767"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//x部分表示还不确定的部分。</span></span><br><span class="line">高<span class="number">32</span>位：xxxx xxxx xxxx xxxx <span class="number">1</span>(P) <span class="number">11</span>(DPL) <span class="number">0</span> <span class="number">1100</span> <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line"><span class="comment">//p为1表示该段描述符有效，DPL为11表示三环，否则三环测试连敲门的权限都没有了。</span></span><br><span class="line">高<span class="number">32</span>位<span class="number">16</span>进制：XXXXEC00</span><br><span class="line">    </span><br><span class="line">低<span class="number">32</span>位：(xxxx xxxx xxxx xxxx) (xxxx xxxx xxxx xxxx)</span><br><span class="line"><span class="comment">//段选择符指向的段描述符如果是比当前CPL小的DPL的则表示要提权，否则表示无需提权。</span></span><br><span class="line">低<span class="number">32</span>位<span class="number">16</span>进制：XXXXXXXX</span><br></pre></td></tr></table></figure>

<p>查看段描述符</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210804163643397.png" alt="image-20210804163643397"></p>
<p>尝试用调用门调用上图黄标的段描述符的零环权限来<strong>提权</strong>。</p>
<p>所以构造的调用门低32位16进制为：0008XXXX(index为1，指向的正是上图黄标段描述符)</p>
<p>虚拟机上的xp系统上执行如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __declspec(naked) <span class="built_in">GetRegister</span>()</span><br><span class="line">&#123;</span><br><span class="line">	_asm</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> <span class="number">3</span><span class="comment">//断点，由于是通过调用门提权为零环，该代码段和内核同权限，所以会断到windbg中，而不是断在IDE。</span></span><br><span class="line">		retf</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> buff[<span class="number">6</span>];<span class="comment">//下断点！！！！！！！！！！！！！！！！！！！！！</span></span><br><span class="line">	*(DWORD*)&amp;buff[<span class="number">0</span>]=<span class="number">0x12345678</span>;<span class="comment">//随便输入</span></span><br><span class="line">	*(WORD*)&amp;buff[<span class="number">4</span>]=<span class="number">0x48</span>;<span class="comment">//段选择子，0x48对应的段描述符为空，所以用此位置装手动添加的调用门段描述符</span></span><br><span class="line">	_asm</span><br><span class="line">	&#123;</span><br><span class="line">		call fword ptr[buff]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码的<code>下断点！！！！！！！！！！！！！！！！！！！！！</code>处下断点。然后执行代码断到此处断点，进入反汇编找到GetRegister裸函数的函数地址。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210804170022297.png" alt="image-20210804170022297"></p>
<p>上图黄标可知跳转目标地址为00401010</p>
<p>所以构造的调用门段描述符为0040EC00&#96;00081010</p>
<p>windbg下断点，修改gdt中0x48段选择子对应的位置内容为0040EC00&#96;00081010</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210804170558502.png" alt="image-20210804170558502"></p>
<p>执行call fword ptr[buff]代码前的寄存器情况：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210804170729597.png" alt="image-20210804170729597"></p>
<p>执行call fword ptr[buff]代码后，成功跳转了GetRegister裸函数代码中的int 3，所以windbg断了下来。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210804170914485.png" alt="image-20210804170914485"></p>
<p>在00401010地址处因为int 3断了下来。</p>
<p><code>发现寄存器窗口为空，查明是有bug</code>，<a target="_blank" rel="noopener" href="https://blog.csdn.net/forchoosen/article/details/107074378">解决方案</a>（参考命令：!WingDbg.regfix）</p>
<p>此时windbg断下，查看windbg的寄存器显示（与执行call fword ptr[buff]前的寄存器比较）：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210804181052839.png" alt="image-20210804181052839"></p>
<p>对应颜色画笔标记为修改了的部分，其中ESP从0012FF28修改为B2B69DD0，直接从低2G空间跳转到高2G内核空间。CS变为8是因为我们在调用门描述符中设置为跳转到08段选择子对应的段描述符。</p>
<p>有部分其他寄存器也被改了，原因是系统底层代码写死了的部分修改，另外还有int 3的干扰。</p>
<p>windbg此时查看B2B69DD0处堆栈</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210804181623445.png" alt="image-20210804181623445"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210804181720817.png" alt="image-20210804181720817"></p>
<p>到此已验证完毕！</p>
<p>将代码修改为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line">BYTE GDT[<span class="number">6</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">DWORD dwH2GValue;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __declspec(naked) <span class="built_in">GetRegister</span>()</span><br><span class="line">&#123;</span><br><span class="line">	_asm</span><br><span class="line">	&#123;</span><br><span class="line">         <span class="comment">//此代码段的代码有内核权限,可以直接访问高2G内存空间。</span></span><br><span class="line">		pushad</span><br><span class="line">         pushfd</span><br><span class="line">            </span><br><span class="line">         mov eax,<span class="number">0x8003f00c</span><span class="comment">//读取高2G内存</span></span><br><span class="line">         mov ebx,[eax]</span><br><span class="line">         mov dwH2GValue,ebx</span><br><span class="line">         sgdt GDT;<span class="comment">//sdgt指令的含义为读取gdtr寄存器(读取出6个字节的数据,两个字节的limit和4个字节的GDT起始地址)(该指令在三环也能使用)</span></span><br><span class="line">         </span><br><span class="line">         popfd</span><br><span class="line">         popad</span><br><span class="line">		retf<span class="comment">//注意长返回</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> buff[<span class="number">6</span>];<span class="comment">//下断点！！！！！！！！！！！！！！！！！！！！！</span></span><br><span class="line">	*(DWORD*)&amp;buff[<span class="number">0</span>]=<span class="number">0x12345678</span>;<span class="comment">//随便输入</span></span><br><span class="line">	*(WORD*)&amp;buff[<span class="number">4</span>]=<span class="number">0x48</span>;<span class="comment">//段选择子，0x48对应的段描述符为空，所以用此位置装手动添加的调用门段描述符</span></span><br><span class="line">	_asm</span><br><span class="line">	&#123;</span><br><span class="line">		call fword ptr[buff]</span><br><span class="line">	&#125;</span><br><span class="line">    DWORD GDT_BASE=*(PDWORD)(&amp;GDT[<span class="number">2</span>]);<span class="comment">//GDT表的地址</span></span><br><span class="line">    WORD GDT_LIMIT=*(PDWORD)(&amp;GDT[<span class="number">0</span>]);<span class="comment">//GDT表有多长</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x %x %x\n&quot;</span>,dwH2GValue,GDT_BASE,GDT_LIMIT);</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于代码修改了，所以GetRegister函数的首地址也修改了，因此要修改调用门段描述符的段中偏移值。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210804183542660.png" alt="image-20210804183542660"></p>
<p>构造的调用门段描述符为0040EC00&#96;00081020</p>
<p>修改：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210804183704599.png" alt="image-20210804183704599"></p>
<p>执行代码，不能用单步执行的方式执行，而是直接不断点按F5</p>
<p>结果如图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210804201255485.png" alt="image-20210804201255485"></p>
<p>实验成功，提权成功！</p>
<h3 id="调用门-有参"><a href="#调用门-有参" class="headerlink" title="调用门(有参)"></a>调用门(有参)</h3><p>调用门有权限切换时堆栈变化：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210807195216123.png" alt="image-20210807195216123"></p>
<p>R3堆栈的参数1,2,3需要手动push，如果没有手动push，则R3堆栈不存在参数1,2,3。R0堆栈的参数1,2,3取决于调用门描述符中的参数个数，没有手动push的话，R0堆栈的参数1,2,3均为0。</p>
<h4 id="实验-2"><a href="#实验-2" class="headerlink" title="实验"></a>实验</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DWORD x;<span class="comment">//用来存传入的参数1</span></span><br><span class="line">DWORD y;<span class="comment">//参数2</span></span><br><span class="line">DWORD z;<span class="comment">//参数3</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __declspec(naked) <span class="built_in">CateProc</span>()</span><br><span class="line">&#123;</span><br><span class="line">	_asm</span><br><span class="line">    &#123;</span><br><span class="line">        pushad</span><br><span class="line">        pushfd</span><br><span class="line">        mov eax,[esp<span class="number">+0x24</span><span class="number">+0x8</span><span class="number">+0x8</span>]<span class="comment">//读参数赋值给x,y,z</span></span><br><span class="line">        mov dword ptr ds:[x],eax</span><br><span class="line">        mov eax,[esp<span class="number">+0x24</span><span class="number">+0x8</span><span class="number">+0x4</span>]</span><br><span class="line">        mov dword ptr ds:[y],eax</span><br><span class="line">        mov eax,[esp<span class="number">+0x24</span><span class="number">+0x8</span>]</span><br><span class="line">        mov dword ptr ds:[z],eax</span><br><span class="line">        popfd</span><br><span class="line">        popad</span><br><span class="line">     	retf <span class="number">0xC</span> <span class="comment">//注意堆栈平衡，写错直接蓝屏。三个参数，所以为参数平栈为0xC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> buff[<span class="number">6</span>];</span><br><span class="line">    *(DWORD*)&amp;buff[<span class="number">0</span>]=<span class="number">0x12345678</span>;<span class="comment">//断点！！！！！！！！！！！！！！！</span></span><br><span class="line">    *(WORD*)&amp;buff[<span class="number">4</span>]=<span class="number">0x48</span>;</span><br><span class="line">    _asm</span><br><span class="line">    &#123;</span><br><span class="line">         push <span class="number">1</span></span><br><span class="line">         push <span class="number">2</span></span><br><span class="line">         push <span class="number">3</span></span><br><span class="line">		call fword ptr[buff]</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%x,%x,%x\n&quot;</span>,x,y,z);</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>断点！！！！！！！！！！！！！！！</code>处断点，查看断点处地址</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210804230009598.png" alt="image-20210804230009598"></p>
<p>构造调用门段描述符为0040EC03&#96;00081020(3表示3个参数)</p>
<p>修改gdt第10个段描述符：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210804230204980.png" alt="image-20210804230204980"></p>
<p>修改后F5执行</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210804230311195.png" alt="image-20210804230311195"></p>
<p>CateProc函数头加个int 3，来查看一下堆栈情况。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210804230456028.png" alt="image-20210804230456028"></p>
<p>地址未变，段描述符不需要改，直接执行，windbg执行到int 3断下</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210804230842907.png" alt="image-20210804230842907"></p>
<p>此时windbg中查看堆栈情况：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210804231548046.png" alt="image-20210804231548046"></p>
<p>int 3断下时候的堆栈结构</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210804232559040.png" alt="image-20210804232559040"></p>
<p>pushad和pushfd后的堆栈结构（参数此时的相对ESP位置结构）：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210804232907329.png" alt="image-20210804232907329"></p>
<h4 id="【总结】-2"><a href="#【总结】-2" class="headerlink" title="【总结】"></a>【总结】</h4><ol>
<li>当通过门，<strong>权限不变的时候，只会PUSH两个值：CS和返回地址</strong>。新的CS的值由调用门决定。</li>
<li>当通过门，权限改变的时候，会PUSH四个值，<code>SS,ESP,CS,返回地址</code>，新的CS的值由调用门决定，<strong>新的SS和ESP由TSS提供</strong>。</li>
<li>通过门调用时，要执行哪行代码由调用门决定，但使用RETF返回时，由堆栈中压入的值决定，这就是说，<strong>进门时只能按照指定路线走，出门时可以翻墙</strong>（只要改变堆栈里面的值就可以想去哪去哪）</li>
<li>可不可以再建个门出去呢？当然可以了，前门进，后门出</li>
</ol>
<h2 id="中断门"><a href="#中断门" class="headerlink" title="中断门"></a>中断门</h2><p>Windows没有使用调用门，但是使用了中断门。</p>
<p>windows系统使用了中断门的两种情况：</p>
<ol>
<li>[[系统调用]]（老cpu使用中断门，新cpu已经不使用中断门了，而是使用快速调用）</li>
<li>调试（软件断点int 3就是用来执行中断门的）</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210806163434767.png" alt="image-20210806163434767"></p>
<ul>
<li>键盘鼠标显示器等外部设备都是可屏蔽中断</li>
<li>电源等是不可屏蔽中断，无法操作。</li>
<li>现在的中断大多都是用的APIC实现，APIC编程强一些。</li>
</ul>
<p>执行调用门的指令：CALL CS:EIP</p>
<p>但当CPU 执行如下指令：INT N（int 0表示0号中断；int 1表示1号中断…）</p>
<p>查询的却是另一张表，这张表叫IDT</p>
<h3 id="中断指令"><a href="#中断指令" class="headerlink" title="中断指令"></a>中断指令</h3><p>$$<br>INT\ N<br>$$</p>
<p>其中，N是索引，X*8+IDT的基址 就是具体的中断门描述符</p>
<p>保护模式下的中断和异常表解释</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/2018121811050612.png" alt="2018121811050612"></p>
<p>终止就是蓝屏</p>
<h3 id="中断门的堆栈和返回"><a href="#中断门的堆栈和返回" class="headerlink" title="中断门的堆栈和返回"></a>中断门的堆栈和返回</h3><ol>
<li>在没有权限切换时，会向堆栈PUSH3个值，分别是：<strong>CS EFLAG EIP(返回地址)</strong></li>
<li>在有权限切换时，会向堆栈PUSH5个值，分别是：<strong>SS ESP EFLAGS CS EIP(返回地址)</strong></li>
</ol>
<p>在中断门中，不能通过RETF返回(其实也可以)，而应该通过<strong>IRET&#x2F;IRETD</strong>指令返回。IRET是16位，而IRETD是32位</p>
<p>裸函数的话必须写IRETD，部分IDE会自动根据D&#x2F;B位在IRET&#x2F;IRETD中变换。</p>
<h3 id="IDT"><a href="#IDT" class="headerlink" title="IDT"></a>IDT</h3><p>IDT即<strong>中断描述符表</strong>，<em>结构同GDT一样</em>，IDT也是由一系列描述符组成的，每个描述符占8个字节。但要注意的是，<strong>IDT表中的第一个元素不是NULL</strong>。</p>
<p>IDT表中存的中断描述符按照中断编号从0号开始排序下去。</p>
<p>在Windbg中查看IDT表的基址和长度：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210806113112935.png" alt="image-20210806113112935"></p>
<h4 id="IDT表的构成"><a href="#IDT表的构成" class="headerlink" title="IDT表的构成"></a>IDT表的构成</h4><p>IDT表可以包含3种门描述符</p>
<ol>
<li>任务门描述符</li>
<li>中断门描述符</li>
<li>陷阱门描述符</li>
</ol>
<h3 id="中断门描述符"><a href="#中断门描述符" class="headerlink" title="中断门描述符"></a>中断门描述符</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210607203904224.png" alt="image-20210607203904224"></p>
<p>高4字节的0~4位固定为0。</p>
<p>64进制中断门描述符表示：XXXXEE00&#96;XXXXXXXX</p>
<h4 id="中断门提权实验"><a href="#中断门提权实验" class="headerlink" title="中断门提权实验"></a>中断门提权实验</h4><p>参考流程图</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210806171727490.png" alt="image-20210806171727490"></p>
<p><strong>提权与否取决于：中断门描述符的段选择子指向的段描述符的DPL</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/20181213133543199.png" alt="20181213133543199"></p>
<p>实验：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __declspec(naked) <span class="built_in">test</span>()</span><br><span class="line">&#123;</span><br><span class="line">	_asm</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="number">3</span></span><br><span class="line">        iretd<span class="comment">//中断门要用这个返回。如果不是裸函数的话写iret也可以，因为IDE会根据D/B位调成iretd</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _asm</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//32是后续知道idt的空位后回来补上的。IDT表中的第33个中断描述符(编号从0开始)</span></span><br><span class="line">        <span class="type">int</span> <span class="number">32</span>;<span class="comment">//断点！！！！！！！！！！！！！！</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>断点！！！！！！！！！！！！！！</code>处断下反汇编查看test的函数地址。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210806194755824.png" alt="image-20210806194755824"></p>
<p>在IDT中找空的位置构造中断门描述符（空位如下图）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210806195008729.png" alt="image-20210806195008729"></p>
<p>构造的中断门描述符：0040EE00&#96;00081020</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210806195231834.png" alt="image-20210806195231834"></p>
<p>中断门的段选择子0x0008指向的是DPL为0的内核代码段。</p>
<p>int32之前的堆栈情况：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210806195925841.png" alt="image-20210806195925841"></p>
<p>断到int3上：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210806200039623.png" alt="image-20210806200039623"></p>
<p>查看寄存器变化：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210806200514018.png" alt="image-20210806200514018"></p>
<p>有部分其他寄存器也被改了，原因是系统底层代码写死了的部分修改，另外还有int 3的干扰。</p>
<p>查看堆栈：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210806201413231.png" alt="image-20210806201413231"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210806202256635.png" alt="image-20210806202256635"></p>
<p>调用中断门的R3堆栈没有变化。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210811145502207.png" alt="image-20210811145502207"></p>
<h4 id="调用门与中断门的区别"><a href="#调用门与中断门的区别" class="headerlink" title="调用门与中断门的区别"></a>调用门与中断门的区别</h4><ol>
<li>调用门通过CALL FAR指令执行，但中断门通过INT指令</li>
<li>调用门查询GDT表，中断门查询IDT表</li>
<li>CALL CS:EIP中的CS是段选择子，由3部分组成。但INT N指令中的N只是索引，中断门不检查RPL，只检查CPL</li>
<li>调用门可以有参数，但中断门没有参数</li>
</ol>
<h4 id="【重点理解】各种返回加深理解"><a href="#【重点理解】各种返回加深理解" class="headerlink" title="【重点理解】各种返回加深理解"></a>【重点理解】各种返回加深理解</h4><p>iret可以理解为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pop eip</span><br><span class="line">pop cs</span><br><span class="line">popfd</span><br></pre></td></tr></table></figure>

<p>各种返回</p>
<ul>
<li>RET 及其同义词 RETN，从堆栈中弹出 IP 或 EIP(返回地址) 并将控制权转移到新地址。可选的，如果提供了数字二的操作数，它们会在弹出返回地址后将堆栈指针再增加 imm16(16位即两个字节) 字节。</li>
<li>RETF 执行远返回：在弹出 IP&#x2F;EIP(返回地址)后，它会弹出 CS，然后通过可选参数（如果存在）递增堆栈指针，如果返回到另一个特权级别，IRET指令还会在恢复程序执行之前从堆栈中弹出SP(或ESP)和SS，最后将参数计数（以从 RETF  指令获得的字节数）添加到当前 ESP&#x2F;SP 寄存器值。</li>
<li>IRETW 将 IP、CS 和flags弹出为 每个2 个字节，总共从堆栈中取出 6 个字节，如果返回到另一个特权级别，IRET指令还会在恢复程序执行之前从堆栈中弹出SP和SS。</li>
<li>IRETD 将 EIP 弹出为 4 个字节(返回地址)。再弹出 4 个字节，其中前两个被丢弃，后两个进入 CS，并将eflags也弹出为 4 个字节，从堆栈中取出 12 个字节，如果返回到另一个特权级别，IRET指令还会在恢复程序执行之前从堆栈中弹出ESP和SS。</li>
<li><strong>IRET 是 IRETW 或 IRETD 的简写，具体取决于当时的默认 BITS 设置。</strong></li>
</ul>
<h5 id="【实验】在调用门中实现使用IRETD返回，在中断门中实现用RETF返回"><a href="#【实验】在调用门中实现使用IRETD返回，在中断门中实现用RETF返回" class="headerlink" title="【实验】在调用门中实现使用IRETD返回，在中断门中实现用RETF返回"></a><strong>【实验】</strong>在调用门中实现使用IRETD返回，在中断门中实现用RETF返回</h5><h6 id="中断门用RETF返回"><a href="#中断门用RETF返回" class="headerlink" title="中断门用RETF返回"></a>中断门用RETF返回</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&quot;stdafx.h&quot;</span><br><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line"></span><br><span class="line">void __declspec(naked) test()</span><br><span class="line">&#123;</span><br><span class="line">	_asm</span><br><span class="line">    &#123;</span><br><span class="line">        RETF 0x4//中断门用RETF返回（反其道行之）</span><br><span class="line">		</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;%x&quot;,&amp;test);</span><br><span class="line">	getchar();</span><br><span class="line">    _asm</span><br><span class="line">    &#123;</span><br><span class="line">        int 32;//32编号对应位置的中断门段描述符为0040ee00`0008100f</span><br><span class="line">		sub esp,4//因为RETF在返回后还会再add ESP，4（根据RETF 0x4）</span><br><span class="line">    &#125;</span><br><span class="line">    getchar();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="调用门用iretd-返回"><a href="#调用门用iretd-返回" class="headerlink" title="调用门用iretd 返回"></a>调用门用iretd 返回</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> __declspec(naked) <span class="built_in">test</span>()</span><br><span class="line">&#123;</span><br><span class="line">	_asm</span><br><span class="line">    &#123;</span><br><span class="line">        iretd<span class="comment">//调用门用iretd返回（反其道行之）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> buff[<span class="number">6</span>]=&#123;<span class="number">0x78</span>,<span class="number">0x56</span>,<span class="number">0x34</span>,<span class="number">0x12</span>,<span class="number">0x48</span>,<span class="number">0</span>&#125;;<span class="comment">//指向的调用门描述符为0040EC01`0008100F</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%x&quot;</span>,&amp;test);</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">    _asm</span><br><span class="line">    &#123;</span><br><span class="line">        call fword ptr[buff];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="陷阱门"><a href="#陷阱门" class="headerlink" title="陷阱门"></a>陷阱门</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210808163723779.png" alt="image-20210808163723779"></p>
<p>陷阱门段描述符：XXXXEF00&#96;XXXXXXXX</p>
<p><strong>陷阱门与中断门几乎一样</strong>，陷阱门与中断门唯一的区别：</p>
<p>中断门执行时，会将<strong>IF</strong>位清零，但陷阱门不会。</p>
<p>IF位：eflags下标为9的位置。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/1342712354_1402.jpg" alt="1342712354_1402"></p>
<p><strong>IF的含义：</strong></p>
<p>IF标志用于控制处理器对可屏蔽中断请求的响应。置1以响应可屏蔽中断，反之则禁止可屏蔽中断。</p>
<ul>
<li>IF&#x3D;0	CPU不再接受可屏蔽中断</li>
<li>IF&#x3D;1	CPU接受可屏蔽中断</li>
</ul>
<p><code>p.s.不可屏蔽中断不受IF位影响，比如说断电，就是电源通过电源管理器向CPU发送一个请求，这就是一个不可屏蔽中断。(CPU有电容，即使是断电了也能跑一会儿，执行一些清理工作)</code></p>
<p><strong>通过中断门与陷阱门打印EFLAG寄存器的值</strong></p>
<ul>
<li>执行前：216</li>
<li>执行中<ol>
<li>陷阱门：216</li>
<li>中断门：16</li>
</ol>
</li>
</ul>
<h2 id="任务段TSS-难点非重点"><a href="#任务段TSS-难点非重点" class="headerlink" title="任务段TSS(难点非重点)"></a>任务段TSS(难点非重点)</h2><p>在调用门，中断门与陷阱门中，一旦出现权限切换，那么就会有堆栈的切换。而且，由于CS的CPL发生改变，也导致了SS也必须要切换。(CS和SS的权限级别永远都是一致的)</p>
<p>切换时，会有新的ESP和SS（CS是由中断门或者调用门指定）这2个值从哪里来的呢？</p>
<p>答案：<strong>TSS</strong>（Task-state segment），任务状态段。</p>
<h3 id="TSS和TR寄存器"><a href="#TSS和TR寄存器" class="headerlink" title="TSS和TR寄存器"></a>TSS和TR寄存器</h3><p>一块<strong>大于等于104字节</strong>的内存结构。（强调：不在CPU中，就是内存中）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/196406-20200102102107308-1624147754.png" alt="196406-20200102102107308-1624147754"></p>
<p>I&#x2F;O权限位图：I&#x2F;O Map Base Address（没什么用，和硬件是相关的）</p>
<p>CR3：页目录基地址寄存器CR3（PDBR）</p>
<p> 指向前一个任务段（TSS）的链接（<strong>如果不为空的话，存的是前一个TSS段的段选择子</strong>）：Previous Task Link</p>
<p>LDT Segment Selector：LDT段选择子,会加载到LDTR寄存器中。</p>
<p>tss中的ss0,ss1,ss2修改是没用的，即使修改了，也会变回去，因为是系统填写的。</p>
<p>一个TSS对应一个LDT表。LDTR描述的是LDT表的地址和大小。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/48588_1282618334lclL.jpg" alt="48588_1282618334lclL"></p>
<p>LDT和GDT从本质上说是相同的，只是LDT嵌套在GDT之中。LDTR记录局部描述符表的起始位置，<strong>与GDTR不同LDTR的内容是一个段选择子</strong>。由于LDT本身同样是一段内存，也是一个段，所以它也有个描述符描述它，这个描述符就存储在GDT中，对应这个描述符也会有一个选择子，LDTR装载的就是这样一个选择子。LDTR可以在程序中随时改变，通过使用lldt指令。如上图，如果装载的是Selector 2则LDTR指向的是表LDT2。</p>
<p>LDT描述符</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210813135407001.png" alt="image-20210813135407001"></p>
<p>windows 32位以后实际上没有使用LDT。因为用不着这么多段了</p>
<p>更多关于LDT的内容可以<a target="_blank" rel="noopener" href="http://www.techbulo.com/708.html">参考此处</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">nt!_KTSS</span><br><span class="line"><span class="number">+0x000</span> Backlink : Uint2B</span><br><span class="line"><span class="number">+0x002</span> Reserved0 : Uint2B</span><br><span class="line"><span class="number">+0x004</span> Esp0 : Uint4B</span><br><span class="line"><span class="number">+0x008</span> Ss0 : Uint2B</span><br><span class="line"><span class="number">+0x00a</span> Reserved1 : Uint2B</span><br><span class="line"><span class="number">+0x00c</span> NotUsed1 : [<span class="number">4</span>] Uint4B</span><br><span class="line"><span class="number">+0x01c</span> CR3 : Uint4B<span class="comment">//重点寄存器CR3，后续会讲</span></span><br><span class="line"><span class="number">+0x020</span> Eip : Uint4B</span><br><span class="line"><span class="number">+0x024</span> EFlags : Uint4B</span><br><span class="line"><span class="number">+0x028</span> Eax : Uint4B</span><br><span class="line"><span class="number">+0x02c</span> Ecx : Uint4B</span><br><span class="line"><span class="number">+0x030</span> Edx : Uint4B</span><br><span class="line"><span class="number">+0x034</span> Ebx : Uint4B</span><br><span class="line"><span class="number">+0x038</span> Esp : Uint4B</span><br><span class="line"><span class="number">+0x03c</span> Ebp : Uint4B</span><br><span class="line"><span class="number">+0x040</span> Esi : Uint4B</span><br><span class="line"><span class="number">+0x044</span> Edi : Uint4B</span><br><span class="line"><span class="number">+0x048</span> Es : Uint2B</span><br><span class="line"><span class="number">+0x04a</span> Reserved2 : Uint2B</span><br><span class="line"><span class="number">+0x04c</span> Cs : Uint2B</span><br><span class="line"><span class="number">+0x04e</span> Reserved3 : Uint2B</span><br><span class="line"><span class="number">+0x050</span> Ss : Uint2B</span><br><span class="line"><span class="number">+0x052</span> Reserved4 : Uint2B</span><br><span class="line"><span class="number">+0x054</span> Ds : Uint2B</span><br><span class="line"><span class="number">+0x056</span> Reserved5 : Uint2B</span><br><span class="line"><span class="number">+0x058</span> Fs : Uint2B</span><br><span class="line"><span class="number">+0x05a</span> Reserved6 : Uint2B</span><br><span class="line"><span class="number">+0x05c</span> Gs : Uint2B</span><br><span class="line"><span class="number">+0x05e</span> Reserved7 : Uint2B</span><br><span class="line"><span class="number">+0x060</span> LDT : Uint2B</span><br><span class="line"><span class="number">+0x062</span> Reserved8 : Uint2B</span><br><span class="line"><span class="number">+0x064</span> Flags : Uint2B</span><br><span class="line"><span class="number">+0x066</span> IoMapBase : Uint2B</span><br><span class="line"><span class="number">+0x068</span> IoMaps : [<span class="number">1</span>] _KiIoAccessMap</span><br><span class="line"><span class="number">+0x208c</span> IntDirectionMap : [<span class="number">32</span>] UChar</span><br></pre></td></tr></table></figure>

<p> <em>TSS的地址就是TSS段描述符描述的基地址，因此我们通过 dg tr 查看其Base为 80042000。</em>对于查看TSS段，有一个单独的指令。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dg tr</span><br><span class="line">dt _KTSS <span class="number">80042000</span><span class="comment">//Base</span></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210813144727834.png" alt="image-20210813144727834"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210813144750275.png" alt="image-20210813144750275"></p>
<h4 id="TSS的作用"><a href="#TSS的作用" class="headerlink" title="TSS的作用"></a>TSS的作用</h4><p>CPU层面的<strong>任务</strong>就是系统层面上的<strong>线程</strong></p>
<p><strong>Intel CPU设计思想的初衷</strong>：TSS就是实现任务切换（操作系统中也就是线程切换，CPU中没有线程的概念）</p>
<p><strong>操作系统的设计思想</strong>：TSS的任务切换在操作系统中其实就是同时换掉”一堆“寄存器，与线程切换无关。windows和linux系统实际上只使用了ss和esp.</p>
<p>本质：<strong>不要把TSS与“线程切换“联系到一起</strong>，TSS的意义仅在于可以同时换掉”一堆“寄存器</p>
<h4 id="CPU是如何找到TSS的"><a href="#CPU是如何找到TSS的" class="headerlink" title="CPU是如何找到TSS的"></a>CPU是如何找到TSS的</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210808175145728.png" alt="image-20210808175145728"></p>
<blockquote>
<p>任务寄存器TR，16位寄存器。  其内保存的是任务状态段<strong>TSS的16位段选择子</strong>。每项任务都配有一个任务状态段TSS，用来描述该任务的运行状态。就用16位的选择子来检索任务状态段。总是将当前任务的TSS的选择符放在TR中，而TSS的描述符放在TSS描述符高速缓冲寄存器中（<strong>就是段描述符除了16位的端选择子部分的其他80位</strong>）(针对这句话一下说明)。</p>
<p>在保护方式下，选择器寄存器的D1 D0是特权标志，D2为描述符表类型标志，高13位是选择码，指出本段的描述符在由D2指出的描述符表中的逻辑排序。当一个段第一次被访问时，首先根据指令给出选择器的D2位及高13位，到内存中相应的描述符表内取出相应的描述符(64位)，送入对应的描述符高速缓冲寄存器(64位)，再从描述符中取出段基址进行逻辑到线性地址的变换。以后再访问该段时，直接从描述符寄存器(64位)中取地址信息，免去从内存中选取描述符的过程，实现加速。</p>
<p>在系统中 GDT，IDT 只有一个，所以GDTR,IDTR中存放的是该表入口地址；而任务不只一个，所以LDTR，TR存放的是当前任务的选择符。</p>
</blockquote>
<h4 id="TSS段描述符"><a href="#TSS段描述符" class="headerlink" title="TSS段描述符"></a>TSS段描述符</h4><p>TSS段描述符是系统段描述符的一种，在GDT中。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/123.png" alt="123"></p>
<p>TSS的limit以字节为单位的，所以上图高4字节的23位的G代表0，含义是limit以字节为单位。</p>
<p><strong>TYPE为1011和1001都表示TSS段描述符</strong>。</p>
<ul>
<li>1001(0x9)表示当前的TSS段描述符没有加载到TR寄存器中。</li>
<li>1011(0xB)表示已经加载了（忙碌状态）</li>
</ul>
<p><strong>加载前TYPE是0xB，加载后0x9</strong></p>
<ul>
<li>构造TSS段描述符(零环已使用)：<strong>XX008BXX&#96;XXXX0068</strong></li>
<li>构造TSS段描述符(零环未使用)：<strong>XX0089XX&#96;XXXX0068</strong></li>
<li>构造TSS段描述符(三环已使用)：<strong>XX00EBXX&#96;XXXX0068</strong></li>
<li>构造TSS段描述符(三环未使用)：<strong>XX00E9XX&#96;XXXX0068</strong>（下面实验使用这个才能成功）</li>
</ul>
<p>之前的段描述符G位都是填1，TSS段描述符填的是0，表示按字节为单位</p>
<p>TSS段描述符</p>
<h4 id="TR寄存器的读写"><a href="#TR寄存器的读写" class="headerlink" title="TR寄存器的读写"></a>TR寄存器的读写</h4><p><strong>1）将TSS段描述符加载到TR寄存器</strong></p>
<p>指令：LTR</p>
<ul>
<li>用LTR指令去装载的话，仅仅是改变TR寄存器的值(92位)，并没有真正改变TSS</li>
<li>LTR指令只能在系统层使用（ltr是特权指令，CPU权限零环）</li>
<li>加载后TSS段描述符会状态位发生改变（加载完后，TYPE会从0x9变成0xB）</li>
</ul>
<p><strong>2）读TR寄存器</strong></p>
<p>指令：STR</p>
<p>如果用STR去读的话，只读了TR的0~15位，也就是选择子。</p>
<h4 id="修改TR寄存器"><a href="#修改TR寄存器" class="headerlink" title="修改TR寄存器"></a>修改TR寄存器</h4><ol>
<li><p>在Ring0，我们可以通过LTR指令去修改TR寄存器</p>
</li>
<li><p>在Ring3，我们可以<strong>通过CALL FAR或者JMP FAR指令来修改</strong>(不但改TR寄存器，还会通过TSS改所有的寄存器)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/12313213213213.jpg" alt="12313213213213"></p>
</li>
</ol>
<ul>
<li><p>用JMP去访问一个代码段的时候，改变的是CS和EIP：</p>
<p>​		JMP 0x48:0x123456,如果0x48是代码段</p>
<p>​		执行后：CS-&gt;0x48   EIP-&gt;0x123456</p>
</li>
<li><p>用JMP去访问一个任务段的时候</p>
<p>​		如果0x48是TSS段描述符，先修改TR寄存器，<strong>再用TR.Base指向的TSS中的值修改当前的各种寄存器（TSS涉及的寄存器）</strong>。</p>
</li>
</ul>
<h4 id="CALL-FAR或者JMP-FAR一个任务段描述符的不同点（重点）"><a href="#CALL-FAR或者JMP-FAR一个任务段描述符的不同点（重点）" class="headerlink" title="CALL FAR或者JMP FAR一个任务段描述符的不同点（重点）"></a><strong>CALL FAR或者JMP FAR一个任务段描述符的不同点</strong>（重点）</h4><ol>
<li>第一个不同点在于<strong>Previous Task Link</strong><ul>
<li><strong>CALL FAR调用了TSS段之后，Previous Task Link会被填入前一个TSS段的段选择子</strong></li>
<li><strong>JMP FAR调用了TSS段之后，Previous Task Link不会被改变。</strong></li>
</ul>
</li>
<li>第二个不同点在于<strong>nt位</strong>（EFLAGS的第14位）<ul>
<li>CALL FAR调用了TSS段之后，<strong>nt位会置一</strong></li>
<li>JMP FAR调用了TSS段之后，<strong>nt位清0</strong></li>
</ul>
</li>
</ol>
<p><strong>nt位（EFLAGS的第14位）（保护模式下）的理解：</strong></p>
<ol>
<li>NT&#x3D;0时，iret为中断返回，会在<strong>堆栈中找返回值</strong>返回</li>
<li>NT&#x3D;1时，iret不是中断返回，会找<strong>TSS中的Previous Task Link</strong>返回</li>
</ol>
<p> nt位（eflags有部分位）不允许被应用程序所修改</p>
<p>注意：int也会把nt位清零（<strong>无法实验证实</strong>）。所以call的方式调用任务段跳转到代码后用int会导致蓝屏，而jmp却可以。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/20181217172756828.png" alt="20181217172756828"></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37375427/article/details/85051515">jmp call 中断详解（对理解有一定帮助）</a></p>
<h4 id="TSS段描述符实验"><a href="#TSS段描述符实验" class="headerlink" title="TSS段描述符实验"></a>TSS段描述符实验</h4><p>不管跳几环，TSS中一定要改ss，cs，fs这三个段寄存器</p>
<p>使用CALL和JMP去访问一个任务段，并能正确返回。</p>
<h5 id="CALL实验返回"><a href="#CALL实验返回" class="headerlink" title="CALL实验返回"></a>CALL实验返回</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line">DWORD dwOK;</span><br><span class="line">DWORD dwESP;</span><br><span class="line">DWORD dwCS;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __declspec(naked) <span class="built_in">test</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//dwOK = 1;</span></span><br><span class="line">	_asm</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//int 3</span></span><br><span class="line">        mov eax,esp;</span><br><span class="line">        mov dwESP,eax;</span><br><span class="line">        mov ax,cs;</span><br><span class="line">        mov word ptr[dwCS],ax;</span><br><span class="line">        iretd</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> bu[<span class="number">0x10</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> iCr3;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input CR3:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%x&quot;</span>,&amp;iCr3);<span class="comment">//通过windbg工具!process 0 0指令获取</span></span><br><span class="line">    </span><br><span class="line">    DWORD iTss[<span class="number">0x68</span>]=&#123;<span class="comment">//用栈空间构造TSS，TSS段描述符中的Base填该数组的首地址</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//link</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//esp0   也可填((DWORD)bu)-0x10，照常运行</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//ss0</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//esp1</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//ss1</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//esp2</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//ss2</span></span><br><span class="line">        (DWORD)iCr3,<span class="comment">//cr3</span></span><br><span class="line">        (DWORD)test,<span class="comment">//eip   此处要填入跳转位置的地址</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//eflags</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//eax</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//ecx</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//edx</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//ebx</span></span><br><span class="line">        ((DWORD)bu)<span class="number">-0x10</span>,<span class="comment">//esp   -0x10是因为esp是往小地址升栈的。</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//ebp</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//esi</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//edi</span></span><br><span class="line">        <span class="number">0x00000023</span>,<span class="comment">//es</span></span><br><span class="line">        <span class="number">0x00000008</span>,<span class="comment">//cs	0x1B（cs段选择子决定是否升了权限，由于0x8选择子指向的段描述符是0环权限，所以此处是提权了的）</span></span><br><span class="line">        <span class="number">0x00000010</span>,<span class="comment">//ss	0x23</span></span><br><span class="line">        <span class="number">0x00000023</span>,<span class="comment">//ds</span></span><br><span class="line">        <span class="number">0x00000030</span>,<span class="comment">//fs	0x3B</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//gs</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//ldt(如果想使用LDT的话，可以自己构造LDT使用)</span></span><br><span class="line">        <span class="number">0x20ac0000</span> <span class="comment">//I/O Map Base Address</span></span><br><span class="line">	&#125;;</span><br><span class="line">    <span class="comment">/*__asm&#123;</span></span><br><span class="line"><span class="comment">        int 0x20</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>,iTss);</span><br><span class="line">    <span class="type">char</span> buff[<span class="number">6</span>]=&#123;<span class="number">0x78</span>,<span class="number">0x56</span>,<span class="number">0x34</span>,<span class="number">0x12</span>,<span class="number">0x48</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    _asm</span><br><span class="line">    &#123;</span><br><span class="line">        call fword ptr[buff];</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ok=%d ESP=%x CS=%x \n&quot;</span>,dwOK,dwESP,dwCS);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在windbg中断下，输入!process 0 0指令，根据程序名查看CR3：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210814132256597.png" alt="image-20210814132256597"></p>
<p>g放开内核断点，控制台输入上图黄标,得到iTss的地址，长调用之前调试器断下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210814132349732.png" alt="image-20210814132349732"></p>
<p>windbg再次断下，构造TSS段描述符：0000E912&#96;FDCC0068</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210814132525309.png" alt="image-20210814132525309"></p>
<p>修改好后，确保iTss字符数组首地址不会变的时候，不下断点重新运行（否则会出现如下图的单步运行异常），填入新的CR3</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210814133359037.png" alt="image-20210814133359037"></p>
<p>p.s.单步运行异常是可以用windbg单步调试的状态，p指令单步走，r指令查看寄存器。</p>
<p>输入CR3时的寄存器情况</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210814133524278.png" alt="image-20210814133524278"></p>
<p>重新运行结果：（下图左边寄存器为返回后的值）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210814134241466.png" alt="image-20210814134241466"></p>
<p>再次运行程序在test函数头加int3观察</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210814140654925.png" alt="image-20210814140654925"></p>
<p>与我们的修改完全一致，只是如果在test函数头加int3，会导致蓝屏，无法正常返回。</p>
<p><strong>后面的实验发现CALL过去的方式不能在test函数头加int3(蓝屏)是因为int会将nt位清0，导致iretd在堆栈中找返回值(实则没有，所以蓝屏)</strong></p>
<p><strong>可以在CALL实验中将test函数中的int 3用pushfd和popfd包裹起来</strong>（防止int 3修改eflags寄存器），避免蓝屏。（已实验证实可以）</p>
<p><strong>JMP过去的方式可以加int 3不蓝屏。</strong></p>
<h5 id="JMP实验返回"><a href="#JMP实验返回" class="headerlink" title="JMP实验返回"></a>JMP实验返回</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> trs[<span class="number">6</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __declspec(naked)  <span class="built_in">test</span>()</span><br><span class="line">&#123;</span><br><span class="line">        __asm</span><br><span class="line">        &#123;</span><br><span class="line">                jmp fword ptr trs;</span><br><span class="line">                <span class="comment">//iretd;</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> stack[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        DWORD cr3=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;cr3:&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%X&quot;</span>,&amp;cr3);</span><br><span class="line"></span><br><span class="line">        DWORD tss[<span class="number">0x68</span>]=&#123;</span><br><span class="line">                <span class="number">0x0</span>,</span><br><span class="line">                <span class="number">0x0</span>,</span><br><span class="line">                <span class="number">0x0</span>,</span><br><span class="line">                <span class="number">0x0</span>,</span><br><span class="line">                <span class="number">0x0</span>,</span><br><span class="line">                <span class="number">0x0</span>,</span><br><span class="line">                <span class="number">0x0</span>,</span><br><span class="line">                cr3,</span><br><span class="line">                (DWORD)test,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                ((DWORD)stack) - <span class="number">100</span>,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                <span class="number">0x23</span>,</span><br><span class="line">                <span class="number">0x08</span>,</span><br><span class="line">                <span class="number">0x10</span>,</span><br><span class="line">                <span class="number">0x23</span>,</span><br><span class="line">                <span class="number">0x30</span>,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                <span class="number">0x20ac0000</span></span><br><span class="line">        &#125;;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%X\n&quot;</span>,tss);</span><br><span class="line">        WORD rs=<span class="number">0</span>;</span><br><span class="line">        _asm</span><br><span class="line">        &#123;</span><br><span class="line">                str ax;<span class="comment">//str指令为保存当前TSS的段选择子到ax中</span></span><br><span class="line">                mov rs,ax;</span><br><span class="line">        &#125;</span><br><span class="line">        *(WORD*)&amp;trs[<span class="number">4</span>]=rs;<span class="comment">//保存跳回来的jmp的目标段选择子和目标地址</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">6</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x48</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        __asm</span><br><span class="line">        &#123;</span><br><span class="line">                jmp fword ptr buf;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;zsaddfsafdsa\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210814141149228.png" alt="image-20210814141149228"></p>
<p>构造tss段描述符：0000E912&#96;FD780068</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eq gdtr+0x48 0000E912`FD780068</span><br></pre></td></tr></table></figure>

<p>获取CR3后输入，成功执行</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210814142148937.png" alt="image-20210814142148937"></p>
<h6 id="JMP实验中test头添加int观察实验"><a href="#JMP实验中test头添加int观察实验" class="headerlink" title="JMP实验中test头添加int观察实验"></a><strong>JMP实验中test头添加int观察实验</strong></h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> trs[<span class="number">6</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __declspec(naked)  <span class="built_in">test</span>()</span><br><span class="line">&#123;</span><br><span class="line">        __asm</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="number">3</span><span class="comment">//！！！！和上个实验唯一的区别：添加int 3！！！！！</span></span><br><span class="line">            jmp fword ptr trs;</span><br><span class="line">            <span class="comment">//iretd;</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="type">char</span> stack[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        DWORD cr3=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;cr3:&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%X&quot;</span>,&amp;cr3);</span><br><span class="line">        DWORD tss[<span class="number">0x68</span>]=&#123;</span><br><span class="line">                <span class="number">0x0</span>,</span><br><span class="line">                <span class="number">0x0</span>,</span><br><span class="line">                <span class="number">0x0</span>,</span><br><span class="line">                <span class="number">0x0</span>,</span><br><span class="line">                <span class="number">0x0</span>,</span><br><span class="line">                <span class="number">0x0</span>,</span><br><span class="line">                <span class="number">0x0</span>,</span><br><span class="line">                cr3,</span><br><span class="line">                (DWORD)test,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                ((DWORD)stack) - <span class="number">100</span>,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                <span class="number">0x23</span>,</span><br><span class="line">                <span class="number">0x08</span>,</span><br><span class="line">                <span class="number">0x10</span>,</span><br><span class="line">                <span class="number">0x23</span>,</span><br><span class="line">                <span class="number">0x30</span>,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                <span class="number">0x20ac0000</span></span><br><span class="line">        &#125;;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%X\n&quot;</span>,tss);</span><br><span class="line">        WORD rs=<span class="number">0</span>;</span><br><span class="line">        _asm</span><br><span class="line">        &#123;</span><br><span class="line">                str ax;<span class="comment">//str指令为保存当前TSS的段选择子到ax中</span></span><br><span class="line">                mov rs,ax;</span><br><span class="line">        &#125;</span><br><span class="line">        *(WORD*)&amp;trs[<span class="number">4</span>]=rs;<span class="comment">//保存跳回来的jmp的目标段选择子和目标地址</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">6</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x48</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        __asm</span><br><span class="line">        &#123;</span><br><span class="line">                jmp fword ptr buf;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;zsaddfsafdsa\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正常执行。</p>
<h2 id="任务门"><a href="#任务门" class="headerlink" title="任务门"></a>任务门</h2><p>这里主要介绍如何通过任务门去访问任务段</p>
<p><strong>有了任务段为什么还要有任务门？</strong></p>
<p>答：任务门为异常(INT)提供了可切换任务的机制，是一种被动的机制，而单纯的任务段必须被主动调用(CALL JMP)</p>
<p>任务门描述符可以放在GDT,LDT和IDT中</p>
<h3 id="任务门描述符"><a href="#任务门描述符" class="headerlink" title="任务门描述符"></a>任务门描述符</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210810155043085.png" alt="image-20210810155043085"></p>
<p>TSS Segment Selector指向一个TSS段描述符。</p>
<p>任务门描述符的构造：0000E500&#96;XXXX0000</p>
<h3 id="任务门的执行过程"><a href="#任务门的执行过程" class="headerlink" title="任务门的执行过程"></a>任务门的执行过程</h3><p><strong>INT N—&gt;查IDT表，找到任务门描述符—&gt;通过中断门描述符，查GDT表，找到任务段描述符—&gt;使用TSS段中的值修改寄存器—&gt;IRETD返回。</strong></p>
<p>任务门描述符不一定在IDT中。多个任务门可以指向同一个TSS段描述符(如下图)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210810155400565.png" alt="image-20210810155400565"></p>
<h3 id="课后练习：实现任务门进1环。"><a href="#课后练习：实现任务门进1环。" class="headerlink" title="课后练习：实现任务门进1环。"></a>课后练习：实现任务门进1环。</h3><p>实验流程图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210816225541578.png" alt="image-20210816225541578"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __declspec(naked) <span class="built_in">test</span>()</span><br><span class="line">&#123;</span><br><span class="line">	_asm</span><br><span class="line">    &#123;</span><br><span class="line">        iretd</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> bu[<span class="number">0x10</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> iCr3;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input CR3:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%x&quot;</span>,&amp;iCr3);<span class="comment">//通过windbg工具!process 0 0指令获取</span></span><br><span class="line">    </span><br><span class="line">    DWORD iTss[<span class="number">0x68</span>]=&#123;<span class="comment">//用栈空间构造TSS，TSS段描述符中的Base填该数组的首地址</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//link</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//esp0</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//ss0</span></span><br><span class="line">        ((DWORD)bu)<span class="number">-0x10</span>,<span class="comment">//esp1  esp1必须修改，不然会蓝屏（不知为何任务段处做的零环实验，esp0可以不填）</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//ss1</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//esp2</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//ss2</span></span><br><span class="line">        (DWORD)iCr3,<span class="comment">//cr3</span></span><br><span class="line">        (DWORD)test,<span class="comment">//eip   此处要填入跳转位置的地址</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//eflags</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//eax</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//ecx</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//edx</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//ebx</span></span><br><span class="line">        ((DWORD)bu)<span class="number">-0x10</span>,<span class="comment">//esp   -0x10是因为esp是往小地址升栈的。</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//ebp</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//esi</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//edi</span></span><br><span class="line">        <span class="number">0x00000023</span>,<span class="comment">//es</span></span><br><span class="line">        <span class="number">0x00000091</span>,<span class="comment">//cs	0x1B（cs段选择子决定是否升了权限，由于0x91选择子指向的段描述符是1环权限，所以此处是提权了的）</span></span><br><span class="line">        <span class="number">0x00000099</span>,<span class="comment">//ss	0x23</span></span><br><span class="line">        <span class="number">0x00000023</span>,<span class="comment">//ds</span></span><br><span class="line">        <span class="number">0x000000A9</span>,<span class="comment">//fs	0x3B</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//gs</span></span><br><span class="line">        <span class="number">0x00000000</span>,<span class="comment">//ldt(如果想使用LDT的话，可以自己构造LDT使用)</span></span><br><span class="line">        <span class="number">0x20ac0000</span> <span class="comment">//I/O Map Base Address</span></span><br><span class="line">	&#125;;</span><br><span class="line">    <span class="comment">/*__asm&#123;</span></span><br><span class="line"><span class="comment">        int 0x20</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;iTss:%x\n&quot;</span>,iTss);</span><br><span class="line">    _asm</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="number">0x20</span>;<span class="comment">//放入任务门</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造任务门放进IDT中第33个位置,即int 0x20对应的位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eq 8003f500 0000E500`00480000</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210816223122790.png" alt="image-20210816223122790"></p>
<p>在GDT的0x48位置构造TSS段描述符</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210816213131908.png" alt="image-20210816213131908"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eq 8003f048 0000E912`fdcc0068</span><br></pre></td></tr></table></figure>

<p>将原本<code>0x1B选择的CS</code>，<code>0x23选择的SS</code>和<code>0x3B选择的FS</code>三个段描述符复制后到GDT表的空的空间中，仅修改DPL为01b（因为目的是要进1环）。</p>
<ul>
<li><p>CS</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eq <span class="number">8003</span>f090 <span class="number">00</span>cfbb00`<span class="number">0000</span>ffff<span class="comment">//CS在TSS中修改为0x91</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>SS</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eq <span class="number">8003</span>f098 <span class="number">00</span>cfb300`<span class="number">0000</span>ffff<span class="comment">//SS在TSS中修改xin为0x99</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>FS</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eq <span class="number">8003</span>f0a8 <span class="number">0040</span>b300`<span class="number">00000</span>fff<span class="comment">//FS在TSS中修改为0xA9</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>修改后的gdt表：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210816223047078.png" alt="image-20210816223047078"></p>
<p>成功执行：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210816223308855.png" alt="image-20210816223308855"></p>
<h3 id="逆向int-8实验"><a href="#逆向int-8实验" class="headerlink" title="逆向int 8实验"></a>逆向int 8实验</h3><p>下图第三题</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210810152110148.png" alt="image-20210810152110148"></p>
<p>windbg指令U</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">U　　//这个命令主要用于反汇编某个地址，其后面可以跟函数名和地址。</span><br></pre></td></tr></table></figure>

<p><strong>uf</strong>命令可以看到跳转等的下文。(更有用)</p>
<p><strong>实验流程图</strong>：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210816174502207.png" alt="image-20210816174502207"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/2018121811050612.png" alt="2018121811050612"></p>
<p>查看idt表吗，下图黄标为int 8的中断门描述符</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210816170139162.png" alt="image-20210816170139162"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210810155043085.png" alt="image-20210810155043085"></p>
<p>0x85拆解为1000 0101b，type为0101b，发现int 8指向的是任务门描述符。可知TSS段选择子为0x0050,拆解为：0101 0000b，IT位为0，因此在gdt表中找gdtr+0x50的位置为TSS段描述符(如下图黄标)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210816171357608.png" alt="image-20210816171357608"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/67da19ce25a32b127b6e42f82ed6b0a3.jpeg" alt="67da19ce25a32b127b6e42f82ed6b0a3"></p>
<p>由TSS段描述符可知，TSS内存的所在位置为0x8054af00。</p>
<p>查看TSS内存：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/196406-20200102102107308-1624147754.png" alt="196406-20200102102107308-1624147754"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210816173952057.png" alt="image-20210816173952057"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210816174123638.png" alt="image-20210816174123638"></p>
<p>上图黄标为EIP地址，0x805404ce。</p>
<p>windbg反汇编EIP地址，则找到了int 8将执行的目标代码：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210816190000468.png" alt="image-20210816190000468"></p>
<p>黄标就是蓝屏</p>
<p>CLI表示禁止中断发生，STL允许中断发生</p>
<p>IDA中找该函数：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210816190714434.png" alt="image-20210816190714434"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210816190840273.png" alt="image-20210816190840273"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; uf <span class="number">0x805404ce</span></span><br><span class="line">nt!KiTrap08:</span><br><span class="line"><span class="number">805404</span>ce fa              cli	<span class="comment">//IF位清零，即禁止中断发生</span></span><br><span class="line"><span class="number">805404</span>cf <span class="number">8</span>b0d3cf0dfff    mov     ecx,dword ptr ds:[<span class="number">0</span>FFDFF03Ch]</span><br><span class="line"><span class="number">805404</span>d5 <span class="number">8</span>d4150          lea     eax,[ecx<span class="number">+50</span>h]</span><br><span class="line"><span class="number">805404</span>d8 c6400589        mov     byte ptr [eax<span class="number">+5</span>],<span class="number">89</span>h<span class="comment">//改变任务段描述符状态为空闲，试图修改TSS段描述符中type中的忙位为0,</span></span><br><span class="line"><span class="number">805404</span>dc <span class="number">9</span>c              pushfd</span><br><span class="line"><span class="number">805404</span>dd <span class="number">812424</span>ffbfffff  <span class="keyword">and</span>     dword ptr [esp],<span class="number">0</span>FFFFBFFFh<span class="comment">//NT清0，不清楚意义何在</span></span><br><span class="line"><span class="number">805404e4</span> <span class="number">9</span>d              popfd</span><br><span class="line"><span class="number">805404e5</span> a13cf0dfff      mov     eax,dword ptr ds:[FFDFF03Ch]<span class="comment">//eax是GDT表首地址</span></span><br><span class="line"><span class="comment">//下面几步取TSS内存基址放入ecx中</span></span><br><span class="line"><span class="number">805404</span>ea <span class="number">8</span>a6857          mov     ch,byte ptr [eax<span class="number">+57</span>h]</span><br><span class="line"><span class="number">805404</span>ed <span class="number">8</span>a4854          mov     cl,byte ptr [eax<span class="number">+54</span>h]</span><br><span class="line"><span class="number">805404</span>f0 c<span class="number">1e110</span>          shl     ecx,<span class="number">10</span>h</span><br><span class="line"><span class="number">805404</span>f3 <span class="number">668</span>b4852        mov     cx,word ptr [eax<span class="number">+52</span>h]<span class="comment">//此后ecx是gdtr+0x50的任务段描述符中的tss地址</span></span><br><span class="line"><span class="number">805404</span>f7 a140f0dfff      mov     eax,dword ptr ds:[FFDFF040h]<span class="comment">//似乎无用</span></span><br><span class="line"><span class="number">805404</span>fc <span class="number">890</span>d40f0dfff    mov     dword ptr ds:[<span class="number">0</span>FFDFF040h],ecx<span class="comment">//gdtr+0x50的任务段描述符中的tss地址放入[当前KPCR存TSS地址的地址中]</span></span><br><span class="line"></span><br><span class="line">nt!KiTrap08<span class="number">+0x34</span>:<span class="comment">//!!!!!!!!!!!!!!!!!</span></span><br><span class="line"><span class="number">80540502</span> <span class="number">6</span>a00            push    <span class="number">0</span></span><br><span class="line"><span class="number">80540504</span> <span class="number">6</span>a00            push    <span class="number">0</span></span><br><span class="line"><span class="number">80540506</span> <span class="number">6</span>a00            push    <span class="number">0</span></span><br><span class="line"><span class="number">80540508</span> <span class="number">50</span>              push    eax</span><br><span class="line"><span class="number">80540509</span> <span class="number">6</span>a08            push    <span class="number">8</span></span><br><span class="line"><span class="number">8054050</span>b <span class="number">6</span>a7f            push    <span class="number">7</span>Fh</span><br><span class="line"><span class="number">8054050</span>d e8048dfbff      call    nt!<span class="built_in">KeBugCheck2</span> (<span class="number">804</span>f9216)</span><br><span class="line"><span class="number">80540512</span> ebee            jmp     nt!KiTrap08<span class="number">+0x34</span> (<span class="number">80540502</span>)  Branch<span class="comment">//循环至!!!!!!!!!!!!!!!!!</span></span><br></pre></td></tr></table></figure>

<p>上面代码分析不一定正确。</p>
<p>p.s.我取了内核态和用户态FS的值，在内核态FS&#x3D;0x30, 在用户态FS&#x3D;0x3B。</p>
<p>远程执行思路图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210817122234616.png" alt="image-20210817122234616"></p>
<p>略（未实验）</p>
<h2 id="LDT相关"><a href="#LDT相关" class="headerlink" title="LDT相关"></a>LDT相关</h2><p>LDT段描述符结构</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/20200220223113225.jpg" alt="20200220223113225"></p>
<p>LDTR结构</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/20200221184557778.jpg" alt="20200221184557778"></p>
<p>与其他结构的关系</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/20200221211315395.jpg" alt="20200221211315395"></p>
<h3 id="自己构建LDT表和其中的数据段描述符实验"><a href="#自己构建LDT表和其中的数据段描述符实验" class="headerlink" title="自己构建LDT表和其中的数据段描述符实验"></a>自己构建LDT表和其中的数据段描述符实验</h3><ol>
<li>LLDT<br>LLDT的作用是装载局部描述符表寄存器LDTR。</li>
<li>SLDT<br>SLDT的作用是读取局部描述符表寄存器LDTR中的内容读取出来并存储。</li>
<li>LGDT<br>LGDT的作用是装载全局描述符表寄存器GDTR。</li>
<li>SGDT<br>SGDT的作用是读取全局描述符表寄存器GDTR中的内容读取出来并存储。</li>
</ol>
<p>LDT为什么叫局部描述符，是因为和程序挂钩，也就是用本程序的CR3才能获取到地址，所以应该放到三环。想看的话只能通过物理地址去看。</p>
<p>别的程序访问效果如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210816135130139.png" alt="image-20210816135130139"></p>
<p>实验代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> ldtTable[<span class="number">0x3ff</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> gdtr[<span class="number">6</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">__declspec(naked) <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		pushad;<span class="comment">//[去掉不影响实验成功]</span></span><br><span class="line">		pushfd;<span class="comment">//[去掉不影响实验成功]</span></span><br><span class="line">		lea eax,[gdtr<span class="number">+2</span>];<span class="comment">//读gdtTable的首地址所在地址</span></span><br><span class="line">		mov eax,[eax];<span class="comment">//读gdtTable的首地址</span></span><br><span class="line">        <span class="comment">//------开始构造ldt段描述符低4字节-------</span></span><br><span class="line">		lea eax,[eax<span class="number">+0x90</span>];<span class="comment">//eax为gdtTable的首地址+0x90的地址</span></span><br><span class="line">		lea ecx,ldtTable;<span class="comment">//ecx存自己构建的ldtTable的首地址</span></span><br><span class="line">		mov bx,cx;<span class="comment">//存到bx中，只取cx就够了</span></span><br><span class="line">		shl ebx,<span class="number">0x10</span>;<span class="comment">//左移16位(补零)</span></span><br><span class="line">		mov bx,<span class="number">0x03ff</span>;<span class="comment">//ebx为[cx]+03ff</span></span><br><span class="line">		mov dword ptr ds:[eax],ebx;<span class="comment">//构造好的ebx放进[gdtTable的首地址+0x90的地址]</span></span><br><span class="line">        <span class="comment">//------开始构造ldt段描述符高4字节-------</span></span><br><span class="line">		lea eax,[eax<span class="number">+4</span>];<span class="comment">//eax调整为[gdtTable的首地址+0x94的地址]</span></span><br><span class="line">		shr ecx,<span class="number">0x10</span>;<span class="comment">//将存放着自己构建的ldtTable的地址右移16位，即只保留高位的16位</span></span><br><span class="line">		mov byte ptr ds:[eax],cl;<span class="comment">//cx低8位放进[gdtTable的首地址+0x94的地址]</span></span><br><span class="line">		mov byte ptr ds:[eax<span class="number">+1</span>],<span class="number">0xe2</span>;<span class="comment">//0xe2放到[gdtTable的首地址+0x95的地址]   0xE2的拆解:P=1 DPL=11 S=0 TYPE=0010</span></span><br><span class="line">		mov byte ptr ds:[eax<span class="number">+4</span>],ch;<span class="comment">//cx高8位放进[gdtTable的首地址+0x98的地址]</span></span><br><span class="line">        <span class="comment">//-------ldt段描述符高4字节为[cl]+0xe2+0x00+[ch]------</span></span><br><span class="line">		mov ax,<span class="number">0x93</span>;</span><br><span class="line">		lldt ax;<span class="comment">//加载段选择子为0x93的ldt段描述符</span></span><br><span class="line">		popfd;<span class="comment">//[去掉不影响实验成功]</span></span><br><span class="line">		popad;<span class="comment">//[去掉不影响实验成功]</span></span><br><span class="line">		retf;<span class="comment">//调用门提权返回</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> buf[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x48</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="type">char</span> cldtr[]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b=<span class="number">0</span>;</span><br><span class="line">	*((<span class="type">unsigned</span> <span class="type">int</span> *)(ldtTable<span class="number">+8</span>))=<span class="number">0x0000ffff</span>;<span class="comment">//构造ldt表中的数据段描述符</span></span><br><span class="line">	*((<span class="type">unsigned</span> <span class="type">int</span> *)(ldtTable<span class="number">+0xc</span>))=<span class="number">0x00cFF300</span>;<span class="comment">//0x00cFF300是三环，0x00cf9300为0环</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%X,ldtTable=%X\n&quot;</span>,test,ldtTable);</span><br><span class="line">	</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		sgdt gdtr;</span><br><span class="line">		push fs;<span class="comment">//[去掉不影响实验成功]</span></span><br><span class="line">		call fword ptr buf;<span class="comment">//调用门提权，用于提权后构造ldt表与其内的数据段描述符</span></span><br><span class="line">		sldt cldtr;</span><br><span class="line">		pop fs;<span class="comment">//[去掉不影响实验成功]</span></span><br><span class="line">		mov ax,<span class="number">0x0f</span>;</span><br><span class="line">		mov ds,ax;<span class="comment">//加载ldt表内的数据段描述符</span></span><br><span class="line">		mov eax,a;<span class="comment">//尝试读</span></span><br><span class="line">		mov b,eax;<span class="comment">//尝试写(读a的值写入b)</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实验图解：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210816164118935.png" alt="image-20210816164118935"></p>
<p>运行程序</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210816163834960.png" alt="image-20210816163834960"></p>
<p>401000为test地址，可知构造的调用门描述符为</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eq gdtr+0x48 0040ec00`00081000</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210816164556502.png" alt="image-20210816164556502"></p>
<p>运行，下图成功将b改为10了，实验成功。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210816164830888.png" alt="image-20210816164830888"></p>
<p>此时查看gdt表：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210816164938808.png" alt="image-20210816164938808"></p>
<p>0x90的位置(蓝色区域)已被修改为ldt段描述符</p>
<p>可进一步实验，将LDT中的数据段描述符改成DPL改为零环，则数据读写失败(略，已证明)</p>
<h1 id="保护模式–页"><a href="#保护模式–页" class="headerlink" title="保护模式–页"></a>保护模式–页</h1><p>实模式下访问的内存地址都是<strong>物理内存地址</strong>，保护模式下访问的内存地址都是<strong>线性地址</strong></p>
<p>物理内存的大小等同于内存条，但物理内存不是内存条，之间还有映射关系</p>
<p>线性地址，有效地址，物理地址的概念理解</p>
<p>如下指令：</p>
<p>MOV eax,dword ptr ds:[0x12345678]</p>
<p>其中，0x12345678是<strong>有效地址</strong></p>
<p>ds.Base+0x12345678是<strong>线性地址</strong>(通常有效地址和线性地址是一个值，因为ds.Base为0)</p>
<ul>
<li>线性地址转换成物理地址的方式在x86 cpu下有两种模式，一种是10-10-12，另一种是2-9-9-12的形式。</li>
<li>如果是64位CPU的话，还有第三种更加复杂的方式。(类似2-9-9-12)</li>
</ul>
<hr>
<ul>
<li>Q：两个进程都存在0x12345678的线性地址，为什么找到的内容不一样</li>
<li>A：因为<strong>每个进程都有各自的一堆表（存储着该进程线性地址到物理内存的映射关系）</strong></li>
</ul>
<h2 id="10-10-12分页"><a href="#10-10-12分页" class="headerlink" title="10-10-12分页"></a>10-10-12分页</h2><p>10-10-12分页的内核模块是ntoskrnl.exe</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210820144620796.png" alt="image-20210820144620796"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210817141821836.png" alt="image-20210817141821836"></p>
<p><strong>修改10-10-12分页的方式</strong>：boot.ini中的**&#x2F;execute&#x3D;optin**表示10-10-12分页</p>
<p>每个进程都有一个CR3（准确来说是CR3中的值）</p>
<p>CR3本身是一个寄存器，一个CPU核只有一套寄存器。</p>
<p>CR3指向一个物理页(所有寄存器中，只有CR3存的是物理地址，其他寄存器存的都是线性地址)，一共4096字节(4KB)，如图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210817141832675.png" alt="image-20210817141832675"></p>
<p>将线性地址的32位拆分为10位，10位，12位。其中，第一个10位就代表了第一级内在什么位置。</p>
<p>windbg查看物理地址指令是<br>$$<br>!dd<br>$$<br>找第一级的物理地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!dd DirBase(低3位十六进制清零)+线性地址第一个十位*4</span><br></pre></td></tr></table></figure>

<p>将里面取得的值的低3位16进制置为0，因为低3位16进制代表的是属性</p>
<p>找第二级物理地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!dd 上一步取到的值(低3位十六进制清零)+线性地址第二个十位*4</span><br></pre></td></tr></table></figure>

<p>再次将取得的值的低3位16进制置为0</p>
<p>找到对应物理地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">要找的物理地址=上一步取到的值(低3位十六进制清零)+线性地址第三个12位</span><br></pre></td></tr></table></figure>

<p>取物理地址里存的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!dd 要找的物理地址</span><br></pre></td></tr></table></figure>



<h3 id="PDE与PTE"><a href="#PDE与PTE" class="headerlink" title="PDE与PTE"></a>PDE与PTE</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210817143849226.png" alt="image-20210817143849226"></p>
<p>页目录表（占4KB）中每个页目录表项占4个字节，每个页目录项又指向一个4KB的页表，每个页表项占4个字节。因此每个页表有1024个页表项。</p>
<p>无论是PDE还是PTE，里面记录的前20位*2的12次方(后面添加12位0)是<strong>物理地址</strong>，后面12位是属性。</p>
<p><strong>PTE的特点</strong></p>
<ul>
<li>PTE可以没有物理页(P位为0即无效，也就是没有物理页)，且只能对应一个物理页</li>
<li>多个PTE可以指向同一个物理页</li>
</ul>
<p><strong>10-10-12一些细节</strong></p>
<ol>
<li>一个物理页是4KB（4096个字节），刚好是2的12次方个字节，所以需要12个二进制位索引4KB大小的物理页，说明了10-10-12中最后一个为什么是12。</li>
<li>页表是1024个页表项，即2的10次方个成员，所以需要10个二进制位索引，说明了10-10-12的中间的10的由来。</li>
<li>同理页目录项。</li>
<li>10-10-12分页决定了当前CPU物理内存的最大值就是4GB(1024*1024*4096(B)&#x3D;4GB)</li>
</ol>
<p><strong>同一个进程的两个线性地址只要前5位16进制是一样的，那么他们就一定在一个物理页上。因为PDE与PTE都一样，而后三位十六进制只决定他们在物理页上的偏移。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210817151041469.png" alt="image-20210817151041469"><br>$$<br>物理页的属性&#x3D;PDE属性\ &amp;\  PTE属性<br>$$</p>
<table>
<thead>
<tr>
<th><strong>位</strong></th>
<th><strong>功能描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>P</strong></td>
<td>有效位：1-有效    0-无效    决定是否存在物理页</td>
</tr>
<tr>
<td><strong>R&#x2F;W</strong></td>
<td>0-只读(常量区)	1-可读可写</td>
</tr>
<tr>
<td><strong>U&#x2F;S</strong></td>
<td>权限位：0-特权用户(-1环【VT】和0环)	1-普通用户(1,2,3环)</td>
</tr>
<tr>
<td><strong>P&#x2F;S</strong></td>
<td>只对PDE有意义，PS(PageSize)的意思，当PS&#x3D;&#x3D;1时，表示PDE指向大物理页(4MB)，即不需要拆分PTE了，<strong>PDE的低22位直接是物理页的页内偏移。</strong></td>
</tr>
<tr>
<td><strong>PAT</strong></td>
<td>页属性表（也是用来控制页属性的，但是对CPU有要求）</td>
</tr>
<tr>
<td><strong>A</strong></td>
<td>是否被访问(读或者写)过 访问过置1，即使只访问一个字节也会导致PDE，PTE置1</td>
</tr>
<tr>
<td><strong>D</strong></td>
<td>脏位：是否被写过   0-没有被写过     1-被写过</td>
</tr>
<tr>
<td><strong>G</strong></td>
<td>1-全局页(全局TLB)   0-相对TLB，只有P&#x2F;S位等于1的时候(大页)，他才有效。P&#x2F;S为零的时候，G位永远为零。<strong>全局页不会随进程切换清空TLB</strong></td>
</tr>
<tr>
<td><strong>PWT</strong></td>
<td>-</td>
</tr>
<tr>
<td><strong>PCD</strong></td>
<td>-</td>
</tr>
</tbody></table>
<p><strong>有效位</strong>,CPU没有使用，操作系统使用了，用来判断缺页。CPU寻址的时候发现P位为0就触发0xE号中断，此时操作系统得以发挥，在9~11位的有效位判断到底是没分物理页，还是缺页将此页挪到文件里了(然后再给补上页)。（具体的细节后面会有更详细的解读）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210818201133076.png" alt="image-20210818201133076"></p>
<p><code>-的部分学完控制寄存器与TLB才能理解，此处先略过(后面有讲)</code></p>
<p>可见10-10-12分页没有可执行属性，但在2-9-9-12有个位对这种情况做了补充</p>
<p>页有两种</p>
<ul>
<li>小页单位：4KB</li>
<li>大页单位：4MB（只有系统里面一部分经常使用的内存才会使用大页）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov dword ptr ds:[<span class="number">0</span>]</span><br><span class="line"><span class="comment">//cpu两步判断这个线性地址可写：</span></span><br><span class="line"><span class="comment">//1. 判断ds段描述符是否可写</span></span><br><span class="line"><span class="comment">//2. 通过PDE&amp;PTE的R/W属性判断该物理地址是否可写</span></span><br><span class="line"><span class="number">0</span>的线性地址如果不可写，直接意味着<span class="number">0</span>x~<span class="number">0xFFF</span>的线性地址都不可写，因为前<span class="number">5</span>位<span class="number">16</span>进制一致，即都在同一个物理页上</span><br></pre></td></tr></table></figure>

<ol>
<li>2G以上是内核才能访问的原因是U&#x2F;S位的设置问题，如果将内核的某个页设置为1，就可以在R3访问了</li>
<li>0,1,2是系统环，可以访问系统页和用户页，0环是特权环；1,2环虽然不是特权级环，但是是系统环；3环是用户环，可以访问用户页</li>
</ol>
<h3 id="页目录表PDT基址-线性地址"><a href="#页目录表PDT基址-线性地址" class="headerlink" title="页目录表PDT基址(线性地址)"></a>页目录表PDT基址(线性地址)</h3><ul>
<li>Q：如果系统要保证某个线性地址是有效的，那么必须为其填充正确的PDE与PTE，如果我们想填充PDE与PTE，那么必须能够访问PDT与PTT。那么是谁帮我们填好了PDE与PTE呢？</li>
<li>A：操作系统；如果A进程创建B进程，那么是A进程帮B进程填好PDT和PTT</li>
</ul>
<p>在程序中，我们是不能直接访问物理页的，想要访问物理页，必须通过线性地址。</p>
<p>CR3中存储的是物理地址，不能在程序中直接读取的。如果想读取，也要把Cr3<br>的值挂到PDT和PTT中才能访问，那么怎么通过线性地址访问PDT和PTT呢？</p>
<p><strong>拆解4G线性内存：</strong></p>
<ol>
<li>低2G(0~7FFFFFFF) 各个进程几乎不同</li>
<li>高2G(80000000~FFFFFFFF) 各个进程几乎相同</li>
<li>0~7FFFFFFF的前64K和后64K都是没有映射的</li>
</ol>
<p>发现：<br>$$<br>0xC0300000线性地址存储的值就是PDT的基址<br>$$</p>
<ol>
<li><p>通过0xC0300000(这个线性地址是一定存在的，如果它不存在，系统也没办法访问这个表)找到的物理页就是页目录表</p>
</li>
<li><p>这个物理页即是页目录表，本身也是页表</p>
</li>
<li><p>页目录表是一张特殊的页表，每一项PTE指向的不是普通的物理页，而是指向其他的页表</p>
</li>
<li><p>如果我们要访问低N个PDE，公式如下：<br>$$<br>0xC0300000+N*4<br>$$</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210818111918749.png" alt="image-20210818111918749"></p>
</li>
</ol>
<p><strong>CR3中的值+0xC00该物理地址中存的就是CR3中的值</strong></p>
<p><strong>PDT是PTT中的一个（如图红色区域就是PDT）</strong>。</p>
<h3 id="页表PTT基址-线性地址"><a href="#页表PTT基址-线性地址" class="headerlink" title="页表PTT基址(线性地址)"></a>页表PTT基址(线性地址)</h3><ul>
<li>0xC0000000对应的是第一个PTT的基地址</li>
<li>0xC0001000对应的是第二个PTT的基地址</li>
<li>每个PTT基地址之间隔着0x1000（4KB）（物理地址不连续，但线性地址是连续的）</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210818120306245.png" alt="image-20210818120306245"></p>
<ol>
<li>页表被映射到了从0xC0000000到0xC03FFFFF的4M地址空间</li>
<li>在这1024个表中有一张特殊的表：<strong>页目录表（页表中的第0x300项）</strong></li>
<li>页目录表被映射到了0xC0300000开始处的4K地址空间</li>
</ol>
<p><strong>0xC0300000实际上是通过0xC0000000算出来的：</strong><br>$$<br>VirtualAddr对应的PDE线性地址&#x3D;(VirtualAddr &gt;&gt; 12) * 4+0xC0000000<br>$$<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210822152334263.png" alt="image-20210822152334263"></p>
<blockquote>
<p>Windows 把所有页表映射到0xC0000000到0xC03FFFFF 这4MB的地址空间中，对于这4M的地址空间也有一个页目录表与之对应。不妨设为Px。既然Windows 把全部页表都映射到上述的4M地址空间，那么页目录表Px自然也在其中。第一个页表对应的线性地址为0xC0000000H，即用上述公式应该能找到第一张页表对应的PDE所在线性地址。利用公式PDE_Addr &#x3D; (VirtualAddr &gt;&gt; 12) * 4 + 0xC0000000，将0xC0000000H带入其中，可以求得第一个PDE地址：PDE_Addr &#x3D;C0300000H。</p>
<p>C0300000H-0xC0300FFF的页表映射了0xC0000000到0xC03FFFFF 这4MB的地址空间的物理内存。而这4m地址空间恰恰是页目录表的物理地址。所以说C0300000H-0xC0300FFF对应的4k地址空间就是页目录。</p>
</blockquote>
<p>windbg拆解线性地址命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">！vtop 3a37a000(CR3) 0xXXXXXXXX(要拆解的线性地址)</span><br></pre></td></tr></table></figure>

<h4 id="小实验"><a href="#小实验" class="headerlink" title="小实验"></a>小实验</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DWORD result1;</span><br><span class="line">DWORD result2;</span><br><span class="line">DWORD result3;</span><br><span class="line"></span><br><span class="line"> __declspec(naked) <span class="function"><span class="type">void</span> <span class="title">callGate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;	</span><br><span class="line">		pushad</span><br><span class="line">		pushfd</span><br><span class="line">		mov eax,dword ptr ds:[<span class="number">0xC0300000</span>];</span><br><span class="line">		mov result1,eax;</span><br><span class="line">		mov eax,dword ptr ds:[<span class="number">0xC0000000</span>];</span><br><span class="line">		mov result2,eax;</span><br><span class="line">		mov eax,dword ptr ds:[<span class="number">0xC0001000</span>];</span><br><span class="line">		mov result3,eax;</span><br><span class="line">		popfd</span><br><span class="line">		popad</span><br><span class="line">		retf</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;callGateFunc address:%X\n&quot;</span>,callGate);</span><br><span class="line">	<span class="type">char</span> gate[<span class="number">6</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x48</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">	_asm</span><br><span class="line">	&#123;</span><br><span class="line">		call fword ptr ds:[gate];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;0xC0300000 result:%X\n&quot;</span>,result1);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;0xC0000000 result:%X\n&quot;</span>,result2);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;0xC0001000 result:%X\n&quot;</span>,result3);</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210821182319577.png" alt="image-20210821182319577"></p>
<h4 id="掌握一个进程所有的物理内存读写权限【公式总结】"><a href="#掌握一个进程所有的物理内存读写权限【公式总结】" class="headerlink" title="掌握一个进程所有的物理内存读写权限【公式总结】"></a>掌握一个进程所有的物理内存读写权限<strong>【公式总结】</strong></h4><p>10-10-12		PDI-PTI-物理页内偏移</p>
<ul>
<li>PDI：页目录索引</li>
<li>PTI：页表索引</li>
</ul>
<ol>
<li><p><strong>访问页目录表项PDE地址的公式：</strong><br>$$<br>0xC0300000+PDI*4<br>$$</p>
</li>
<li><p><strong>访问页表项PTE地址的公式：</strong><br>$$<br>0xC0000000+PDI<em>4096+PTI</em>4<br>$$</p>
</li>
</ol>
<p>$$<br>0xC0000000+PDI<em>2的10次方</em>4+PTI<em>4&#x3D;0xC0000000+(PDI</em>2的10次方+PTI)*4<br>$$</p>
<p>$$<br>0xC0000000+PDI拼接PTI部分*4<br>$$</p>
<h5 id="实验-3"><a href="#实验-3" class="headerlink" title="实验"></a>实验</h5><p>将buf的物理页挂到0线性地址那附近，通过<code>0 + buf的物理页偏移部分</code>的地址调用MessageBoxW函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">push 0</span></span><br><span class="line"><span class="comment">push 0</span></span><br><span class="line"><span class="comment">push 0</span></span><br><span class="line"><span class="comment">push 0</span></span><br><span class="line"><span class="comment">call 0</span></span><br><span class="line"><span class="comment">retn</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">char</span> buf[]=&#123;<span class="number">0x6a</span>,<span class="number">0x00</span>,<span class="number">0x6a</span>,<span class="number">0</span>,<span class="number">0x6a</span>,<span class="number">0</span>,<span class="number">0x6a</span>,<span class="number">0</span>,<span class="number">0xE8</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0xc3</span>&#125;;</span><br><span class="line"></span><br><span class="line">__declspec(naked) <span class="function"><span class="type">void</span> <span class="title">callGate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;	</span><br><span class="line">		</span><br><span class="line">		push <span class="number">0x30</span>;<span class="comment">//手动修改fs框架1</span></span><br><span class="line">		pop fs;<span class="comment">//手动修改fs框架2</span></span><br><span class="line">		pushad;</span><br><span class="line">		pushfd;</span><br><span class="line">		</span><br><span class="line">		lea eax,buf;</span><br><span class="line">		mov ebx,dword ptr ds:[<span class="number">0xc0300000</span>];</span><br><span class="line">		test ebx,ebx;</span><br><span class="line">		je __gpPDE;<span class="comment">//PDE为0则跳转</span></span><br><span class="line"></span><br><span class="line">		shr eax,<span class="number">12</span>;<span class="comment">//去掉buf地址的最后12位物理页偏移</span></span><br><span class="line">		<span class="keyword">and</span> eax,<span class="number">0xfffff</span>;<span class="comment">//取buf地址前20位</span></span><br><span class="line">		shl eax,<span class="number">2</span>;<span class="comment">//buf地址前20位乘4</span></span><br><span class="line"></span><br><span class="line">		add eax, <span class="number">0xc0000000</span>;<span class="comment">//buf的PTE对应地址</span></span><br><span class="line">		mov eax,[eax];<span class="comment">//buf对应的PTE</span></span><br><span class="line">		mov dword ptr ds:[<span class="number">0xc0000000</span>],eax;<span class="comment">//将buf对应PTE放到0线性地址对应的PTE位置中</span></span><br><span class="line">		jmp __retR;</span><br><span class="line"></span><br><span class="line">__gpPDE:		<span class="comment">//如果0线性地址对应的PDE是0的话跳转到这里来</span></span><br><span class="line">		shr eax,<span class="number">22</span>;</span><br><span class="line">		<span class="keyword">and</span> eax,<span class="number">0x3ff</span>;<span class="comment">//取第一个10位</span></span><br><span class="line">		shl eax,<span class="number">2</span>;<span class="comment">//第一个10位乘4</span></span><br><span class="line">		</span><br><span class="line">		add eax, <span class="number">0xc0300000</span>;<span class="comment">//找到对应PDE的地址</span></span><br><span class="line">		mov eax,[eax];<span class="comment">//找到对应PDE</span></span><br><span class="line">		mov dword ptr ds:[<span class="number">0xc0300000</span>],eax;<span class="comment">//将buf对应PDE放到0线性地址对应的PDE位置中，PDE就换了，所以后面的PTE也就不用换了，反正整个PTT表都换了</span></span><br><span class="line">__retR:	</span><br><span class="line">		popfd;</span><br><span class="line">		popad;</span><br><span class="line">		retf;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> functionAddress = (<span class="type">unsigned</span> <span class="type">int</span>)MessageBox;<span class="comment">//获取MessageBox地址</span></span><br><span class="line">	<span class="type">int</span> offset1=((<span class="type">unsigned</span> <span class="type">int</span>)buf) &amp; <span class="number">0xfff</span>;<span class="comment">//获取buf本身的物理页上的偏移</span></span><br><span class="line">	<span class="comment">//修正EIP,调用MessageBoxW函数</span></span><br><span class="line">	*((<span class="type">unsigned</span> <span class="type">int</span> *)&amp;buf[<span class="number">9</span>])= functionAddress - (<span class="number">13</span> + offset1); </span><br><span class="line">	<span class="type">char</span> segmentGate[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x48</span>,<span class="number">0</span>&#125;;<span class="comment">//调用门,0040EC00`00081000</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;MessageBox:%X  callGate = %X,buf=%X\n&quot;</span>,MessageBox,callGate,buf);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		call fword ptr segmentGate;</span><br><span class="line">		push <span class="number">0x3b</span>;<span class="comment">//手动修正fs框架1</span></span><br><span class="line">		pop fs;<span class="comment">//手动修正fs框架2</span></span><br><span class="line">		mov eax,offset1;</span><br><span class="line">		call eax;<span class="comment">//调用offset地址</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210821192154718.png" alt="image-20210821192154718"></p>
<h4 id="10-10-12内核逆向分析MmIsAddressValid函数"><a href="#10-10-12内核逆向分析MmIsAddressValid函数" class="headerlink" title="10-10-12内核逆向分析MmIsAddressValid函数"></a>10-10-12内核逆向分析MmIsAddressValid函数</h4><p>一个用于判断虚拟内存地址是否有效的API，逆向该函数可以知道操作系统是怎么找PDE和PTE的。</p>
<h5 id="用IDA"><a href="#用IDA" class="headerlink" title="用IDA"></a>用IDA</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210819130503077.png" alt="image-20210819130503077"></p>
<p>可以将内核文件放入IDA分析。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210819132944697.png" alt="image-20210819132944697"></p>
<h5 id="用windbg"><a href="#用windbg" class="headerlink" title="用windbg"></a>用windbg</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uf MmIsAddressValid</span><br></pre></td></tr></table></figure>

<p>尝试逆向：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; uf MmIsAddressValid</span><br><span class="line">nt!MmIsAddressValid:</span><br><span class="line"><span class="number">804e4661</span> <span class="number">8</span>bff            mov     edi,edi</span><br><span class="line"><span class="number">804e4663</span> <span class="number">55</span>              push    ebp</span><br><span class="line"><span class="number">804e4664</span> <span class="number">8</span>bec            mov     ebp,esp</span><br><span class="line"><span class="number">804e4666</span> <span class="number">8</span>b4d08          mov     ecx,dword ptr [ebp<span class="number">+8</span>]<span class="comment">//要检查的线性地址存入ecx</span></span><br><span class="line"><span class="number">804e4669</span> <span class="number">8</span>bc1            mov     eax,ecx</span><br><span class="line"><span class="number">804e466</span>b c<span class="number">1e814</span>          shr     eax,<span class="number">14</span>h<span class="comment">//要检查的线性地址右移20位，相当于右移22位再左移2位，即乘4,下一句修正后两位</span></span><br><span class="line"><span class="number">804e466</span>e bafc0f0000      mov     edx,<span class="number">0</span>FFCh</span><br><span class="line"><span class="number">804e4673</span> <span class="number">23</span>c2            <span class="keyword">and</span>     eax,edx<span class="comment">//(要检查的线性地址前12位)的后两位清零</span></span><br><span class="line"><span class="number">804e4675</span> <span class="number">2</span>d0000d03f      sub     eax,<span class="number">3</span>FD00000h<span class="comment">//等同于add eax,0xc0300000</span></span><br><span class="line"><span class="number">804e467</span>a <span class="number">8</span>b00            mov     eax,dword ptr [eax]<span class="comment">//此后eax为PDE的值</span></span><br><span class="line"><span class="number">804e467</span>c a801            test    al,<span class="number">1</span><span class="comment">//检测PDE末尾（P位）是否为1</span></span><br><span class="line"><span class="number">804e467</span>e <span class="number">0</span>f84d2f10000    je      nt!MmIsAddressValid<span class="number">+0x4f</span> (<span class="number">804</span>f3856)  Branch<span class="comment">//P位不为1就跳</span></span><br><span class="line"></span><br><span class="line">nt!MmIsAddressValid<span class="number">+0x1f</span>:</span><br><span class="line"><span class="number">804e4684</span> <span class="number">84</span>c0            test    al,al</span><br><span class="line"><span class="number">804e4686</span> <span class="number">7824</span>            js      nt!MmIsAddressValid<span class="number">+0x53</span> (<span class="number">804e46</span>ac)  Branch<span class="comment">//判断PDE后8位的首位(P/S位)是否1，是1就跳，表示指向大物理页，不用拆pte了</span></span><br><span class="line"></span><br><span class="line">nt!MmIsAddressValid<span class="number">+0x23</span>:</span><br><span class="line"><span class="number">804e4688</span> c<span class="number">1e90</span>a          shr     ecx,<span class="number">0</span>Ah<span class="comment">//要检查的线性地址右移10位，相当于左移12位后右移两位，因为要乘4,下一句修正后两位</span></span><br><span class="line"><span class="number">804e468</span>b <span class="number">81e1f</span>cff3f00    <span class="keyword">and</span>     ecx,<span class="number">3</span>FFFFCh<span class="comment">//右移后的线性地址的后两位清零</span></span><br><span class="line"><span class="number">804e4691</span> <span class="number">81e900000040</span>    sub     ecx,<span class="number">40000000</span>h<span class="comment">//等同于add ecx,0xc0000000</span></span><br><span class="line"><span class="number">804e4697</span> <span class="number">8</span>bc1            mov     eax,ecx</span><br><span class="line"><span class="number">804e4699</span> <span class="number">8</span>b08            mov     ecx,dword ptr [eax]<span class="comment">//此后ecx是PTE的值</span></span><br><span class="line"><span class="number">804e469</span>b f6c101          test    cl,<span class="number">1</span><span class="comment">//判断P位</span></span><br><span class="line"><span class="number">804e469</span>e <span class="number">0</span>f84b2f10000    je      nt!MmIsAddressValid<span class="number">+0x4f</span> (<span class="number">804</span>f3856)  Branch<span class="comment">//P位不为1就跳</span></span><br><span class="line"></span><br><span class="line">nt!MmIsAddressValid<span class="number">+0x3b</span>:</span><br><span class="line"><span class="number">804e46</span>a4 <span class="number">84</span>c9            test    cl,cl<span class="comment">//判断PAT位</span></span><br><span class="line"><span class="number">804e46</span>a6 <span class="number">0</span>f88b6de0300    js      nt!MmIsAddressValid<span class="number">+0x3f</span> (<span class="number">80522562</span>)  Branch<span class="comment">//PAT位是1就跳，即PAT为0则一定是有效的</span></span><br><span class="line"></span><br><span class="line">nt!MmIsAddressValid<span class="number">+0x53</span>:</span><br><span class="line"><span class="number">804e46</span>ac b001            mov     al,<span class="number">1</span><span class="comment">//al置1，因为eax是默认返回值，返回1，线性地址有效</span></span><br><span class="line"></span><br><span class="line">nt!MmIsAddressValid<span class="number">+0x55</span>:<span class="comment">//返回</span></span><br><span class="line"><span class="number">804e46</span>ae <span class="number">5</span>d              pop     ebp</span><br><span class="line"><span class="number">804e46</span>af c20400          ret     <span class="number">4</span></span><br><span class="line">    </span><br><span class="line"> nt!MmIsAddressValid<span class="number">+0x4f</span>:<span class="comment">//PDE或PTE的P位检查未通过</span></span><br><span class="line"><span class="number">804</span>f3856 <span class="number">32</span>c0            <span class="keyword">xor</span>     al,al<span class="comment">//al置0，因为eax是默认返回值，返回0，线性地址无效</span></span><br><span class="line"><span class="number">804</span>f3858 e9510effff      jmp     nt!MmIsAddressValid<span class="number">+0x55</span> (<span class="number">804e46</span>ae)  Branch</span><br><span class="line"></span><br><span class="line">nt!MmIsAddressValid<span class="number">+0x3f</span>:<span class="comment">//PAT位=1的处理</span></span><br><span class="line"><span class="number">80522562</span> <span class="number">23</span>c2            <span class="keyword">and</span>     eax,edx<span class="comment">//edx：0FFCh，eax：PTE的线性地址</span></span><br><span class="line">    <span class="comment">//比如说0xC0000XXX变成XXX</span></span><br><span class="line"><span class="number">80522564</span> <span class="number">8</span>b80000030c0    mov     eax,dword ptr [eax<span class="number">-3</span>FD00000h]<span class="comment">//比如说0xC0000XXX变成0xC0300XXX，自己实验中发现0xC0300XXX地址中为0</span></span><br><span class="line"><span class="number">8052256</span>a <span class="number">66258100</span>        <span class="keyword">and</span>     ax,<span class="number">81</span>h</span><br><span class="line"><span class="number">8052256</span>e <span class="number">3</span>c81            cmp     al,<span class="number">81</span>h<span class="comment">//第0位和第7位必须为1内存地址才有效</span></span><br><span class="line"><span class="number">80522570</span> <span class="number">0</span>f853621fcff    jne     nt!MmIsAddressValid<span class="number">+0x53</span> (<span class="number">804e46</span>ac)  Branch</span><br><span class="line"></span><br><span class="line">nt!MmIsAddressValid<span class="number">+0x53</span>:<span class="comment">//检查未通过</span></span><br><span class="line"><span class="number">80522576</span> e9db12fdff      jmp     nt!MmIsAddressValid<span class="number">+0x4f</span> (<span class="number">804</span>f3856)  Branch</span><br></pre></td></tr></table></figure>

<blockquote>
<p>sub     eax,3FD00000h等同于add eax,0xc0300000详解：</p>
<p>因为3FD00000h+0xc0300000&#x3D;0x100000000</p>
<p>eax+0xc0300000&#x3D;eax+0x100000000-3FD00000h，0x100000000装不下所以会溢出等同于没有。</p>
</blockquote>
<h2 id="2-9-9-12分页"><a href="#2-9-9-12分页" class="headerlink" title="2-9-9-12分页"></a>2-9-9-12分页</h2><p>2-9-9-12分页的内核模块是ntkrnlpa.exe</p>
<p>在之前的课程中我们讲解了<strong>10-10-12分页</strong>方式，在这种分页方式下，物理地址最多可达4GB，但随着硬件发展，4GB的物理地址范围已经无法满足要求，Intel在1996年就已经意识到这个问题了，所以设计了新的分页方式。也就是我们本节课要讲的<strong>2-9-9-12分页</strong>，又称为<strong>PAE（物理地址拓展）分页</strong>。</p>
<p>与64位比较相似。</p>
<p><strong>为什么是10-10-12</strong></p>
<ol>
<li>先确定了物理页的大小为4K，所以后面的12位的功能就确定了。</li>
<li>当初的物理内存比较小，所以4个字节的PTE就够了，加上页的尺寸是4K，所以一个页能存储1024个PTE，也就是2的10次方，第二个10位确定了。</li>
<li>剩下的10位为PDI，10+10+12&#x3D;32。</li>
</ol>
<p><strong>为什么是2-9-9-12</strong></p>
<ol>
<li><p>物理页的大小是确定的，4KB不能随便改，所以后面的12位确定了</p>
</li>
<li><p>如果想增大物理内存的访问范围，就需要增大PTE，增大多少了呢，考虑对齐的因素，增加到8个字节。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210819142745181.png" alt="image-20210819142745181"></p>
<p>因为一个物理页就4KB，由于PTE由4字节变成8字节，所以项数由1024项缩小为512项。</p>
<p>而512项需要9个二进制位进行索引，所以PTI是9。</p>
</li>
<li><p>同理PDI也是9位(2的9次方) </p>
</li>
<li><p>最后，32 - 9 - 9 - 12 还差2位 所以就再做一级 叫PDPI</p>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210819143625209.png" alt="image-20210819143625209"></p>
<p>因为只有两位，所以PDPTE只有4个。</p>
<p>2-9-9-12可以最大允许的物理内存为：2的36次方(PDE是36位的物理地址宽度)，即<strong>64G</strong>。</p>
<p>2-9-9-12 VirtualAddr对应的PDE线性地址&#x3D;(VirtualAddr &gt;&gt; 12) * 8+0xC0000000</p>
<p>代入第一个PTE的地址0xC0000000可知：PDT地址为0xC0600000</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210822194231558.png" alt="image-20210822194231558"></p>
<p>第4个PDPTE指向了一个PDT表，此表的前四项指向了PDPTE的每一个元素。</p>
<ul>
<li>C0600000是第一个PDT表的首地址</li>
<li>C0601000是第二个PDT表的首地址</li>
<li>C0602000是第三个PDT表的首地址</li>
<li>C0603000是第四个PDT表的首地址</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210822211646330.png" alt="image-20210822211646330"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210822212611498.png" alt="image-20210822212611498"></p>
<p>在同一个PDT中相邻两个PTT首地址间隔为0x1000</p>
<p>通过0xC0603000线性地址读取第四个PDT的第一个PDE内容成功：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210822213911198.png" alt="image-20210822213911198"></p>
<ol>
<li><p><strong>访问页目录表项PDE地址的公式：</strong></p>
<ul>
<li>0xC0000000+PDI*4</li>
<li>0xC0100000+PDI*4</li>
<li>0xC0200000+PDI*4</li>
<li>0xC0300000+PDI*4</li>
</ul>
</li>
<li><p><strong>访问页表项PTE地址的公式：</strong><br>$$<br>0xC0000000+PDI<em>4096+PTI</em>8<br>$$</p>
</li>
</ol>
<h3 id="页目录指针表项Page-Dircetory-Point-Table-Entry"><a href="#页目录指针表项Page-Dircetory-Point-Table-Entry" class="headerlink" title="页目录指针表项Page-Dircetory-Point-Table Entry"></a>页目录指针表项Page-Dircetory-Point-Table Entry</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210819144239301.png" alt="image-20210819144239301"></p>
<p>Avail：CPU设计给操作系统用的，操作系统设计者爱用不用</p>
<p>35~12位存储的是页目录表PDT的物理基址，低12位补零，共36位，即页目录表基址。</p>
<p>存的项也是占用8字节</p>
<h3 id="PDE结构"><a href="#PDE结构" class="headerlink" title="PDE结构"></a>PDE结构</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210819144958741.png" alt="image-20210819144958741"></p>
<table>
<thead>
<tr>
<th><strong>位</strong></th>
<th><strong>功能描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>P</strong></td>
<td>有效位：1-有效    0-无效    决定是否存在物理页</td>
</tr>
<tr>
<td><strong>R&#x2F;W</strong></td>
<td>0-只读(常量区)	1-可读可写</td>
</tr>
<tr>
<td><strong>U&#x2F;S</strong></td>
<td>权限位：0-特权用户(-1环【VT】和0环)	1-普通用户(1,2,3环)</td>
</tr>
<tr>
<td><strong>P&#x2F;S</strong></td>
<td>只对PDE有意义，PS(PageSize)的意思，当PS&#x3D;&#x3D;1时，表示PDE指向大物理页(2MB)</td>
</tr>
<tr>
<td><strong>PAT</strong></td>
<td>页属性表（也是用来控制页属性的，但是对CPU有要求）</td>
</tr>
<tr>
<td><strong>A</strong></td>
<td>是否被访问(读或者写)过 访问过置1，即使只访问一个字节也会导致PDE，PTE置1</td>
</tr>
<tr>
<td><strong>D</strong></td>
<td>脏位：是否被写过   0-没有被写过     1-被写过</td>
</tr>
<tr>
<td><strong>G</strong></td>
<td>1-全局页(全局TLB)   0-相对TLB，只有P&#x2F;S位等于1的时候(大页)，他才有效。P&#x2F;S为零的时候，G位永远为零。</td>
</tr>
<tr>
<td><strong>PWT</strong></td>
<td>-</td>
</tr>
<tr>
<td><strong>PCD</strong></td>
<td>-</td>
</tr>
</tbody></table>
<p>2-9-9-12结构下的两种页</p>
<ol>
<li>小页	4KB</li>
<li>大页    2MB（和10-10-12分页的4MB不一样，2的(9+12)次方）</li>
</ol>
<h3 id="PTE结构"><a href="#PTE结构" class="headerlink" title="PTE结构"></a>PTE结构</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210819151236597.png" alt="image-20210819151236597"></p>
<p>小实验：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//12FF7C地址中存了一个100</span></span><br><span class="line"><span class="comment">//拆分线性地址：</span></span><br><span class="line"><span class="comment">//00</span></span><br><span class="line"><span class="comment">//0 0000 0000</span></span><br><span class="line"><span class="comment">//1 0010 1111  =0x12F  *8=0x978</span></span><br><span class="line"><span class="comment">//F7C</span></span><br><span class="line"></span><br><span class="line">Failed to get VadRoot</span><br><span class="line">PROCESS <span class="number">818</span>eeb70  SessionId: <span class="number">0</span>  Cid: <span class="number">0714</span>    Peb: <span class="number">7</span>ffde000  ParentCid: <span class="number">064</span>8</span><br><span class="line">    DirBase: <span class="number">0</span>89c<span class="number">02e0</span>  ObjectTable: e118dde0  HandleCount:  <span class="number">15.</span></span><br><span class="line">    Image: test.exe</span><br><span class="line"></span><br><span class="line">kd&gt; !dq <span class="number">0</span>89c<span class="number">02e0</span></span><br><span class="line"># <span class="number">89</span>c<span class="number">02e0</span> <span class="number">00000000</span>`<span class="number">18116001</span> <span class="number">00000000</span>`<span class="number">18057001</span></span><br><span class="line"># <span class="number">89</span>c02f0 <span class="number">00000000</span>`<span class="number">18058001</span> <span class="number">00000000</span>`<span class="number">18095001</span></span><br><span class="line"># <span class="number">89</span>c0300 <span class="number">00000000</span>`<span class="number">17</span>d7b001 <span class="number">00000000</span>`<span class="number">17</span>efc001</span><br><span class="line"># <span class="number">89</span>c0310 <span class="number">00000000</span>`<span class="number">17</span>fbd001 <span class="number">00000000</span>`<span class="number">17</span>ffa001</span><br><span class="line"># <span class="number">89</span>c0320 <span class="number">00000000</span>`<span class="number">15886001</span> <span class="number">00000000</span>`<span class="number">15707001</span></span><br><span class="line"># <span class="number">89</span>c0330 <span class="number">00000000</span>`<span class="number">155</span>c8001 <span class="number">00000000</span>`<span class="number">158</span>c5001</span><br><span class="line"># <span class="number">89</span>c0340 <span class="number">00000000</span>`f8d<span class="number">0e360</span> <span class="number">00000000</span>`<span class="number">164</span>cc001</span><br><span class="line"># <span class="number">89</span>c0350 <span class="number">00000000</span>`<span class="number">166</span>cd001 <span class="number">00000000</span>`<span class="number">1674</span>a001</span><br><span class="line">kd&gt; !dq <span class="number">18116000</span></span><br><span class="line">#<span class="number">18116000</span> <span class="number">00000000</span>`<span class="number">17</span>bfe067 <span class="number">00000000</span>`<span class="number">18019067</span></span><br><span class="line">#<span class="number">18116010</span> <span class="number">00000000</span>`<span class="number">17</span>f3d067 <span class="number">00000000</span>`<span class="number">00000000</span></span><br><span class="line">#<span class="number">18116020</span> <span class="number">00000000</span>`<span class="number">00000000</span> <span class="number">00000000</span>`<span class="number">00000000</span></span><br><span class="line">#<span class="number">18116030</span> <span class="number">00000000</span>`<span class="number">00000000</span> <span class="number">00000000</span>`<span class="number">00000000</span></span><br><span class="line">#<span class="number">18116040</span> <span class="number">00000000</span>`<span class="number">00000000</span> <span class="number">00000000</span>`<span class="number">00000000</span></span><br><span class="line">#<span class="number">18116050</span> <span class="number">00000000</span>`<span class="number">00000000</span> <span class="number">00000000</span>`<span class="number">00000000</span></span><br><span class="line">#<span class="number">18116060</span> <span class="number">00000000</span>`<span class="number">00000000</span> <span class="number">00000000</span>`<span class="number">00000000</span></span><br><span class="line">#<span class="number">18116070</span> <span class="number">00000000</span>`<span class="number">00000000</span> <span class="number">00000000</span>`<span class="number">00000000</span></span><br><span class="line">kd&gt; !dq <span class="number">17</span>bfe000<span class="number">+0x12F</span>*<span class="number">8</span></span><br><span class="line">#<span class="number">17</span>bfe978 <span class="number">80000000</span>`<span class="number">17</span>f92067 <span class="number">80000000</span>`<span class="number">0e2</span>c3025</span><br><span class="line">#<span class="number">17</span>bfe988 <span class="number">80000000</span>`<span class="number">0e244025</span> <span class="number">00000000</span>`<span class="number">00000000</span></span><br><span class="line">#<span class="number">17</span>bfe998 <span class="number">00000000</span>`<span class="number">00000000</span> <span class="number">00000000</span>`<span class="number">00000000</span></span><br><span class="line">#<span class="number">17</span>bfe9a8 <span class="number">00000000</span>`<span class="number">00000000</span> <span class="number">00000000</span>`<span class="number">00000000</span></span><br><span class="line">#<span class="number">17</span>bfe9b8 <span class="number">00000000</span>`<span class="number">00000000</span> <span class="number">00000000</span>`<span class="number">00000000</span></span><br><span class="line">#<span class="number">17</span>bfe9c8 <span class="number">00000000</span>`<span class="number">00000000</span> <span class="number">00000000</span>`<span class="number">00000000</span></span><br><span class="line">#<span class="number">17</span>bfe9d8 <span class="number">00000000</span>`<span class="number">00000000</span> <span class="number">00000000</span>`<span class="number">00000000</span></span><br><span class="line">#<span class="number">17</span>bfe<span class="number">9e8</span> <span class="number">00000000</span>`<span class="number">00000000</span> <span class="number">00000000</span>`<span class="number">00000000</span></span><br><span class="line">kd&gt; !dd <span class="number">17</span>f92000<span class="number">+0xF7C</span></span><br><span class="line">#<span class="number">17</span>f92f7c 【<span class="number">00000064</span>】 <span class="number">0012</span>ffc0 <span class="number">0040130</span>9 <span class="number">00000001</span><span class="comment">//【】中确实为100</span></span><br><span class="line">#<span class="number">17</span>f92f8c <span class="number">003</span>80b90 <span class="number">003</span>80c08 <span class="number">003</span>80039 <span class="number">00360032</span></span><br><span class="line">#<span class="number">17</span>f92f9c <span class="number">7</span>ffde000 <span class="number">00000006</span> b2cded04 <span class="number">0012</span>ff94</span><br><span class="line">#<span class="number">17</span>f92fac <span class="number">8061850</span>d <span class="number">0012</span>ffe0 <span class="number">00404</span>950 <span class="number">0041027</span>8</span><br><span class="line">#<span class="number">17</span>f92fbc <span class="number">00000000</span> <span class="number">0012</span>fff0 <span class="number">7</span>c817067 <span class="number">003</span>80039</span><br><span class="line">#<span class="number">17</span>f92fcc <span class="number">00360032</span> <span class="number">7</span>ffde000 <span class="number">80545</span>bfd <span class="number">0012</span>ffc8</span><br><span class="line">#<span class="number">17</span>f92fdc <span class="number">8197</span>eb40 ffffffff <span class="number">7</span>c839ac0 <span class="number">7</span>c817070</span><br><span class="line">#<span class="number">17</span>f92fec <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00401220</span></span><br></pre></td></tr></table></figure>

<h3 id="X-D标志位"><a href="#X-D标志位" class="headerlink" title="X&#x2F;D标志位"></a>X&#x2F;D标志位</h3><p>在AMD中称为NX，即No Excetion</p>
<p><strong>PDE&#x2F;PTE结构如下</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210819151523802.png" alt="image-20210819151523802"></p>
<ul>
<li>段的属性有可读，可写和可执行</li>
<li>页的属性只有可读，可写</li>
</ul>
<p>当RET执行返回的时候，如果我修改堆栈里面的数据指向一个我提前准备好的数据(把数据当做代码来执行，漏洞都是依赖这点)</p>
<p>所以，Intel就做了硬件保护，做了一个不可执行位，XD&#x3D;1时，那么你的软件溢出了也没关系，即使你的EIP蹦到了危险的“数据区“，也是不可以执行的！</p>
<p><strong>在PAE(2-9-9-12)分页模式下，PDE或PTE的最高位为XD&#x2F;NX位,为1表示该内存只可在代码段执行。</strong>数据段不可执行</p>
<p>0x8开头的就是被保护的，因为首位二进制为1,进0环了直接改了就是了</p>
<h3 id="2-9-9-12内核逆向分析MmIsAddressValid函数"><a href="#2-9-9-12内核逆向分析MmIsAddressValid函数" class="headerlink" title="2-9-9-12内核逆向分析MmIsAddressValid函数"></a>2-9-9-12内核逆向分析MmIsAddressValid函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">nt!MmIsAddressValid:</span><br><span class="line"><span class="number">80511980</span> <span class="number">8</span>bff            mov     edi,edi</span><br><span class="line"><span class="number">80511982</span> <span class="number">55</span>              push    ebp</span><br><span class="line"><span class="number">80511983</span> <span class="number">8</span>bec            mov     ebp,esp</span><br><span class="line"><span class="number">80511985</span> <span class="number">51</span>              push    ecx</span><br><span class="line"><span class="number">80511986</span> <span class="number">51</span>              push    ecx</span><br><span class="line"><span class="number">80511987</span> <span class="number">8</span>b4d08          mov     ecx,dword ptr [ebp<span class="number">+8</span>]<span class="comment">//ecx取到要判断是否有效的线性地址</span></span><br><span class="line"><span class="number">8051198</span>a <span class="number">56</span>              push    esi<span class="comment">//push esi代表后面要用esi</span></span><br><span class="line"><span class="number">8051198</span>b <span class="number">8</span>bc1            mov     eax,ecx<span class="comment">//eax也为要判断是否有效的线性地址</span></span><br><span class="line"><span class="number">8051198</span>d c<span class="number">1e812</span>          shr     eax,<span class="number">12</span>h<span class="comment">//右移18位</span></span><br><span class="line"><span class="number">80511990</span> bef83f0000      mov     esi,<span class="number">3</span>FF8h</span><br><span class="line"><span class="number">80511995</span> <span class="number">23</span>c6            <span class="keyword">and</span>     eax,esi<span class="comment">//与11 1111 1111 1000，此后eax为pdi部分</span></span><br><span class="line"><span class="number">80511997</span> <span class="number">2</span>d0000a03f      sub     eax,<span class="number">3</span>FA00000h<span class="comment">//add eax,C0600000，eax此后为线性地址对应的PDE地址</span></span><br><span class="line"><span class="number">8051199</span>c <span class="number">8</span>b10            mov     edx,dword ptr [eax]<span class="comment">//edx为pde低64位</span></span><br><span class="line"><span class="number">8051199</span>e <span class="number">8</span>b4004          mov     eax,dword ptr [eax<span class="number">+4</span>]<span class="comment">//eax为pde高64位</span></span><br><span class="line"><span class="number">805119</span>a1 <span class="number">8945</span>fc          mov     dword ptr [ebp<span class="number">-4</span>],eax<span class="comment">//pde高64位存进局部变量1中</span></span><br><span class="line"><span class="number">805119</span>a4 <span class="number">8</span>bc2            mov     eax,edx<span class="comment">//eax为pde低64位</span></span><br><span class="line"><span class="number">805119</span>a6 <span class="number">57</span>              push    edi<span class="comment">//要用edi</span></span><br><span class="line"><span class="number">805119</span>a7 <span class="number">83e001</span>          <span class="keyword">and</span>     eax,<span class="number">1</span><span class="comment">//eax为PDE的p位</span></span><br><span class="line"><span class="number">805119</span>aa <span class="number">33</span>ff            <span class="keyword">xor</span>     edi,edi<span class="comment">//edi清零</span></span><br><span class="line"><span class="number">805119</span>ac <span class="number">0</span>bc7            <span class="keyword">or</span>      eax,edi<span class="comment">//判断PDE的p位是否为0</span></span><br><span class="line"><span class="number">805119</span>ae <span class="number">7461</span>            je      nt!MmIsAddressValid<span class="number">+0x91</span> (<span class="number">80511</span>a11)  Branch<span class="comment">//PDE的p位为零则跳</span></span><br><span class="line"></span><br><span class="line">nt!MmIsAddressValid<span class="number">+0x30</span>:<span class="comment">//PDE的p位不是零</span></span><br><span class="line"><span class="number">805119</span>b0 bf80000000      mov     edi,<span class="number">80</span>h</span><br><span class="line"><span class="number">805119</span>b5 <span class="number">23</span>d7            <span class="keyword">and</span>     edx,edi<span class="comment">//取pde的PS位，判断是否大页</span></span><br><span class="line"><span class="number">805119</span>b7 <span class="number">6</span>a00            push    <span class="number">0</span></span><br><span class="line"><span class="number">805119</span>b9 <span class="number">8955</span>f8          mov     dword ptr [ebp<span class="number">-8</span>],edx<span class="comment">//pde的PS位存入局部变量2空间</span></span><br><span class="line"><span class="number">805119</span>bc <span class="number">58</span>              pop     eax<span class="comment">//eax清零</span></span><br><span class="line"><span class="number">805119</span>bd <span class="number">7404</span>            je      nt!MmIsAddressValid<span class="number">+0x43</span> (<span class="number">805119</span>c3)  Branch<span class="comment">//PS位为0，即小页就跳转</span></span><br><span class="line"></span><br><span class="line">nt!MmIsAddressValid<span class="number">+0x3f</span>:<span class="comment">//大页，则不用判断PTE</span></span><br><span class="line"><span class="number">805119</span>bf <span class="number">85</span>c0            test    eax,eax</span><br><span class="line"><span class="number">805119</span>c1 <span class="number">7452</span>            je      nt!MmIsAddressValid<span class="number">+0x95</span> (<span class="number">80511</span>a15)  Branch<span class="comment">//百分百跳转到线性地址有效后返回</span></span><br><span class="line"></span><br><span class="line">nt!MmIsAddressValid<span class="number">+0x43</span>:<span class="comment">//PDE PS位为0，为小页则跳转</span></span><br><span class="line"><span class="number">805119</span>c3 c<span class="number">1e909</span>          shr     ecx,<span class="number">9</span><span class="comment">//线性地址右移9位，相当于右移12位，再左移3位(*8)</span></span><br><span class="line"><span class="number">805119</span>c6 <span class="number">81e1f</span>8ff7f00    <span class="keyword">and</span>     ecx,<span class="number">7</span>FFFF8h<span class="comment">//后三位置零，此后ecx为(pdpte+pdi+pti)部分</span></span><br><span class="line"><span class="number">805119</span>cc <span class="number">8</span>b81040000c0    mov     eax,dword ptr [ecx<span class="number">-3</span>FFFFFFCh]<span class="comment">//mov eax,[ecx+0xC0000004],此后eax为PTE高64位</span></span><br><span class="line"><span class="number">805119</span>d2 <span class="number">81e900000040</span>    sub     ecx,<span class="number">40000000</span>h<span class="comment">//mov eax,[ecx+0xC0000000],此后ecx为PTE低64位地址</span></span><br><span class="line"><span class="number">805119</span>d8 <span class="number">8</span>b11            mov     edx,dword ptr [ecx]<span class="comment">//edx为PTE低64位</span></span><br><span class="line"><span class="number">805119</span>da <span class="number">8945</span>fc          mov     dword ptr [ebp<span class="number">-4</span>],eax<span class="comment">//高64位部分存入局部变量1</span></span><br><span class="line"><span class="number">805119</span>dd <span class="number">53</span>              push    ebx<span class="comment">//临时保存ebx，要用</span></span><br><span class="line"><span class="number">805119</span>de <span class="number">8</span>bc2            mov     eax,edx<span class="comment">//eax为PTE低64位</span></span><br><span class="line"><span class="number">805119e0</span> <span class="number">33</span>db            <span class="keyword">xor</span>     ebx,ebx<span class="comment">//ebx清零</span></span><br><span class="line"><span class="number">805119e2</span> <span class="number">83e001</span>          <span class="keyword">and</span>     eax,<span class="number">1</span><span class="comment">//取PTE的P位</span></span><br><span class="line"><span class="number">805119e5</span> <span class="number">0</span>bc3            <span class="keyword">or</span>      eax,ebx<span class="comment">//判断PTE的P位是否为0</span></span><br><span class="line"><span class="number">805119e7</span> <span class="number">5</span>b              pop     ebx<span class="comment">//还原ebx</span></span><br><span class="line"><span class="number">805119e8</span> <span class="number">7427</span>            je      nt!MmIsAddressValid<span class="number">+0x91</span> (<span class="number">80511</span>a11)  Branch<span class="comment">//PTE的P位是零就跳</span></span><br><span class="line"></span><br><span class="line">nt!MmIsAddressValid<span class="number">+0x6a</span>:<span class="comment">//PTE的P位不是零</span></span><br><span class="line"><span class="number">805119</span>ea <span class="number">23</span>d7            <span class="keyword">and</span>     edx,edi<span class="comment">//edx为PTE的PAT位是否为0</span></span><br><span class="line"><span class="number">805119</span>ec <span class="number">6</span>a00            push    <span class="number">0</span></span><br><span class="line"><span class="number">805119</span>ee <span class="number">8955</span>f8          mov     dword ptr [ebp<span class="number">-8</span>],edx<span class="comment">//PTE的PAT位存入局部变量2</span></span><br><span class="line"><span class="number">805119</span>f1 <span class="number">58</span>              pop     eax<span class="comment">//eax清零</span></span><br><span class="line"><span class="number">805119</span>f2 <span class="number">7421</span>            je      nt!MmIsAddressValid<span class="number">+0x95</span> (<span class="number">80511</span>a15)  Branch<span class="comment">//PTE的PAT位为0就跳到函数有效返回部分</span></span><br><span class="line"></span><br><span class="line">nt!MmIsAddressValid<span class="number">+0x74</span>:<span class="comment">//无用</span></span><br><span class="line"><span class="number">805119</span>f4 <span class="number">85</span>c0            test    eax,eax</span><br><span class="line"><span class="number">805119</span>f6 <span class="number">751</span>d            jne     nt!MmIsAddressValid<span class="number">+0x95</span> (<span class="number">80511</span>a15)  Branch<span class="comment">//绝对不跳</span></span><br><span class="line"></span><br><span class="line">nt!MmIsAddressValid<span class="number">+0x78</span>:<span class="comment">//PTE的PAT位为1的处理</span></span><br><span class="line"><span class="number">805119</span>f8 <span class="number">23</span>ce            <span class="keyword">and</span>     ecx,esi<span class="comment">//and PTE低64位地址,3FF8h,可能是取PTE低64位地址的PDI部分</span></span><br><span class="line"><span class="number">805119</span>fa <span class="number">8</span>b89000060c0    mov     ecx,dword ptr [ecx<span class="number">-3</span>FA00000h]<span class="comment">//mov ecx,[ecx+C060 0000h]，？？？</span></span><br><span class="line"><span class="number">80511</span>a00 b881000000      mov     eax,<span class="number">81</span>h</span><br><span class="line"><span class="number">80511</span>a05 <span class="number">23</span>c8            <span class="keyword">and</span>     ecx,eax<span class="comment">//ecx为[(PTE低64位地址&amp;3FF8h)+C060 0000h]&amp;81h</span></span><br><span class="line"><span class="number">80511</span>a07 <span class="number">33</span>d2            <span class="keyword">xor</span>     edx,edx<span class="comment">//edx清零</span></span><br><span class="line"><span class="number">80511</span>a09 <span class="number">3</span>bc8            cmp     ecx,eax</span><br><span class="line"><span class="number">80511</span>a0b <span class="number">7508</span>            jne     nt!MmIsAddressValid<span class="number">+0x95</span> (<span class="number">80511</span>a15)  Branch<span class="comment">//判断[(PTE低64位地址&amp;3FF8h)+C060 0000h]的第7和第0位是否均为1，若有一个不是1，跳转。</span></span><br><span class="line"></span><br><span class="line">nt!MmIsAddressValid<span class="number">+0x8d</span>:<span class="comment">//无用</span></span><br><span class="line"><span class="number">80511</span>a0d <span class="number">85</span>d2            test    edx,edx</span><br><span class="line"><span class="number">80511</span>a0f <span class="number">7504</span>            jne     nt!MmIsAddressValid<span class="number">+0x95</span> (<span class="number">80511</span>a15)  Branch<span class="comment">//绝对不跳</span></span><br><span class="line"></span><br><span class="line">nt!MmIsAddressValid<span class="number">+0x91</span>:<span class="comment">//PDE P位为零的处理</span></span><br><span class="line"><span class="number">80511</span>a11 <span class="number">32</span>c0            <span class="keyword">xor</span>     al,al<span class="comment">//返回0，线性地址无效</span></span><br><span class="line"><span class="number">80511</span>a13 eb02            jmp     nt!MmIsAddressValid<span class="number">+0x97</span> (<span class="number">80511</span>a17)  Branch</span><br><span class="line"></span><br><span class="line">nt!MmIsAddressValid<span class="number">+0x95</span>:</span><br><span class="line"><span class="number">80511</span>a15 b001            mov     al,<span class="number">1</span><span class="comment">//返回1，线性地址有效</span></span><br><span class="line"></span><br><span class="line">nt!MmIsAddressValid<span class="number">+0x97</span>:<span class="comment">//退出函数</span></span><br><span class="line"><span class="number">80511</span>a17 <span class="number">5</span>f              pop     edi</span><br><span class="line"><span class="number">80511</span>a18 <span class="number">5</span>e              pop     esi</span><br><span class="line"><span class="number">80511</span>a19 c9              leave<span class="comment">//？</span></span><br><span class="line"><span class="number">80511</span>a1a c20400          ret     <span class="number">4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="旁路转换缓冲TLB"><a href="#旁路转换缓冲TLB" class="headerlink" title="旁路转换缓冲TLB"></a>旁路转换缓冲TLB</h2><p>每次访问一个物理页，查表的过程特别繁琐，举个例子，2-9-9-12分页模式下读一个四字节实际上会读24个字节，如果<strong>跨页读</strong>可能更多。</p>
<p>CPU内部做了一个表，来记录这些东西，这个表格是<strong>CPU内部的(不在内存中)<strong>，和寄存器一样快，这个表格：</strong>TLB（Translation Lookaside Buffer）</strong>即<strong>旁路转换缓冲</strong>,或称为<strong>页表缓冲</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210819194408894.png" alt="image-20210819194408894"></p>
<p>说明：</p>
<ol>
<li>ATTR(属性)：属性是PDPE，PDE，PTE三个属性AND起来的。如果是10-10-12就是PDE and PTE</li>
<li>不同的CPU，这个表的大小不一样</li>
<li>只要CR3变了，TLB立马刷新，一核一套TLB</li>
<li>LRU(统计信息)，记录每个地址的读写情况，确定哪个地址访问更频繁</li>
<li>存的是线性地址的前20位对应物理地址。</li>
</ol>
<p>操作系统的高2G映射基本不变，如果CR3改了，TLB刷新，重建高2G以上内存很浪费。所以PDE和PTE中有个G标志位，<strong>如果G位为1，刷新TLB时将不会刷新PDE&#x2F;PTE的G位为1的页</strong>。当TLB满了，根据统计信息将不常用的地址废弃，最近最常用的保留。</p>
<p><strong>高两G有大量G位为1的PDE</strong>，低2G也有G为1</p>
<h3 id="TLB种类"><a href="#TLB种类" class="headerlink" title="TLB种类"></a>TLB种类</h3><p>TLB在X86体系的CPU里的实际应用最早是从Intel的486PU开始的，在X86体系的CPU里边，<strong>每个核</strong>都设有如下4组TLB：</p>
<ol>
<li>缓存一般页表(4K字节页面)的指令页表缓存(Instruction-TLB)</li>
<li>缓存一般页表(4K字节页面)的数据页表缓存(Data-TLB)</li>
<li>缓存大尺寸页表(2M&#x2F;4M字节页面)的指令页表缓存(Instruction-TLB)</li>
<li>缓存大尺寸页表(2M&#x2F;4M字节页面)的数据页表缓存(Data-TLB)</li>
</ol>
<p>CPU能区分是读一个内存地址还是执行一个内存地址</p>
<p>如果是mov指令访问的内存放入数据页表缓存（读一个内存地址），如果是call&#x2F;jmp等指令访问的内存放入指令页表缓存（执行一个内存地址）。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/MousseLee/p/14404074.html">Shadow Walker，一种隐藏内存的技术。</a></p>
<p>可以用于过代码校验，在指令页表缓存中给目标地址修改为新的物理页。当执行的时候是到物理页执行，可是读的时候，读的还是原来的位置，即未被修改。</p>
<p>这种解决方案适合处理零环（也有点不稳定）而不适合处理三环，因为三环内存老是刷新（非常不稳定）。</p>
<p>三环有更好的方案挂钩子防止对方检测到(无痕hook)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210819215515748.png" alt="image-20210819215515748"></p>
<h3 id="TLB相关实验"><a href="#TLB相关实验" class="headerlink" title="TLB相关实验"></a>TLB相关实验</h3><h4 id="体验TLB的存在"><a href="#体验TLB的存在" class="headerlink" title="体验TLB的存在"></a>体验TLB的存在</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DWORD result;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __declspec(naked) <span class="built_in">func</span>()</span><br><span class="line">&#123;</span><br><span class="line">	_asm</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//给零地址挂物理页，可能会蓝屏（有可能被用着中）   0x01234867(G=0)  0x01234967(G=1)</span></span><br><span class="line">		mov dword ptr ds:[<span class="number">0xc0000000</span>],<span class="number">0x01234867</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//给零地址赋值</span></span><br><span class="line">		mov dword ptr ds:[<span class="number">0</span>],<span class="number">0x11111111</span></span><br><span class="line">            </span><br><span class="line">		<span class="comment">//将物理页改了，随便改成别的物理页</span></span><br><span class="line">		mov dword ptr ds:[<span class="number">0xc0000000</span>],<span class="number">0x02345867</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//再次读线性地址</span></span><br><span class="line">		mov eax,dword ptr ds:[<span class="number">0</span>]</span><br><span class="line">		mov result,eax</span><br><span class="line">		</span><br><span class="line">		retf</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;func address:%X\n&quot;</span>,func);</span><br><span class="line">	<span class="type">char</span> buff[<span class="number">6</span>]=&#123;<span class="number">0x11</span>,<span class="number">0x11</span>,<span class="number">0x11</span>,<span class="number">0x11</span>,<span class="number">0x48</span>,<span class="number">0</span>&#125;;<span class="comment">//调用门描述符0040EC00`00081000</span></span><br><span class="line">	_asm</span><br><span class="line">	&#123;</span><br><span class="line">		call fword ptr[buff]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;result:%X\n&quot;</span>,result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210820124123585.png" alt="image-20210820124123585"></p>
<p>进程切换后，结果被刷新：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DWORD result;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __declspec(naked) <span class="built_in">func</span>()</span><br><span class="line">&#123;</span><br><span class="line">	_asm</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//给零地址挂物理页，可能会蓝屏   0x01234867(G=0)  0x01234967(G=1)</span></span><br><span class="line">		mov dword ptr ds:[<span class="number">0xc0000000</span>],<span class="number">0x01234867</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//给零地址赋值</span></span><br><span class="line">		mov dword ptr ds:[<span class="number">0</span>],<span class="number">0x11111111</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//进程切换，只要有加载CR3的操作，那么就会清除TLB（除了G=1的内存）</span></span><br><span class="line">		mov eax,cr3</span><br><span class="line">		mov cr3,eax</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将物理页改了，随便改成别的物理页</span></span><br><span class="line">		mov dword ptr ds:[<span class="number">0xc0000000</span>],<span class="number">0x02345867</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//再次读线性地址</span></span><br><span class="line">		mov eax,dword ptr ds:[<span class="number">0</span>]</span><br><span class="line">		mov result,eax</span><br><span class="line">		</span><br><span class="line">		retf</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;func address:%X\n&quot;</span>,func);</span><br><span class="line">	<span class="type">char</span> buff[<span class="number">6</span>]=&#123;<span class="number">0x11</span>,<span class="number">0x11</span>,<span class="number">0x11</span>,<span class="number">0x11</span>,<span class="number">0x48</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	_asm</span><br><span class="line">	&#123;</span><br><span class="line">		call fword ptr[buff]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;result:%X\n&quot;</span>,result);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210820133141085.png" alt="image-20210820133141085"></p>
<p>结果中的0是因为新物理页中的值就是0</p>
<h4 id="全局页的意义"><a href="#全局页的意义" class="headerlink" title="全局页的意义"></a>全局页的意义</h4><p>上面的代码修改为全局页：</p>
<p> 把上述代码中的mov dword ptr ds:[0xc0000000],0x01234867从0x01234867修改为0x01234967</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210820134644415.png" alt="image-20210820134644415"></p>
<p>因此可知，全局页不会随进程切换清空TLB</p>
<h4 id="INVLPG指令的意义"><a href="#INVLPG指令的意义" class="headerlink" title="INVLPG指令的意义"></a>INVLPG指令的意义</h4><p>INVLPG dword ptr ds:[0]&#x2F;&#x2F;手动清空0线性地址对应在TLB的一条缓存。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DWORD result;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __declspec(naked) <span class="built_in">func</span>()</span><br><span class="line">&#123;</span><br><span class="line">	_asm</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//给零地址挂物理页，可能会蓝屏   0x01234867(G=0)  0x01234967(G=1)</span></span><br><span class="line">		mov dword ptr ds:[<span class="number">0xc0000000</span>],<span class="number">0x01234967</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//给零地址赋值</span></span><br><span class="line">		mov dword ptr ds:[<span class="number">0</span>],<span class="number">0x11111111</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//进程切换</span></span><br><span class="line">		mov eax,cr3</span><br><span class="line">		mov cr3,eax</span><br><span class="line"></span><br><span class="line">		INVLPG dword ptr ds:[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将物理页改了，随便改成别的物理页</span></span><br><span class="line">		mov dword ptr ds:[<span class="number">0xc0000000</span>],<span class="number">0x02345867</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//再次读线性地址</span></span><br><span class="line">		mov eax,dword ptr ds:[<span class="number">0</span>]</span><br><span class="line">		mov result,eax</span><br><span class="line">		</span><br><span class="line">		retf</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;func address:%X\n&quot;</span>,func);</span><br><span class="line">	<span class="type">char</span> buff[<span class="number">6</span>]=&#123;<span class="number">0x11</span>,<span class="number">0x11</span>,<span class="number">0x11</span>,<span class="number">0x11</span>,<span class="number">0x48</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	_asm</span><br><span class="line">	&#123;</span><br><span class="line">		call fword ptr[buff]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;result:%X\n&quot;</span>,result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210820135304899.png" alt="image-20210820135304899"></p>
<p>手动清空缓存成功，读出新物理页的值。</p>
<h1 id="中断与异常"><a href="#中断与异常" class="headerlink" title="中断与异常"></a>中断与异常</h1><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p><strong>什么是中断？</strong></p>
<p><strong>中断的本质目的就是改变CPU执行的路线</strong></p>
<ol>
<li><p>中断通常是由CPU外部的输入输出设备(硬件)所触发的，供外部设备通知CPU“有事情需要处理”，因此又叫中断请求（Interrupt Request）</p>
</li>
<li><p>中断请求的目的是希望CPU暂时停止执行当前正在执行的程序，转而去执行中断请求所对应的中断处理例程(中断处理程序在哪由IDT表决定)</p>
</li>
<li><p>80x86有两条中断请求线</p>
<p>​		非屏蔽中断线，称为NMI(NonMaskable Interrupt)</p>
<p>​		可屏蔽中断线，称为INTR(Interrupt Require)</p>
</li>
</ol>
<p><strong>非可屏蔽中断如何处理</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210820165939064.png" alt="image-20210820165939064"></p>
<p>当非可屏蔽中断产生时，CPU在执行完当前指令后会从里面进入中断处理程序</p>
<p>非可屏蔽中断不受EFLAG寄存器中IF位的影响，一旦发生，CPU必须 处理</p>
<p>非可屏蔽中断处理程序位于IDT表中的2号位置</p>
<p><strong>可屏蔽中断</strong></p>
<p>在硬件级，可屏蔽中断是由一块专门的芯片来管理的，通常称为<strong>中断控制器</strong>。它负责分配中断资源和管理各个中断源发出的中断请求。为了便于标识各个中断请求，中断管理器通常用<strong>IRQ（Interrupt Request）</strong>后面加上数字来表示不同的中断。</p>
<p>比如：在Windows中，时钟中断（即下图的系统计时器）的IRQ编号为0，也就是：IRQ0</p>
<p>win10查看IRQ：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210820171447027.png" alt="image-20210820171447027"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210820171507433.png" alt="image-20210820171507433"></p>
<p>大多数操作系统时钟在10<del>100ms之间，Windows系统为10</del>20MS。</p>
<p>时钟中断只是操作系统进行线程切换的一个机会。哪怕是一个无限循环的程序，一个单核系统，CPU依然有机会线程切换。</p>
<p><strong>可屏蔽中断如何处理</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210820172028590.png" alt="image-20210820172028590"></p>
<ol>
<li><p>如果自己的程序执行时，不希望CPU去处理这些中断</p>
<p>​		用<strong>CLI</strong>指令<strong>清空</strong>EFLAG寄存器中的IF位</p>
<p>​		用<strong>STI</strong>指令<strong>设置</strong>EFLAG寄存器中的IF位</p>
</li>
<li><p>硬件中断与IDT表中的对应关系并非固定不变的，参见<strong>APIC（高级可编程中断控制器）</strong></p>
</li>
</ol>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>异常通常是CPU在执行指令时检测到的某些错误，比如除0，访问无效页面等。</p>
<p><strong>中断与异常的区别：</strong></p>
<ol>
<li><strong>中断</strong>来自于外部设备，是中断源(比如键盘)发起的，CPU是被动的。</li>
<li><strong>异常</strong>来自于CPU本身，是CPU主动产生的(cpu在执行的时候发现错误了)。</li>
<li>INT N虽然被称为“软件中断”，但其本质是异常。<strong>EFLAG的IF位对INT N无效</strong>。</li>
</ol>
<p><strong>异常处理</strong></p>
<p>无论是<code>由硬件设备触发的中断请求</code>还是<code>由CPU产生的异常</code>，<strong>处理程序都在IDT表</strong>。</p>
<p>常见的异常处理程序如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210820173459803.png" alt="image-20210820173459803"></p>
<p><strong>举例缺页异常</strong></p>
<p>缺页异常的产生，比如：</p>
<ol>
<li>当PDE&#x2F;PTE的P&#x3D;0时</li>
<li>当PDE&#x2F;PTE的属性为只读，但程序试图写入的时候</li>
</ol>
<p>一旦发生缺页异常，CPU会执行IDT表中的0xE号中断处理程序，由操作系统来接管。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210820173746701.png" alt="image-20210820173746701"></p>
<h1 id="控制寄存器CR"><a href="#控制寄存器CR" class="headerlink" title="控制寄存器CR"></a>控制寄存器CR</h1><p>控制寄存器用于控制和确定CPU的操作模式</p>
<p>共5个 <strong>CR0,CR1,CR2,CR3,CR4</strong></p>
<p>CR1-保留，CR3-页目录表基址（不同分页模式不一样）</p>
<h2 id="CR0寄存器"><a href="#CR0寄存器" class="headerlink" title="CR0寄存器"></a>CR0寄存器</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210820174741733.png" alt="image-20210820174741733"></p>
<table>
<thead>
<tr>
<th>位</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>PE</strong></td>
<td>CR0的位是启用保护标志位(Protection Enable).。PE&#x3D;1保护模式    PE&#x3D;0实地址模式，该标志仅开启段级保护，而并没有启用分页机制。若要启用分页机制，PE和PG标志位都要置位</td>
</tr>
<tr>
<td><strong>PG</strong></td>
<td>设置该位时即开启了分页机制。在开启这个标志位之前必须已经或同时开启PE标志</td>
</tr>
<tr>
<td><strong>WP</strong></td>
<td>对于Intel 80x86或以上的CPU，CR0的位16是写保护(Write Protect)标志，<strong>当设置该标志时，处理器会禁止超级用户程序(例如特权级0的程序)向用户级只读页面执行写操作</strong>。只要是写别人的内存，不管是干嘛的，首先把这个位设置0，写完了再改回来1。</td>
</tr>
<tr>
<td><strong>AM</strong></td>
<td>管理三环下的字节对齐检查。设置为1的时候，用户态当EFLAGS寄存器中的AC标志为1时候是按照段描述的D\B位字节对齐检查的。</td>
</tr>
<tr>
<td><strong>CD</strong></td>
<td>禁止写Cache总开关，相当于PDE,PTE中的PWT和PCD位的总控</td>
</tr>
</tbody></table>
<ol>
<li>PG&#x3D;0且PE&#x3D;0时，处理器工作在实地址模式</li>
<li>PG&#x3D;0且PE&#x3D;1时，处理器工作在没有开启分页机制的保护模式下(目前为止没有任何一个操作系统工作在这个模式)</li>
<li>PG&#x3D;1且PE&#x3D;0时，这种情况不存在，在PE没有开启的情况下，无法开启PG</li>
<li>PG&#x3D;1且PE&#x3D;1时，处理器工作在开启了分页机制的保护模式下</li>
</ol>
<p><strong>当CPL&lt;3的时候</strong></p>
<ul>
<li>如果WP&#x3D;0	可以读写任意用户级物理页，只要线性地址有效</li>
<li>如果WP&#x3D;1	可以读取任意用户即物理页，但对于只读的物理页，则不可以写</li>
</ul>
<h2 id="CR2寄存器"><a href="#CR2寄存器" class="headerlink" title="CR2寄存器"></a>CR2寄存器</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210820175813882.png" alt="image-20210820175813882"></p>
<p>当CPU访问某个无效页面时，会产生缺页异常，此时，CPU会将引起异常的线性地址存放在CR2中。</p>
<p>int 0xE里面有这个函数（函数非常长）的处理流程。</p>
<h2 id="CR4寄存器"><a href="#CR4寄存器" class="headerlink" title="CR4寄存器"></a>CR4寄存器</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210820180052860.png" alt="image-20210820180052860"></p>
<table>
<thead>
<tr>
<th>位</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>PAE</td>
<td>PAE&#x3D;1是2-9-9-12分页  PAE&#x3D;0是10-10-12分页</td>
</tr>
<tr>
<td>PSE</td>
<td>大页的总开关，PDE中的PS位的总开关，只有当PSE为1的时候，PDE中的PS位才有意义。仅PSE和PS位都是1的时候，该PDE指向的物理页才是大页</td>
</tr>
<tr>
<td>PGE</td>
<td>全局页总开关，PTE和PDE的G位总开关。PGE&#x3D;1时，G位才有效。把PGE设为0，进程切换就会刷新全部TLB</td>
</tr>
</tbody></table>
<hr>
<p><strong>控制寄存器更多的细节参考白皮书第三卷</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210820180519008.png" alt="image-20210820180519008"></p>
<h1 id="PDE-PTE中的PWT和PCD位"><a href="#PDE-PTE中的PWT和PCD位" class="headerlink" title="PDE,PTE中的PWT和PCD位"></a>PDE,PTE中的PWT和PCD位</h1><p><strong>cpu缓存Cache</strong></p>
<ol>
<li>CPU缓存是位于CPU与物理内存之间的临时存储器，它的容量比内存小的多，但是交换速度却比内存要快得多。</li>
<li>CPU缓存可以做的很大，有几K，几十K，几百K，甚至上M的也有。</li>
</ol>
<p>CPU缓存与TLB存储的东西的区别</p>
<ul>
<li>TLB：线性地址《—–》物理地址</li>
<li>CPU缓存：物理地址《—–》内容</li>
</ul>
<p>关于Cache的更多细节可以了解因特尔白皮书第三卷</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210820181214528.png" alt="image-20210820181214528"></p>
<p><strong>PWT：Page Write Through</strong></p>
<p>PWT&#x3D;1时。写Cache的时候也要讲数据写入内存中</p>
<p>PWT&#x3D;1时。写Cache的时候只写入Cache</p>
<p><strong>PCS：Page Cache Disable</strong></p>
<p>PCD&#x3D;1时，禁止某个页的写入Cache，直接写内存。</p>
<p>比如：做页表用的页，已经存储在TLB中了，可能不需要再缓存了，因此他们的PCS都是置1的。</p>
<h1 id="保护模式阶段总结"><a href="#保护模式阶段总结" class="headerlink" title="保护模式阶段总结"></a>保护模式阶段总结</h1><p>参见因特尔白皮书第三卷的第3章到第11章</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210820181901011.png" alt="image-20210820181901011"></p>
<p><strong>保护模式实验(两道题)：</strong></p>
<h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 给定一个线性地址，和长度，读取内容；</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ReadMemory</span><span class="params">(OUT BYTE* buffer,IN DWORD dwAddr,IN DWORD dwLeght)</span></span></span><br><span class="line"><span class="function">要求：</span></span><br><span class="line"><span class="function">1) 可以自己指定分页方式。</span></span><br><span class="line"><span class="function">2) 页不存在，要提示，不能报错。</span></span><br><span class="line"><span class="function">3) 可以正确读取数据。</span></span><br></pre></td></tr></table></figure>

<p>残缺版，并未实现所有功能：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __declspec(naked) <span class="built_in">callGate</span>()</span><br><span class="line">&#123;</span><br><span class="line">	_asm</span><br><span class="line">	&#123;</span><br><span class="line">		pushfd;</span><br><span class="line">		pushad;</span><br><span class="line">		mov esi,[esp<span class="number">+0x24</span><span class="number">+0x8</span><span class="number">+0x8</span>];<span class="comment">//dwLeght</span></span><br><span class="line">        mov eax,[esp<span class="number">+0x24</span><span class="number">+0x8</span><span class="number">+0x4</span>];<span class="comment">//dwAddr</span></span><br><span class="line">        mov ecx,[esp<span class="number">+0x24</span><span class="number">+0x8</span>];<span class="comment">//buffer</span></span><br><span class="line">		mov edx,eax;</span><br><span class="line">		<span class="comment">//取gdi</span></span><br><span class="line">		shr edx,<span class="number">21</span>;</span><br><span class="line">		<span class="keyword">and</span> edx,<span class="number">0x1FF</span>;</span><br><span class="line">		shl edx,<span class="number">3</span>;<span class="comment">//*8</span></span><br><span class="line">		mov edx,dword ptr ds:[edx<span class="number">+0xc0600000</span>];</span><br><span class="line">		test edx,<span class="number">1</span>;</span><br><span class="line">		jz __PERROR;</span><br><span class="line">		test dl,dl;</span><br><span class="line">		<span class="comment">//js __bigPage;</span></span><br><span class="line">		<span class="comment">//取gti</span></span><br><span class="line">		mov edx,eax</span><br><span class="line">		shr edx,<span class="number">12</span>;</span><br><span class="line">		<span class="keyword">and</span> edx,<span class="number">0xFFFFF</span>;</span><br><span class="line">		shl edx,<span class="number">3</span>;<span class="comment">//*8</span></span><br><span class="line">		mov edx,dword ptr ds:[edx<span class="number">+0xc0000000</span>];</span><br><span class="line">		test edx,<span class="number">1</span>;</span><br><span class="line">		jz __PERROR;</span><br><span class="line">		<span class="comment">//读数据</span></span><br><span class="line">		mov result,<span class="number">1</span>;</span><br><span class="line">__for:</span><br><span class="line">		mov dl,byte ptr ds:[eax];</span><br><span class="line">		inc eax;</span><br><span class="line">		mov byte ptr ds:[ecx],dl;</span><br><span class="line">		inc ecx;</span><br><span class="line">		dec esi;</span><br><span class="line">		cmp esi,<span class="number">0</span>;</span><br><span class="line">		jnz __for;</span><br><span class="line">		jmp __ret;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//__bigPage:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">__PERROR:</span><br><span class="line">		mov result,<span class="number">0</span></span><br><span class="line">__ret:</span><br><span class="line">		popad;</span><br><span class="line">		popfd;</span><br><span class="line">		retf <span class="number">0xC</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ReadMemory</span><span class="params">(BYTE* buffer,DWORD dwAddr,DWORD dwLeght)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//此处需要对线性地址做是否跨页的判断,决定下面校验几次.</span></span><br><span class="line">	<span class="type">char</span> buff[<span class="number">6</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x48</span>,<span class="number">0</span>&#125;;<span class="comment">//0040EC03`0008100A</span></span><br><span class="line">	_asm</span><br><span class="line">	&#123;</span><br><span class="line">		push dwLeght</span><br><span class="line">		push dwAddr</span><br><span class="line">		push buffer</span><br><span class="line">		call fword ptr[buff];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result;<span class="comment">// 返回值取决于全局变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//构造测试用例</span></span><br><span class="line">	<span class="type">int</span> x=(<span class="type">int</span>)<span class="number">0x12345678</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%X\n&quot;</span>,callGate);</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">	BYTE a[<span class="number">4</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="type">int</span> iRet=<span class="built_in">ReadMemory</span>(a,(DWORD)&amp;x,<span class="number">4</span>);</span><br><span class="line">	<span class="keyword">if</span>(!iRet)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;内存无效\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;用函数读到:%X\n&quot;</span>,*(DWORD*)a);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210824161101189.png" alt="image-20210824161101189"></p>
<p>改成读取0x12345678地址：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210824161159229.png" alt="image-20210824161159229"></p>
<h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.</span> 申请长度为<span class="number">100</span>的DWORD的数组,且每项用该项的地址初始化；</span><br><span class="line">把这个数组所在的物理页挂到<span class="number">0x1000</span>的地址上;</span><br><span class="line">定义一个指针，指向<span class="number">0x1000</span>这个页里的数组所在的地址,用<span class="number">0x1000</span>这个页的线性地址打印出这数组的值；</span><br><span class="line"></span><br><span class="line">要求：</span><br><span class="line">数组所在的物理页，是同一个页；</span><br></pre></td></tr></table></figure>

<p>略</p>
<h1 id="补充知识点"><a href="#补充知识点" class="headerlink" title="补充知识点"></a>补充知识点</h1><h2 id="CPU信息查询"><a href="#CPU信息查询" class="headerlink" title="CPU信息查询"></a>CPU信息查询</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov eax,80000008;//通过eax设置cpuid的参数</span><br><span class="line">cpuid;</span><br><span class="line">;//此后eax获取到的值为0x00003028</span><br><span class="line">;//解读：0x30为线性地址位数，0x28为物理地址位数。</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210822171000712.png" alt="image-20210822171000712"></p>
<p>支持很多cpu信息查询，包括是否支持VT也通过该指令查找</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax,1;</span><br><span class="line">cpuid;</span><br><span class="line">;//此后ecx的第五位为1的话表示CPU支持VT</span><br></pre></td></tr></table></figure>



<h2 id="MDL？物理页地址映射？"><a href="#MDL？物理页地址映射？" class="headerlink" title="MDL？物理页地址映射？"></a>MDL？物理页地址映射？</h2></article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4" title="头像" alt="头像"></a><div class="post-copyright__author_name">ZEROKO14</div><div class="post-copyright__author_desc">zeroko14's blog</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://che77a38.github.io/posts/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://che77a38.github.io/posts/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/')">保护模式</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://che77a38.github.io/posts/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=保护模式&amp;url=https://che77a38.github.io/posts/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://che77a38.github.io" target="_blank">ZEROKO14的个人博客</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E5%86%85%E6%A0%B8%E7%9B%B8%E5%85%B3/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>内核相关<span class="tagsPageCount">5</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/nas%E6%96%B9%E6%A1%88/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">nas方案</div></div></a></div><div class="next-post pull-right"><a href="/posts/%E4%BA%8B%E4%BB%B6%E7%AD%89%E5%BE%85/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">事件等待</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/posts/%E5%8F%A5%E6%9F%84%E8%A1%A8/" title="句柄表"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-11-24</div><div class="title">句柄表</div></div></a></div><div><a href="/posts/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/" title="系统调用"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-11-24</div><div class="title">系统调用</div></div></a></div><div><a href="/posts/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/" title="进程与线程"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-11-24</div><div class="title">进程与线程</div></div></a></div><div><a href="/posts/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/" title="驱动开发"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-11-24</div><div class="title">驱动开发</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description">欢迎来到ZEROKO14的个人博客</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">ZEROKO14</h1><div class="author-info__desc">zeroko14's blog</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/che77a38" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E5%89%8D%E7%9A%84%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="toc-number">1.</span> <span class="toc-text">学习前的环境配置</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E6%9C%BA%E8%B0%83%E8%AF%95%E9%85%8D%E7%BD%AE"><span class="toc-number">1.1.</span> <span class="toc-text">双机调试配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E5%A7%8B%E5%8F%8C%E6%9C%BA%E8%B0%83%E8%AF%95"><span class="toc-number">1.2.</span> <span class="toc-text">开始双机调试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WinDbg%E7%9A%84%E9%80%80%E5%87%BA"><span class="toc-number">1.3.</span> <span class="toc-text">WinDbg的退出</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%93%E6%AE%B5"><span class="toc-number">2.</span> <span class="toc-text">保护模式–段</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.</span> <span class="toc-text">段寄存器结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.1.</span> <span class="toc-text">段寄存器的结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E8%AF%BB%E5%86%99"><span class="toc-number">2.1.2.</span> <span class="toc-text">段寄存器的读写</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">读段寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">写段寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%E5%B1%9E%E6%80%A7%E6%8E%A2%E6%B5%8B"><span class="toc-number">2.1.2.3.</span> <span class="toc-text">段寄存器属性探测</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E6%AE%B5%E9%80%89%E6%8B%A9%E5%AD%90"><span class="toc-number">2.1.3.</span> <span class="toc-text">段描述符与段选择子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">段描述符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E9%80%89%E6%8B%A9%E5%AD%90"><span class="toc-number">2.1.3.2.</span> <span class="toc-text">段选择子</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%88%B0%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.1.3.2.1.</span> <span class="toc-text">加载段描述符到段寄存器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">2.1.3.3.</span> <span class="toc-text">段描述符的属性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#P%E4%BD%8D%E5%92%8CG%E4%BD%8D"><span class="toc-number">2.1.3.3.1.</span> <span class="toc-text">P位和G位</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#P%E4%BD%8D"><span class="toc-number">2.1.3.3.1.1.</span> <span class="toc-text">P位</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#G%E4%BD%8D"><span class="toc-number">2.1.3.3.1.2.</span> <span class="toc-text">G位</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#S%E4%BD%8D%E5%92%8CTYPE%E5%9F%9F"><span class="toc-number">2.1.3.3.2.</span> <span class="toc-text">S位和TYPE域</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#S%E4%BD%8D"><span class="toc-number">2.1.3.3.2.1.</span> <span class="toc-text">S位</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#TYPE%E5%9F%9F"><span class="toc-number">2.1.3.3.2.2.</span> <span class="toc-text">TYPE域</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#D-B%E4%BD%8D"><span class="toc-number">2.1.3.3.3.</span> <span class="toc-text">D&#x2F;B位</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AVL%E5%B1%9E%E6%80%A7"><span class="toc-number">2.1.3.3.4.</span> <span class="toc-text">AVL属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AE%B5%E6%9D%83%E9%99%90%E6%A3%80%E6%9F%A5%EF%BC%88CPL%EF%BC%8CRPL-DPL%EF%BC%89"><span class="toc-number">2.1.3.3.5.</span> <span class="toc-text">段权限检查（CPL，RPL,DPL）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E7%A8%8B%E5%BA%8F%E5%A4%84%E4%BA%8E%E5%87%A0%E7%8E%AF"><span class="toc-number">2.1.3.3.5.1.</span> <span class="toc-text">如何查看程序处于几环</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%AE%B5%E7%9A%84%E6%9D%83%E9%99%90%E6%A3%80%E6%9F%A5"><span class="toc-number">2.1.3.3.5.2.</span> <span class="toc-text">数据段的权限检查</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AF%8D%E6%B1%87%E6%80%BB%E7%BB%93"><span class="toc-number">2.1.3.3.5.3.</span> <span class="toc-text">词汇总结</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%B7%A8%E6%AE%B5"><span class="toc-number">2.2.</span> <span class="toc-text">代码跨段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E9%97%B4%E7%9A%84%E8%B7%B3%E8%BD%AC-%E6%AE%B5%E9%97%B4%E8%B7%B3%E8%BD%AC%E9%9D%9E%E8%B0%83%E7%94%A8%E9%97%A8%E4%B9%8B%E7%B1%BB%E7%9A%84"><span class="toc-number">2.2.1.</span> <span class="toc-text">代码间的跳转(段间跳转	非调用门之类的)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">执行流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E3%80%90%E6%80%BB%E7%BB%93%E3%80%91"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">【总结】</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E3%80%90%E6%9C%80%E7%BB%88%E6%80%BB%E7%BB%93%E3%80%91"><span class="toc-number">2.2.1.3.</span> <span class="toc-text">【最终总结】</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C"><span class="toc-number">2.2.1.4.</span> <span class="toc-text">实验</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%95%BF%E8%B0%83%E7%94%A8%E4%B8%8E%E7%9F%AD%E8%B0%83%E7%94%A8"><span class="toc-number">2.3.</span> <span class="toc-text">长调用与短调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%AD%E8%B0%83%E7%94%A8"><span class="toc-number">2.3.1.</span> <span class="toc-text">短调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%BF%E8%B0%83%E7%94%A8-%E8%B7%A8%E6%AE%B5%E4%B8%8D%E6%8F%90%E6%9D%83"><span class="toc-number">2.3.2.</span> <span class="toc-text">长调用(跨段不提权)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%BF%E8%B0%83%E7%94%A8-%E8%B7%A8%E6%AE%B5%E5%B9%B6%E6%8F%90%E6%9D%83"><span class="toc-number">2.3.3.</span> <span class="toc-text">长调用(跨段并提权)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E6%80%BB%E7%BB%93%E3%80%91-1"><span class="toc-number">2.3.4.</span> <span class="toc-text">【总结】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E9%97%A8"><span class="toc-number">2.4.</span> <span class="toc-text">调用门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E9%97%A8-%E6%97%A0%E5%8F%82"><span class="toc-number">2.4.1.</span> <span class="toc-text">调用门(无参)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%A8%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">2.4.1.1.</span> <span class="toc-text">门描述符的结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E9%97%A8%E6%8C%87%E4%BB%A4%E6%B5%81%E7%A8%8B"><span class="toc-number">2.4.1.2.</span> <span class="toc-text">调用门指令流程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%80%90%E9%87%8D%E7%82%B9%E3%80%91%E8%B0%83%E7%94%A8%E9%97%A8%E6%9D%83%E9%99%90%E7%9B%B8%E5%85%B3"><span class="toc-number">2.4.1.2.1.</span> <span class="toc-text">【重点】调用门权限相关</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-1"><span class="toc-number">2.4.1.3.</span> <span class="toc-text">实验</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E9%97%A8-%E6%9C%89%E5%8F%82"><span class="toc-number">2.4.2.</span> <span class="toc-text">调用门(有参)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-2"><span class="toc-number">2.4.2.1.</span> <span class="toc-text">实验</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E3%80%90%E6%80%BB%E7%BB%93%E3%80%91-2"><span class="toc-number">2.4.2.2.</span> <span class="toc-text">【总结】</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E9%97%A8"><span class="toc-number">2.5.</span> <span class="toc-text">中断门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E6%8C%87%E4%BB%A4"><span class="toc-number">2.5.1.</span> <span class="toc-text">中断指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E9%97%A8%E7%9A%84%E5%A0%86%E6%A0%88%E5%92%8C%E8%BF%94%E5%9B%9E"><span class="toc-number">2.5.2.</span> <span class="toc-text">中断门的堆栈和返回</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IDT"><span class="toc-number">2.5.3.</span> <span class="toc-text">IDT</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IDT%E8%A1%A8%E7%9A%84%E6%9E%84%E6%88%90"><span class="toc-number">2.5.3.1.</span> <span class="toc-text">IDT表的构成</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E9%97%A8%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">2.5.4.</span> <span class="toc-text">中断门描述符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E9%97%A8%E6%8F%90%E6%9D%83%E5%AE%9E%E9%AA%8C"><span class="toc-number">2.5.4.1.</span> <span class="toc-text">中断门提权实验</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E9%97%A8%E4%B8%8E%E4%B8%AD%E6%96%AD%E9%97%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.5.4.2.</span> <span class="toc-text">调用门与中断门的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E3%80%90%E9%87%8D%E7%82%B9%E7%90%86%E8%A7%A3%E3%80%91%E5%90%84%E7%A7%8D%E8%BF%94%E5%9B%9E%E5%8A%A0%E6%B7%B1%E7%90%86%E8%A7%A3"><span class="toc-number">2.5.4.3.</span> <span class="toc-text">【重点理解】各种返回加深理解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%80%90%E5%AE%9E%E9%AA%8C%E3%80%91%E5%9C%A8%E8%B0%83%E7%94%A8%E9%97%A8%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%BD%BF%E7%94%A8IRETD%E8%BF%94%E5%9B%9E%EF%BC%8C%E5%9C%A8%E4%B8%AD%E6%96%AD%E9%97%A8%E4%B8%AD%E5%AE%9E%E7%8E%B0%E7%94%A8RETF%E8%BF%94%E5%9B%9E"><span class="toc-number">2.5.4.3.1.</span> <span class="toc-text">【实验】在调用门中实现使用IRETD返回，在中断门中实现用RETF返回</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E9%97%A8%E7%94%A8RETF%E8%BF%94%E5%9B%9E"><span class="toc-number">2.5.4.3.1.1.</span> <span class="toc-text">中断门用RETF返回</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E9%97%A8%E7%94%A8iretd-%E8%BF%94%E5%9B%9E"><span class="toc-number">2.5.4.3.1.2.</span> <span class="toc-text">调用门用iretd 返回</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%B7%E9%98%B1%E9%97%A8"><span class="toc-number">2.6.</span> <span class="toc-text">陷阱门</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E6%AE%B5TSS-%E9%9A%BE%E7%82%B9%E9%9D%9E%E9%87%8D%E7%82%B9"><span class="toc-number">2.7.</span> <span class="toc-text">任务段TSS(难点非重点)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TSS%E5%92%8CTR%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.7.1.</span> <span class="toc-text">TSS和TR寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TSS%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">2.7.1.1.</span> <span class="toc-text">TSS的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CPU%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0TSS%E7%9A%84"><span class="toc-number">2.7.1.2.</span> <span class="toc-text">CPU是如何找到TSS的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TSS%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">2.7.1.3.</span> <span class="toc-text">TSS段描述符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TR%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E8%AF%BB%E5%86%99"><span class="toc-number">2.7.1.4.</span> <span class="toc-text">TR寄存器的读写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9TR%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.7.1.5.</span> <span class="toc-text">修改TR寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CALL-FAR%E6%88%96%E8%80%85JMP-FAR%E4%B8%80%E4%B8%AA%E4%BB%BB%E5%8A%A1%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%9A%84%E4%B8%8D%E5%90%8C%E7%82%B9%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">2.7.1.6.</span> <span class="toc-text">CALL FAR或者JMP FAR一个任务段描述符的不同点（重点）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TSS%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%AE%9E%E9%AA%8C"><span class="toc-number">2.7.1.7.</span> <span class="toc-text">TSS段描述符实验</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#CALL%E5%AE%9E%E9%AA%8C%E8%BF%94%E5%9B%9E"><span class="toc-number">2.7.1.7.1.</span> <span class="toc-text">CALL实验返回</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#JMP%E5%AE%9E%E9%AA%8C%E8%BF%94%E5%9B%9E"><span class="toc-number">2.7.1.7.2.</span> <span class="toc-text">JMP实验返回</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#JMP%E5%AE%9E%E9%AA%8C%E4%B8%ADtest%E5%A4%B4%E6%B7%BB%E5%8A%A0int%E8%A7%82%E5%AF%9F%E5%AE%9E%E9%AA%8C"><span class="toc-number">2.7.1.7.2.1.</span> <span class="toc-text">JMP实验中test头添加int观察实验</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E9%97%A8"><span class="toc-number">2.8.</span> <span class="toc-text">任务门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E9%97%A8%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">2.8.1.</span> <span class="toc-text">任务门描述符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E9%97%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">2.8.2.</span> <span class="toc-text">任务门的执行过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0%EF%BC%9A%E5%AE%9E%E7%8E%B0%E4%BB%BB%E5%8A%A1%E9%97%A8%E8%BF%9B1%E7%8E%AF%E3%80%82"><span class="toc-number">2.8.3.</span> <span class="toc-text">课后练习：实现任务门进1环。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%86%E5%90%91int-8%E5%AE%9E%E9%AA%8C"><span class="toc-number">2.8.4.</span> <span class="toc-text">逆向int 8实验</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LDT%E7%9B%B8%E5%85%B3"><span class="toc-number">2.9.</span> <span class="toc-text">LDT相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E6%9E%84%E5%BB%BALDT%E8%A1%A8%E5%92%8C%E5%85%B6%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%AE%9E%E9%AA%8C"><span class="toc-number">2.9.1.</span> <span class="toc-text">自己构建LDT表和其中的数据段描述符实验</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%93%E9%A1%B5"><span class="toc-number">3.</span> <span class="toc-text">保护模式–页</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-10-12%E5%88%86%E9%A1%B5"><span class="toc-number">3.1.</span> <span class="toc-text">10-10-12分页</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PDE%E4%B8%8EPTE"><span class="toc-number">3.1.1.</span> <span class="toc-text">PDE与PTE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E7%9B%AE%E5%BD%95%E8%A1%A8PDT%E5%9F%BA%E5%9D%80-%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80"><span class="toc-number">3.1.2.</span> <span class="toc-text">页目录表PDT基址(线性地址)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8PTT%E5%9F%BA%E5%9D%80-%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80"><span class="toc-number">3.1.3.</span> <span class="toc-text">页表PTT基址(线性地址)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E5%AE%9E%E9%AA%8C"><span class="toc-number">3.1.3.1.</span> <span class="toc-text">小实验</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%8C%E6%8F%A1%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E6%89%80%E6%9C%89%E7%9A%84%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E8%AF%BB%E5%86%99%E6%9D%83%E9%99%90%E3%80%90%E5%85%AC%E5%BC%8F%E6%80%BB%E7%BB%93%E3%80%91"><span class="toc-number">3.1.3.2.</span> <span class="toc-text">掌握一个进程所有的物理内存读写权限【公式总结】</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-3"><span class="toc-number">3.1.3.2.1.</span> <span class="toc-text">实验</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-10-12%E5%86%85%E6%A0%B8%E9%80%86%E5%90%91%E5%88%86%E6%9E%90MmIsAddressValid%E5%87%BD%E6%95%B0"><span class="toc-number">3.1.3.3.</span> <span class="toc-text">10-10-12内核逆向分析MmIsAddressValid函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8IDA"><span class="toc-number">3.1.3.3.1.</span> <span class="toc-text">用IDA</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8windbg"><span class="toc-number">3.1.3.3.2.</span> <span class="toc-text">用windbg</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-9-9-12%E5%88%86%E9%A1%B5"><span class="toc-number">3.2.</span> <span class="toc-text">2-9-9-12分页</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E7%9B%AE%E5%BD%95%E6%8C%87%E9%92%88%E8%A1%A8%E9%A1%B9Page-Dircetory-Point-Table-Entry"><span class="toc-number">3.2.1.</span> <span class="toc-text">页目录指针表项Page-Dircetory-Point-Table Entry</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PDE%E7%BB%93%E6%9E%84"><span class="toc-number">3.2.2.</span> <span class="toc-text">PDE结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PTE%E7%BB%93%E6%9E%84"><span class="toc-number">3.2.3.</span> <span class="toc-text">PTE结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#X-D%E6%A0%87%E5%BF%97%E4%BD%8D"><span class="toc-number">3.2.4.</span> <span class="toc-text">X&#x2F;D标志位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-9-12%E5%86%85%E6%A0%B8%E9%80%86%E5%90%91%E5%88%86%E6%9E%90MmIsAddressValid%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.5.</span> <span class="toc-text">2-9-9-12内核逆向分析MmIsAddressValid函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%81%E8%B7%AF%E8%BD%AC%E6%8D%A2%E7%BC%93%E5%86%B2TLB"><span class="toc-number">3.3.</span> <span class="toc-text">旁路转换缓冲TLB</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TLB%E7%A7%8D%E7%B1%BB"><span class="toc-number">3.3.1.</span> <span class="toc-text">TLB种类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TLB%E7%9B%B8%E5%85%B3%E5%AE%9E%E9%AA%8C"><span class="toc-number">3.3.2.</span> <span class="toc-text">TLB相关实验</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%93%E9%AA%8CTLB%E7%9A%84%E5%AD%98%E5%9C%A8"><span class="toc-number">3.3.2.1.</span> <span class="toc-text">体验TLB的存在</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E9%A1%B5%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-number">3.3.2.2.</span> <span class="toc-text">全局页的意义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#INVLPG%E6%8C%87%E4%BB%A4%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-number">3.3.2.3.</span> <span class="toc-text">INVLPG指令的意义</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%BC%82%E5%B8%B8"><span class="toc-number">4.</span> <span class="toc-text">中断与异常</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD"><span class="toc-number">4.1.</span> <span class="toc-text">中断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">4.2.</span> <span class="toc-text">异常</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8CR"><span class="toc-number">5.</span> <span class="toc-text">控制寄存器CR</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CR0%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">5.1.</span> <span class="toc-text">CR0寄存器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CR2%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">5.2.</span> <span class="toc-text">CR2寄存器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CR4%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">5.3.</span> <span class="toc-text">CR4寄存器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PDE-PTE%E4%B8%AD%E7%9A%84PWT%E5%92%8CPCD%E4%BD%8D"><span class="toc-number">6.</span> <span class="toc-text">PDE,PTE中的PWT和PCD位</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93"><span class="toc-number">7.</span> <span class="toc-text">保护模式阶段总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%A2%98"><span class="toc-number">7.1.</span> <span class="toc-text">第一题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%A2%98"><span class="toc-number">7.2.</span> <span class="toc-text">第二题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">8.</span> <span class="toc-text">补充知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU%E4%BF%A1%E6%81%AF%E6%9F%A5%E8%AF%A2"><span class="toc-number">8.1.</span> <span class="toc-text">CPU信息查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MDL%EF%BC%9F%E7%89%A9%E7%90%86%E9%A1%B5%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%EF%BC%9F"><span class="toc-number">8.2.</span> <span class="toc-text">MDL？物理页地址映射？</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/avalonia/" title="avalonia">avalonia</a><time datetime="2024-09-11T14:51:13.000Z" title="发表于 2024-09-11 22:51:13">2024-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/%E8%A7%86%E9%A2%91%E6%95%88%E6%9E%9C/" title="PR">PR</a><time datetime="2024-07-18T07:06:08.330Z" title="发表于 2024-07-18 15:06:08">2024-07-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/%E5%89%8D%E7%AB%AF/" title="WEB前端">WEB前端</a><time datetime="2024-07-18T07:06:08.323Z" title="发表于 2024-07-18 15:06:08">2024-07-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/slidev/" title="slidev">slidev</a><time datetime="2024-07-18T07:06:08.319Z" title="发表于 2024-07-18 15:06:08">2024-07-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="C++多线程">C++多线程</a><time datetime="2024-07-18T07:05:59.794Z" title="发表于 2024-07-18 15:05:59">2024-07-18</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2024 By <a class="footer-bar-link" href="/" title="ZEROKO14" target="_blank">ZEROKO14</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu"></a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">57</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">48</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">6</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size: 0.88rem;">C#<sup>3</sup></a><a href="/tags/C/" style="font-size: 0.88rem;">C++<sup>5</sup></a><a href="/tags/CSS/" style="font-size: 0.88rem;">CSS<sup>1</sup></a><a href="/tags/CSharp/" style="font-size: 0.88rem;">CSharp<sup>1</sup></a><a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 0.88rem;">C语言<sup>1</sup></a><a href="/tags/FPS/" style="font-size: 0.88rem;">FPS<sup>1</sup></a><a href="/tags/HTML/" style="font-size: 0.88rem;">HTML<sup>1</sup></a><a href="/tags/JavaScript/" style="font-size: 0.88rem;">JavaScript<sup>1</sup></a><a href="/tags/MFC/" style="font-size: 0.88rem;">MFC<sup>1</sup></a><a href="/tags/PE/" style="font-size: 0.88rem;">PE<sup>1</sup></a><a href="/tags/QT/" style="font-size: 0.88rem;">QT<sup>1</sup></a><a href="/tags/WPF/" style="font-size: 0.88rem;">WPF<sup>3</sup></a><a href="/tags/ai/" style="font-size: 0.88rem;">ai<sup>1</sup></a><a href="/tags/cmake/" style="font-size: 0.88rem;">cmake<sup>1</sup></a><a href="/tags/doxygen/" style="font-size: 0.88rem;">doxygen<sup>1</sup></a><a href="/tags/git/" style="font-size: 0.88rem;">git<sup>1</sup></a><a href="/tags/json/" style="font-size: 0.88rem;">json<sup>1</sup></a><a href="/tags/linux/" style="font-size: 0.88rem;">linux<sup>1</sup></a><a href="/tags/next/" style="font-size: 0.88rem;">next<sup>1</sup></a><a href="/tags/ppt/" style="font-size: 0.88rem;">ppt<sup>1</sup></a><a href="/tags/slidev/" style="font-size: 0.88rem;">slidev<sup>1</sup></a><a href="/tags/vue/" style="font-size: 0.88rem;">vue<sup>1</sup></a><a href="/tags/xml/" style="font-size: 0.88rem;">xml<sup>1</sup></a><a href="/tags/yaml/" style="font-size: 0.88rem;">yaml<sup>1</sup></a><a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 0.88rem;">代码规范<sup>1</sup></a><a href="/tags/%E5%86%85%E6%A0%B8/" style="font-size: 0.88rem;">内核<sup>2</sup></a><a href="/tags/%E5%86%85%E6%A0%B8%E7%9B%B8%E5%85%B3/" style="font-size: 0.88rem;">内核相关<sup>5</sup></a><a href="/tags/%E5%8A%A0%E8%A7%A3%E5%AF%86/" style="font-size: 0.88rem;">加解密<sup>1</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 0.88rem;">多线程<sup>1</sup></a><a href="/tags/%E5%BC%80%E5%8F%91/" style="font-size: 0.88rem;">开发<sup>4</sup></a><a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 0.88rem;">数学<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 0.88rem;">数据库<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 0.88rem;">数据结构<sup>1</sup></a><a href="/tags/%E6%9E%B6%E6%9E%84/" style="font-size: 0.88rem;">架构<sup>1</sup></a><a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 0.88rem;">正则表达式<sup>1</sup></a><a href="/tags/%E7%9B%91%E6%8E%A7/" style="font-size: 0.88rem;">监控<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 0.88rem;">算法<sup>1</sup></a><a href="/tags/%E7%AE%A1%E7%90%86/" style="font-size: 0.88rem;">管理<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 0.88rem;">网络<sup>2</sup></a><a href="/tags/%E9%80%86%E5%90%91/" style="font-size: 0.88rem;">逆向<sup>2</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.cbd.int/mathjax@3.2.2/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.cbd.int/mermaid@10.2.4/dist/mermaid.min.js').then(runMermaid)
  }

  anzhiyu.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>