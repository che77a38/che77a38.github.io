<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>C++基础 | ZEROKO14的个人博客</title><meta name="author" content="ZEROKO14"><meta name="copyright" content="ZEROKO14"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#18171d"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="C++基础"><meta name="application-name" content="C++基础"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#18171d"><meta property="og:type" content="article"><meta property="og:title" content="C++基础"><meta property="og:url" content="https://che77a38.github.io/posts/C++%E5%9F%BA%E7%A1%80/index.html"><meta property="og:site_name" content="ZEROKO14的个人博客"><meta property="og:description" content="C++概述 “c++”中的++来自于c语言中的递增运算符++，该运算符将变量加1。c++起初也叫”c with class”.通过名称表明，c++是对C的扩展，因此c++是c语言的超集，这意味着任何有效的c程序都是有效的c++程序。c++程序可以使用已有的c程序库。    库是编程模块的集合，可以在"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4"><meta property="article:author" content="ZEROKO14"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4"><meta name="description" content="C++概述 “c++”中的++来自于c语言中的递增运算符++，该运算符将变量加1。c++起初也叫”c with class”.通过名称表明，c++是对C的扩展，因此c++是c语言的超集，这意味着任何有效的c程序都是有效的c++程序。c++程序可以使用已有的c程序库。    库是编程模块的集合，可以在"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://che77a38.github.io/posts/C++%E5%9F%BA%E7%A1%80/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2024/07/27/125766904/ba62475f396df9de3316a08ed9e65d86_5680958632268053399..png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":true,"limitCount":50,"languages":{"author":"作者: ZEROKO14","link":"链接: ","source":"来源: ZEROKO14的个人博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'ZEROKO14的个人博客',
  title: 'C++基础',
  postAI: '',
  pageFillDescription: 'C++概述, 可移植性和标准, 简单的c++程序, 注意：, c++头文件为什么没有.h？, using namespace std 是什么?, 面向过程思想, 面向对象思想, 面向对象三大特性, , , , C++对C的扩展, 作用域运算符, 无限定名字查找, 名字控制, C++命名空间(namespace), 命名空间使用语法, 创建一个命名空间, using声明, using编译指令, C++对C语言的增强以及扩展, 全局变量检测增强, 函数检测增强, 类型转换检测增强, struct增强, bool数据类型扩展, 三目运算符增强, [左值和右值概念], Cx2FC++中const的区别, C中的const, C++中的const, Cx2FC++中const异同总结, 链接属性区别, 修改区别, C++中const分配内存的情况, 尽量以const替换define, 引用(reference), 引用基本用法, 函数中的引用, 引用做参数, 引用做返回值, 引用的本质, 指针引用, 常量引用, 内联函数(inline function), 内联函数的引出, 内联函数基本概念, 内联函数和编译器, 函数的默认参数, 函数的占位参数, 函数重载(overload), 函数重载基本语法, 函数重载实现原理, extern C浅析, 终极解决方案：, 类和对象, 类的封装, 封装, 访问权限, 尽量将成员变量设置为private, 对象的构造和析构, 构造函数和析构函数, 构造函数的分类及调用, 无参构造调用方式注意点：（重点）, 有参构造调用方法, [注意事项1], [注意事项2], [注意事项3], 析构函数的调用时机, 显示调用析构带来的后果, 拷贝构造函数的调用时机, 构造函数自动生成规则, 深拷贝和浅拷贝, 浅拷贝, 深拷贝, explicit关键字, 初始化列表, 类对象作为成员, 动态对象创建, C动态分配内存方法, new operator, malloc和new的区别, placement new机制, delete operator, 用于数组的new和delete, [注意], 使用new和delete采用相同形式, 嵌套类和局部类, 静态成员（static）, 静态成员变量, 静态成员函数, const静态成员属性, 静态成员实现单例模式, C++面向对象模型初探, 成员变量和函数的存储, this指针, this指针工作原理, this指针的使用, 空指针访问成员函数, 常量关键词(const), const修饰成员函数, const修饰对象(常对象), 友元, 友元语法, 运算符重载, 基本语法：, 可重载的运算符, 加号运算符重载, 左移运算符ltlt重载, 成员函数方式重载左移运算符：, 全局函数方式重载左移运算符, 自增自减(++x2F–)运算符重载, 指针运算符(*、-gt)重载, 赋值运算符x3D重载, 下标运算符[]重载, 关系运算符重载, 函数调用运算符()重载, 不要重载ampamp、||, 运算符重载总结, 附录：运算符和结合性, 继承, 继承基本概念, 派生类访问控制, 虚基类的构造函数, 多态, 父类引用x2F指向子类对象的四种方式, 动态多态原理, 原理详解, 向上类型转换及问题, 迟绑定实现方案原理, 内存布局详解, 单继承中虚函数, 多重继承中的虚函数, 多重继承中同时存在虚继承和虚函数, 多继承中的虚表内存布局, 多态的实际开发意义, 纯虚函数和抽象类, 纯虚函数和多继承, 只有纯虚函数的抽象类, 虚析构和纯虚析构, 重写 重载 重定义 区别, 多态与别的语言的区别盘点, 位域, 模板, 函数模板, 函数模板和普通函数区别, 函数模板和普通函数的调用规则, 函数模板机制原理剖析, 函数模板分文件编写, 函数模板特化, 类模板, 类模板做函数参数, 类模板和派生, 类模板派生普通类, 类模板派生类模板, 类模板中的成员函数类外实现, 类模板的分文件编写, 类模板和静态成员, 类模板中的友元函数, 动态数组模板类, 头文件dynamicArray.h, 源文件dynamicArray.hpp, main文件main.cpp, 类模板特化, 模板模板参数, 类型转换, 静态类型转换(static_cast), 动态类型转换(dynamic_cast), 常量转换(const_cast), 重新解释转换(reinterpret_cast), 异常, 异常的基本概念, c++异常机制相比C语言异常处理的优势?, 异常基本语法, 异常严格类型匹配, 栈解旋(unwinding), 异常接口声明, 异常变量生命周期, 异常的多态使用, 异常原理, 使用了异常处理机制的C++函数调用, 栈回退（stack unwind）, 异常捕获, 抛出异常, 总结, Windows中的结构化异常处理, 开销分析, C++标准异常库, 标准库介绍, 编写自己的异常类, 如何编写自己的异常类？, Function-try-block, 异常安全, C++输入和输出流, 流的概念和流类库的结构, 与iostream类库有关的头文件, 在iostream头文件中定义的流对象, 在iostream头文件中重载运算符, 标准Ix2FO流, cout流对象, cerr流对象, clog流对象, 标准输入流, 标准输出流, 格式化输出, 使用流对象的有关成员函数, 控制符格式化输出, 对程序的几点说明(注意点), 文件读写, 文件流类和文件流对象, C++打开文件, C++关闭文件, C++对ASCII文件的读写操作, 4种ASCII读写方式, C++对二进制文件的读写操作, 用成员函数read和write读写二进制文件, 断言, C++与C性能分析, 将C源代码封装成C++类代码, 内存泄露检测知识点(调试技巧注意点篇), VC编译选项基本运行时检查的作用, C++如何使用第三方库, homebrew, 配合cmake使用开发包, vcpkg包管理器, 下载与安装, 使用, 集成使用, 与CMAKE配合使用, vcpkg与homebrew的区别, boost库, C++通用开源框架和库, 人工智能, 异步事件循环, 音频, 生物信息, 压缩和归档库, 并发执行和多线程, 密码学, 数据库, 调试库, 图形用户界面, 图形, 图像处理, 国际化, 日志, 机器学习, 数学, 多媒体, 网络, 物理学, 机器人学, 科学计算, 脚本, 序列化, 视频, 虚拟机, Web应用框架, XML, 多项混杂, 编译器, 在线Cx2FC++编译器列表, Cx2FC++调试器列表, Cx2FC++集成开发环境（IDE）列表, 构建系统, 静态代码分析概述中的来自于语言中的递增运算符该运算符将变量加起初也叫通过名称表明是对的扩展因此是语言的超集这意味着任何有效的程序都是有效的程序程序可以使用已有的程序库库是编程模块的集合可以在程序中调用它们库对很多常见的编程问题提供了可靠的解决方法因此可以节省程序员大量的时间和工作量泛型编程面向对象融合了种不同的编程方式语言代表的过程性语言在语言基础上添加的类代表的面向对象语言模板支持的泛型编程可移植性和标准程序是否可移植性有两个问题需要解决第一是硬件针对特定硬件编程的程序是不可移植的第二语言的实现为了兼容需要制定标准新特性标准排序时间排序已有的特性异常运行阶段类型识别模板标准模板库对于传统的结构化语言我们向来没有太多的疑惑函数调用那么自然而明显只是从程序的某一个地点调到另一个地点去执行但是对于面向对象语言我们疑惑就会很多其原因就是编译器为我们程序员做了太多隐藏的工作构造函数析构函数虚函数继承多态有时候它为我们合成出一些额外的函数有时候它又偷偷在我们写的函数里放进更多的操作有时候也会给我们的对象里放进一些奇妙的东西使得我们的时候结果可我们预期不一样简单的程序表示刷新缓冲区并且换行注意头文件为什么没有在语言中头文件使用扩展名将其作为一种通过名称标识文件类型的简单方式但是得用法改变了头文件没有扩展名但是有些语言的头文件被转换为的头文件这些文件被重新命名丢掉了扩展名使之成为风格头文件并在文件名称前面加上前缀表明来自语言例如版本的为由于使用不同的扩展名来表示不同文件类型因此用一些特殊的扩展名如或表示的头文件也是可以的标准委员会也认为是可以的但是关键问题是用哪个比较好最后一致同意不适用任何扩展名头文件类型约定示例说明旧式风格以结尾程序可用旧式风格以结尾程序可用新式风格无扩展名程序可用使用转换后的加上前缀无扩展名程序可用可使用非特性如是什么是指标识符的各种可见范围命名空间用关键字来定义命名空间是的一种机制用来把单个标识符下的大量有逻辑联系的程序实体组合到一起此标识符作为此组群的名字面向过程思想面向过程是一种以过程为中心的编程思想通过分析出解决问题所需要的步骤然后用函数把这些步骤一步一步实现使用的时候一个一个依次调用就可以了面向过程编程思想的核心功能分解自顶向下逐层细化程序数据结构算法面向过程编程语言存在的主要缺点是不符合人的思维习惯而是要用计算机的思维方式去处理问题而且面向过程编程语言重用性低维护困难面向对象思想面向对象编程简称技术是开发计算机应用程序的一种新方法新思想过去的面向过程编程常常会导致所有的代码都包含在几个模块中使程序难以阅读和维护在做一些修改时常常牵一动百使以后的开发和维护难以为继而使用技术常常要使用许多代码模块每个模块都只提供特定的功能它们是彼此独立的这样就增大了代码重用的几率更加有利于软件的开发维护和升级在面向对象中算法与数据结构被看做是一个整体称作对象现实世界中任何类的对象都具有一定的属性和操作也总能用数据结构与算法两者合一地来描述所以可以用下面的等式来定义对象和程序对象算法数据结构程序对象对象面向对象编程思想的核心应对变化提高复用面向对象三大特性封装特性把客观事物封装成抽象的类并且类可以把自己的数据和方法只让可信的类或者对象操作对不可信的进行信息隐藏类将成员变量和成员函数封装在类的内部根据需要设置访问权限通过成员函数管理内部状态继承特性继承所表达的是类之间相关的关系这种关系使得对象可以继承另外一类对象的特征和能力继承的作用避免公用代码的重复开发减少代码和数据冗余多态特性多态性可以简单地概括为一个接口多种方法字面意思为多种形态程序在运行时才决定调用的函数它是面向对象编程领域的核心概念对的扩展作用域运算符全局变量局部变量全局被隐藏通常情况下如果有两个同名变量一个是全局变量另一个是局部变量那么局部变量在其作用域内具有较高的优先权它将屏蔽全局变量全局变量局部变量和全局变量同名打印局部变量局部变量打印全局变量全局变量这个例子可以看出作用域运算符可以用来解决局部变量与全局变量的重名问题即在局部变量的作用域内可用对被屏蔽的同名的全局变量进行访问无限定名字查找如果限定作用符左侧留空只会在全局命名空间查找名字控制创建名字是程序设计过程中一项最基本的活动当一个项目很大时它会不可避免地包含大量名字允许我们对名字的产生和名字的可见性进行控制我们之前在学习语言可以通过关键字来使得名字只得在本编译单元内可见在中我们将通过一种通过命名空间来控制对名字的访问命名空间作用解决命名冲突在中名称可以是符号常量变量函数结构枚举类和对象等等工程越大名称互相冲突性的可能性越大另外使用多个厂商的类库时也可能导致名称冲突为了避免在大规模程序的设计中以及在程序员使用各种各样的库时这些标识符的命名发生冲突标准引入关键字命名空间名字空间名称空间可以更好地控制标识符的作用域命名空间使用语法命名空间用途解决名称冲突命名空间下可以存放变量函数结构体类命名空间必须要声明在全局作用域命名空间可以嵌套命名空间命名空间是开放的可以随时将新成员添加到命名空间下命名空间是可以匿名的创建一个命名空间命名空间只能全局范围内定义以下错误写法命名空间可嵌套命名空间命名空间是开放的即可以随时把新的成员加入已有的命名空间中声明和实现可分离无名命名空间意味着命名空间中的标识符只能在本文件内访问相当于给这个标识符加上了使得其可以作为内部连接这两个都可以访问命名空间别名声明声明可使得指定的标识符可用通过命名空间域运算符声明不可直接访问同名冲突相同作用域注意同名冲突声明碰到函数重载如果命名空间包含一组用相同名字重载的函数声明就声明了这个重载函数的所有集合编译指令编译指令使整个命名空间标识符可用不会产生二义性二义性产生不知道调用还是的理解注意点声明和普通声明在一个作用域同时存在会报错但编译指令和普通声明在一个作用域同时存在时优先普通声明若不存在普通声明此时才使用使用的命名空间中的声明没有普通声明下两个编译指令会报错注意使用声明或编译指令会增加命名冲突的可能性也就是说如果有名称空间并在代码中使用作用域解析运算符则不会出现二义性我们刚讲的一些东西一开始会觉得难一些这些东西以后还是挺常用只要理解了它们的工作机理使用它们非常简单需要记住的关键问题是当引入一个全局的编译指令时就为该文件打开了该命名空间它不会影响任何其他的文件所以可以在每一个实现文件中调整对命名空间的控制比如如果发现某一个实现文件中有太多的指令而产生的命名冲突就要对该文件做个简单的改变通过明确的限定或者声明来消除名字冲突这样不需要修改其他的实现文件对语言的增强以及扩展全局变量检测增强赋值当做定义没有赋值当做声明此代码在下编译失败在下编译通过函数检测增强没有写类型可以是任意类型没有写类型可以是任意类型没有写参数代表可以传任何类型的实参语言如果函数没有参数建议写代表没有参数以上代码编译器编译可通过编译器无法编译通过在语言中表示返回值为接受任意参数的函数表示返回值为的无参函数汇编本质并没有区别编译器也不会报错都是接受任意参数在中和具有相同的意义都表示返回值为的无参函数类型转换检测增强在不同类型的变量一般是不能直接赋值的需要相应的强转以上代码编译器编译可通过编译器无法编译通过增强中定义结构体变量需要加上关键字不需要中的结构体只能定义成员变量不能定义成员函数即可以定义成员变量也可以定义成员函数结构体中即可以定义成员变量也可以定义成员函数中定义结构体变量不需要加关键字数据类型扩展标准的类型有两种内建的常量转换为整数和转换为整数表示状态这三个名字都是关键字类型只有两个值值值类型占个字节大小给类型赋值时非值会自动转换为值会自动转换为类型占一个字节大小语言中没有这种类型给类型赋值时非值会自动转换为值会自动转换三目运算符增强语言三目运算表达式返回值为数据值为右值不能赋值思考一个问题三目运算表达式返回的是什么返回的是右值语言三目运算表达式返回值为变量本身引用为左值可以赋值思考一个问题三目运算表达式返回的是什么返回的是返回的是左值变量的引用返回的是左值变量的引用语言中等价于中左值和右值概念在中可以放在赋值操作符左边的是左值可以放到赋值操作符右面的是右值有些变量即可以当左值也可以当右值左值为代表表示内存可以寻址可以赋值右值为代表就是可以知道它的值比如在内存中有地址没有但是可以到它的值理解左值引用编译器对他做的操作是自动提领就是自动加个操作所以左值引用更像一个常量指针它和常量指针唯一的区别就在于他不用每次都让我们自己写了除此以外真的没什么区别在这里就是一个右值它是活在寄存器里的一个值他在内存里根本没有存在的位置你无法对它取地址这就是个右值中的区别中的常量的引进是在早期版本中当时标准规范正在制定那时尽管委员会决定在中引入但是他们中的理解为一个不能改变的普通变量也就是认为应该是一个只读变量既然是变量那么就会给分配内存修饰全局变量时默认是外部链接属性看似是一件合理的编码但是这将得出一个错误因为占用某块内存所以编译器不知道它在编译时的值是多少中的在中一个不一定创建内存空间而在中一个总是需要一块内存空间在中是否为常量分配内存空间依赖于如何使用一般说来如果一个仅仅用来把一个名字用一个值代替就像使用一样那么该存储局空间就不必创建如果存储空间没有分配内存的话在进行完数据类型检查后为了代码更加有效值也许会折叠到代码中不过取一个地址或者把它定义为则会为该创建内存空间在中出现在所有函数之外的作用于整个文件也就是说它在该文件外不可见默认为内部连接中其他的标识符一般默认为外部连接中异同总结链接属性区别语言默认外部链接编译前自动加默认内部链接想要外部链接需要手动加当语言两个文件中都有的时候编译器会报重定义的错误而在中则不会因为中的默认是内部连接的如果想让中的具有外部连接必须显示声明为修改区别语言中全局部变量直接修改编译失败间接修改编译通过但由于存储在只读数据段运行失败语言中局部变量直接修改编译失败但可以通过指针间接修改中全局变量与一样中局部变量直接修改编译失败若分配了变量内存的话可以通过指针间接修改若未分配内存则指针修改仅仅修改了一个临时内存空间中的值对原值不影响中分配内存的情况对于基础数据类型也就是这种编译器会把它放到符号表中不分配内存当对其取地址时会分配临时内存无法间接修改原值显示为修改后无变化使用普通变量初始化变量可以间接修改原值修改成功自定义数据类型可以间接修改原值修改成功当上面未分配变量内存的情况下此时该变量可以作为数组定义括号中的数值编译通过编译不通过错误显示表达式必须含有常量值在支持标准的编译器中可以使用变量定义数组都不支持完整的尽量以替换在旧版本中如果想建立一个常量必须使用预处理器我们定义的宏从未被编译器看到过因为在预处理阶段所有的已经被替换为了于是并没有将其加入到符号表中但我们使用这个常量获得一个编译错误信息时可能会带来一些困惑因为这个信息可能会提到但是并没有提到如果被定义在一个不是你写的头文件中你可能并不知道代表什么也许解决这个问题要花费很长时间解决办法就是用一个常量替换上面的宏和区别总结有类型可进行编译器类型安全检查无类型不可进行类型检查有作用域而不重视作用域虽然可卸载宏常量默认定义处到文件结尾如果定义在指定作用域下有效的常量那么就不能用宏常量不可以有命名空间错误命名冲突引用引用基本用法引用是对的重要扩充在中指针的作用基本都是一样的但是增加了另外一种给函数传递地址的途径这就是按引用传递它也存在于其他一些编程语言中并不是的发明变量名实质上是一段连续内存空间的别名是一个标号门牌号程序中通过变量来申请并命名内存空间通过变量的名字可以使用存储空间对一段连续的内存空间只能取一个别名吗中新增了引用的概念引用可以作为一个已定义变量的别名基本语法注意事项在此不是求地址运算而是起标识作用类型标识符是指目标变量的类型必须在声明引用变量时进行初始化引用初始化之后不能改变不能有引用必须确保引用是和一块合法的存储单元关联可以建立对数组的引用建立数组引用方法一建立数组引用方法二函数中的引用最常见看见引用的地方是在函数参数和返回值中当引用被用作函数参数的时在函数内对任何引用的修改将对还函数外的参数产生改变当然可以通过传递一个指针来做相同的事情但引用具有更清晰的语法如果从函数中返回一个引用必须像从函数中返回一个指针一样对待当函数返回值时引用关联的内存一定要存在引用做参数值传递地址传递引用传递值传递地址传递引用传递通过引用参数产生的效果同按地址传递是一样的引用的语法更清楚简单函数调用时传递的实参不必加符在被调函数中不必在参数前加符引用作为其它变量的别名而存在因此在一些场合可以代替指针主张用引用传递取代地址传递的方式因为引用语法容易且不易出错引用做返回值不能返回局部变量的引用函数当左值必须返回引用返回局部变量引用局部变量返回静态变量引用不能返回局部变量的引用如果函数做左值那么必须返回引用引用的本质引用的本质在内部实现是一个指针常量编译器在编译过程中使用常指针作为引用的内部实现因此引用所占用的空间大小与指针相同只是这个过程是编译器内部实现用户不可见原理发现是引用转换为是引用转换为自动转换为这也能说明引用为什么必须初始化内部发现是引用自动帮我们转换为指针引用在语言中如果想改变一个指针的指向而不是它所指向的内容函数声明可能这样给指针变量取一个别名对于中的引用语法清晰多了函数参数变成指针的引用用不着取得指针的地址常量引用常量引用的定义格式常量引用注意字面量不能赋给引用但是可以赋给引用编译器自动给创建临时空间修饰的引用不能修改此时就是不能修改的值不能把一个字面量赋给引用但是可以把一个字面量赋给常引用编译器自动给创建临时空间常引用可以通过指针间接修改把上面引用的修改流程改成指针参考如下引用使用场景常量引用主要用在函数的形参尤其是类的拷贝复制构造函数将函数的形参定义为常量引用的好处引用不产生新的变量减少形参与实参传递时的开销由于引用可能导致实参随形参改变而改变将其定义为常量引用可以消除这种副作用防止函数中意外修改数据如果希望实参随着形参的改变而改变那么使用一般的引用如果不希望实参随着形参改变那么使用常引用对于非常量引用必须将其绑定到一个具有持久性的左值而不是一个临时值这是因为非常量引用是为了能够修改引用的对象而临时值是没有持久性的无法被修改原因如下生命周期问题临时值是暂时创建的它们没有持久性只在表达式求值时存在一旦表达式结束临时值就会被销毁因此在使用非常量引用时我们需要确保引用的对象在引用的整个生命周期内是有效的而不是在临时值消失后引用一个已销毁的对象修改限制非常量引用的目的是允许对引用的对象进行修改然而临时值是常量对象它们的值是不可修改的因此将非常量引用绑定到临时值上是没有意义的因为我们无法通过引用修改临时值简单理解对于这样的函数常引用参数是允许的但是对于这样的函数非常引用参数不允许只能这样内联函数内联函数的引出从中继承的一个重要特征就是效率假如的效率明显低于的效率那么就会有很大的一批程序员不去使用了在中我们经常把一些短并且执行频繁的计算写成宏而不是函数这样做的理由是为了执行效率宏可以避免函数调用的开销这些都由预处理来完成但是在出现之后使用预处理宏会出现两个问题第一个在中也会出现宏看起来像一个函数调用但是会有隐藏一些难以发现的错误第二个问题是特有的预处理器不允许访问类的成员也就是说预处理器宏不能用作类类的成员函数因为展开成了自加了两次为了保持预处理宏的效率又增加安全性而且还能像一般成员函数那样可以在类里访问自如引入了内联函数内联函数为了继承宏函数的效率没有函数调用时开销然后又可以像普通函数那样可以进行参数返回值类型的安全检查又可以作为成员函数注意编译器将会检查函数参数列表使用是否正确并返回值进行必要的转换这些事预处理器无法完成的内联函数基本概念在中预定义宏的概念是用内联函数来实现的而内联函数本身也是一个真正的函数内联函数具有普通函数的所有行为唯一不同之处在于内联函数会在适当的地方像预定义宏一样展开所以不需要函数调用的开销因此应该不使用宏使用内联函数在开启了优化选项后编译器可能不会为一个内联甚至非内联的函数生成语言入门栈区栈框架汇编层面的调用栈编译器可能使用很多优化技术消除这个构造在普通函数非成员函数函数前面加上关键字使之成为内联函数但是必须注意必须函数体和声明结合在一起否则编译器将它作为普通函数来对待即在函数声明和实现同时加入关键字才被称为内联下面不是内联下面是内联下面是内联内联函数的确占用空间但是内联函数相对于普通函数的优势只是省去了函数调用时候的压栈跳转返回的开销我们可以理解为内联函数是以空间换时间任何在类内部定义的函数自动成为内联函数内联函数和编译器内联函数并不是何时何地都有效为了理解内联函数何时有效应该要知道编译器碰到内联函数会怎么处理对于任何类型的函数编译器会将函数类型包括函数名字参数类型返回值类型放入到符号表中同样当编译器看到内联函数并且对内联函数体进行分析没有发现错误时也会将内联函数放入符号表当调用一个内联函数的时候编译器首先确保传入参数类型是正确匹配的或者如果类型不正完全匹配但是可以将其转换为正确类型并且返回值在目标表达式里匹配正确类型或者可以转换为目标类型内联函数就会直接替换函数调用这就消除了函数调用的开销假如内联函数是成员函数对象指针也会被放入合适位置类型检查和类型转换包括在合适位置放入对象指针这些都是预处理器不能完成的但是内联编译会有一些限制以下情况编译器可能考虑不会将函数进行内联编译不能存在任何形式的循环语句不能存在过多的条件判断语句函数体不能过于庞大不能对函数进行取址操作内联仅仅只是给编译器一个建议编译器不一定会接受这种建议如果你没有将函数声明为内联函数那么编译器也可能将此函数做内联编译一个好的编译器将会内联小的简单的函数函数的默认参数在声明函数原型的时可为一个或者多个参数指定默认缺省的参数值当函数调用的时候如果没有指定这个值编译器会自动用默认值代替注意点形参设置默认参数值那么后面位置的形参也需要设置默认参数如果函数声明和函数定义分开函数声明设置了默认参数函数定义不能再设置默认参数如下情况编译报错声明定义如果没有传参数那么使用默认参数如果传一个参数那么第二个参数使用默认参数如果传入两个参数那么两个参数都使用我们传入的参数注意点函数的默认参数从左向右如果一个参数设置了默认参数那么这个参数之后的参数都必须设置默认参数如果函数声明和函数定义分开写函数声明和函数定义不能同时设置默认参数和上面内联知识点正好相反内联要求声明和定义都要加函数的占位参数函数内部无法使用占位参数占位参数也可以设置默认值函数内部依旧无法使用占位参数错误调用占位参数也是参数必须传参数正确调用正确调用正确调用在声明函数时可以设置占位参数占位参数只有参数类型声明而没有参数名声明一般情况下在函数体内部无法使用占位参数占位符功能作用暂时基本没用什么时候用在后面我们要讲的操作符重载的后置要用到这个函数重载能使名字方便使用是任何程序设计语言的一个重要特征同一个函数名在不同场景下可以具有不同的含义在传统语言中函数名必须是唯一的程序中不允许出现同名的函数在中是允许出现同名的函数这种现象称为函数重载函数重载的目的就是为了方便的使用函数名函数重载并不复杂等大家学完就会明白什么时候需要用到他们以及是如何编译链接的函数重载基本语法实现函数重载的条件同一个作用域参数个数不同参数类型不同参数顺序不同函数重载条件无参数返回值不作为函数重载依据无法重载仅按返回值区分的函数虽然上面三个函数可以作为重载同时存在但这里调用会产生二义性因此会报错注意函数重载和默认参数一起使用需要额外注意二义性问题的产生函数重载碰上默认参数这时两个函数都能匹配调用产生二义性这是尤其要注意的为什么函数返回值不作为重载条件呢当编译器能从上下文中确定唯一的函数的时如这个当然是没有问题的然而我们在编写程序过程中可以忽略他的返回值那么这个时候一个函数为另一个为当我们直接调用这个时候编译器就不确定调用那个函数所以在中禁止使用返回值作为重载的条件函数重载实现原理编译器为了实现函数重载也是默认为我们做了一些幕后的工作编译器用不同的参数类型来修饰不同的函数名比如编译器可能会将函数名修饰成当编译器碰到编译器可能将函数名修饰为当编译器碰到编译器可能会将函数名修饰为我这里使用可能这个字眼是因为编译器如何修饰重载的函数名称并没有一个统一的标准所以不同的编译器可能会产生不同的内部名以下三个函数在下生成的编译之后的函数名为代表无参数代表参数为类型代表第一个参数为类型第二个参数为类型浅析在下测试函数被编译成函数函数被编译成函数通过这个测试由于中需要支持函数重载所以和中对同一个函数经过编译后生成的函数名是不相同的这就导致了一个问题如果在中调用一个使用语言编写模块中的某个函数那么是根据的名称修饰方式来查找并链接这个函数那么就会发生链接错误以上例中调用函数在链接阶段会去找结果是没有找到的因为这个函数是语言编写的生成的符号是那么如果我想在调用的函数怎么办的主要作用就是为了实现代码能够调用其他语言代码加上后这部分代码编译器按语言的方式进行编译和链接而不是按的方式例如如下情况需要调用语言函数头文件解决方案将这句替换为语言源文件你好源文件解决方案将这句替换为报错显示未解析的外部命令终极解决方案作用能区分和的调用针对性加或不加并且省去每个函数都要加的麻烦这句的意思是如果是引入的话这句的目的是为了让该文件头文件中的函数在也能跑起来类和对象和中区别语言只有变量而语言既有变量也有函数语言中中的成员变量不能赋初值中的中的成员变量可以类的封装把事物的属性和行为表示出来那么就可以抽象出来这个事物封装把变量属性和函数操作合成一个整体封装在一个类中对变量和函数进行访问控制访问权限在类的内部作用域范围内没有访问权限之分所有成员可以相互访问在类的外部作用域范围外访问权限才有意义在类的外部只有修饰的成员才能被访问在没有涉及继承与派生时和是同等级的外部不允许访问中和的区别默认访问权限为默认访问权限为尽量将成员变量设置为可赋予客户端访问数据的一致性如果成员变量不是客户端唯一能够访问对象的方法就是通过成员函数如果类中所有权限的成员都是函数客户在访问类成员时只会默认访问函数不需要考虑访问的成员需不需要添加这就省下了许多搔首弄耳的时间可细微划分访问控制使用成员函数可使得我们对变量的控制处理更加精细如果我们让所有的成员变量为每个人都可以读写它如果我们设置为我们可以实现不准访问只读访问读写访问甚至你可以写出只写访问对象的构造和析构构造函数和析构函数这两个函数将会被编译器自动调用完成对象初始化和对象清理工作无论你是否喜欢对象的初始化和清理工作是编译器强制我们要做的事情即使你不提供初始化操作和清理操作编译器也会给你增加默认的操作只是这个默认初始化操作不会做任何事所以编写类就应该顺便提供初始化函数构造函数和析构函数构造函数主要作用在于创建对象时为对象的成员属性赋值构造函数由编译器自动调用无须手动调用析构函数主要用于对象销毁前系统自动调用执行一些清理工作例如成员变量有存堆区指针那么堆区空间由析构函数中释放最合适了构造函数语法构造函数函数名和类名相同没有返回值不能有但可以有参数可以重载析构函数语法析构函数函数名是在类名前面加组成没有返回值不能有不能有参数不能重载构造函数的分类及调用按参数类型无参构造函数有参构造函数按类型分类普通构造函数拷贝构造函数复制构造函数有参构造函数拷贝构造函数复制构造函数使用另一个对象初始化本对象打印年龄无参构造调用方式注意点重点正确方式错误方式会被误认为是函数声明引申出来的情况如下当使用父类指针指向子类对象的时候举个例子是纯虚类接口也是的父类这样是正确的这样是错误的有参构造调用方法不推荐无参构造调用方式调用无参构造函数无参构造函数错误调用方式原因是会被编译器看成返回值为的名为的函数声明调用有参构造函数第一种括号法最常用调用拷贝构造函数第二种匿名对象显示调用构造函数匿名对象没有名字的对象注意使用匿名对象初始化判断调用哪一个构造函数要看匿名对象的参数类型等价于第三种号法隐式转换调用拷贝构造注意事项除了匿名构造外其他情况析构都是在作用域尾执行匿名构造情况构造函数中打印调用构造函数分割线以上输出为调用构造函数调用析构函数分割线原因为编译器看到这种情况的时候执行完构造后会立即调用析构函数其他情况分割线以上输出为调用构造函数分割线调用析构函数注意事项为的实例化对象和的区别当有变量来接的时候那么编译器认为他是一个匿名对象当没有变量来接的时候编译器认为你等价于拷贝构造函数初始化匿名对象汇编层面上实际并没有调用拷贝构造函数而是调用的无参构造函数避免这种用法正常调用无参构造函数的方法上下这两行含义完全相等若上下同时存在会产生编译错误重定义注意事项不存在参数类实例本身的构造函数即不存在如下构造函数构造成功报错显示的复制构造函数不能带有类型的参数从理解上来看上面代码段中的参数传参为值传递而在中类对象的值传递本质上调用的就是拷贝构造函数则会产生一个无限递归因此必须要报错下面调用时机处是对这个理解的更深理解析构函数的调用时机对象在栈上生命周期结束的时候系统会自动调用析构函数对象在堆上系统不会自动调用析构函数必须见到对象生命周期结束被销毁时主动调用对象是对象的成员的析构函数被调用时对象的析构函数也被调用如果是的对象即使离开了作用域也会一直存在必须主动否则只有在结束程序时才会执行析构虽然离开了作用域但用动态开辟空间的对象是不会析构的你可以观察任务管理器看到内存一直在上升但你在其他地方确无法使用所开辟的空间因为这个指针是保存在栈上的当离开作用域后就自动析构或者说自动消失了但它所在分配空间是分配在堆上的只有主动析构或程序结束才会释放空间也就是丢失了这块空间的地址无法操作这块空间了对不是的对象的析构函数和打断点可以发现是先返回值后调用析构函数显示调用析构函数不但不会带来任何好处还会造成很多奇怪难以分析的问题手动析构调用函数自动析构调用函数同时销毁本身后一个行为由系统完成用户不能参与我们构造对象往往都是在一段语句体中比如函数判断循环还有就直接被一对包含的语句体这个对象在语句体中被创建在语句体结束的时候被销毁问题就在于这样的对象在生命周期中是存在于栈上的也就是说如何管理是系统完成而程序员不能控制的所以即使我们调用了析构在对象生命周期结束后系统仍然会再调用一次析构函数将其在栈上销毁实现真正的析构所以如果我们在析构函数中有清除堆数据的语句调用两次意味着第二次会试图清理已经被清理过了的根本不再存在的数据这是件会导致运行时错误的问题并且在编译的时候不会告诉你显示调用析构带来的后果显式调用的时候析构函数相当于的一个普通的成员函数编译器隐式调用析构函数如分配了堆内存显式调用析构的话引起重复释放堆内存的异常把一个对象看作占用了部分栈内存占用了部分堆内存如果申请了的话这样便于理解这个问题系统隐式调用析构函数的时候会加入释放栈内存的动作而堆内存则由用户手工的释放用户显式调用析构函数的时候只是单纯执行析构函数内的语句不会释放栈内存也不会摧毁对象拷贝构造函数的调用时机对象以值传递的方式传给函数参数函数局部对象以值传递的方式从函数返回模式下调用一次拷贝构造不调用任何构造用一个对象初始化另一个对象旧对象初始化新对象相当于传递的参数是普通对象函数参数也是普通对象传递将会调用拷贝构造输出结果函数返回局部对象局部下没有调用拷贝构造函数下调用一次拷贝构造函数局部下生成下生成上面结果说明编译器存在一种对返回值的优化技术在模式下并没有进行这种优化所以函数中创建对象调用了一次构造函数当编译器发现你要返回这个局部的对象时编译器通过调用拷贝构造生成一个临时对象返回然后调用的析构函数我们从常理来分析的话这个匿名对象和这个局部的对象是相同的两个对象那么如果能直接返回对象就会省去一个拷贝构造和一个析构函数的开销在程序中一个对象的拷贝也是非常耗时的如果减少这种拷贝和析构的次数那么从另一个角度来说也是编译器对程序执行效率上进行了优化所以在这里编译器偷偷帮我们做了一层优化当我们这样去调用编译器偷偷将我们的代码更改为调用默认构造函数对进行处理这里只分配空间不初始化理解上就是编译器编译发布版本的时候直接改成了类对象的引用传递重点理解结论函数的返回值是一个匿名对象时会调用匿名对象的拷贝函数结论有关匿名对象的去和留如果用匿名对象初始化另一个同类型的对象匿名对象被接收不会调用析构函数如果用匿名对象赋值给另一个同类型的对象已经初始化默认或者有参数匿名对象被析构默认构造函数有参数构造函数拷贝复制构造函数用一个对象初始化另一个对象拷贝复制构造函数析构函数重载操作符如果函数返回值是一个对象建议用对象直接接收有参构造函数拷贝构造函数析构匿名对象被接收不调用默认构造函数不调用析构节约内存提高速度如何被构造的呢函数返回值的拷贝构造默认构造函数匿名对象赋值给新对象析构匿名对象重载操作符析构析构输出结果为构造函数自动生成规则默认情况下编译器至少为我们写的类增加个函数默认构造函数无参函数体为空默认析构函数无参函数体为空默认拷贝构造函数对类中非静态成员属性简单值拷贝赋值运算符重载函数定义时的运算符调用的是拷贝构造之外之后的运算符调用的都是函数如果用户定义拷贝构造函数不会再提供任何默认构造函数如果用户定义了普通构造非拷贝不在提供默认无参构造但是会提供默认拷贝构造深拷贝和浅拷贝浅拷贝同一类型的对象之间可以赋值使得两个对象的成员变量的值相同两个对象仍然是独立的两个对象这种情况被称为浅拷贝一般情况下浅拷贝没有任何副作用但是当类中有指针并且指针指向动态分配的内存空间析构函数做了动态内存释放的处理会导致内存问题深拷贝当类中有指针并且此指针有动态分配空间析构函数做了释放处理往往需要自定义拷贝构造函数自行给指针动态分配空间深拷贝增加拷贝构造函数用对象初始化对象调用提供的默认拷贝构造函数关键字提供了关键字字面意思更清晰的禁止通过构造函数的隐式转换方式来构造对象常用于修饰构造函数防止隐式转化调用构造函数产生的误解常针对单参数的构造函数或者除了第一个参数外其余参数都有默认值的多参构造而言这里报错显示不存在从转换到的适当构造函数没问题上面例子可看出就是禁止用隐式方式来构造对象情况各种情况的输出效果初始化列表构造函数和其他函数不同除了有名字参数列表函数体之外还有初始化列表传统方式初始化初始化列表方式初始化注意初始化成员列表参数列表只能在构造函数使用类对象作为成员在类中定义的数据成员一般都是基本的数据类型但是类中的成员也可以是对象叫做对象成员中对对象的初始化是非常重要的操作当创建一个对象的时候编译器必须确保调用了所有子对象的构造函数如果所有的子对象有默认构造函数编译器可以自动调用他们但是如果子对象没有默认的构造函数或者想指定调用某个构造函数怎么办那么是否可以在类的构造函数直接调用子类的属性完成初始化呢但是如果子类的成员属性是私有的我们是没有办法访问并完成初始化的解决办法非常简单对于子类调用构造函数为此提供了专门的语法即构造函数初始化列表当调用构造函数时首先按各对象成员在类定义中的顺序和参数列表的顺序无关依次调用它们的构造函数对这些对象初始化最后再调用本身的函数体也就是说先调用对象成员的构造函数再调用本身的构造函数析构函数和构造函数调用顺序相反先构造后析构汽车类默认构造函数大众汽车带参数构造函数析构函数拖拉机默认构造函数爬土坡专用拖拉机带参数构造函数析构函数人类类不存在合适的构造函数初始化列表可以指定调用构造函数构造函数开着去上班开着去上班析构函数宝马东风拖拉机赵四刘能输出结果动态对象创建当创建一个对象时会发生两件事为对象分配内存调用构造函数来初始化那块内存第一步我们能保证实现需要我们确保第二步一定能发生强迫我们这么做是因为使用未初始化的对象是程序出错的一个重要原因动态分配内存方法为了在运行时动态分配内存在他的标准库中提供了一些函数以及它的变种和释放内存的这些函数是有效的但是原始的需要程序员理解和小心使用为了使用的动态内存分配函数在堆上创建一个类的实例我们必须这样做分配内存调用初始化函数清理对象释放对象问题在于程序员必须确定对象的长度返回一个指针不允许将赋值给其他任何指针必须强转可能申请内存失败所以必须判断返回值来确保内存分配成功用户在使用对象之前必须记住对他初始化构造函数不能显示调用初始化构造函数是由编译器调用用户有可能忘记调用初始化函数的动态内存分配函数太复杂容易令人混淆是不可接受的中我们推荐使用运算符和中解决动态内存分配的方案是把创建一个对象所需要的操作都结合在一个称为的运算符里当用创建一个对象时它就在堆里为对象分配内存并调用构造函数完成初始化相当于构造函数操作符能确定在调用构造函数初始化之前内存分配是成功的所有不用显式确定调用是否成功现在我们发现在堆里创建对象的过程变得简单了只需要一个简单的表达式它带有内置的长度计算类型转换和安全检查这样在堆创建一个对象和在栈里创建对象一样简单和的区别和属于库函数和属于运算符不会调用构造函数会调用构造函数返回下要强转返回创建的对象的指针机制一般来说使用申请空间时是从系统的堆中分配空间申请所得的空间的位置是根据当时的内存的实际使用情况决定的但是在某些特殊情况下可能需要在已分配的特定内存创建对象这就是所谓的定位放置操作定位放置操作的语法形式不同于普通的操作例如一般都用如下语句申请空间而定位放置操作则使用如下语句申请空间其中就是程序员指定的内存首地址用定位放置操作既可以在栈上生成对象也可以在堆上生成对象取决于地址是指向哪里使用语句定位生成对象时指针和数组名指向同一片存储区所以与其说定位放置操作是申请空间还不如说是利用已经请好的空间真正的申请空间的工作是在此之前完成的使用语句定位生成对象时会自动调用类的构造函数但是由于对象的空间不会自动释放对象实际上是借用别人的空间所以必须显示的调用类的析构函数如本例中的如果有这样一个场景我们需要大量的申请一块类似的内存空间然后又释放掉比如在在一个中对于客户端的请求每个客户端的每一次上行数据我们都需要为此申请一块内存当我们处理完请求给客户端下行回复时释放掉该内存表面上看者符合的内存管理要求没有什么错误但是仔细想想很不合理为什么我们每个请求都要重新申请一块内存呢要知道每一次内从的申请系统都要在内存中找到一块合适大小的连续的内存空间这个过程是很慢的相对而言极端情况下如果当前系统中有大量的内存碎片并且我们申请的空间很大甚至有可能失败为什么我们不能共用一块我们事先准备好的内存呢可以的我们可以使用来构造对象那么就会在我们指定的内存空间中构造对象这种方式存在的根本原因是因为内存申请是个耗时操作将对象分配到了栈上表达式的反面是表达式表达式先调用析构函数然后释放内存正如表达式返回一个指向对象的指针一样需要一个对象的地址只适用于由创建的对象如果使用一个由或者或者创建的对象使用这个行为是未定义的因为大多数和的实现机制都使用了和所以很可能没有调用析构函数就释放了内存如果正在删除的对象的指针是将不发生任何事因此建议在删除指针后立即把指针赋值为以免对它删除两次对一些对象删除两次可能会产生某些问题无参构造函数有参构造函数析构函数不会置空指针用于数组的和使用和在堆上创建数组非常容易创建字符数组创建整型数组创建整型数组并初始化释放数组内存当创建一个对象数组的时候必须对数组中的每一个对象调用构造函数一般来说除了在栈上可以聚合初始化必须提供一个默认的构造函数栈聚合初始化创建堆上对象调用有参构造函数创建堆上对象调用无参构造函数创建堆上对象数组必须提供默认构造函数以下代码可以不强制在堆中生成数组对象时候类必须有默认构造函数即不能是自己实现了有参数构造函数却没实现无参构造函数的情况但是以上代码在部分编译器不支持支持所以为了兼容性最好提供一个默认构造函数并且不使用上面语法注意可能会出错如果对一个指针执行操作这将可能成为一个程序错误除非指针指向的内容是非常简单的因为它将不执行析构函数以下代码未调用析构函数导致可用内存减少这里写将导致下面的不执行析构函数因此不要用去接受出来的对象利用无法调用析构函数使用和采用相同形式以上代码有什么问题吗下直接中断下析构函数调用一次使用了也搭配使用了问题在于有个对象那么其他个对象可能没有调用析构函数也就是说其他个对象可能删除不完全因为它们的析构函数没有被调用我们现在清楚使用的时候发生了两件事一分配内存二调用构造函数那么调用的时候也有两件事一析构函数二释放内存那么刚才我们那段代码最大的问题在于指针指向的内存中到底有多少个对象因为这个决定应该有多少个析构函数应该被调用换句话说指针指向的是一个单一的对象还是一个数组对象由于单一对象和数组对象的内存布局是不同的更明确的说数组所用的内存通常还包括数组大小记录使得的时候知道应该调用几次析构函数单一对象的话就没有这个记录单一对象和数组对象的内存布局可理解为下图本图只是为了说明编译器不一定如此实现但是很多编译器是这样做的当我们使用一个的时候我们必须让知道指针指向的内存空间中是否存在一个数组大小记录的办法就是我们告诉它当我们使用那么就知道是一个对象数组从而清楚应该调用几次析构函数结论如果在表达式中使用必须在相应的表达式中也使用如果在表达式中不使用一定不要在相应的表达式中使用嵌套类和局部类嵌套类在一个类中定义另一个类在语言中嵌套类其实与外围类没有什么太强的依赖关系往往是因为外围类需要使用嵌套类对象作为底层实现并且该嵌套类只用于外围类的实现且同时可以对用户隐藏该底层实现时才使用嵌套类即作用总结访问控制限定嵌套类只能由这个类访问局部类在一个函数中定义另一个类静态成员对静态的理解术语有一段不同寻常的历史起初引入关键字是为了表示退出一个块后依然存在的局部变量在这种情况下术语是有意义的变量一直存在当再次进入该块时仍然存在随后在中有了第二种含义表示不能被其他文件访问的全局变量和函数为了避免引入一个新的关键字关键字被重用了最后第三次重用了这个关键字与前面赋予的含义完全不一样这里将其解释为属于类且不属于类对象的变量和函数这个含义和相同静态成员变量在一个类中若将一个成员变量声明为这种成员称为静态成员变量与一般的数据成员不同无论建立了多少个对象都只有一个静态数据的拷贝静态成员变量属于某个类所有对象共享静态变量是在编译阶段就分配空间对象还没有创建时就已经分配空间静态非常量成员变量必须在类中声明在类外定义静态常量成员可以在类内一次性完成声明和定义静态数据成员不属于某个对象编译阶段就分配内存在为对象分配空间中不包括静态成员所占空间静态数据成员可以通过类名或者对象名来引用两种访问方式也有访问权限类的静态成员属性类外初始化初始化时不加这种类外定义方式看起来是在类外但其实还是算类内即这种可无视权限通过类名直接访问通过对象访问静态成员也有访问权限类外不能访问私有成员注意由于静态空间的申请和初始化都在之前因此可以利用静态成员的类外定义来在之前执行一些代码前执行的代码我在外哦静态成员函数在类定义中前面有说明的成员函数称为静态成员函数静态成员函数使用方式和静态变量一样同样在对象没有创建前即可通过类名调用静态成员函数主要为了访问静态变量但是不能访问普通成员变量静态成员函数的意义不在于信息共享数据沟通而在于管理静态数据成员完成对静态数据成员的封装静态成员函数只能访问静态变量不能访问普通成员变量静态成员函数的使用和静态成员变量一样可以通过类或者对象访问静态成员函数也有访问权限普通成员函数可访问静态成员变量也可以访问非静态成员变量普通成员函数可以访问和成员属性静态成员函数只能访问成员属性无法访问无法访问静态成员属性类外初始化类名直接调用通过对象调用静态成员函数也有访问权限类外无法访问私有静态成员函数注意静态成员函数不属于任何一个类对象没有指针而非静态成员必须随类对象的产生而产生所以静态成员函数看不见非静态成员自然也就不能访问了但是如果静态成员函数通过引用一个对象是可以直接访问私有成员的也体现了它成员函数的特权构造函数静态成员函数的原型声明静态数据成员静态成员函数的类外定义参数表中创建对象静态成员函数通过对象访问非静态数据成员静态成员函数处理静态数据成员静态数据成员初始化静态成员函数调用时一般使用类名静态成员属性如果一个类的成员既要实现共享又要实现不可改变那就用修饰定义静态数据成员时最好在类内部初始化只读区不可修改静态成员实现单例模式单例模式是一种常用的软件设计模式在它的核心结构中只包含一个被称为单例的特殊类通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问从而方便对实例个数的控制并节约系统资源如果希望在系统中某个类的对象只能存在一个单例模式是最好的解决方案单例在单例类的内部实现只生成一个实例同时它提供一个静态的工厂方法让客户可以访问它的唯一实例为了防止在外部对其实例化将其默认构造函数和拷贝构造函数设计为私有在单例类内部定义了一个类型的静态对象作为外部共享的唯一实例关键点私有化默认构造函数拷贝构造函数唯一实例指针对外提供接口将指针返回用单例模式模拟公司员工使用打印机场景打印机可以打印员工要输出的内容并且可以累积打印机使用次数案例如下打印内容已打印次数离职报告入职合同提交代码面向对象模型初探成员变量和函数的存储中的非静态数据成员直接内含在类对象中就像一样成员函数虽然内含在声明之内却不出现在对象空间中每一个非内联成员函数只会诞生一份函数实例空类的结果为只有类中的非静态成员才真正占用对象空间他们也要内存对齐和结构体一样指针指针工作原理通过上例我们知道的数据和操作也是分开存储并且每一个非内联成员函数只会诞生一份函数实例也就是说多个同类型的对象会共用一块代码那么问题是这一块代码是如何区分那个对象调用自己的呢规定指针是隐含在对象成员函数内的一种指针当一个对象被创建后它的每一个成员函数都含有一个系统自动生成的隐含参数指针用以传入这个对象的地址也就是说虽然我们没有写上指针编译器在编译的时候也是会加上的因此也称为指向本对象的指针指针并不是对象的一部分不会影响对象的结果指针是实现封装的一种机制它将对象和该对象调用的成员函数连接在一起在外部看来每一个对象都拥有自己的函数成员一般情况下并不写而是让系统进行默认设置指针永远指向当前对象成员函数通过指针即可知道操作的是那个对象的数据指针是一种隐含指针它隐含于每个类的非静态成员函数中指针无需定义直接使用即可编译器对普通成员函数的内部处理的理解图指针的使用当形参和成员变量同名时可用指针来区分实际开发一般类中命名规范为表示避开命名冲突在类的非静态成员函数中返回对象本身可使用为对象本身重点理解案例内含链式编程思想返回引用返回对象本身链式编程思想若将的返回值改成值传递返回对象返回对象本身则链式编程思想结果为理解对象的值赋值就是调用拷贝构造函数从返回引用改成返回值后实际上调用的是拷贝构造函数来生成了一个匿名对象该匿名对象又调用函数返回值又因为调用拷贝构造函数生成另一个匿名对象最终实际上只进行了一次后面的每次都是针对每次拷贝构造函数生成的匿名对象而非这里额外提一下函数千万不要返回局部对象的引用或指针因为该指针指向的空间已经被释放了该指针为悬垂指针指向曾经存在的对象但该对象已经不再存在了此类指针称为垂悬指针空指针访问成员函数如果成员函数中没有用到指针直接用成员变量内部也会用到指针可以用空指针调用成员函数可以给成员函数的加判断防止别人用空指针访问成员函数如下防止别人用空指针访问成员函数常量关键词以下所有强调的直接修改对应的间接修改指的是通过指针来间接修改可否间接修改参考之前部分的内容修饰成员函数用修饰的成员函数时修饰指针指向的内存区域常量成员函数体内不可以直接修改本类中的任何普通成员变量当成员变量类型符前用意思可变的修饰时例外定义方式函数名功能常成员函数可以访问常对象中的数据成员但仍然不允许修改没有修饰的常对象中数据成员的值注意汇编本质就是函数传参的第一个参数改成了因此重写函数时候需要写上这个函数后的修饰对象常对象作用使常对象中所有没有修饰的成员变量不可直接修改两种定义方式类名对象名实参列表类名对象名实参列表注意常对象不能调用该对象的非型的成员函数除了构造函数和析构函数常对象可访问或非数据成员不能直接修改除非成员用修饰个人理解常函数的本质是把本来由编译器暗中传入普通函数的类型名在常函数中传入为类型名加多的使指向的内存不可直接修改了常对象的本质就是编译器限制对象调用普通成员函数只能调用常函数个人问题关键词实现原理友元类的主要特点之一是数据隐藏即类的私有成员无法在类的外部作用域之外访问但是有时候需要在类的外部访问类的私有成员怎么办解决方法是使用友元函数友元函数是一种特权函数允许这个特权函数访问私有成员开发中线程回调函数需要访问类中静态成员往往使用友元函数或者静态成员函数该函数要更麻烦些友元语法关键字只出现在声明处其他类类成员函数全局函数都可声明为友元友元函数不是类的成员不带指针友元函数可访问对象任意成员属性包括私有属性若类是类的友元类则类的所有成员函数都是类的友元函数友元类友元成员函数全局函数做友元函数成员函数做友元函数友元类我的朋友参观我的朋友玩耍在友元全局函数友元全局函数访问客厅卧室友元类注意友元关系不能被继承友元关系是单向的类是类的朋友但类不一定是类的朋友友元关系不具有传递性类是类的朋友类是类的朋友但类不一定是类的朋友和不能同时存在简单的说声明全局函数时会默认函数为的和后面的冲突违法标准规定声明前不能加存储类型关键字的规定是纯面向对象的吗如果一个类被声明为意味着它不是这个类的成员函数却可以修改这个类的私有成员而且必须列在类的定义中因此他是一个特权函数不是完全的面向对象语言而只是一个混合产品增加关键字只是用来解决一些实际问题这也说明这种语言是不纯的毕竟设计的目的是为了实用性而不是追求理想的抽象尽量使用成员函数除非不得已的情况下才使用友元函数什么时候使用友元函数运算符重载的某些场合需要使用友元两个类要共享数据的时候综合训练动态数组类省略运算符重载运算符重载就是对已有的运算符重新进行定义赋予其另一种功能以适应不同的数据类型本质上运算符重载只是一种语法上的方便也就是它只是另一种函数调用的方式在中可以定义一个处理类的新运算符这种定义很像一个普通的函数定义只是函数的名字由关键字及其紧跟的运算符组成差别仅此而已它像任何其他函数一样也是一个函数当编译器遇到适当的模式时就会调用这个函数基本语法定义重载的运算符就像定义函数只是该函数的名字是这里的代表了被重载的运算符函数的参数中参数个数取决于两个因素运算符是一元一个参数的还是二元两个参数运算符被定义为全局函数对于一元是一个参数对于二元是两个参数还是成员函数对于一元没有参数对于二元是一个参数此时该类的对象用作左耳参数有些人很容易滥用运算符重载它确实是一个有趣的工具但是应该注意它仅仅是一种语法上的方便而已是另外一种函数调用的方式从这个角度来看只有在能使涉及类的代码更易写尤其是更易读时请记住读代码的机会比我们写代码多多了才有理由重载运算符如果不是这样就改用其他更易用更易读的方式对于运算符重载另外一个常见的反应是恐慌突然之间运算符的含义变得不同寻常了一切都变了所有代码的功能都要改变并非如此对于内置的数据类型的表达式的的运算符是不可能改变的例如想重载类型数据的号可重载的运算符几乎中所有的运算符都可以重载但运算符重载的使用时相当受限制的特别是不能使用中当前没有意义的运算符例如用求幂不能改变运算符优先级不能改变运算符的参数个数这样的限制有意义否则所有这些行为产生的运算符只会混淆而不是澄清寓语意加号运算符重载对于内置的数据类型编译器知道如何进行运算但是对于自定义的数据类型编译器不知道如何运算实现加号运算符重载的两种方式成员函数必须返回的是类本身因为返回的是局部对象会调用拷贝构造函数如果返回的话就不能实现链式编程思路两种调用方式全局函数必须返回的是类本身因为返回的是局部对象会调用拷贝构造函数两种调用方式注意全局方式和成员函数方式同时存在的时候不能用的形式调用因为具有二义性编译器分不清左移运算符重载对于自定义数据类型不能直接用自定义对象来输出需要重载左移运算符利用成员函数重载无法实现让在左侧因此我们不用成员函数重载成员函数方式重载左移运算符换成则不可以链式编程处写也可以只是起个别名而已和的名称一样也可以为为两种调用方式此处在右边因此用成员函数来重载左移运算符的方式并不好全局函数方式重载左移运算符为为两种调用方式因此基本都是采用全局函数方式重载左移运算符因为是全局函数所以访问类中私有数据要权限解决方案将左移运算符全局重载函数设置为对应类的友元函数给每个需要显示的私有变量设置公有的函数自增自减运算符重载重载的和运算符有点让人不知所措因为我们总是希望能根据它们出现在所作用对象的前面还是后面来调用不同的函数解决办法很简单例如当编译器看到前置它就调用当编译器看到后置它就会去调用重载前置重载后置前置后置总结表示任意类型解读如果定义了也要定义递增操作符比较麻烦因为他们都有前缀和后缀形式而两种语义略有不同重载和时应该模仿他们对应的内置操作符对于和而言后置形式是先返回然后对象或者返回的是对象的原值前置形式对象先或返回当前对象返回的是新对象其标准形式为上图注意调用代码时候要优先使用前缀形式除非确实需要后缀形式返回的原值前缀和后缀形式语义上是等价的输入工作量也相当只是效率经常会略高一些由于前缀形式少创建了一个临时对象注意对于标准数据类型前置可以嵌套多个前置而后置只能一次重复嵌套后置递增或递减会报错如下图而对于我们上面自己实现的前后置重载后置可以嵌套多层而没有语法错误但是从第二次开始运算的结果就已经存在临时对象中而不影响最初的对象因此多次嵌套后置递增或递减也是没有意义的要避免这样使用指针运算符重载这里为了描述指针运算符重载引入智能指针的概念智能指针用途托管出来的对象的释放让其自动帮忙在声明周期结束时候释放堆区对象设计智能指针类别内部维护出来的对象的指针在析构的时候释放堆区出来的对象重载直接通过智能指针对象重载后的指针运算符操作原对象的成员函数案例如下重载指针的操作符这里必须返回引用是因为如果返回的话会调用拷贝构造函数创建一个新的临时对象返回如果忘记释放那么就会造成内存泄漏智能指针对象因为在堆区创建所以声明周期结束时候会自动调用智能指针的析构函数而智能指针的析构函数中写好了对新建的类对象的因此我们用智能指针创建堆区上的对象时候不需要自己手动直接通过智能指针操作类的成员函数为什么应该返回指针类型是因为等价于指针运算符重载必须是成员函数注意两种一样的调用形式对比号对于重载的理解编译器会自动对调用重载函数再接解析注意上诉案例中的智能指针并不存在什么实际价值因为每个类都要专门写对应的智能指针去处理特别麻烦在实际生产中还是自动手动调用释放赋值运算符重载必须是成员函数调用的是拷贝构造函数不自己写默认浅拷贝调用的是赋值运算符重载函数不自己写默认浅拷贝即只有定义时候的运算符调用的是拷贝构造函数默认提供的赋值运算符重载是浅拷贝若类有用到堆区空间应该实现成深拷贝重载赋值运算符返回本身的引用是为了链式编程同时也必须是返回的引用如果返回难么系统实际上是调用了拷贝构造函数生成了一个临时对象来返回那么链式编程中的下一次就是这个临时对象调用这个赋值运算符重载函数函数内中的释放堆空间的操作就就释放的是临时对象中指针指向的堆空间而很显然原本要释放的堆空间却没有释放并且遗失了他的指针因此势必内存泄露注意由于当前对象已经创建完毕那么就有可能指向堆内存这个时候如果直接赋值会导致内存没有及时释放因此要先释放之前的堆空间返回这个实际上更符合整形链式赋值的汇编流程析构函数两种调用方式理解链式调用赋值运算符重载函数类比如下代码先把的值赋给再把的值赋给从右向左因此也是先调用然后重点上面案例代码中对于赋值运算符重载的返回值类型的解读下标运算符重载实现访问数组时候利用访问元素必须是成员函数类内返回引用的目的是为了可以返回左值来修改里面的值关系运算符重载对于自定义数据类型编译器不知道如何进行比较类内全局省略了懒得写了函数调用运算符重载重载使用时候很像函数调用因此称为仿函数仿函数返回值和参数个数都不固定很灵活函数调用运算符必须是成员函数只有当左操作数是一个基本类型对象时才重载为全局函数使用情景后面中大量用到类中多少个参数都可以两种调用方式对象对象参数列表注意是匿名函数对象后面的括号表示匿名对象调用函数运算符重载函数特点当前行执行完立即释放不要重载不能重载和的原因是无法在这两种情况下实现内置操作符的完整语义内置版本版本特殊之处在于内置版本的和首先计算左边的表达式如果这完全能够决定结果就无需计算右边的表达式了而且能够保证不需要我们都已经习惯这种方便的特性了内置版本和重载后结果不一致的案例原来情况应该从左往右运算左边为假则退出运算结果为假这边却是先运算导致的变为的值真假根据内置的执行顺序我们发现这个案例中执行顺序并不是从左向右而是先右后左这就是不满足我们习惯的特性了由于先执行导致本身发生了变化初始值是现在经过运算变成输出了真内置版本应该输出的是假运算符重载总结和操作符只能通过成员函数进行重载和只能通过全局函数配合友元函数进行重载不要重载和操作符因为无法实现短路规则常规建议附录运算符和结合性优先级运算符名称或含义使用形式结合方向说明数组下标数组名常量表达式左到右圆括号表达式函数名形参表成员选择对象对象成员名成员选择指针对象指针成员名负号运算符表达式右到左单目运算符按位取反运算符表达式自增运算符变量名变量名自减运算符变量名变量名取值运算符指针变量取地址运算符变量名逻辑非运算符表达式类型强制类型转换数据类型表达式长度运算符表达式除表达式表达式左到右双目运算符乘表达式表达式余数取模整型表达式整型表达式加表达式表达式左到右双目运算符减表达式表达式左移变量表达式左到右双目运算符右移变量表达式大于表达式表达式左到右双目运算符大于等于表达式表达式小于表达式表达式小于等于表达式表达式等于表达式表达式左到右双目运算符不等于表达式表达式按位与表达式表达式左到右双目运算符按位异或表达式表达式左到右双目运算符按位或表达式表达式左到右双目运算符逻辑与表达式表达式左到右双目运算符逻辑或表达式表达式左到右双目运算符条件运算符表达式表达式表达式右到左三目运算符赋值运算符变量表达式右到左除后赋值变量表达式乘后赋值变量表达式取模后赋值变量表达式加后赋值变量表达式减后赋值变量表达式左移后赋值变量表达式右移后赋值变量表达式按位与后赋值变量表达式按位异或后赋值变量表达式按位或后赋值变量表达式逗号运算符表达式表达式左到右继承继承基本概念最重要的特征是代码重用通过继承机制可以利用已有的数据类型来定义新的数据类型新的类不仅拥有旧类的成员还拥有新定义的成员一个类继承于类或称从类派生类这样的话类成为基类父类类成为派生类子类派生类中的成员包含两大部分一类是从基类继承过来的一类是自己增加的成员从基类继承过过来的表现其共性而新增的成员体现了其个性定义格式派生类名继承方式基类名派生类新增的数据成员和成员函数三种继承方式公有继承私有继承保护继承从继承源上分单继承指每个派生类只直接继承了一个基类的特征多继承指多个基类派生出一个派生类的继承关系多继承的派生类直接继承了不止一个基类的特征派生类访问控制派生类继承基类派生类拥有基类中全部成员变量和成员方法除了构造和析构之外的成员方法但是在派生类中继承的成员并不一定能直接访问不同的继承方式会导致不同的访问权限派生类的访问权限规则如下继承中的对象模型父类中私有属性子类是继承下去了只不过由编译器给隐藏了访问不到可以利用开发人员工具查看对象模型的位置开发人员命令提示跳转到项目路径下查看对象模型类名文件名注意和类名之间没有空格继承中的构造和析构先调用父类构造再调用自身类中其他对象成员构造再调用自身构造析构的顺序与构造相反利用初始化列表语法显示调用父类中的其他构造函数不用初始化列表显示调用的情况下系统默认调用无参构造函数父类中的构造析构拷贝构造不会被子类继承下去的在继承的过程中如果没有创建这些函数编译器会自动生成它们继承与对象嵌套混搭的构造和析构继承中同名成员的处理方法当子类成员和父类成员同名时子类依然从父类继承同名成员如果子类有成员和父类同名子类访问其成员默认访问子类的成员本作用域就近原则在子类通过作用域进行同名成员区分在派生类中使用基类的同名成员显示使用类名限定符继承中的同名成员函数要注意任何时候重新定义基类中的一个重载函数在子类的父类中所有重载版本都将被自动隐藏可以利用作用域显示指定调用继承中的静态成员特性处理方式和非静态成员一致只不过调用方式有两种通过对象通过类名如访问子类中父类作用域下的静态成员变量多继承我们可以从一个类继承我们也可以能同时从多个类继承这就是多继承但是由于多继承是非常受争议的从多个类继承可能会导致函数变量等同名导致较多的歧义多继承会带来一些二义性的问题如果两个基类中有同名的函数或者变量那么通过派生类对象去访问这个函数或变量时就不能明确到底调用从基类继承的版本还是从基类继承的版本解决方法就是显示指定调用那个基类的版本菱形继承和虚继承两个派生类继承同一个基类而又有某个类同时继承者两个派生类这种继承被称为菱形继承或者钻石型继承这种继承所带来的问题草泥马继承自动物的函数和数据继承了两份其实我们应该清楚这份数据我们只需要一份就可以并且还伴随二义性问题对于这种菱形继承所带来的两个问题为我们提供了一种方式采用虚基类作用编译器帮我们做了一些幕后工作使得这种菱形问题在继承时候能只继承一份数据并且也解决了二义性的问题使模型变成了和三个类对象共享了一份数据虚继承实现原理虚继承普通继承结果如下普通继承虚继承菱形最顶层的类内存布局图没有发生改变和通过虚继承的方式派生自这两个对象的布局图中可以看出编译器为我们的对象中增加了一个指向了一张表这张表保存了当前的虚指针相对于虚基类的首地址的偏移量派生于和继承了两个基类的指针并调整了与虚基类的首地址的偏移量当使用虚继承时在继承体系中无论被继承多少次对象内存模型中均只会出现一个虚基类的子对象这和多继承是完全不同的的存储结构指针访问类中虚表中的偏移量代码如下虚继承只能解决具备公共祖先的多继承所带来的二义性问题不能解决没有公共祖先的多继承的工程开发中真正意义上的多继承是几乎不被使用因为多重继承带来的代码复杂性远多于其带来的便利多重继承对代码维护性上的影响是灾难性的在设计方法上任何多继承都可以用单继承代替虚基类的构造函数最派生类继承结构中建立对象时所指定的类最派生类的构造函数的成员初始化列表中必须给出对虚基类的构造函数的调用如果未列出则相应的虚基类必须有缺省构造函数若是虚基类且没有缺省构造函数则必须如下写明初始化列表如果不是虚基类调用父类非默认构造函数只需要传入父类而如果祖先中有虚基类那么初始化列表中必须有虚基类单个虚基类的案例构造函数构造函数构造函数构造函数输出结果为虚基类构造函数永远先于非虚基类构造函数执行对象的内存布局图如下多个虚基类案例构造函数构造函数构造函数构造函数构造函数有多个虚基类则多个虚基类都要写进初始化列表除非有缺省构造函数构造函数内存布局分析因开发人员命令提示工具问题单字母类名与多同字母类名同等看待类名内存布局多态多态是面向对象程序设计语言中数据抽象和继承之外的第三个基本特征多态性提供接口与具体实现之间的另一层隔离静态多态运算符重载和函数重载动态多态条件先有继承关系父类中有虚函数子类重写父类中的虚函数父类的指针或引用指向子类的对象静态多态和动态多态的区别就是函数地址是早绑定静态联编还是晚绑定动态联编如果函数的调用在编译阶段就可以确定函数的调用地址并产生代码就是静态多态编译时多态就是说地址是早绑定的而如果函数的调用地址不能编译不能在编译期间确定而需要在运行时才能决定这这就属于晚绑定动态多态运行时多态重写覆盖是指派生类中存在重新定义的函数其函数名参数列表返回值类型所有都必须同基类中被重写的函数一致只有函数体不同花括号内派生类调用时会调用派生类的重写函数不会调用被重写函数重写的基类中被重写的函数必须有修饰动态多态案例虚函数代表其可被子类重写实现运行时多态动物在睡觉重写父类函数猫猫在睡觉重写父类函数狗狗在睡觉重载若把类中函数前的去掉结果如下则不能实现运行时多态父类引用指向子类对象的四种方式纯虚类接口继承自接口接口指针被指向对象为栈上分配内存指针被指向对象为堆上分配内存引用被引用对象为栈上分配内存引用被引用对象为堆上分配内存这一句指针获取语句必须有如果直接的话这里创建的临时对象没有被任何智能指针或其他变量捕获这意味着它将在当前语句结束时变成无主对象因为没有地方存储指向它的指针以供后续释放动态多态原理原理详解向上类型转换及问题若上面代码未用虚函数则运行结果如上图问题抛出我们给函数传入的对象是和输出的结果却是动物在睡觉把函数体与函数调用相联系称为绑定捆绑当绑定在程序运行之前由编译器和连接器完成时称为早绑定语言中只有一种函数调用方式就是早绑定上面的问题就是由于早绑定引起的因为编译器在只有地址时并不知道要调用的正确函数编译是根据指向对象的指针或引用的类型来选择函数调用这个时候由于的参数类型是编译器确定了应该调用的是的而不是真正传入的对象分割线中小插曲允许用父类的指针或引用指向子类的对象但不强制类型转换的情况下父类指针或引用是访问不到子类新增的成员的编译器决定任何妄图使用父类指针或引用想调用子类中的未覆盖父类的成员函数的行为均被编译器视为非法但实际上可以通过指针的方式间接访问虚函数表来达到违反语义的行为解决上面的问题的方法就是迟绑定迟捆绑动态绑定运行时绑定意味着绑定要根据对象的实际类型发生在运行迟绑定实现方案原理对于特定的函数进行动态绑定要求在基类中声明这个函数的时候使用关键字动态绑定也就对函数起作用为创建一个需要动态绑定的虚成员函数可以简单在这个函数声明前面加上关键字定义时候不需要如果一个函数在基类中被声明为那么在所有派生类中它都是的在派生类中函数的重定义称为重写关键字只能修饰成员函数构造函数不能为虚函数注意可以在派生类声明前使用关键字这也是无害的建议加上让人一看代码就知道这个函数是对父类函数进行重写的首先我们看看编译器如何处理虚函数当编译器发现我们的类中有虚函数的时候编译器会创建一张虚函数表把虚函数的函数入口地址放到虚函数表中并且在类中秘密增加一个指针这个指针就是缩写这个指针是指向对象的虚函数表在多态调用的时候根据指针找到虚函数表来实现动态绑定在编译阶段编译器秘密增加了一个指针但是此时指针并没有初始化指向虚函数表什么时候才会指向虚函数表在对象构建的时候也就是在对象初始化调用构造函数的时候编译器首先默认会在我们所编写的每一个构造函数中增加一些指针初始化的代码如果没有提供构造函数编译器会提供默认的构造函数那么就会在默认构造函数里做此项工作初始化指针使之指向本对象的虚函数表起初子类继承基类子类继承了基类的指针这个指针是指向基类虚函数表当子类调用构造函数使得子类的指针指向了子类的虚函数表当子类无重写基类虚函数时当子类重写基类虚函数时没用虚函数的情况第一个参数实际上是对象的首地址传进作为指针因此调用的永远是传参对象的首地址使用虚函数的情况将第一个参数即对象首地址放进将对象首地址指向的第一个成员即对应的虚函数表首地址放进中将对象首地址放进作为指针将虚函数表首地址中存的函数地址放进中所以调用的函数实现了运行时多态传参对象的首地址内存布局详解当父类写了虚函数后类内部的结构发生了改变多了虚函数表指针指向虚函数表虚函数表内部记录着虚函数的入口地址当父类指针或引用指向子类对象发生多态调用的时候是从虚函数表中找函数入口地址加了虚函数指针后内存布局上面运行多态类名对象内存布局案例中用父类指针手动调用子类函数一样注意函数指针也要必须调用约定一致才可成功此处成功只是刚好一致而已形如如下的指定了调用约定的函数指针变量单继承中虚函数在单继承形式下子类的完全获得父类的虚函数表和数据子类如果重写了父类的虚函数如就会把虚函数表原本对应的记录内容覆盖为新的函数地址内容否则继续保持原本的函数地址记录如果子类定义了新的虚函数虚函数表内会追加一条记录记录该函数的地址如动物在睡觉动物在玩耍重写父类函数猫猫在睡觉新增的虚函数猫猫在做某事类名内存布局编译器在处理第二条语句时发现这是一个多态的调用那么就会按照如下对虚函数的多态访问机制调用函数指针调整量虚函数在内的偏移多重继承中的虚函数图解上面代码对象空间布局如下重点解读和单重继承类似多重继承时会把所有的父类全部按序包含在自身内部而且每一个父类都对应一个单独的虚函数表多重继承下子类不再具有自身的虚函数表它的虚函数表与第一个父类的虚函数表合并了同样的如果子类重写了任意父类的虚函数都会覆盖对应的函数地址记录如果重写了函数两个父类都有该函数那么两个虚函数表的记录都需要被覆盖多重继承中同时存在虚继承和虚函数上面案例修改为如下由于虚继承的本身语义内必须重写函数因此我们需要再重写函数虚继承的引入把对象的模型变得十分复杂除了每个基类和和公共基类的虚函数表指针需要记录外每个虚拟继承了的父类还需要记录一个虚基类表的指针虚基类表每项记录了被继承的虚基类子对象相对于虚基类表指针的偏移量比如的虚基类表第二项记录值为正是相对于的偏移量同理的虚基类表第二项记录值也正是相对于的偏移量和虚函数表不同的是虚基类表的第一项记录着当前子对象相对与虚基类表指针的偏移和子对象内的虚表指针都是存储在相对于自身的字节偏移处因此该值是假定和或者内没有定义新的虚函数即不会产生虚函数表那么虚基类表第一项字段的值应该是通过以上的对象组织形式编译器解决了公共虚基类的多份拷贝的问题通过每个父类的虚基类表指针都能找到被公共使用的虚基类的子对象的位置并依次访问虚基类子对象的数据至于虚基类定义的虚函数它和其他的虚函数的访问形式相同本例中如果使用虚基类指针访问对象的将会被转化为如下形式通过以上的描述我们基本认清了的对象模型尤其是在多重虚拟继承下的复杂结构通过这些真实的例子使得我们认清内的本质注意指针的位置和基类成员在派生类成员中的内存布局是不确定的也就是说标准里面没有规定必须要放在最后只不过编译器的实现而已标准大概只规定了这套机制的原理至于具体的实现比如各成员的排放顺序和优化由各个编译器厂商自己定多继承中的虚表内存布局当有多个虚函数表时虚函数表的结果是代表没有下一个虚函数表非末尾的其他虚函数表由什么代表结束在不同操作系统中不一样代表有下一个虚函数表父类中没有而子类中有的虚函数都填入第一个虚函数表中注意在打印对象虚函数表的时候只打印最上层基类声明的虚函数即虚函数表显示不全需要用监视或内存窗口手动显示虚表的所有内容多态的实际开发意义多态的好处代码可读性强组织结构清晰扩展性强面向对象程序设计原则开闭原则对扩展进行开放对修改进行关闭解释开闭原则含义是说一个软件实体应该通过扩展来实现变化而不是通过修改已有的代码来实现变化的原因没有修改底层模块代码改变量少可以有效的防止风险的扩散开闭原则实现方法就是多态开闭原则的好处提高复用性提高维护性提高拓展性未采用开闭原则案例计算器这种程序不利于扩展维护困难如果修改功能或者扩展功能需要在源代码基础上修改面向对象程序设计一个基本原则开闭原则对修改关闭对扩展开放抽象基类加法计算器减法计算器乘法计算器计算结果多态的案例华硕华硕处理器已就绪显卡已就绪金士顿内存条金士顿内存条已就绪华硕华硕金士顿内存条金士顿内存条纯虚函数和抽象类在设计时常常希望基类仅仅作为其派生类的一个接口这就是说仅想对基类进行向上类型转换使用它的接口而不希望用户实际的创建一个基类的对象同时创建一个纯虚函数允许接口中放置成员原函数而不一定要提供一段可能对这个函数毫无意义的代码为了上面的目的可以在基类中加入至少一个纯虚函数使得基类称为抽象类纯虚函数使用关键字并在其后面加上如果试图去实例化一个抽象类编译器则会阻止这种操作返回类型函数名当继承一个抽象类的时候必须实现所有的纯虚函数否则由抽象类派生的类也是一个抽象类告诉编译器在中为函数保留一个位置但在这个特定位置不放地址建立公共接口目的是为了将子类公共的操作抽象出来可以通过一个公共接口来操纵一组类且这个公共接口不需要事先实现或者不需要完全实现案例如下抽象制作饮品烧水冲泡倒入杯中加入辅料规定流程制作咖啡烧水煮农夫山泉冲泡冲泡咖啡倒入杯中将咖啡倒入杯中加入辅料加入牛奶制作茶水烧水煮自来水冲泡冲泡茶叶倒入杯中将茶水倒入杯中加入辅料加入食盐业务函数纯虚函数和多继承多继承带来了一些争议但是接口继承可以说一种毫无争议的运用了绝大数面向对象语言都不支持多继承但是绝大数面向对象对象语言都支持接口的概念中没有接口的概念但是可以通过纯虚函数实现接口不同点在于接口类中只有函数原型定义没有任何数据定义多重继承接口不会带来二义性和复杂性问题接口类只是一个功能声明并不是功能实现子类需要根据功能说明定义功能实现只有纯虚函数的抽象类其他语言中的接口实际上就是只有纯虚函数的抽象类这种格式的意义在于契约定义接口首先是一种契约它定义了一个类必须实现哪些方法但不关心这些方法的具体实现这种契约的机制允许不同的类实现相同的接口从而可以在不同的实现之间进行切换而不影响使用这些类的代码解耦接口是解耦合的强大工具通过依赖于接口而不是具体的实现我们可以改变具体的实现而不需要修改依赖于这些接口的代码这对于构建易于测试维护和扩展的系统尤为重要多继承在很多面向对象的编程语言中类只能从一个类继承单继承但是可以实现多个接口这提供了一种形式的多继承允许对象拥有来自多个源的行为灵活性和可拓展性接口使得代码更加灵活和可拓展例如如果你的应用开始时使用的是一种算法或数据结构随着应用的发展你可能需要替换为更高效的实现如果你的代码依赖于接口而不是具体的实现这种替换会变得非常简单接口与多态性关于多态性虽然通过继承包括抽象类和具体类的继承也能实现多态性但接口提供了另一种方式接口允许不同的类共享同一个接口的定义这意味着我们可以使用接口类型的引用来调用实现了该接口的任何类的实例的方法例如考虑一个日志系统你可能有多种方式来记录日志文件数据库远程服务等如果所有这些日志记录器实现了同一个接口比如那么你可以在不同的记录器之间切换而不改变使用这些记录器的代码这种灵活性是使用接口的直接好处以一段为例子看接口只有纯虚函数的抽象类的作用实现逻辑实现逻辑这样类中的方法可以接受任何实现了接口的对象作为参数这样就利用到了多态性可见接口能实现更灵活的多态入门对接口和抽象类的理解实际开发中经常会同时使用接口和抽象类接口定义行为的契约而抽象类提供部分实现虚析构和纯虚析构虚析构函数和纯虚构函数都是为了解决基类的指针指向派生类对象并用基类的指针删除派生类对象产生的只调用了基类的析构函数而没有调用派生类的析构函数的问题构造析构构造析构返回结果为构造构造析构可见只调用了基类的析构函数而没有调用派生类的析构函数如果在的析构函数定义前加结果为构造构造析构析构纯虚析构函数纯虚析构函数在中是合法的但是在使用的时候有一个额外的限制必须在类外为纯虚析构函数提供一个函数体非纯虚析构函数类内与类外定义都行纯析构函数类不是抽象类可以实例化对象类是抽象类不可以实例化对象如果类的目的不是为了实现多态作为基类来使用就不要声明虚析构函数反之则应该为类声明虚析构函数原因如下这是因为在使用继承和多态的情况下如果一个基类指针指向一个派生类对象并且通过基类指针删除该对象时如果基类的析构函数不是虚函数那么只会调用基类的析构函数而不会调用派生类的析构函数这可能导致派生类中的资源无法正确释放从而引发内存泄漏或其他问题通过将基类的析构函数声明为虚函数可以解决这个问题当通过基类指针删除派生类对象时会首先调用派生类的析构函数然后再调用基类的析构函数确保派生类中的资源得到正确释放因此如果你的类可能会被继承并且在使用多态时需要通过基类指针来删除对象那么应该将析构函数声明为虚函数这样可以确保在删除对象时调用正确的析构函数避免资源泄漏和其他问题然而如果你的类不会被继承或不会用于多态那么声明虚析构函数可能会带来额外的开销因此在这种情况下可以不声明虚析构函数这样可以避免不必要的开销并保持代码的简洁性重写重载重定义区别重载同一作用域的同名函数同一个作用域参数个数参数顺序参数类型不同和函数返回值没有关系也可以作为重载条件重定义隐藏有继承子类派生类重新定义父类基类的同名成员非函数子类隐藏父类所有同名重载函数可以用作用域显式调用重写覆盖有继承子类派生类重写父类基类的函数函数返回值函数名字函数参数必须和基类中的虚函数一致多态与别的语言的区别盘点入门与多态对比与多态对比位域语言入门位域语言中的位域只能用于整型数据类型如等而还支持对非整数类型的位域进行定义如布尔类型枚举类型等对齐规则的差异在语言中位域的对齐规则是相对于结构体的起始位置不同位域之间可能会进行位填充以满足对齐要求在中位域的对齐规则是相对于前一个位域的结束位置不会进行位填充因此位域之间不会有空隙既可以使用也可以使用的位域案例模板模板参数列表中除了允许包含类型模板参数也允许包含非类型模板参数这些参数可以是整型包括但不限于及其对应的带符号整型枚举类型指针或引用到对象或函数以及对于整数类型用户可以在模板实例化时传入一个整数常量表达式作为模板参数的值正确传入整数常量作为模板参数函数模板提供了函数模板所谓函数模板实际上是建立一个通用函数其函数类型和形参类型不具体制定用一个虚拟的类型来代表这个通用函数就成为函数模板凡是函数体相同的函数都可以用这个模板代替不必定义多个函数只需在模板中定义一次即可在调用函数时系统会根据实参的类型来取代模板中的虚拟类型从而实现不同函数的功能提供两种模板机制函数模板和类模板模板用于表达逻辑结构相同但具体数据元素类型不同的数据对象的通用行为目的用模板是为了实现泛型可以减轻编程的工作量增强函数的重用性格式上下两种完全一样是自定义通用数据类型名称两种使用方式自动类型推导通过参数必须要推导出一致的才可以使用显示指定类型下面是实现对通用基本数据类型数组进行排序的案例通用模板实现数据交换模板实现通用类型快速排序方法由小到大函数模板和普通函数区别函数模板如果使用自动类型推导是不可以发生隐式类型转换的可以使用显示指定类型方式调用函数模板此时可以发生隐式类型转换普通函数可以发生隐式类型转换函数模板普通函数调用函数模板严格匹配类型调用普通函数调用普通函数普通函数可以隐式类型转换结论函数模板如果使用自动类型推导不允许自动类型转换必须严格匹配类型普通函数可以进行自动类型转换函数模板和普通函数的调用规则若函数模板和普通函数都可以调用那么优先调用普通函数若想强制调用函数模板可以使用空模板参数列表空模板函数模板也可以发生重载肯定呀本质上就是编译器帮你把所有用到的各种类型都写了若函数模板能产生更好的匹配不用隐式转换的情况那么优先使用函数模板函数模板普通函数如果函数模板和普通函数都能匹配编译器优先考虑普通函数如果我必须要调用函数模板那么怎么办此时普通函数也可以匹配因为普通函数可以自动类型转换但是此时函数模板能够有更好的匹配如果函数模板可以产生一个更好的匹配那么选择模板函数模板重载如果函数模板和普通函数都能匹配编译器优先考虑普通函数函数模板机制原理剖析函数模板机制结论编译器并不是把函数模板处理成能够处理任何类型的函数只是基本数据类型函数模板通过具体类型产生不同的函数两次编译在声明的地方对模板代码本身进行编译语法检测在调用的地方对参数替换后的代码进行编译产生不同的函数这也就是模板的分文件特殊化的原因成员模板函数不能为虚函数同时也不能有默认参数函数模板分文件编写函数模板的分文件编写与类模板分文件编写一致参考类模板的分文件编写章节函数模板特化也称为模板具体化上面提到模板并不是真实的通用对于自定义的数据类型可以使用具体化技术实现对自定义数据类型的特殊使用格式如下案例普通交换函数第三代具体化显示具体化的原型和定意思以开头并通过名称来指出类型具体化优先于常规模板函数模板特化有两种形式明确特化和部分特化明确特化是指为特定类型或参数提供完全不同的函数实现它使用语法来声明特化版本并提供特定的实现下面是一个示例展示了如何对函数模板进行明确特化声明一个函数模板明确特化的实现在上面的示例中我们定义了一个函数模板它可以打印任意类型的值然后通过使用语法我们对进行了明确特化为类型提供了一个特殊的实现部分特化是指对函数模板的一部分参数进行特化它使用模板参数的部分列表来匹配特定的实例并提供特定的实现下面是一个示例展示了如何对函数模板进行部分特化声明一个函数模板部分特化的实现在上面的示例中我们对进行了部分特化为特定的参数组合提供了一个特殊的实现类模板类模板和函数模板的区别类模板不可以使用自动类型推导只能用显示指定类型错误类模板中可以有默认参数函数模板不可以有类模板中的成员函数并不是一开始就创建的而是在运行阶段确定出的数据类型才去创建我是我是有这句话才报错有这句话才报错因此类模板中的成员函数并不是一开始就创建的而是在运行阶段确定出的数据类型才去创建此时有问题才报错类模板做函数参数三种方式指定传入类型参数模板化整个类模板化类型为查看的数据类型类型为指定函数参数的传入类型要求传入的参数必须是类型为为参数模板化将参数模板化可自动类型推导或显式指定类型为为将整个类模板化可自动类型推导或显式指定类型为为自动推导和类型转换类模板和派生两种情况如下类模板派生普通类类模板子类实例化的时候需要具体化的父类子类需要知道父类的具体类型是什么样的这样编译器才能知道给子类分配多少内存普通派生类类模板派生类模板父类类模板本质上是一样的类模板中的成员函数类外实现写法如下直接这样写会报错应该用下面写法此时编译器并不知道具体是哪个类的该函数因为要传指针所以必须知道实际上是什么类模板类是一系列类的集合因此必须指明类外实现上述代码中如果不按照这个格式写会报错如下类模板的分文件编写类模板中的成员函数不会一开始就创建因此导致分文件编写时连接不到函数的实现出现无法解析的外部命令错误编译器可以顺利通过编译并执行但是在和编辑器下如果只包含头文件那么会报错链接错误需要包含文件但是如果类模板中有友元类那么编译失败原因类模板需要二次编译在出现模板的地方编译一次在调用模板的地方再次编译编译规则为独立编译编译器编译源码逐个编译单元编译的两种解决方式直接包含文件实现和声明都放在一个文件中就不用两个文件了不推荐将文件后缀名改为其实本质依旧是将类声明和实现写到同一个文件中调用的时候的是也可以用后缀虚幻引擎使用后缀总之就是模板的定义必须和声明放在同一个文件中更详细的流程可以参考此知乎链接函数模板的分文件编写与类模板分文件编写一致这也导致了的模板库基本是开源的如果库的用户不需要去产生这个模板的新的实例化类型则可以在库内部的模板实现文件中对所有可能的类型进行显式实例化如果库的用户有产生新的实例化类型的需求则无法隐藏实现模板二次编译编译器编译源码逐个编译单元编译的类模板和静态成员直接看案例类模板中的友元函数友元函数在类中声明时函数名后接表示函数模板要到类外找也可以友元函数直接写成函数模板声明方便号位置的函数模板声明声明函数模板是存在此处为号位置友元函数在类内实现友元函数在类内实现友元函数类外实现此处并非友元函数模板而是模板类中的友元函数告诉编译器这个函数模板是存在此处为号位置之前的号位置用于声明此处存在编译器本来看到这里会去找普通的友元函数因为他没有但因为有了空的编译器看到才会去找下面的函数模板类模板碰到友元函数模板类模板碰到友元函数友元函数类外实现加上空参数列表告诉编译去匹配函数模板函数模板的方式不写可以编译通过写了之后会找的普通函数调用因为写了普通函数的声明设计一个动态数组模板类完成对不同类型元素的管理重点案例其中涉及到内存泄露检测动态数组模板类内含检测堆是否释放完全的方法头文件不改变原来的拼接写行表示用函数模板的方式这样也可以就不用写了改变原来的拼接插入删除清空数据推入栈顶弹出栈顶数据获取长度获取容量源文件一个如果是对象那么这个对象必须提供默认的构造函数一个一个一个一个如果有原内存空间删除原内存空间是否有必要存疑在此处插入语句查看容量是够足够拼接不够的话就扩容需要扩容不能处理重叠位置的挪移要用需要扩容文件下面用于定位内存泄露位置用类来测试动态数组模板类无参构造必须提供默认构造函数才能供构造析构拷贝构造等于号赋值有参构造必须提供默认构造函数才能供输出显示年龄名称小明小黑小红小白用于检测内存泄露必须放在此处开辟函数的目的是为了当函数执行完后该释放的内存早该释放了此时才可以在这里测试是否有内存泄露重点用于拷贝字节如果目标区域和源区域有重叠的话能够保证源串在被覆盖之前将重叠区域的字节拷贝到目标区域中但复制后源内容会被更改但是当目标区域与源区域没有重叠则和函数功能相同重点崩溃的调试定位问题技巧崩溃的时候在弹出的对话框按相应按钮进入调试按键查看即调用堆栈里面从上到下列出的对应从里层到外层的函数调用历史双击某一行可将光标定位到此次调用的源代码或汇编指令处看不懂时双击下一行直到能看懂为止类模板特化模板特化是从标准开始引入的特性并在后续的标准中进行了一些改进和扩展因此无论是还是都支持模板特化在中你可以通过使用语法来实现模板特化下面是一个示例展示了如何对一个类模板进行明确特化声明一个类模板明确特化的实现在上面的示例中我们定义了一个类模板并为其提供了一个通用的实现然后通过使用语法我们对进行了明确特化并提供了一个特定的实现你还可以进行部分特化对模板的一部分参数进行特化下面是一个示例声明一个类模板部分特化的实现在上面的示例中我们对进行了部分特化为特定的参数组合提供了一个特殊的实现模板模板参数模板模板参数是在标准中引入的这意味着从开始就可以使用模板模板参数来定义模板将模板作为另一个模板的参数模板模板参数是中的一项强大的模板技术它提供了更高级的模板编程能力使得代码更加灵活和通用它允许你以模板作为参数传递给其他模板从而实现更复杂的泛型编程和模板元编程类型转换静态类型转换语法目标变量原变量原对象允许内置数据类型转换允许父子之间的指针或引用的转换上行转换是安全的下行转换是不安全的但都允许无继承关系指针转换转换失败动态类型转换语法目标变量原变量原对象不允许内置数据类型转换允许父子之间指针或引用的上行转换但若发生多态总是安全的下行转换在多态的情况下也可以用转换总结将一切不安全的情况扼杀于萌芽继承关系指针子类指针转换成父类指针可以父类指针转换成子类指针不可以多态内含虚函数并且重写了中那虚函数父类指针转换成子类指针本不可以但因为是多态所以可以常量转换作用该运算符用来修改指针或引用类型的属性常量指针被转化成非常量指针或非常量指针被转化成常量指针并且仍然指向原来的对象常量引用被转换成非常量引用或非常量引用被转换成常量引用并且仍然指向原来的对象注意不能直接对非指针和非引用的变量使用操作符去直接移除它的常量指针常量指针被转化成非常量指针非常量指针被转化成常量指针不能对非指针或非引用进行转换常量引用非常量引用被转换成常量引用重新解释转换这是最不安全的一种转换机制最有可能出问题同时也最自由什么都可以转理解等同于语言的强制类型转换转无继承关系指针转换异常异常的基本概念说提供异常的基本目的就是为了处理上面的问题基本思想是让一个函数在发现了自己无法处理的错误时抛出一个异常然后它的直接或者间接调用者能够处理这个问题也就是中说的将问题检测和问题处理相分离一种思想在所有支持异常处理的编程语言中例如要认识到的一个思想在异常处理过程中由问题检测代码可以抛出一个对象给问题处理代码通过这个对象的类型和内容实际上完成了两个部分的通信通信的内容是出现了什么错误当然各种语言对异常的具体实现有着或多或少的区别但是这个通信的思想是不变的一句话异常处理就是处理程序中的错误所谓错误是指在程序运行的过程中发生的一些异常事件如除溢出数组下标越界所要读取的文件不存在空指针内存不足等等语言中的异常处理中仍然可以使用整型的返回值标识错误使用宏可以简单的理解为一个全局整型变量去记录错误可用输出上述方法的两个缺陷返回值意义不一致问题例如表示错误还是表示错误函数的返回值只有一个虽然可以通过指针或引用来返回另外的值但这样就会令你的程序晦涩难懂异常的必要之处部分函数使用异常更好处理比如构造函数没有返回值不方便使用错误码方式处理比如这样的函数如果越界了只能使用异常或者终止程序处理没办法通过返回值表示错误很多的第三方库都包含异常比如等等常用的库那么我们使用它们也需要使用异常异常机制相比语言异常处理的优势语言中没有内建的异常机制类似于其他高级语言中的块通常语言程序员会使用错误码或者返回值来处理异常情况函数的返回值可以忽略但异常不可忽略如果程序出现异常但是没有被捕获程序就会终止这多少会促使程序员开发出来的程序更健壮一点而如果使用语言的宏或者函数返回值调用者都有可能忘记检查从而没有对错误进行处理结果造成程序莫名其面的终止或出现错误的结果整型返回值没有任何语义信息而异常却包含语义信息有时你从类名就能够体现出来整型返回值缺乏相关的上下文信息异常作为一个类可以拥有自己的成员这些成员就可以传递足够的信息异常处理可以在调用跳级这是一个代码编写时的问题假设在有多个函数的调用栈中出现了某个错误使用整型返回码要求你在每一级函数中都要进行处理而使用异常处理的栈展开机制只需要在一处进行处理就可以了不需要每级函数都处理异常机制缺陷案例如果判断返回值那么返回值是错误码还是结果如果不判断返回值那么时候程序结果已经不正确写的代码写的代码由于没有处理异常导致结果运算错误写的代码更严重的是由于没有继续抛出异常导致的代码没有办法捕获异常所以我们希望异常应该捕获如果你捕获可以那么异常必须继续抛给上层函数你不处理不代表你的上层不处理这个例子异常没有捕获的结果就是运行结果错的一塌糊涂结果未知未知的结果程序没有必要执行下去异常的一直不处理最终程序会终止调用该函数中默认调用最终中止程序运行异常基本语法异常的关键词若有异常则通过操作创建一个异常对象或变量并抛出类似会结束当前函数将可能抛出异常的程序段放到块之中如果想捕获其他类型如果在段执行期间没有引起异常那么跟在后面的字句就不会执行子句会根据出现的先后顺序被检查匹配的语句捕获并处理异常或继续抛出异常异常必须有函数进行处理如果匹配的处理未找到则运行函数将自动被调用其缺省功能调用终止程序处理不了的异常可以在的最后一个分支使用向上抛异常可以是自定义类型写的代码写代码比较粗心忘记处理异常由于没有处理异常导致结果运算错误写的代码没有处理异常程序直接中断执行处理异常更严重的是由于没有继续抛出异常导致的代码没有办法捕获异常除数为异常处理使得异常的引发和异常的处理不必在一个函数中这样底层的函数可以着重解决具体问题而不必过多的考虑异常的处理上层调用者可以在适当的位置设计对不同类型异常的处理异常严格类型匹配捕捉方式是通过严格类型匹配即不存在隐式类型转换自定义异常我自己的异常开始抛出异常抛出类型异常抛出类型异常抛出类型异常抛出的匿名对象抛出类型异常抛出类型异常抛出类型异常捕获自定义异常对象抛出类型异常捕获所有异常抛出其他类型异常栈解旋异常被抛出后从进入块起到异常被抛掷前这期间在栈上构造的所有对象都会被自动析构析构的顺序与构造的顺序相反这一过程称为栈的解旋对象被创建对象被析构抛出异常此句未输出此句未输出异常被捕获异常接口声明可以在函数声明中列出可能抛出异常的所有类型即限定抛出异常的类型这个函数能够且只能抛出类型及其子类型的异常如果在函数声明中没有包含异常接口声明则此函数可以抛任何类型的异常一个不抛任何类型异常的函数可声明为代表不允许抛出异常如果一个函数抛出了它的异常接口声明所不允许抛出的异常函数会被调用该函数默认行为调用函数中断程序可抛出所有类型异常只能抛出类型异常不能抛出任何类型异常运行中断报错运行中断报错捕获异常分别在下做测试正确接口声明不影响使用但不能正常发挥限制异常抛出类型的作用异常变量生命周期默认构造函数拷贝构造函数析构函数修改位对应不同输出结果修改位对应不同输出结果异常被捕获其他异常被捕获修改位是修改位是调用拷贝构造函数效率低修改位是修改位是只调用默认构造函数效率高推荐修改位是修改位是对象会提前释放掉不能再非法操作显然的情况在中调用的函数会报错因为已被析构总结第二种方式才是正确的做法异常的多态使用提供基类异常类内含纯虚函数空指针异常类和越界异常类继承重写函数测试利用父类引用指向子类对象越界异常越界异常异常原理语言入门栈区函数调用解析参考语言的函数栈架构主要承载着以下几个部分传递参数通常函数的调用参数总是在这个函数栈框架的最顶端传递返回地址告诉被调用者的语句应该到哪里去通常指向该函数调用的下一条语句代码段中的偏移存放调用者的当前栈指针便于清理被调用者的所有局部变量并恢复调用者的现场存放当前函数内的所有局部变量所有局部和临时变量都是存储在栈上的使用了异常处理机制的函数调用首先澄清一点这里说的函数是指该函数可能会直接或间接地抛出一个异常即该函数的定义存放在一个编译而不是传统单元内并且该函数没有使用异常过滤器该函数的定义内使用了块以上两者满足其一即可为了能够成功地捕获异常和正确地完成栈回退编译器必须要引入一些额外的数据结构和相应的处理机制我们首先来看看引入了异常处理机制的栈框架大概是什么样子由上图可见在每个函数的栈框架中都多了一个类型的结构体进一步分析就会发现这是一个典型的单向链表式结构成员指向链表的上一个节点它主要用于在函数调用栈中逐级向上寻找匹配的块并完成栈回退工作成员指向完成异常捕获和栈回退所必须的数据结构主要是两张记载着关键数据的表块表及栈回退表成员用来定位块以及在栈回退表中寻找正确的入口需要说明的是编译器会为每一个函数定义一个结构不过只会为包含了块的函数定义成员此外异常处理器还会为每个线程维护一个指向当前异常处理框架的指针该指针指向异常处理器链表的链尾通常存放在某个槽或能起到类似作用的地方栈回退栈回退是伴随异常处理机制引入中的一个新概念主要用来确保在异常被抛出捕获并处理后所有生命期已结束的对象都会被正确地析构它们所占用的空间会被正确地回收下面描述编译器是如何实现栈回退机制的图中的函数内所有真实代码均以黑色和蓝色字体标示编译器生成的代码则由灰色和橙色字体标明此时在图里给出的变量和成员作用就十分明显了变量用于跟踪函数内局部对象的构造析构阶段再配合编译器为每个函数生成的表就可以完成退栈机制表中的字段记录了对应阶段应当执行的析构操作析构函数指针字段则记录了与之相对应的对象指针偏移将所指的偏移值加上当前栈框架基址就是要代入所指析构函数的指针这样即可完成对该对象的析构工作而字段则指向下一个需要析构对象所在的行下标在发生异常时异常处理器首先检查当前函数栈框架内的值并通过取得表然后将作为下标带入表中执行该行定义的析构操作然后转向由指向的下一行直到为为止在当前函数的栈回退工作结束后异常处理器可沿当前函数栈框架内的值回溯到异常处理链中的上一节点重复上述操作直到所有回退工作完成为止值得一提的是的值完全在编译时决定运行时仅需执行若干次简单的整形立即数赋值通常是直接赋值给里的某个寄存器此外对于所有内部类型以及使用了默认构造析构方法并且它的所有成员和基类也使用了默认方法的类型其创建和销毁均不影响的值栈回退的触发当发生异常且没有立即捕获时会启动栈回退过程栈回退会逐层销毁当前作用域中的对象调用这些对象的析构函数以确保资源得到释放析构函数在栈回退中的执行在栈回退过程中对象的析构函数会被调用如果析构函数抛出异常就会与原始异常相冲突因为此时已经有一个异常正在传播异常处理机制的限制的异常处理机制无法同时处理两个异常所以如果在栈回退异常传播过程中析构函数再抛出新的异常就会导致异常中的异常问题这会调用并结束程序析构函数处理异常析构函数不应主动抛出异常在中析构函数的一个核心原则是不抛异常如果析构函数中的代码可能会抛出异常应该尽量用捕获并在必要时记录日志而不是将异常传播到析构函数外在特殊情况下使用如果析构函数确实执行了可能引发异常的复杂操作例如文件操作资源释放等此时可以使用与引入的来检测当前是否存在未捕获的异常以决定是否抑制抛出新的异常异常捕获一个异常被抛出时就会立即引发的异常捕获机制在上一小节中我们已经看到了变量在跟踪对象构造析构方面的作用实际上除了能够跟踪对象创建销毁阶段以外还能够标识当前执行点是否在块中以及如果当前函数有多个块的话究竟在哪个块中这是通过在每一个块的入口和出口各为赋予一个唯一值并确保在对应块内的变化恰在此范围之内来实现的在具体实现异常捕获时首先异常处理器检查发生异常的位置是否在当前函数的某个块之内这项工作可以通过将当前函数的值依次在指向表的条目中进行范围为的比对来完成例如上图中的在时发生了异常则通过比对的表发现故该异常发生在内的第一个块中其次如果异常发生的位置在当前函数中的某个块内则尝试匹配该相应条目中的表表中记录了与指定块配套出现的所有块相关信息包括这个块所能捕获的异常类型及其起始地址等信息若找到了一个匹配的块则复制当前异常对象到此块然后跳转到其入口地址执行块内代码否则则说明异常发生位置不在当前函数的块内或者这个块中没有与当前异常相匹配的块此时则沿着函数栈框架中所指地址即异常处理链中的上一个节点逐级重复以上过程直至找到一个匹配的块或到达异常处理链的首节点对于后者我们称为发生了未捕获的异常对于异常处理器而言未捕获的异常是一个严重错误将导致当前进程被强制结束抛出异常在编译一段代码时编译器会将所有语句替换为其运行时库中的某一指定函数这里我们叫它与本文提到的所有其它数据结构和属性名一样在实际应用中它可以是任意名称该函数接收一个编译器认可的内部结构我们叫它结构这个结构中包含了待抛出异常对象的起始地址用于销毁它的析构函数以及它的信息对于没有启用机制编译器禁用了机制或没有在类层次结构中使用虚表的异常类层次结构可能还要包含其所有基类的信息以便与相应的块进行匹配在图中的深灰色框图内我们使用伪代码展示了函数中的语句将被编译器最终翻译成的样子实际上在多数情况下函数即我们前面曾多次提到的异常处理器异常捕获和栈回退等各项重要工作都由它来完成首先接收并保存对象然后从处找到与当前函数对应的等异常处理相关数据并按照前文所述的机制完成异常捕获和栈回退由此完成了包括抛出捕获回退等步骤的整套异常处理机制总结程序在抛出异常后则通过当前的获得该结构体中记录着栈回退表和语句块的信息首先去语句块中寻找匹配的语句块如果没有找到则进行进行栈回退到上一层的函数重复这个过程直到找到匹配的语句块如果一直到达异常处理链的顶点都没有找到则强制结束进程当然也有可能在当前的栈帧中就没有语句块那就直接进行栈回退去匹配语句块中的结构化异常处理带有一种名为结构化异常处理的机制非常著名的内存访问违例出错对话框就是该机制的一种体现结构化异常处理与前文讨论的异常处理机制有惊人的相似之处同样使用类似的链式结构实现对于下的应用程序只需使用注册异常处理器用替代前文所述的等很少的改动即可将此两种错误处理机制合而为一这样做的优势十分明显由于可直接借助操作系统提供的机制所以简化了异常处理器的实现使块得以捕获操作系统产生的异常如内存访问违例等等使操作系统的异常处理机制能够捕获所有异常实际上大多数下的编译器的异常机制均使用这种方式实现开销分析了解其某一特性的实现原理主要是为了避免错误地使用该特性要达到这个目的还要在了解实现原理的基础上进行一些额外的开销分析工作特性时间开销空间开销无运行时开销每函数一个对象其中的成员仅在函数中包含至少一个块时使用典型情况下小于字节栈框架极高的效率每次调用时进行次额外的整形赋值和一次访问每调用两个指针和一个整形开销典型情况下小于字节跟踪极高的效率每次进出块或对象构造析构一次整形立即数赋值无已记入栈框架中的相应项目异常的抛出捕获和栈回退异常的抛出是一次级操作在单个函数中进行捕获和栈回退也均为操作但异常捕获的总体成本为其中等于当前函数调用栈中从抛出异常的位置到达匹配块之间所经过的函数调用中包含块即定义了有效的函数个数栈回退的总成本为其中等于当前函数调用栈中从抛出异常的位置到达匹配块之间所经过的函数调用数在异常处理结束前需保存异常对象及其析构函数指针和相应的信息具体根据对象尺寸编译器选项是否开启及异常捕获器的参数传递方式传值或传址等因素有较大变化典型情况下小于字节可以看出在没有抛出异常时的异常处理机制是十分有效的在有异常被抛出后可能会依当前函数调用栈的情形进行若干次整形比较块表匹配操作但这通常不会超过几十次对于大多数年前的来说整形比较也只需时钟周期所以异常捕获的效率还是很高的栈回退的效率则与语句基本相当考虑到即使是传统的函数调用错误处理和逐级返回机制也不是没有代价的这些开销在绝大多数情形下仍可以接受空间开销方面每函数一个结构体的引入在某些极端情形下会明显增加目标文件尺寸和内存开销但是典型情况下它们的影响并不大但也没有小到可以完全忽略的程度如果正在为一个资源严格受限的环境开发应用程序你可能需要考虑关闭异常处理和机制以节约存储空间以上讨论的是一种典型的异常机制的实现方式各具体编译器厂商可能有自己的优化和改进方案但总体的出入不会很大标准异常库标准库介绍标准库中也提供了很多的异常类它们是通过类继承组织起来的异常类继承层级结构图如下每个类所在的头文件在图下方标识出来颜色对应其头文件标准异常类的成员在上述继承体系中每个类都有提供了构造函数复制构造函数和赋值操作符重载类及其子类类及其子类它们的构造函数是接受一个类型的形式参数用于异常信息的描述所有的异常类都有一个方法返回类型风格字符串的值描述异常信息标准异常类的具体描述异常名称描述所有标准异常类的父类当请求分配内存失败时这是个特殊的异常如果函数的异常抛出列表里声明了异常当函数内部抛出了异常抛出列表中没有的异常这是调用的函数中若抛出异常不论什么类型都会被替换为类型使用操作符操作一个指针而该指针是带有虚函数的类这时抛出异常使用转换引用失败的时候操作过程出现错误逻辑错误可以在运行前检测的错误运行时错误仅在运行时才可以检测的错误的子类异常名称描述试图生成一个超出该类型最大长度的对象时例如的操作参数的值域错误主要用在数学函数中例如使用一个负值调用只能操作非负数的函数超出有效范围参数不合适在标准库中当利用对象构造时而中的字符不是或的时候抛出该异常的子类异常名称描述计算结果超出了有意义的值域范围算术计算上溢算术计算下溢参数不合适在标准库中当利用对象构造时而中的字符不是或的时候抛出该异常案例如下年龄应该在岁之间实际使用的时候往往是不需要自己抛异常的比如容器会自动抛异常开发者只需要处理异常就可以了编写自己的异常类标准库中的异常是有限的在自己的异常类中可以添加自己的信息标准库中的异常类值允许设置一个用来描述异常的字符串如何编写自己的异常类建议自己的异常类要继承标准异常类因为中可以抛出任何类型的异常所以我们的异常类可以不继承自标准异常但是这样可能会导致程序混乱尤其是当我们多人协同开发时当继承标准异常类时应该重载父类的函数和虚析构函数因为栈展开的过程中要复制异常类型那么要根据你在类中添加的成员考虑是否提供自己的复制构造函数自定义异常类可以隐式类型转换为反之不可以基类中有这个则重写时候必须写转换为用函数抛出异常越界越界年龄必须在之间长度异常我的异常年龄必须在之间围绕函数体建立异常处理程序是一种函数体的替代语法形式是函数定义的一部分它的行为比较复杂对于普通函数和构造函数析构函数在到达结尾时候的行为不太一致可以认为是比较坑的函数块的主要目的是应对从构造函数中的成员初始化器列表抛出的异常进行记录并重抛修改异常对象并重抛抛出一个不同的异常或终止程序它们很少为析构函数或常规函数所用这里为构造函数隐式到达析构函数上函数块的子句的末尾也会自动重新抛出当前异常就像一样但允许使用语句不抛出异常索引在边界内抛出异常越界在进入任何构造函数上的函数块的子句前所有完整构造的成员和基类都会被销毁如果构造函数或析构函数上使用的函数块的子句访问对象的基类或非静态成员则行为未定义异常安全什么是异常安全的函数需要满足下面两条不泄露任何资源不允许数据结构遭到损坏面对构造和析构构造函数提供强异常保证确保构造函数要么成功完成创建对象要么失败后不影响程序状态强异常保证析构函数提供无失败保证确保析构函数不会抛出异常以保证资源安全地释放最稳妥是使用与修饰析构函数局部异常处理的思想重点在于抛出异常的合理性构造函数中若遇到无法恢复的错误如内存不足应抛出异常但对于非关键性错误如一些简单的参数错误可以考虑通过其他手段处理减少异常的传播成本输入和输出流流的概念和流类库的结构程序的输入指的是从输入文件将数据传送给程序程序的输出指的是从程序将数据传送给输出文件输入输出包含以下三个方面的内容对系统指定的标准设备的输入和输出即从键盘输入数据输出到显示器屏幕这种输入输出称为标准的输入输出简称标准以外存磁盘文件为对象进行输入和输出即从磁盘文件输入数据数据输出到磁盘文件以外存文件为对象的输入输出称为文件的输入输出简称文件对内存中指定的空间进行输入和输出通常指定一个字符数组作为存储空间实际上可以利用该空间存储任何信息这种输入和输出称为字符串输入输出简称串编译系统提供了用于输入输出的类库这个单词是由个部分组成的即意为输入输出流在类库中包含许多用于输入输出的类常用的见表是抽象基类由它派生出类和类两个类名中第个字母和分别代表输入和输出类支持输入操作类支持输出操作类支持输入输出操作类是从类和类通过多重继承而派生的类其继承层次见上图表示对文件的输入输出需要用和类两个类名中第个字母和分别代表输入和输出第个字母代表文件支持对文件的输入操作支持对文件的输出操作类继承了类类继承了类类继承了类见图类库中还有其他一些类但是对于一般用户来说以上这些已能满足需要了与类库有关的头文件类库中不同的类的声明被放在不同的头文件中用户在自己的程序中用命令包含了有关的头文件就相当于在本程序中声明了所需要用到的类可以换种说法头文件是程序与类库的接口类库的接口分别由不同的头文件来实现常用的有包含了对输入输出流进行操作所需的基本信息用于用户管理的文件的操作用于字符串流用于混合使用和的机制时例如想将程序转变为程序在使用格式化时应包含此头文件在头文件中定义的流对象在头文件中定义的类有等在头文件中不仅定义了有关的类还定义了种流对象对象含义对应设备对应的类语言中相应的标准文件标准输入流键盘标准输出流屏幕标准错误流屏幕标准日志流屏幕在头文件中定义以上个流对象用以下的形式以为例在定义为流类对象时把标准输出设备作为参数这样它就与标准输出设备显示器联系起来如果有就会在显示器的屏幕上输出在头文件中重载运算符和本来在中是被定义为左位移运算符和右位移运算符的由于在头文件中对它们进行了重载使它们能用作标准类型数据的输入和输出运算符所以在用它们的程序中必须用命令把包含到程序中表示将数据放入对象中表示将对象中存储的数据拿出标准流标准对象流对象是的缩写意为在控制台终端显示器的输出强调几点不是预定义的关键字它是流类的对象在中定义顾名思义流是流动的数据流是流向显示器的数据流中的数据是用流插入运算符顺序加入的如果有按顺序将字符串插人到流中就将它们送到显示器在显示器上输出字符串流是容纳数据的载体它并不是一个运算符人们关心的是流中的内容也就是向显示器输出什么用输出基本类型的数据时可以不必考虑数据是什么类型系统会判断数据的类型并根据其类型选择调用与之匹配的运算符重载函数这个过程都是自动的用户不必干预如果在语言中用函数输出不同类型的数据必须分别指定相应的输出格式符十分麻烦而且容易出错的机制对用户来说显然是方便而安全的流在内存中对应开辟了一个缓冲区用来存放流中的数据当向流插人一个时不论缓冲区是否已满都立即输出流中所有数据然后插入一个换行符并刷新流清空缓冲区注意如果插人一个换行符如则只输出和换行而不刷新流但并不是所有编译系统都体现出这一区别在中只对和运算符用于标准类型数据的输入输出进行了重载但未对用户声明的类型数据的输入输出进行重载如果用户声明了新的类型并希望用和运算符对其进行输入输出按照重运算符重载来做流对象流对象是标准错误流流已被指定为与显示器关联的作用是向标准错误设备输出有关出错信息与标准输出流的作用和用法差不多但有一点不同流通常是传送到显示器输出但也可以被重定向输出到磁盘文件而流中的信息只能在显示器输出当调试程序时往往不希望程序运行时的出错信息被送到其他文件而要求在显示器上及时输出这时应该用流中的信息是用户根据需要指定的流对象流对象也是标准日志流它是的缩写它的作用和相同都是在终端显示器上显示出错误信息区别是不经过缓冲区直接向显示器上输出有关信息而中的信息存放在缓冲区中缓冲区满后或遇时向显示器输出缓冲区的概念标准输入流标准输入流对象重点掌握的函数一次只能读取一个字符一个参数读一个字符两个参数可以读字符串读字符串忽略默认忽略个若填入参数代表忽略个字符偷窥从缓冲区只看不取放回放回缓冲区队列头标志位标志位复位为用来更改的状态标示符的用来清除缓存区的数据流环境下不能使用尽量用替代重点注意和的区别输入一个字母型变量中放了型数据置输出输入一个数字由于值为输入流不能正常工作故此处的输入无效输出不确定值此处用流标志复位此处已为输入一个数字但刚才输入的字符并没有从流中清除所以又把那个字符放入中流输入流又不能正常工作输出不确定值在此处又为再次修复输入流取走刚才流中的字符输入一个数字再次接收用记输入这次输入数字正常输出了现在再看一下输入流的输出表明输入流已恢复正常重点注意和的区别遇换行符结束读取换行符遗留在缓冲区所以要处理已读取了个字符或遇到了文件尾或遇到了分隔符结束读取若遇到换行符结束读取丢弃换行符换行符不在缓冲区也不被取走而是直接丢掉重点注意和的区别从输入流中提取字符提取的字符被忽略不被使用每抛弃一个字符它都要计数和比较字符如果计数值达到或者被抛弃的字符是则函数执行终止否则它继续等待它的一个常用功能就是用来清除以回车结束的输入缓冲区的内容消除上一次输入对下一次输入的影响比如可以这么用通常把第一个参数设置得足够大这样实际上总是只有第二个参数起作用所以这一句就是把回车包括回车之前的所以字符从输入缓冲流中清除出去的作用就是清除输入缓冲区成功时返回失败时会置位函数返回另外对于绑定了输出的输入流调用还会刷新输出缓冲区重点注意实践得知下并不能清空输入缓冲区因此用替代把第一个参数设置得足够大这样实际上总是只有第二个参数起作用所以这一句就是把回车包括回车之前的所以字符从输入缓冲流中清除出去用此来达到清空数据流的操作这样就能吃掉一大段了但理论上依旧不能保证吃掉一行注意需要把用括号括起来避免和定义的宏混淆因为中定义了所以会产生编译错误程序执行时有一个标志变量来标志输入的异常状态其中有三位标志位分别用来标志三种异常信息他们分别是这三个标志位在标志变量中是这样分配的类定义了这四个常量其实这四个标志常量就是取对应标志位的掩码也即输入的四种异常情况输入输出流出现致命错误不可挽回已经到达文件尾输入输出流出现非致命错误可挽回流状态完全正常各异常标志位都为可以用输出语句来验证这几个常量的值注意与的返回值相同当读取不匹配类型的值或时会造成流错误而返回只有才会返回非其他函数讲解链式编程忽略缓冲区当前字符将数据放回缓冲区从缓冲区取走一个字符从缓冲区取走的字符将数据再放回缓冲区偷窥偷窥下缓冲区的数据偷窥缓冲区数据练习作业使用和完成类似功能请输入一个数字或者字符串数字字符串标准输出流刷新缓冲区下有效向缓冲区写字符从中向缓冲区写个字节到当前输出流中刷新缓冲区下有效刷新缓冲区输出一个字符链式编程输出字符串输出多少个格式化输出在输出数据时为简便起见往往不指定输出的格式由系统根据数据的类型采取默认的格式但有时希望数据按指定的格式输出如要求以十六进制或八进制形式输出一个整数对输出的小数只保留两位小数等有两种方法可以达到此目的使用控制符的方法使用流对象的有关成员函数使用流对象的有关成员函数通过调用流对象中用于控制输出格式的成员函数来控制输出格式用于控制输出格式的常用的成员函数如下流成员函数和控制符括号中的参数表示格式状态它是通过格式标志来指定的格式标志在类中被定义为枚举值因此在引用这些格式标志时要在前面加上类名和域运算符格式标志见表控制符格式化输出提供了在输入输出流中使用的控制符有的书中称为操纵符需要头文件通过流成员函数卸载十进制使用控制符对程序的几点说明注意点成员函数和控制符只对其后的第一个输出项有效之后依然按按系统默认的域宽输出如果要求在输出数据时都按指定的同一域宽输出不能只调用一次而必须在输出每一项前都调用一次在表中的输出格式状态分为组每一组中同时只能选用一种例如和中只能选一它们是互相排斥的在用成员函数和控制符设置输出格式状态后如果想改设置为同组的另一状态应当调用成员函数对应于成员函数或对应于控制符先终止原来设置的状态然后再设置其他状态大家可以从本程序中看到这点程序在开始虽然没有用成员函数和控制符设置用输出格式状态但系统默认指定为因此要改变为或也应当先用函数终止原来设置若未终止格式就设置别的格式设置的格式均不起作用系统依然以未终止格式输出用函数设置格式状态时可以包含两个或多个格式标志由于这些格式标志在类中被定义为枚举值每一个格式标志以一个二进位代表因此可以用位或运算符组合多个格式标志如包含两个状态标志用组合可以看到对输出格式的控制既可以用控制符也可以用流的有关成员函数二者的作用是相同的控制符是在头文件中定义的因此用控制符时必须包含头文件流的成员函数是在头文件中定义的因此只需包含头文件不必包含许多程序人员感到使用控制符方便简单可以在一个输出语句中连续使用多种控制符文件读写头文件文件流类和文件流对象输入输出是以系统指定的标准设备输入设备为键盘输出设备为显示器为对象的在实际应用中常以磁盘文件作为对象即从磁盘文件读取数据将数据输出到磁盘文件和文件有关系的输入输出类主要在这个头文件中被定义在这个头文件中主要被定义了三个类由这三个类控制对文件的各种输入输出操作他们分别是其中类是由类派生而来他们之间的继承关系见下图所示图中打错了应该是由于文件设备并不像显示器屏幕与键盘那样是标准默认设备所以它在头文件中是没有像那样预先定义的全局对象所以我们必须自己定义一个该类的对象类它是从类派生的用来支持从磁盘文件的输入类它是从类派生的用来支持向磁盘文件的输出类它是从类派生的用来支持对磁盘文件的输入输出打开文件所谓打开文件是一种形象的说法如同打开房门就可以进入房间活动一样打开文件是指在文件读写之前做必要的准备工作包括为文件流对象和指定的磁盘文件建立关联以便使文件流流向指定的磁盘文件指定文件的工作方式如该文件是作为输入文件还是输出文件是文件还是二进制文件等以上工作可以通过两种不同的方法实现调用文件流的成员函数如定义类输出文件流类对象使文件流与文件建立关联第行是调用输出文件流的成员函数打开磁盘文件并指定它为输出文件文件流对象将向磁盘文件输出数据是模式的一种表示以输出方式打开一个文件或者简单地说此时是一个输出文件接收从内存输出的数据磁盘文件名可以包括路径如如缺省路径则默认为当前目录下的文件在定义文件流对象时指定参数在声明文件流类时定义了带参数的构造函数其中包含了打开磁盘文件的功能因此可以在定义文件流对象时指定参数调用文件流类的构造函数来实现打开文件的功能几点说明新版本的类库中不提供和每一个打开的文件都有一个文件指针该指针的初始位置由方式指定每次读写都从文件指针的当前位置开始每读入一个字节指针就后移一个字节当文件指针移到最后就会遇到文件结束文件结束符也占一个字节其值为此时流对象的成员函数的值为非值一般设为表示文件结束了可以用位或运算符对输入输出方式进行组合如表中最后行所示那样还可以举出下面一些例子打开一个输入文件若文件不存在则返回打开失败的信息打开一个输出文件在文件尾接着写数据若文件不存在则返回打开失败的信息打开一个新文件作为输出文件如果文件已存在则返回打开失败的信息打开一个二进制文件可读可写但不能组合互相排斥的方式如如果打开操作失败函数的返回值为假如果是用调用构造函数的方式打开文件的则流对象的值为可以据此测试打开是否成功如或关闭文件在对已打开的磁盘文件的读写操作完成后应关闭该文件关闭文件用成员函数如将输出文件流所关联的磁盘文件关闭所谓关闭实际上是解除该磁盘文件与文件流的关联原来设置的工作方式也失效这样就不能再通过文件流对该文件进行输入或输出此时可以将文件流与其他磁盘文件建立关联通过文件流对新的文件进行输入或输出如文件路径打开方式此时文件流与建立关联并指定了的工作方式对文件的读写操作如果文件的每一个字节中均以代码形式存放数据即一个字节存放一个字符这个文件就是文件或称字符文件程序可以从文件中读入若干个字符也可以向它输出一些字符用流插入运算符和流提取运算符输入输出标准类型的数据和都巳在中被重载为能用于和类对象的标准类型的输入输出由于和分别是和类的派生类因此它们从和类继承了公用的重载函数所以在对磁盘文件的操作中可以通过文件流对象和流插入运算符及流提取运算符实现对磁盘文件的读写如同用和对标准设备进行读写一样用文件流的等成员函数进行字符的输入输出用流成员函数输出单个字符函数读入一个字符和函数读入一行字符创建文件输入流对象创建文件输出流对象文件打开失败关闭文件流对象种读写方式打开文件判断文件是否打开成功文件打开失败第一种方式第二种方式第三种方式全局函数需要头文件第四种方式关闭文件注意全局和流对象中的的区别的对象中存在读到哪个读多少函数此外还存在一个全局函数需要头文件从哪读读到哪类型分隔符可选项注意将文件指针移动到文件开头为文件流对象清空好坏标志位将光标回到文件头对二进制文件的读写操作二进制文件不是以代码存放数据的它将内存中数据存储形式不加转换地传送到磁盘文件因此它又称为内存数据的映像文件因为文件中的信息不是字符数据而是字节中的二进制形式的信息因此它又称为字节文件对二进制文件的操作也需要先打开文件用完后要关闭文件在打开时要用指定为以二进制形式传送和存储二进制文件除了可以作为输入文件或输出文件外还可以是既能输入又能输出的文件这是和文件不同的地方用成员函数和读写二进制文件对二进制文件的读写主要用类的成员函数和来实现这两个成员函数的原型为字符指针指向内存中一段存储空间是读写的字节数调用的方式为上面第一行中的是输出文件流对象函数将字符指针所给出的地址开始的个字节的内容不加转换地写到磁盘文件中在第二行中是输入文件流对象函数从所关联的磁盘文件中读入个字节或遇结束存放在字符指针所指的一段空间内二进制模式读写文件创建文件对象输出流对象写入文件关闭文件输出流从文件中读取对象数组打开失败关闭文件输入流断言断言就是对一个表达式的判断当表达式为假时就输出诊断消息并调用函数中止程序断言的使用格式如果指定的表达式为程序会终止并显示诊断消息和头文件分别是用于在和中进行断言的头文件断言语句仅在定义了时才进行编译在发布版本中断言不会产生开销或性能成本断言不能代替程序中的错误检查只能出现于理所当然正确的地方与性能分析参考此文其实对一个优秀的编译器而言的各种特性本身就是使用汇编加以千锤百炼而最优化实现的可以说想用甚至汇编比编译器更高效地实现某个特性几乎是不可能的要是真能做到这一点的话就应该去写个编译器造福广大程序员才对相对与传统程序而言中有可能引入额外运行时开销的新特性包括虚基类虚函数和异常异常对于大多数现代编译器来说在正常情况未抛出异常下块中的代码执行效率和普通代码一样高而且由于不再需要使用传统上通过返回值或函数调用来判断错误的方式代码的实际执行效率还可能进一步提高抛出和捕捉异常的效率也只是在某些情况下才会稍低于函数正常返回的效率何况对于一个编写良好的程序抛出和捕捉异常的机会应该不多对象的构造和析构对象的构造和析构开销也不总是存在对于不需要初始化销毁的类型并没有构造和析构的开销相反对于那些需要初始化销毁的类型来说即使用传统的方式实现也至少需要与之相当的开销这里要注意的一点是尽量不要让构造和析构函数过于臃肿特别是在一个类层次结构中更要注意时刻保持你的构造析构函数中只有最必要的初始化和销毁操作把那些并不是每个子对象都需要执行的操作留给其他方法和派生类去解决之所以被广泛认为比低效其根本原因在于由于程序员对某些特性的实现方式及其产生的开销不够了解致使他们在错误的场合使用了错误的特性而这些错误基本都集中在把异常当作另一种流控机制而不是仅将其用于错误处理中一个类和或其基类的构造析构函数过于臃肿包含了很多非初始化销毁范畴的代码滥用或不正确地使用虚函数和虚基类机制将源代码封装成类代码将宏定义常量主要是整形和字符串一些连续的整形值可以定义成枚举类型宏函数简单的宏函数可以改写成内联函数如果比较复杂可以改写成类的成员函数若成员函数都用到了某个变量可以将这个变量设置为类的成员变量通过类的访问控制权限控制一般只有成员可以对外界访问不被外界访问的可以设置成成员或者成员内存泄露检测知识点调试技巧注意点篇重点崩溃的调试定位问题技巧崩溃的时候在弹出的对话框按相应按钮进入调试按键查看即调用堆栈里面从上到下列出的对应从里层到外层的函数调用历史双击某一行可将光标定位到此次调用的源代码或汇编指令处看不懂时双击下一行直到能看懂为止编译选项基本运行时检查的作用详情见链接如何使用第三方库最原始的方法就是自己建一个目录把依赖的库的源代码直接放里面是一个开发包通常包含用于编译和链接程序的头文件和库有大量的包管理器包括等内含自己的包管理器这里提一嘴谷歌的构建工具以及魔改版的配合使用开发包在中设置将包安装在固定的目录通常是在文件中需要手动设置变量指向包的安装目录如果是在上应该是这样就能够找到安装的包的头文件和库文件使用命令查找并链接包在中使用命令来查找需要的包例如然后在目标库上链接该包包管理器是的跨平台开源软件包管理器极大地简化了和上第三方库的下载与安装如果项目要使用第三方库建议通过来安装它们同时支持开源和专有库与的比较源码级兼容在编写程序时一直有二进制兼容的问题在可执行文件链接到三方库时编译器的类型和版本的统一非常重要通过下载源码而不是二进制文件的方式来提供三方库下载与安装的官方源码站点下面介绍的是二进制方式安装下载编译平台在中执行工程目录下的命令编译好后会在同级目录下生成文件平台在命令行中执行在工程目录下命令会生成一个可执行文件定义环境变量想到处使用别忘了添加到中比如注意想要使用系统带的路径就设置为全局就可以使用同一个使用查看支持的库安装一个库查看已安装的库移除已经安装的库集成使用提供了一套机制可以全自动的适配目录而开发者不需要关心已安装的库的目录在哪里也不需要设置集成到全局输入后返回表示集成成功并提供了一个在项目中使用的提示你可以将该指令添加到你的构建命令中以确保能够正确地使用安装的库在项目根目录执行命令表示的路径位置具体而言命令会执行以下操作在当前用户的目录下创建一个名为的隐藏文件夹用于存储的集成信息将的路径添加到系统环境变量中以便在构建项目时能够找到针对不同的开发环境自动配置构建工具如等的相关设置以确保它们能够正确地使用移除集成之后与一起使用时需添加依赖以及在设置路径与配合使用以库为例成功的话将返回如下寻找添加的库添加库链接编写如下为安装的根目录与手动执行效果一致上面这一行针对某些包不管用实测比如说等测试框架此时使用下面的命令在上寻找添加的库添加库链接与的区别主要针对平台而支持和主要使用作为构建系统而支持多种构建系统包括和库库是一个优秀的可移植开源的库它是由标准委员会库工作自成员发起它是对的延续和扩充设计理念和比较接近都是利用泛型让复用达到最大化其中有些内容经常成为下一代标准库内容在社区影响很大是不折不扣的准标准库相比更加实用集中在算法部分而包含了不少工具类可以完成比较具体的工作当下在开发中熟练掌握的使用可谓是必备的主要包含一下几个大类字符串及文本处理容器迭代子算法函数对象和高阶编程泛型编程模板元编程预处理元编程并发编程数学相关纠错和测试数据结构输入输出跨语言支持内存相关语法分析杂项有一些库是跨类别包含的就是既属于这个类别又属于那个类别通用开源框架和库点击参考更多库记录是一系列算法容器迭代器和其他基本组件的集合源代码库提供了同行的评审和可移植的源代码库大量通用库的集合来自于彭博资讯实验室的开发环境提供专业品质创造性编码的开源开发社区轻量级的只包含头文件的库将的一些新特性移植到中使用契约式编程和现代科技设计的通用的跨平台的库公共部分企业应用程序开发框架由开发和使用的开源库包罗万象的类库用于开发跨平台软件用于构建高性能和高度可扩展性系统的事件框架用于实时的视频流和高性能网络应用程序的语言写的多平台工具库库的设计包括常见的设计模式和习语的实现只含头文件的小型库开发工具包用于创意性编码跨平台的应用程序和用户界面框架跨平台的框架使开发者能够更容易地使用和同时也满足了他们对性能和优势的需求具备所有功能的一系列面向对象的框架能够非常高效地处理和分析大量的数据为欧洲原子能研究机构所用是具有代表性的版本用于额外的大型数据集的标准模板库跨平台快速应用程序开发框架用于开发应用程序和组件的库的开放人工智能游戏行为树启动器工具基于模板的演化计算库能够帮助你非常快速地编写出自己的随机优化算法框架编程语言集用于创建人工智能应用程序的多用途软件系统异步事件循环用于网络和底层编程的跨平台的库功能齐全高性能的时间循环轻微地仿效但是不再像一样有局限性也修复了它的一些事件通知库跨平台异步音频声音音乐数字化音乐库易于使用的跨平台的音频引擎和音频内容的游戏创作工具音频和音乐数字信号处理库开源音频库跨平台的音频一个完全开放的免版税的高度通用的音频编解码器免费编解码器为所废弃易用和高效的音频合成是一种完全开放的非专有的免版税的通用压缩音频格式生物信息基因组学和生物技术用于表示和分析群体遗传学数据的库专注于生物数据序列分析的算法和数据结构用于解析和处理文件的库直接把联想测试应用到文件的基因结构变异压缩和归档库一个完全免费免费专利和高质量的数据压缩能够快速解压缩的压缩库对各种归档提供抽象访问的库主要用于视频游戏设计灵感部分来自于的文件子系统用于创建读写和操作文件档案例如和的库它通过的一系列子类使用格式提供了透明的压缩和解压缩的数据非常快速的压缩算法无损压缩数据库压缩比率跟接近但是解压缩速度却要快得多格式默认和通用的压缩方法及其快速的实时无损数据压缩库单一的源文件紧缩膨胀压缩库使用兼容归档读写写方式最新修复支持磁盘跨越加密和缓冲快速压缩和解压缩非常紧凑的数据流压缩库提供归档的读权限并发执行和多线程用于的计算库针对进行优化的模板库用于的反应性编程库线程构件块基于的加速流体仿真库并行编程的异构系统的开放标准类似于标准模板库的并行算法库用于任何规模的并行和分布式应用程序的通用运行时系统用于的向量表达式模板库容器基于树数据结构树和二叉树数据结构实现命令内存容器的模板库中开放寻址哈希表算法的实现密码学一个跨平台的文件加密工具加密文件可以移植到所有可支持的操作系统和处理器中加密库一个有关加密方案的免费的库标准的完整实现实现了和协议的安全通信库免费的协议属于的一个分支一个非常全面的模块化的可移植的加密工具基于的加密库固执己见容易使用底层的加密库一个强大的商用的功能齐全的开放源代码的加密库用实现的一个小巧可移植的实现了的加密算法数据库服务器驱动程序和工具用于的对象关系映射用于数据库数据库的很简单的客户端库快速键值存储库符合数据库四大基本元素的嵌入键值存储封装了的的包装器来自的嵌入键值的快速存储一个完全嵌入式的功能齐全的关系数据库只有几百可以正确包含到你的项目中调试库内存和资源泄露检测单元测试测试库一个很时尚的原生的框架只包含头文件用于单元测试测试驱动开发和行为驱动开发由移植过来的测试框架测试驱动程序谷歌测试框架用于跟踪内存错误的多平台调试堆用语言编写测试用于跟踪内存分配跨平台的网络试图分析器使用写的迷你单元测试框架只使用了两个宏用于视图的单一文件分析器轻量级的单元测试框架游戏引擎一个跨平台框架用于构建游戏互动图书演示和其他图形应用程序社区项目用于构建一个免费的游戏引擎实现开放的世界游戏语言编写的开源高性能的实时引擎实现的用于创建游戏的开源框架与绑定图形用户界面很灵活的跨平台库快速轻量级的跨平台的工具包用于创建图形用户界面的跨平台工具包用于受欢迎的库的官方接口拥有最小依赖关系的立即模式图形用户界面是一个游戏接口中间件快速灵活简单的终端用户界面没有更多依赖关系的绘图控件用户与技术应用的控件功能丰富的基于的编程库本质上提供了一群控件是用于嵌入式系统和互动娱乐软件的用户界面开发解决方案包含源代码和预编译库的公共图形函数库库允许开发人员使用一个代码库可以为和其他平台创建应用程序图形跨平台的渲染库支持多种输出设备的图形库一个小型的渲染和动画引擎和图形引擎用编写的一个面向场景实时灵活的渲染引擎并非游戏引擎具有高性能的开源图形工具包用于渲染和游戏开发的框架用和编写用于绘制文字图形和图像的完整的图形库跨平台的渲染和游戏引擎图像处理通用图像库用于图像处理的小型开源工具包用于加载保存显示和转换的图像处理和转换库可以处理的图片格式包括开源库支持现在多媒体应用所需的通用图片格式和其他格式库跨平台的开源图像分析系统程序的接口程序的接口开源计算机视觉类库引擎用于图像分析通用计算机视觉库用于计算机图形学图像处理和可视化的开源免费软件系统国际化提供和全球化支持的和库用于不同字符编码之间的编码转换库的解析生成器进行编解码和处理数据的语言库中构建和迭代和文档的库非常健全的库只包含头文件解析器用可移植的编写的解析器占用内存非常少一个迷你的库非常简单的解析器语言中的解析和打印库很容易和任何模型集成轻量级的库中解析序列化只包含头文件用于数据和层次间的相互解析的简单类将数据映射到对象的基于的库用于的快速解析生成器包含和两种风格的语言中快速流解析库日志设计非常模块化并且具有扩展性日志库只包含单一的头文件一系列类库灵活添加日志到文件系统日志和其他地方轻量级库可以添加日志到你的应用程序中机器学习快速的神经网络框架以语言为核心的现代计算机视觉库可扩展的机器学习库开源计算机视觉库使用协同过滤进行产品推荐建议的语言库机器学习工具用于机器学习的快速增量算法套件数学高质量的线性代数库速度和易用性做到了很好的平衡语法和很相似高性能的数学库用于密集和稀疏算法来自谷歌的库用于建模和解决大型复杂非线性最小平方问题高效可靠的集合算法集合用于游戏和图形的免费数学库高级模板头文件库包括线性代数矩阵向量操作数值解决和其他相关的算法数学图形模板库是一组广泛实现基本图形的工具用于个高精度计算的库处理有符号整数有理数和浮点数多媒体构建媒体处理组件图形的库使用开放标准协议的多媒体流库媒体框架基于和的多媒体播放框架能够帮助你轻而易举地编写出一个播放器简单直控媒体层快速简单的多媒体库网络面向对象网络变成工具包用于网络和底层编程的跨平台的库高级网络编程的开源库集合语言的异步网络多协议文件传输库非常轻量级的网络服务器用于多线程服务器的非阻塞网络库的客户端服务器库基于语言的超轻型软件平台用于可扩展的服务器端和网络应用对于编程人员可以考虑语言服务器库其设计为轻量级易使用用于构建网络和基于互联网应用程序的类库可以运行在桌面服务器移动和嵌入式系统为游戏开发人员提供的跨平台的开源网络引擎用于之上的构建的异步框架基于的客户端服务器库高速模块化的异步通信物理学动力学仿真引擎的游戏物理引擎的游戏物理引擎快速轻量级的游戏物理库的游戏物理引擎开放动力学引擎开源高性能库模拟刚体动力学开源框架包装器高性能多体动力学物理库模拟关节生物力学和机械系统像车辆机器人和人体骨骼机器人学一组开源模块提供机器人平台的自主权尤其是自主的海洋车辆移动机器人编程工具包点云库是一个独立的大规模的开放项目用于图像和点云处理一个独立的库包括机器人动力学运动规划和控制一组库的集合用于机器人系统的仿真和控制机器人操作系统提供了一些库和工具帮助软件开发人员创建机器人应用程序科学计算用一维或者多维计算的语言库科学库脚本用于的易于使用的嵌入式脚本语言用于配置文件和基本应用程序脚本的小型快速脚本引擎用于创建绑定的一个可以让你的代码链接到和的包装器接口生成器嵌入式的引擎谷歌的快速引擎可以被嵌入到任何应用程序中序列化快速数据交换格式和系统序列化库内存高效的序列化库的高效二进制序列化库例如协议缓冲谷歌的数据交换格式语言的协议缓冲实现用于低延迟应用程序的对二进制格式的应用程序信息的编码和解码高效的跨语言用于和其它多种语言中最初由开发视频编码解码一个完整的跨平台的解决方案用于记录转换视频和音频流开放的视频编解码器的实现开源编解码器免费开源的视频压缩格式虚拟机中有趣的让我们一起来看看这个旨在实现单片机上的实现用纯粹的编写的小型快速轻量级的虚拟机应用框架提供易于使用强大的嵌入式服务器带有可选的和支持免费高性能的开发框架不是一个微型框架灵感来自于使用语言开发的用于应用程序的超快速和灵活的服务器框架轻量级的库帮助你使用编程语言创建服务器使用编写的基于库的框架试图效仿因此得此名开发应用的库就是个垃圾的解析很烦人对于计算机它也是个灾难这种糟糕的东西完全没有存在的理由了用语言编写的解析库的解析器和工具包的解析器用于的支持的轻量级简单快速的解析器试图创建最快速的解析器同时保持易用性可移植性和合理的兼容性简单小型的解析器可以很容易地集成到其它项目中简单快速的解析器可以很容易集成到其它项目中的一个全新的接口使用了的许多许多优势模板异常和更好的异常处理用可移植的的子集编写的验证解析器多项混杂一些有用的库或者工具但是不适合上面的分类或者还没有分类的小型安全和快速格式化库从派生的一系列核心库用于容器的打印库易于使用的生成库帮助开发人员禁止应用程序中的不安全的函数的简单的头文件编写和使用模拟类的库的请求响应解析器用于检测盒特征提取的小型库许可证管理器允许移动访问设备的通用库正则表达式库灵感来自于中正则表达式的功能的进程间通信框架开源的代码编辑控件语言编写的跨平台串口库的简单动态字符串库超轻的解析器超轻的正则表达式库移动机器人模拟器功能丰富面向对象的管理变量的框架条形码扫描器库可以扫描照片图片和视频流中的条形码并返回结果易于使用的正则表达式基于库的库使用来构建扩展的库的另一个字符串库功能更丰富但是没有缓冲溢出问题还包含了一个包装器编译器编译器列表由苹果公司开发的编译器集合由英特尔公司开发模块化和可重用编译器和工具链技术的集合由微软公司开发和交叉编译器和工具轻量级的语言编译器在线编译器列表在线编译器解释器一个简单的协作工具一个简单的在线编译器解释器你可以粘贴的或者代码在线执行并查看结果在线编译器支持各种编译器交互式编译器可以进行汇编输出上在线编译和执行程序一个在线编译器和调试工具允许你在线编译源代码并执行支持多种编程语言调试器列表来自维基百科的调试器列表调试器内存调试内存泄露检测性能分析工具集成开发环境列表构建与平台上的用于和开发的集成开发环境来自的跨平台的的集成开发环境免费和的集成开发环境另一个跨平台的免费的集成开发环境可移植的集成开发环境基于平台的功能齐全的和集成开发环境轻量级的快速跨平台的集成开发环境来自的家庭计算机集成开发环境由驱动的用于的微模式免费开源集成开发环境来自微软的集成开发环境主要用于开发的的集成开发环境也支持其他语言尤其是和跨平台的和集成开发环境也是的一部分的客户端服务器索引用于跟基于的的集成由苹果公司开发一个用于的根据你敲的代码快速模糊搜索并进行代码补全的引擎构建系统用于为工具生成编译数据库的工具基于文件的简单依赖管理器跨平台的免费开源软件用于管理软件使用独立编译的方法进行构建的过程基于和的包管理器高性能开源的构建系统支持高度可扩展性的编译缓冲和网络分布专注于速度的小型构建系统使用配置的软件构建工具高性能的代码构建系统甚至对于非常大型的软件项目也能提供最好的增量构建次数基于文件的构建系统用于后台监控变化的文件静态代码分析提高质量减少瑕疵的代码分析工具列表静态代码分析工具使用进行代码分析的工具可以在和文件中用于和的静态源代码分析工具用于提高质量减少瑕疵查找和程序的源代码分析工具来自维基百科的静态代码分析工具列表',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-28 18:12:05',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://th.bing.com/th/id/OIP.wtmjepfWPBvn26uz7s18dgHaHa?rs=1&amp;pid=ImgDetMain"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">ZEROKO14的个人博客</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size: 1.05rem;">C#<sup>3</sup></a><a href="/tags/C/" style="font-size: 1.05rem;">C++<sup>5</sup></a><a href="/tags/CSS/" style="font-size: 1.05rem;">CSS<sup>1</sup></a><a href="/tags/CSharp/" style="font-size: 1.05rem;">CSharp<sup>1</sup></a><a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 1.05rem;">C语言<sup>1</sup></a><a href="/tags/FPS/" style="font-size: 1.05rem;">FPS<sup>1</sup></a><a href="/tags/HTML/" style="font-size: 1.05rem;">HTML<sup>1</sup></a><a href="/tags/JavaScript/" style="font-size: 1.05rem;">JavaScript<sup>1</sup></a><a href="/tags/MFC/" style="font-size: 1.05rem;">MFC<sup>1</sup></a><a href="/tags/PE/" style="font-size: 1.05rem;">PE<sup>1</sup></a><a href="/tags/QT/" style="font-size: 1.05rem;">QT<sup>1</sup></a><a href="/tags/WPF/" style="font-size: 1.05rem;">WPF<sup>3</sup></a><a href="/tags/ai/" style="font-size: 1.05rem;">ai<sup>1</sup></a><a href="/tags/cmake/" style="font-size: 1.05rem;">cmake<sup>1</sup></a><a href="/tags/doxygen/" style="font-size: 1.05rem;">doxygen<sup>1</sup></a><a href="/tags/git/" style="font-size: 1.05rem;">git<sup>1</sup></a><a href="/tags/json/" style="font-size: 1.05rem;">json<sup>1</sup></a><a href="/tags/linux/" style="font-size: 1.05rem;">linux<sup>1</sup></a><a href="/tags/next/" style="font-size: 1.05rem;">next<sup>1</sup></a><a href="/tags/ppt/" style="font-size: 1.05rem;">ppt<sup>1</sup></a><a href="/tags/slidev/" style="font-size: 1.05rem;">slidev<sup>1</sup></a><a href="/tags/vue/" style="font-size: 1.05rem;">vue<sup>1</sup></a><a href="/tags/xml/" style="font-size: 1.05rem;">xml<sup>1</sup></a><a href="/tags/yaml/" style="font-size: 1.05rem;">yaml<sup>1</sup></a><a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 1.05rem;">代码规范<sup>1</sup></a><a href="/tags/%E5%86%85%E6%A0%B8/" style="font-size: 1.05rem;">内核<sup>2</sup></a><a href="/tags/%E5%86%85%E6%A0%B8%E7%9B%B8%E5%85%B3/" style="font-size: 1.05rem;">内核相关<sup>5</sup></a><a href="/tags/%E5%8A%A0%E8%A7%A3%E5%AF%86/" style="font-size: 1.05rem;">加解密<sup>1</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 1.05rem;">多线程<sup>1</sup></a><a href="/tags/%E5%BC%80%E5%8F%91/" style="font-size: 1.05rem;">开发<sup>4</sup></a><a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 1.05rem;">数学<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 1.05rem;">数据库<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 1.05rem;">数据结构<sup>1</sup></a><a href="/tags/%E6%9E%B6%E6%9E%84/" style="font-size: 1.05rem;">架构<sup>1</sup></a><a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 1.05rem;">正则表达式<sup>1</sup></a><a href="/tags/%E7%9B%91%E6%8E%A7/" style="font-size: 1.05rem;">监控<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 1.05rem;">算法<sup>1</sup></a><a href="/tags/%E7%AE%A1%E7%90%86/" style="font-size: 1.05rem;">管理<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 1.05rem;">网络<sup>2</sup></a><a href="/tags/%E9%80%86%E5%90%91/" style="font-size: 1.05rem;">逆向<sup>2</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/09/"><span class="card-archive-list-date">九月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">七月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">13</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/06/"><span class="card-archive-list-date">六月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/04/"><span class="card-archive-list-date">四月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">十一月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">27</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/12/"><span class="card-archive-list-date">十二月 2022</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/10/"><span class="card-archive-list-date">十月 2021</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2020/12/"><span class="card-archive-list-date">十二月 2020</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url">技术</a></span><span class="article-meta tags"></span></div></div><h1 class="post-title" itemprop="name headline">C++基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-07-16T04:06:28.928Z" title="发表于 2024-07-16 12:06:28">2024-07-16</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-10-28T10:12:05.496Z" title="更新于 2024-10-28 18:12:05">2024-10-28</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="C++基础"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为新加坡"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>新加坡</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://che77a38.github.io/posts/C++%E5%9F%BA%E7%A1%80/"><header><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url">技术</a><h1 id="CrawlerTitle" itemprop="name headline">C++基础</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">ZEROKO14</span><time itemprop="dateCreated datePublished" datetime="2024-07-16T04:06:28.928Z" title="发表于 2024-07-16 12:06:28">2024-07-16</time><time itemprop="dateCreated datePublished" datetime="2024-10-28T10:12:05.496Z" title="更新于 2024-10-28 18:12:05">2024-10-28</time></header><h1 id="C-概述"><a href="#C-概述" class="headerlink" title="C++概述"></a>C++概述</h1><blockquote>
<p>“c++”中的++来自于c语言中的递增运算符++，该运算符将变量加1。c++起初也叫”c with class”.通过名称表明，c++是对C的扩展，因此c++是c语言的超集，这意味着任何有效的c程序都是有效的c++程序。c++程序可以使用已有的c程序库。</p>
</blockquote>
<span id="more"></span>

<p><strong>库</strong>是编程模块的集合，可以在程序中调用它们。库对很多常见的编程问题提供了可靠的解决方法，因此可以节省程序员大量的时间和工作量。<br>$$<br>c++&#x3D;c+泛型编程+面向对象<br>$$<br>c++融合了3种不同的编程方式:</p>
<ol>
<li>c语言代表的过程性语言.</li>
<li>c++在c语言基础上添加的类代表的面向对象语言.</li>
<li>c++模板支持的泛型编程。</li>
</ol>
<h2 id="可移植性和标准"><a href="#可移植性和标准" class="headerlink" title="可移植性和标准"></a>可移植性和标准</h2><p>程序是否可移植性有两个问题需要解决。第一是硬件，针对特定硬件编程的程序是不可移植的。第二，语言的实现</p>
<p>为了兼容需要制定标准</p>
<p>新特性标准排序：（时间排序）</p>
<ol>
<li>c++98     已有的c++特性+异常+运行阶段类型识别(RTTI)+模板+标准模板库([[STL]])</li>
<li>c++11</li>
<li>c++14</li>
<li>c++17</li>
</ol>
<p> <code>对于传统的结构化语言，我们向来没有太多的疑惑，函数调用那么自然而明显，只是从程序的某一个地点调到另一个地点去执行。但是对于面向对象(OO)语言，我们疑惑就会很多。其原因就是c++编译器为我们程序员做了太多隐藏的工作：构造函数，析构函数、虚函数、继承、多态....有时候它为我们合成出一些额外的函数,有时候它又偷偷在我们写的函数里，放进更多的操作。有时候也会给我们的对象里放进一些奇妙的东西，使得我们sizeof的时候结果可我们预期不一样。</code></p>
<h2 id="简单的c-程序"><a href="#简单的c-程序" class="headerlink" title="简单的c++程序"></a>简单的c++程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;	</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//endl--end line表示刷新缓冲区并且换行</span></span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a><strong>注意：</strong></h2><h3 id="c-头文件为什么没有-h？"><a href="#c-头文件为什么没有-h？" class="headerlink" title="c++头文件为什么没有.h？"></a>c++头文件为什么没有.h？</h3><p>在c语言中头文件使用扩展名.h,将其作为一种通过名称标识文件类型的简单方式。但是c++得用法改变了，c++头文件没有扩展名。但是有些c语言的头文件被转换为c++的头文件，这些文件被重新命名，丢掉了扩展名.h(使之成为c++风格头文件)，并在文件名称前面加上前缀c(表明来自c语言)。例如c++版本的math.h为cmath.</p>
<p><code>由于C使用不同的扩展名来表示不同文件类型，因此用一些特殊的扩展名(如hpp或hxx)表示c++的头文件也是可以的，ANSI/IOS标准委员会也认为是可以的，但是关键问题是用哪个比较好，最后一致同意不适用任何扩展名。</code></p>
<table>
<thead>
<tr>
<th>头文件类型</th>
<th>约定</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>c++旧式风格</td>
<td>以.h结尾</td>
<td>iostream.h</td>
<td>c++程序可用</td>
</tr>
<tr>
<td>c旧式风格</td>
<td>以.h结尾</td>
<td>math.h</td>
<td>c&#x2F;c++程序可用</td>
</tr>
<tr>
<td>c++新式风格</td>
<td>无扩展名</td>
<td>iostream</td>
<td>c++程序可用，使用namespace std</td>
</tr>
<tr>
<td>转换后的c</td>
<td>加上前缀c,无扩展名</td>
<td>cmath</td>
<td>c++程序可用，可使用非c特性，如namespace std</td>
</tr>
</tbody></table>
<h3 id="using-namespace-std-是什么"><a href="#using-namespace-std-是什么" class="headerlink" title="using namespace std 是什么?"></a>using namespace std 是什么?</h3><p>namespace是指标识符的各种可见范围。命名空间用关键字namespace 来定义。命名空间是C++的一种机制，用来把单个标识符下的大量有逻辑联系的程序实体组合到一起。此标识符作为此组群的名字。</p>
<h2 id="面向过程思想"><a href="#面向过程思想" class="headerlink" title="面向过程思想"></a>面向过程思想</h2><blockquote>
<p>面向过程是一种以过程为中心的编程思想。</p>
<p>通过分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。</p>
</blockquote>
<p><strong>面向过程编程思想的核心</strong>：功能分解，自顶向下，逐层细化（程序&#x3D;[[数据结构]]+[[算法]]）。</p>
<p><strong>面向过程编程语言存在的主要缺点</strong>是不符合人的思维习惯，而是要用计算机的思维方式去处理问题，而且面向过程编程语言重用性低，维护困难。</p>
<h2 id="面向对象思想"><a href="#面向对象思想" class="headerlink" title="面向对象思想"></a>面向对象思想</h2><blockquote>
<p><em><strong>面向对象编程</strong></em>（Object-Oriented Programming）简称 OOP 技术，是开发计算机应用程序的一种新方法、新思想。过去的面向过程编程常常会导致所有的代码都包含在几个模块中，使程序难以阅读和维护。在做一些修改时常常牵一动百，使以后的开发和维护难以为继。而使用 OOP 技术，常常要使用许多代码模块，每个模块都只提供特定的功能，它们是彼此独立的，这样就增大了代码重用的几率，更加有利于软件的开发、维护和升级。</p>
</blockquote>
<p>在面向对象中，**[[算法]]与[[数据结构]]被看做是一个整体，称作对象**，现实世界中任何类的对象都具有一定的属性和操作，也总能用[[数据结构]]与[[算法]]两者合一地来描述，所以可以用下面的等式来定义对象和程序：<br>$$<br>对象 &#x3D; 算法 + 数据结构<br>$$</p>
<p>$$<br>程序 &#x3D; 对象 + 对象 + ……<br>$$</p>
<p><strong>面向对象编程思想的核心：应对变化，提高复用。</strong></p>
<h3 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h3><h4 id="封装特性"><a href="#封装特性" class="headerlink" title="封装特性"></a><a href="#%E7%B1%BB%E7%9A%84%E5%B0%81%E8%A3%85"><strong>封装特性</strong></a></h4><blockquote>
<p>把客观事物封装成抽象的类，<strong>并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。</strong></p>
</blockquote>
<p>类将成员变量和成员函数封装在类的内部，根据需要设置访问权限，通过成员函数管理内部状态。</p>
<h4 id="继承特性"><a href="#继承特性" class="headerlink" title="继承特性"></a><a href="#%E7%BB%A7%E6%89%BF"><strong>继承特性</strong></a></h4><blockquote>
<p>继承所表达的是类之间相关的关系，这种关系使得<strong>对象可以继承另外一类对象的特征和能力</strong>。</p>
</blockquote>
<p>继承的作用：避免公用代码的重复开发，减少代码和数据冗余。</p>
<h4 id="多态特性"><a href="#多态特性" class="headerlink" title="多态特性"></a><a href="#%E5%A4%9A%E6%80%81"><strong>多态特性</strong></a></h4><blockquote>
<p>多态性可以简单地概括为“一个接口，多种方法”，字面意思为多种形态。<strong>程序在运行时才决定调用的函数</strong>，它是面向对象编程领域的<strong>核心概念</strong>。</p>
</blockquote>
<h1 id="C-对C的扩展"><a href="#C-对C的扩展" class="headerlink" title="C++对C的扩展"></a>C++对C的扩展</h1><h2 id="作用域运算符"><a href="#作用域运算符" class="headerlink" title="::作用域运算符"></a>::作用域运算符</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//局部变量</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">	<span class="comment">//全局a被隐藏</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常情况下，如果有两个同名变量，一个是全局变量，另一个是局部变量，那么局部变量在其作用域内具有较高的优先权，它将屏蔽全局变量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//1. 局部变量和全局变量同名</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">	<span class="comment">//打印局部变量a</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;局部变量a:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//打印全局变量a</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;全局变量a:&quot;</span> &lt;&lt; ::a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子可以看出，<strong>作用域运算符</strong>可以用来解决局部变量与全局变量的重名问题，即在局部变量的作用域内，可用::对被屏蔽的同名的全局变量进行访问。</p>
<h3 id="无限定名字查找"><a href="#无限定名字查找" class="headerlink" title="无限定名字查找"></a>无限定名字查找</h3><p>如果<code>::</code>限定作用符左侧留空，只<strong>会在全局命名空间查找</strong>；<code>::a</code></p>
<h2 id="名字控制"><a href="#名字控制" class="headerlink" title="名字控制"></a>名字控制</h2><blockquote>
<p>创建名字是程序设计过程中一项最基本的活动，当一个项目很大时，它会不可避免地包含大量名字。c++允许我们对名字的产生和名字的可见性进行控制。</p>
<p>我们之前在学习c语言可以通过static关键字来使得名字只得在本编译单元内可见，在c++中我们将通过一种通过命名空间来控制对名字的访问。</p>
</blockquote>
<h3 id="C-命名空间-namespace"><a href="#C-命名空间-namespace" class="headerlink" title="C++命名空间(namespace)"></a>C++命名空间(namespace)</h3><p>作用:解决命名冲突</p>
<blockquote>
<p>在c++中，名称（name）可以是符号常量、变量、函数、结构、枚举、类和对象等等。工程越大，名称互相冲突性的可能性越大。另外使用多个厂商的类库时，也可能导致名称冲突。为了避免，在大规模程序的设计中，以及在程序员使用各种各样的C++库时，这些标识符的命名发生冲突，标准C++引入关键字namespace（命名空间&#x2F;名字空间&#x2F;名称空间），可以更好地控制标识符的作用域。</p>
</blockquote>
<h3 id="命名空间使用语法"><a href="#命名空间使用语法" class="headerlink" title="命名空间使用语法"></a>命名空间使用语法</h3><ol>
<li>命名空间用途：解决名称冲突</li>
<li>命名空间下可以存放：变量，函数，结构体，类…</li>
<li>命名空间必须要声明在全局作用域</li>
<li>命名空间可以嵌套命名空间</li>
<li>命名空间是开放的，可以随时将新成员添加到命名空间下</li>
<li>命名空间是可以匿名的</li>
</ol>
<h4 id="创建一个命名空间"><a href="#创建一个命名空间" class="headerlink" title="创建一个命名空间:"></a>创建一个命名空间:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> B&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>命名空间只能全局范围内定义（<em><strong>以下错误写法</strong></em>）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">namespace</span> A&#123;</span><br><span class="line">		<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">namespace</span> B&#123;</span><br><span class="line">		<span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>命名空间可嵌套命名空间</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">namespace</span> B&#123;</span><br><span class="line">		<span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>命名空间是开放的，即可以随时把新的成员加入已有的命名空间中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;hello namespace!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声明和实现可分离</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> MySpace&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> param)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MySpace::func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;MySpace::func1&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MySpace::func2</span><span class="params">(<span class="type">int</span> param)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;MySpace::func2 : &quot;</span> &lt;&lt; param &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无名命名空间，意味着命名空间中的标识符只能在本文件内访问，相当于给这个标识符加上了static，使得其可以作为内部连接</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;hello namespace&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a : &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a : &quot;</span> &lt;&lt; ::a &lt;&lt; endl;<span class="comment">//这两个都可以访问</span></span><br><span class="line">	<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>命名空间别名</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> veryLongName&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;hello namespace&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">namespace</span> shortName = veryLongName;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;veryLongName::a : &quot;</span> &lt;&lt; shortName::a &lt;&lt; endl;</span><br><span class="line">	veryLongName::<span class="built_in">func</span>();</span><br><span class="line">	shortName::<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="using声明"><a href="#using声明" class="headerlink" title="using声明"></a>using声明</h3><p>using声明可使得指定的标识符可用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line">	<span class="type">int</span> paramA = <span class="number">20</span>;</span><br><span class="line">	<span class="type">int</span> paramB = <span class="number">30</span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">funcA</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;hello funcA&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">funcB</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;hello funcA&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//1. 通过命名空间域运算符</span></span><br><span class="line">	cout &lt;&lt; A::paramA &lt;&lt; endl;</span><br><span class="line">	A::<span class="built_in">funcA</span>();</span><br><span class="line">	<span class="comment">//2. using声明</span></span><br><span class="line">	<span class="keyword">using</span> A::paramA;</span><br><span class="line">	<span class="keyword">using</span> A::funcA;</span><br><span class="line">	cout &lt;&lt; paramA &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; paramB &lt;&lt; endl; //不可直接访问</span></span><br><span class="line">	<span class="built_in">funcA</span>();</span><br><span class="line">	<span class="comment">//3. 同名冲突</span></span><br><span class="line">	<span class="comment">//int paramA = 20; //相同作用域注意同名冲突</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>using声明碰到函数重载</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span>  <span class="title">func</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> A::func;</span><br><span class="line">	<span class="built_in">func</span>();</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果命名空间包含一组用相同名字重载的函数，using声明就声明了<strong>这个重载函数的所有集合</strong>。</p>
<h3 id="using编译指令"><a href="#using编译指令" class="headerlink" title="using编译指令"></a>using编译指令</h3><p>using编译指令使整个命名空间标识符可用.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line">	<span class="type">int</span> paramA = <span class="number">20</span>;</span><br><span class="line">	<span class="type">int</span> paramB = <span class="number">30</span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">funcA</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;hello funcA&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">funcB</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;hello funcB&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> A;</span><br><span class="line">	cout &lt;&lt; paramA &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; paramB &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">funcA</span>();</span><br><span class="line">	<span class="built_in">funcB</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//不会产生二义性</span></span><br><span class="line">	<span class="type">int</span> paramA = <span class="number">30</span>;</span><br><span class="line">	cout &lt;&lt; paramA &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> B&#123;</span><br><span class="line">	<span class="type">int</span> paramA = <span class="number">20</span>;</span><br><span class="line">	<span class="type">int</span> paramB = <span class="number">30</span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">funcA</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;hello funcA&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">funcB</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;hello funcB&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> A;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> B;</span><br><span class="line">	<span class="comment">//二义性产生，不知道调用A还是B的paramA</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; paramA &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>理解注意点</strong>：</p>
<ol>
<li>using声明和普通声明在一个作用域同时存在，会报错。但using编译指令和普通声明在一个作用域同时存在时，<strong>优先普通声明</strong>，若不存在普通声明，此时才使用使用的命名空间中的声明。</li>
<li>没有普通声明下，两个using编译指令会报错</li>
</ol>
<p><em><strong>注意：使用using声明或using编译指令会增加命名冲突的可能性。也就是说，如果有名称空间，并在代码中使用作用域解析运算符，则不会出现二义性。</strong></em></p>
<p>我们刚讲的一些东西一开始会觉得难一些，这些东西以后还是挺常用，只要理解了它们的工作机理，使用它们非常简单。</p>
<p>需要记住的关键问题是当引入一个全局的using编译指令时，就为该文件打开了该命名空间，它不会影响任何其他的文件，所以可以在每一个实现文件中调整对命名空间的控制。比如，如果发现某一个实现文件中有太多的using指令而产生的命名冲突，就要对该文件做个简单的改变，通过明确的限定或者using声明来消除名字冲突，这样不需要修改其他的实现文件。</p>
<h2 id="C-对C语言的增强以及扩展"><a href="#C-对C语言的增强以及扩展" class="headerlink" title="C++对C语言的增强以及扩展"></a>C++对C语言的增强以及扩展</h2><h3 id="全局变量检测增强"><a href="#全局变量检测增强" class="headerlink" title="全局变量检测增强"></a>全局变量检测增强</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>; <span class="comment">//赋值，当做定义</span></span><br><span class="line"><span class="type">int</span> a; <span class="comment">//没有赋值，当做声明</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a:%d\n&quot;</span>,a);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此代码在c++下编译失败,在c下编译通过.</p>
<h3 id="函数检测增强"><a href="#函数检测增强" class="headerlink" title="函数检测增强"></a>函数检测增强</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//i没有写类型，可以是任意类型</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun1</span><span class="params">(i)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//i没有写类型，可以是任意类型</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun2</span><span class="params">(i)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, i);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//没有写参数，代表可以传任何类型的实参</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun3</span><span class="params">()</span></span>&#123; </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;fun33333333333333333\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C语言，如果函数没有参数，建议写void，代表没有参数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun4</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;fun4444444444444\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">g</span>()&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fun1</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">fun2</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">	<span class="built_in">fun3</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;g = %d\n&quot;</span>, <span class="built_in">g</span>());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上c代码c编译器编译可通过，c++编译器无法编译通过。</p>
<ul>
<li>在C语言中，int fun() 表示返回值为int，接受任意参数的函数，int fun(void) 表示返回值为int的无参函数。(汇编本质并没有区别，编译器也不会报错，都是接受任意参数)</li>
<li>在C++ 中，int fun() 和int fun(void) 具有相同的意义，都表示返回值为int的无参函数。</li>
</ul>
<h3 id="类型转换检测增强"><a href="#类型转换检测增强" class="headerlink" title="类型转换检测增强"></a>类型转换检测增强</h3><p>在C++，不同类型的变量一般是不能直接赋值的，需要相应的强转。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">COLOR</span>&#123; GREEN, RED, YELLOW &#125; color;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	color mycolor = GREEN;</span><br><span class="line">	mycolor = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;mycolor:%d\n&quot;</span>, mycolor);</span><br><span class="line">	<span class="type">char</span>* p = <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上c代码c编译器编译可通过，c++编译器无法编译通过。</p>
<h3 id="struct增强"><a href="#struct增强" class="headerlink" title="struct增强"></a>struct增强</h3><ul>
<li>c中定义结构体变量需要加上struct关键字，c++不需要。</li>
<li>c中的结构体只能定义成员变量，不能定义成员函数。c++即可以定义成员变量，也可以定义成员函数。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 结构体中即可以定义成员变量，也可以定义成员函数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">	string mName;</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span></span>&#123; mName = name; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> age)</span></span>&#123; mAge = age; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showStudent</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; mName &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. c++中定义结构体变量不需要加struct关键字</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Student student;</span><br><span class="line">	student.<span class="built_in">setName</span>(<span class="string">&quot;John&quot;</span>);</span><br><span class="line">	student.<span class="built_in">setAge</span>(<span class="number">20</span>);</span><br><span class="line">	student.<span class="built_in">showStudent</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="bool数据类型扩展"><a href="#bool数据类型扩展" class="headerlink" title="bool数据类型扩展"></a>bool数据类型扩展</h3><p>标准c++的bool类型有两种内建的常量true(转换为整数1)和false(转换为整数0)表示状态。这三个名字都是关键字。</p>
<ul>
<li>bool类型只有两个值，true(1值)，false(0值)</li>
<li>bool类型占1个字节大小</li>
<li>给bool类型赋值时，非0值会自动转换为true(1),0值会自动转换false(0)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="literal">false</span>) &lt;&lt; endl; <span class="comment">//为1，//bool类型占一个字节大小</span></span><br><span class="line">	<span class="type">bool</span> flag = <span class="literal">true</span>; <span class="comment">// c语言中没有这种类型</span></span><br><span class="line">	flag = <span class="number">100</span>; <span class="comment">//给bool类型赋值时，非0值会自动转换为true(1),0值会自动转换false(0)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="三目运算符增强"><a href="#三目运算符增强" class="headerlink" title="三目运算符增强"></a>三目运算符增强</h3><ul>
<li>c语言三目运算表达式返回值为数据值，为右值，不能赋值。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ret:%d\n&quot;</span>, a &gt; b ? a : b);</span><br><span class="line"><span class="comment">//思考一个问题，(a &gt; b ? a : b) 三目运算表达式返回的是什么？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//(a &gt; b ? a : b) = 100;</span></span><br><span class="line"><span class="comment">//返回的是右值</span></span><br></pre></td></tr></table></figure>

<ul>
<li>c++语言三目运算表达式返回值为变量本身(引用)，为左值，可以赋值。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ret:%d\n&quot;</span>, a &gt; b ? a : b);</span><br><span class="line"><span class="comment">//思考一个问题，(a &gt; b ? a : b) 三目运算表达式返回的是什么？</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; (a &gt; b ? a : b) &lt;&lt; endl;<span class="comment">//返回的是20</span></span><br><span class="line"><span class="comment">//返回的是左值，变量的引用</span></span><br><span class="line">(a &gt; b ? a : b) = <span class="number">100</span>;<span class="comment">//返回的是左值，变量的引用</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p> <em><em>C语言中</em>(a &gt; b ? &amp;a :&amp; b)等价于 C++中(a &gt; b ? a : b)</em>*</p>
<h4 id="左值和右值概念"><a href="#左值和右值概念" class="headerlink" title="[左值和右值概念]"></a><em><strong>[左值和右值概念]</strong></em></h4><p>  在c++中可以放在赋值操作符左边的是左值，可以放到赋值操作符右面的是右值。</p>
<p>  有些变量即可以当左值，也可以当右值。</p>
<p>  左值为Lvalue，L代表Location，表示内存可以寻址，可以赋值。</p>
<p>  右值为Rvalue，R代表Read,就是可以知道它的值。</p>
<p>  比如:int temp &#x3D; 10; temp在内存中有地址，10没有，但是可以Read到它的值。</p>
<p><strong>理解：</strong></p>
<p><strong>左值</strong>引用。编译器对他做的操作是“自动提领”，就是自动加个*操作。所以左值引用更像一个常量指针，int <em>const，它和常量指针唯一的区别就在于他不用每次都让我们自己写</em>了，除此以外真的没什么区别。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  int a=1;</span><br><span class="line">010913BE  mov     dword ptr [a],1  </span><br><span class="line">   int b=1;</span><br><span class="line">010913C5  mov     dword ptr [b],1  </span><br><span class="line">   int c=a+b;</span><br><span class="line">010913CC  mov     eax,dword ptr [a]  </span><br><span class="line">010913CF  add     eax,dword ptr [b]  </span><br><span class="line">010913D2  mov     dword ptr [c],eax  </span><br></pre></td></tr></table></figure>

<p>在这里a+b就是一个<strong>右值</strong>，它是活在寄存器里的一个值，他在内存里根本没有存在的位置，你无法对它取地址，这就是个右值。</p>
<h3 id="C-C-中const的区别"><a href="#C-C-中const的区别" class="headerlink" title="C&#x2F;C++中const的区别"></a>C&#x2F;C++中const的区别</h3><h4 id="C中的const"><a href="#C中的const" class="headerlink" title="C中的const"></a>C中的const</h4><p>常量的引进是在c++早期版本中，当时标准C规范正在制定。那时，尽管C委员会决定在C中引入const,但是，他们c中的const理解为”一个不能改变的普通变量”，也就是认为const应该是一个只读变量，既然是变量那么就会给const分配内存，<strong>const修饰全局变量时默认是外部链接属性</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> arrSize = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> arr[arrSize];</span><br></pre></td></tr></table></figure>

<p>看似是一件合理的编码，但是这将得出一个错误。 因为arrSize占用某块内存，所以C编译器不知道它在编译时的值是多少？</p>
<h4 id="C-中的const"><a href="#C-中的const" class="headerlink" title="C++中的const"></a>C++中的const</h4><p><em><strong>在c++中，一个const不一定创建内存空间，而在c中，一个const总是需要一块内存空间。</strong></em></p>
<p>在c++中，是否为const常量分配内存空间<strong>依赖于如何使用</strong>。一般说来，如果一个const仅仅用来把一个名字用一个值代替(就像使用#define一样)，那么该存储局空间就不必创建。</p>
<p><strong>如果存储空间没有分配内存的话，在进行完数据类型检查后，为了代码更加有效，值也许会折叠到代码中。</strong></p>
<p>不过，取一个const地址, 或者把它定义为extern,则会为该const创建内存空间。</p>
<p> 在c++中，出现在所有函数之外的const作用于整个文件(也就是说它在该文件外不可见)，默认为内部连接，c++中其他的标识符一般默认为外部连接。</p>
<h4 id="C-C-中const异同总结"><a href="#C-C-中const异同总结" class="headerlink" title="C&#x2F;C++中const异同总结"></a>C&#x2F;C++中const异同总结</h4><h5 id="链接属性区别"><a href="#链接属性区别" class="headerlink" title="链接属性区别"></a>链接属性区别</h5><ol>
<li>C语言默认外部链接（编译前自动加extern）</li>
<li>C++默认内部链接（想要外部链接需要手动加extern）</li>
</ol>
<p><code>当c语言两个文件中都有const int a的时候，编译器会报重定义的错误。而在c++中，则不会，因为c++中的const默认是内部连接的。如果想让c++中的const具有外部连接，必须显示声明为: extern const int a = 10;</code></p>
<h5 id="修改区别"><a href="#修改区别" class="headerlink" title="修改区别"></a>修改区别</h5><ol>
<li>C语言中const全局部变量直接修改编译失败，间接修改编译通过，但由于存储在只读数据段，运行失败</li>
<li>C语言中const局部变量直接修改编译失败。但可以通过指针间接修改。</li>
<li>C++中const全局变量与c一样</li>
<li>C++中const局部变量直接修改编译失败，若分配了变量内存的话，可以通过指针间接修改，若未分配内存，则指针修改仅仅修改了一个临时内存空间中的值， 对原值不影响。</li>
</ol>
<h5 id="C-中const分配内存的情况"><a href="#C-中const分配内存的情况" class="headerlink" title="C++中const分配内存的情况"></a>C++中const分配内存的情况</h5><ol>
<li><p>对于基础数据类型，也就是const int b &#x3D; 10这种，编译器会把它放到符号表中，不分配内存，当对其取地址时，会分配临时内存。（无法间接修改原值）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> b=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *p=(<span class="type">int</span>*)&amp;b;</span><br><span class="line">*p=<span class="number">20</span>;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;b=&quot;</span>&lt;&lt;b&lt;&lt;endl;<span class="comment">//显示为10，修改后无变化</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用普通变量初始化const变量（可以间接修改原值）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b=a;</span><br><span class="line"><span class="type">int</span> *p=(<span class="type">int</span>*)&amp;b;</span><br><span class="line">*p=<span class="number">20</span>;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;b=&quot;</span>&lt;&lt;b&lt;&lt;endl;<span class="comment">//修改成功</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义数据类型（可以间接修改原值）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Person p;</span><br><span class="line">Person* pp=(Person*)&amp;p;</span><br><span class="line">pp-&gt;name=<span class="string">&quot;test&quot;</span>;<span class="comment">//修改成功</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>当上面未分配const变量内存的情况下，此时该const变量可以作为数组定义括号中的数值</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> c[a];<span class="comment">//编译通过</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b=a;</span><br><span class="line"><span class="type">int</span> c[b];<span class="comment">//编译不通过，错误显示：表达式必须含有常量值</span></span><br></pre></td></tr></table></figure>

<p><strong>在支持c99标准的编译器中，可以使用变量定义数组。</strong>(2019VS都不支持完整的C99)</p>
<h2 id="尽量以const替换-define"><a href="#尽量以const替换-define" class="headerlink" title="尽量以const替换#define"></a>尽量以const替换#define</h2><p>在旧版本C中，如果想建立一个常量，必须使用预处理器</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 1024;</span></span><br></pre></td></tr></table></figure>

<p>我们定义的宏MAX从未被编译器看到过，因为在预处理阶段，所有的MAX已经被替换为了1024，于是MAX并没有将其加入到符号表中。但我们使用这个常量获得一个编译错误信息时，可能会带来一些困惑，因为这个信息可能会提到1024，但是并没有提到MAX.如果MAX被定义在一个不是你写的头文件中，你可能并不知道1024代表什么，也许解决这个问题要花费很长时间。</p>
<p>解决办法就是用一个常量替换上面的宏。</p>
<p>const int max&#x3D; 1024;</p>
<p>const和#define区别总结:</p>
<ol>
<li>const有类型，可进行编译器类型安全检查。#define无类型，不可进行类型检查.</li>
<li>const有作用域，而#define不重视作用域(虽然#undef A  可卸载宏常量A)，默认定义处到文件结尾.如果定义在指定作用域下有效的常量，那么#define就不能用。</li>
</ol>
<p>宏常量不可以有命名空间</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> MySpace &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> num 1024</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; MySpace::NUM &lt;&lt; endl; //错误</span></span><br><span class="line">	<span class="comment">//int num = 100; //命名冲突</span></span><br><span class="line">	cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="引用-reference"><a href="#引用-reference" class="headerlink" title="引用(reference)"></a><em><strong>引用(reference)</strong></em></h2><h3 id="引用基本用法"><a href="#引用基本用法" class="headerlink" title="引用基本用法"></a>引用基本用法</h3><p><em><strong>引用是c++对c的重要扩充。</strong></em>在c&#x2F;c++中指针的作用基本都是一样的，但是c++增加了另外一种给函数传递地址的途径，这就是按引用传递(pass-by-reference)，它也存在于其他一些编程语言中，并不是c++的发明。</p>
<ol>
<li>变量名实质上是一段连续内存空间的别名，是一个标号(门牌号)</li>
<li>程序中通过变量来申请并命名内存空间</li>
<li>通过变量的名字可以使用存储空间</li>
</ol>
<p><strong>对一段连续的内存空间只能取一个别名吗？</strong></p>
<p>c++中新增了引用的概念，引用可以作为一个已定义变量的别名。</p>
<p><strong>基本语法:</strong><br>$$<br>Type&amp;\  ref &#x3D; val;<br>$$<br>注意事项：</p>
<ol>
<li>&amp;在此不是求地址运算，而是起标识作用。</li>
<li>类型标识符是指目标变量的类型</li>
<li>必须在声明引用变量时进行初始化。</li>
<li>引用初始化之后不能改变。</li>
<li>不能有NULL引用。必须确保引用是和一块合法的存储单元关联。</li>
<li><strong>可以建立对数组的引用</strong>。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 建立数组引用方法一</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ArrRef[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line">ArrRef&amp; aRef = arr;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>;i ++)&#123;</span><br><span class="line">	aRef[i] = i<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">	cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">//2. 建立数组引用方法二</span></span><br><span class="line"><span class="built_in">int</span>(&amp;f)[<span class="number">10</span>] = arr;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">	f[i] = i<span class="number">+10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">	cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h3 id="函数中的引用"><a href="#函数中的引用" class="headerlink" title="函数中的引用"></a>函数中的引用</h3><p>最常见看见引用的地方是在函数参数和返回值中。当引用被用作函数参数的时，在函数内对任何引用的修改，将对还函数外的参数产生改变。当然，可以通过传递一个指针来做相同的事情，但引用具有更清晰的语法。</p>
<p>如果从函数中返回一个引用，必须像从函数中返回一个指针一样对待。当函数返回值时，引用关联的内存一定要存在。</p>
<h4 id="引用做参数"><a href="#引用做参数" class="headerlink" title="引用做参数"></a>引用做参数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//值传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ValueSwap</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = m;</span><br><span class="line">	m = n;</span><br><span class="line">	n = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//地址传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PointerSwap</span><span class="params">(<span class="type">int</span>* m,<span class="type">int</span>* n)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = *m;</span><br><span class="line">	*m = *n;</span><br><span class="line">	*n = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//引用传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ReferenceSwap</span><span class="params">(<span class="type">int</span>&amp; m,<span class="type">int</span>&amp; n)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = m;</span><br><span class="line">	m = n;</span><br><span class="line">	n = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="comment">//值传递</span></span><br><span class="line">	<span class="built_in">ValueSwap</span>(a, b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//地址传递</span></span><br><span class="line">	<span class="built_in">PointerSwap</span>(&amp;a, &amp;b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//引用传递</span></span><br><span class="line">	<span class="built_in">ReferenceSwap</span>(a, b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单：	</p>
<ol>
<li>函数调用时传递的实参不必加“&amp;”符 </li>
<li>在被调函数中不必在参数前加“*”符</li>
</ol>
<p>引用作为其它变量的别名而存在，因此在一些场合可以代替指针。C++主张用引用传递取代地址传递的方式，因为引用语法容易且不易出错。</p>
<h4 id="引用做返回值"><a href="#引用做返回值" class="headerlink" title="引用做返回值"></a>引用做返回值</h4><ol>
<li>不能返回局部变量的引用。</li>
<li>函数当左值，必须返回引用。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回局部变量引用</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">TestFun01</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>; <span class="comment">//局部变量</span></span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回静态变量引用</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">TestFunc02</span><span class="params">()</span></span>&#123;	</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;static int a : &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//不能返回局部变量的引用</span></span><br><span class="line">	<span class="type">int</span>&amp; ret01 = <span class="built_in">TestFun01</span>();</span><br><span class="line">	<span class="comment">//如果函数做左值，那么必须返回引用</span></span><br><span class="line">	<span class="built_in">TestFunc02</span>();</span><br><span class="line">	<span class="built_in">TestFunc02</span>() = <span class="number">100</span>;</span><br><span class="line">	<span class="built_in">TestFunc02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="引用的本质"><a href="#引用的本质" class="headerlink" title="引用的本质"></a>引用的本质</h3><p><em><strong>引用的本质在c++内部实现是一个指针常量.</strong></em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type&amp; ref = val; <span class="comment">// Type* const ref = &amp;val;</span></span><br></pre></td></tr></table></figure>

<p>c++编译器在编译过程中使用常指针作为引用的内部实现，因此引用所占用的空间大小与指针相同，只是这个过程是编译器内部实现，用户不可见。</p>
<p>原理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发现是引用，转换为 int* const ref = &amp;a;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testFunc</span><span class="params">(<span class="type">int</span>&amp; ref)</span></span>&#123;</span><br><span class="line">	ref = <span class="number">100</span>; <span class="comment">// ref是引用，转换为*ref = 100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span>&amp; aRef = a; <span class="comment">//自动转换为 int* const aRef = &amp;a;这也能说明引用为什么必须初始化</span></span><br><span class="line">	aRef = <span class="number">20</span>; <span class="comment">//内部发现aRef是引用，自动帮我们转换为: *aRef = 20;</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;aRef:&quot;</span> &lt;&lt; aRef &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">testFunc</span>(a);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="指针引用"><a href="#指针引用" class="headerlink" title="指针引用"></a>指针引用</h3><p>在c语言中如果想改变一个指针的指向而不是它所指向的内容，函数声明可能这样:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void fun(int**);</span><br></pre></td></tr></table></figure>

<p>给指针变量取一个别名。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Type* pointer = <span class="literal">NULL</span>;  </span><br><span class="line">Type*&amp; = pointer;</span><br></pre></td></tr></table></figure>

<p>对于c++中的引用，语法清晰多了。函数参数变成指针的引用，用不着取得指针的地址。</p>
<h3 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h3><p>常量引用的定义格式:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Type&amp; ref = val;</span><br></pre></td></tr></table></figure>

<p>常量引用注意：</p>
<ol>
<li>字面量不能赋给引用，但是可以赋给const引用（编译器自动给创建临时空间）</li>
<li>const修饰的引用，不能修改。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span>&amp; aRef = a; <span class="comment">//此时aRef就是a</span></span><br><span class="line">	<span class="comment">//aRef = 200; 不能修改aRef的值</span></span><br><span class="line">	a = <span class="number">200</span>; <span class="comment">//OK</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;aRef:&quot;</span> &lt;&lt; aRef &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//不能把一个字面量赋给引用</span></span><br><span class="line">	<span class="comment">//int&amp; ref = 100;</span></span><br><span class="line">	<span class="comment">//但是可以把一个字面量赋给常引用（编译器自动给创建临时空间）</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span>&amp; ref = <span class="number">100</span>; <span class="comment">//int temp = 200; const int&amp; ret = temp;</span></span><br><span class="line">    <span class="comment">//常引用可以通过指针间接修改</span></span><br><span class="line">    <span class="type">int</span>* p=(<span class="type">int</span>*)&amp;ref;</span><br><span class="line">    *p=<span class="number">200</span>;<span class="comment">//OK</span></span><br><span class="line">    <span class="comment">//把上面引用的修改流程改成指针参考如下：</span></span><br><span class="line">    <span class="type">int</span> temp=<span class="number">100</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> pp=&amp;temp;</span><br><span class="line">    <span class="type">int</span>* ppp=pp;</span><br><span class="line">    *ppp=<span class="number">200</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>[const引用使用场景]</strong></em></p>
<p> 常量引用主要用在函数的形参，尤其是类的拷贝&#x2F;复制构造函数。</p>
<p>将函数的形参定义为常量引用的好处:</p>
<ul>
<li>引用不产生新的变量，减少形参与实参传递时的开销。</li>
<li>由于引用可能导致实参随形参改变而改变，将其定义为常量引用可以消除这种副作用。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//const int&amp; param防止函数中意外修改数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowVal</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; param)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;param:&quot;</span> &lt;&lt; param &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果希望实参随着形参的改变而改变，那么使用一般的引用，如果不希望实参随着形参改变，那么使用常引用。</strong></p>
<blockquote>
<p>对于非常量引用，必须将其绑定到一个具有持久性的左值，而不是一个临时值。这是因为非常量引用是为了能够修改引用的对象，而临时值是没有持久性的，无法被修改。</p>
<p>原因如下:</p>
<ol>
<li>生命周期问题：临时值是暂时创建的，它们没有持久性，只在表达式求值时存在。一旦表达式结束，临时值就会被销毁。因此，在使用非常量引用时，我们需要确保引用的对象在引用的整个生命周期内是有效的，而不是在临时值消失后引用一个已销毁的对象。</li>
<li>修改限制：非常量引用的目的是允许对引用的对象进行修改。然而，临时值是常量对象，它们的值是不可修改的。因此，将非常量引用绑定到临时值上是没有意义的，因为我们无法通过引用修改临时值。</li>
</ol>
<p>简单理解:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于这样的函数(常引用参数)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; prices)</span></span>;</span><br><span class="line"><span class="type">int</span> res=s.<span class="built_in">maxProfit</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(&#123;<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>&#125;));</span><br><span class="line"><span class="comment">//↑是允许的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//但是对于这样的函数(非常引用参数)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span></span>;</span><br><span class="line"><span class="type">int</span> res=s.<span class="built_in">maxProfit</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(&#123;<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>&#125;));<span class="comment">//不允许</span></span><br><span class="line"><span class="comment">//只能这样:</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; prices = &#123;<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>&#125;;</span><br><span class="line">s.<span class="built_in">maxProfit</span>(prices);</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="内联函数-inline-function"><a href="#内联函数-inline-function" class="headerlink" title="内联函数(inline function)"></a>内联函数(inline function)</h2><h3 id="内联函数的引出"><a href="#内联函数的引出" class="headerlink" title="内联函数的引出"></a>内联函数的引出</h3><p>c++从c中继承的一个重要特征就是效率。假如c++的效率明显低于c的效率，那么就会有很大的一批程序员不去使用c++了。</p>
<p>在c中我们经常把一些短并且执行频繁的计算写成宏，而不是函数，这样做的理由是为了执行效率，宏可以避免函数调用的开销，这些都由预处理来完成。</p>
<p>但是在c++出现之后，使用预处理宏会出现两个问题：</p>
<ul>
<li>第一个在c中也会出现，宏看起来像一个函数调用，但是会有隐藏一些难以发现的错误。</li>
<li>第二个问题是c++特有的，预处理器不允许访问类的成员，也就是说预处理器宏不能用作类类的成员函数。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> COMPARE(x,y) ((x) &lt; (y) ? (x) : (y))</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Compare</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x &lt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">3</span>;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;COMPARE(++a, b):&quot; &lt;&lt; COMPARE(++a, b) &lt;&lt; endl; // 3 因为展开成了((++a) &lt; (b) ? (++a) : (b)),a自加了两次</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Compare(int x,int y):&quot;</span> &lt;&lt; <span class="built_in">Compare</span>(++a, b) &lt;&lt; endl; <span class="comment">//2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了保持预处理宏的效率又增加安全性，而且还能像一般成员函数那样可以在类里访问自如，c++引入了内联函数(inline function).</p>
<p>内联函数为了继承宏函数的效率，没有函数调用时开销，然后又可以像普通函数那样，可以进行参数，返回值类型的安全检查，又可以作为成员函数。</p>
<p><strong>注意</strong>: 编译器将会检查函数参数列表使用是否正确，并返回值(进行必要的转换)。这些事预处理器无法完成的。</p>
<h3 id="内联函数基本概念"><a href="#内联函数基本概念" class="headerlink" title="内联函数基本概念"></a>内联函数基本概念</h3><p>在c++中，预定义宏的概念是用内联函数来实现的，而<em><strong>内联函数本身也是一个真正的函数</strong></em>。内联函数具有普通函数的所有行为。唯一不同之处在于内联函数会在适当的地方像预定义宏一样展开，所以不需要函数调用的开销。因此应该不使用宏，使用内联函数。</p>
<blockquote>
<p>在开启了优化选项后，编译器可能不会为一个内联甚至非内联的函数生成[[C语言入门#栈区（stack）|栈框架(汇编层面的调用栈)]]，编译器可能使用很多优化技术消除这个构造</p>
</blockquote>
<p>在普通函数(非成员函数)函数前面加上inline关键字使之成为内联函数。但是必须注意<strong>必须函数体和声明结合在一起，否则编译器将它作为普通函数来对待。</strong>（<strong>即在函数声明和实现同时加入关键字inline才被称为内联</strong>）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面不是内联</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;&#125;;</span><br><span class="line"><span class="comment">//下面是内联</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;<span class="keyword">return</span> ++;&#125;</span><br><span class="line"><span class="comment">//下面是内联</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>内联函数的确占用空间，但是内联函数相对于普通函数的优势只是省去了函数调用时候的压栈，跳转，返回的开销。我们可以理解为内联函数是以<em><strong>空间换时间</strong></em>。</p>
<p><strong>任何在类内部定义的函数自动成为内联函数。</strong></p>
<h3 id="内联函数和编译器"><a href="#内联函数和编译器" class="headerlink" title="内联函数和编译器"></a>内联函数和编译器</h3><blockquote>
<p>内联函数并不是何时何地都有效，为了理解内联函数何时有效，应该要知道编译器碰到内联函数会怎么处理？</p>
<p>对于任何类型的函数，编译器会将函数类型(包括函数名字，参数类型，返回值类型)放入到符号表中。同样，当编译器看到内联函数，并且对内联函数体进行分析没有发现错误时，也会将内联函数放入符号表。</p>
<p>当调用一个内联函数的时候，编译器首先确保传入参数类型是正确匹配的，或者如果类型不正完全匹配，但是可以将其转换为正确类型，并且返回值在目标表达式里匹配正确类型，或者可以转换为目标类型，内联函数就会直接替换函数调用，这就消除了函数调用的开销。假如内联函数是成员函数，对象this指针也会被放入合适位置。</p>
<p>类型检查和类型转换、包括在合适位置放入对象this指针这些都是预处理器不能完成的。</p>
</blockquote>
<p>但是c++内联编译会有一些限制，以下情况编译器可能考虑不会将函数进行内联编译：</p>
<ul>
<li>不能存在任何形式的循环语句</li>
<li>不能存在过多的条件判断语句</li>
<li>函数体不能过于庞大</li>
<li>不能对函数进行取址操作</li>
</ul>
<p><em><strong>内联仅仅只是给编译器一个建议，编译器不一定会接受这种建议，如果你没有将函数声明为内联函数，那么编译器也可能将此函数做内联编译。一个好的编译器将会内联小的、简单的函数。</strong></em></p>
<h2 id="函数的默认参数"><a href="#函数的默认参数" class="headerlink" title="函数的默认参数"></a>函数的默认参数</h2><p>c++在声明函数原型的时可为一个或者多个参数指定默认(缺省)的参数值，当函数调用的时候如果没有指定这个值，编译器会自动用默认值代替。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestFunc01</span><span class="params">(<span class="type">int</span> a = <span class="number">10</span>, <span class="type">int</span> b = <span class="number">20</span>)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a + b  = &quot;</span> &lt;&lt; a + b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意点:</span></span><br><span class="line"><span class="comment">//1. 形参b设置默认参数值，那么后面位置的形参c也需要设置默认参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestFunc02</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b = <span class="number">10</span>,<span class="type">int</span> c = <span class="number">10</span>)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//2. 如果函数声明和函数定义分开，函数声明设置了默认参数，函数定义不能再设置默认参数</span></span><br><span class="line"><span class="comment">//如下情况编译报错</span></span><br><span class="line"><span class="comment">//void TestFunc04(int a,int b = 10,int c = 10);//声明</span></span><br><span class="line"><span class="comment">//void TestFunc04(int a,int b = 10,int c = 10)&#123;&#125;;//定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestFunc03</span><span class="params">(<span class="type">int</span> a = <span class="number">0</span>,<span class="type">int</span> b = <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestFunc03</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//1.如果没有传参数，那么使用默认参数</span></span><br><span class="line">	<span class="built_in">TestFunc01</span>();</span><br><span class="line">	<span class="comment">//2. 如果传一个参数，那么第二个参数使用默认参数</span></span><br><span class="line">	<span class="built_in">TestFunc01</span>(<span class="number">100</span>);</span><br><span class="line">	<span class="comment">//3. 如果传入两个参数，那么两个参数都使用我们传入的参数</span></span><br><span class="line">	<span class="built_in">TestFunc01</span>(<span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>注意点：</strong></em></p>
<ul>
<li>函数的默认参数从左向右，如果一个参数设置了默认参数，那么这个参数之后的参数都必须设置默认参数。</li>
<li>如果函数声明和函数定义分开写，函数声明和函数定义不能同时设置默认参数（和上面内联知识点正好相反，内联要求声明和定义都要加inline）。</li>
</ul>
<h2 id="函数的占位参数"><a href="#函数的占位参数" class="headerlink" title="函数的占位参数"></a>函数的占位参数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestFunc01</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">	<span class="comment">//函数内部无法使用占位参数</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a + b = &quot;</span> &lt;&lt; a + b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//占位参数也可以设置默认值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestFunc02</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> = <span class="number">20</span>)</span></span>&#123;</span><br><span class="line">	<span class="comment">//函数内部依旧无法使用占位参数</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a + b = &quot;</span> &lt;&lt; a + b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//错误调用，占位参数也是参数，必须传参数</span></span><br><span class="line">	<span class="comment">//TestFunc01(10,20); </span></span><br><span class="line">	<span class="comment">//正确调用</span></span><br><span class="line">	<span class="built_in">TestFunc01</span>(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>);</span><br><span class="line">	<span class="comment">//正确调用</span></span><br><span class="line">	<span class="built_in">TestFunc02</span>(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">	<span class="comment">//正确调用</span></span><br><span class="line">	<span class="built_in">TestFunc02</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>c++在声明函数时，可以设置占位参数。占位参数只有参数类型声明，而没有参数名声明。一般情况下，在函数体内部无法使用占位参数。</p>
<p>**占位符功能作用:**暂时基本没用，什么时候用，在后面我们要讲的操作符重载的后置++要用到这个.</p>
<h2 id="函数重载-overload"><a href="#函数重载-overload" class="headerlink" title="函数重载(overload)"></a><em><strong>函数重载(overload)</strong></em></h2><hr>
<p>$$<br>能使名字方便使用，是任何程序设计语言的一个重要特征！<br>$$</p>
<hr>
<p>同一个函数名在不同场景下可以具有不同的含义。</p>
<blockquote>
<p>在传统c语言中，函数名必须是唯一的，程序中不允许出现同名的函数。在c++中是允许出现同名的函数，这种现象称为函数重载。</p>
<p>函数重载的目的就是为了方便的使用函数名。</p>
<p>函数重载并不复杂，等大家学完就会明白什么时候需要用到他们，以及是如何编译，链接的。</p>
</blockquote>
<h3 id="函数重载基本语法"><a href="#函数重载基本语法" class="headerlink" title="函数重载基本语法"></a>函数重载基本语法</h3><p><em><strong>实现函数重载的条件：</strong></em></p>
<ul>
<li>同一个作用域</li>
<li>参数个数不同</li>
<li>参数类型不同</li>
<li>参数顺序不同</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 函数重载条件</span></span><br><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">MyFunc</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;无参数!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">MyFunc</span><span class="params">(<span class="type">int</span> a)</span></span>&#123; cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">MyFunc</span><span class="params">(string b)</span></span>&#123; cout &lt;&lt; <span class="string">&quot;b: &quot;</span> &lt;&lt; b &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">MyFunc</span><span class="params">(<span class="type">int</span> a, string b)</span></span>&#123; cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MyFunc</span><span class="params">(string b, <span class="type">int</span> a)</span></span>&#123;cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.返回值不作为函数重载依据</span></span><br><span class="line"><span class="keyword">namespace</span> B&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">MyFunc</span><span class="params">(string b, <span class="type">int</span> a)</span></span>&#123;&#125;</span><br><span class="line">	<span class="comment">//int MyFunc(string b, int a)&#123;&#125; //无法重载仅按返回值区分的函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunc</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;myFunc(int a)&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunc</span><span class="params">(<span class="type">int</span>&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;myFunc(int a)&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunc</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;myFunc(int a)&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//myFunc(a);//虽然上面三个函数可以作为重载同时存在，但这里调用会产生二义性，因此会报错。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>注意:</strong></em> 函数重载和默认参数一起使用，需要额外注意二义性问题的产生。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyFunc</span><span class="params">(string b)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b: &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数重载碰上默认参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyFunc</span><span class="params">(string b, <span class="type">int</span> a = <span class="number">10</span>)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">MyFunc</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">//这时，两个函数都能匹配调用，产生二义性，这是尤其要注意的！！！</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>为什么函数返回值不作为重载条件呢？</strong></p>
<p>当编译器能从上下文中确定唯一的函数的时，如int ret &#x3D; func(),这个当然是没有问题的。然而，我们在编写程序过程中可以忽略他的返回值。那么这个时候,一个函数为</p>
<p>void func(int x);另一个为int func(int x); 当我们直接调用func(10),这个时候编译器就不确定调用那个函数。所以在c++中禁止使用返回值作为重载的条件。</p>
</blockquote>
<h3 id="函数重载实现原理"><a href="#函数重载实现原理" class="headerlink" title="函数重载实现原理"></a>函数重载实现原理</h3><blockquote>
<p>编译器为了实现函数重载，也是默认为我们做了一些幕后的工作，编译器用不同的参数类型来修饰不同的函数名，比如void func(); 编译器可能会将函数名修饰成_func，当编译器碰到void func(int x),编译器可能将函数名修饰为_func_int,当编译器碰到void func(int x,char c),编译器可能会将函数名修饰为_func_int_char我这里使用”可能”这个字眼是因为编译器如何修饰重载的函数名称并没有一个统一的标准，所以不同的编译器可能会产生不同的内部名。</p>
</blockquote>
<p> 以下三个函数在linux下生成的编译之后的函数名为:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x,<span class="type">char</span> y)</span></span>&#123;&#125;</span><br><span class="line">_Z4funcv <span class="comment">//v 代表void,无参数</span></span><br><span class="line">_Z4funci <span class="comment">//i 代表参数为int类型</span></span><br><span class="line">_Z4funcic <span class="comment">//i 代表第一个参数为int类型，第二个参数为char类型</span></span><br></pre></td></tr></table></figure>

<h3 id="extern-“C”浅析"><a href="#extern-“C”浅析" class="headerlink" title="extern “C”浅析"></a><em><strong>extern “C”浅析</strong></em></h3><p>在linux下测试</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c函数: <span class="function"><span class="type">void</span> <span class="title">MyFunc</span><span class="params">()</span></span>&#123;&#125; ,被编译成函数: MyFunc</span><br><span class="line">c++函数: <span class="function"><span class="type">void</span> <span class="title">MyFunc</span><span class="params">()</span></span>&#123;&#125;,被编译成函数: _Z6Myfuncv</span><br></pre></td></tr></table></figure>

<p>通过这个测试，由于c++中需要支持函数重载，所以c和c++中对同一个函数经过编译后生成的函数名是不相同的，这就导致了一个问题，如果在c++中调用一个使用c语言编写模块中的某个函数，那么c++是根据c++的名称修饰方式来查找并链接这个函数，那么就会发生链接错误，以上例，c++中调用MyFunc函数，在链接阶段会去找Z6Myfuncv，结果是没有找到的，因为这个MyFunc函数是c语言编写的，生成的符号是MyFunc。</p>
<p>那么如果我想在c++调用c的函数怎么办？</p>
<p>extern “C”的主要作用就是为了实现c++代码能够调用其他c语言代码。加上extern “C”后，这部分代码编译器按c语言的方式进行<em><strong>编译</strong></em>和<em><strong>链接</strong></em>，而不是按c++的方式。</p>
<p>例如如下情况，C++需要调用c语言函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.h--头文件</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">show</span><span class="params">()</span>;<span class="comment">//解决方案2：将这句替换为extern &quot;C&quot; void show();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//test.c--c语言源文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">show</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;你好\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main.cpp--c++源文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.h&quot;</span><span class="comment">//解决方案1：将这句替换为extern &quot;C&quot; void show();</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    show();<span class="comment">//F5报错显示:未解析的外部命令。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="终极解决方案："><a href="#终极解决方案：" class="headerlink" title="终极解决方案："></a>终极解决方案：</h4><p><strong>作用</strong>：能区分C和C++的调用针对性加或不加extern “C”，并且省去每个函数都要加extern “C”的麻烦</p>
<p><em><strong>MyModule.h</strong></em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYMODULE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYMODULE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __cplusplus<span class="comment">//这句的意思是&quot;如果是C++引入的话&quot;（这句的目的是为了让该c文件头文件中的函数在C++也能跑起来）</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><em><strong>MyModule.c</strong></em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;MyModule.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p><em><strong>C和C++中struct区别</strong></em></p>
<ul>
<li>c语言struct只有变量，而c++语言struct 既有变量，也有函数</li>
<li>c语言中struct中的成员变量不能赋初值，C++中的struct中的成员变量可以</li>
</ul>
<h3 id="类的封装"><a href="#类的封装" class="headerlink" title="类的封装"></a>类的封装</h3><blockquote>
<p>把事物的属性和行为表示出来，那么就可以抽象出来这个事物。</p>
</blockquote>
<h4 id="封装"><a href="#封装" class="headerlink" title="封装:"></a>封装:</h4><ol>
<li>把变量（属性）和函数（操作）合成一个整体，封装在一个类中</li>
<li>对变量和函数进行访问控制</li>
</ol>
<h4 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h4><ol>
<li>在类的内部(作用域范围内)，没有访问权限之分，所有成员可以相互访问</li>
<li>在类的外部(作用域范围外)，访问权限才有意义：public，private，protected</li>
<li>在类的外部，只有public修饰的成员才能被访问，在没有涉及继承与派生时，		private和protected是同等级的，外部不允许访问</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps45.jpg" alt="img"></p>
<p> <em><strong>[C++中struct和class的区别?]</strong></em></p>
<p> class默认访问权限为private,struct默认访问权限为public.</p>
<h4 id="尽量将成员变量设置为private"><a href="#尽量将成员变量设置为private" class="headerlink" title="尽量将成员变量设置为private"></a>尽量将成员变量设置为private</h4><ol>
<li>可赋予客户端访问数据的一致性。</li>
</ol>
<p>   如果成员变量不是public，客户端唯一能够访问对象的方法就是通过成员函数。如果类中所有public权限的成员都是函数，客户在访问类成员时只会默认访问函数，不需要考虑访问的成员需不需要添加(),这就省下了许多搔首弄耳的时间。</p>
<ol start="2">
<li>可细微划分访问控制</li>
</ol>
<p>   使用成员函数可使得我们对变量的控制处理更加精细。如果我们让所有的成员变量为public，每个人都可以读写它。如果我们设置为private，我们可以实现“不准访问”、“只读访问”、“读写访问”，甚至你可以写出“只写访问”。</p>
<h3 id="对象的构造和析构"><a href="#对象的构造和析构" class="headerlink" title="对象的构造和析构"></a>对象的构造和析构</h3><p><em><strong>构造函数</strong></em>和<em><strong>析构函数</strong></em>，这两个函数将会被编译器自动调用，完成对象初始化和对象清理工作。</p>
<p><em><strong>无论你是否喜欢，对象的初始化和清理工作是编译器强制我们要做的事情，即使你不提供初始化操作和清理操作，编译器也会给你增加默认的操作，只是这个默认初始化操作不会做任何事，所以编写类就应该顺便提供初始化函数。</strong></em></p>
<h4 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h4><p>构造函数主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。</p>
<p>析构函数主要用于对象<em><strong>销毁前</strong></em>系统自动调用，执行一些清理工作(例如成员变量有存堆区指针，那么堆区空间由析构函数中释放最合适了)。</p>
<p><strong>构造函数语法：</strong></p>
<ul>
<li>构造函数函数名和类名相同，没有返回值，不能有void，但可以有参数,可以重载。</li>
<li>ClassName(){}</li>
</ul>
<p><strong>析构函数语法：</strong></p>
<ul>
<li>析构函数函数名是在类名前面加”~”组成,没有返回值，不能有void,不能有参数，不能重载。</li>
<li><code>~ClassName()&#123;&#125;</code></li>
</ul>
<h5 id="构造函数的分类及调用"><a href="#构造函数的分类及调用" class="headerlink" title="构造函数的分类及调用"></a>构造函数的分类及调用</h5><ul>
<li>按参数类型：<ol>
<li>无参构造函数</li>
<li>有参构造函数</li>
</ol>
</li>
<li>按类型分类：<ol>
<li>普通构造函数</li>
<li>拷贝构造函数(复制构造函数)</li>
</ol>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;no param constructor!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mAge = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//有参构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;1 param constructor!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//拷贝构造函数(复制构造函数) 使用另一个对象初始化本对象</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; person)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;copy constructor!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mAge = person.mAge;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//打印年龄</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">PrintPerson</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Age:&quot;</span> &lt;&lt; mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="无参构造调用方式注意点：（重点）"><a href="#无参构造调用方式注意点：（重点）" class="headerlink" title="无参构造调用方式注意点：（重点）"></a>无参构造调用方式注意点：（<strong>重点</strong>）</h5><ul>
<li>正确方式：<code>Person person1;</code></li>
<li>错误方式：<code>Person person1();</code>&#x2F;&#x2F;会被误认为是函数声明</li>
</ul>
<p>引申出来的情况如下:(当使用父类指针指向子类对象的时候)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//举个例子:ITestOutput是纯虚类(接口),也是TestOutput的父类</span></span><br><span class="line"><span class="comment">//这样是正确的   </span></span><br><span class="line">TestOutput testObj;</span><br><span class="line">ITestOutput* i = &amp;testObj;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这样是错误的</span></span><br><span class="line">ITestOutput* i = &amp;<span class="built_in">TestOutput</span>();</span><br></pre></td></tr></table></figure>

<h5 id="有参构造调用方法"><a href="#有参构造调用方法" class="headerlink" title="有参构造调用方法"></a>有参构造调用方法</h5><ol>
<li><code>Person person01(100);</code></li>
<li><code>Person person02(person01);</code></li>
<li><code>Person person03 = Person(300);</code></li>
<li><code>Person person04 = 100;(不推荐)</code></li>
<li><code>Person person05 = person04;</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 无参构造调用方式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//调用无参构造函数</span></span><br><span class="line">	Person person1; </span><br><span class="line">	person<span class="number">1.</span><span class="built_in">PrintPerson</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//无参构造函数错误调用方式</span></span><br><span class="line">	<span class="comment">//Person person2();！原因是会被编译器看成返回值为Person的名为person2的函数声明。！</span></span><br><span class="line">	<span class="comment">//person2.PrintPerson();</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2. 调用有参构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//第一种 括号法，最常用</span></span><br><span class="line">	<span class="function">Person <span class="title">person01</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">	person<span class="number">01.</span><span class="built_in">PrintPerson</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//调用拷贝构造函数</span></span><br><span class="line">	<span class="function">Person <span class="title">person02</span><span class="params">(person01)</span></span>;</span><br><span class="line">	person<span class="number">02.</span><span class="built_in">PrintPerson</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第二种 匿名对象(显示调用构造函数)</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="number">200</span>); <span class="comment">//匿名对象，没有名字的对象</span></span><br><span class="line"></span><br><span class="line">	Person person03 = <span class="built_in">Person</span>(<span class="number">300</span>);</span><br><span class="line">	person<span class="number">03.</span><span class="built_in">PrintPerson</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//注意: 使用匿名对象初始化判断调用哪一个构造函数，要看匿名对象的参数类型</span></span><br><span class="line">	<span class="function">Person <span class="title">person06</span><span class="params">(Person(<span class="number">400</span>))</span></span>; <span class="comment">//等价于 Person person06 = Person(400);</span></span><br><span class="line">	person<span class="number">06.</span><span class="built_in">PrintPerson</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第三种 =号法 隐式转换</span></span><br><span class="line">	Person person04 = <span class="number">100</span>; <span class="comment">//Person person04 =  Person(100)</span></span><br><span class="line">	person<span class="number">04.</span><span class="built_in">PrintPerson</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//调用拷贝构造</span></span><br><span class="line">	Person person05 = person04; <span class="comment">//Person person05 =  Person(person04)</span></span><br><span class="line">	person<span class="number">05.</span><span class="built_in">PrintPerson</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="注意事项1"><a href="#注意事项1" class="headerlink" title="[注意事项1]"></a><strong>[注意事项1]</strong></h5><p>除了匿名构造外，其他情况析构都是在作用域尾执行。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匿名构造情况</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="number">19</span>);<span class="comment">//构造函数中打印调用构造函数</span></span><br><span class="line">	cout&lt;&lt;分割线&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*以上输出为:</span></span><br><span class="line"><span class="comment">调用构造函数</span></span><br><span class="line"><span class="comment">调用析构函数</span></span><br><span class="line"><span class="comment">分割线</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//原因为:编译器看到Person(19);这种情况的时候，执行完构造后会立即调用析构函数。</span></span><br><span class="line"><span class="comment">//其他情况</span></span><br><span class="line">&#123;</span><br><span class="line">    Person p=<span class="built_in">Person</span>(<span class="number">19</span>);</span><br><span class="line">    cout&lt;&lt;分割线&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*以上输出为:</span></span><br><span class="line"><span class="comment">调用构造函数</span></span><br><span class="line"><span class="comment">分割线</span></span><br><span class="line"><span class="comment">调用析构函数</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="注意事项2"><a href="#注意事项2" class="headerlink" title="[注意事项2]"></a><strong>[注意事项2]</strong></h5><p><em><strong>b为A的实例化对象,A a &#x3D; A(b) 和 A(b)的区别？</strong></em></p>
<p>  当A(b) 有变量来接的时候，那么编译器认为他是一个匿名对象，当没有变量来接的时候，编译器认为你A(b) 等价于 A b.</p>
<p>拷贝构造函数初始化匿名对象汇编层面上实际并没有调用拷贝构造函数，而是调用的无参构造函数。（避免这种用法）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p;<span class="comment">//正常调用无参构造函数的方法</span></span><br><span class="line"><span class="built_in">Person</span>(p);<span class="comment">//上下这两行含义完全相等,若上下同时存在会产生编译错误:p重定义</span></span><br></pre></td></tr></table></figure>

<h5 id="注意事项3"><a href="#注意事项3" class="headerlink" title="[注意事项3]"></a>[注意事项3]</h5><p>不存在参数类实例本身的构造函数，即不存在如下构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Person</span>(Person person)</span><br><span class="line">	&#123;</span><br><span class="line">		m_age = person.m_age;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person构造成功&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>报错显示:”Person” 的复制构造函数不能带有 “Person” 类型的参数</p>
<p>从理解上来看，上面代码段中的参数传参为值传递，而在C++中，类对象的值传递本质上调用的就是拷贝构造函数，则会产生一个无限递归，因此必须要报错。(下面调用时机处是对这个理解的更深理解)</p>
<h4 id="析构函数的调用时机"><a href="#析构函数的调用时机" class="headerlink" title="析构函数的调用时机"></a>析构函数的调用时机</h4><ul>
<li>对象在栈上，生命周期结束的时候系统会自动调用析构函数。</li>
<li>对象在堆上，系统不会自动调用析构函数，必须见到delete。</li>
</ul>
<ol>
<li>对象生命周期结束，被销毁时；</li>
<li>主动调用delete ；</li>
<li>对象i是对象o的成员，o的析构函数被调用时，对象i的析构函数也被调用。</li>
</ol>
<p><strong>如果是new的对象，即使离开了作用域也会一直存在，必须主动delete，否则只有在结束程序时才会执行析构。</strong>(虽然离开了作用域，但用new动态开辟空间的对象是不会析构的，你可以观察任务管理器，看到内存一直在上升。但你在其他地方确无法使用a所开辟的空间，因为a这个指针是保存在栈上的，当离开作用域后就自动析构(或者说自动消失了)，但它所在分配空间是分配在堆上的，只有主动析构或程序结束，才会释放空间，也就是丢失了这块空间的地址，无法操作这块空间了 。)</p>
<p>对不是new的对象的析构函数和return打断点，可以发现是<strong>先返回值后调用析构函数</strong>。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_37185283/article/details/78723981">显示调用析构函数不但不会带来任何好处，还会造成很多奇怪、难以分析的问题</a></p>
<ol>
<li>手动析构 &#x3D;&#x3D; 调用函数</li>
<li>自动析构 &#x3D;&#x3D; 调用函数同时销毁本身，后一个行为由系统完成，用户不能参与</li>
</ol>
<blockquote>
<p>我们构造对象，往往都是在一段语句体中，比如函数，判断，循环，还有就直接被一对“{}”包含的语句体。这个对象在语句体中被创建，在语句体结束的时候被销毁。问题就在于，这样的对象在生命周期中是<strong>存在于栈上的</strong>。也就是说，如何管理，是系统完成而程序员不能控制的。所以，即使我们调用了析构，在对象生命周期结束后，系统仍然会再调用一次析构函数，将其在栈上销毁，实现真正的析构。所以，如果我们在析构函数中有清除堆数据的语句，调用两次意味着第二次会试图清理已经被清理过了的，根本不再存在的数据！这是件会导致运行时错误的问题，并且在编译的时候不会告诉你！</p>
</blockquote>
<h5 id="显示调用析构带来的后果"><a href="#显示调用析构带来的后果" class="headerlink" title="显示调用析构带来的后果"></a>显示调用析构带来的后果</h5><ol>
<li>显式调用的时候，析构函数相当于的一个<strong>普通的成员函数</strong>；</li>
<li>编译器隐式调用析构函数，如分配了堆内存，显式调用析构的话引起重复<strong>释放堆内存的异常</strong>；</li>
<li>把一个对象看作占用了部分栈内存，占用了部分堆内存（如果申请了的话），这样便于理解这个问题，系统隐式调用析构函数的时候，会加入释放栈内存的动作（而堆内存则由用户手工的释放）；<strong>用户显式调用析构函数的时候</strong>，只是<strong>单纯执行析构函数内的语句</strong>，<strong>不会释放栈内存，也不会摧毁对象</strong>。</li>
</ol>
<h4 id="拷贝构造函数的调用时机"><a href="#拷贝构造函数的调用时机" class="headerlink" title="拷贝构造函数的调用时机"></a>拷贝构造函数的调用时机</h4><ul>
<li>对象以值传递的方式传给函数参数</li>
<li>函数局部对象以值传递的方式从函数返回(vs debug模式下调用一次拷贝构造，[[qt]]不调用任何构造)</li>
<li>用一个对象初始化另一个对象</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;no param contructor!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mAge = <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;param constructor!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; person)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;copy constructor!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mAge = person.mAge;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Person</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;destructor!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//1. 旧对象初始化新对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	Person p3 = p; <span class="comment">// 相当于Person p3 = Person(p);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2. 传递的参数是普通对象，函数参数也是普通对象，传递将会调用拷贝构造</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doBussiness</span><span class="params">(Person p)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="built_in">doBussiness</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果:</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20201228113351913.png" alt="image-20201228113351913"  />

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3. 函数返回局部对象</span></span><br><span class="line"><span class="function">Person <span class="title">MyBusiness</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;局部p:&quot;</span> &lt;&lt; (<span class="type">int</span>*)&amp;p &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//vs release、qt下没有调用拷贝构造函数</span></span><br><span class="line">	<span class="comment">//vs debug下调用一次拷贝构造函数</span></span><br><span class="line">	Person p = <span class="built_in">MyBusiness</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;局部p:&quot;</span> &lt;&lt; (<span class="type">int</span>*)&amp;p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>debug下生成：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20201228113453490.png" alt="image-20201228113453490"></p>
<p>release下生成：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20201228113744991.png" alt="image-20201228113744991"></p>
<p><em><strong>[上面结果说明:]</strong></em></p>
<p>  编译器存在一种对返回值的优化技术,<strong>RVO(Return Value Optimization)</strong>.在vs debug模式下并没有进行这种优化，所以函数MyBusiness中创建p对象，调用了一次构造函数，当编译器发现你要返回这个局部的对象时，编译器通过调用拷贝构造生成一个临时Person对象返回，然后调用p的析构函数。</p>
<p>  我们从常理来分析的话，这个匿名对象和这个局部的p对象是相同的两个对象，那么如果能直接返回p对象，就会省去一个拷贝构造和一个析构函数的开销，在程序中一个对象的拷贝也是非常耗时的，如果减少这种拷贝和析构的次数，那么从另一个角度来说，也是编译器对程序执行效率上进行了优化。</p>
<p>  所以在这里，编译器偷偷帮我们做了一层优化：</p>
<p>  当我们这样去调用: <code>Person p = MyBusiness();</code></p>
<p>  编译器偷偷将我们的代码更改为:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="type">void</span> <span class="title">MyBussiness</span><span class="params">(Person&amp; _result)</span></span>&#123;</span><br><span class="line">       _result.X:<span class="built_in">X</span>(); <span class="comment">//调用Person默认构造函数</span></span><br><span class="line">       <span class="comment">//.....对_result进行处理</span></span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   Person p; <span class="comment">//这里只分配空间，不初始化</span></span><br><span class="line">   <span class="built_in">MyBussiness</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>理解上就是编译器编译发布版本的时候直接改成了<strong>类对象的引用传递</strong></p>
<p>【重点理解】</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结论1：函数的返回值是一个匿名对象时，会调用匿名对象的拷贝函数</span></span><br><span class="line"><span class="comment">结论2：有关匿名对象的去和留：</span></span><br><span class="line"><span class="comment">如果用匿名对象 初始化 另一个同类型的对象 匿名对象被接收				   不会调用析构函数</span></span><br><span class="line"><span class="comment">如果用匿名对象 赋值给 另一个同类型的对象（已经初始化：默认或者有参数） 匿名对象被析构</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test06</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Test06</span>() &#123;</span><br><span class="line">		a = b = <span class="number">0</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;默认构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Test06</span>(<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">		<span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参数构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Test06</span>(<span class="type">const</span> Test06&amp; obj) &#123;<span class="comment">//拷贝/复制构造函数：用一个对象初始化另一个对象			</span></span><br><span class="line">		a = obj.a; b = obj.b;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝/复制构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Test06</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Test06&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Test06&amp; obj) &#123;</span><br><span class="line">		a = obj.a; b = obj.b;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;重载=操作符&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">printT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果函数返回值是一个对象，建议用对象直接接收</span></span><br><span class="line"><span class="function">Test06 <span class="title">getTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Test06 <span class="title">c</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;		<span class="comment">//有参构造函数</span></span><br><span class="line">	<span class="keyword">return</span> c;			<span class="comment">//拷贝构造函数</span></span><br><span class="line">						<span class="comment">//析构c	</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">objectShow06</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//匿名对象被接收，t1不调用默认构造函数 ,不调用析构，节约内存，提高速度</span></span><br><span class="line">	Test06 t1 = <span class="built_in">getTest</span>();<span class="comment">//t1如何被构造的呢？？？===》函数返回值的拷贝构造</span></span><br><span class="line"></span><br><span class="line">	Test06 t2;		<span class="comment">//默认构造函数</span></span><br><span class="line">	t2 = <span class="built_in">getTest</span>(); <span class="comment">//匿名对象赋值给新对象，析构匿名对象</span></span><br><span class="line">					<span class="comment">//重载=操作符</span></span><br><span class="line">	t<span class="number">1.</span><span class="built_in">printT</span>();</span><br><span class="line">	t<span class="number">2.</span><span class="built_in">printT</span>();</span><br><span class="line">	<span class="comment">//析构t2</span></span><br><span class="line">	<span class="comment">//析构t1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">objectShow06</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出结果为:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20201230151324082.png" alt="image-20201230151324082"></p>
<h4 id="构造函数自动生成规则"><a href="#构造函数自动生成规则" class="headerlink" title="构造函数自动生成规则"></a>构造函数自动生成规则</h4><ul>
<li>默认情况下，c++编译器至少为我们写的类增加4个函数<ol>
<li>默认构造函数(无参，函数体为空)</li>
<li>默认析构函数(无参，函数体为空)</li>
<li>默认拷贝构造函数，对类中非静态成员属性简单值拷贝</li>
<li>赋值运算符重载，operator&#x3D;()函数。(定义时的&#x3D;运算符调用的是拷贝构造之外，之后的&#x3D;运算符调用的都是operator&#x3D;()函数)</li>
</ol>
</li>
<li>如果用户定义拷贝构造函数，c++不会再提供任何默认构造函数</li>
<li>如果用户定义了普通构造(非拷贝)，c++不在提供默认无参构造，但是会提供默认拷贝构造</li>
</ul>
<h4 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h4><h5 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h5><p>同一类型的对象之间可以赋值，使得两个对象的成员变量的值相同，两个对象仍然是独立的两个对象，这种情况被称为<em><strong>浅拷贝.</strong></em></p>
<p>一般情况下，浅拷贝没有任何副作用，但是当类中有指针，并且指针指向动态分配的内存空间，析构函数做了动态内存释放的处理，会导致内存问题。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps1.jpg" alt="img"></p>
<h5 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h5><p>当类中有指针，并且此指针有动态分配空间，析构函数做了释放处理，往往需要自定义拷贝构造函数，自行给指针动态分配空间，深拷贝。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps2.jpg" alt="img"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">char</span>* name,<span class="type">int</span> age)&#123;</span><br><span class="line">		pName = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(name) + <span class="number">1</span>);</span><br><span class="line">		<span class="built_in">strcpy</span>(pName,name);</span><br><span class="line">		mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//增加拷贝构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; person)&#123;</span><br><span class="line">		pName = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(person.pName) + <span class="number">1</span>);</span><br><span class="line">		<span class="built_in">strcpy</span>(pName, person.pName);</span><br><span class="line">		mAge = person.mAge;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Person</span>()&#123;</span><br><span class="line">		<span class="keyword">if</span> (pName != <span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="built_in">free</span>(pName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span>* pName;</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;Edward&quot;</span>,<span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="comment">//用对象p1初始化对象p2,调用c++提供的默认拷贝构造函数</span></span><br><span class="line">	Person p2 = p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="explicit关键字"><a href="#explicit关键字" class="headerlink" title="explicit关键字"></a>explicit关键字</h4><p>c++提供了<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/390935.htm">关键字</a>explicit(字面意思：更清晰的)，禁止通过<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/5411414.htm">构造函数</a>的隐式转换方式来构造对象。</p>
<ul>
<li>explicit<strong>常</strong>用于修饰构造函数,防止隐式转化调用构造函数产生的误解。</li>
<li><strong>常</strong>针对单参数的构造函数(或者除了第一个参数外其余参数都有默认值的多参构造)而言。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">char</span> ch;</span><br><span class="line">	<span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span>  <span class="title">Test</span><span class="params">(<span class="type">char</span> ch)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;ch = ch;</span><br><span class="line">		num = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//Test test1=&#x27;b&#x27;;//这里报错显示：不存在从char转换到Test的适当构造函数。</span></span><br><span class="line">    <span class="function">Test <span class="title">test1</span><span class="params">(<span class="string">&#x27;b&#x27;</span>)</span></span>;<span class="comment">//没问题</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面例子可看出：explicit就是禁止用隐式方式来构造对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">char</span> ch;</span><br><span class="line">	<span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Test</span>(<span class="type">char</span> ch)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;ch = ch;</span><br><span class="line">		num = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Test</span>(<span class="type">int</span> num)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;num = num;</span><br><span class="line">		ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;...情况&quot;</span> &lt;&lt; endl;</span><br><span class="line">	Test test1=<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">	cout &lt;&lt; test<span class="number">1.</span>ch &lt;&lt;<span class="string">&quot;  &quot;</span>&lt;&lt; test<span class="number">1.</span>num &lt;&lt; endl;</span><br><span class="line">	Test test2=<span class="number">65</span>;</span><br><span class="line">	cout &lt;&lt; test<span class="number">2.</span>ch &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; test<span class="number">2.</span>num &lt;&lt; endl;</span><br><span class="line">	<span class="function">Test <span class="title">test3</span> <span class="params">(<span class="string">&#x27;c&#x27;</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; test<span class="number">3.</span>ch &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; test<span class="number">3.</span>num &lt;&lt; endl;</span><br><span class="line">	<span class="function">Test <span class="title">test4</span> <span class="params">(<span class="number">66</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; test<span class="number">4.</span>ch &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; test<span class="number">4.</span>num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>各种情况的输出效果：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20201228152115809.png" alt="image-20201228152115809"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20201228152153312.png" alt="image-20201228152153312"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20201228152220005.png" alt="image-20201228152220005"></p>
<h4 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h4><p>构造函数和其他函数不同，除了有名字，参数列表，函数体之外还有初始化列表。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">	<span class="comment">//传统方式初始化</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)&#123;</span><br><span class="line">		mA = a;</span><br><span class="line">		mB = b;</span><br><span class="line">		mC = c;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">//初始化列表方式初始化</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c):<span class="built_in">mA</span>(a),<span class="built_in">mB</span>(b),<span class="built_in">mC</span>(c)&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> mA;</span><br><span class="line">	<span class="type">int</span> mB;</span><br><span class="line">	<span class="type">int</span> mC;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><em><strong>注意：</strong></em>初始化成员列表(参数列表)只能在构造函数使用。</p>
<h3 id="类对象作为成员"><a href="#类对象作为成员" class="headerlink" title="类对象作为成员"></a>类对象作为成员</h3><p>在类中定义的数据成员一般都是基本的数据类型。但是类中的成员也可以是对象，叫做<em><strong>对象成员</strong></em>。</p>
<blockquote>
<p>C++中对对象的初始化是非常重要的操作，当创建一个对象的时候，c++编译器必须确保调用了所有子对象的构造函数。如果所有的子对象有默认构造函数，编译器可以自动调用他们。但是如果子对象没有默认的构造函数，或者想指定调用某个构造函数怎么办？</p>
<p><strong>那么是否可以在类的构造函数直接调用子类的属性完成初始化呢？但是如果子类的成员属性是私有的，我们是没有办法访问并完成初始化的。</strong></p>
<p><strong>解决办法非常简单：对于子类调用构造函数，c++为此提供了专门的语法，即构造函数初始化列表。</strong></p>
<p>当调用构造函数时，首先按各对象成员在类<strong>定义中的顺序（和参数列表的顺序无关）</strong>依次调用它们的构造函数，对这些对象初始化，最后再调用本身的函数体。也就是说，<strong>先调用对象成员的构造函数，再调用本身的构造函数。</strong></p>
<p>析构函数和构造函数调用顺序相反，先构造，后析构。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//汽车类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Car</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Car 默认构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mName = <span class="string">&quot;大众汽车&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Car</span>(string name)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Car 带参数构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mName = name;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Car</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Car 析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string mName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拖拉机</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tractor</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Tractor</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Tractor 默认构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mName = <span class="string">&quot;爬土坡专用拖拉机&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Tractor</span>(string name)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Tractor 带参数构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mName = name;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Tractor</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Tractor 析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string mName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//人类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">	<span class="comment">//类mCar不存在合适的构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(string name)&#123;</span><br><span class="line">		mName = name;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="comment">//初始化列表可以指定调用构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(string carName, string tracName, string name) : <span class="built_in">mTractor</span>(tracName), <span class="built_in">mCar</span>(carName), <span class="built_in">mName</span>(name)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person 构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">GoWorkByCar</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; mName &lt;&lt; <span class="string">&quot;开着&quot;</span> &lt;&lt; mCar.mName &lt;&lt; <span class="string">&quot;去上班!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">GoWorkByTractor</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; mName &lt;&lt; <span class="string">&quot;开着&quot;</span> &lt;&lt; mTractor.mName &lt;&lt; <span class="string">&quot;去上班!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Person</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person 析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string mName;</span><br><span class="line">	Car mCar;</span><br><span class="line">	Tractor mTractor;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//Person person(&quot;宝马&quot;, &quot;东风拖拉机&quot;, &quot;赵四&quot;);</span></span><br><span class="line">	<span class="function">Person <span class="title">person</span><span class="params">(<span class="string">&quot;刘能&quot;</span>)</span></span>;</span><br><span class="line">	person.<span class="built_in">GoWorkByCar</span>();</span><br><span class="line">	person.<span class="built_in">GoWorkByTractor</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20201228143347961.png" alt="image-20201228143347961"></p>
<h3 id="动态对象创建"><a href="#动态对象创建" class="headerlink" title="动态对象创建"></a>动态对象创建</h3><p>当创建一个c++对象时会发生两件事:</p>
<ol>
<li>为对象分配内存</li>
<li>调用构造函数来初始化那块内存</li>
</ol>
<p>第一步我们能保证实现，需要我们确保第二步一定能发生。c++强迫我们这么做是因为使用未初始化的对象是程序出错的一个重要原因。</p>
<h4 id="C动态分配内存方法"><a href="#C动态分配内存方法" class="headerlink" title="C动态分配内存方法"></a>C动态分配内存方法</h4><p>为了在运行时动态分配内存，c在他的标准库中提供了一些函数,malloc以及它的变种calloc和realloc,释放内存的free,这些函数是有效的、但是原始的，需要程序员理解和小心使用。为了使用c的动态内存分配函数在堆上创建一个类的实例，我们必须这样做:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>()&#123;</span><br><span class="line">		mAge = <span class="number">20</span>;</span><br><span class="line">		pName = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(<span class="string">&quot;john&quot;</span>)<span class="number">+1</span>);</span><br><span class="line">		<span class="built_in">strcpy</span>(pName, <span class="string">&quot;john&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">		mAge = <span class="number">20</span>;</span><br><span class="line">		pName = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(<span class="string">&quot;john&quot;</span>)<span class="number">+1</span>);</span><br><span class="line">		<span class="built_in">strcpy</span>(pName, <span class="string">&quot;john&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Clean</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (pName != <span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="built_in">free</span>(pName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">	<span class="type">char</span>* pName;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//分配内存</span></span><br><span class="line">	Person* person = (Person*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Person));</span><br><span class="line">	<span class="keyword">if</span>(person == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//调用初始化函数</span></span><br><span class="line">	person-&gt;<span class="built_in">Init</span>();</span><br><span class="line">	<span class="comment">//清理对象</span></span><br><span class="line">	person-&gt;<span class="built_in">Clean</span>();</span><br><span class="line">	<span class="comment">//释放person对象</span></span><br><span class="line">	<span class="built_in">free</span>(person);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>问题在于：</strong></em></p>
<ol>
<li>程序员必须确定对象的长度。</li>
<li>malloc返回一个void<em>指针，c++不允许将void</em>赋值给其他任何指针，必须强转。</li>
<li>malloc可能申请内存失败，所以必须判断返回值来确保内存分配成功。</li>
<li>用户在使用对象之前必须记住对他初始化，构造函数不能显示调用初始化(构造函数是由编译器调用)，用户有可能忘记调用初始化函数。</li>
</ol>
<p>c的动态内存分配函数太复杂，容易令人混淆，是不可接受的，c++中我们推荐使用运算符new 和 delete.</p>
<h5 id="new-operator"><a href="#new-operator" class="headerlink" title="new operator"></a><strong>new operator</strong></h5><p>C++中解决动态内存分配的方案是<strong>把创建一个对象所需要的操作都结合在一个称为new的运算符里</strong>。当用new创建一个对象时，它就在堆里<strong>为对象分配内存并调用构造函数完成初始化</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Person* person = <span class="keyword">new</span> Person;</span><br><span class="line"><span class="comment">//相当于:</span></span><br><span class="line">Person* person = (Person*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Person));</span><br><span class="line">	<span class="keyword">if</span>(person == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">person-&gt;<span class="built_in">Init</span>(); <span class="comment">//构造函数</span></span><br></pre></td></tr></table></figure>

<p>New操作符能确定在调用构造函数初始化之前内存分配是成功的，所有不用显式确定调用是否成功。</p>
<p>现在我们发现在堆里创建对象的过程变得简单了，只需要一个简单的表达式，它带有<strong>内置的长度计算、类型转换和安全检查</strong>。这样在堆创建一个对象和在栈里创建对象一样简单。</p>
<h6 id="malloc和new的区别"><a href="#malloc和new的区别" class="headerlink" title="malloc和new的区别"></a>malloc和new的区别</h6><ol>
<li>malloc和free属于库函数，new和delete属于运算符</li>
<li>malloc不会调用构造函数，new会调用构造函数</li>
<li>malloc返回void* C++下要强转，new返回创建的对象的指针</li>
</ol>
<h5 id="placement-new机制"><a href="#placement-new机制" class="headerlink" title="placement new机制"></a>placement new机制</h5><blockquote>
<p>一般来说，使用new申请空间时，是从系统的“堆”（heap）中分配空间。申请所得的空间的位置是根据当时的内存的实际使用情况决定的。但是，在某些特殊情况下，可能需要在已分配的特定内存创建对象，这就是所谓的“定位放置new”（placement new）操作。</p>
<p>定位放置new操作的语法形式不同于普通的new操作。例如，一般都用如下语句<code>A* p=new A</code>;申请空间，而定位放置new操作则使用如下语句<code>A* p=new (ptr)A</code>;申请空间，其中ptr就是程序员指定的内存首地址。</p>
</blockquote>
<ul>
<li>用定位放置new操作，既可以在栈(stack)上生成对象，也可以在堆（heap）上生成对象。取决于ptr地址是指向哪里</li>
<li>使用语句A* p&#x3D;new (mem) A;定位生成对象时，指针p和数组名mem指向同一片存储区。所以，与其说定位放置new操作是申请空间，还不如说是利用已经请好的空间，真正的申请空间的工作是在此之前完成的。</li>
<li>使用语句A *p&#x3D;new (mem) A;定位生成对象时，会自动调用类A的构造函数，但是由于对象的空间不会自动释放（对象实际上是借用别人的空间），所以必须显示的调用类的析构函数，如本例中的<code>p-&gt;~A()</code>。</li>
</ul>
<blockquote>
<p>如果有这样一个场景，我们需要大量的申请一块类似的内存空间，然后又释放掉，比如在在一个server中对于客户端的请求，每个客户端的每一次上行数据我们都需要为此申请一块内存，当我们处理完请求给客户端下行回复时释放掉该内存，表面上看者符合c++的内存管理要求，没有什么错误，但是仔细想想很不合理，为什么我们每个请求都要重新申请一块内存呢，要知道每一次内从的申请，系统都要在内存中找到一块合适大小的连续的内存空间，这个过程是很慢的（相对而言)，极端情况下，如果当前系统中有大量的内存碎片，并且我们申请的空间很大，甚至有可能失败。为什么我们不能共用一块我们事先准备好的内存呢？可以的，我们可以使用placement new来构造对象，那么就会在我们指定的内存空间中构造对象。</p>
<p>这种方式存在的根本原因是因为<strong>内存申请是个耗时操作</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;A&#x27;s constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	~<span class="built_in">A</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;A&#x27;s destructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;num:&quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> mem[<span class="number">100</span>];</span><br><span class="line">	mem[<span class="number">0</span>] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">	mem[<span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	mem[<span class="number">2</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	mem[<span class="number">3</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	cout &lt;&lt; (<span class="type">void</span>*)mem &lt;&lt; endl;</span><br><span class="line">	A* p = <span class="built_in">new</span> (mem)A;<span class="comment">//将A对象分配到了栈上</span></span><br><span class="line">	cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">	p-&gt;<span class="built_in">show</span>();</span><br><span class="line">	p-&gt;~<span class="built_in">A</span>();</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="delete-operator"><a href="#delete-operator" class="headerlink" title="delete operator"></a><strong>delete operator</strong></h5><p>new表达式的反面是delete表达式。<strong>delete表达式先调用析构函数，然后释放内存。</strong>正如new表达式返回一个指向对象的指针一样，delete需要一个对象的地址。</p>
<p>delete只适用于由new创建的对象。</p>
<p><strong>如果使用一个由malloc或者calloc或者realloc创建的对象使用delete,这个行为是未定义的。</strong>因为大多数new和delete的实现机制都使用了malloc和free,所以很可能没有调用析构函数就释放了内存。</p>
<p>如果正在删除的对象的指针是NULL,将不发生任何事，因此建议在删除指针后，立即把指针赋值为NULL，以免对它删除两次，对一些对象删除两次可能会产生某些问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		pName = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(<span class="string">&quot;undefined&quot;</span>) + <span class="number">1</span>);</span><br><span class="line">		<span class="built_in">strcpy</span>(pName, <span class="string">&quot;undefined&quot;</span>);</span><br><span class="line">		mAge = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">char</span>* name, <span class="type">int</span> age)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		pName = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(name) + <span class="number">1</span>);</span><br><span class="line">		<span class="built_in">strcpy</span>(pName, name);</span><br><span class="line">		mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; pName &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Person</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (pName != <span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="keyword">delete</span> pName;</span><br><span class="line">			pName = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">char</span>* pName;</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Person* person1 = <span class="keyword">new</span> Person;</span><br><span class="line">	Person* person2 = <span class="keyword">new</span> <span class="built_in">Person</span>(<span class="string">&quot;John&quot;</span>,<span class="number">33</span>);</span><br><span class="line"></span><br><span class="line">	person1-&gt;<span class="built_in">ShowPerson</span>();</span><br><span class="line">	person2-&gt;<span class="built_in">ShowPerson</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span> person1;</span><br><span class="line">    person1=<span class="literal">NULL</span>;<span class="comment">//delete不会置空指针</span></span><br><span class="line">	<span class="keyword">delete</span> person2;</span><br><span class="line">     person2=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="用于数组的new和delete"><a href="#用于数组的new和delete" class="headerlink" title="用于数组的new和delete"></a>用于数组的new和delete</h5><p>使用new和delete在堆上创建数组非常容易。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建字符数组</span></span><br><span class="line"><span class="type">char</span>* pStr = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">100</span>];</span><br><span class="line"><span class="comment">//创建整型数组</span></span><br><span class="line"><span class="type">int</span>* pArr1 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">100</span>]; </span><br><span class="line"><span class="comment">//创建整型数组并初始化</span></span><br><span class="line"><span class="type">int</span>* pArr2 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放数组内存</span></span><br><span class="line"><span class="keyword">delete</span>[] pStr;</span><br><span class="line"><span class="keyword">delete</span>[] pArr1;</span><br><span class="line"><span class="keyword">delete</span>[] pArr2;</span><br></pre></td></tr></table></figure>

<p>当创建一个对象数组的时候，必须对数组中的每一个对象调用构造函数，<strong>一般来说</strong>除了在栈上可以聚合初始化，必须提供一个默认的构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>()&#123;</span><br><span class="line">		pName = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(<span class="string">&quot;undefined&quot;</span>) + <span class="number">1</span>);</span><br><span class="line">		<span class="built_in">strcpy</span>(pName, <span class="string">&quot;undefined&quot;</span>);</span><br><span class="line">		mAge = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">char</span>* name, <span class="type">int</span> age)&#123;</span><br><span class="line">		pName = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(name));</span><br><span class="line">		<span class="built_in">strcpy</span>(pName, name);</span><br><span class="line">		mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Person</span>()&#123;</span><br><span class="line">		<span class="keyword">if</span> (pName != <span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="keyword">delete</span> pName;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">char</span>* pName;</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//栈聚合初始化</span></span><br><span class="line">	Person person[] = &#123; <span class="built_in">Person</span>(<span class="string">&quot;john&quot;</span>, <span class="number">20</span>), <span class="built_in">Person</span>(<span class="string">&quot;Smith&quot;</span>, <span class="number">22</span>) &#125;;</span><br><span class="line">	cout &lt;&lt; person[<span class="number">1</span>].pName &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//创建堆上对象调用有参构造函数</span></span><br><span class="line">    Test* test1 = <span class="keyword">new</span> <span class="built_in">Test</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="comment">//创建堆上对象调用无参构造函数</span></span><br><span class="line">    Test* test1 = <span class="keyword">new</span> <span class="built_in">Test</span>();</span><br><span class="line">    <span class="comment">//创建堆上对象数组必须提供默认构造函数</span></span><br><span class="line">	Person* workers = <span class="keyword">new</span> Person[<span class="number">20</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下代码可以不强制在堆中生成数组对象时候类必须有默认构造函数（即不能是自己实现了有参数构造函数却没实现无参构造函数的情况）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person* workers = <span class="keyword">new</span> Person[<span class="number">2</span>]&#123;<span class="built_in">Person</span>(<span class="string">&quot;john&quot;</span>, <span class="number">20</span>), <span class="built_in">Person</span>(<span class="string">&quot;Smith&quot;</span>, <span class="number">22</span>)&#125;;</span><br></pre></td></tr></table></figure>

<p>但是以上代码在部分编译器不支持（VS2015支持）。所以为了兼容性，最好提供一个默认构造函数，并且不使用上面语法。</p>
<h5 id="注意"><a href="#注意" class="headerlink" title="[注意]"></a><strong>[注意]</strong></h5><p>delete void*可能会出错</p>
<p>如果对一个void<em>指针执行delete操作，*<em>这将可能成为一个程序错误，除非指针指向的内容是非常简单的，因为它将不执行析构函数</em></em>.以下代码未调用析构函数，导致可用内存减少。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">char</span>* name, <span class="type">int</span> age)&#123;</span><br><span class="line">		pName = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(name));</span><br><span class="line">		<span class="built_in">strcpy</span>(pName,name);</span><br><span class="line">		mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Person</span>()&#123;</span><br><span class="line">		<span class="keyword">if</span> (pName != <span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="keyword">delete</span> pName;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">char</span>* pName;</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">void</span>* person = <span class="keyword">new</span> <span class="built_in">Person</span>(<span class="string">&quot;john&quot;</span>,<span class="number">20</span>);<span class="comment">//这里写void*将导致下面的delete不执行析构函数</span></span><br><span class="line">	<span class="keyword">delete</span> person;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，<strong>不要用void*去接受new出来的对象，利用void*无法调用析构函数</strong>。</p>
<h5 id="使用new和delete采用相同形式"><a href="#使用new和delete采用相同形式" class="headerlink" title="使用new和delete采用相同形式"></a>使用new和delete采用相同形式</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person* person = <span class="keyword">new</span> Person[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">delete</span> person;</span><br></pre></td></tr></table></figure>

<p>以上代码有什么问题吗？(vs下直接中断、qt下析构函数调用一次)</p>
<p>使用了new也搭配使用了delete，问题在于Person有10个对象，那么其他9个对象可能没有调用析构函数，也就是说其他9个对象可能删除不完全，因为它们的析构函数没有被调用。</p>
<p>我们现在清楚使用new的时候发生了两件事: 一、分配内存；二、调用构造函数，那么调用delete的时候也有两件事：一、析构函数；二、释放内存。</p>
<p>那么刚才我们那段代码最大的问题在于：person指针指向的内存中到底有多少个对象，因为这个决定应该有多少个析构函数应该被调用。换句话说，person指针指向的是一个单一的对象还是一个数组对象，由于单一对象和数组对象的内存布局是不同的。更明确的说，数组所用的内存通常还包括“数组大小记录”，使得delete的时候知道应该调用几次析构函数。单一对象的话就没有这个记录。单一对象和数组对象的内存布局可理解为下图:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps3.jpg" alt="img"></p>
<p>本图只是为了说明，编译器不一定如此实现，但是很多编译器是这样做的。</p>
<p>当我们使用一个delete的时候，我们必须让delete知道指针指向的内存空间中是否存在一个“数组大小记录”的办法就是我们告诉它。当我们使用delete[]，那么delete就知道是一个对象数组，从而清楚应该调用几次析构函数。</p>
<p><em><strong>结论:</strong></em></p>
<p>  <strong>如果在new表达式中使用[]，必须在相应的delete表达式中也使用[].如果在new表达式中不使用[], 一定不要在相应的delete表达式中使用[].</strong></p>
<h3 id="嵌套类和局部类"><a href="#嵌套类和局部类" class="headerlink" title="嵌套类和局部类"></a>嵌套类和局部类</h3><ol>
<li><p>嵌套类（在一个类中定义另一个类）：</p>
<p>在C++语言中，<strong>嵌套类</strong>（nested class）其实与外围类没有什么太强的依赖关系 ，往往是因为外围类需要使用嵌套类对象作为底层实现，并且该嵌套类只用于外围类的实现，且同时可以对用户隐藏该底层实现时才使用嵌套类。（即作用总结：<strong>访问控制，限定嵌套类只能由这个类访问。</strong>）</p>
</li>
<li><p>局部类：在一个函数中定义另一个类</p>
</li>
</ol>
<h2 id="静态成员（static）"><a href="#静态成员（static）" class="headerlink" title="静态成员（static）"></a>静态成员（static）</h2><blockquote>
<p><strong>对static静态的理解</strong></p>
<p>术语“static”有一段不同寻常的历史。起初，C引入关键字static是为了表示退出一个块后依然存在的局部变量。在这种情况下，术语”static”是有意义的：变量一直存在，当再次进入该块时仍然存在。随后，static在C中有了第二种含义，表示不能被其他文件访问的全局变量和函数。为了避免引入一个新的关键字，关键字static被重用了。最后，C++第三次重用了这个关键字，与前面赋予的含义完全不一样，这里将其解释为：属于类且不属于类对象的变量和函数。这个含义和Java相同。</p>
</blockquote>
<h3 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h3><p>在一个类中，若将一个成员变量声明为static，这种成员称为静态成员变量。与一般的数据成员不同，无论建立了多少个对象，都只有一个静态数据的拷贝。静态成员变量，属于某个类，<strong>所有对象共享</strong>。 </p>
<p>静态变量，是在编译阶段就分配空间，<strong>对象还没有创建时，就已经分配空间。</strong></p>
<ul>
<li><strong>静态非常量成员变量必须在类中声明，在类外定义。</strong>(静态常量成员可以在类内一次性完成声明和定义)</li>
<li><em><strong>静态数据成员不属于某个对象，编译阶段就分配内存，在为对象分配空间中不包括静态成员所占空间。</strong></em></li>
<li><em><strong>静态数据成员可以通过类名或者对象名来引用（两种访问方式）。</strong></em></li>
<li><em><strong>也有访问权限</strong></em></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//类的静态成员属性</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> sNum;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> sOther;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类外初始化，初始化时不加static</span></span><br><span class="line"><span class="type">int</span> Person::sNum = <span class="number">0</span>;<span class="comment">//这种类外定义方式看起来是在类外，但其实还是算类内，即这种可无视private权限</span></span><br><span class="line"><span class="type">int</span> Person::sOther = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1. 通过类名直接访问</span></span><br><span class="line">	Person::sNum = <span class="number">100</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Person::sNum:&quot;</span> &lt;&lt; Person::sNum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2. 通过对象访问</span></span><br><span class="line">	Person p1, p2;</span><br><span class="line">	p<span class="number">1.</span>sNum = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1.sNum:&quot;</span> &lt;&lt; p<span class="number">1.</span>sNum &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2.sNum:&quot;</span> &lt;&lt; p<span class="number">2.</span>sNum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//3. 静态成员也有访问权限，类外不能访问私有成员</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;Person::sOther:&quot; &lt;&lt; Person::sOther &lt;&lt; endl;</span></span><br><span class="line">	Person p3;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;p3.sOther:&quot; &lt;&lt; p3.sOther &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【注意】</strong>由于静态空间的申请和初始化都在main之前，因此可以利用静态成员的类外定义来在main之前执行一些代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>  <span class="title">testfunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//main前执行的代码</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;我在main外哦！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> test::a = <span class="built_in">testfunc</span>();</span><br></pre></td></tr></table></figure>

<h3 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h3><p>在类定义中，前面有static说明的成员函数称为静态成员函数。静态成员函数使用方式和静态变量一样，同样在对象没有创建前，即可通过类名调用。静态成员函数主要为了访问静态变量，但是，不能访问普通成员变量。</p>
<p><strong>静态成员函数的意义：不在于信息共享，数据沟通，而在于管理静态数据成员，完成对静态数据成员的封装。</strong></p>
<ul>
<li><strong>静态成员函数只能访问静态变量，不能访问普通成员变量</strong></li>
<li>静态成员函数的使用和静态成员变量一样可以通过类或者对象访问</li>
<li>静态成员函数也有访问权限</li>
<li>普通成员函数可访问静态成员变量、也可以访问非静态成员变量</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//普通成员函数可以访问static和non-static成员属性</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">changeParam1</span><span class="params">(<span class="type">int</span> param)</span></span>&#123;</span><br><span class="line">		mParam = param;</span><br><span class="line">		sNum = param;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//静态成员函数只能访问static成员属性</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">changeParam2</span><span class="params">(<span class="type">int</span> param)</span></span>&#123;</span><br><span class="line">		<span class="comment">//mParam = param; //无法访问</span></span><br><span class="line">		sNum = param;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">changeParam3</span><span class="params">(<span class="type">int</span> param)</span></span>&#123;</span><br><span class="line">		<span class="comment">//mParam = param; //无法访问</span></span><br><span class="line">		sNum = param;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> mParam;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> sNum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态成员属性类外初始化</span></span><br><span class="line"><span class="type">int</span> Person::sNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1. 类名直接调用</span></span><br><span class="line">	Person::<span class="built_in">changeParam2</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2. 通过对象调用</span></span><br><span class="line">	Person p;</span><br><span class="line">	p.<span class="built_in">changeParam2</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//3. 静态成员函数也有访问权限</span></span><br><span class="line">	<span class="comment">//Person::changeParam3(100); //类外无法访问私有静态成员函数</span></span><br><span class="line">	<span class="comment">//Person p1;</span></span><br><span class="line">	<span class="comment">//p1.changeParam3(200);</span></span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【注意】</strong></p>
<p>静态成员函数不属于任何一个类对象，<strong>没有this指针</strong>，而非静态成员必须随类对象的产生而产生，所以静态成员函数”看不见”非静态成员，自然也就不能访问了<br>但是<strong>如果静态成员函数通过引用一个对象，是可以直接访问私有成员的，也体现了它成员函数的特权。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Point</span>(<span class="type">int</span> a) &#123;                      <span class="comment">//构造函数</span></span><br><span class="line">		x = a;</span><br><span class="line">		y += x; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">f1</span><span class="params">(Point m)</span></span>;           <span class="comment">//静态成员函数的原型声明</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> y;                      <span class="comment">//静态数据成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Point::f1</span><span class="params">(Point m)</span> </span>&#123;              <span class="comment">//静态成员函数的类外定义      参数表中创建对象</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;x=&quot;</span> &lt;&lt; m.x &lt;&lt; endl;       <span class="comment">//静态成员函数通过对象访问非静态数据成员</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;y=&quot;</span> &lt;&lt; y &lt;&lt; endl;         <span class="comment">//静态成员函数处理静态数据成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Point::y = <span class="number">0</span>;                      <span class="comment">//静态数据成员初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Point <span class="title">P1</span><span class="params">(<span class="number">5</span>)</span>, <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	Point::<span class="built_in">f1</span>(P1);                     <span class="comment">//静态成员函数调用时一般使用 类名::</span></span><br><span class="line">	Point::<span class="built_in">f1</span>(p2);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="const静态成员属性"><a href="#const静态成员属性" class="headerlink" title="const静态成员属性"></a>const静态成员属性</h3><p>如果一个类的成员，既要实现共享，又要实现不可改变，那就用 static const 修饰。<em><strong>定义静态const数据成员时，最好在类内部初始化</strong></em>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//static const int mShare = 10;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">static</span> <span class="type">int</span> mShare = <span class="number">10</span>; <span class="comment">//只读区，不可修改</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; Person::mShare &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//Person::mShare = 20;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="静态成员实现单例模式"><a href="#静态成员实现单例模式" class="headerlink" title="静态成员实现单例模式"></a>静态成员实现单例模式</h3><p>单例模式是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。<strong>通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问</strong>，从而方便对实例个数的控制并节约系统资源。如果希望在系统中某个类的对象只能存在一个，单例模式是最好的解决方案。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps1.png" alt="img"></p>
<p>Singleton（单例）：在单例类的内部实现只生成一个实例，同时它提供一个静态的getInstance()工厂方法，让客户可以访问它的唯一实例；为了防止在外部对其实例化，将其默认构造函数和拷贝构造函数设计为私有；在单例类内部定义了一个Singleton类型的静态对象，作为外部共享的唯一实例。</p>
<p>关键点：</p>
<ol>
<li>私有化默认构造函数，拷贝构造函数，唯一实例指针</li>
<li>对外提供getInstance接口，将指针返回</li>
</ol>
<p>用单例模式，模拟公司员工使用打印机场景，打印机可以打印员工要输出的内容，并且可以累积打印机使用次数，案例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> Printer* <span class="title">getInstance</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> pPrinter;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">PrintText</span><span class="params">(string text)</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;打印内容:&quot;</span> &lt;&lt; text &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;已打印次数:&quot;</span> &lt;&lt; mTimes &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;--------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mTimes++;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">Printer</span>()&#123; mTimes = <span class="number">0</span>; &#125;</span><br><span class="line">	<span class="built_in">Printer</span>(<span class="type">const</span> Printer&amp;)&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">static</span> Printer* pPrinter;</span><br><span class="line">	<span class="type">int</span> mTimes;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Printer* Printer::pPrinter = <span class="keyword">new</span> Printer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Printer* printer = Printer::<span class="built_in">getInstance</span>();</span><br><span class="line">	printer-&gt;<span class="built_in">PrintText</span>(<span class="string">&quot;离职报告!&quot;</span>);</span><br><span class="line">	printer-&gt;<span class="built_in">PrintText</span>(<span class="string">&quot;入职合同!&quot;</span>);</span><br><span class="line">	printer-&gt;<span class="built_in">PrintText</span>(<span class="string">&quot;提交代码!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-面向对象模型初探"><a href="#C-面向对象模型初探" class="headerlink" title="C++面向对象模型初探"></a>C++面向对象模型初探</h2><h3 id="成员变量和函数的存储"><a href="#成员变量和函数的存储" class="headerlink" title="成员变量和函数的存储"></a>成员变量和函数的存储</h3><ul>
<li>c++中的<em><strong>非静态数据成员</strong></em>直接内含在类对象中，就像c struct一样。</li>
<li>成员函数(member function)虽然内含在class声明之内，却不出现在对象空间中。</li>
<li>每一个非内联成员函数(non-inline member function)只会诞生一份函数实例.</li>
<li>空类的sizeof结果为1</li>
<li>只有类中的非静态成员才真正占用对象空间，他们也要内存对齐（和结构体一样）</li>
</ul>
<h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><h4 id="this指针工作原理"><a href="#this指针工作原理" class="headerlink" title="this指针工作原理"></a>this指针工作原理</h4><p>通过上例我们知道，c++的数据和操作也是分开存储，并且每一个非内联成员函数(non-inline member function)只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p>
<p>那么问题是：这一块代码是如何区分那个对象调用自己的呢？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps29.jpg" alt="img"></p>
<p>c++规定，this指针是隐含在对象成员函数内的一种指针。当一个对象被创建后，它的每一个成员函数都含有一个系统自动生成的隐含参数指针this，用以传入这个对象的地址，也就是说虽然我们没有写上this指针，编译器在编译的时候也是会加上的。因此this也称为“指向本对象的指针”，this指针并不是对象的一部分，不会影响sizeof(对象)的结果。</p>
<p> 　this指针是C++实现封装的一种机制，它将对象和该对象调用的成员函数连接在一起，在外部看来，每一个对象都拥有自己的函数成员。一般情况下，并不写this，而是让系统进行默认设置。<br>$$<br>this指针永远指向当前对象。<br>$$<br>成员函数通过this指针即可知道操作的是那个对象的数据。<strong>This指针是一种隐含指针，它隐含于每个类的非静态成员函数中。</strong>This指针无需定义，直接使用即可。</p>
<p><em><strong>c++编译器对普通成员函数的内部处理的理解图</strong></em></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps59.jpg" alt="img"></p>
<h4 id="this指针的使用"><a href="#this指针的使用" class="headerlink" title="this指针的使用"></a>this指针的使用</h4><ul>
<li>当形参和成员变量同名时，可用this指针来区分(实际开发一般类中命名规范为m_xxx表示member_xxx避开命名冲突)</li>
<li>在类的非静态成员函数中返回对象本身，可使用return *this.</li>
</ul>
<p><code>p.s.   *this为对象本身</code></p>
<p><strong>【重点理解】</strong>this案例：(内含链式编程思想)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> num;</span><br><span class="line">	<span class="built_in">Test</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		num = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Test&amp; <span class="title">plusNum</span><span class="params">(<span class="type">int</span> num)</span><span class="comment">//返回引用</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;num += num;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//返回对象本身</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Test t1;</span><br><span class="line">	t<span class="number">1.</span><span class="built_in">plusNum</span>(<span class="number">10</span>);</span><br><span class="line">	cout &lt;&lt; t<span class="number">1.</span>num &lt;&lt; endl;</span><br><span class="line">	t<span class="number">1.</span><span class="built_in">plusNum</span>(<span class="number">10</span>).<span class="built_in">plusNum</span>(<span class="number">10</span>).<span class="built_in">plusNum</span>(<span class="number">10</span>);<span class="comment">//链式编程思想</span></span><br><span class="line">	cout &lt;&lt; t<span class="number">1.</span>num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20201230145442591.png" alt="image-20201230145442591"></p>
<p>若将plusNum的返回值改成值传递:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Test <span class="title">plusNum</span><span class="params">(<span class="type">int</span> num)</span><span class="comment">//返回对象</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;num += num;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//返回对象本身</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>则</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Test t1;</span><br><span class="line">	t<span class="number">1.</span><span class="built_in">plusNum</span>(<span class="number">10</span>);</span><br><span class="line">	cout &lt;&lt; t<span class="number">1.</span>num &lt;&lt; endl;</span><br><span class="line">	t<span class="number">1.</span><span class="built_in">plusNum</span>(<span class="number">10</span>).<span class="built_in">plusNum</span>(<span class="number">10</span>).<span class="built_in">plusNum</span>(<span class="number">10</span>);<span class="comment">//链式编程思想</span></span><br><span class="line">	cout &lt;&lt; t<span class="number">1.</span>num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果为：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20201230145558329.png" alt="image-20201230145558329"></p>
<p>理解：对象的值赋值就是调用拷贝构造函数,从返回<strong>引用</strong>改成返回<strong>值</strong>后，实际上调用的是拷贝构造函数来生成了一个匿名对象,该匿名对象又调用plusNum函数返回值又因为调用拷贝构造函数生成另一个匿名对象…最终实际上，t1只进行了一次plusNum(10)，后面的每次plusNum都是针对每次拷贝构造函数生成的匿名对象而非t1。</p>
<p>这里额外提一下，<strong>函数千万不要返回局部对象的引用或指针</strong>，因为该指针指向的空间已经被释放了，该指针为悬垂指针(指向曾经存在的对象，但该对象已经不再存在了，此类指针称为垂悬指针)</p>
<h4 id="空指针访问成员函数"><a href="#空指针访问成员函数" class="headerlink" title="空指针访问成员函数"></a>空指针访问成员函数</h4><p>如果成员函数中没有用到this指针(直接用成员变量内部也会用到this指针)，可以用空指针调用成员函数</p>
<p>可以给成员函数的this加判断，防止别人用空指针访问成员函数，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">myTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>==<span class="literal">NULL</span>)<span class="comment">//防止别人用空指针访问成员函数</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="常量关键词-const"><a href="#常量关键词-const" class="headerlink" title="常量关键词(const)"></a>常量关键词(const)</h3><p><code>以下所有强调的直接修改对应的间接修改指的是通过指针来间接修改（可否间接修改参考之前const部分的内容）</code></p>
<h4 id="const修饰成员函数"><a href="#const修饰成员函数" class="headerlink" title="const修饰成员函数"></a>const修饰成员函数</h4><ul>
<li>用const修饰的成员函数时，const修饰this指针指向的内存区域，<strong>常量成员函数体内不可以直接修改本类中的任何普通成员变量。</strong></li>
<li>当成员变量类型符前用mutable（意思：可变的）修饰时例外。</li>
</ul>
<p>定义方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> 函数名() <span class="type">const</span>;</span><br></pre></td></tr></table></figure>

<p>功能：常成员函数可以<strong>访问</strong>常对象中的数据成员，但仍然不允许修改没有mutable修饰的常对象中数据成员的值。</p>
<p>**[注意]**汇编本质就是函数传参的第一个参数改成了const，因此重写函数时候需要写上这个函数后的const</p>
<h4 id="const修饰对象-常对象"><a href="#const修饰对象-常对象" class="headerlink" title="const修饰对象(常对象)"></a>const修饰对象(常对象)</h4><p>作用：使常对象中所有没有mutable修饰的成员变量不可直接修改</p>
<p>两种定义方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类名   <span class="type">const</span>   对象名(实参列表);</span><br><span class="line"><span class="type">const</span>   类名   对象名(实参列表);</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>常对象不能调用该对象的非const型的成员函数（除了构造函数和析构函数）。</li>
<li>常对象可访问 const 或非 const 数据成员，不能直接修改，除非成员用mutable修饰</li>
</ul>
<p><strong>【个人理解】</strong></p>
<p>常函数的本质是把本来由编译器暗中传入普通函数的<em><em>类型名</em> const  this</em><em>在常函数中传入为**const  类型名</em> const  this**。加多的const使this指向的内存不可直接修改了。</p>
<p>常对象的本质就是编译器限制对象调用普通成员函数，只能调用常函数。</p>
<p>【个人问题】mutable关键词实现原理?</p>
<h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>类的主要特点之一是<strong>数据隐藏</strong>，即类的私有成员无法在类的外部(作用域之外)访问。但是，有时候需要在类的外部访问类的私有成员，怎么办？</p>
<p>解决方法是使用友元函数，<strong>友元函数是一种特权函数，c++允许这个特权函数访问私有成员。</strong></p>
<p>开发中,线程回调函数需要访问类中静态成员,往往使用友元函数或者静态成员函数(该函数要更麻烦些).</p>
<h4 id="友元语法"><a href="#友元语法" class="headerlink" title="友元语法"></a>友元语法</h4><ul>
<li>friend关键字只出现在声明处</li>
<li>其他类、类成员函数、全局函数都可声明为友元</li>
<li><strong>友元函数不是类的成员，不带this指针</strong></li>
<li>友元函数可访问对象任意成员属性，包括私有属性</li>
<li>若Ａ类是Ｂ类的友元类，则Ａ类的所有成员函数都是Ｂ类的友元函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="comment">//友元类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyFriend</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//友元成员函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">LookAtBedRoom</span><span class="params">(Building&amp; building)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">PlayInBedRoom</span><span class="params">(Building&amp; building)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>&#123;</span><br><span class="line">	<span class="comment">//全局函数做友元函数</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">CleanBedRoom</span><span class="params">(Building&amp; building)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">	<span class="comment">//成员函数做友元函数</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">MyFriend::LookAtBedRoom</span><span class="params">(Building&amp; building)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">MyFriend::PlayInBedRoom</span><span class="params">(Building&amp; building)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span>	</span></span><br><span class="line">	<span class="comment">//友元类</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">MyFriend</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Building</span>();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string mSittingRoom;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string mBedroom;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyFriend::LookAtBedRoom</span><span class="params">(Building&amp; building)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;我的朋友参观&quot;</span> &lt;&lt; building.mBedroom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyFriend::PlayInBedRoom</span><span class="params">(Building&amp; building)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;我的朋友玩耍在&quot;</span> &lt;&lt; building.mBedroom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//友元全局函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CleanBedRoom</span><span class="params">(Building&amp; building)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;友元全局函数访问&quot;</span> &lt;&lt; building.mBedroom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>()&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;mSittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">	<span class="keyword">this</span>-&gt;mBedroom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	Building building;</span><br><span class="line">	MyFriend myfriend;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">CleanBedRoom</span>(building);</span><br><span class="line">	myfriend.<span class="built_in">LookAtBedRoom</span>(building);</span><br><span class="line">	myfriend.<span class="built_in">PlayInBedRoom</span>(building);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <em><strong>[友元类注意]</strong></em></p>
<ol>
<li>友元关系不能被继承。</li>
<li>友元关系是单向的，类A是类B的朋友，但类B不一定是类A的朋友。</li>
<li>友元关系不具有传递性。类B是类A的朋友，类C是类B的朋友，但类C不一定是类A的朋友。</li>
<li><strong>static和friend不能同时存在，简单的说friend static声明全局函数时, friend会默认函数为extern的, 和后面的static冲突. static friend违法标准规定friend声明前不能加存储类型关键字的规定.</strong></li>
</ol>
<p><em><strong>c++是纯面向对象的吗？</strong></em></p>
<p>如果一个类被声明为friend,意味着它不是这个类的成员函数，却可以修改这个类的私有成员，而且必须列在类的定义中，因此他是一个特权函数。c++不是完全的面向对象语言，而只是一个混合产品。增加friend关键字只是用来解决一些实际问题，这也说明这种语言是不纯的。毕竟c++设计的目的是为了实用性，而不是追求理想的抽象。</p>
<p><strong>尽量使用成员函数，除非不得已的情况下才使用友元函数。</strong></p>
<p><strong>什么时候使用友元函数：</strong></p>
<ol>
<li>运算符重载的某些场合需要使用友元。</li>
<li>两个类要共享数据的时候</li>
</ol>
<p>综合训练（动态数组类）</p>
<p><code>省略...</code></p>
<h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>运算符重载，就是对已有的运算符重新进行定义，<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/483609.htm">赋予</a>其另一种功能，以适应不同的数据类型。</p>
<p>$$<br>本质上，运算符重载(operator overloading)只是一种”语法上的方便”,也就是它只是另一种函数调用的方式。<br>$$<br>在c++中，可以定义一个处理类的新运算符。这种定义很像一个普通的函数定义，只是<strong>函数的名字由关键字operator及其紧跟的运算符组成</strong>。差别仅此而已。它像任何其他函数一样也是一个函数，当编译器遇到适当的模式时，就会调用这个函数。</p>
<h4 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a><em><strong>基本语法：</strong></em></h4><p>定义重载的运算符就像定义函数，只是该函数的名字是operator@,这里的@代表了被重载的运算符。函数的参数中参数个数取决于两个因素。</p>
<ul>
<li>运算符是一元(一个参数)的还是二元(两个参数)；</li>
<li>运算符被定义为全局函数(对于一元是一个参数，对于二元是两个参数)还是成员函数(对于一元没有参数，对于二元是一个参数-此时该类的对象用作左耳参数)</li>
</ul>
<blockquote>
<p>有些人很容易滥用运算符重载。它确实是一个有趣的工具。但是应该注意，它仅仅是一种语法上的方便而已，是另外一种函数调用的方式。从这个角度来看，只有在能使涉及类的代码更易写，尤其是<strong>更易读时(请记住，读代码的机会比我们写代码多多了)才有理由重载运算符</strong>。如果不是这样，就改用其他更易用，更易读的方式。</p>
<p>  对于运算符重载，另外一个常见的反应是恐慌：突然之间，C运算符的含义变得不同寻常了，一切都变了，所有C代码的功能都要改变！并非如此，<strong>对于内置的数据类型的表达式的的运算符是不可能改变的</strong>。（例如想重载int类型数据的+号）</p>
</blockquote>
<h4 id="可重载的运算符"><a href="#可重载的运算符" class="headerlink" title="可重载的运算符"></a>可重载的运算符</h4><p>几乎C中所有的运算符都可以重载，但运算符重载的使用时相当受限制的。特别是<strong>不能使用C中当前没有意义的运算符</strong>(例如用**求幂)<strong>不能改变运算符优先级</strong>，<strong>不能改变运算符的参数个数</strong>。这样的限制有意义，否则，所有这些行为产生的运算符只会混淆而不是澄清寓语意。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps32.jpg" alt="img"></p>
<h4 id="加号运算符重载"><a href="#加号运算符重载" class="headerlink" title="加号运算符重载"></a>加号运算符重载</h4><p>对于内置的数据类型，编译器知道如何进行运算，但是对于自定义的数据类型，编译器不知道如何运算。</p>
<p><strong>实现加号运算符重载的两种方式:</strong></p>
<ol>
<li><p>成员函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="built_in">Test</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		a = <span class="number">0</span>; </span><br><span class="line">		b = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    Test <span class="keyword">operator</span>+(Test&amp; test)<span class="comment">//必须返回的是类本身，因为返回的是局部对象t，会调用拷贝构造函数(如果返回void的话就不能实现链式编程思路)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Test t;</span><br><span class="line">        t.a+=a+test.a;</span><br><span class="line">        t.b+=b+test.b;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>两种调用方式：</p>
<ul>
<li>t1.operator+(t2);</li>
<li>t1+t2;</li>
</ul>
</li>
<li><p>全局函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="built_in">Test</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		a = <span class="number">0</span>; </span><br><span class="line">		b = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> Test <span class="keyword">operator</span>+(Test&amp; test1,Test&amp; tes2)<span class="comment">//必须返回的是类本身，因为返回的是局部对象t，会调用拷贝构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        Test t;</span><br><span class="line">        t.a+=test<span class="number">1.</span>a+tes<span class="number">2.</span>a;</span><br><span class="line">        t.b+=test<span class="number">1.</span>b+tes<span class="number">2.</span>b;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>两种调用方式：</p>
<ul>
<li>operator+(t1,t2);</li>
<li>t1+t2;</li>
</ul>
</li>
</ol>
<p><strong>【注意】</strong></p>
<p>全局方式和成员函数方式同时存在的时候不能用t1+t2的形式调用，因为具有二义性，编译器分不清</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210108170757184.png" alt="image-20210108170757184"></p>
<h4 id="左移运算符"><a href="#左移运算符" class="headerlink" title="左移运算符&lt;&lt;重载"></a>左移运算符&lt;&lt;重载</h4><p>对于自定义数据类型，不能直接用”cout&lt;&lt;自定义对象”来输出，需要重载左移运算符&lt;&lt;</p>
<p><strong>利用成员函数重载，无法实现让cout在左侧，因此我们不用成员函数重载</strong></p>
<h5 id="成员函数方式重载左移运算符："><a href="#成员函数方式重载左移运算符：" class="headerlink" title="成员函数方式重载左移运算符："></a>成员函数方式重载左移运算符：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">	ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out)<span class="comment">//ostream&amp;换成void则不可以链式编程。out处写cout也可以，只是起个别名而已，和cout的名称一样也可以</span></span><br><span class="line">	&#123;</span><br><span class="line">		out &lt;&lt;<span class="string">&quot;a为&quot;</span>&lt;&lt; a&lt;&lt;<span class="string">&quot;\tb为&quot;</span> &lt;&lt; b;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>两种调用方式:</p>
<ol>
<li>t1 &lt;&lt; cout;（<strong>此处cout在右边，因此用成员函数来重载左移运算符的方式并不好</strong>）</li>
<li>t1.operator&lt;&lt;(cout);</li>
</ol>
<h5 id="全局函数方式重载左移运算符"><a href="#全局函数方式重载左移运算符" class="headerlink" title="全局函数方式重载左移运算符"></a>全局函数方式重载左移运算符</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Test&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">	out &lt;&lt; <span class="string">&quot;a为&quot;</span> &lt;&lt; t.a &lt;&lt; <span class="string">&quot;\tb为&quot;</span> &lt;&lt; t.b;</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两种调用方式:</p>
<ol>
<li>operator&lt;&lt;(cout,t1);</li>
<li>cout&lt;&lt;t1;</li>
</ol>
<p>因此基本都是采用全局函数方式重载左移运算符。</p>
<p>因为是全局函数，所以访问类中私有数据要权限，解决方案：</p>
<ol>
<li>将左移运算符全局重载函数设置为对应类的友元函数</li>
<li>给每个需要显示的私有变量设置公有的getXXX()函数</li>
</ol>
<h4 id="自增自减-–-运算符重载"><a href="#自增自减-–-运算符重载" class="headerlink" title="自增自减(++&#x2F;–)运算符重载"></a>自增自减(++&#x2F;–)运算符重载</h4><blockquote>
<p>重载的++和–运算符有点让人不知所措，因为我们总是希望能根据它们出现在所作用对象的前面还是后面来调用不同的函数。解决办法很简单，例如<strong>当编译器看到++a(前置++)，它就调用operator++(a),当编译器看到a++（后置++），它就会去调用operator++(a,int).</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span>&#123;</span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,Complex&amp; complex)&#123;</span><br><span class="line">		os &lt;&lt; <span class="string">&quot;A:&quot;</span> &lt;&lt; complex.mA &lt;&lt; <span class="string">&quot; B:&quot;</span> &lt;&lt; complex.mB &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> os;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Complex</span>()&#123;</span><br><span class="line">		mA = <span class="number">0</span>;</span><br><span class="line">		mB = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重载前置++</span></span><br><span class="line">	Complex&amp; <span class="keyword">operator</span>++()&#123;</span><br><span class="line">		mA++;</span><br><span class="line">		mB++;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重载后置++</span></span><br><span class="line">	Complex <span class="keyword">operator</span>++(<span class="type">int</span>)&#123;	</span><br><span class="line">		Complex temp;</span><br><span class="line">		temp.mA = <span class="keyword">this</span>-&gt;mA;</span><br><span class="line">		temp.mB = <span class="keyword">this</span>-&gt;mB;</span><br><span class="line">		mA++;</span><br><span class="line">		mB++;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//前置--</span></span><br><span class="line">	Complex&amp; <span class="keyword">operator</span>--()&#123;</span><br><span class="line">		mA--;</span><br><span class="line">		mB--;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//后置--</span></span><br><span class="line">	Complex <span class="keyword">operator</span>--(<span class="type">int</span>)&#123;</span><br><span class="line">		Complex temp;</span><br><span class="line">		temp.mA = mA;</span><br><span class="line">		temp.mB = mB;</span><br><span class="line">		mA--;</span><br><span class="line">		mB--;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ShowComplex</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;A:&quot;</span> &lt;&lt; mA &lt;&lt; <span class="string">&quot; B:&quot;</span> &lt;&lt; mB &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> mA;</span><br><span class="line">	<span class="type">int</span> mB;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Complex complex;</span><br><span class="line">	complex++;</span><br><span class="line">	cout &lt;&lt; complex;</span><br><span class="line">	++complex;</span><br><span class="line">	cout &lt;&lt; complex;</span><br><span class="line"></span><br><span class="line">	Complex ret = complex++;</span><br><span class="line">	cout &lt;&lt; ret;</span><br><span class="line">	cout &lt;&lt; complex;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	ret--;</span><br><span class="line">	--ret;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ret:&quot;</span> &lt;&lt; ret;</span><br><span class="line">	complex--;</span><br><span class="line">	--complex;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;complex:&quot;</span> &lt;&lt; complex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps53.jpg" alt="img"></p>
<p><code>p.s.	T表示任意类型</code></p>
<p>解读:</p>
<p>**如果定义了++c，也要定义c++**，递增操作符比较麻烦，因为他们都有前缀和后缀形式，而两种语义略有不同。重载operator++和operator–时应该模仿他们对应的内置操作符。</p>
<p>对于++和–而言，后置形式是先返回，然后对象++或者–，返回的是对象的原值。前置形式，对象先++或–，返回当前对象，返回的是新对象。其标准形式为上图</p>
<hr>
<p><strong>【注意】</strong></p>
<p>调用代码时候，要<strong>优先使用前缀形式</strong>，除非确实需要后缀形式返回的原值，前缀和后缀形式语义上是等价的，输入工作量也相当，只是效率经常会略高一些，由于<strong>前缀形式少创建了一个临时对象</strong>。</p>
<hr>
<p><strong>【注意】</strong></p>
<p><strong>对于标准数据类型：前置可以嵌套多个前置，而后置只能一次。</strong></p>
<p>重复嵌套后置递增或递减会报错，如下图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210108172108584.png" alt="image-20210108172108584"></p>
<p>而对于我们上面自己实现的前后置重载，后置可以嵌套多层而没有语法错误，但是从第二次开始，运算的结果就已经存在临时对象中而不影响最初的对象。因此<strong>多次嵌套后置递增或递减也是没有意义的，要避免这样使用。</strong></p>
<hr>
<h4 id="指针运算符-、-重载"><a href="#指针运算符-、-重载" class="headerlink" title="指针运算符(*、-&gt;)重载"></a>指针运算符(*、-&gt;)重载</h4><p>这里为了描述指针运算符重载，引入智能指针的概念。</p>
<p><strong>智能指针</strong></p>
<ul>
<li>用途：托管new出来的对象的释放，让其自动帮忙在声明周期结束时候释放堆区对象</li>
<li>设计smartPoint智能指针类别，内部维护Person*new出来的对象的指针，在析构的时候释放堆区new出来的person对象。</li>
<li>重载(*、-&gt;)，直接通过智能指针对象重载后的指针运算符(*、-&gt;)，操作原对象的成员函数。</li>
</ul>
<p>案例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> param)&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mParam = param;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">PrintPerson</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Param:&quot;</span> &lt;&lt; mParam &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> mParam;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPointer</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">SmartPointer</span>(Person* person)&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;pPerson = person;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重载指针的-&gt;、*操作符</span></span><br><span class="line">	Person* <span class="keyword">operator</span>-&gt;()&#123;</span><br><span class="line">		<span class="keyword">return</span> pPerson;</span><br><span class="line">	&#125;</span><br><span class="line">	Person&amp; <span class="keyword">operator</span>*()&#123;<span class="comment">//这里必须返回引用是因为，如果返回Person的话会调用拷贝构造函数，创建一个新的临时对象返回。</span></span><br><span class="line">		<span class="keyword">return</span> *pPerson;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">SmartPointer</span>()&#123;</span><br><span class="line">		<span class="keyword">if</span> (pPerson != <span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="keyword">delete</span> pPerson;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Person* pPerson;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//Person* person = new Person(100);</span></span><br><span class="line">	<span class="comment">//如果忘记释放，那么就会造成内存泄漏</span></span><br><span class="line"></span><br><span class="line">	<span class="function">SmartPointer <span class="title">pointer</span><span class="params">(<span class="keyword">new</span> Person(<span class="number">100</span>))</span></span>;<span class="comment">//智能指针对象因为在堆区创建，所以声明周期结束时候会自动调用智能指针的析构函数，而智能指针的析构函数中写好了对新建的Person类对象的delete。因此我们用智能指针创建堆区上的Person对象时候，不需要自己手动delete。</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">//直接通过智能指针操作Person类的成员函数</span></span><br><span class="line">    pointer-&gt;<span class="built_in">PrintPerson</span>();</span><br><span class="line">    (*pointer).<span class="built_in">PrintPerson</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么<code>operator-&gt;()</code>应该返回指针类型,是因为:<br>$$<br>p-&gt;m\qquad等价于\qquad(p.operator-&gt;())-&gt;m &#x3D; 10<br>$$<br>*<em>指针运算符(<em>、-&gt;)重载必须是成员函数</em></em> </p>
<p>【注意】两种一样的调用形式对比：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pointer-&gt;<span class="built_in">PrintPerson</span>();<span class="comment">//pointer.operator-&gt;()-&gt;PrintPerson();（1号）</span></span><br><span class="line">(*pointer).<span class="built_in">PrintPerson</span>();<span class="comment">//pointer.operator*().PrintPerson();</span></span><br></pre></td></tr></table></figure>

<p><strong>对于-&gt;重载的理解，编译器会自动对pointer调用-&gt;重载函数再接-&gt;解析；</strong></p>
<p>【注意】</p>
<p>上诉案例中的智能指针并不存在什么实际价值，因为每个类都要专门写对应的智能指针去处理，特别麻烦，在实际生产中还是自动手动调用delete释放。</p>
<h4 id="赋值运算符-重载"><a href="#赋值运算符-重载" class="headerlink" title="赋值运算符&#x3D;重载"></a>赋值运算符&#x3D;重载</h4><p>必须是成员函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test t1;</span><br><span class="line">    t<span class="number">1.</span>a=<span class="number">2</span>;</span><br><span class="line">    Test t2=t1;<span class="comment">//调用的是拷贝构造函数（不自己写默认浅拷贝）</span></span><br><span class="line">    t2=t1;<span class="comment">//调用的是赋值运算符重载函数（不自己写默认浅拷贝）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即<strong>只有定义时候的&#x3D;运算符调用的是拷贝构造函数。</strong></p>
<p>默认提供的赋值运算符重载是<strong>浅拷贝</strong>。若类有用到堆区空间，应该实现成<strong>深拷贝</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">char</span>* name,<span class="type">int</span> id, <span class="type">int</span> age)&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;pName = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(name) + <span class="number">1</span>];</span><br><span class="line">		<span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;pName, name);</span><br><span class="line">		<span class="keyword">this</span>-&gt;mID = id;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重载赋值运算符</span></span><br><span class="line">	Person&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Person&amp; person)&#123;<span class="comment">//返回本身的引用是为了链式编程，同时也必须是返回Person的引用，如果返回Person，难么系统实际上是调用了拷贝构造函数生成了一个临时对象来返回，那么链式编程中的下一次就是这个临时对象调用这个赋值运算符重载函数，函数内中的释放堆空间的操作就就释放的是临时对象中指针指向的堆空间，而很显然，原本要释放的堆空间却没有释放，并且遗失了他的指针。因此势必内存泄露。</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//注意:由于当前对象已经创建完毕，那么就有可能pName指向堆内存</span></span><br><span class="line">		<span class="comment">//这个时候如果直接赋值，会导致内存没有及时释放，因此要先释放之前的堆空间</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;pName != <span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pName;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>-&gt;pName = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(person.pName) + <span class="number">1</span>];</span><br><span class="line">		<span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;pName,person.pName);</span><br><span class="line">		<span class="keyword">this</span>-&gt;mID = person.mID;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mAge = person.mAge;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//返回(Person&amp;)person这个实际上更符合整形链式赋值的汇编流程</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">Person</span>()&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;pName != <span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pName;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span>* pName;</span><br><span class="line">	<span class="type">int</span> mID;</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>两种调用方式:</p>
<ol>
<li>person1&#x3D;person2;</li>
<li>person1.operator&#x3D;(person2);</li>
</ol>
<p>理解链式调用赋值运算符&#x3D;重载函数</p>
<p>person1&#x3D;person2&#x3D;person3;</p>
<p>类比如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">3</span>,b,c;</span><br><span class="line">c=b=a;<span class="comment">//先把a的值赋给b，再把b的值赋给c,从右向左</span></span><br></pre></td></tr></table></figure>

<p>因此person1&#x3D;person2&#x3D;person3;也是先调用person2&#x3D;person3，然后person1&#x3D;person3。</p>
<p><strong>【重点】上面案例代码中对于赋值运算符重载的返回值类型的解读</strong></p>
<h4 id="下标运算符-重载"><a href="#下标运算符-重载" class="headerlink" title="下标运算符[]重载"></a>下标运算符[]重载</h4><p>实现访问数组时候利用[]访问元素</p>
<p>必须是成员函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类内</span></span><br><span class="line"><span class="type">int</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> index)<span class="comment">//返回引用的目的是为了可以返回左值来修改里面的值</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.pAddress[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="关系运算符重载"><a href="#关系运算符重载" class="headerlink" title="关系运算符重载"></a>关系运算符重载</h4><p>对于自定义数据类型，编译器不知道如何进行比较</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类内</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(Person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(Person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//全局省略了，懒得写了</span></span><br></pre></td></tr></table></figure>

<h4 id="函数调用运算符-重载"><a href="#函数调用运算符-重载" class="headerlink" title="函数调用运算符()重载"></a>函数调用运算符()重载</h4><ul>
<li>重载()</li>
<li>使用时候很像函数调用，因此称为<strong>仿函数</strong></li>
<li>仿函数返回值和参数个数都不固定，很灵活</li>
<li><strong>函数调用运算符必须是成员函数</strong>（只有当左操作数是一个基本类型对象时，才重载为全局函数）</li>
<li>使用情景：后面[[STL]]中大量用到！</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类中</span></span><br><span class="line"><span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="comment">/*多少个参数都可以*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两种调用方式:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对象();</span><br><span class="line">对象.<span class="built_in">operator</span>()(<span class="comment">/* 参数列表 */</span>);</span><br></pre></td></tr></table></figure>

<p><strong>【注意】</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">MyAdd</span>()(<span class="number">1</span>,<span class="number">1</span>) &lt;&lt; endl;<span class="comment">//MyAdd()是匿名函数对象,后面的括号表示匿名对象调用函数运算符重载函数  特点：当前行执行完立即释放</span></span><br></pre></td></tr></table></figure>

<h4 id="不要重载-、"><a href="#不要重载-、" class="headerlink" title="不要重载&amp;&amp;、||"></a>不要重载&amp;&amp;、||</h4><p>不能重载operator&amp;&amp; 和 operator|| 的原因是：<strong>无法在这两种情况下实现内置操作符的完整语义。</strong></p>
<p> <strong>内置版本版本特殊之处在于</strong>：内置版本的&amp;&amp;和||首先计算左边的表达式，如果这完全能够决定结果，就无需计算右边的表达式了–而且能够保证不需要。我们都已经习惯这种方便的特性了。</p>
<p>内置版本和重载后结果不一致的案例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Complex</span>(<span class="type">int</span> flag)&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;flag = flag;</span><br><span class="line">	&#125;</span><br><span class="line">	Complex&amp; <span class="keyword">operator</span>+=(Complex&amp; complex)&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;flag = <span class="keyword">this</span>-&gt;flag + complex.flag;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>&amp;&amp;(Complex&amp; complex)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;flag &amp;&amp; complex.flag;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> flag;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Complex <span class="title">complex1</span><span class="params">(<span class="number">0</span>)</span></span>;  <span class="comment">//flag 0 </span></span><br><span class="line">	<span class="function">Complex <span class="title">complex2</span><span class="params">(<span class="number">1</span>)</span></span>;  <span class="comment">//flag 1</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//原来情况，应该从左往右运算，左边为假，则退出运算，结果为假</span></span><br><span class="line">	<span class="comment">//这边却是，先运算（complex1+complex2），导致，complex1的flag变为complex1+complex2的值， complex1.a = 1</span></span><br><span class="line">	<span class="comment">// 1 &amp;&amp; 1</span></span><br><span class="line">	<span class="comment">//complex1.operator&amp;&amp;(complex1.operator+=(complex2))</span></span><br><span class="line">	<span class="keyword">if</span> (complex1 &amp;&amp; (complex1 += complex2))&#123;   </span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;真!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;假!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据内置&amp;&amp;的执行顺序，我们发现这个案例中执行顺序并不是从左向右，而是先右后左，这就是不满足我们习惯的特性了。由于complex1 <em><strong>+&#x3D;</strong></em> complex2先执行，导致complex1 本身发生了变化，初始值是0，现在经过+&#x3D;运算变成1,1 &amp;&amp; 1输出了真。(内置版本应该输出的是假)</p>
<h4 id="运算符重载总结"><a href="#运算符重载总结" class="headerlink" title="运算符重载总结"></a>运算符重载总结</h4><ul>
<li>&#x3D;, [], () 和 -&gt; 操作符只能通过成员函数进行重载 </li>
<li>&lt;&lt; 和 &gt;&gt;只能通过全局函数配合友元函数进行重载 </li>
<li>不要重载 &amp;&amp; 和 || 操作符，因为无法实现短路规则</li>
</ul>
<p>常规建议：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps64.jpg" alt="img"></p>
<h5 id="附录：运算符和结合性"><a href="#附录：运算符和结合性" class="headerlink" title="附录：运算符和结合性"></a>附录：运算符和结合性</h5><table>
<thead>
<tr>
<th><em><strong>优先级</strong></em></th>
<th><em><strong>运算符</strong></em></th>
<th><em><strong>名称或含义</strong></em></th>
<th><em><strong>使用形式</strong></em></th>
<th><em><strong>结合方向</strong></em></th>
<th><em><strong>说明</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td><em><strong>1</strong></em></td>
<td><em><strong>[]</strong></em></td>
<td>数组下标</td>
<td>数组名[常量表达式]</td>
<td>左到右</td>
<td>–</td>
</tr>
<tr>
<td></td>
<td><em><strong>()</strong></em></td>
<td>圆括号</td>
<td>(表达式）&#x2F;函数名(形参表)</td>
<td></td>
<td>–</td>
</tr>
<tr>
<td></td>
<td><em><strong>.</strong></em></td>
<td>成员选择（对象）</td>
<td>对象.成员名</td>
<td></td>
<td>–</td>
</tr>
<tr>
<td></td>
<td><em><strong>-&gt;</strong></em></td>
<td>成员选择（指针）</td>
<td>对象指针-&gt;成员名</td>
<td></td>
<td>–</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em><strong>2</strong></em></td>
<td><em><strong>-</strong></em></td>
<td>负号运算符</td>
<td>-表达式</td>
<td>右到左</td>
<td>单目运算符</td>
</tr>
<tr>
<td></td>
<td><em><strong>~</strong></em></td>
<td>按位取反运算符</td>
<td>~表达式</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td><em><strong>++</strong></em></td>
<td>自增运算符</td>
<td>++变量名&#x2F;变量名++</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td><em><strong>–</strong></em></td>
<td>自减运算符</td>
<td>–变量名&#x2F;变量名–</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>*******</td>
<td>取值运算符</td>
<td>*指针变量</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td><em><strong>&amp;</strong></em></td>
<td>取地址运算符</td>
<td>&amp;变量名</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td><em><strong>!</strong></em></td>
<td>逻辑非运算符</td>
<td>!表达式</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td><em><strong>(类型)</strong></em></td>
<td>强制类型转换</td>
<td>(数据类型)表达式</td>
<td></td>
<td>–</td>
</tr>
<tr>
<td></td>
<td><em><strong>sizeof</strong></em></td>
<td>长度运算符</td>
<td>sizeof(表达式)</td>
<td></td>
<td>–</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em><strong>3</strong></em></td>
<td><em><strong>&#x2F;</strong></em></td>
<td>除</td>
<td>表达式&#x2F;表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td></td>
<td>*******</td>
<td>乘</td>
<td>表达式*表达式</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td><em><strong>%</strong></em></td>
<td>余数（取模）</td>
<td>整型表达式%整型表达式</td>
<td></td>
<td></td>
</tr>
<tr>
<td><em><strong>4</strong></em></td>
<td><em><strong>+</strong></em></td>
<td>加</td>
<td>表达式+表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td></td>
<td><em><strong>-</strong></em></td>
<td>减</td>
<td>表达式-表达式</td>
<td></td>
<td></td>
</tr>
<tr>
<td><em><strong>5</strong></em></td>
<td><em><strong>&lt;&lt;</strong></em></td>
<td>左移</td>
<td>变量&lt;&lt;表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td></td>
<td><em><strong>&gt;&gt;</strong></em></td>
<td>右移</td>
<td>变量&gt;&gt;表达式</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em><strong>6</strong></em></td>
<td><em><strong>&gt;</strong></em></td>
<td>大于</td>
<td>表达式&gt;表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td></td>
<td><em><strong>&gt;&#x3D;</strong></em></td>
<td>大于等于</td>
<td>表达式&gt;&#x3D;表达式</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td><em><strong>&lt;</strong></em></td>
<td>小于</td>
<td>表达式&lt;表达式</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td><em><strong>&lt;&#x3D;</strong></em></td>
<td>小于等于</td>
<td>表达式&lt;&#x3D;表达式</td>
<td></td>
<td></td>
</tr>
<tr>
<td><em><strong>7</strong></em></td>
<td><em><strong>&#x3D;&#x3D;</strong></em></td>
<td>等于</td>
<td>表达式&#x3D;&#x3D;表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td></td>
<td><em><strong>！&#x3D;</strong></em></td>
<td>不等于</td>
<td>表达式!&#x3D; 表达式</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em><strong>8</strong></em></td>
<td><em><strong>&amp;</strong></em></td>
<td>按位与</td>
<td>表达式&amp;表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td><em><strong>9</strong></em></td>
<td><em><strong>^</strong></em></td>
<td>按位异或</td>
<td>表达式^表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td><em><strong>10</strong></em></td>
<td><em><strong>|</strong></em></td>
<td>按位或</td>
<td>表达式|表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td><em><strong>11</strong></em></td>
<td><em><strong>&amp;&amp;</strong></em></td>
<td>逻辑与</td>
<td>表达式&amp;&amp;表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td><em><strong>12</strong></em></td>
<td><em><strong>||</strong></em></td>
<td>逻辑或</td>
<td>表达式||表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em><strong>13</strong></em></td>
<td><em><strong>?:</strong></em></td>
<td>条件运算符</td>
<td>表达式1?表达式2: 表达式3</td>
<td>右到左</td>
<td>三目运算符</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em><strong>14</strong></em></td>
<td><em><strong>&#x3D;</strong></em></td>
<td>赋值运算符</td>
<td>变量&#x3D;表达式</td>
<td>右到左</td>
<td>–</td>
</tr>
<tr>
<td></td>
<td><em><strong>&#x2F;&#x3D;</strong></em></td>
<td>除后赋值</td>
<td>变量&#x2F;&#x3D;表达式</td>
<td></td>
<td>–</td>
</tr>
<tr>
<td></td>
<td><em><strong>&#x3D;</strong></em></td>
<td>乘后赋值</td>
<td>变量*&#x3D;表达式</td>
<td></td>
<td>–</td>
</tr>
<tr>
<td></td>
<td><em><strong>%&#x3D;</strong></em></td>
<td>取模后赋值</td>
<td>变量%&#x3D;表达式</td>
<td></td>
<td>–</td>
</tr>
<tr>
<td></td>
<td><em><strong>+&#x3D;</strong></em></td>
<td>加后赋值</td>
<td>变量+&#x3D;表达式</td>
<td></td>
<td>–</td>
</tr>
<tr>
<td></td>
<td><em><strong>-&#x3D;</strong></em></td>
<td>减后赋值</td>
<td>变量-&#x3D;表达式</td>
<td></td>
<td>–</td>
</tr>
<tr>
<td></td>
<td><em><strong>&lt;&lt;&#x3D;</strong></em></td>
<td>左移后赋值</td>
<td>变量&lt;&lt;&#x3D;表达式</td>
<td></td>
<td>–</td>
</tr>
<tr>
<td></td>
<td><em><strong>&gt;&gt;&#x3D;</strong></em></td>
<td>右移后赋值</td>
<td>变量&gt;&gt;&#x3D;表达式</td>
<td></td>
<td>–</td>
</tr>
<tr>
<td></td>
<td><em><strong>&amp;&#x3D;</strong></em></td>
<td>按位与后赋值</td>
<td>变量&amp;&#x3D;表达式</td>
<td></td>
<td>–</td>
</tr>
<tr>
<td></td>
<td><em><strong>^&#x3D;</strong></em></td>
<td>按位异或后赋值</td>
<td>变量^&#x3D;表达式</td>
<td></td>
<td>–</td>
</tr>
<tr>
<td></td>
<td><em><strong>|&#x3D;</strong></em></td>
<td>按位或后赋值</td>
<td>变量|&#x3D;表达式</td>
<td></td>
<td>–</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em><strong>15</strong></em></td>
<td><em><strong>，</strong></em></td>
<td>逗号运算符</td>
<td>表达式,表达式,…</td>
<td>左到右</td>
<td>–</td>
</tr>
</tbody></table>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="继承基本概念"><a href="#继承基本概念" class="headerlink" title="继承基本概念"></a><strong>继承基本概念</strong></h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps27.jpg" alt="img"></p>
<blockquote>
<p>c++最重要的特征是<strong>代码重用</strong>，通过继承机制可以利用已有的数据类型来定义新的数据类型，新的类不仅拥有旧类的成员，还拥有新定义的成员。</p>
<p>一个B类继承于A类，或称从类A派生类B。这样的话，类A成为基类（父类）， 类B成为派生类（子类）。</p>
</blockquote>
<p>派生类中的<strong>成员，包含两大部分</strong>：</p>
<ul>
<li>一类是<strong>从基类继承</strong>过来的，一类是<strong>自己增加</strong>的成员。</li>
<li>从基类继承过过来的表现其<strong>共性</strong>，而新增的成员体现了其<strong>个性</strong>。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps55.png" alt="img"></p>
<p><em><strong>定义格式：</strong></em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class 派生类名 :  继承方式 基类名&#123;</span><br><span class="line">      <span class="comment">//派生类新增的数据成员和成员函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三种继承方式：</p>
<ul>
<li>public：公有继承</li>
<li>private：私有继承</li>
<li>protected：保护继承</li>
</ul>
<p>从继承源上分： </p>
<ul>
<li>单继承：指每个派生类只直接继承了一个基类的特征</li>
<li>多继承：指多个基类派生出一个派生类的继承关系,多继承的派生类直接继承了不止一个基类的特征</li>
</ul>
<h4 id="派生类访问控制"><a href="#派生类访问控制" class="headerlink" title="派生类访问控制"></a>派生类访问控制</h4><p>派生类继承基类，<strong>派生类拥有基类中全部成员变量和成员方法（除了构造和析构之外的成员方法）</strong>，但是在派生类中，继承的成员并不一定能直接访问，<strong>不同的继承方式会导致不同的访问权限</strong>。</p>
<p>派生类的访问权限规则如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps75.jpg" alt="img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps128.jpg" alt="img"></p>
<p><strong>继承中的对象模型</strong></p>
<ul>
<li><p>父类中私有属性，子类是继承下去了，只不过由编译器给隐藏了，访问不到</p>
</li>
<li><p>可以利用开发人员工具查看对象模型</p>
<ol>
<li><p>vs2015的位置：C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Visual Studio 2015\Visual Studio Tools\VS2015 开发人员命令提示.exe</p>
</li>
<li><p>跳转到项目路径下</p>
</li>
<li><p>查看对象模型：cl &#x2F;d1 reportSingleClassLayout类名 文件名(注意：reportSingleClassLayout和类名之间没有空格)</p>
</li>
<li><pre><code class="cpp">class Father
&#123;
    int m_A;
    char m_B;
&#125;;

class Son:public Father
&#123;
    int m_C;
&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">  5. ![image-20210118121802527](https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210118121802527.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 继承中的构造和析构</span><br><span class="line"></span><br><span class="line">- **先调用父类构造，再调用自身类中其他对象成员构造，再调用自身构造**，析构的顺序与构造相反</span><br><span class="line">- 利用**初始化列表语法，显示调用父类中的其他构造函数**（不用初始化列表显示调用的情况下，系统默认调用无参构造函数）</span><br><span class="line">- 父类中的**构造，析构，拷贝构造，operator=** 不会被子类继承下去的（在继承的过程中，如果没有创建这些函数，编译器会自动生成它们。）</span><br><span class="line"></span><br><span class="line">***继承与对象嵌套混搭的构造和析构***</span><br><span class="line"></span><br><span class="line">![img](https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps36.jpg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 继承中同名成员的处理方法</span><br><span class="line"></span><br><span class="line">- 当子类成员和父类成员同名时，子类依然从父类继承同名成员</span><br><span class="line">- 如果子类有成员和父类同名，子类访问其成员默认访问子类的成员(本作用域，**就近原则**)</span><br><span class="line">- 在子类**通过作用域::进行同名成员区分**(在派生类中使用基类的同名成员，显示使用类名限定符)</span><br><span class="line"></span><br><span class="line">继承中的同名成员函数要**【注意】**：</span><br><span class="line"></span><br><span class="line">**任何时候重新定义基类中的一个重载函数，在子类的父类中所有重载版本都将被自动隐藏**，可以利用作用域显示指定调用</span><br><span class="line"></span><br><span class="line">#### 继承中的静态成员特性</span><br><span class="line"></span><br><span class="line">处理方式和非静态成员一致</span><br><span class="line"></span><br><span class="line">只不过调用方式有两种</span><br><span class="line"></span><br><span class="line">1. 通过对象</span><br><span class="line">2. 通过类名（如：Son::Base::m_A,访问子类Son中父类作用域下的m_A静态成员变量）</span><br><span class="line"></span><br><span class="line">#### 多继承</span><br><span class="line"></span><br><span class="line">我们可以从一个类继承，我们也可以能同时从多个类继承，这就是多继承。但是由于多继承是非常受争议的，从多个类继承可能会导致函数、变量等同名导致较多的歧义。</span><br><span class="line"></span><br><span class="line">![img](https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps41.jpg)</span><br><span class="line"></span><br><span class="line">多继承会带来一些二义性的问题， 如果两个基类中有同名的函数或者变量，那么通过派生类对象去访问这个函数或变量时就不能明确到底调用从基类1继承的版本还是从基类2继承的版本？</span><br><span class="line"></span><br><span class="line">解决方法就是显示指定调用那个基类的版本。</span><br><span class="line"></span><br><span class="line">#### 菱形继承和虚继承</span><br><span class="line"></span><br><span class="line">两个派生类继承同一个基类而又有某个类同时继承者两个派生类，这种继承被称为菱形继承，或者钻石型继承。</span><br><span class="line"></span><br><span class="line">![img](https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps63.png)![img](https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202410281134905.png)</span><br><span class="line"></span><br><span class="line">这种继承所带来的问题：草泥马继承自动物的函数和数据**继承了两份**，其实我们应该清楚，这份数据我们**只需要一份**就可以，并且还伴随二义性问题。</span><br><span class="line"></span><br><span class="line">对于这种菱形继承所带来的两个问题，c++为我们提供了一种方式，采用**虚基类**。</span><br><span class="line"></span><br><span class="line">**作用：**编译器帮我们做了一些幕后工作，使得这种菱形问题在继承时候能**只继承一份数据**，并且也解决了二义性的问题。使模型变成了Base1和 Base2 Derived三个类对象共享了一份BigBase数据。</span><br><span class="line"></span><br><span class="line">##### 虚继承实现原理</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">class BigBase &#123;</span><br><span class="line">public:</span><br><span class="line">	BigBase() &#123; mParam = 0; &#125;</span><br><span class="line">	void func() &#123; cout &lt;&lt; &quot;BigBase::func&quot; &lt;&lt; endl; &#125;</span><br><span class="line">public: int mParam;</span><br><span class="line">&#125;;</span><br><span class="line">#if 0 //虚继承</span><br><span class="line">class Base1 : virtual public BigBase &#123;&#125;;</span><br><span class="line">class Base2 : virtual public BigBase &#123;&#125;;</span><br><span class="line">#else //普通继承</span><br><span class="line">class Base1 : public BigBase &#123;&#125;;</span><br><span class="line">class Base2 : public BigBase &#123;&#125;;</span><br><span class="line">#endif</span><br><span class="line">class Derived : public Base1, public Base2 &#123;&#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</li>
</ul>
<p>结果如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>普通继承</th>
<th>虚继承</th>
</tr>
</thead>
<tbody><tr>
<td>BigBase：</td>
<td><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210119112607731.png" alt="image-20210119112607731"></td>
<td><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210119112604027.png" alt="image-20210119112604027"></td>
</tr>
<tr>
<td>Base1：</td>
<td><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210119112457172.png" alt="image-20210119112457172"></td>
<td><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210119112527908.png" alt="image-20210119112527908"></td>
</tr>
<tr>
<td>Base2：</td>
<td><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210119112436034.png" alt="image-20210119112436034"></td>
<td><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210119112410840.png" alt="image-20210119112410840"></td>
</tr>
<tr>
<td>Derived：</td>
<td><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210119112255936.png" alt="image-20210119112255936"></td>
<td><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210119112329474.png" alt="image-20210119112329474"></td>
</tr>
</tbody></table>
<ul>
<li>BigBase 菱形最顶层的类，内存布局图没有发生改变。</li>
<li>Base1和Base2通过虚继承的方式派生自BigBase,这两个对象的布局图中可以看出编译器为我们的对象中增加了一个vbptr (virtual base pointer),vbptr指向了一张表，这张表保存了当前的虚指针相对于虚基类的首地址的偏移量。</li>
<li>Derived派生于Base1和Base2,继承了两个基类的vbptr指针，并调整了vbptr与虚基类的首地址的偏移量。</li>
</ul>
<p>当使用虚继承时，在继承体系中无论被继承多少次，<strong>对象内存模型中均只会出现一个虚基类的子对象</strong>（这和多继承是完全不同的）</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210120153202392.png" alt="image-20210120153202392" style="zoom: 67%;" />

<p>D的存储结构：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210120153036533.png" alt="image-20210120153036533" style="zoom:50%;" />

<p>指针访问Derived类中Base2虚表中的偏移量4，代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Derived d;</span><br><span class="line">cout&lt;&lt;*((<span class="type">int</span>*)*((<span class="type">int</span>*)&amp;d<span class="number">+1</span>)<span class="number">+1</span>)&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210119115528168.png" alt="image-20210119115528168"></p>
<p>虚继承只能解决具备公共祖先的多继承所带来的二义性问题，不能解决没有公共祖先的多继承的.</p>
<p>工程开发中真正意义上的多继承是几乎不被使用，因为<strong>多重继承带来的代码复杂性远多于其带来的便利</strong>，<strong>多重继承对代码维护性上的影响是灾难性的</strong>，在设计方法上，<strong>任何多继承都可以用单继承代替</strong>。</p>
<h5 id="虚基类的构造函数"><a href="#虚基类的构造函数" class="headerlink" title="虚基类的构造函数"></a>虚基类的构造函数</h5><p><strong>最派生类</strong>：继承结构中建立对象时所指定的类；</p>
<p>最派生类的构造函数的成员<strong>初始化列表中必须给出对虚基类的构造函数的调用</strong>，如果未列出，则相应的虚基类<strong>必须有缺省构造函数</strong>；</p>
<p>若A是虚基类,且没有缺省构造函数，则必须如下写明A()初始化列表</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210120154101261.png" alt="image-20210120154101261"></p>
<p>p.s.如果不是虚基类，调用父类非默认构造函数只需要传入父类，而如果祖先中有虚基类，那么初始化列表中必须有虚基类。</p>
<p>单个虚基类的案例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>(<span class="type">int</span> a)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;A构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">B</span>(<span class="type">int</span> a,<span class="type">int</span> b):<span class="built_in">A</span>(a)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;B构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">C</span>(<span class="type">int</span> a, <span class="type">int</span> c) :<span class="built_in">A</span>(a)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;c = c;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;C构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DD</span> : <span class="keyword">public</span> C,<span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">DD</span>(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c,<span class="type">int</span> d) :<span class="built_in">B</span>(a,b), <span class="built_in">C</span>(a,c),<span class="built_in">A</span>(a)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;c = c;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;DD构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">DD <span class="title">d</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210120160100338.png" alt="image-20210120160100338"></p>
<p>p.s.<strong>虚基类构造函数永远先于非虚基类构造函数执行</strong></p>
<p>d对象的内存布局图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210120160156859.png" alt="image-20210120160156859"></p>
<p>多个虚基类案例：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210120161329374.png" style="zoom: 67%;" />

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>(<span class="type">int</span> a)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;A构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">B</span>(<span class="type">int</span> a,<span class="type">int</span> b):<span class="built_in">A</span>(a)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;B构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">C</span>(<span class="type">int</span> a, <span class="type">int</span> c) :<span class="built_in">A</span>(a)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;c = c;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;C构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DD</span> : <span class="keyword">public</span> C,<span class="keyword">virtual</span> <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">DD</span>(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c,<span class="type">int</span> d) :<span class="built_in">B</span>(a, b),<span class="built_in">C</span>(a, c),<span class="built_in">A</span>(a)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;c = c;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;DD构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EE</span> :<span class="keyword">virtual</span> <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">EE</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> e) :<span class="built_in">B</span>(a, b), <span class="built_in">A</span>(a)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;e = e;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;EE构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> e;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FF</span> :<span class="keyword">public</span> EE, <span class="keyword">public</span> DD</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">FF</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> e, <span class="type">int</span> d,<span class="type">int</span> f):<span class="built_in">A</span>(a),<span class="built_in">B</span>(a,b),<span class="built_in">EE</span>(a,b,e),<span class="built_in">DD</span>(a,b,c,d)<span class="comment">//有多个虚基类，则多个虚基类都要写进初始化列表，除非有缺省构造函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;f = f;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;FF构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> f;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">FF <span class="title">f</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210120161412297.png" alt="image-20210120161412297"></p>
<p>内存布局分析：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210120164422842.png" alt="image-20210120164422842"></p>
<p><code>因开发人员命令提示工具问题，单字母类名与多同字母类名同等看待</code></p>
<table>
<thead>
<tr>
<th align="center">类名</th>
<th align="center">内存布局</th>
</tr>
</thead>
<tbody><tr>
<td align="center">AAA</td>
<td align="center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210120164914264.png" alt="image-20210120164914264"></td>
</tr>
<tr>
<td align="center">BB</td>
<td align="center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210120164927251.png" alt="image-20210120164927251"></td>
</tr>
<tr>
<td align="center">CC</td>
<td align="center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210120164944123.png" alt="image-20210120164944123"></td>
</tr>
<tr>
<td align="center">DD</td>
<td align="center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210120165007699.png" alt="image-20210120165007699"></td>
</tr>
<tr>
<td align="center">EE</td>
<td align="center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210120165156147.png" alt="image-20210120165156147"></td>
</tr>
<tr>
<td align="center">FF</td>
<td align="center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210120165232831.png" alt="image-20210120165232831"></td>
</tr>
</tbody></table>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p><strong>多态</strong>是面向对象程序设计语言中<strong>数据抽象</strong>和<strong>继承</strong>之外的<strong>第三个基本特征</strong>。</p>
<p><strong>多态性</strong>(polymorphism)提供<strong>接口与具体实现之间</strong>的另一层<strong>隔离</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210120170500049.png" alt="image-20210120170500049"></p>
<p>静态多态：运算符重载和函数重载</p>
<p>动态多态条件：</p>
<ol>
<li>先有继承关系</li>
<li>父类中有虚函数，子类重写父类中的虚函数</li>
<li>父类的指针或引用指向子类的对象</li>
</ol>
<p>静态多态和动态多态的区别：就是函数地址是早绑定(<strong>静态联编</strong>)还是晚绑定(<strong>动态联编</strong>)。</p>
<blockquote>
<p>如果函数的调用，在编译阶段就可以确定函数的调用地址，并产生代码，就是静态多态(编译时多态)，就是说地址是早绑定的。而如果函数的调用地址不能编译不能在编译期间确定，而需要在运行时才能决定，这这就属于晚绑定(动态多态,运行时多态)。</p>
</blockquote>
<p><strong>重写(覆盖)<strong>：是指</strong>派生类中存在重新定义的函数</strong>。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。<strong>只有函数体不同</strong>（花括号内），派生类调用时会调用派生类的重写函数，不会调用被重写函数。<strong>重写的基类中被重写的函数必须有virtual修饰</strong>。</p>
<p>动态多态案例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">sleep</span><span class="params">()</span><span class="comment">//虚函数，代表其可被子类重写实现运行时多态</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;动物在睡觉&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>:<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">sleep</span><span class="params">()</span><span class="comment">//重写父类函数</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;猫猫在睡觉&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">sleep</span><span class="params">()</span><span class="comment">//重写父类函数</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;狗狗在睡觉&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sleep</span><span class="params">(Animal&amp; animal)</span><span class="comment">//重载</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	animal.<span class="built_in">sleep</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Animal a;</span><br><span class="line">	Dog d;</span><br><span class="line">	Cat c;</span><br><span class="line">	<span class="built_in">Sleep</span>(a);</span><br><span class="line">	<span class="built_in">Sleep</span>(d);</span><br><span class="line">	<span class="built_in">Sleep</span>(c);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210120172342123.png" alt="image-20210120172342123"></p>
<p>若把Animal类中sleep函数前的virtual去掉，结果如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210120172425758.png" alt="image-20210120172425758"></p>
<p>则不能实现运行时多态</p>
<h4 id="父类引用-指向子类对象的四种方式"><a href="#父类引用-指向子类对象的四种方式" class="headerlink" title="父类引用&#x2F;指向子类对象的四种方式"></a>父类引用&#x2F;指向子类对象的四种方式</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ITestOutput</span><span class="comment">//纯虚类,接口ITestOutput</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">testOutput</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestOutput</span>:<span class="keyword">public</span> ITestOutput<span class="comment">//继承自接口接口ITestOutput</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">testOutput</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;testOutput&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">testOutput2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;testOutput2&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>指针,被指向对象为栈上分配内存</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TestOutput testoutput;</span><br><span class="line">ITestOutput* i = &amp;testoutput;</span><br></pre></td></tr></table></figure>

<p><strong>指针,被指向对象为堆上分配内存</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ITestOutput* i = <span class="keyword">new</span> TestOutput;</span><br></pre></td></tr></table></figure>

<p><strong>引用,被引用对象为栈上分配内存</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TestOutput testObj;</span><br><span class="line">ITestOutput&amp; i = testObj;</span><br></pre></td></tr></table></figure>

<p><strong>引用,被引用对象为堆上分配内存</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ITestOutput* p = <span class="keyword">new</span> TestOutput</span><br><span class="line">ITestOutput&amp; i = *p;</span><br><span class="line">i.<span class="built_in">testOutput</span>();</span><br><span class="line"><span class="comment">//p这一句指针获取语句必须有,如果直接&quot;ITestOutput&amp; i = *new TestOutput&quot;的话,这里创建的临时对象没有被任何智能指针或其他变量捕获，这意味着它将在当前语句结束时变成无主对象（dangling reference），因为没有地方存储指向它的指针以供后续释放。</span></span><br></pre></td></tr></table></figure>

<h4 id="动态多态原理"><a href="#动态多态原理" class="headerlink" title="动态多态原理"></a>动态多态原理</h4><h5 id="原理详解"><a href="#原理详解" class="headerlink" title="原理详解"></a>原理详解</h5><h6 id="向上类型转换及问题"><a href="#向上类型转换及问题" class="headerlink" title="向上类型转换及问题"></a>向上类型转换及问题</h6><p><em><strong>若上面代码未用虚函数，则运行结果如上图</strong></em></p>
<p><em><strong>问题抛出:</strong></em> 我们给Sleep函数传入的对象是dog和cat，输出的结果却是动物在睡觉。</p>
<p>把函数体与函数调用相联系称为<strong>绑定</strong>(捆绑，binding)</p>
<p><code>当绑定在程序运行之前(由编译器和连接器)完成时，称为**早绑定(early binding).**C语言中只有一种函数调用方式，就是早绑定。</code></p>
<p>上面的问题就是由于早绑定引起的，因为编译器在只有Animal地址时并不知道要调用的正确函数。编译<em><strong>是根据指向对象的指针或引用的类型</strong></em>来选择函数调用。这个时候由于sleep的参数类型是Animal&amp;,编译器确定了应该调用的sleep是Animal::sleep的，而不是真正传入的对象Dog::sleep。</p>
<hr>
<p><em><strong>分割线中小插曲</strong></em></p>
<blockquote>
<p>p.s.C++允许用父类的指针或引用指向子类的对象，但不强制类型转换的情况下，父类指针或引用是访问不到子类新增的成员的（编译器决定）</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> var;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClassA</span>:<span class="keyword">public</span> MyClass</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> varA;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">funA</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210121154910794.png" alt="image-20210121154910794" style="zoom:80%;" /><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210121155023822.png" alt="image-20210121155023822" style="zoom: 80%;" /></p>
<blockquote>
<p>任何妄图使用父类指针或引用想调用子类中的未覆盖父类的成员函数的行为均被编译器视为非法，但实际上可以通过指针的方式间接访问虚函数表来达到违反C++语义的行为</p>
</blockquote>
<hr>
<p>解决上面的问题的方法就是<strong>迟绑定</strong>(迟捆绑,动态绑定,运行时绑定，late binding),意味着绑定要根据对象的实际类型，发生在运行。</p>
<h6 id="迟绑定实现方案原理"><a href="#迟绑定实现方案原理" class="headerlink" title="迟绑定实现方案原理"></a>迟绑定实现方案原理</h6><p>对于特定的函数进行动态绑定，c++要求在基类中声明这个函数的时候使用virtual关键字,<strong>动态绑定也就对virtual函数起作用.</strong></p>
<ul>
<li>为创建一个需要动态绑定的虚成员函数，可以简单在这个函数声明前面加上virtual关键字，<strong>定义时候不需要</strong>.</li>
<li>如果一个函数在基类中被声明为virtual，那么在所有派生类中它都是virtual的.</li>
<li>在派生类中virtual函数的<strong>重定义</strong>称为<strong>重写</strong>(override).</li>
<li>Virtual关键字只能修饰成员函数.</li>
<li><strong>构造函数不能为虚函数</strong></li>
</ul>
<p><em><strong>注意：</strong></em>可以在派生类声明前使用关键字virtual(这也是无害的,建议加上,让人一看代码就知道这个函数是对父类函数进行重写的)</p>
<blockquote>
<p>首先，我们看看编译器如何处理虚函数。当编译器发现我们的类中有虚函数的时候，编译器会创建一张虚函数表，把虚函数的函数入口地址放到虚函数表中，并且在类中秘密增加一个指针，这个指针就是vpointer(缩写vptr)，这个指针是指向对象的虚函数表。在多态调用的时候，根据vptr指针，找到虚函数表来实现动态绑定。</p>
<p>在编译阶段，编译器秘密增加了一个vptr指针，但是此时vptr指针并没有初始化指向虚函数表(vtable),什么时候vptr才会指向虚函数表？在对象构建的时候，也就是在对象初始化调用构造函数的时候。编译器首先默认会在我们所编写的每一个构造函数中，增加一些vptr指针初始化的代码。如果没有提供构造函数，编译器会提供默认的构造函数，那么就会在默认构造函数里做此项工作，初始化vptr指针，使之指向本对象的虚函数表。</p>
<p>起初，子类继承基类，子类继承了基类的vptr指针，这个vptr指针是指向基类虚函数表，当子类调用构造函数，使得子类的vptr指针指向了子类的虚函数表。</p>
</blockquote>
<p>当子类无重写基类虚函数时:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps56.png" alt="img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps58.jpg" alt="img" style="zoom:67%;" /></p>
<p>当子类重写基类虚函数时:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps193.png" alt="img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps88.jpg" alt="img" style="zoom:67%;" /></p>
<p>没用虚函数的情况：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"> 	<span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;A \n&quot;</span>&lt;&lt;endl;&#125;   </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Test1</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;A1 \n&quot;</span>&lt;&lt;endl;&#125;   </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;B \n&quot;</span>&lt;&lt;endl;&#125;   </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Test1</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;B1 \n&quot;</span>&lt;&lt;endl;&#125;   </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fun</span><span class="params">(A* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p-&gt;<span class="built_in">Test1</span>();</span><br><span class="line">    <span class="comment">//mov ecx,[ebp+8]     //fun第一个参数（实际上是对象b的首地址）传进ecx作为this指针</span></span><br><span class="line">    <span class="comment">//call 08314B5h(A::Test1)    //因此调用的永远是A::Test1()</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    <span class="built_in">Fun</span>(&amp;b);<span class="comment">//传参：对象b的首地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用虚函数的情况：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"> 	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;A \n&quot;</span>&lt;&lt;endl;&#125;   </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Test1</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;A1 \n&quot;</span>&lt;&lt;endl;&#125;   </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;B \n&quot;</span>&lt;&lt;endl;&#125;   </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Test1</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;B1 \n&quot;</span>&lt;&lt;endl;&#125;   </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fun</span><span class="params">(A* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p-&gt;<span class="built_in">Test1</span>();</span><br><span class="line">    <span class="comment">//mov eax,dword ptr [ebp+8]  //将第一个参数（即b对象首地址）放进eax</span></span><br><span class="line">	<span class="comment">//mov edx,dword ptr [eax]    //将对象首地址指向的第一个成员（即b对应的虚函数表首地址）放进edx中</span></span><br><span class="line">	<span class="comment">//mov ecx,dword ptr [ebp+8]  //将b对象首地址放进ecx作为this指针</span></span><br><span class="line">	<span class="comment">//mov eax,dword ptr [edx+4]  //将虚函数表首地址+4中存的Test1()函数地址放进eax中</span></span><br><span class="line">	<span class="comment">//call eax  			    //所以调用的函数实现了运行时多态</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    <span class="built_in">Fun</span>(&amp;b);<span class="comment">//传参：对象b的首地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="内存布局详解"><a href="#内存布局详解" class="headerlink" title="内存布局详解"></a>内存布局详解</h4><ul>
<li>当父类写了虚函数后，类内部的结构发生了改变，多了<strong>vfptr（虚函数表指针），指向vftable（虚函数表）</strong></li>
<li>虚函数表内部记录着<strong>虚函数的入口地址</strong></li>
<li>当父类指针或引用指向子类对象，发生多态，调用的时候是从虚函数表中找函数入口地址</li>
</ul>
<p>加了虚函数指针后，内存布局：</p>
<p>上面运行多态</p>
<table>
<thead>
<tr>
<th align="center">类名</th>
<th align="center">对象内存布局</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Animal</td>
<td align="center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210120174254340.png" alt="image-20210120174254340"></td>
</tr>
<tr>
<td align="center">Cat</td>
<td align="center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210120174344137.png" alt="image-20210120174344137"></td>
</tr>
<tr>
<td align="center">Dog</td>
<td align="center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210120174326827.png" alt="image-20210120174326827"></td>
</tr>
</tbody></table>
<p>案例中用父类指针手动调用子类函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Dog d;</span><br><span class="line">Animal* p = &amp;d;</span><br><span class="line">((<span class="built_in">void</span>(*)())*(<span class="type">int</span>*)*(<span class="type">int</span>*)(p))();</span><br><span class="line"><span class="comment">//((void(*)())*(int*)*(int*)(&amp;d))();//一样</span></span><br><span class="line"><span class="comment">//***注意***函数指针也要必须调用约定一致才可成功，此处成功只是刚好一致而已。</span></span><br><span class="line"><span class="comment">//形如如下的指定了调用约定的函数指针变量</span></span><br><span class="line"><span class="comment">//int (__cdecl *pFun)(int,int);</span></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210120175133996.png" alt="image-20210120175133996"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210120175103635.png" alt="image-20210120175103635"></p>
<h5 id="单继承中虚函数"><a href="#单继承中虚函数" class="headerlink" title="单继承中虚函数"></a>单继承中虚函数</h5><p>在单继承形式下，子类的完全获得父类的虚函数表和数据。子类如果重写了父类的虚函数（如fun），就会把虚函数表原本fun对应的记录（内容MyClass::fun）覆盖为新的函数地址（内容MyClassA::fun），否则继续保持原本的函数地址记录。如果子类定义了新的虚函数，虚函数表内会追加一条记录，记录该函数的地址（如MyClassA::funA）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">sleep</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;动物在睡觉&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">play</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;动物在玩耍&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>:<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">sleep</span><span class="params">()</span><span class="comment">//重写父类函数</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;猫猫在睡觉&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span><span class="comment">//Cat新增的虚函数</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;猫猫在做某事&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">类名</th>
<th align="center">内存布局</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Animal</td>
<td align="center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210120222934600.png" alt="image-20210120222934600"></td>
</tr>
<tr>
<td align="center">Cat</td>
<td align="center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210120224045504.png" alt="image-20210120224045504"></td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass*pc=<span class="keyword">new</span> MyClassA;</span><br><span class="line">pc-&gt;<span class="built_in">fun</span>();<span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>编译器在处理第二条语句时，发现这是一个多态的调用，那么就会按照如下对虚函数的多态访问机制调用函数fun。<br>$$<br>*(this指针+调整量)<a href="">虚函数在vftable内的偏移</a><br>$$</p>
<h5 id="多重继承中的虚函数"><a href="#多重继承中的虚函数" class="headerlink" title="多重继承中的虚函数"></a>多重继承中的虚函数</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> var;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClassA</span>:<span class="keyword">public</span> MyClass</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> varA;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">funA</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClassB</span>:<span class="keyword">public</span> MyClass</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> varB;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">funB</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClassC</span> :<span class="keyword">public</span> MyClassB, <span class="keyword">public</span> MyClassA</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> varC;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">funB</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">funC</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>图解上面代码：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210120230828691.png" alt="image-20210120230828691" style="zoom:80%;" />

<p>MyClassC对象空间布局如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210120231043689.png" alt="image-20210120231043689" style="zoom:80%;" /><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210120231101348.png" alt="image-20210120231101348"></p>
<p><strong>【重点解读】</strong></p>
<p>和单重继承类似，多重继承时MyClassC会把<strong>所有的父类全部按序包含在自身内部</strong>。而且<strong>每一个父类都对应一个单独的虚函数表</strong>。</p>
<p><strong>多重继承下，子类不再具有自身的虚函数表，它的虚函数表与第一个父类的虚函数表合并了</strong>。同样的，如果子类重写了任意父类的虚函数，都会覆盖对应的函数地址记录。<strong>如果MyClassC重写了fun函数（两个父类都有该函数），那么两个虚函数表的记录都需要被覆盖</strong>！</p>
<hr>
<h5 id="多重继承中同时存在虚继承和虚函数"><a href="#多重继承中同时存在虚继承和虚函数" class="headerlink" title="多重继承中同时存在虚继承和虚函数"></a>多重继承中同时存在虚继承和虚函数</h5><p>上面案例修改为如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClassA</span>:<span class="keyword">virtual</span> <span class="keyword">public</span> MyClass</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClassB</span>:<span class="keyword">virtual</span> <span class="keyword">public</span> MyClass</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClassC</span>:<span class="keyword">public</span> MyClassA,<span class="keyword">public</span> MyClassB</span><br><span class="line"></span><br><span class="line"><span class="comment">//由于虚继承的本身语义，MyClassC内必须重写fun函数，因此我们需要再重写fun函数。</span></span><br></pre></td></tr></table></figure>

<p>虚继承的引入把对象的模型变得十分复杂，除了每个基类（MyClassA和MyClassB）和公共基类（MyClass）的虚函数表指针需要记录外，每个虚拟继承了MyClass的父类还需要记录一个虚基类表vbtable的指针vbptr。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210120233032009.png" alt="image-20210120233032009"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210120234600438.png" alt="image-20210120234600438"></p>
<p>虚基类表每项记录了<strong>被继承的虚基类子对象相对于虚基类表指针的偏移量</strong>。比如MyClassA的虚基类表第二项记录值为24，正是MyClass::vfptr相对于MyClassA::vbptr的偏移量，同理MyClassB的虚基类表第二项记录值12也正是MyClass::vfptr相对于MyClassA::vbptr的偏移量。</p>
<p>和虚函数表不同的是，<strong>虚基类表的第一项记录着当前子对象相对与虚基类表指针的偏移</strong>。MyClassA和MyClassB子对象内的虚表指针都是存储在相对于自身的4字节偏移处，因此该值是-4。假定MyClassA和MyClassC或者MyClassB内没有定义新的虚函数，即不会产生虚函数表，那么虚基类表第一项字段的值应该是0。</p>
<p>通过以上的对象组织形式，编译器解决了公共虚基类的多份拷贝的问题。通过每个父类的虚基类表指针，都能找到被公共使用的虚基类的子对象的位置，并依次访问虚基类子对象的数据。至于虚基类定义的虚函数，它和其他的虚函数的访问形式相同，本例中，如果使用虚基类指针MyClass*pc访问MyClassC对象的fun，将会被转化为如下形式：<br>$$<br>*(pc+28)<a href="">0</a><br>$$<br>通过以上的描述，我们基本认清了C++的对象模型。尤其是在多重、虚拟继承下的复杂结构。通过这些真实的例子，使得我们认清C++内class的本质</p>
<p>【注意】</p>
<p>指针的位置和基类成员在派生类成员中的内存布局是不确定的，也就是说标准里面没有规定int a必须要放在最后，只不过g++编译器的实现而已。<strong>c++标准大概只规定了这套机制的原理，至于具体的实现，比如各成员的排放顺序和优化，由各个编译器厂商自己定</strong></p>
<h6 id="多继承中的虚表内存布局"><a href="#多继承中的虚表内存布局" class="headerlink" title="多继承中的虚表内存布局"></a>多继承中的虚表内存布局</h6><ol>
<li>当有多个虚函数表时，虚函数表的结果是0，代表没有下一个虚函数表</li>
<li>非末尾的其他虚函数表由什么代表结束在不同操作系统中不一样，代表有下一个虚函数表</li>
<li>父类中没有，而子类中有的虚函数，都填入第一个虚函数表中</li>
</ol>
<p>【注意】vs在打印对象虚函数表的时候，只打印最上层基类声明的虚函数。</p>
<p>即，虚函数表显示不全，需要用监视或内存窗口手动显示虚表的所有内容</p>
<h4 id="多态的实际开发意义"><a href="#多态的实际开发意义" class="headerlink" title="多态的实际开发意义"></a>多态的实际开发意义</h4><ul>
<li>多态的好处<ol>
<li>代码可读性强</li>
<li>组织结构清晰</li>
<li>扩展性强</li>
</ol>
</li>
</ul>
<p>面向对象程序设计原则<strong>【开闭原则】</strong>：<strong>对扩展进行开放，对修改进行关闭</strong></p>
<p>解释：<strong>开闭原则</strong>含义是说一个软件实体应该通过扩展来实现变化，而不是通过修改已有的代码来实现变化的。</p>
<p>原因：没有修改底层模块，代码改变量少，可以有效的防止风险的扩散。</p>
<p>开闭原则实现方法就是<strong>多态</strong></p>
<ul>
<li>开闭原则的好处：<ol>
<li>提高复用性</li>
<li>提高维护性</li>
<li>提高拓展性</li>
</ol>
</li>
</ul>
<p>未采用开闭原则案例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Caculator</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setA</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mA = a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setB</span><span class="params">(<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mB = b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setOperator</span><span class="params">(string oper)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mOperator = oper;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;mOperator == <span class="string">&quot;+&quot;</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> mA + mB;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;mOperator == <span class="string">&quot;-&quot;</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> mA - mB;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;mOperator == <span class="string">&quot;*&quot;</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> mA * mB;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;mOperator == <span class="string">&quot;/&quot;</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> mA / mB;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> mA;</span><br><span class="line">	<span class="type">int</span> mB;</span><br><span class="line">	string mOperator;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这种程序不利于扩展，维护困难，如果修改功能或者扩展功能需要在源代码基础上修改</p>
<p>面向对象程序设计一个基本原则:开闭原则(对修改关闭，对扩展开放)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractCaculator</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setA</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mA = a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setB</span><span class="params">(<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mB = b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getResult</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> mA;</span><br><span class="line">	<span class="type">int</span> mB;</span><br><span class="line">	string mOperator;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PlusCaculator</span> : <span class="keyword">public</span> AbstractCaculator&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> mA + mB;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MinusCaculator</span> : <span class="keyword">public</span> AbstractCaculator&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> mA - mB;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//乘法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultipliesCaculator</span> : <span class="keyword">public</span> AbstractCaculator&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> mA * mB;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoBussiness</span><span class="params">(AbstractCaculator* caculator)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	caculator-&gt;<span class="built_in">setA</span>(a);</span><br><span class="line">	caculator-&gt;<span class="built_in">setB</span>(b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;计算结果：&quot;</span> &lt;&lt; caculator-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> caculator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多态的案例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cpu</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">work</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Gpu</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">work</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">work</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span></span><br><span class="line">&#123;</span><br><span class="line">	Cpu* cpu;</span><br><span class="line">	Gpu* gpu;</span><br><span class="line">	Memory* mem;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Computer</span>(Cpu* c, Gpu* g, Memory* m) :<span class="built_in">cpu</span>(c), <span class="built_in">gpu</span>(g), <span class="built_in">mem</span>(m)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cpu-&gt;<span class="built_in">work</span>();</span><br><span class="line">		gpu-&gt;<span class="built_in">work</span>();</span><br><span class="line">		mem-&gt;<span class="built_in">work</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Computer</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (cpu)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> cpu;</span><br><span class="line">			cpu = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (gpu)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> gpu;</span><br><span class="line">			gpu = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (mem)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> mem;</span><br><span class="line">			mem = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> 华硕cpu:<span class="keyword">public</span> Cpu</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;华硕处理器已就绪&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GTX1080</span>:<span class="keyword">public</span> Gpu</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;GTX1080显卡已就绪&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> 金士顿内存条 :<span class="keyword">public</span> Memory</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;金士顿内存条已就绪&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	华硕cpu* pcpu=<span class="keyword">new</span> 华硕cpu;</span><br><span class="line">	GTX1080* pgpu=<span class="keyword">new</span> GTX1080;</span><br><span class="line">	金士顿内存条* pmem=<span class="keyword">new</span> 金士顿内存条;</span><br><span class="line">	<span class="function">Computer <span class="title">myComputer</span><span class="params">(pcpu, pgpu, pmem)</span></span>;</span><br><span class="line">	myComputer.<span class="built_in">doWork</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h4><blockquote>
<p>在设计时，常常希望基类仅仅作为其派生类的一个接口。这就是说，仅想对基类进行向上类型转换，使用它的接口，而<strong>不希望用户实际的创建一个基类的对象</strong>。同时创建一个纯虚函数允许接口中放置成员原函数，而不一定要提供一段可能对这个函数毫无意义的代码。</p>
</blockquote>
<p>为了上面的目的，可以在基类中加入至少一个纯虚函数(pure virtual function),使得基类称为抽象类(abstract class).</p>
<ul>
<li><p>纯虚函数使用关键字virtual，并在其后面加上&#x3D;0。<strong>如果试图去实例化一个抽象类，编译器则会阻止这种操作。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> 返回类型 函数名()=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当<strong>继承一个抽象类的时候，必须实现所有的纯虚函数，否则由抽象类派生的类也是一个抽象类</strong>。</p>
</li>
<li><p>Virtual void fun() &#x3D; 0;告诉编译器在vftable中为函数保留一个位置，但在<strong>这个特定位置不放地址</strong>。</p>
</li>
</ul>
<p><strong>建立公共接口目的</strong>是为了将子类公共的操作抽象出来，可以<strong>通过一个公共接口来操纵一组类，且这个公共接口不需要事先实现</strong>(或者不需要完全实现)。</p>
<p>案例如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps25.jpg" alt="img"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象制作饮品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractDrinking</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//烧水</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//冲泡</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//倒入杯中</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//加入辅料</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//规定流程</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">MakeDrink</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">Boil</span>();</span><br><span class="line">		<span class="built_in">Brew</span>();</span><br><span class="line">		<span class="built_in">PourInCup</span>();</span><br><span class="line">		<span class="built_in">PutSomething</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//制作咖啡</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Coffee</span> : <span class="keyword">public</span> AbstractDrinking&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//烧水</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;煮农夫山泉!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//冲泡</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;冲泡咖啡!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//倒入杯中</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;将咖啡倒入杯中!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//加入辅料</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;加入牛奶!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//制作茶水</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tea</span> : <span class="keyword">public</span> AbstractDrinking&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//烧水</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;煮自来水!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//冲泡</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;冲泡茶叶!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//倒入杯中</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;将茶水倒入杯中!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//加入辅料</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;加入食盐!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//业务函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoBussiness</span><span class="params">(AbstractDrinking* drink)</span></span>&#123;</span><br><span class="line">	drink-&gt;<span class="built_in">MakeDrink</span>();</span><br><span class="line">	<span class="keyword">delete</span> drink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">DoBussiness</span>(<span class="keyword">new</span> Coffee);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">DoBussiness</span>(<span class="keyword">new</span> Tea);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="纯虚函数和多继承"><a href="#纯虚函数和多继承" class="headerlink" title="纯虚函数和多继承"></a>纯虚函数和多继承</h6><p>多继承带来了一些争议，但是接口继承可以说一种毫无争议的运用了。</p>
<p><strong>绝大数面向对象语言都不支持多继承，但是绝大数面向对象对象语言都支持接口的概念</strong>，c++中没有接口的概念，但是可以<strong>通过纯虚函数实现接口</strong>。<br>$$<br>不同点在于:接口类中只有函数原型定义，没有任何数据定义。<br>$$<br>多重继承接口不会带来二义性和复杂性问题。接口类只是一个功能声明，并不是功能实现，子类需要根据功能说明定义功能实现。</p>
<h6 id="只有纯虚函数的抽象类"><a href="#只有纯虚函数的抽象类" class="headerlink" title="只有纯虚函数的抽象类"></a>只有纯虚函数的抽象类</h6><p>其他语言中的<strong>接口</strong>实际上就是<strong>只有纯虚函数的抽象类</strong></p>
<p>这种格式的意义在于:</p>
<ol>
<li><p><strong>契约定义</strong></p>
<p>接口首先是一种契约，它定义了一个类必须实现哪些方法，但不关心这些方法的具体实现。<strong>这种契约的机制允许不同的类实现相同的接口，从而可以在不同的实现之间进行切换</strong>，而不影响使用这些类的代码。</p>
</li>
<li><p><strong>解耦</strong></p>
<p>接口是解耦合的强大工具。通过<strong>依赖于接口而不是具体的实现，我们可以改变具体的实现而不需要修改依赖于这些接口的代码</strong>。这对于构建易于测试、维护和扩展的系统尤为重要。</p>
</li>
<li><p><strong>多继承</strong></p>
<p>在很多面向对象的编程语言中，类只能从一个类继承（单继承），但是可以实现多个接口。这提供了一种形式的多继承，<strong>允许对象拥有来自多个源的行为</strong>。</p>
</li>
<li><p><strong>灵活性和可拓展性</strong></p>
<p>接口使得代码更加灵活和可拓展。例如，如果你的应用开始时使用的是一种算法或数据结构，随着应用的发展，你可能需要替换为更高效的实现。如果你的代码依赖于接口而不是具体的实现，这种替换会变得非常简单。</p>
</li>
<li><p><strong>接口与多态性</strong></p>
<p>关于多态性，虽然通过继承（包括抽象类和具体类的继承）也能实现多态性，但接口提供了另一种方式。接口<strong>允许不同的类共享同一个接口的定义，这意味着我们可以使用接口类型的引用来调用实现了该接口的任何类的实例的方法</strong>。</p>
<p>例如，考虑一个日志系统，你可能有多种方式来记录日志（文件、数据库、远程服务等）。如果所有这些日志记录器实现了同一个接口（比如ILogger），那么你可以在不同的记录器之间切换而不改变使用这些记录器的代码。这种灵活性是使用接口的直接好处。</p>
</li>
</ol>
<p>以一段csharp为例子看接口(只有纯虚函数的抽象类)的作用</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IHuntable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Hunt</span>(<span class="params">Animal a</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Tiger</span> : <span class="title">Animal</span>, <span class="title">IHuntable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Hunt</span>(<span class="params">Animal a</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 实现逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Snake</span> : <span class="title">Animal</span>, <span class="title">IHuntable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Hunt</span>(<span class="params">Animal a</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 实现逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，<code>Farmer</code>类中的<code>feedAnimal</code>方法可以接受任何实现了<code>IHuntable</code>接口的对象作为参数，这样就利用到了多态性：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">feedAnimal</span>(<span class="params">IHuntable ht, Animal a</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ht.Hunt(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见,接口能实现更灵活的多态</p>
<p>[[CSharp入门#对接口和抽象类的理解|实际开发中，经常会同时使用接口和抽象类。接口定义行为的契约，而抽象类提供部分实现]]</p>
<h4 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构"></a>虚析构和纯虚析构</h4><p><strong>虚析构函数和纯虚构函数</strong>都是为了解决<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/535539.htm">基类</a>的<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/159417.htm">指针</a>指向派生类对象，并用基类的指针删除派生类对象产生的“只调用了基类的析构函数而没有调用派生类的析构函数”的问题</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="comment">/* args */</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A 构造&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">A</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A 析构&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(<span class="comment">/* args */</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;B 构造&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">B</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;B 析构&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A *a = <span class="keyword">new</span> B;</span><br><span class="line">    <span class="keyword">delete</span> a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回结果为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A 构造</span><br><span class="line">B 构造</span><br><span class="line">A 析构</span><br><span class="line">//可见:只调用了基类的析构函数而没有调用派生类的析构函数</span><br></pre></td></tr></table></figure>

<p>如果在A的析构函数定义前加virtual,结果为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A 构造</span><br><span class="line">B 构造</span><br><span class="line">B 析构</span><br><span class="line">A 析构</span><br></pre></td></tr></table></figure>

<p><strong>纯虚析构函数</strong></p>
<p>纯虚析构函数在c++中是合法的，但是在使用的时候有一个额外的限制：<strong>必须在类外为纯虚析构函数提供一个函数体</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非纯虚析构函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">A</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A::~<span class="built_in">A</span>()&#123;&#125;<span class="comment">//类内与类外定义都行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//纯析构函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">B</span>() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">B::~<span class="built_in">B</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	A a; <span class="comment">//A类不是抽象类，可以实例化对象</span></span><br><span class="line">	B b; <span class="comment">//B类是抽象类，不可以实例化对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210121171549279.png" alt="image-20210121171549279"></p>
<p>如果类的目的不是为了实现多态作为基类来使用，就不要声明虚析构函数，反之，则应该为类声明虚析构函数。(原因如下)</p>
<blockquote>
<p>这是因为在使用继承和多态的情况下，如果一个基类指针指向一个派生类对象，并且通过基类指针删除该对象时，如果基类的析构函数不是虚函数，那么只会调用基类的析构函数，而不会调用派生类的析构函数。这可能导致派生类中的资源无法正确释放，从而引发内存泄漏或其他问题。</p>
<p>通过将基类的析构函数声明为虚函数，可以解决这个问题。当通过基类指针删除派生类对象时，会首先调用派生类的析构函数，然后再调用基类的析构函数，确保派生类中的资源得到正确释放。</p>
<p>因此，如果你的类可能会被继承，并且在使用多态时需要通过基类指针来删除对象，那么应该将析构函数声明为虚函数。这样可以确保在删除对象时调用正确的析构函数，避免资源泄漏和其他问题。</p>
<p>然而，如果你的类不会被继承或不会用于多态，那么声明虚析构函数可能会带来额外的开销。因此，在这种情况下，可以不声明虚析构函数。这样可以避免不必要的开销，并保持代码的简洁性。</p>
</blockquote>
<h4 id="重写-重载-重定义-区别"><a href="#重写-重载-重定义-区别" class="headerlink" title="重写 重载 重定义 区别"></a>重写 重载 重定义 区别</h4><ul>
<li>重载，同一作用域的同名函数<ol>
<li>同一个作用域</li>
<li>参数个数，参数顺序，参数类型不同</li>
<li>和函数返回值，没有关系</li>
<li>const也可以作为重载条件  &#x2F;&#x2F;do(const Teacher&amp; t){}  do(Teacher&amp; t)</li>
</ol>
</li>
<li>重定义（隐藏）<ol>
<li>有继承</li>
<li>子类（派生类）重新定义父类（基类）的同名成员（非virtual函数）</li>
<li>子类隐藏父类所有同名重载函数，可以用作用域显式调用</li>
</ol>
</li>
<li>重写（覆盖）<ol>
<li>有继承</li>
<li>子类（派生类）重写父类（基类）的virtual函数</li>
<li>函数返回值，函数名字，函数参数，必须和基类中的虚函数一致</li>
</ol>
</li>
</ul>
<h4 id="多态与别的语言的区别盘点"><a href="#多态与别的语言的区别盘点" class="headerlink" title="多态与别的语言的区别盘点"></a>多态与别的语言的区别盘点</h4><p>[[CSharp入门#CSharp与C++多态对比|CSharp与C++多态对比]]</p>
<h2 id="位域"><a href="#位域" class="headerlink" title="位域"></a>位域</h2><p>[[C语言入门#位域|C语言中的位域]]只能用于整型数据类型（如int、char等），而<strong>C++还支持对非整数类型的位域进行定义，如布尔类型、枚举类型等</strong>。</p>
<p>对齐规则的差异:</p>
<ul>
<li>在C语言中，位域的对齐规则是相对于结构体的起始位置，不同位域之间可能会进行位填充以满足对齐要求。</li>
<li>在C++中，位域的对齐规则是相对于前一个位域的结束位置，不会进行位填充，因此<strong>位域之间不会有空隙</strong>。</li>
</ul>
<p>C++既可以使用struct,也可以使用class</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++的位域案例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Flags</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">bool</span> flag1 : <span class="number">1</span>;</span><br><span class="line">    <span class="type">bool</span> flag2 : <span class="number">1</span>;</span><br><span class="line">    <span class="type">bool</span> flag3 : <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	Flags myFlags;</span><br><span class="line">    myFlags.flag1 = <span class="literal">true</span>;</span><br><span class="line">    myFlags.flag2 = <span class="literal">false</span>;</span><br><span class="line">    myFlags.flag3 = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Flag 1: &quot;</span> &lt;&lt; myFlags.flag1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Flag 2: &quot;</span> &lt;&lt; myFlags.flag2 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Flag 3: &quot;</span> &lt;&lt; myFlags.flag3 &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>模板参数列表中除了允许包含类型模板参数,也允许包含非类型模板参数，这些参数可以是整型（包括但不限于 <code>int</code>, <code>long</code>, <code>long long</code>, <code>unsigned</code> 及其对应的带符号整型）、枚举类型、指针或引用（到对象或函数），以及<code>std::nullptr_t</code>。对于整数类型，用户可以在模板实例化时传入一个整数常量表达式作为模板参数的值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">MyClass&lt;<span class="number">10</span>&gt; obj;  <span class="comment">// 正确：传入整数常量作为模板参数</span></span><br></pre></td></tr></table></figure>

<h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p>c++提供了函数模板(function template.)所谓函数模板，<em><strong>实际上是建立一个通用函数，其函数类型和形参类型不具体制定，用一个虚拟的类型来代表。这个通用函数就成为函数模板。</strong></em>凡是函数体相同的函数都可以用这个模板代替，不必定义多个函数，只需在模板中定义一次即可。在调用函数时系统会根据实参的类型来取代模板中的虚拟类型，从而实现不同函数的功能。</p>
<ul>
<li>c++提供两种模板机制:<em><strong>函数模板</strong></em>和<em><strong>类模板</strong></em></li>
</ul>
<p>$$<br>模板用于表达逻辑结构相同，但具体数据元素类型不同的数据对象的通用行为<br>$$</p>
<p>目的：<em><strong>用模板是为了实现泛型，可以减轻编程的工作量，增强函数的重用性。</strong></em></p>
<ul>
<li><p>格式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="comment">//上下两种完全一样，T是自定义通用数据类型名称</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>两种使用方式:</p>
<ol>
<li><strong>自动类型推导</strong>  —  通过参数必须要推导出一致的T才可以使用</li>
<li><strong>显示指定类型</strong>  —  mySwap&lt;int&gt;(a,b);</li>
</ol>
</li>
</ul>
<p>下面是实现对通用基本数据类型数组进行排序的案例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通用模板实现数据交换</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a,T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	T temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//模板实现通用类型快速排序方法(由小到大)</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(T array[], <span class="type">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> min = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i<span class="number">+1</span>; j &lt; length; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (array[j]&lt;array[min])</span><br><span class="line">			&#123;</span><br><span class="line">				min = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i!=min)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">mySwap</span>(array[i], array[min]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="函数模板和普通函数区别"><a href="#函数模板和普通函数区别" class="headerlink" title="函数模板和普通函数区别"></a>函数模板和普通函数区别</h4><ul>
<li>函数模板<strong>如果使用自动类型推导，是不可以发生隐式类型转换的</strong>，可以使用显示指定类型方式调用函数模板，此时可以发生隐式类型转换</li>
<li>普通函数，可以发生隐式类型转换</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">MyPlus</span><span class="params">(T a, T b)</span></span>&#123;</span><br><span class="line">	T ret = a + b;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MyPlus</span><span class="params">(<span class="type">int</span> a,<span class="type">char</span> b)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> ret = a + b;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">char</span> b = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//调用函数模板，严格匹配类型</span></span><br><span class="line">	<span class="built_in">MyPlus</span>(a, a);</span><br><span class="line">	<span class="built_in">MyPlus</span>(b, b);</span><br><span class="line">	<span class="comment">//调用普通函数</span></span><br><span class="line">	<span class="built_in">MyPlus</span>(a, b);</span><br><span class="line">	<span class="comment">//调用普通函数  普通函数可以隐式类型转换</span></span><br><span class="line">	<span class="built_in">MyPlus</span>(b, a);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//结论：</span></span><br><span class="line">	<span class="comment">//函数模板如果使用自动类型推导，不允许自动类型转换，必须严格匹配类型</span></span><br><span class="line">	<span class="comment">//普通函数可以进行自动类型转换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="函数模板和普通函数的调用规则"><a href="#函数模板和普通函数的调用规则" class="headerlink" title="函数模板和普通函数的调用规则"></a>函数模板和普通函数的调用规则</h4><ul>
<li><p>若函数模板和普通函数都可以调用，那么<strong>优先调用普通函数</strong>，若想强制调用函数模板，可以使用<strong>空模板</strong>参数列表</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myPrint&lt;&gt;(a,b);<span class="comment">//空模板</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数模板也可以发生重载（肯定呀，本质上就是编译器帮你把所有用到的各种类型都写了)</p>
</li>
<li><p>若函数模板<strong>能产生更好的匹配（不用隐式转换的情况），那么优先使用函数模板</strong></p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">MyPlus</span><span class="params">(T a, T b)</span></span>&#123;</span><br><span class="line">	T ret = a + b;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MyPlus</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> ret = a + b;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">	<span class="type">char</span> d = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">	<span class="comment">//如果函数模板和普通函数都能匹配，c++编译器优先考虑普通函数</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">MyPlus</span>(a, b) &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//如果我必须要调用函数模板,那么怎么办?</span></span><br><span class="line">	cout &lt;&lt; MyPlus&lt;&gt;(a, b) &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//此时普通函数也可以匹配，因为普通函数可以自动类型转换</span></span><br><span class="line">	<span class="comment">//但是此时函数模板能够有更好的匹配</span></span><br><span class="line">	<span class="comment">//如果函数模板可以产生一个更好的匹配，那么选择模板</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">MyPlus</span>(c,d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数模板重载</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">MyPlus</span><span class="params">(T a, T b, T c)</span></span>&#123;</span><br><span class="line">	T ret = a + b + c;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="type">int</span> c = <span class="number">30</span>;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">MyPlus</span>(a, b, c) &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//如果函数模板和普通函数都能匹配，c++编译器优先考虑普通函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="函数模板机制原理剖析"><a href="#函数模板机制原理剖析" class="headerlink" title="函数模板机制原理剖析"></a>函数模板机制原理剖析</h4><p><em><strong>函数模板机制结论：</strong></em></p>
<ul>
<li>编译器并不是把函数模板处理成能够处理任何类型的函数,只是基本数据类型</li>
<li>函数模板通过具体类型产生不同的函数</li>
<li><strong>两次编译，在声明的地方对模板代码本身进行编译(语法检测)，在调用的地方对参数替换后的代码进行编译（产生不同的函数）</strong>（这也就是模板的分文件特殊化的原因）</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yyxt/p/5090942.html">成员模板函数不能为虚函数，同时也不能有默认参数</a></p>
<h4 id="函数模板分文件编写"><a href="#函数模板分文件编写" class="headerlink" title="函数模板分文件编写"></a>函数模板分文件编写</h4><p>函数模板的分文件编写与类模板分文件编写一致，参考<a href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%88%86%E6%96%87%E4%BB%B6%E7%BC%96%E5%86%99">类模板的分文件编写章节</a></p>
<h4 id="函数模板特化"><a href="#函数模板特化" class="headerlink" title="函数模板特化"></a>函数模板特化</h4><p>也称为模板具体化</p>
<p>上面提到模板并不是真实的通用，对于自定义的数据类型，可以使用具体化技术，实现对自定义数据类型的特殊使用。</p>
<p>格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function"><span class="type">bool</span> <span class="title">myCompare</span><span class="params">(Person &amp;a,Person &amp;b)</span></span>;</span><br></pre></td></tr></table></figure>

<p>案例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	string mName;</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通交换函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T &amp;a,T &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	T temp = a;</span><br><span class="line">	a = b; </span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第三代具体化，显示具体化的原型和定意思以template&lt;&gt;开头，并通过名称来指出类型</span></span><br><span class="line"><span class="comment">//具体化优先于常规模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;<span class="type">void</span>  <span class="built_in">mySwap</span>&lt;Person&gt;(Person &amp;p1, Person &amp;p2)</span><br><span class="line">&#123;</span><br><span class="line">	string nameTemp;</span><br><span class="line">	<span class="type">int</span> ageTemp;</span><br><span class="line"></span><br><span class="line">	nameTemp = p<span class="number">1.</span>mName;</span><br><span class="line">	p<span class="number">1.</span>mName = p<span class="number">2.</span>mName;</span><br><span class="line">	p<span class="number">2.</span>mName = nameTemp;</span><br><span class="line"></span><br><span class="line">	ageTemp = p<span class="number">1.</span>mAge;</span><br><span class="line">	p<span class="number">1.</span>mAge = p<span class="number">2.</span>mAge;</span><br><span class="line">	p<span class="number">2.</span>mAge = ageTemp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数模板特化有两种形式：明确特化和部分特化。</p>
<p>明确特化是指为特定类型或参数提供完全不同的函数实现。它使用<code>template&lt;&gt;</code>语法来声明特化版本，并提供特定的实现。</p>
<p>下面是一个示例，展示了如何对函数模板进行明确特化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个函数模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Generic template: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 明确特化的实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">print</span>&lt;<span class="type">int</span>&gt;(<span class="type">int</span> value) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Specialized template for int: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们定义了一个函数模板<code>print</code>，它可以打印任意类型的值。然后，通过使用<code>template&lt;&gt;</code>语法，我们对<code>print&lt;int&gt;</code>进行了明确特化，为<code>int</code>类型提供了一个特殊的实现。</p>
<p>部分特化是指对函数模板的一部分参数进行特化。它使用模板参数的部分列表来匹配特定的实例，并提供特定的实现。</p>
<p>下面是一个示例，展示了如何对函数模板进行部分特化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个函数模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T value, U extra)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Generic template: &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; extra &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 部分特化的实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">print</span>&lt;T, <span class="type">int</span>&gt;(T value, <span class="type">int</span> extra) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Partial specialization for T and int: &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; extra &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们对<code>print&lt;T, int&gt;</code>进行了部分特化，为特定的参数组合提供了一个特殊的实现。</p>
<h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><ul>
<li><p>类模板和函数模板的区别</p>
<ol>
<li><p>类模板不可以使用自动类型推导，<strong>只能用显示指定类型</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person&lt;string,<span class="type">int</span>&gt; p;</span><br><span class="line"><span class="comment">//Person p;//错误</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>类模板中，<strong>可以有默认参数</strong>（函数模板不可以有）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">T2</span>=<span class="type">int</span>&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<p><strong>类模板中的成员函数，并不是一开始就创建的，而是在运行阶段确定出T的数据类型才去创建</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">doSomething1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;我是aa&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">doSomething2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我是bb&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T t;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		t.<span class="built_in">doSomething1</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		t.<span class="built_in">doSomething2</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Test&lt;BB&gt; t;</span><br><span class="line">	<span class="comment">//t.fun1();//有这句话才报错</span></span><br><span class="line">	t.<span class="built_in">fun2</span>();</span><br><span class="line">	Test&lt;AA&gt; t2;</span><br><span class="line">	t<span class="number">2.f</span>un1();</span><br><span class="line">	<span class="comment">//t2.fun2();//有这句话才报错</span></span><br><span class="line">    <span class="comment">//因此类模板中的成员函数，并不是一开始就创建的，而是在运行阶段确定出T的数据类型才去创建，此时有问题才报错。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类模板做函数参数"><a href="#类模板做函数参数" class="headerlink" title="类模板做函数参数"></a>类模板做函数参数</h4><ul>
<li>三种方式<ol>
<li><p>指定传入类型</p>
</li>
<li><p>参数模板化</p>
</li>
<li><p>整个类模板化</p>
</li>
</ol>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T1 t1;</span><br><span class="line">	T2 t2;</span><br><span class="line">	<span class="built_in">Test</span>(T1 t1,T2 t2)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;t1 = t1;</span><br><span class="line">		<span class="keyword">this</span>-&gt;t2 = t2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;T1类型为&quot;</span>&lt;&lt;<span class="built_in">typeid</span>(T1).<span class="built_in">name</span>()&lt;&lt; endl; <span class="comment">//typeid(T1).name()查看T1的数据类型	</span></span><br><span class="line">         cout &lt;&lt;<span class="string">&quot;T2类型为&quot;</span>&lt;&lt;<span class="built_in">typeid</span>(T2).<span class="built_in">name</span>() &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">(Test&lt;string,<span class="type">int</span>&gt; &amp;t)</span><span class="comment">//指定函数参数的传入类型，要求传入的参数必须是Test&lt;string,int&gt;类型</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;t1为&quot;</span>&lt;&lt;t.t1&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;t2为&quot;</span>&lt;&lt;t.t2&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;<span class="comment">//参数模板化，将参数模板化，可自动类型推导或显式指定类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">(Test&lt;T1, T2&gt; &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;t1为&quot;</span> &lt;&lt; t.t1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;t2为&quot;</span> &lt;&lt; t.t2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="comment">//将整个类模板化，可自动类型推导或显式指定类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun3</span><span class="params">(T &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;t1为&quot;</span> &lt;&lt; t.t1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;t2为&quot;</span> &lt;&lt; t.t2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Test &lt;string,<span class="type">int</span>&gt;<span class="built_in">test</span>(<span class="string">&quot;hello&quot;</span>, <span class="number">100</span>);</span><br><span class="line">	test.<span class="built_in">doWork</span>();</span><br><span class="line">	<span class="built_in">fun1</span>(test);</span><br><span class="line">    <span class="comment">//自动推导和类型转换</span></span><br><span class="line">	<span class="built_in">fun2</span>(test); <span class="comment">//fun2 &lt; string, int &gt;(test);</span></span><br><span class="line">	<span class="built_in">fun3</span>(test); <span class="comment">//fun3&lt;Test &lt;string, int&gt;&gt;(test);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类模板和派生"><a href="#类模板和派生" class="headerlink" title="类模板和派生"></a>类模板和派生</h4><p>两种情况如下：</p>
<h5 id="类模板派生普通类"><a href="#类模板派生普通类" class="headerlink" title="类模板派生普通类"></a>类模板派生普通类</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MyClass</span>(T property)&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mProperty = property;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T mProperty;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类实例化的时候需要具体化的父类，子类需要知道父类的具体类型是什么样的</span></span><br><span class="line"><span class="comment">//这样c++编译器才能知道给子类分配多少内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//普通派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass</span> : <span class="keyword">public</span> MyClass&lt;<span class="type">int</span>&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">SubClass</span>(<span class="type">int</span> b) : <span class="built_in">MyClass</span>&lt;<span class="type">int</span>&gt;(<span class="number">20</span>)&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mB = b;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> mB;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="类模板派生类模板"><a href="#类模板派生类模板" class="headerlink" title="类模板派生类模板"></a>类模板派生类模板</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">	T m;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>，<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child2</span> : <span class="keyword">public</span> Base&lt;T2&gt;  </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T mParam;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Child2&lt;<span class="type">int</span>&gt; d2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本质上是一样的。</p>
<h5 id="类模板中的成员函数类外实现"><a href="#类模板中的成员函数类外实现" class="headerlink" title="类模板中的成员函数类外实现"></a>类模板中的成员函数类外实现</h5><p>写法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(T1 name, T2 age);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T1 mName;</span><br><span class="line">	T2 mAge;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">直接这样写会报错，应该用下面写法，此时编译器并不知道具体是哪个类的该函数，因为要传this指针，所以必须知道实际上是什么类（模板类是一系列类的集合），因此必须指明</span></span><br><span class="line"><span class="comment">Person::Person(T1 name, T2 age)&#123;</span></span><br><span class="line"><span class="comment">	this-&gt;mName = name;</span></span><br><span class="line"><span class="comment">	this-&gt;mAge = age;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line">Person&lt;T1, T2&gt;::<span class="built_in">Person</span>(T1 name, T2 age)&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="type">void</span> Person&lt;T1, T2&gt;::<span class="built_in">showPerson</span>()&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;Obama&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中如果不按照这个格式写，会报错如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210128165130414.png" alt="image-20210128165130414" style="zoom: 80%;" /><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210128165515868.png" alt="image-20210128165515868" style="zoom:80%;" /></p>
<h5 id="类模板的分文件编写"><a href="#类模板的分文件编写" class="headerlink" title="类模板的分文件编写"></a>类模板的分文件编写</h5><p>类模板中的成员函数，不会一开始就创建，因此导致分文件编写时，连接不到函数的实现，出现<strong>无法解析的外部命令错误</strong>。</p>
<blockquote>
<p>[[qt]]编译器可以顺利通过编译并执行，但是在Linux和vs编辑器下如果只包含头文件，那么会报错链接错误，需要包含cpp文件，但是如果类模板中有友元类，那么编译失败！</p>
</blockquote>
<ul>
<li><p>原因：</p>
<ol>
<li>类模板需要二次编译，在出现模板的地方编译一次，在调用模板的地方再次编译</li>
<li>C++编译规则为独立编译（编译器编译源码 逐个编译单元编译的）</li>
</ol>
</li>
<li><p>两种解决方式：</p>
<ol>
<li>直接包含.cpp文件,实现和声明都放在一个文件中,就不用两个文件了（不推荐）</li>
<li>将.cpp文件后缀名改为.hpp(其实本质依旧是将类声明和实现写到同一个文件中)（调用的时候include的是hpp）(也可以用.cpp.impl后缀,虚幻引擎使用.inl后缀)</li>
</ol>
<p><strong>总之就是:模板的定义必须和声明放在同一个文件中</strong></p>
<p>更详细的流程可以参考<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/535308979">此知乎链接</a></p>
</li>
</ul>
<p><code>函数模板的分文件编写与类模板分文件编写一致</code></p>
<p>这也导致了 <strong>C++的模板库，基本是开源的</strong> </p>
<blockquote>
<p>如果库的用户不需要去产生这个模板的新的实例化类型，则可以在库内部的模板实现文件中对所有可能的类型进行显式实例化。如果库的用户有产生新的实例化类型的需求，则无法隐藏实现</p>
</blockquote>
<p>Person.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(T1 name,T2 age);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T1 mName;</span><br><span class="line">	T2 mAge;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Person.cpp&quot;</span><span class="comment">//！！！！！！！！</span></span></span><br></pre></td></tr></table></figure>

<p>Person.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line">Person&lt;T1, T2&gt;::<span class="built_in">Person</span>(T1 name, T2 age)&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="type">void</span> Person&lt;T1, T2&gt;::<span class="built_in">ShowPerson</span>()&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;Person.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//模板二次编译</span></span><br><span class="line"><span class="comment">//编译器编译源码 逐个编译单元编译的</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;Obama&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	p.<span class="built_in">ShowPerson</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="类模板和静态成员"><a href="#类模板和静态成员" class="headerlink" title="类模板和静态成员"></a>类模板和静态成员</h5><p>直接看案例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span> &gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TEST</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T a;</span><br><span class="line">	<span class="type">static</span> T b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span> &gt;</span><br><span class="line">T TEST&lt;T&gt;::b = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<h5 id="类模板中的友元函数"><a href="#类模板中的友元函数" class="headerlink" title="类模板中的友元函数"></a>类模板中的友元函数</h5><ol>
<li>友元函数在类中声明时，函数名后接&lt;&gt;表示函数模板要到类外找。</li>
<li>也可以友元函数直接写成函数模板</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//声明Person&lt;class T1, class T2&gt; ，方便2号位置的函数模板声明</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>;</span><br><span class="line"><span class="comment">//声明PrintPerson2&lt;class T1, class T2&gt;函数模板是存在，此处为2号位置</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt; </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintPerson2</span><span class="params">(Person&lt;T1, T2&gt;&amp; p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//友元函数在类内实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">	<span class="comment">//1. 友元函数在类内实现</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">PrintPerson</span><span class="params">(Person&lt;T1, T2&gt;&amp; p)</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; p.mName &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; p.mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.友元函数类外实现（此处并非友元函数模板，而是模板类中的友元函数）</span></span><br><span class="line">	<span class="comment">//告诉编译器这个函数模板是存在，此处为3号位置，之前的2号位置用于声明此处存在，编译器本来看到这里会去找普通的友元函数，因为他没有template，但因为有了空的&lt;&gt;，编译器看到才会去找下面的函数模板。</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="type">void</span> PrintPerson2&lt;&gt;(Person&lt;T1, T2&gt;&amp; p);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//3. 类模板碰到友元函数模板</span></span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> U1, <span class="keyword">class</span> U2&gt;</span></span><br><span class="line"><span class="function">	<span class="keyword">friend</span> <span class="type">void</span> <span class="title">PrintPerson</span><span class="params">(Person&lt;U1, U2&gt;&amp; p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(T1 name, T2 age)&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T1 mName;</span><br><span class="line">	T2 mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person &lt;string, <span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;Jerry&quot;</span>, <span class="number">20</span>);</span><br><span class="line">	<span class="built_in">PrintPerson</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板碰到友元函数</span></span><br><span class="line"><span class="comment">//友元函数类外实现  加上&lt;&gt;空参数列表，告诉编译去匹配函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1 , <span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintPerson2</span><span class="params">(Person&lt;T1, T2&gt;&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Name2:&quot;</span> &lt;&lt; p.mName &lt;&lt; <span class="string">&quot; Age2:&quot;</span> &lt;&lt; p.mAge &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数模板的方式</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1 , <span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintPerson</span><span class="params">(Person&lt;T1, T2&gt;&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; p.mName &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; p.mAge &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person &lt;string, <span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;Jerry&quot;</span>, <span class="number">20</span>);</span><br><span class="line">	<span class="built_in">PrintPerson2</span>(p);   <span class="comment">//不写可以编译通过，写了之后，会找PrintPerson2的普通函数调用，因为写了普通函数PrintPerson2的声明	</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设计一个动态数组模板类(MyArray),完成对不同类型元素的管理：（重点案例）(其中涉及到内存泄露检测)</p>
<h5 id="动态数组模板类"><a href="#动态数组模板类" class="headerlink" title="动态数组模板类"></a>动态数组模板类</h5><p><a href="#main%E6%96%87%E4%BB%B6main.cpp">内含检测堆是否释放完全的方法</a></p>
<h6 id="头文件dynamicArray-h"><a href="#头文件dynamicArray-h" class="headerlink" title="头文件dynamicArray.h"></a>头文件dynamicArray.h</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> New   new(_NORMAL_BLOCK, __FILE__, __LINE__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DynamicArray</span></span><br><span class="line">&#123;</span><br><span class="line">	T* pArray=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> mCapacity;</span><br><span class="line">	<span class="type">int</span> msize=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">DynamicArray</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">DynamicArray</span>(<span class="type">int</span> capacity);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">DynamicArray</span>(<span class="type">const</span> DynamicArray&lt;T&gt;&amp; dynamicArray);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">DynamicArray</span>(T* t, <span class="type">int</span> num);</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">DynamicArray</span>();</span><br><span class="line"></span><br><span class="line">	DynamicArray&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> DynamicArray&lt;T&gt;&amp; dynamicArray);</span><br><span class="line"></span><br><span class="line">	DynamicArray&lt;T&gt; <span class="keyword">operator</span>+(<span class="type">const</span> DynamicArray&lt;T&gt;&amp; dynamicArray);<span class="comment">//不改变原来的拼接</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;&lt;&gt;(ostream&amp; cout, <span class="type">const</span> DynamicArray&lt;T&gt;&amp; dynamicArray);</span><br><span class="line">	<span class="comment">//template&lt;class T&gt;//------------------------------------------------------------------------1</span></span><br><span class="line">	<span class="comment">//friend ostream&amp; operator&lt;&lt;(ostream&amp; cout, const DynamicArray&lt;T&gt;&amp; dynamicArray);//-----------2（写1,2行表示用函数模板的方式，这样也可以，就不用写&lt;&gt;了）</span></span><br><span class="line"></span><br><span class="line">	T&amp; <span class="keyword">operator</span>[](<span class="type">int</span> index);</span><br><span class="line"></span><br><span class="line">	<span class="function">DynamicArray&lt;T&gt;&amp; <span class="title">append_DynamicArray</span><span class="params">(<span class="type">const</span> DynamicArray&lt;T&gt; dynamicArray)</span></span>;<span class="comment">//改变原来的拼接</span></span><br><span class="line"></span><br><span class="line">	<span class="function">DynamicArray&lt;T&gt;&amp; <span class="title">insert_DynamicArray</span><span class="params">(<span class="type">int</span> pos,T data)</span></span>;<span class="comment">//插入</span></span><br><span class="line"></span><br><span class="line">	<span class="function">DynamicArray&lt;T&gt;&amp; <span class="title">delete_DynamicArray</span><span class="params">(<span class="type">int</span> pos)</span></span>;<span class="comment">//删除</span></span><br><span class="line"></span><br><span class="line">	<span class="function">DynamicArray&lt;T&gt;&amp; <span class="title">clear_DynamicArray</span><span class="params">()</span></span>;<span class="comment">//清空</span></span><br><span class="line"></span><br><span class="line">	<span class="function">DynamicArray&lt;T&gt;&amp; <span class="title">Push_back_DynamicArray</span><span class="params">(T data)</span></span>;<span class="comment">//数据推入栈顶</span></span><br><span class="line"></span><br><span class="line">	<span class="function">DynamicArray&lt;T&gt;&amp; <span class="title">Pop_back_DynamicArray</span><span class="params">()</span></span>;<span class="comment">//弹出栈顶数据</span></span><br><span class="line"></span><br><span class="line">	<span class="function">T&amp; <span class="title">Top_back_DynamicArray</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getLength</span><span class="params">()</span></span>;<span class="comment">//获取长度</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetCapacity</span><span class="params">()</span></span>;<span class="comment">//获取容量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h6 id="源文件dynamicArray-hpp"><a href="#源文件dynamicArray-hpp" class="headerlink" title="源文件dynamicArray.hpp"></a>源文件dynamicArray.hpp</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dynamicArray.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">DynamicArray&lt;T&gt;::<span class="built_in">DynamicArray</span>()</span><br><span class="line">&#123;</span><br><span class="line">	mCapacity = <span class="number">5</span>;</span><br><span class="line">	pArray = New T[mCapacity];</span><br><span class="line">	<span class="comment">//cout&lt;&lt;&quot;New一个&quot;&lt;&lt;pArray&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">DynamicArray&lt;T&gt;::<span class="built_in">DynamicArray</span>(<span class="type">int</span> capacity)</span><br><span class="line">&#123;</span><br><span class="line">	mCapacity = capacity;</span><br><span class="line">	pArray = New T[mCapacity];<span class="comment">// 如果T是对象，那么这个对象必须提供默认的构造函数</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;New一个&quot; &lt;&lt; pArray &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">DynamicArray&lt;T&gt;::<span class="built_in">DynamicArray</span>(<span class="type">const</span> DynamicArray&lt;T&gt;&amp; dynamicArray)</span><br><span class="line">&#123;</span><br><span class="line">	mCapacity = dynamicArray.mCapacity;</span><br><span class="line">	msize = dynamicArray.msize;</span><br><span class="line">	pArray = New T[mCapacity];</span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;New一个&quot; &lt;&lt; pArray &lt;&lt; endl;</span></span><br><span class="line">	<span class="built_in">memcpy</span>(pArray, dynamicArray.pArray, <span class="built_in">sizeof</span>(T)*mCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">DynamicArray&lt;T&gt;::<span class="built_in">DynamicArray</span>(T* t, <span class="type">int</span> num)</span><br><span class="line">&#123;</span><br><span class="line">	mCapacity = num;</span><br><span class="line">	msize = num;</span><br><span class="line">	pArray = New T[mCapacity];</span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;New一个&quot; &lt;&lt; pArray &lt;&lt; endl;</span></span><br><span class="line">	<span class="built_in">memcpy</span>(pArray, t, <span class="built_in">sizeof</span>(T)*mCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">DynamicArray&lt;T&gt;::~<span class="built_in">DynamicArray</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (pArray)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; &quot;delete一个&quot; &lt;&lt; pArray &lt;&lt; endl;</span></span><br><span class="line">		<span class="keyword">delete</span>[] pArray;</span><br><span class="line">		pArray = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">DynamicArray&lt;T&gt;&amp; DynamicArray&lt;T&gt;::<span class="keyword">operator</span>=(<span class="type">const</span> DynamicArray&lt;T&gt;&amp; dynamicArray)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//如果有原内存空间删除原内存空间</span></span><br><span class="line">	<span class="keyword">if</span> (pArray)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span>[] pArray;</span><br><span class="line">		pArray = <span class="literal">NULL</span>;<span class="comment">//是否有必要存疑</span></span><br><span class="line">	&#125;</span><br><span class="line">	mCapacity = dynamicArray.mCapacity;</span><br><span class="line">	pArray = New T[mCapacity];</span><br><span class="line">	<span class="comment">//cout &lt;&lt; sizeof(T)*mCapacity &lt;&lt; endl;</span></span><br><span class="line">	<span class="built_in">memcpy</span>(pArray, dynamicArray.pArray, <span class="built_in">sizeof</span>(T)*mCapacity);</span><br><span class="line">	msize = dynamicArray.msize;</span><br><span class="line">	<span class="keyword">return</span> (DynamicArray&lt;T&gt;&amp;)dynamicArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">DynamicArray&lt;T&gt; DynamicArray&lt;T&gt;::<span class="keyword">operator</span>+(<span class="type">const</span> DynamicArray&lt;T&gt;&amp; dynamicArray)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">DynamicArray&lt;T&gt; <span class="title">tmpArray</span><span class="params">(msize +dynamicArray.msize)</span></span>;</span><br><span class="line">	tmpArray.msize = msize + dynamicArray.msize;</span><br><span class="line">	<span class="built_in">memcpy</span>(tmpArray.pArray, pArray, <span class="built_in">sizeof</span>(T)*msize);</span><br><span class="line">	<span class="built_in">memcpy</span>(tmpArray.pArray+msize, dynamicArray.pArray, <span class="built_in">sizeof</span>(T)*dynamicArray.msize);</span><br><span class="line">	<span class="keyword">return</span> tmpArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T &amp; DynamicArray&lt;T&gt;::<span class="keyword">operator</span>[](<span class="type">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 在此处插入 return 语句</span></span><br><span class="line">	<span class="keyword">return</span> pArray[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">DynamicArray&lt;T&gt;&amp; DynamicArray&lt;T&gt;::<span class="built_in">append_DynamicArray</span>(<span class="type">const</span> DynamicArray&lt;T&gt; dynamicArray)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//查看容量是够足够拼接,不够的话就扩容</span></span><br><span class="line">	<span class="keyword">if</span> (mCapacity&lt;msize+dynamicArray.msize)</span><br><span class="line">	&#123;</span><br><span class="line">		mCapacity = msize + dynamicArray.msize;</span><br><span class="line">		T* oldpArray = pArray;</span><br><span class="line">		pArray = New T[mCapacity];</span><br><span class="line">		<span class="built_in">memcpy</span>(pArray, oldpArray, <span class="built_in">sizeof</span>(T)*msize);</span><br><span class="line">		<span class="keyword">delete</span>[] oldpArray;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memcpy</span>(pArray+msize, dynamicArray.pArray, <span class="built_in">sizeof</span>(T)*dynamicArray.msize);</span><br><span class="line">	msize += dynamicArray.msize;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">DynamicArray&lt;T&gt;&amp; DynamicArray&lt;T&gt;::<span class="built_in">insert_DynamicArray</span>(<span class="type">int</span> pos, T data)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (pos&gt;msize)</span><br><span class="line">	&#123;</span><br><span class="line">		pos = msize;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (pos&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		pos = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (msize==mCapacity)<span class="comment">//需要扩容</span></span><br><span class="line">	&#123;</span><br><span class="line">		mCapacity++;</span><br><span class="line">		T* oldPArray = pArray;</span><br><span class="line">		pArray = New T[mCapacity];</span><br><span class="line">		<span class="built_in">memcpy</span>(pArray,oldPArray,<span class="built_in">sizeof</span>(T)*pos);</span><br><span class="line">		pArray[pos] = data;</span><br><span class="line">		<span class="built_in">memcpy</span>(pArray + pos + <span class="number">1</span>, oldPArray + pos, <span class="built_in">sizeof</span>(T)*(msize - pos));</span><br><span class="line">		msize++;</span><br><span class="line">		<span class="keyword">delete</span>[] oldPArray;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memmove</span>(pArray+pos<span class="number">+1</span>, pArray+pos, <span class="built_in">sizeof</span>(T)*(msize - pos));</span><br><span class="line">		pArray[pos] = data;</span><br><span class="line">		msize++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">DynamicArray&lt;T&gt;&amp; DynamicArray&lt;T&gt;::<span class="built_in">delete_DynamicArray</span>(<span class="type">int</span> pos)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (pos &gt;= msize)</span><br><span class="line">	&#123;</span><br><span class="line">		pos = msize<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (pos &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		pos = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memmove</span>(pArray + pos, pArray + pos + <span class="number">1</span>,<span class="built_in">sizeof</span>(T)*(msize - pos - <span class="number">1</span>));<span class="comment">//memcpy不能处理重叠位置的挪移，要用memmove</span></span><br><span class="line">	msize--;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">DynamicArray&lt;T&gt;&amp; DynamicArray&lt;T&gt;::<span class="built_in">clear_DynamicArray</span>()</span><br><span class="line">&#123;</span><br><span class="line">	msize = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">DynamicArray&lt;T&gt;&amp; DynamicArray&lt;T&gt;::<span class="built_in">Push_back_DynamicArray</span>(T data)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (msize == mCapacity)<span class="comment">//需要扩容</span></span><br><span class="line">	&#123;</span><br><span class="line">		mCapacity++;</span><br><span class="line">		T* oldPArray = pArray;</span><br><span class="line">		pArray = New T[mCapacity];</span><br><span class="line">		<span class="built_in">memcpy</span>(pArray, oldPArray, <span class="built_in">sizeof</span>(T)*msize);</span><br><span class="line">		pArray[msize] = data;</span><br><span class="line">		msize++;</span><br><span class="line">		<span class="keyword">delete</span>[] oldPArray;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		pArray[msize] = data;</span><br><span class="line">		msize++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">DynamicArray&lt;T&gt;&amp; DynamicArray&lt;T&gt;::<span class="built_in">Pop_back_DynamicArray</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;msize == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	msize--;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T &amp; DynamicArray&lt;T&gt;::<span class="built_in">Top_back_DynamicArray</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> pArray[msize - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span> DynamicArray&lt;T&gt;::<span class="built_in">getLength</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> msize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span> DynamicArray&lt;T&gt;::<span class="built_in">GetCapacity</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> mCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, <span class="type">const</span> DynamicArray&lt;T&gt;&amp; dynamicArray)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dynamicArray.msize; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; dynamicArray.pArray[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="main文件main-cpp"><a href="#main文件main-cpp" class="headerlink" title="main文件main.cpp"></a>main文件main.cpp</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dynamicArray.hpp&quot;</span></span></span><br><span class="line"><span class="comment">//下面用于定位内存泄露位置</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> New   new(_NORMAL_BLOCK, __FILE__, __LINE__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRTDBG_MAP_ALLOC  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;crtdbg.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//用Person类来测试动态数组模板类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span>* mName;</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无参构造&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; endl; </span><br><span class="line">		mName = New <span class="type">char</span>[<span class="number">20</span>]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">		mAge = <span class="number">0</span>;</span><br><span class="line">	&#125;<span class="comment">//必须提供默认构造函数，才能供dynamicArray构造Person</span></span><br><span class="line">	~<span class="built_in">Person</span>()&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;析构&quot;</span>&lt;&lt;mName&lt;&lt;<span class="keyword">this</span>&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">if</span> (mName)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span>[] mName;</span><br><span class="line">			mName = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Person</span>(Person&amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		mName = New <span class="type">char</span>[<span class="number">20</span>]&#123; <span class="number">0</span> &#125;;</span><br><span class="line">		mAge=p.mAge ;</span><br><span class="line">		<span class="built_in">memcpy</span>(mName,p.mName,<span class="built_in">strlen</span>(p.mName)<span class="number">+1</span>);</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;拷贝构造&quot;</span>&lt;&lt;mName&lt;&lt;<span class="keyword">this</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	Person&amp; <span class="keyword">operator</span>=(Person&amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		mAge = p.mAge;</span><br><span class="line">		<span class="built_in">memcpy</span>(mName, p.mName, <span class="built_in">strlen</span>(p.mName) + <span class="number">1</span>);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;等于号赋值&quot;</span> &lt;&lt; mName &lt;&lt; <span class="keyword">this</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">char</span>* name,<span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		mName = New <span class="type">char</span>[<span class="number">20</span>]&#123; <span class="number">0</span> &#125;;</span><br><span class="line">		<span class="built_in">memcpy</span>(mName, name, <span class="built_in">strlen</span>(name)<span class="number">+1</span>);</span><br><span class="line">		mAge = age;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造&quot;</span> &lt;&lt; mName &lt;&lt; <span class="keyword">this</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, Person&amp; p)<span class="comment">//必须提供默认构造函数，才能供dynamicArray输出显示</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;年龄：&quot;</span> &lt;&lt; p.mAge &lt;&lt; <span class="string">&quot;  名称：&quot;</span> &lt;&lt; p.mName&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">return</span> cout;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">intDynamicArrayTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">5</span>] = &#123; <span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span> &#125;;</span><br><span class="line">	<span class="type">int</span> b[<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	<span class="function">DynamicArray&lt;<span class="type">int</span>&gt; <span class="title">dynamicArray</span><span class="params">(b, <span class="number">5</span>)</span></span>;</span><br><span class="line">	<span class="function">DynamicArray&lt;<span class="type">int</span>&gt; <span class="title">dynamicArray1</span><span class="params">(a, <span class="number">5</span>)</span></span>;</span><br><span class="line">	<span class="comment">//dynamicArray.insert_DynamicArray(10, 9).insert_DynamicArray(10, 10);</span></span><br><span class="line">	dynamicArray.<span class="built_in">delete_DynamicArray</span>(<span class="number">10</span>).<span class="built_in">delete_DynamicArray</span>(<span class="number">10</span>);</span><br><span class="line">	cout&lt;&lt; dynamicArray &lt;&lt;endl;</span><br><span class="line">	cout &lt;&lt; dynamicArray1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">personDynamicArrayTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;小明&quot;</span>, <span class="number">16</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;小黑&quot;</span>, <span class="number">22</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;小红&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;小白&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	DynamicArray&lt;Person&gt; dynamicArray;</span><br><span class="line">	cout &lt;&lt; dynamicArray &lt;&lt; endl;</span><br><span class="line">	<span class="comment">/*dynamicArray.insert_DynamicArray(0, p4);</span></span><br><span class="line"><span class="comment">	cout &lt;&lt; dynamicArray &lt;&lt; endl;*/</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">intDynamicArrayTest</span>();</span><br><span class="line">	<span class="built_in">personDynamicArrayTest</span>();</span><br><span class="line">	_CrtDumpMemoryLeaks();<span class="comment">//用于检测内存泄露，必须放在此处,开辟test函数的目的是为了当test函数执行完后，该释放的内存早该释放了，此时才可以在这里测试是否有内存泄露</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【重点】</strong>memmove用于拷贝字节，如果目标区域和源区域有重叠的话，memmove能够保证源串在被覆盖之前将重叠区域的字节拷贝到目标区域中，但复制后源内容会被更改。但是当目标区域与源区域没有重叠则和memcpy函数功能相同。</p>
<p><strong>【重点】</strong>（<strong>崩溃的调试定位问题技巧</strong>）崩溃的时候在弹出的对话框按相应按钮进入调试，按Alt+7键查看Call Stack即“调用堆栈”里面从上到下列出的对应从里层到外层的函数调用历史。双击某一行可将光标定位到此次调用的源代码或汇编指令处，看不懂时双击下一行，直到能看懂为止。</p>
<h4 id="类模板特化"><a href="#类模板特化" class="headerlink" title="类模板特化"></a>类模板特化</h4><p>模板特化是从C++98标准开始引入的特性，并在后续的C++标准中进行了一些改进和扩展。因此，无论是C++98、C++11、C++14、C++17还是C++20，都支持模板特化。</p>
<p>在C++中，你可以通过使用<code>template&lt;&gt;</code>语法来实现模板特化。下面是一个示例，展示了如何对一个类模板进行明确特化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个类模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;General template&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 明确特化的实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">int</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Specialized template for int&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们定义了一个类模板<code>MyClass</code>，并为其提供了一个通用的实现。然后，通过使用<code>template&lt;&gt;</code>语法，我们对<code>MyClass&lt;int&gt;</code>进行了明确特化，并提供了一个特定的实现。</p>
<p>你还可以进行部分特化，对模板的一部分参数进行特化。下面是一个示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个类模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;General template&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 部分特化的实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;T, <span class="type">int</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Partial specialization for T and int&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们对<code>MyClass&lt;T, int&gt;</code>进行了部分特化，为特定的参数组合提供了一个特殊的实现。</p>
<h3 id="模板模板参数"><a href="#模板模板参数" class="headerlink" title="模板模板参数"></a>模板模板参数</h3><p>模板模板参数（Template Template Parameters）是在C++98标准中引入的。这意味着从C++98开始，就可以使用模板模板参数来定义模板，将模板作为另一个模板的参数。</p>
<p>模板模板参数是C++中的一项强大的模板技术，它提供了更高级的模板编程能力，使得代码更加灵活和通用。它允许你以模板作为参数传递给其他模板，从而实现更复杂的泛型编程和模板元编程。</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="静态类型转换-static-cast"><a href="#静态类型转换-static-cast" class="headerlink" title="静态类型转换(static_cast)"></a>静态类型转换(static_cast)</h3><p>语法：static_cast&lt;目标变量&gt;(原变量&#x2F;原对象)</p>
<ol>
<li>允许内置数据类型转换</li>
<li>允许<strong>父子之间</strong>的指针或引用的转换(上行转换是安全的，下行转换是不安全的,但都允许)</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无继承关系指针转换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	Animal* animal01 = <span class="literal">NULL</span>;</span><br><span class="line">	Other* other01 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//转换失败</span></span><br><span class="line">	<span class="comment">//Animal* animal02 = static_cast&lt;Animal*&gt;(other01);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态类型转换-dynamic-cast"><a href="#动态类型转换-dynamic-cast" class="headerlink" title="动态类型转换(dynamic_cast)"></a>动态类型转换(dynamic_cast)</h3><p>语法：dynamic_cast&lt;目标变量&gt;(原变量&#x2F;原对象)</p>
<ol>
<li>不允许内置数据类型转换</li>
<li>允许<strong>父子之间</strong>指针或引用的<strong>上行转换</strong><ul>
<li>但若发生<strong>多态，总是安全的</strong>,下行转换在多态的情况下也可以用dynamic_cast转换</li>
</ul>
</li>
</ol>
<p>总结：将一切不安全的情况扼杀于萌芽</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承关系指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	Animal* animal01 = <span class="literal">NULL</span>;</span><br><span class="line">	Dog* dog01 = <span class="keyword">new</span> Dog;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//子类指针转换成父类指针 可以</span></span><br><span class="line">	Animal* animal02 = <span class="built_in">dynamic_cast</span>&lt;Animal*&gt;(dog01);</span><br><span class="line">	animal02-&gt;<span class="built_in">ShowName</span>();</span><br><span class="line">	<span class="comment">//父类指针转换成子类指针 不可以</span></span><br><span class="line">	<span class="comment">//Dog* dog02 = dynamic_cast&lt;Dog*&gt;(animal01);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//多态</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Animal* animal01 = <span class="keyword">new</span> Dog;<span class="comment">//Animal内含虚函数，并且Dog重写了Animal中那虚函数</span></span><br><span class="line">	<span class="comment">//父类指针转换成子类指针本不可以，但因为是多态，所以可以</span></span><br><span class="line">	Dog* dog01 = <span class="built_in">dynamic_cast</span>&lt;Dog*&gt;(animal01);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常量转换-const-cast"><a href="#常量转换-const-cast" class="headerlink" title="常量转换(const_cast)"></a>常量转换(const_cast)</h3><p>作用：<strong>该运算符用来修改指针或引用类型的const属性</strong></p>
<ol>
<li><strong>常量指针被转化成非常量指针</strong>或<strong>非常量指针被转化成常量指针</strong>，并且仍然指向原来的对象；</li>
<li><strong>常量引用被转换成非常量引用</strong>或<strong>非常量引用被转换成常量引用</strong>,并且仍然指向原来的对象；</li>
</ol>
<p>***注意:***不能直接对非指针和非引用的变量使用const_cast操作符去直接移除它的const.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常量指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span>* np = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(p);<span class="comment">//常量指针被转化成非常量指针</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>* pp = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span>* npp = <span class="built_in">const_cast</span>&lt;<span class="type">const</span> <span class="type">int</span>*&gt;(pp);<span class="comment">//非常量指针被转化成常量指针</span></span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;  <span class="comment">//不能对非指针或非引用进行转换</span></span><br><span class="line">	<span class="comment">//int b = const_cast&lt;int&gt;(a); &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常量引用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> &amp; refNum = num;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span>&amp; refNum2 = <span class="built_in">const_cast</span>&lt;<span class="type">const</span> <span class="type">int</span>&amp;&gt;(refNum);<span class="comment">//非常量引用被转换成常量引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="重新解释转换-reinterpret-cast"><a href="#重新解释转换-reinterpret-cast" class="headerlink" title="重新解释转换(reinterpret_cast)"></a>重新解释转换(reinterpret_cast)</h3><p>这是最不安全的一种转换机制，最有可能出问题，同时也最自由,<strong>什么都可以转</strong>。</p>
<p>理解：等同于C语言的强制类型转换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>;<span class="comment">//int转int*</span></span><br><span class="line"><span class="type">int</span>* p=<span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(a);</span><br><span class="line"></span><br><span class="line">Base* base=<span class="literal">NULL</span>;<span class="comment">//无继承关系指针转换</span></span><br><span class="line">Other* other=<span class="built_in">reinterpret_cast</span>&lt;Other*&gt;(base);</span><br></pre></td></tr></table></figure>

<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="异常的基本概念"><a href="#异常的基本概念" class="headerlink" title="异常的基本概念"></a>异常的基本概念</h3><blockquote>
<p>Bjarne Stroustrup说：提供异常的基本目的就是为了处理上面的问题。基本思想是：让一个函数在发现了自己无法处理的错误时抛出（throw）一个异常，然后它的（直接或者间接）调用者能够处理这个问题。也就是《C++ primer》中说的：将问题检测和问题处理相分离。 </p>
<p>一种思想：在所有支持异常处理的编程语言中（例如java），要认识到的一个思想：在异常处理过程中，由问题检测代码可以抛出一个对象给问题处理代码，通过这个对象的类型和内容，实际上完成了两个部分的通信，通信的内容是“出现了什么错误”。当然，各种语言对异常的具体实现有着或多或少的区别，但是这个通信的思想是不变的。</p>
</blockquote>
<p><em><strong>一句话：异常处理就是处理程序中的错误。所谓错误是指在程序运行的过程中发生的一些异常事件（如：除0溢出，数组下标越界，所要读取的文件不存在,空指针，内存不足等等）。</strong></em></p>
<ul>
<li><p>C语言中的异常处理(C++中仍然可以)</p>
<ol>
<li><p>使用整型的返回值标识错误</p>
</li>
<li><p>使用errno宏（可以简单的理解为一个全局整型变量）去记录错误。（可用perror输出）</p>
</li>
</ol>
</li>
<li><p>上述方法的两个缺陷</p>
<ol>
<li>返回值意义不一致问题，例如0表示错误还是1表示错误</li>
<li>函数的返回值只有一个，虽然可以通过指针或引用来返回另外的值，但这样就会令你的程序晦涩难懂</li>
</ol>
</li>
</ul>
<p><strong>异常的必要之处</strong></p>
<ul>
<li>部分函数使用异常更好处理，比如构造函数没有返回值，不方便使用错误码方式处理。比如<br>T&amp; operator这样的函数，如果pos越界了只能使用异常或者终止程序处理，没办法通过返回<br>值表示错误</li>
<li>很多的第三方库都包含异常，比如boost、gtest、gmock等等常用的库，那么我们使用它们<br>也需要使用异常</li>
</ul>
<h4 id="c-异常机制相比C语言异常处理的优势"><a href="#c-异常机制相比C语言异常处理的优势" class="headerlink" title="c++异常机制相比C语言异常处理的优势?"></a>c++异常机制相比C语言异常处理的优势?</h4><blockquote>
<p>C语言中没有内建的异常机制,类似于其他高级语言中的try-catch块。通常，C语言程序员会使用错误码或者返回值来处理异常情况</p>
</blockquote>
<ul>
<li>函数的返回值可以忽略，但<strong>异常不可忽略</strong>。如果程序出现异常，但是没有被捕获，程序就会终止，这多少会促使程序员开发出来的程序更健壮一点。而如果使用C语言的error宏或者函数返回值，调用者都有可能忘记检查，从而没有对错误进行处理，结果造成程序莫名其面的终止或出现错误的结果。</li>
<li>整型返回值没有任何语义信息。而异常却包含语义信息，有时你从类名就能够体现出来。</li>
<li>整型返回值缺乏相关的上下文信息。异常作为一个类，可以拥有自己的成员，这些成员就可以传递足够的信息。</li>
<li>异常处理可以在调用跳级。这是一个代码编写时的问题：假设在有多个函数的调用栈中出现了某个错误，<strong>使用整型返回码要求你在每一级函数中都要进行处理。而使用异常处理的栈展开机制，只需要在一处进行处理就可以了，不需要每级函数都处理</strong>。</li>
</ul>
<p>C异常机制缺陷案例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果判断返回值，那么返回值是错误码还是结果？</span></span><br><span class="line"><span class="comment">//如果不判断返回值，那么b==0时候，程序结果已经不正确</span></span><br><span class="line"><span class="comment">//A写的代码</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">A_MyDivide</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (b == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//B写的代码</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">B_MyDivide</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> ba = a + <span class="number">100</span>;</span><br><span class="line">	<span class="type">int</span> bb = b;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> ret = A_MyDivide(ba, bb);  <span class="comment">//由于B没有处理异常，导致B结果运算错误</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C写的代码</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">C_MyDivide</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> ret = B_MyDivide(a, b); <span class="comment">//更严重的是，由于B没有继续抛出异常，导致C的代码没有办法捕获异常</span></span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//所以,我们希望：</span></span><br><span class="line"><span class="comment">//1.异常应该捕获，如果你捕获，可以，那么异常必须继续抛给上层函数,你不处理，不代表你的上层不处理</span></span><br><span class="line"><span class="comment">//2.这个例子，异常没有捕获的结果就是运行结果错的一塌糊涂，结果未知，未知的结果程序没有必要执行下去</span></span><br></pre></td></tr></table></figure>

<p>异常的一直不处理,最终程序会终止,调用<code>std::terminate()</code>,该函数中默认调用<code>std::abort()</code>,最终中止程序运行</p>
<h3 id="异常基本语法"><a href="#异常基本语法" class="headerlink" title="异常基本语法"></a>异常基本语法</h3><p>异常的关键词：<strong>try    catch    throw</strong></p>
<ul>
<li>若有异常则通过throw操作创建一个异常对象或变量并抛出，<strong>throw类似return会结束当前函数</strong>。</li>
<li>将可能抛出异常的程序段放到try块之中。</li>
<li>catch如果想捕获其他类型，catch(…)</li>
<li>如果在try段执行期间没有引起异常，那么跟在try后面的catch字句就不会执行。</li>
<li>catch子句会根据出现的先后顺序被检查，匹配的catch语句捕获并处理异常(或继续抛出异常)</li>
<li>异常必须有函数进行处理，如果匹配的处理未找到，则运行函数terminate将自动被调用，其缺省功能调用abort终止程序。</li>
<li>处理不了的异常，可以在catch的最后一个分支，使用throw，向上抛。</li>
<li>异常可以是自定义类型</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">A_MyDivide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (b == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//B写的代码 B写代码比较粗心，忘记处理异常</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">B_MyDivide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> ba = a;</span><br><span class="line">	<span class="type">int</span> bb = b;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> ret = <span class="built_in">A_MyDivide</span>(ba, bb) + <span class="number">100</span>;  <span class="comment">//由于B没有处理异常，导致B结果运算错误</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C写的代码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C_MyDivide</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//没有处理异常，程序直接中断执行</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1 </span></span><br><span class="line">	ret = <span class="built_in">B_MyDivide</span>(a, b);</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理异常</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> </span></span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		ret = <span class="built_in">B_MyDivide</span>(a, b); <span class="comment">//更严重的是，由于B没有继续抛出异常，导致C的代码没有办法捕获异常</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (<span class="type">int</span> e)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;C_MyDivide Call B_MyDivide 除数为:&quot;</span> &lt;&lt; e &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">C_MyDivide</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>c++异常处理使得<strong>异常的引发和异常的处理不必在一个函数中</strong>，这样底层的函数可以着重解决具体问题，而不必过多的考虑异常的处理。<strong>上层调用者可以在适当的位置设计对不同类型异常的处理</strong>。</p>
<h4 id="异常严格类型匹配"><a href="#异常严格类型匹配" class="headerlink" title="异常严格类型匹配"></a>异常严格类型匹配</h4><p><em><strong>捕捉方式是通过严格类型匹配</strong></em>。(即不存在隐式类型转换)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span><span class="comment">//自定义异常</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printError</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;我自己的异常&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;开始抛出异常...&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//throw 10; //抛出int类型异常</span></span><br><span class="line">	<span class="comment">//throw &#x27;a&#x27;; //抛出char类型异常</span></span><br><span class="line">	<span class="comment">//throw &quot;abcd&quot;; //抛出char*类型异常</span></span><br><span class="line">    <span class="comment">//throw MyException();//抛出MyException的匿名对象</span></span><br><span class="line">	string ex = <span class="string">&quot;string exception!&quot;</span>;</span><br><span class="line">	<span class="keyword">throw</span> ex;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		<span class="built_in">TestFunction</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (<span class="type">int</span>)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;抛出Int类型异常!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (<span class="type">char</span>)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;抛出Char类型异常!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (<span class="type">char</span>*)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;抛出Char*类型异常!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">catch</span>(MyException e)<span class="comment">//捕获自定义异常对象</span></span><br><span class="line">    &#123;</span><br><span class="line">		e.<span class="built_in">printError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="built_in">catch</span> (string)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;抛出string类型异常!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//捕获所有异常</span></span><br><span class="line">	<span class="built_in">catch</span> (...)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;抛出其他类型异常!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="栈解旋-unwinding"><a href="#栈解旋-unwinding" class="headerlink" title="栈解旋(unwinding)"></a>栈解旋(unwinding)</h4><p>异常被抛出后，从进入try块起，到异常被抛掷前，这期间在栈上构造的所有对象，都会被自动析构。析构的顺序与构造的顺序相反，这一过程称为栈的解旋(unwinding).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name)&#123;</span><br><span class="line">		mName = name;</span><br><span class="line">		cout &lt;&lt; mName &lt;&lt; <span class="string">&quot;对象被创建!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Person</span>()&#123;</span><br><span class="line">		cout &lt;&lt; mName &lt;&lt; <span class="string">&quot;对象被析构!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string mName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//抛出异常</span></span><br><span class="line">	<span class="keyword">throw</span> <span class="number">10</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;此句未输出&quot;</span>&lt;&lt;endl;<span class="comment">//此句未输出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		<span class="built_in">TestFunction</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (...)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;异常被捕获!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210302140505545.png" alt="image-20210302140505545"></p>
<h3 id="异常接口声明"><a href="#异常接口声明" class="headerlink" title="异常接口声明"></a>异常接口声明</h3><ul>
<li><p>可以在函数声明中列出可能抛出异常的所有类型,即限定抛出异常的类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="title">throw</span><span class="params">(A,B,C)</span></span>;<span class="comment">//这个函数func能够且只能抛出类型A,B,C及其子类型的异常。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果在函数声明中没有包含异常接口声明，则此函数可以抛任何类型的异常</p>
</li>
<li><p>一个不抛任何类型异常的函数可声明为:void func() throw(),代表不允许抛出异常</p>
</li>
<li><p>如果一个函数抛出了它的异常接口声明所不允许抛出的异常,unexcepted函数会被调用，该函数默认行为调用terminate函数中断程序。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可抛出所有类型异常</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestFunction01</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只能抛出int char char*类型异常</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestFunction02</span><span class="params">()</span> <span class="title">throw</span><span class="params">(<span class="type">int</span>,<span class="type">char</span>,<span class="type">char</span>*)</span></span>&#123;</span><br><span class="line">	string exception = <span class="string">&quot;error!&quot;</span>;</span><br><span class="line">	<span class="keyword">throw</span> exception;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不能抛出任何类型异常</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestFunction03</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		<span class="comment">//TestFunction01();</span></span><br><span class="line">		<span class="comment">//TestFunction02();//运行中断，报错</span></span><br><span class="line">		<span class="comment">//TestFunction03();//运行中断，报错</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (...)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;捕获异常!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别在qt vs linux下做测试! </p>
<ul>
<li>Qt and Linux 正确!</li>
<li>vs2015接口声明不影响使用，但不能正常发挥限制异常抛出类型的作用</li>
</ul>
<h3 id="异常变量生命周期"><a href="#异常变量生命周期" class="headerlink" title="异常变量生命周期"></a>异常变量生命周期</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MyException</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;默认构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">MyException</span>(MyException&amp; e)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;拷贝构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">MyException</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;析构函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="built_in">MyException</span>();<span class="comment">//《《《修改位1》》》对应不同输出结果</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="built_in">TestFunction</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (MyException e) &#123;<span class="comment">//《《《修改位2》》》对应不同输出结果</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;异常被捕获!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;其他异常被捕获!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li><p>《修改位1》是throw MyException();      《修改位2》是 catch(MyException e);</p>
<p><strong>调用拷贝构造函数，效率低</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210302150222651.png" alt="image-20210302150222651"></p>
</li>
<li><p>《修改位1》是throw MyException();       《修改位2》是catch(MyException&amp; e);</p>
<p><strong>只调用默认构造函数，效率高，推荐</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210302150136700.png" alt="image-20210302150136700"></p>
</li>
<li><p>《修改位1》是throw &amp;MyException();       《修改位2》是catch(MyException* e);</p>
<p><strong>对象会提前释放掉，不能再非法操作</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210302150025665.png" alt="image-20210302150025665"></p>
<p>显然3的情况：在catch中调用e的函数会报错，因为MyException已被析构</p>
</li>
</ol>
<p><strong>总结，第二种方式才是正确的做法</strong></p>
<h3 id="异常的多态使用"><a href="#异常的多态使用" class="headerlink" title="异常的多态使用"></a>异常的多态使用</h3><ol>
<li>提供基类异常类BaseException，内含纯虚函数virtual void printError()&#x3D;0;</li>
<li>空指针异常类和越界异常类继承BaseException</li>
<li>重写virtual void printError()函数</li>
<li>测试：利用父类引用指向子类对象</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//越界异常</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OutOfRangeException</span> : <span class="keyword">public</span> BaseException&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">printError</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;越界异常!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">throw</span> <span class="built_in">NullPointerException</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		<span class="built_in">doWork</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (BaseException&amp; ex)&#123;</span><br><span class="line">		ex.<span class="built_in">printError</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异常原理"><a href="#异常原理" class="headerlink" title="异常原理"></a>异常原理</h3><p>[[C语言入门#栈区（stack）|函数调用解析参考]]</p>
<p>C语言的函数栈架构主要承载着以下几个部分：</p>
<ul>
<li>1、传递参数：通常，函数的调用参数总是在这个函数栈框架的最顶端。</li>
<li>2、传递返回地址：告诉被调用者的 return 语句应该 return 到哪里去，通常指向该函数调用的下一条语句（代码段中的偏移）。</li>
<li>3、存放调用者的当前栈指针：便于清理被调用者的所有局部变量、并恢复调用者的现场。</li>
<li>4、存放当前函数内的所有局部变量：所有局部和临时变量都是存储在栈上的。</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202410250910552.png" alt="在这里插入图片描述" style="zoom:67%;" />

<h4 id="使用了异常处理机制的C-函数调用"><a href="#使用了异常处理机制的C-函数调用" class="headerlink" title="使用了异常处理机制的C++函数调用"></a>使用了异常处理机制的C++函数调用</h4><p>首先澄清一点，这里说的 “C++ 函数”是指：</p>
<ul>
<li>该函数可能会直接或间接地抛出一个异常：即该函数的定义存放在一个 C++ 编译（而不是传统 C）单元内，并且该函数没有使用 “throw()” 异常过滤器。</li>
<li>该函数的定义内使用了 try 块。</li>
</ul>
<p>以上两者满足其一即可。为了能够成功地捕获异常和正确地完成栈回退（stack unwind），编译器必须要引入一些额外的数据结构和相应的处理机制。我们首先来看看引入了异常处理机制的栈框架大概是什么样子</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202410250916702.png" alt="在这里插入图片描述"></p>
<p>由上图可见，在每个 C++ 函数的栈框架中都多了一个 <strong>EXP 类型的结构体</strong>。进一步分析就会发现，这是一个典型的单向链表式结构</p>
<ul>
<li><code>piPrev</code> 成员指向链表的上一个节点，它主要用于在函数调用栈中逐级向上寻找匹配的 catch 块，并完成栈回退工作。</li>
<li><code>piHandler</code> 成员指向完成异常捕获和栈回退所必须的数据结构（主要是两张记载着关键数据的表：<strong>“try”块表</strong>：<code>tblTryBlocks</code> 及“<strong>栈回退表</strong>”：<code>tblUnwind</code>）。</li>
<li><code>nStep</code> 成员用来定位 try 块，以及在栈回退表中寻找正确的入口。</li>
</ul>
<p><strong>需要说明的是</strong>：<strong>编译器会为每一个 “C++ 函数”定义一个 EHDL 结构，不过只会为包含了 “try” 块的函数定义 tblTryBlocks 成员</strong>。此外，异常处理器还会为每个线程维护一个指向当前异常处理框架的指针。该指针指向异常处理器链表的链尾，通常存放在某个 TLS 槽（Thread-Local Storage Slot）或能起到类似作用的地方。</p>
<h4 id="栈回退（stack-unwind）"><a href="#栈回退（stack-unwind）" class="headerlink" title="栈回退（stack unwind）"></a>栈回退（stack unwind）</h4><p><strong>“栈回退”是伴随异常处理机制引入 C++ 中的一个新概念，主要用来确保在异常被抛出、捕获并处理后，所有生命期已结束的对象都会被正确地析构，它们所占用的空间会被正确地回收</strong>。下面描述编译器是如何实现栈回退机制的：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202410250937035.png" alt="在这里插入图片描述"></p>
<p>图中的 “FuncUnWind” 函数内，所有真实代码均以黑色和蓝色字体标示，编译器生成的代码则由灰色和橙色字体标明。此时，在图里给出的 nStep 变量和 tblUnwind 成员作用就十分明显了。</p>
<p><strong>nStep 变量用于跟踪函数内局部对象的构造、析构阶段。再配合编译器为每个函数生成的 tblUnwind 表，就可以完成退栈机制。</strong> 表中的 pfnDestroyer 字段记录了对应阶段应当执行的析构操作（析构函数指针）；pObj 字段则记录了与之相对应的对象 this 指针偏移。将 pObj 所指的偏移值加上当前栈框架基址（EBP），就是要代入 pfnDestroyer 所指析构函数的 this 指针，这样即可完成对该对象的析构工作。而 nNextIdx 字段则指向下一个需要析构对象所在的行（下标）。</p>
<p>在发生异常时，异常处理器首先检查当前函数栈框架内的 nStep 值，并通过 piHandler 取得 tblUnwind[] 表。然后将 nStep 作为下标带入表中，执行该行定义的析构操作，然后转向由 nNextIdx 指向的下一行，直到 nNextIdx 为 -1 为止。在当前函数的栈回退工作结束后，异常处理器可沿当前函数栈框架内 piPrev 的值回溯到异常处理链中的上一节点重复上述操作，直到所有回退工作完成为止。</p>
<p>值得一提的是，<strong>nStep 的值完全在编译时决定</strong>，运行时仅需执行若干次简单的整形立即数赋值（通常是直接赋值给CPU里的某个寄存器）。此外，对于所有内部类型以及使用了默认构造、析构方法（并且它的所有成员和基类也使用了默认方法）的类型，其创建和销毁均不影响 nStep 的值。</p>
<blockquote>
<p><strong>栈回退的触发</strong>：当发生异常且没有立即捕获时，C++ 会启动栈回退过程（stack unwinding）。栈回退会逐层销毁当前作用域中的对象（调用这些对象的析构函数），以确保资源得到释放。</p>
<p><strong>析构函数在栈回退中的执行</strong>：在栈回退过程中，对象的析构函数会被调用。如果析构函数抛出异常，就会与原始异常相冲突，因为此时已经有一个异常正在传播。</p>
<p><strong>异常处理机制的限制</strong>：C++ 的异常处理机制无法同时处理两个异常，所以如果在栈回退（异常传播）过程中析构函数再抛出新的异常，就会导致“异常中的异常”问题，这会调用 <code>std::terminate()</code> 并结束程序。</p>
<p>析构函数处理异常:</p>
<ul>
<li><strong>析构函数不应主动抛出异常</strong>：在 C++ 中，<strong>析构函数的一个核心原则是“不抛异常”</strong>。如果析构函数中的代码可能会抛出异常，应该尽量用 try-catch 捕获，并在必要时记录日志，而不是将异常传播到析构函数外。</li>
<li><strong>在特殊情况下使用</strong> std::uncaught_exceptions()：如果析构函数确实执行了可能引发异常的复杂操作（例如文件操作、资源释放等），此时可以使用 [[C++11与14#uncaught_exceptions|C++17引入的std::uncaught_exceptions()]] 来检测当前是否存在未捕获的异常，以决定是否抑制抛出新的异常。</li>
</ul>
</blockquote>
<h4 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h4><p>一个异常被抛出时,就会立即引发C++的异常捕获机制</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202410281014841.png" alt="异常捕获机制"></p>
<p>在上一小节中，我们已经看到了 nStep 变量在跟踪对象构造、析构方面的作用。实际上 nStep 除了能够跟踪对象创建、销毁阶段以外，还能够标识当前执行点是否在 try 块中，以及（如果当前函数有多个 try 块的话）究竟在哪个 try 块中。这是通过在每一个 try 块的入口和出口各为 nStep 赋予一个唯一 ID 值，并确保 nStep 在对应 try 块内的变化恰在此范围之内来实现的。</p>
<p>在具体实现异常捕获时，首先，C++ 异常处理器检查发生异常的位置是否在当前函数的某个 try 块之内。这项工作可以通过将当前函数的 nStep 值依次在 piHandler 指向 tblTryBlocks[] 表的条目中进行范围为 [nBeginStep, nEndStep) 的比对来完成。</p>
<p>例如：上图中的 FuncB 在 nStep &#x3D;&#x3D; 2 时发生了异常，则通过比对 FuncB 的 tblTryBlocks[] 表发现 2∈[1, 3)，故该异常发生在 FuncB 内的第一个 try 块中。其次，如果异常发生的位置在当前函数中的某个 try 块内，则尝试匹配该 tblTryBlocks[] 相应条目中的 tblCatchBlocks[] 表。tblCatchBlocks[] 表中记录了与指定 try 块配套出现的所有 catch 块相关信息，包括这个 catch 块所能捕获的异常类型及其起始地址等信息。若找到了一个匹配的 catch 块，则复制当前异常对象到此 catch 块，然后跳转到其入口地址执行块内代码。否则，则说明异常发生位置不在当前函数的 try 块内，或者这个 try 块中没有与当前异常相匹配的 catch 块，此时则沿着函数栈框架中 piPrev 所指地址（即：异常处理链中的上一个节点）逐级重复以上过程，直至找到一个匹配的 catch 块或到达异常处理链的首节点。对于后者，我们称为发生了<strong>未捕获的异常</strong>，对于 C++ 异常处理器而言，未捕获的异常是一个严重错误，将导致当前进程被强制结束。</p>
<h4 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202410281020212.png" alt="异常的抛出"></p>
<p>在编译一段 C++ 代码时，编译器会将所有 throw 语句替换为其 C++ 运行时库中的某一指定函数，这里我们叫它 <strong>__CxxRTThrowExp</strong>（与本文提到的所有其它数据结构和属性名一样，在实际应用中它可以是任意名称）。该函数接收一个编译器认可的内部结构（我们叫它 EXCEPTION 结构）。这个结构中包含了待抛出异常对象的起始地址、用于销毁它的析构函数，以及它的 type_info 信息。对于没有启用 RTTI 机制（编译器禁用了 RTTI 机制或没有在类层次结构中使用虚表）的异常类层次结构，可能还要包含其所有基类的 type_info 信息，以便与相应的 catch 块进行匹配。</p>
<p>在图中的深灰色框图内，我们使用 C++ 伪代码展示了函数 FuncA 中的 “throw myExp(1);” 语句将被编译器最终翻译成的样子。实际上在多数情况下，__CxxRTThrowExp 函数即我们前面曾多次提到的“异常处理器”，异常捕获和栈回退等各项重要工作都由它来完成。__CxxRTThrowExp 首先接收（并保存）EXCEPTION 对象；然后从 TLS：Current ExpHdl 处找到与当前函数对应的 piHandler、nStep 等异常处理相关数据；并按照前文所述的机制完成异常捕获和栈回退。由此完成了包括“抛出”-&gt;“捕获”-&gt;“回退”等步骤的整套异常处理机制。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>程序在抛出异常后，则通过当前的 ExpHdl 获得 piHandle，该结构体中记录着栈回退表和 try 语句块的信息，首先去 try 语句块中寻找匹配的 catch 语句块，如果没有找到则进行进行栈回退到上一层的函数，重复这个过程直到找到匹配的 catch 语句块，如果一直到达异常处理链的顶点都没有找到，则强制结束进程。当然也有可能在当前的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%A0%88%E5%B8%A7&spm=1001.2101.3001.7020">栈帧</a>中就没有 try 语句块，那就直接进行栈回退去匹配 catch 语句块</p>
<h4 id="Windows中的结构化异常处理"><a href="#Windows中的结构化异常处理" class="headerlink" title="Windows中的结构化异常处理"></a>Windows中的结构化异常处理</h4><p>Microsoft Windows 带有一种名为“结构化异常处理”的机制，非常著名的“内存访问违例”出错对话框就是该机制的一种体现。Windows 结构化异常处理与前文讨论的 C++ 异常处理机制有惊人的相似之处，同样使用类似的链式结构实现。对于 Windows 下的应用程序，只需使用 <code>SetUnhandledExceptionFilter API</code> 注册异常处理器；用 <code>FS:[0]</code> 替代前文所述的 <code>TLS: Current ExpHdl</code> 等很少的改动，即可将此两种错误处理机制合而为一。这样做的优势十分明显：</p>
<ul>
<li>由于可直接借助操作系统提供的机制，所以简化了 C++ 异常处理器的实现。</li>
<li>使“<code>catch (...)</code>” 块得以捕获操作系统产生的异常（如：“内存访问违例”等等）。</li>
<li>使操作系统的异常处理机制能够捕获所有 C++ 异常。</li>
</ul>
<p>实际上，大多数 Windows 下的 C++ 编译器的异常机制均使用这种方式实现。</p>
<h4 id="开销分析"><a href="#开销分析" class="headerlink" title="开销分析"></a>开销分析</h4><p>了解其某一特性的实现原理主要是为了避免错误地使用该特性。要达到这个目的，还要在了解实现原理的基础上进行一些额外的开销分析工作：</p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>时间开销</strong></th>
<th><strong>空间开销</strong></th>
</tr>
</thead>
<tbody><tr>
<td>EHDL</td>
<td>无运行时开销</td>
<td>每“C++函数”一个 EHDL 对象，其中的 tblTryBlocks[] 成员仅在函数中包含至少一个 try 块时使用。典型情况下小于 64 字节。</td>
</tr>
<tr>
<td>C++栈框架</td>
<td>极高的 O(1) 效率，每次调用时进行3次额外的整形赋值和一次 TLS 访问。</td>
<td>每 调用两个指针和一个整形开销。典型情况下小于 16 字节。</td>
</tr>
<tr>
<td>step 跟踪</td>
<td>极高的 O(1) 效率每次进出 try 块或对象构造&#x2F;析构一次整形立即数赋值。</td>
<td>无（已记入 C++ 栈框架中的相应项目）。</td>
</tr>
<tr>
<td>异常的抛出、捕获和栈回退</td>
<td>异常的抛出是一次 O(1) 级操作。在单个函数中进行捕获和栈回退也均为 O(1) 操作。但异常捕获的总体成本为 O(m)，其中 m 等于当前函数调用栈中，从抛出异常的位置到达匹配 catch 块之间所经过的函数调用中，包含 try 块（即：定义了有效 tblTryBlocks[]）的函数个数。栈回退的总成本为 O(n)，其中 n 等于当前函数调用栈中，从抛出异常的位置到达匹配 catch 块之间所经过的函数调用数。</td>
<td>在异常处理结束前，需保存异常对象及其析构函数指针和相应的 type_info 信息。具体根据对象尺寸、编译器选项（是否开启 RTTI）及异常捕获器的参数传递方式（传值或传址）等因素有较大变化。典型情况下小于 256 字节。</td>
</tr>
</tbody></table>
<p>可以看出，在没有抛出异常时，C++ 的异常处理机制是十分有效的。在有异常被抛出后，可能会依当前函数调用栈的情形进行若干次整形比较（try块表匹配）操作，但这通常不会超过几十次。对于大多数 15 年前的 CPU 来说，整形比较也只需 1 时钟周期，所以异常捕获的效率还是很高的。栈回退的效率则与 return 语句基本相当。</p>
<p>考虑到即使是传统的函数调用、错误处理和逐级返回机制也不是没有代价的。这些开销在绝大多数情形下仍可以接受。空间开销方面，每“C++ 函数”一个 EHDL 结构体的引入在某些极端情形下会明显增加目标文件尺寸和内存开销。但是典型情况下，它们的影响并不大，但也没有小到可以完全忽略的程度。如果正在为一个资源严格受限的环境开发应用程序，你可能需要考虑关闭异常处理和 RTTI 机制以节约存储空间。</p>
<p>以上讨论的是一种典型的异常机制的实现方式，各具体编译器厂商可能有自己的优化和改进方案，但总体的出入不会很大。</p>
<h3 id="C-标准异常库"><a href="#C-标准异常库" class="headerlink" title="C++标准异常库"></a>C++标准异常库</h3><h4 id="标准库介绍"><a href="#标准库介绍" class="headerlink" title="标准库介绍"></a>标准库介绍</h4><p>标准库中也提供了很多的异常类，它们是通过类继承组织起来的。异常类继承层级结构图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps21.jpg" alt="img"></p>
<p><code>每个类所在的头文件在图下方标识出来。(颜色对应其头文件)</code></p>
<p><em><strong>标准异常类的成员：</strong></em></p>
<ol>
<li>在上述继承体系中，每个类都有提供了构造函数、复制构造函数、和赋值操作符重载。</li>
<li>logic_error类及其子类、runtime_error类及其子类，它们的构造函数是接受一个string类型的形式参数，用于异常信息的描述</li>
<li>所有的异常类都有一个what()方法，返回const char* 类型（C风格字符串）的值，描述异常信息。</li>
</ol>
<p><em><strong>标准异常类的具体描述：</strong></em></p>
<table>
<thead>
<tr>
<th>异常名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>exception</td>
<td>所有标准异常类的父类</td>
</tr>
<tr>
<td>bad_alloc</td>
<td>当operator new and operator new[]，请求分配内存失败时</td>
</tr>
<tr>
<td>bad_exception</td>
<td>这是个特殊的异常，如果函数的异常抛出列表里声明了bad_exception异常，当函数内部抛出了异常抛出列表中没有的异常，这是调用的unexpected函数中若抛出异常，不论什么类型，都会被替换为bad_exception类型</td>
</tr>
<tr>
<td>bad_typeid</td>
<td>使用typeid操作符，操作一个NULL指针，而该指针是带有虚函数的类，这时抛出bad_typeid异常</td>
</tr>
<tr>
<td>bad_cast</td>
<td>使用dynamic_cast转换引用失败的时候</td>
</tr>
<tr>
<td>ios_base::failure</td>
<td>io操作过程出现错误</td>
</tr>
<tr>
<td>logic_error</td>
<td>逻辑错误，可以在运行前检测的错误</td>
</tr>
<tr>
<td>runtime_error</td>
<td>运行时错误，仅在运行时才可以检测的错误</td>
</tr>
</tbody></table>
<p><em><strong>logic_error的子类：</strong></em></p>
<table>
<thead>
<tr>
<th>异常名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>length_error</td>
<td>试图生成一个超出该类型最大长度的对象时，例如vector的resize操作</td>
</tr>
<tr>
<td>domain_error</td>
<td>参数的值域错误，主要用在数学函数中。例如使用一个负值调用只能操作非负数的函数</td>
</tr>
<tr>
<td>out_of_range</td>
<td>超出有效范围</td>
</tr>
<tr>
<td>invalid_argument</td>
<td>参数不合适。在标准库中，当利用string对象构造bitset时，而string中的字符不是’0’或’1’的时候，抛出该异常</td>
</tr>
</tbody></table>
<p><em><strong>runtime_error的子类：</strong></em></p>
<table>
<thead>
<tr>
<th>异常名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>range_error</td>
<td>计算结果超出了有意义的值域范围</td>
</tr>
<tr>
<td>overflow_error</td>
<td>算术计算上溢</td>
</tr>
<tr>
<td>underflow_error</td>
<td>算术计算下溢</td>
</tr>
<tr>
<td>invalid_argument</td>
<td>参数不合适。在标准库中，当利用string对象构造bitset时，而string中的字符不是’0’或’1’的时候，抛出该异常</td>
</tr>
</tbody></table>
<p>案例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age)&#123;</span><br><span class="line">		<span class="keyword">if</span> (age &lt; <span class="number">0</span> || age &gt; <span class="number">150</span>)&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;年龄应该在0-150岁之间!&quot;</span>);<span class="comment">//实际使用的时候，往往是不需要自己抛异常的，比如STL容器会自动抛异常，开发者只需要处理异常就可以了</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		<span class="function">Person <span class="title">p</span><span class="params">(<span class="number">151</span>)</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (out_of_range&amp; ex)&#123;</span><br><span class="line">		cout &lt;&lt; ex.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="编写自己的异常类"><a href="#编写自己的异常类" class="headerlink" title="编写自己的异常类"></a>编写自己的异常类</h4><ol>
<li>标准库中的异常是有限的；</li>
<li>在自己的异常类中，可以添加自己的信息。（标准库中的异常类值允许设置一个用来描述异常的字符串）。</li>
</ol>
<h5 id="如何编写自己的异常类？"><a href="#如何编写自己的异常类？" class="headerlink" title="如何编写自己的异常类？"></a>如何编写自己的异常类？</h5><ol>
<li><strong>建议自己的异常类要继承标准异常类</strong>。因为C++中可以抛出任何类型的异常，所以我们的异常类可以不继承自标准异常，但是这样可能会导致程序混乱，尤其是当我们多人协同开发时。</li>
<li>当继承标准异常类时，<strong>应该重载父类的what函数和虚析构函数</strong>。</li>
<li>因为栈展开的过程中，要复制异常类型，那么要根据你在类中添加的成员考虑是否提供自己的复制构造函数。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义异常类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyOutOfRange</span>:<span class="keyword">public</span> exception</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MyOutOfRange</span>(<span class="type">const</span> string  errorInfo)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Error = errorInfo;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">MyOutOfRange</span>(<span class="type">const</span> <span class="type">char</span> * errorInfo)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">//const char*可以隐式类型转换为string，反之不可以</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Error =  errorInfo;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">virtual</span>  ~<span class="built_in">MyOutOfRange</span>()</span><br><span class="line">	&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span> *  <span class="title">what</span><span class="params">()</span> <span class="type">const</span><span class="comment">//基类中有这个const，则重写时候必须写const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        <span class="comment">//string转换为const char*，用c_str()函数</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_Error.<span class="built_in">c_str</span>() ;</span><br><span class="line">	&#125;</span><br><span class="line">	string m_Error;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (age &lt;= <span class="number">0</span> || age &gt; <span class="number">150</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//抛出异常 越界</span></span><br><span class="line">			<span class="comment">//cout &lt;&lt; &quot;越界&quot; &lt;&lt; endl;</span></span><br><span class="line">			<span class="comment">//throw  out_of_range(&quot;年龄必须在0~150之间&quot;);</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//throw length_error(&quot;长度异常&quot;);</span></span><br><span class="line">			<span class="keyword">throw</span> <span class="built_in">MyOutOfRange</span>((<span class="string">&quot;我的异常 年龄必须在0~150之间&quot;</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">try</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">Person <span class="title">p</span><span class="params">(<span class="number">151</span>)</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> ( out_of_range &amp; e )</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (length_error &amp; e)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (MyOutOfRange e)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Function-try-block"><a href="#Function-try-block" class="headerlink" title="Function-try-block"></a>Function-try-block</h3><p>围绕函数体建立异常处理程序</p>
<p>是一种 <em>函数体</em> 的替代语法形式，是<a target="_blank" rel="noopener" href="https://www.apiref.com/cpp-zh/cpp/language/function.html">函数定义</a>的一部分。</p>
<blockquote>
<p>它的行为比较复杂，对于普通函数和构造函数析构函数在到达catch-block结尾时候的行为不太一致，可以认为是比较坑的。</p>
<p>函数 try 块的主要目的是<strong>应对从构造函数中的成员初始化器列表抛出的异常</strong>，进行记录并重抛，修改异常对象并重抛，抛出一个不同的异常，或终止程序。它们很少为析构函数或常规函数所用。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span></span><br><span class="line">&#123;</span><br><span class="line">    std::string m;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">S</span>(<span class="type">const</span> std::string&amp; str, <span class="type">int</span> idx)</span><br><span class="line">    <span class="keyword">try</span> : <span class="built_in">m</span>(str, idx)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;S(&quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; idx &lt;&lt; <span class="string">&quot;) constructed, m = &quot;</span> &lt;&lt; m &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(<span class="type">const</span> std::exception&amp; e)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;S(&quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; idx &lt;&lt; <span class="string">&quot;) failed: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125; <span class="comment">// 这里为构造函数隐式  &quot;throw;&quot;         到达析构函数上函数 try 块的 catch 子句的末尾也会自动重新抛出当前异常，就像 throw; 一样，但允许使用 return 语句。</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S s1&#123;<span class="string">&quot;ABC&quot;</span>, <span class="number">1</span>&#125;; <span class="comment">// 不抛出异常（索引在边界内）</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        S s2&#123;<span class="string">&quot;ABC&quot;</span>, <span class="number">4</span>&#125;; <span class="comment">// 抛出异常（越界）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (std::exception&amp; e)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;S s2... raised an exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在进入<strong>任何构造函数上的函数 try 块的 catch 子句</strong>前，所有完整构造的成员和基类都会被销毁。</p>
<p>如果构造函数或析构函数上使用的函数 try 块的 catch 子句访问对象的基类或非静态成员，则行为未定义。</p>
<h3 id="异常安全"><a href="#异常安全" class="headerlink" title="异常安全"></a>异常安全</h3><p>什么是异常安全的函数,需要满足下面两条:</p>
<ul>
<li>不泄露任何资源</li>
<li>不允许数据结构遭到损坏</li>
</ul>
<p>面对构造和析构:</p>
<ul>
<li><strong>构造函数提供强异常保证</strong>：确保构造函数要么成功完成创建对象，要么失败后不影响程序状态（强异常保证）</li>
<li><strong>析构函数提供无失败保证</strong>：确保析构函数不会抛出异常，以保证资源安全地释放。(最稳妥是使用 [[C++11与14#noexcept]] 修饰析构函数)</li>
</ul>
<blockquote>
<p>局部<strong>异常处理的思想</strong>重点在于:<br><strong>抛出异常的合理性</strong>：构造函数中若遇到无法恢复的错误（如内存不足），应抛出异常；但对于非关键性错误（如一些简单的参数错误），可以考虑通过其他手段处理，减少异常的传播成本。</p>
</blockquote>
<h2 id="C-输入和输出流"><a href="#C-输入和输出流" class="headerlink" title="C++输入和输出流"></a>C++输入和输出流</h2><h3 id="流的概念和流类库的结构"><a href="#流的概念和流类库的结构" class="headerlink" title="流的概念和流类库的结构"></a>流的概念和流类库的结构</h3><p>程序的输入指的是从输入文件将数据传送给程序，程序的输出指的是从程序将数据传送给输出文件。</p>
<p>C++输入输出包含以下三个方面的内容：</p>
<ol>
<li><p>对系统指定的标准设备的输入和输出。即从键盘输入数据，输出到显示器屏幕。这种输入输出称为标准的输入输出，简称标准I&#x2F;O。</p>
</li>
<li><p>以外存磁盘文件为对象进行输入和输出，即从磁盘文件输入数据，数据输出到磁盘文件。以外存文件为对象的输入输出称为文件的输入输出，简称文件I&#x2F;O。</p>
</li>
<li><p>对内存中指定的空间进行输入和输出。通常指定一个字符数组作为存储空间(实际上可以利用该空间存储任何信息)。这种输入和输出称为字符串输入输出，简称串I&#x2F;O。</p>
<p>​	</p>
<p>C++编译系统提供了用于输入输出的iostream类库。iostream这个单词是由3个部 分组成的，即i-o-stream，意为输入输出流。在iostream类库中包含许多用于输入输出的 类。常用的见表</p>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps54.jpg" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps86.jpg" alt="img"></p>
<p>ios是抽象基类，由它派生出istream类和ostream类，两个类名中第1个字母i和o分别代表输入(input)和输出(output)。 istream类支持输入操作，ostream类支持输出操作， iostream类支持输入输出操作。iostream类是从istream类和ostream类通过多重继承而派生的类。其继承层次见上图表示。</p>
<p>C++对文件的输入输出需要用ifstrcam和ofstream类，两个类名中第1个字母i和o分别代表输入和输出，第2个字母f代表文件 (file)。ifstream支持对文件的输入操作， ofstream支持对文件的输出操作。类ifstream继承了类istream，类ofstream继承了类ostream，类fstream继承了 类iostream。见图 </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps117.jpg" alt="img"></p>
<p>I&#x2F;O类库中还有其他一些类，但是对于一般用户来说，以上这些已能满足需要了。</p>
<h3 id="与iostream类库有关的头文件"><a href="#与iostream类库有关的头文件" class="headerlink" title="与iostream类库有关的头文件"></a>与iostream类库有关的头文件</h3><p>iostream类库中不同的类的声明被放在不同的头文件中，用户在自己的程序中用#include命令包含了有关的头文件就相当于在本程序中声明了所需 要用到的类。可以换 —种说法：头文件是程序与类库的接口，iostream类库的接口分别由不同的头文件来实现。常用的有</p>
<ul>
<li>iostream  包含了对输入输出流进行操作所需的基本信息。</li>
<li>fstream  用于用户管理的文件的I&#x2F;O操作。</li>
<li>strstream  用于字符串流I&#x2F;O。</li>
<li>stdiostream  用于混合使用C和C + +的I&#x2F;O机制时，例如想将C程序转变为C++程序。</li>
<li>iomanip  在使用格式化I&#x2F;O时应包含此头文件。</li>
</ul>
<h3 id="在iostream头文件中定义的流对象"><a href="#在iostream头文件中定义的流对象" class="headerlink" title="在iostream头文件中定义的流对象"></a>在iostream头文件中定义的流对象</h3><p>在 iostream 头文件中定义的类有 ios，istream，ostream，iostream，istream 等。</p>
<p>在iostream头文件中不仅定义了有关的类，还定义了4种流对象，</p>
<table>
<thead>
<tr>
<th><em><strong>对象</strong></em></th>
<th><em><strong>含义</strong></em></th>
<th><em><strong>对应设备</strong></em></th>
<th><em><strong>对应的类</strong></em></th>
<th><em><strong>c语言中相应的标准文件</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td>cin</td>
<td>标准输入流</td>
<td>键盘</td>
<td>istream_withassign</td>
<td>stdin</td>
</tr>
<tr>
<td>cout</td>
<td>标准输出流</td>
<td>屏幕</td>
<td>ostream_withassign</td>
<td>stdout</td>
</tr>
<tr>
<td>cerr</td>
<td>标准错误流</td>
<td>屏幕</td>
<td>ostream_withassign</td>
<td>stderr</td>
</tr>
<tr>
<td>clog</td>
<td>标准日志流</td>
<td>屏幕</td>
<td>ostream_withassign</td>
<td>stderr</td>
</tr>
</tbody></table>
<p>在iostream头文件中定义以上4个流对象用以下的形式（以cout为例）：<br>  ostream cout ( stdout);<br>    在定义cout为ostream流类对象时，把标准输出设备stdout作为参数，这样它就与标准输出设备(显示器)联系起来，如果有<br>  cout &lt;&lt;3;<br>就会在显示器的屏幕上输出3。</p>
<h5 id="在iostream头文件中重载运算符"><a href="#在iostream头文件中重载运算符" class="headerlink" title="在iostream头文件中重载运算符"></a><strong>在iostream头文件中重载运算符</strong></h5><p>“&lt;&lt;”和“&gt;&gt;”本来在C++中是被定义为左位移运算符和右位移运算符的，由于在iostream头文件中对它们进行了重载， 使它们能用作标准类型数据的输入和输出运算符。所以，在用它们的程序中必须用#include命令把iostream包含到程序中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br></pre></td></tr></table></figure>

<ol>
<li>&gt;&gt;a表示将数据放入a对象中。</li>
<li>&lt;&lt;a表示将a对象中存储的数据拿出。</li>
</ol>
<h3 id="标准I-O流"><a href="#标准I-O流" class="headerlink" title="标准I&#x2F;O流"></a>标准I&#x2F;O流</h3><p>标准I&#x2F;O对象:cin，cout，cerr，clog</p>
<h4 id="cout流对象"><a href="#cout流对象" class="headerlink" title="cout流对象"></a>cout流对象</h4><p>cout是console output的缩写，意为在控制台（终端显示器）的输出。强调几点。</p>
<ol>
<li><p>cout不是C++预定义的关键字，它是ostream流类的对象，在iostream中定义。 顾名思义，流是流动的数据，cout流是流向显示器的数据。cout流中的数据是用流插入运算符“&lt;&lt;”顺序加入的。如果有:<br> cout&lt;&lt;”I “&lt;&lt;”study C++ “&lt;&lt;”very hard. &lt;&lt; “hello world !”;</p>
<p> 按顺序将字符串”I “, “study C++ “, “very hard.”插人到cout流中，cout就将它们送到显示器，在显示器上输出字符串”I study C++ very hard.”。cout流是容纳数据的载体，它并不是一个运算符。人们关心的是cout流中的内容，也就是向显示器输出什么。</p>
</li>
<li><p>用“cout&lt;&lt;”输出基本类型的数据时，可以不必考虑数据是什么类型，系统会判断数据的类型，并根据其类型选择调用与之匹配的运算符重载函数。这个过程都是自动的，用户不必干预。如果在C语言中用prinf函数输出不同类型的数据，必须分别指定相应的输出格式符，十分麻烦，而且容易出错。C++的I&#x2F;O机制对用户来说，显然是方便而安全的。</p>
</li>
<li><p>cout流在内存中对应开辟了一个缓冲区，用来存放流中的数据，当向cout流插人一个endl时，不论缓冲区是否已满，都立即输出流中所有数据，然后插入一个换行符， 并刷新流（清空缓冲区）。注意如果插人一个换行符”\n“（如cout&lt;&lt;a&lt;&lt;”\n”），则只输出和换行，而不刷新cout 流(但并不是所有编译系统都体现出这一区别）。</p>
</li>
<li><p>在iostream中只对”&lt;&lt;”和”&gt;&gt;”运算符用于标准类型数据的输入输出进行了重载，但未对用户声明的类型数据的输入输出进行重载。如果用户声明了新的类型，并希望用”&lt;&lt;”和”&gt;&gt;”运算符对其进行输入输出，按照重运算符重载来做。</p>
</li>
</ol>
<h4 id="cerr流对象"><a href="#cerr流对象" class="headerlink" title="cerr流对象"></a>cerr流对象</h4><p><strong>cerr流对象是标准错误流，cerr流已被指定为与显示器关联</strong>。cerr的 作用是向标准错误设备(standard error device)输出有关出错信息。cerr与标准输出流cout的作用和用法差不多。但有一点不同：cout流通常是传送到显示器输出，但也可以被重定向输出到磁盘文件，而cerr流中的信息只能在显示器输出。当调试程序时，往往不希望程序运行时的出错信息被送到其他文件，而要求在显示器上及时输出，这时 应该用cerr。cerr流中的信息是用户根据需要指定的。</p>
<h4 id="clog流对象"><a href="#clog流对象" class="headerlink" title="clog流对象"></a>clog流对象</h4><p>clog流对象也是标准日志流，它是console log的缩写。它的作用和cerr相同，都是在终端显示器上显示出错误信息。区别：cerr是不经过缓冲区，直接向显示器上输出有关信息，而clog中的信息存放在缓冲区中，缓冲区满后或遇endl时向显示器输出。</p>
<p><strong>缓冲区的概念:</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps20.jpg" alt="img"></p>
<h3 id="标准输入流"><a href="#标准输入流" class="headerlink" title="标准输入流"></a>标准输入流</h3><p>标准输入流对象cin，重点掌握的函数</p>
<ul>
<li>cin.get() &#x2F;&#x2F;一次只能读取一个字符</li>
<li>cin.get(一个参数) &#x2F;&#x2F;读一个字符</li>
<li>cin.get(两个参数) &#x2F;&#x2F;可以读字符串</li>
<li>cin.getline()&#x2F;&#x2F;读字符串</li>
<li>cin.ignore()&#x2F;&#x2F;忽略，默认忽略1个，若填入参数n代表忽略n个字符</li>
<li>cin.peek()&#x2F;&#x2F;偷窥，从缓冲区只看不取</li>
<li>cin.putback()&#x2F;&#x2F;放回，放回缓冲区队列头</li>
<li>cin.fail()&#x2F;&#x2F;标志位</li>
<li>cin.clear()&#x2F;&#x2F;标志位复位为0(用来更改cin的状态标示符的)</li>
<li>cin.sync()&#x2F;&#x2F;用来清除缓存区的数据流(vs2015环境下不能使用，尽量用cin.ignore替代)</li>
</ul>
<p><strong>【重点注意】cin.clear和cin.fail的区别</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="type">int</span> a;</span><br><span class="line"> cout&lt;&lt;<span class="string">&quot;输入一个字母:&quot;</span>&lt;&lt;endl;</span><br><span class="line"> cin&gt;&gt;a;  <span class="comment">//int型变量中放了char型数据,failbit置1</span></span><br><span class="line"> cout&lt;&lt;<span class="string">&quot;cin.fail()=&quot;</span>&lt;&lt;cin.<span class="built_in">fail</span>()&lt;&lt;endl;    <span class="comment">//输出1</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//cin.clear();</span></span><br><span class="line"> <span class="comment">//cin.sync();</span></span><br><span class="line"> cout&lt;&lt;<span class="string">&quot;输入一个数字:&quot;</span>&lt;&lt;endl;    <span class="comment">//由于failbit值为1,输入流不能正常工作</span></span><br><span class="line"> cin&gt;&gt;a;                         <span class="comment">//故此处的输入无效</span></span><br><span class="line"> cout&lt;&lt;a&lt;&lt;endl;                  <span class="comment">//输出不确定值</span></span><br><span class="line"></span><br><span class="line"> cin.<span class="built_in">clear</span>();                    <span class="comment">//此处用cin.clear()流标志复位</span></span><br><span class="line"> <span class="comment">//cin.sync();</span></span><br><span class="line"> cout&lt;&lt;<span class="string">&quot;cin.fail()=&quot;</span>&lt;&lt;cin.<span class="built_in">fail</span>()&lt;&lt;endl;        <span class="comment">//此处failbit已为0</span></span><br><span class="line"></span><br><span class="line"> cout&lt;&lt;<span class="string">&quot;输入一个数字:&quot;</span>&lt;&lt;endl;</span><br><span class="line"> <span class="comment">//但刚才输入的字符并没有从流中清除,所以cin&gt;&gt;a又把那个字符放入a中,流输入流又不能正常工作</span></span><br><span class="line"> cin&gt;&gt;a;</span><br><span class="line"> cout&lt;&lt;a&lt;&lt;endl; <span class="comment">//输出不确定值</span></span><br><span class="line"> cout&lt;&lt;<span class="string">&quot;cin.fail()=&quot;</span>&lt;&lt;cin.<span class="built_in">fail</span>()&lt;&lt;endl;    <span class="comment">//在此处failbit又为1</span></span><br><span class="line"></span><br><span class="line"> cin.<span class="built_in">clear</span>();            <span class="comment">//再次修复输入流</span></span><br><span class="line"> cin.<span class="built_in">ignore</span>();            <span class="comment">//取走刚才流中的字符</span></span><br><span class="line"> cout&lt;&lt;<span class="string">&quot;输入一个数字:&quot;</span>&lt;&lt;endl;    <span class="comment">//再次接收用记输入,这次输入数字,正常输出了</span></span><br><span class="line"> cin&gt;&gt;a;</span><br><span class="line"> cout&lt;&lt;<span class="string">&quot;a=&quot;</span>&lt;&lt;a&lt;&lt;endl;</span><br><span class="line"> <span class="comment">//现在再看一下输入流的failbit</span></span><br><span class="line"> cout&lt;&lt;<span class="string">&quot;cin.fail()=&quot;</span>&lt;&lt;cin.<span class="built_in">fail</span>()&lt;&lt;endl;<span class="comment">//输出0,表明输入流已恢复正常</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【重点注意】cin.get和cin.getline的区别</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210310173521606.png" alt="image-20210310173521606" style="zoom:80%;" /><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210310173332264.png" alt="image-20210310173332264" style="zoom:80%;" /></p>
<ul>
<li>cin.get：遇换行符结束读取,<strong>换行符遗留在缓冲区</strong>,所以要处理。</li>
<li>cin.getline：已读取了size-1个字符或遇到了文件尾或遇到了分隔符结束读取，若遇到换行符结束读取，丢弃换行符(换行符不在缓冲区也不被buf取走，而是直接丢掉)。</li>
</ul>
<p><strong>【重点注意】cin.ignore和cin.sync的区别</strong></p>
<ol>
<li><p>cin.ignore(a,ch)</p>
<p>从输入流（cin）中提取字符，提取的字符被忽略（ignore），不被使用。每抛弃一个字符，它都要计数和比较字符：如果计数值达到a或者被抛弃的字符是ch，则cin.ignore()函数执行终止；否则，它继续等待。</p>
<p>它的一个常用功能就是用来清除以回车结束的输入缓冲区的内容，消除上一次输入对下一次输入的影响。</p>
<p>比如可以这么用：</p>
<p>cin.ignore(1024,’\n’)，通常把第一个参数设置得足够大，这样实际上总是只有第二个参数’\n’起作用，所以这一句就是把回车（包括回车）之前的所以字符从输入缓冲（流）中清除出去。</p>
</li>
<li><p>cin.sync()</p>
<p>sync()的作用就是清除输入缓冲区。成功时返回0，失败时badbit会置位，函数返回-1.<br>另外，对于绑定了输出的输入流，调用sync()，还会刷新输出缓冲区。</p>
</li>
</ol>
<p>【重点注意】实践得知，vs2015下，sync并不能清空输入缓冲区，因此用ignore替代</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cin.<span class="built_in">ignore</span>(std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>(), <span class="string">&#x27;\n&#x27;</span>);<span class="comment">//把第一个参数设置得足够大，这样实际上总是只有第二个参数&#x27;\n&#x27;起作用，所以这一句就是把回车（包括回车）之前的所以字符从输入缓冲（流）中清除出去，用此来达到清空数据流的操作；这样就能吃掉一大段了，但理论上依旧不能保证吃掉一行</span></span><br><span class="line"><span class="comment">/*===============注意====================</span></span><br><span class="line"><span class="comment">需要把max用括号括起来避免和windows定义的宏混淆</span></span><br><span class="line"><span class="comment">(std::numeric_limits&lt;double&gt;::max)()</span></span><br><span class="line"><span class="comment">因为Windef.h中定义了</span></span><br><span class="line"><span class="comment">#ifndef max</span></span><br><span class="line"><span class="comment">#define max(a,b)            (((a) &gt; (b)) ? (a) : (b))</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">所以会产生编译错误=======================*/</span></span><br><span class="line"><span class="comment">//cin.ignore(1,EOF);</span></span><br></pre></td></tr></table></figure>

<p>程序执行时有一个标志变量来标志输入的异常状态，其中有三位标志位分别用来标志三种异常信息，他们分别是：failbit，eofbit，badbit。这三个标志位在标志变量中是这样分配的：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/image-20210311154555574.png" alt="image-20210311154555574"></p>
<p>ios类定义了这四个常量badbit, eofbit, failbit, goodbit，其实这四个标志常量就是取对应标志位的掩码，也即输入的四种异常情况！</p>
<ol>
<li>ios::badbit  001  输入（输出）流出现致命错误，不可挽回 </li>
<li>ios::eofbit  010  已经到达文件尾</li>
<li>ios::failbit  100  输入（输出）流出现非致命错误，可挽回</li>
<li>ios::goodbit  000  流状态完全正常, 各异常标志位都为0</li>
</ol>
<p>可以用输出语句来验证这几个常量的值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; ios:: failbit &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; ios:: eofbit &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; ios:: badbit &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; ios:: goodbit &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>【注意】cin&gt;&gt;与cin.getline的返回值相同</p>
<p>当读取不匹配类型的值或EOF时会造成流错误而返回NULL。（只有goodbit才会返回非NULL）</p>
<hr>
<p>其他函数讲解：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cin.get</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">	<span class="type">char</span> ch = cin.<span class="built_in">get</span>();</span><br><span class="line">	cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cin.<span class="built_in">get</span>(ch);</span><br><span class="line">	cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//链式编程</span></span><br><span class="line">	<span class="type">char</span> char1, char2, char3, char4;</span><br><span class="line">	cin.<span class="built_in">get</span>(char1).<span class="built_in">get</span>(char2).<span class="built_in">get</span>(char3).<span class="built_in">get</span>(char4);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; char1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; char2 &lt;&lt; <span class="string">&quot;&quot;</span> &lt;&lt; char3 &lt;&lt;  <span class="string">&quot; &quot;</span> &lt;&lt; char4 &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="comment">//cin.get(buf.1024);</span></span><br><span class="line">	cin.<span class="built_in">getline</span>(buf,<span class="number">1024</span>);</span><br><span class="line">	cout &lt;&lt; buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cin.ignore</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	cin.<span class="built_in">ignore</span>(<span class="number">2</span>); <span class="comment">//忽略缓冲区当前字符</span></span><br><span class="line">	cin.<span class="built_in">get</span>(buf,<span class="number">1024</span>);</span><br><span class="line">	cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cin.putback 将数据放回缓冲区</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从缓冲区取走一个字符</span></span><br><span class="line">	<span class="type">char</span> ch = cin.<span class="built_in">get</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;从缓冲区取走的字符:&quot;</span> &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//将数据再放回缓冲区</span></span><br><span class="line">	cin.<span class="built_in">putback</span>(ch);</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	cin.<span class="built_in">get</span>(buf,<span class="number">1024</span>);</span><br><span class="line">	cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cin.peek 偷窥</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//偷窥下缓冲区的数据</span></span><br><span class="line">	<span class="type">char</span> ch = cin.<span class="built_in">peek</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;偷窥缓冲区数据:&quot;</span> &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	cin.<span class="built_in">get</span>(buf, <span class="number">1024</span>);</span><br><span class="line">	cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//练习  作业 使用cin.get和putback完成类似功能</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test05</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入一个数字或者字符串:&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="type">char</span> ch = cin.<span class="built_in">peek</span>();</span><br><span class="line">	<span class="keyword">if</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">		<span class="type">int</span> number;</span><br><span class="line">		cin &gt;&gt; number;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;数字:&quot;</span> &lt;&lt; number &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="type">char</span> buf[<span class="number">64</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">		cin.<span class="built_in">getline</span>(buf, <span class="number">64</span>);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;字符串:&quot;</span> &lt;&lt;  buf &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="标准输出流"><a href="#标准输出流" class="headerlink" title="标准输出流"></a>标准输出流</h3><ol>
<li>cout.flush() &#x2F;&#x2F;刷新缓冲区 Linux下有效</li>
<li>cout.put() &#x2F;&#x2F;向缓冲区写字符</li>
<li>cout.write() &#x2F;&#x2F;从buff中向缓冲区写num个字节到当前输出流中。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cout.flush 刷新缓冲区，linux下有效</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;	</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">	<span class="comment">//刷新缓冲区</span></span><br><span class="line">	cout.<span class="built_in">flush</span>(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cout.put 输出一个字符</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout.<span class="built_in">put</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">	<span class="comment">//链式编程</span></span><br><span class="line">	cout.<span class="built_in">put</span>(<span class="string">&#x27;h&#x27;</span>).<span class="built_in">put</span>(<span class="string">&#x27;e&#x27;</span>).<span class="built_in">put</span>(<span class="string">&#x27;l&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cout.write 输出字符串 buf,输出多少个</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//char* str = &quot;hello world!&quot;;</span></span><br><span class="line">	<span class="comment">//cout.write(str, strlen(str));</span></span><br><span class="line">	<span class="type">char</span>* str = <span class="string">&quot;*************&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">strlen</span>(str); i ++)&#123;</span><br><span class="line">		cout.<span class="built_in">write</span>(str, i);</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">strlen</span>(str); i &gt; <span class="number">0</span>; i --)&#123;</span><br><span class="line">		cout.<span class="built_in">write</span>(str, i);</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h4><p>在输出数据时，为简便起见，往往不指定输出的格式，由系统根据数据的类型采取默认的格式，但有时希望数据按指定的格式输出，如要求以十六进制或八进制形式输出一个整数，对输出的小数只保留两位小数等。有两种方法可以达到此目的。</p>
<ol>
<li>使用控制符的方法；</li>
<li>使用流对象的有关成员函数。</li>
</ol>
<h5 id="使用流对象的有关成员函数"><a href="#使用流对象的有关成员函数" class="headerlink" title="使用流对象的有关成员函数"></a>使用流对象的有关成员函数</h5><p>通过调用流对象cout中用于控制输出格式的成员函数来控制输出格式。用于控制输出格式的常用的成员函数如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps30.jpg" alt="img"></p>
<p>流成员函数setf和控制符setiosflags括号中的参数表示格式状态，它是通过格式标志来指定的。格式标志在类ios中被定义为枚举值。因此在引用这些格式标志时要在前面加上类名ios和域运算符“::”。格式标志见表13.5。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps89.jpg" alt="img"></p>
<h5 id="控制符格式化输出"><a href="#控制符格式化输出" class="headerlink" title="控制符格式化输出"></a>控制符格式化输出</h5><p>C++提供了在输入输出流中使用的控制符(有的书中称为操纵符)。(需要iomanip头文件)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps109.jpg" alt="img"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过流成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> number = <span class="number">99</span>;</span><br><span class="line">	cout.<span class="built_in">width</span>(<span class="number">20</span>);</span><br><span class="line">	cout.<span class="built_in">fill</span>(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">	cout.<span class="built_in">setf</span>(ios::left);</span><br><span class="line">	cout.<span class="built_in">unsetf</span>(ios::dec); <span class="comment">//卸载十进制</span></span><br><span class="line">	cout.<span class="built_in">setf</span>(ios::hex);</span><br><span class="line">	cout.<span class="built_in">setf</span>(ios::showbase);</span><br><span class="line">	cout.<span class="built_in">unsetf</span>(ios::hex);</span><br><span class="line">	cout.<span class="built_in">setf</span>(ios::oct);</span><br><span class="line">	cout &lt;&lt; number &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用控制符</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> number = <span class="number">99</span>;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">20</span>)</span><br><span class="line">		&lt;&lt; <span class="built_in">setfill</span>(<span class="string">&#x27;~&#x27;</span>)</span><br><span class="line">		&lt;&lt; <span class="built_in">setiosflags</span>(ios::showbase)</span><br><span class="line">		&lt;&lt; <span class="built_in">setiosflags</span>(ios::left)</span><br><span class="line">		&lt;&lt; hex</span><br><span class="line">		&lt;&lt; number</span><br><span class="line">		&lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="对程序的几点说明-注意点"><a href="#对程序的几点说明-注意点" class="headerlink" title="对程序的几点说明(注意点)"></a>对程序的几点说明(注意点)</h5><ol>
<li><p><strong>成员函数width(n)和控制符setw(n)只对其后的第一个输出项有效。</strong>(之后依然按按系统默认的域宽输出)</p>
<p>如果要求在输出数据时都按指定的同一域宽n输出，不能只调用一次width(n)， 而必须在输出每一项前都调用一次width(n)</p>
</li>
<li><p>在表13.5中的输出格式状态分为5组，每一组中同时只能选用一种（例如dec、hex和oct中只能选一，它们是互相排斥的）。在用成员函数setf和 控制符setiosflags设置输出格式状态后，如果想改设置为同组的另一状态，应当调用成员函数unsetf（对应于成员函数self）或 resetiosflags（对应于控制符setiosflags），先终止原来设置的状态。然后再设置其他状态，大家可以从本程序中看到这点。程序在开始虽然没有用成员函数self和控制符setiosflags设置用dec输出格式状态，但系统默认指定为dec，因此要改变为hex或oct，也应当先 用unsetf 函数终止原来设置。<strong>若未终止格式就设置别的格式，设置的格式均不起作用</strong>，系统依然以未终止格式输出。</p>
</li>
<li><p>用setf 函数设置格式状态时，可以包含两个或多个格式标志，由于这些格式标志在ios类中被定义为枚举值，每一个格式标志以一个二进位代表，因此可<strong>以用位或运算符“|”组合多个格式标志</strong>。如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout.<span class="built_in">setf</span>(ios::internal I ios::showpos);  <span class="comment">//包含两个状态标志，用&quot;|&quot;组合</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可以看到：对输出格式的控制，既可以用控制符，也可以用cout流的有关成员函数，二者的作用是相同的。控制符是在头文件iomanip中定义的，因此<strong>用控制符时，必须包含iomanip头文件</strong>。cout流的成员函数是在头文件iostream 中定义的，因此只需包含头文件iostream，不必包含iomanip。许多程序人员感到使用控制符方便简单，可以在一个cout输出语句中连续使用多种控制符。</p>
</li>
</ol>
<h3 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h3><p>头文件：&lt;fstream&gt;</p>
<h4 id="文件流类和文件流对象"><a href="#文件流类和文件流对象" class="headerlink" title="文件流类和文件流对象"></a>文件流类和文件流对象</h4><p>输入输出是以系统指定的标准设备（输入设备为键盘，输出设备为显示器）为对象的。在实际应用中，常以磁盘文件作为对象。即从磁盘文件读取数据，将数据输出到磁盘文件。</p>
<p>和文件有关系的输入输出类主要在fstream.h这个头文件中被定义，在这个头文件中主要被定义了三个类，由这三个类控制对文件的各种输入输出操作，他们分别是ifstream、ofstream、fstream，其中fstream类是由iostream类派生而来，他们之间的继承关系见下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps24.jpg" alt="img">（图中打错了，应该是fstream）</p>
<p>由于文件设备并不像显示器屏幕与键盘那样是标准默认设备，所以它在fstream头文件中是没有像cout那样预先定义的全局对象，所以我们必须自己定义一个该类的对象。ifstream类，它是从istream类派生的，用来支持从磁盘文件的输入。ofstream类，它是从ostream类派生的，用来支持向磁盘文件的输出。</p>
<p>fstream类，它是从iostream类派生的，用来支持对磁盘文件的输入输出。</p>
<h4 id="C-打开文件"><a href="#C-打开文件" class="headerlink" title="C++打开文件"></a>C++打开文件</h4><p>所谓打开(open)文件是一种形象的说法，如同打开房门就可以进入房间活动一样。 打开文件是指在文件读写之前做必要的准备工作，包括：</p>
<ol>
<li>为文件流对象和指定的磁盘文件建立关联，以便使文件流流向指定的磁盘文件。</li>
<li>指定文件的工作方式，如：该文件是作为输入文件还是输出文件，是ASCII文件还是二进制文件等。</li>
</ol>
<p>以上工作可以通过两种不同的方法实现:</p>
<ol>
<li><p>调用文件流的成员函数open。如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ofstream outfile;  <span class="comment">//定义ofstream类(输出文件流类)对象outfile</span></span><br><span class="line">outfile.<span class="built_in">open</span>(<span class="string">&quot;f1.dat&quot;</span>,ios::out);  <span class="comment">//使文件流与f1.dat文件建立关联</span></span><br></pre></td></tr></table></figure>

<p>第2行是调用输出文件流的成员函数open打开磁盘文件f1.dat，并指定它为输出文件，文件流对象outfile将向磁盘文件f1.dat输出数据。ios::out是I&#x2F;O模式的一种，表示以输出方式打开一个文件。或者简单地说，此时f1.dat是一个输出文件，接收从内存输出的数据。</p>
<p>磁盘文件名可以包括路径，如”c:\new\f1.dat”，如缺省路径，则默认为当前目录下的文件。</p>
</li>
<li><p>在定义文件流对象时指定参数</p>
<p>在声明文件流类时定义了带参数的构造函数，其中包含了打开磁盘文件的功能。因此，可以在定义文件流对象时指定参数，调用文件流类的构造函数来实现打开文件的功能。</p>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage/wps95.jpg" alt="img"></p>
<p>几点说明：</p>
<ol>
<li>新版本的I&#x2F;O类库中不提供ios::nocreate和ios::noreplace。</li>
<li>每一个打开的文件都有一个文件指针，该指针的初始位置由I&#x2F;O方式指定，每次读写都从文件指针的当前位置开始。每读入一个字节，指针就后移一个字节。当文件指针移到最后，就会遇到文件结束EOF（文件结束符也占一个字节，其值为-1)，此时流对象的成员函数eof的值为非0值(一般设为1)，表示文件结束了。</li>
<li>可以用“位或”运算符“|”对输入输出方式进行组合，如表13.6中最后3行所示那样。还可以举出下面一些例子：<br>  ios::in | ios:: noreplace  &#x2F;&#x2F;打开一个输入文件，若文件不存在则返回打开失败的信息<br>  ios::app | ios::nocreate  &#x2F;&#x2F;打开一个输出文件，在文件尾接着写数据，若文件不存在，则返回打开失败的信息<br>  ios::out l ios::noreplace  &#x2F;&#x2F;打开一个新文件作为输出文件，如果文件已存在则返回打开失败的信息<br>  ios::in l ios::out I ios::binary  &#x2F;&#x2F;打开一个二进制文件，可读可写<br>但不能组合互相排斥的方式，如 ios::nocreate l ios::noreplace。</li>
<li>如果打开操作失败，open函数的返回值为0(假)，如果是用调用构造函数的方式打开文件的，则流对象的值为0。可以据此测试打开是否成功。如<br>  if(outfile.open(“f1.bat”, ios::app) &#x3D;&#x3D;0)<br>cout &lt;&lt;”open error”;<br>或<br>  if( !outfile.open(“f1.bat”, ios::app) )<br>cout &lt;&lt;”open error”;</li>
</ol>
<h4 id="C-关闭文件"><a href="#C-关闭文件" class="headerlink" title="C++关闭文件"></a>C++关闭文件</h4><p>在对已打开的磁盘文件的读写操作完成后，应关闭该文件。关闭文件用成员函数close。如：outfile.close( );  &#x2F;&#x2F;将输出文件流所关联的磁盘文件关闭<br><strong>所谓关闭，实际上是解除该磁盘文件与文件流的关联，原来设置的工作方式也失效，这样，就不能再通过文件流对该文件进行输入或输出。</strong>此时可以将文件流与其他磁盘文件建立关联，通过文件流对新的文件进行输入或输出。如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outfile.<span class="built_in">open</span>(<span class="string">&quot;f2.dat&quot;</span>,ios::app|ios::nocreate);<span class="comment">//(文件路径，打开方式)</span></span><br></pre></td></tr></table></figure>

<p>此时文件流outfile与f2.dat建立关联，并指定了f2.dat的工作方式。</p>
<h4 id="C-对ASCII文件的读写操作"><a href="#C-对ASCII文件的读写操作" class="headerlink" title="C++对ASCII文件的读写操作"></a>C++对ASCII文件的读写操作</h4><p>如果文件的每一个字节中均以ASCII代码形式存放数据,即一个字节存放一个字符,这个文件就是ASCII文件(或称字符文件)。程序可以从ASCII文件中读入若干个字符,也可以向它输出一些字符。</p>
<ol>
<li><p>用流插入运算符“&lt;&lt;”和流提取运算符“&gt;&gt;”输入输出标准类型的数据。“&lt;&lt;”和“ &gt;&gt;”都巳在iostream中被重载为能用于ostream和istream类对象的标准类型的输入输出。由于ifstream和 ofstream分别是ostream和istream类的派生类；因此它们从ostream和istream类继承了公用的重载函数，所以在对磁盘文件的操作中，可以通过文件流对象和流插入运算符“&lt;&lt;”及 流提取运算符“&gt;&gt;”实现对磁盘 文件的读写，如同用cin、cout和&lt;&lt;、&gt;&gt;对标准设备进行读写一样。</p>
</li>
<li><p>用文件流的put、get、geiline等成员函数进行字符的输入输出，：用C++流成员函数put输出单个字符、C++ get()函数读入一个字符和C++ getline()函数读入一行字符。</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">char</span>* sourceFileName = <span class="string">&quot;./source.txt&quot;</span>;</span><br><span class="line">	<span class="type">char</span>* targetFileName = <span class="string">&quot;./target.txt&quot;</span>;</span><br><span class="line">	<span class="comment">//创建文件输入流对象</span></span><br><span class="line">	<span class="function">ifstream <span class="title">ism</span><span class="params">(sourceFileName, ios::in)</span></span>;</span><br><span class="line">	<span class="comment">//创建文件输出流对象</span></span><br><span class="line">	<span class="function">ofstream <span class="title">osm</span><span class="params">(targetFileName,ios::out)</span></span>;</span><br><span class="line">	<span class="keyword">if</span> (!ism)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文件打开失败!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (!ism.<span class="built_in">eof</span>())&#123;</span><br><span class="line">		<span class="type">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">		ism.<span class="built_in">getline</span>(buf,<span class="number">1024</span>);</span><br><span class="line">		cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">		osm &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//关闭文件流对象</span></span><br><span class="line">	ism.<span class="built_in">close</span>();</span><br><span class="line">	osm.<span class="built_in">close</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4种ASCII读写方式"><a href="#4种ASCII读写方式" class="headerlink" title="4种ASCII读写方式"></a>4种ASCII读写方式</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打开文件</span></span><br><span class="line">ifs.<span class="built_in">open</span>(<span class="string">&quot;./test.txt&quot;</span>,ios::in);</span><br><span class="line"><span class="keyword">if</span>(!ifs.<span class="built_in">is_open</span>())<span class="comment">//判断文件是否打开成功</span></span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;文件打开失败&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第一种方式</span></span><br><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">while</span>(ifs&gt;&gt;buf)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;buf&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二种方式</span></span><br><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">while</span>(ifs.<span class="built_in">getline</span>(buf,<span class="built_in">sizeof</span>(buf)))</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;buf&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第三种方式</span></span><br><span class="line">string buf;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">getline</span>(ifs,buf))<span class="comment">//全局getline函数，需要&lt;string&gt;头文件</span></span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;buf&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第四种方式</span></span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="keyword">while</span>((c=ifs.<span class="built_in">get</span>())!=EOF)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭文件</span></span><br><span class="line">ifs.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure>

<p>【注意】全局getline和ifstream流对象中的getline的区别</p>
<ol>
<li>ifstream的对象ifs中存在<strong>ifs.getline(读到哪个buf，读多少num)函数</strong></li>
<li>此外还存在一个全局函数（需要<string>头文件）<strong>getline(从哪读ifs,读到哪buf（string类型）,分隔符[可选项])</strong></li>
</ol>
<p>【注意】</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将文件指针移动到文件开头（file为文件流对象）</span></span><br><span class="line">file.<span class="built_in">clear</span>(std::ios::goodbit);<span class="comment">//清空好坏标志位</span></span><br><span class="line">file.<span class="built_in">seekg</span>(std::ios::beg);<span class="comment">//将光标回到文件头</span></span><br></pre></td></tr></table></figure>

<h4 id="C-对二进制文件的读写操作"><a href="#C-对二进制文件的读写操作" class="headerlink" title="C++对二进制文件的读写操作"></a>C++对二进制文件的读写操作</h4><p>二进制文件不是以ASCII代码存放数据的，它将内存中数据存储形式不加转换地传送到磁盘文件，因此它又称为内存数据的映像文件。因为文件中的信息不是字符数据，而是字节中的二进制形式的信息，因此它又称为字节文件。</p>
<p>对二进制文件的操作也需要先打开文件，用完后要关闭文件。在打开时要用ios::binary指定为以二进制形式传送和存储。二进制文件除了可以作为输入文件或输出文件外,还<strong>可以是既能输入又能输出的文件</strong>。这是和ASCII文件不同的地方。</p>
<h4 id="用成员函数read和write读写二进制文件"><a href="#用成员函数read和write读写二进制文件" class="headerlink" title="用成员函数read和write读写二进制文件"></a>用成员函数read和write读写二进制文件</h4><p>对二进制文件的读写主要用istream类的成员函数read和write来实现。这两个成员函数的原型为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">read</span><span class="params">(<span class="type">char</span> *buffer,<span class="type">int</span> len)</span></span>;</span><br><span class="line"><span class="function">ostream&amp; <span class="title">write</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * buffer,<span class="type">int</span> len)</span></span>;</span><br></pre></td></tr></table></figure>


<p>字符指针buffer指向内存中一段存储空间。len是读写的字节数。调用的方式为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a. <span class="built_in">write</span>(p1,<span class="number">50</span>);</span><br><span class="line">b. <span class="built_in">read</span>(p2,<span class="number">30</span>);</span><br></pre></td></tr></table></figure>


<p>上面第一行中的a是输出文件流对象，write函数将字符指针p1所给出的地址开始的50个字节的内容不加转换地写到磁盘文件中。在第二行中，b是输入文件流对象，read 函数从b所关联的磁盘文件中，读入30个字节(或遇EOF结束），存放在字符指针p2所指的一段空间内。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">char</span>* name,<span class="type">int</span> age)&#123;</span><br><span class="line">		<span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;mName, name);</span><br><span class="line">		<span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">char</span> mName[<span class="number">64</span>];</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span>* fileName = <span class="string">&quot;person.txt&quot;</span>;</span><br><span class="line">	<span class="comment">//二进制模式读写文件</span></span><br><span class="line">	<span class="comment">//创建文件对象输出流</span></span><br><span class="line">	<span class="function">ofstream <span class="title">osm</span><span class="params">(fileName, ios::out | ios::binary)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;John&quot;</span>,<span class="number">33</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;Edward&quot;</span>, <span class="number">34</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Person对象写入文件</span></span><br><span class="line">	osm.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span>*)&amp;p1,<span class="built_in">sizeof</span>(Person));</span><br><span class="line">	osm.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span>*)&amp;p2, <span class="built_in">sizeof</span>(Person));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭文件输出流</span></span><br><span class="line">	osm.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从文件中读取对象数组</span></span><br><span class="line">	<span class="function">ifstream <span class="title">ism</span><span class="params">(fileName, ios::in | ios::binary)</span></span>;</span><br><span class="line">	<span class="keyword">if</span> (!ism)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;打开失败!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	Person p3;</span><br><span class="line">	Person p4;</span><br><span class="line"></span><br><span class="line">	ism.<span class="built_in">read</span>((<span class="type">char</span>*)&amp;p3, <span class="built_in">sizeof</span>(Person));</span><br><span class="line">	ism.<span class="built_in">read</span>((<span class="type">char</span>*)&amp;p4, <span class="built_in">sizeof</span>(Person));</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; p<span class="number">3.</span>mName &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; p<span class="number">3.</span>mAge &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Age:&quot;</span> &lt;&lt; p<span class="number">4.</span>mName &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; p<span class="number">4.</span>mAge &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭文件输入流</span></span><br><span class="line">	ism.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><blockquote>
<p>断言就是对一个表达式的判断，当表达式为假时就输出诊断消息并调用abort()函数中止程序。</p>
</blockquote>
<p>断言的使用格式：<code>assert (bool_constexpr )；</code></p>
<p>如果指定的表达式为 false，程序会终止并显示诊断消息。</p>
<p><code>assert.h </code>和 <code>cassert </code>头文件分别是用于在 C 和 C++ 中进行断言（assertion）的头文件</p>
<blockquote>
<ul>
<li>断言语句仅在定义了 <code>_DEBUG</code> 时才进行编译。</li>
<li>在发布版本中，断言不会产生开销或性能成本。</li>
</ul>
</blockquote>
<p>断言不能代替程序中的错误检查,只能出现于理所当然正确的地方</p>
<h1 id="C-与C性能分析"><a href="#C-与C性能分析" class="headerlink" title="C++与C性能分析"></a>C++与C性能分析</h1><p><a target="_blank" rel="noopener" href="https://baiy.cn/doc/cpp/inside_rtti.htm">参考此文</a></p>
<blockquote>
<p>其实对一个优秀的编译器而言，C++的各种特性本身就是使用C&#x2F;汇编加以千锤百炼而最优化实现的。可以说，想用C甚至汇编比编译器更高效地实现某个C++特性几乎是不可能的。要是真能做到这一点的话，就应该去写个编译器造福广大程序员才对</p>
</blockquote>
<p>相对与传统C程序而言，C++中有可能引入额外运行时开销的新特性包括：</p>
<ol>
<li><p>虚基类</p>
</li>
<li><p>虚函数</p>
</li>
<li><p>RTTI（dynamic_cast和typeid）</p>
</li>
<li><p>异常</p>
<p>异常，对于大多数现代编译器来说，在正常情况（未抛出异常）下，try块中的代码执行效率和普通代码一样高，而且由于不再需要使用传统上通过返回值或函数调用来判断错误的方式，代码的实际执行效率还可能进一步提高。抛出和捕捉异常的效率也只是在某些情况下才会稍低于函数正常返回的效率，何况对于一个编写良好的程序，抛出和捕捉异常的机会应该不多。</p>
</li>
<li><p>对象的构造和析构</p>
<p>对象的构造和析构开销也不总是存在。对于不需要初始化&#x2F;销毁的类型，并没有构造和析构的开销，相反对于那些需要初始化&#x2F;销毁的类型来说，即使用传统的C方式实现，也至少需要与之相当的开销。这里要注意的一点是尽量不要让构造和析构函数过于臃肿，特别是在一个类层次结构中更要注意。时刻保持你的构造、析构函数中只有最必要的初始化和销毁操作，把那些并不是每个（子）对象都需要执行的操作留给其他方法和派生类去解决</p>
</li>
</ol>
<blockquote>
<p>C++之所以 被广泛认为比C“低效”，其根本原因在于：由于程序员对某些特性的实现方式及其产生的开销不够了解，致使他们在错误的场合使用了错误的特性。而这些错误基本都集中在：</p>
<ul>
<li>把异常当作另一种流控机制，而不是仅将其用于错误处理中</li>
<li>一个类和&#x2F;或其基类的构造、析构函数过于臃肿，包含了很多非初始化&#x2F;销毁范畴的代码</li>
<li>滥用或不正确地使用RTTI、虚函数和虚基类机制</li>
</ul>
</blockquote>
<h1 id="将C源代码封装成C-类代码"><a href="#将C源代码封装成C-类代码" class="headerlink" title="将C源代码封装成C++类代码"></a>将C源代码封装成C++类代码</h1><ol>
<li>将宏定义—&gt;常量const<ul>
<li>主要是整形和字符串</li>
<li>一些连续的整形值可以定义成枚举类型</li>
</ul>
</li>
<li>宏函数<ul>
<li>简单的宏函数可以改写成<a href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E7%9A%84%E5%BC%95%E5%87%BA">内联函数</a></li>
<li>如果比较复杂,可以改写成类的成员函数</li>
</ul>
</li>
<li>若成员函数都用到了某个变量,可以将这个变量设置为类的成员变量</li>
<li>通过类的访问控制权限控制<ul>
<li>一般只有public成员可以对外界访问,不被外界访问的可以设置成private成员或者protect成员</li>
</ul>
</li>
</ol>
<h1 id="内存泄露检测知识点-调试技巧注意点篇"><a href="#内存泄露检测知识点-调试技巧注意点篇" class="headerlink" title="内存泄露检测知识点(调试技巧注意点篇)"></a>内存泄露检测知识点(调试技巧注意点篇)</h1><p><strong>【重点】</strong>（<strong>崩溃的调试定位问题技巧</strong>）崩溃的时候在弹出的对话框按相应按钮进入调试，按Alt+7键查看Call Stack即“调用堆栈”里面从上到下列出的对应从里层到外层的函数调用历史。双击某一行可将光标定位到此次调用的源代码或汇编指令处，看不懂时双击下一行，直到能看懂为止。</p>
<h1 id="VC编译选项“基本运行时检查”的作用"><a href="#VC编译选项“基本运行时检查”的作用" class="headerlink" title="VC编译选项“基本运行时检查”的作用"></a>VC编译选项“基本运行时检查”的作用</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/aqtata/article/details/106156275">详情见链接</a></p>
<h1 id="C-如何使用第三方库"><a href="#C-如何使用第三方库" class="headerlink" title="C++如何使用第三方库"></a>C++如何使用第三方库</h1><ul>
<li>C++最原始的方法就是自己建一个deps目录,把依赖的库的源代码直接放里面</li>
<li>apt-get install libxxx-dev    <code>libxxx-dev</code>是一个开发包，通常包含用于编译和链接程序的头文件和库</li>
<li>C++有大量的包管理器，包括 buckaroo、vcpkg、cget、conan、conda、cpm、cppan、hunter 等。</li>
<li>xmake内含自己的包管理器</li>
</ul>
<p>p.s.这里提一嘴谷歌的构建工具bazel,以及魔改版的blade</p>
<h2 id="homebrew"><a href="#homebrew" class="headerlink" title="homebrew"></a>homebrew</h2><h3 id="配合cmake使用开发包"><a href="#配合cmake使用开发包" class="headerlink" title="配合cmake使用开发包"></a>配合cmake使用开发包</h3><p><strong>在 CMakeLists.txt 中设置 CMAKE_PREFIX_PATH</strong>:</p>
<ul>
<li><p>Homebrew 将包安装在固定的目录,通常是 <code> /opt/homebrew/Cellar/</code>。</p>
</li>
<li><p>在 CMakeLists.txt 文件中,需要手动设置 </p>
<p><code>CMAKE_PREFIX_PATH</code></p>
<p> 变量,指向 Homebrew 包的安装目录:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_PREFIX_PATH /opt/homebrew/Cellar/)<span class="comment">#如果是在intel mac上应该是/opt/homebrew/xxx</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>这样 CMake 就能够找到 Homebrew 安装的包的头文件和库文件。</p>
</li>
</ul>
<p><strong>使用 find_package() 命令查找并链接包</strong>:</p>
<ul>
<li><p>在 CMakeLists.txt 中使用 </p>
<p><code>find_package()</code></p>
<p> 命令来查找需要的包,例如 OpenCV:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(OpenCV REQUIRED)</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后在目标库上链接该包:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(my_target PRIVATE <span class="variable">$&#123;OpenCV_LIBS&#125;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="vcpkg包管理器"><a href="#vcpkg包管理器" class="headerlink" title="vcpkg包管理器"></a>vcpkg包管理器</h2><blockquote>
<p>vcpkg是Microsoft的跨平台开源软件包管理器，极大地简化了 Windows、Linux 和 macOS 上第三方库的下载与安装。如果项目要使用第三方库，建议通过 vcpkg 来安装它们。vcpkg 同时支持开源和专有库。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/96c64afc7c23">与conan的比较</a></p>
<p><strong>源码级兼容</strong></p>
<p>在编写C++程序时，一直有二进制兼容的问题。在可执行文件链接到三方库时，编译器的类型和版本的统一非常重要。Vcpkg通过下载源码(而不是二进制文件)的方式来提供三方库。</p>
<h3 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h3><p><a target="_blank" rel="noopener" href="https://github.com/microsoft/vcpkg">Vcpkg的官方源码站点</a></p>
<p>下面介绍的是二进制方式安装:</p>
<ul>
<li><p>下载</p>
<p><code>git clone https://github.com/microsoft/vcpkg</code></p>
</li>
<li><p>编译</p>
<ul>
<li>Windows平台：在cmd中执行Vcpkg工程目录下的“bootstrap-vcpkg.bat”命令，编译好后会在同级目录下生成vcpkg.exe文件。</li>
<li>Linux&#x2F;mac平台：在命令行中执行在vcpkg工程目录下<code>sudo bash ./bootstrap-vcpkg.sh</code>命令,会生成一个可执行文件vcpkg。定义环境变量 <code>VCPKG_ROOT=&quot;~/vcpkg&quot;</code></li>
</ul>
<p>想到处使用别忘了添加到path中,比如mac:<code>export PATH=$PATH:$VCPKG_ROOT</code></p>
</li>
</ul>
<p>注意clion想要使用系统带的vcpkg,路径就设置为<code>~/vcpkg</code>,全局就可以使用同一个vcpkg</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>查看Vcpkg支持的库  <code>vcpkg search xxxx</code></p>
<p>安装一个库   <code>vcpkg install xxxx</code>  </p>
<p>查看已安装的库  <code>vcpkg list</code></p>
<p>移除已经安装的库  <code>vcpkg remove xxxx</code></p>
<h3 id="集成使用"><a href="#集成使用" class="headerlink" title="集成使用"></a>集成使用</h3><blockquote>
<p>Vcpkg提供了一套机制，可以全自动的适配目录，而开发者不需要关心已安装的库的目录在哪里，也不需要设置</p>
</blockquote>
<ul>
<li><p>集成到全局: <code>vcpkg integrate install</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入vcpkg integrate install后,返回:</span></span><br><span class="line">Applied user-wide integration <span class="keyword">for</span> <span class="keyword">this</span> vcpkg root.`</span><br><span class="line">`CMake projects should use: <span class="string">&quot;-DCMAKE_TOOLCHAIN_FILE=/Users/zeroko/vcpkg/scripts/buildsystems/vcpkg.cmake&quot;</span></span><br></pre></td></tr></table></figure>

<p>表示集成成功,并提供了一个在CMake项目中使用vcpkg的提示。你可以将该指令添加到你的CMake构建命令中，以确保CMake能够正确地使用vcpkg安装的库。</p>
<p>在项目根目录执行命令:<code>cmake -DCMAKE_TOOLCHAIN_FILE=/Users/zeroko/vcpkg/scripts/buildsystems/vcpkg.cmake .</code>(<code>.</code>表示CMakeLists.txt的路径位置)</p>
<blockquote>
<p>具体而言，<code>vcpkg integrate install</code>命令会执行以下操作：</p>
<ol>
<li><p>在当前用户的目录下创建一个名为<code>.vcpkg-root</code>的隐藏文件夹，用于存储vcpkg的集成信息。</p>
</li>
<li><p>将vcpkg的路径添加到系统环境变量中，以便在构建项目时能够找到vcpkg。</p>
</li>
<li><p>针对不同的开发环境，自动配置构建工具（如CMake、MSBuild等）的相关设置，以确保它们能够正确地使用vcpkg。</p>
</li>
</ol>
</blockquote>
</li>
<li><p>移除集成: <code>vcpkg integrate remove</code></p>
</li>
</ul>
<p>之后与CMake一起使用时，需添加依赖以及在设置路径</p>
<h3 id="与CMAKE配合使用"><a href="#与CMAKE配合使用" class="headerlink" title="与CMAKE配合使用"></a>与CMAKE配合使用</h3><blockquote>
<p>以openssl库为例</p>
</blockquote>
<ol>
<li><p><code>vcpkg install openssl</code>,成功的话将返回如下:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#	寻找添加的库</span></span><br><span class="line"><span class="keyword">find_package</span>(OpenSSL REQUIRED)</span><br><span class="line"><span class="comment">#	添加库链接</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> PRIVATE OpenSSL::SSL OpenSSL::Crypto)</span><br></pre></td></tr></table></figure>
</li>
<li><p>CMakeLists.txt编写如下:(<code>/Users/zeroko/vcpkg/</code>为vcpkg安装的根目录)</p>
</li>
</ol>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(main)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">aux_source_directory</span>(./  SRCS)</span><br><span class="line"></span><br><span class="line"><span class="comment">#与手动执行cmake -DCMAKE_TOOLCHAIN_FILE=/Users/zeroko/vcpkg/scripts/buildsystems/vcpkg.cmake效果一致</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_TOOLCHAIN_FILE /Users/zeroko/vcpkg/scripts/buildsystems/vcpkg.cmake)</span><br><span class="line"><span class="comment">#上面这一行针对某些包不管用,实测比如说gtest,catch2等测试框架此时使用下面的命令:(在mac上)</span></span><br><span class="line"><span class="keyword">list</span>(APPEND CMAKE_PREFIX_PATH <span class="string">&quot;/Users/zeroko/vcpkg/installed/arm64-osx&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 寻找添加的库</span></span><br><span class="line"><span class="keyword">find_package</span>(OpenSSL REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;SRCS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加库链接</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> PRIVATE OpenSSL::SSL OpenSSL::Crypto)</span><br></pre></td></tr></table></figure>

<h3 id="vcpkg与homebrew的区别"><a href="#vcpkg与homebrew的区别" class="headerlink" title="vcpkg与homebrew的区别"></a>vcpkg与homebrew的区别</h3><ul>
<li>Homebrew 主要针对 macOS 平台,而 vcpkg 支持 Windows、Linux 和 macOS</li>
<li>Homebrew 主要使用 CMake 作为构建系统,而 vcpkg 支持多种构建系统,包括 MSBuild、Ninja 和 CMake</li>
</ul>
<h1 id="boost库"><a href="#boost库" class="headerlink" title="boost库"></a>boost库</h1><blockquote>
<p>​	<strong>boost</strong>库是一个优秀的。可移植，开源的C++库，它是由C++标准委员会库工作自成员发起，它是对STL的延续和扩充，设计理念和STL比较接近，都是利用泛型让复用达到最大化，其中有些内容经常成为下一代C++标准库内容，在C++社区影响很大，是不折不扣的“准”标准库。<br>​	相比STL，boost更加实用。STL集中在算法部分，而boost包含了不少工具类，可以完成比较具体的工作。当下在C&#x2F;C++开发中，熟练掌握boost的使用可谓是必备的。<br>​	boost主要包含一下几个大类：字符串及文本处理、容器、迭代子(Iterator)、算法、函数对象和高阶编程、泛型编程、模板元编程、预处理元编程、并发编程、数学相关、纠错和测试、数据结构、输入&#x2F;输出、跨语言支持、内存相关、语法分析、杂项。 <em>有一些库是跨类别包含的，就是既属于这个类别又属于那个类别。</em></p>
</blockquote>
<h1 id="C-通用开源框架和库"><a href="#C-通用开源框架和库" class="headerlink" title="C++通用开源框架和库"></a>C++通用开源框架和库</h1><p><a target="_blank" rel="noopener" href="https://github.com/yuanzhongqiao/awesome-cpp-cn">点击参考更多库</a></p>
<p>2022-08-24 记录</p>
<ul>
<li>Apache C++ Standard Library：是一系列算法，容器，迭代器和其他基本组件的集合</li>
<li>ASL ：Adobe源代码库提供了同行的评审和可移植的C++源代码库。</li>
<li>Boost ：大量通用C++库的集合。</li>
<li>BDE ：来自于彭博资讯实验室的开发环境。</li>
<li>Cinder：提供专业品质创造性编码的开源开发社区。</li>
<li>Cxxomfort：轻量级的，只包含头文件的库，将C++ 11的一些新特性移植到C++03中。</li>
<li>Dlib：使用契约式编程和现代C++科技设计的通用的跨平台的C++库。</li>
<li>EASTL ：EA-STL公共部分</li>
<li>ffead-cpp ：企业应用程序开发框架</li>
<li>Folly：由Facebook开发和使用的开源C++库</li>
<li>JUCE ：包罗万象的C++类库，用于开发跨平台软件</li>
<li>libPhenom：用于构建高性能和高度可扩展性系统的事件框架。</li>
<li>LibSourcey ：用于实时的视频流和高性能网络应用程序的C++11 evented IO</li>
<li>LibU ：C语言写的多平台工具库</li>
<li>Loki ：C++库的设计，包括常见的设计模式和习语的实现。</li>
<li>MiLi ：只含头文件的小型C++库</li>
<li>openFrameworks ：开发C++工具包，用于创意性编码。</li>
<li>[[Qt]] ：跨平台的应用程序和用户界面框架</li>
<li>Reason ：跨平台的框架，使开发者能够更容易地使用Java，.Net和Python，同时也满足了他们对C++性能和优势的需求。</li>
<li>ROOT ：具备所有功能的一系列面向对象的框架，能够非常高效地处理和分析大量的数据，为欧洲原子能研究机构所用。</li>
<li>STLport：是[[STL]]具有代表性的版本</li>
<li>STXXL：用于额外的大型数据集的标准模板库。</li>
<li>Ultimate++ ：C++跨平台快速应用程序开发框架</li>
<li>Windows Template Library：用于开发Windows应用程序和UI组件的C++库</li>
<li>Yomm11 ：C++11的开放multi-methods.</li>
</ul>
<h2 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h2><ul>
<li>btsk ：游戏行为树启动器工具</li>
<li>Evolving Objects：基于模板的，ANSI C++演化计算库，能够帮助你非常快速地编写出自己的随机优化算法。</li>
<li>Neu：C++11框架，编程语言集，用于创建人工智能应用程序的多用途软件系统。</li>
</ul>
<h2 id="异步事件循环"><a href="#异步事件循环" class="headerlink" title="异步事件循环"></a>异步事件循环</h2><ul>
<li>Boost.Asio：用于网络和底层I&#x2F;O编程的跨平台的C++库。</li>
<li>libev ：功能齐全，高性能的时间循环，轻微地仿效libevent，但是不再像libevent一样有局限性，也修复了它的一些bug。</li>
<li>libevent ：事件通知库</li>
<li>libuv ：跨平台异步I&#x2F;O。</li>
</ul>
<h2 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h2><blockquote>
<p>声音，音乐，数字化音乐库</p>
</blockquote>
<ul>
<li>FMOD ：易于使用的跨平台的音频引擎和音频内容的游戏创作工具。</li>
<li>Maximilian ：C++音频和音乐数字信号处理库</li>
<li>OpenAL ：开源音频库—跨平台的音频API</li>
<li>Opus：一个完全开放的，免版税的，高度通用的音频编解码器</li>
<li>Speex：免费编解码器，为Opus所废弃</li>
<li>Tonic：C++易用和高效的音频合成</li>
<li>Vorbis：Ogg Vorbis是一种完全开放的，非专有的，免版税的通用压缩音频格式。</li>
</ul>
<h2 id="生物信息"><a href="#生物信息" class="headerlink" title="生物信息"></a>生物信息</h2><blockquote>
<p>基因组学和生物技术</p>
</blockquote>
<ul>
<li>libsequence：用于表示和分析群体遗传学数据的C++库。</li>
<li>SeqAn：专注于生物数据序列分析的算法和数据结构。</li>
<li>Vcflib ：用于解析和处理VCF文件的C++库</li>
<li>Wham：直接把联想测试应用到BAM文件的基因结构变异。</li>
</ul>
<h2 id="压缩和归档库"><a href="#压缩和归档库" class="headerlink" title="压缩和归档库"></a>压缩和归档库</h2><ul>
<li>bzip2：一个完全免费，免费专利和高质量的数据压缩</li>
<li>doboz：能够快速解压缩的压缩库</li>
<li>PhysicsFS：对各种归档提供抽象访问的库，主要用于视频游戏，设计灵感部分来自于Quake3的文件子系统。</li>
<li>KArchive：用于创建，读写和操作文件档案（例如zip和 tar）的库，它通过QIODevice的一系列子类，使用gzip格式，提供了透明的压缩和解压缩的数据。</li>
<li>LZ4 ：非常快速的压缩算法</li>
<li>LZHAM ：无损压缩数据库，压缩比率跟LZMA接近，但是解压缩速度却要快得多。</li>
<li>LZMA ：7z格式默认和通用的压缩方法。</li>
<li>LZMAT ：及其快速的实时无损数据压缩库</li>
<li>miniz：单一的C源文件，紧缩&#x2F;膨胀压缩库，使用zlib兼容API，ZIP归档读写，PNG写方式。</li>
<li>Minizip：Zlib最新bug修复，支持PKWARE磁盘跨越，AES加密和IO缓冲。</li>
<li>Snappy ：快速压缩和解压缩</li>
<li>ZLib ：非常紧凑的数据流压缩库</li>
<li>ZZIPlib：提供ZIP归档的读权限。</li>
</ul>
<h2 id="并发执行和多线程"><a href="#并发执行和多线程" class="headerlink" title="并发执行和多线程"></a>并发执行和多线程</h2><ul>
<li>Boost.Compute ：用于OpenCL的C++GPU计算库</li>
<li>Bolt ：针对GPU进行优化的C++模板库</li>
<li>C++React ：用于C++11的反应性编程库</li>
<li>Intel TBB ：Intel线程构件块</li>
<li>Libclsph：基于OpenCL的GPU加速SPH流体仿真库</li>
<li>OpenCL ：并行编程的异构系统的开放标准</li>
<li>OpenMP：OpenMP API</li>
<li>Thrust ：类似于C++标准模板库的并行算法库</li>
<li>HPX ：用于任何规模的并行和分布式应用程序的通用C++运行时系统</li>
<li>VexCL ：用于OpenCL&#x2F;CUDA 的C++向量表达式模板库。</li>
<li>容器</li>
<li>C++ B-tree ：基于B树[[数据结构#<strong>树和二叉树</strong>|数据结构]]，实现命令内存容器的模板库</li>
<li>Hashmaps：C++中开放寻址哈希表算法的实现</li>
</ul>
<h2 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h2><ul>
<li>Bcrypt ：一个跨平台的文件加密工具，加密文件可以移植到所有可支持的操作系统和处理器中。</li>
<li>BeeCrypt：</li>
<li>Botan：C++加密库</li>
<li>Crypto++：一个有关加密方案的免费的C++库</li>
<li>GnuPG：OpenPGP标准的完整实现</li>
<li>GnuTLS ：实现了SSL，TLS和DTLS协议的安全通信库</li>
<li>Libgcrypt</li>
<li>libmcrypt</li>
<li>LibreSSL：免费的SSL&#x2F;TLS协议，属于2014 OpenSSL的一个分支</li>
<li>LibTomCrypt：一个非常全面的，模块化的，可移植的加密工具</li>
<li>libsodium：基于NaCI的加密库，固执己见，容易使用</li>
<li>Nettle 底层的加密库</li>
<li>OpenSSL ：一个强大的，商用的，功能齐全的，开放源代码的加密库。</li>
<li>Tiny AES128 in C ：用C实现的一个小巧，可移植的实现了AES128ESB的加密算法</li>
</ul>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><blockquote>
<p>SQL服务器，ODBC驱动程序和工具</p>
</blockquote>
<ul>
<li>hiberlite ：用于Sqlite3的C++对象关系映射</li>
<li>Hiredis：用于[[数据库#Redis|Redis数据库]]的很简单的C客户端库</li>
<li>LevelDB：快速键值存储库</li>
<li>LMDB：符合[[数据库]]四大基本元素的嵌入键值存储</li>
<li>MySQL++：封装了MySql的C API的C++ 包装器</li>
<li>RocksDB：来自Facebook的嵌入键值的快速存储</li>
<li>SQLite：一个完全嵌入式的，功能齐全的关系[[数据库]]，只有几百KB，可以正确包含到你的项目中。</li>
</ul>
<h2 id="调试库"><a href="#调试库" class="headerlink" title="调试库"></a>调试库</h2><blockquote>
<p>内存和资源泄露检测，单元测试</p>
</blockquote>
<ul>
<li>Boost.Test：Boost测试库</li>
<li>Catch：一个很时尚的，C++原生的框架，只包含头文件，用于单元测试，测试[[驱动开发]]和行为驱动开发。</li>
<li>CppUnit：由JUnit移植过来的C++测试框架</li>
<li>CTest：CMake测试驱动程序</li>
<li>googletest：谷歌C++测试框架</li>
<li>ig-debugheap：用于跟踪内存错误的多平台调试堆</li>
<li>libtap：用C语言编写测试</li>
<li>MemTrack —用于C++跟踪内存分配</li>
<li>microprofile- 跨平台的网络试图分析器</li>
<li>minUnit ：使用C写的迷你单元测试框架，只使用了两个宏</li>
<li>Remotery：用于web视图的单一C文件分析器</li>
<li>UnitTest++：轻量级的C++单元测试框架</li>
<li>游戏引擎</li>
<li>Cocos2d-x ：一个跨平台框架，用于构建2D游戏，互动图书，演示和其他图形应用程序。</li>
<li>Grit ：社区项目，用于构建一个免费的游戏引擎，实现开放的世界3D游戏。</li>
<li>Irrlicht ：C++语言编写的开源高性能的实时#D引擎</li>
<li>Polycode：C++实现的用于创建游戏的开源框架（与Lua绑定）。</li>
</ul>
<h2 id="图形用户界面"><a href="#图形用户界面" class="headerlink" title="图形用户界面"></a>图形用户界面</h2><ul>
<li>CEGUI ：很灵活的跨平台GUI库</li>
<li>FLTK ：快速，轻量级的跨平台的C++GUI工具包。</li>
<li>GTK+：用于创建图形用户界面的跨平台工具包</li>
<li>gtkmm ：用于受欢迎的GUI库GTK+的官方C++接口。</li>
<li>imgui：拥有最小依赖关系的立即模式图形用户界面</li>
<li>libRocket ：libRocket 是一个C++ HTML&#x2F;CSS 游戏接口中间件</li>
<li>MyGUI ：快速，灵活，简单的GUI</li>
<li>Ncurses：终端用户界面</li>
<li>QCustomPlot ：没有更多依赖关系的[[Qt]]绘图控件</li>
<li>Qwt ：用户与技术应用的[[Qt]] 控件</li>
<li>QwtPlot3D ：功能丰富的基于[[Qt]]&#x2F;OpenGL的C++编程库，本质上提供了一群3D控件</li>
<li>OtterUI ：OtterUI 是用于嵌入式系统和互动娱乐软件的用户界面开发解决方案</li>
<li>PDCurses 包含源代码和预编译库的公共图形函数库</li>
<li>wxWidgets C++库，允许开发人员使用一个代码库可以为widows， Mac OS X，Linux和其他平台创建应用程序</li>
</ul>
<h2 id="图形"><a href="#图形" class="headerlink" title="图形"></a>图形</h2><ul>
<li>bgfx：跨平台的渲染库</li>
<li>Cairo：支持多种输出设备的2D图形库</li>
<li>Horde3D 一个小型的3D渲染和动画引擎</li>
<li>magnum C++11和OpenGL 2D&#x2F;3D 图形引擎</li>
<li>Ogre 3D 用C++编写的一个面向场景，实时，灵活的3D渲染引擎（并非游戏引擎）</li>
<li>OpenSceneGraph 具有高性能的开源3D图形工具包</li>
<li>Panda3D 用于3D渲染和游戏开发的框架，用Python和C++编写。</li>
<li>Skia 用于绘制文字，图形和图像的完整的2D图形库</li>
<li>urho3d 跨平台的渲染和游戏引擎。</li>
</ul>
<h2 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h2><ul>
<li>Boost.GIL：通用图像库</li>
<li>CImg ：用于图像处理的小型开源C++工具包</li>
<li>CxImage ：用于加载，保存，显示和转换的图像处理和转换库，可以处理的图片格式包括 BMP, JPEG, GIF, PNG, TIFF, MNG, ICO, PCX, TGA, WMF, WBMP, JBG, J2K。</li>
<li>FreeImage ：开源库，支持现在多媒体应用所需的通用图片格式和其他格式。</li>
<li>GDCM：Grassroots DICOM 库</li>
<li>ITK：跨平台的开源图像分析系统</li>
<li>Magick++：ImageMagick程序的C++接口</li>
<li>MagickWnd：ImageMagick程序的C++接口</li>
<li>OpenCV ：开源计算机视觉类库</li>
<li>tesseract-ocr：OCR引擎</li>
<li>VIGRA ：用于图像分析通用C++计算机视觉库</li>
<li>VTK ：用于3D计算机图形学，图像处理和可视化的开源免费软件系统。</li>
</ul>
<h2 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h2><ul>
<li>gettext ：GNU &#96;gettext’</li>
<li>IBM ICU：提供Unicode 和全球化支持的C、C++ 和Java库</li>
<li>libiconv ：用于不同字符编码之间的编码转换库</li>
<li>Json</li>
<li>frozen ：C&#x2F;C++的Json解析生成器</li>
<li>Jansson ：进行编解码和处理Json数据的C语言库</li>
<li>jbson ：C++14中构建和迭代BSON data,和Json 文档的库</li>
<li>JeayeSON：非常健全的C++ JSON库，只包含头文件</li>
<li>JSON++ ：C++ JSON 解析器</li>
<li>json-parser：用可移植的ANSI C编写的JSON解析器，占用内存非常少</li>
<li>json11 ：一个迷你的C++11 JSON库</li>
<li>jute ：非常简单的C++ JSON解析器</li>
<li>ibjson：C语言中的JSON解析和打印库，很容易和任何模型集成。</li>
<li>libjson：轻量级的JSON库</li>
<li>PicoJSON：C++中JSON解析序列化，只包含头文件</li>
<li>qt-json ：用于JSON数据和 QVariant层次间的相互解析的简单类</li>
<li>QJson：将JSON数据映射到QVariant对象的基于[[Qt]]的库</li>
<li>RapidJSON：用于C++的快速JSON 解析生成器，包含SAX和DOM两种风格的API</li>
<li>YAJL ：C语言中快速流JSON解析库</li>
</ul>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><ul>
<li>Boost.Log ：设计非常模块化，并且具有扩展性</li>
<li>easyloggingpp：C++日志库，只包含单一的头文件。</li>
<li>Log4cpp ：一系列C++类库，灵活添加日志到文件，系统日志，IDSA和其他地方。</li>
<li>templog：轻量级C++库，可以添加日志到你的C++应用程序中</li>
</ul>
<h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><ul>
<li>Caffe ：快速的神经网络框架</li>
<li>CCV ：以C语言为核心的现代计算机视觉库</li>
<li>mlpack ：可扩展的C++机器学习库</li>
<li>OpenCV：开源计算机视觉库</li>
<li>Recommender：使用协同过滤进行产品推荐&#x2F;建议的C语言库。</li>
<li>SHOGUN：Shogun 机器学习工具</li>
<li>sofia-ml ：用于机器学习的快速增量算法套件</li>
</ul>
<h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><ul>
<li>Armadillo ：高质量的C++线性代数库，速度和易用性做到了很好的平衡。语法和MatlAB很相似</li>
<li>blaze：高性能的C++数学库，用于密集和稀疏算法。</li>
<li>ceres-solver ：来自谷歌的C++库，用于建模和解决大型复杂非线性最小平方问题。</li>
<li>CGal：高效，可靠的集合[[算法]]集合</li>
<li>cml ：用于游戏和图形的免费C++数学库</li>
<li>Eigen ：高级C++模板头文件库，包括线性代数，矩阵，向量操作，数值解决和其他相关的[[算法]]。</li>
<li>GMTL：数学图形模板库是一组广泛实现基本图形的工具。</li>
<li>GMP：用于个高精度计算的C&#x2F;C++库，处理有符号整数，有理数和浮点数。</li>
</ul>
<h2 id="多媒体"><a href="#多媒体" class="headerlink" title="多媒体"></a>多媒体</h2><ul>
<li>GStreamer ：构建媒体处理组件图形的库</li>
<li>LIVE555 Streaming Media ：使用开放标准协议(RTP&#x2F;RTCP, RTSP, SIP) 的多媒体流库</li>
<li>libVLC ：libVLC (VLC SDK)媒体框架</li>
<li>QtAv：基于[[Qt]]和FFmpeg的多媒体播放框架，能够帮助你轻而易举地编写出一个播放器</li>
<li>SDL ：简单直控媒体层</li>
<li>SFML ：快速，简单的多媒体库</li>
</ul>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><ul>
<li>ACE：C++面向对象网络变成工具包</li>
<li>Boost.Asio：用于网络和底层I&#x2F;O编程的跨平台的C++库</li>
<li>Casablanca：C++ REST SDK</li>
<li>cpp-netlib：高级[[网络编程]]的开源库集合</li>
<li>Dyad.c：C语言的异步网络</li>
<li>libcurl :多协议文件传输库</li>
<li>Mongoose：非常轻量级的网络服务器</li>
<li>Muduo ：用于Linux多线程服务器的C++非阻塞网络库</li>
<li>net_skeleton ：C&#x2F;C++的TCP 客户端&#x2F;服务器库</li>
<li>nope.c ：基于C语言的超轻型软件平台，用于可扩展的服务器端和网络应用。对于C编程人员，可以考虑node.js</li>
<li>Onion :C语言HTTP服务器库，其设计为轻量级，易使用。</li>
<li>POCO：用于构建网络和基于互联网应用程序的C++类库，可以运行在桌面，服务器，移动和嵌入式系统。</li>
<li>RakNet：为游戏开发人员提供的跨平台的开源C++网络引擎。</li>
<li>Tuf o ：用于[[Qt]]之上的C++构建的异步Web框架。</li>
<li>WebSocket++ ：基于C++&#x2F;Boost Aiso的websocket 客户端&#x2F;服务器库</li>
<li>ZeroMQ ：高速，模块化的异步通信</li>
</ul>
<h2 id="物理学"><a href="#物理学" class="headerlink" title="物理学"></a>物理学</h2><blockquote>
<p>动力学仿真引擎</p>
</blockquote>
<ul>
<li>Box2D：2D的游戏物理引擎。</li>
<li>Bullet ：3D的游戏物理引擎。</li>
<li>Chipmunk ：快速，轻量级的2D游戏物理库</li>
<li>LiquidFun：2D的游戏物理引擎</li>
<li>ODE ：开放动力学引擎-开源，高性能库，模拟刚体动力学。</li>
<li>ofxBox2d：Box2D开源框架包装器。</li>
<li>Simbody ：高性能C++多体动力学&#x2F;物理库，模拟关节生物力学和机械系统，像车辆，机器人和人体骨骼。</li>
</ul>
<h2 id="机器人学"><a href="#机器人学" class="headerlink" title="机器人学"></a>机器人学</h2><ul>
<li>MOOS-IvP ：一组开源C++模块，提供机器人平台的自主权，尤其是自主的海洋车辆。</li>
<li>MRPT：移动机器人编程工具包</li>
<li>PCL ：点云库是一个独立的，大规模的开放项目，用于2D&#x2F;3D图像和点云处理。</li>
<li>Robotics Library (RL)：一个独立的C++库，包括机器人动力学，运动规划和控制。</li>
<li>RobWork：一组C++库的集合，用于机器人系统的仿真和控制。</li>
<li>ROS ：机器人操作系统，提供了一些库和工具帮助软件开发人员创建机器人应用程序。</li>
</ul>
<h2 id="科学计算"><a href="#科学计算" class="headerlink" title="科学计算"></a>科学计算</h2><ul>
<li>FFTW :用一维或者多维计算DFT的C语言库。</li>
<li>GSL：GNU科学库。</li>
</ul>
<h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><ul>
<li>ChaiScript ：用于C++的易于使用的嵌入式脚本语言。</li>
<li>Lua ：用于配置文件和基本应用程序脚本的小型快速脚本引擎。</li>
<li>luacxx：用于创建Lua绑定的C++ 11 API</li>
<li>SWIG ：一个可以让你的C++代码链接到JavaScript，Perl，PHP，Python，Tcl和Ruby的包装器&#x2F;接口生成器</li>
<li>V7：嵌入式的JavaScript 引擎。</li>
<li>V8 ：谷歌的快速JavaScript引擎，可以被嵌入到任何C++应用程序中。</li>
</ul>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><ul>
<li>Cap’n Proto ：快速数据交换格式和RPC系统。</li>
<li>cereal ：C++11 序列化库</li>
<li>FlatBuffers ：内存高效的序列化库</li>
<li>MessagePack ：C&#x2F;C++的高效二进制序列化库，例如 JSON</li>
<li>protobuf ：协议缓冲，谷歌的数据交换格式。</li>
<li>protobuf-c ：C语言的协议缓冲实现</li>
<li>SimpleBinaryEncoding：用于低延迟应用程序的对二进制格式的应用程序信息的编码和解码。</li>
<li>Thrift ：高效的跨语言IPC&#x2F;RPC，用于C++，Java，Python，PHP，C#和其它多种语言中，最初由Twitter开发。</li>
</ul>
<h2 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h2><ul>
<li>libvpx ：VP8&#x2F;VP9编码解码SDK</li>
<li>FFmpeg ：一个完整的，跨平台的解决方案，用于记录，转换视频和音频流。</li>
<li>libde265 ：开放的h.265视频编解码器的实现。</li>
<li>OpenH264：开源H.364 编解码器。</li>
<li>Theora ：免费开源的视频压缩格式。</li>
</ul>
<h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><ul>
<li>CarpVM：C中有趣的VM，让我们一起来看看这个。</li>
<li>MicroPython ：旨在实现单片机上Python3.x的实现</li>
<li>TinyVM：用纯粹的ANSI C编写的小型，快速，轻量级的虚拟机。</li>
</ul>
<h2 id="Web应用框架"><a href="#Web应用框架" class="headerlink" title="Web应用框架"></a>Web应用框架</h2><ul>
<li>Civetweb ：提供易于使用，强大的，C&#x2F;C++嵌入式Web服务器，带有可选的CGI，SSL和Lua支持。</li>
<li>CppCMS ：免费高性能的Web开发框架（不是 CMS）.</li>
<li>Crow ：一个C++微型web框架（灵感来自于Python Flask）</li>
<li>Kore :使用C语言开发的用于web应用程序的超快速和灵活的web服务器&#x2F;框架。</li>
<li>libOnion：轻量级的库，帮助你使用C编程语言创建web服务器。</li>
<li>QDjango：使用C++编写的，基于[[Qt]]库的web框架，试图效仿Django API，因此得此名。</li>
<li>Wt ：开发Web应用的C++库。</li>
</ul>
<h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><blockquote>
<p>XML就是个垃圾，xml的解析很烦人，对于计算机它也是个灾难。这种糟糕的东西完全没有存在的理由了。-Linus Torvalds</p>
</blockquote>
<ul>
<li>Expat ：用C语言编写的xml解析库</li>
<li>Libxml2 ：Gnome的xml C解析器和工具包</li>
<li>libxml++ ：C++的xml解析器</li>
<li>PugiXML ：用于C++的，支持XPath的轻量级，简单快速的XML解析器。</li>
<li>RapidXml ：试图创建最快速的XML解析器，同时保持易用性，可移植性和合理的W3C兼容性。</li>
<li>TinyXML ：简单小型的C++XML解析器，可以很容易地集成到其它项目中。</li>
<li>TinyXML2：简单快速的C++CML解析器，可以很容易集成到其它项目中。</li>
<li>TinyXML++：TinyXML的一个全新的接口，使用了C++的许多许多优势，模板，异常和更好的异常处理。</li>
<li>Xerces-C++ ：用可移植的C++的子集编写的XML验证解析器。</li>
</ul>
<h2 id="多项混杂"><a href="#多项混杂" class="headerlink" title="多项混杂"></a>多项混杂</h2><blockquote>
<p>一些有用的库或者工具，但是不适合上面的分类，或者还没有分类。</p>
</blockquote>
<ul>
<li>C++ Format ：C++的小型，安全和快速格式化库</li>
<li>casacore ：从aips++ 派生的一系列C++核心库</li>
<li>cxx-prettyprint：用于C++容器的打印库</li>
<li>DynaPDF ：易于使用的PDF生成库</li>
<li>gcc-poison ：帮助开发人员禁止应用程序中的不安全的C&#x2F;C++函数的简单的头文件。</li>
<li>googlemock：编写和使用C++模拟类的库</li>
<li>HTTP Parser ：C的http请求&#x2F;响应解析器</li>
<li>libcpuid ：用于x86 CPU检测盒特征提取的小型C库</li>
<li>libevil ：许可证管理器</li>
<li>libusb：允许移动访问USB设备的通用USB库</li>
<li>PCRE：正则表达式C库，灵感来自于Perl中正则表达式的功能。</li>
<li>Remote Call Framework ：C++的进程间通信框架。</li>
<li>Scintilla ：开源的代码编辑控件</li>
<li>Serial Communication Library ：C++语言编写的跨平台，串口库。</li>
<li>SDS：C的简单动态字符串库</li>
<li>SLDR ：超轻的DNS解析器</li>
<li>SLRE：超轻的正则表达式库</li>
<li>Stage ：移动机器人模拟器</li>
<li>VarTypes：C++&#x2F;Qt4功能丰富，面向对象的管理变量的框架。</li>
<li>ZBar：‘条形码扫描器’库，可以扫描照片，图片和视频流中的条形码，并返回结果。</li>
<li>CppVerbalExpressions ：易于使用的C++正则表达式</li>
<li>QtVerbalExpressions：基于C++ VerbalExpressions 库的[[Qt]]库</li>
<li>PHP-CPP：使用C++来构建PHP扩展的库</li>
<li>Better String ：C的另一个字符串库，功能更丰富，但是没有缓冲溢出问题，还包含了一个C++包装器。</li>
</ul>
<h2 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h2><ul>
<li>C&#x2F;C++编译器列表</li>
<li>Clang :由苹果公司开发的</li>
<li>GCC：GNU编译器集合</li>
<li>Intel C++ Compiler ：由英特尔公司开发</li>
<li>LLVM ：模块化和可重用编译器和工具链技术的集合</li>
<li>Microsoft Visual C++ ：MSVC，由微软公司开发</li>
<li>Open WatCom ：Watcom，C，C++和Fortran交叉编译器和工具</li>
<li>TCC ：轻量级的C语言编译器</li>
</ul>
<h2 id="在线C-C-编译器列表"><a href="#在线C-C-编译器列表" class="headerlink" title="在线C&#x2F;C++编译器列表"></a>在线C&#x2F;C++编译器列表</h2><ul>
<li>codepad ：在线编译器&#x2F;解释器，一个简单的协作工具</li>
<li>CodeTwist：一个简单的在线编译器&#x2F;解释器，你可以粘贴的C,C++或者Java代码，在线执行并查看结果</li>
<li>coliru ：在线编译器&#x2F;shell， 支持各种C++编译器</li>
<li>Compiler Explorer：交互式编译器，可以进行汇编输出</li>
<li>CompileOnline：Linux上在线编译和执行C++程序</li>
<li>Ideone ：一个在线编译器和调试工具，允许你在线编译源代码并执行，支持60多种编程语言。</li>
</ul>
<h2 id="C-C-调试器列表"><a href="#C-C-调试器列表" class="headerlink" title="C&#x2F;C++调试器列表"></a>C&#x2F;C++调试器列表</h2><ul>
<li>Comparison of debuggers ：来自维基百科的调试器列表</li>
<li>GDB ：GNU调试器</li>
<li>Valgrind：内存调试，内存泄露检测，性能分析工具。</li>
</ul>
<h2 id="C-C-集成开发环境（IDE）列表"><a href="#C-C-集成开发环境（IDE）列表" class="headerlink" title="C&#x2F;C++集成开发环境（IDE）列表"></a>C&#x2F;C++集成开发环境（IDE）列表</h2><ul>
<li>AppCode ：构建与JetBrains’ IntelliJ IDEA 平台上的用于Objective-C，C,C++，Java和Java开发的集成开发环境</li>
<li>CLion：来自JetBrains的跨平台的C&#x2F;C++的集成开发环境</li>
<li>Code::Blocks ：免费C，C++和Fortran的集成开发环境</li>
<li>CodeLite ：另一个跨平台的免费的C&#x2F;C++集成开发环境</li>
<li>Dev-C++：可移植的C&#x2F;C++&#x2F;C++11集成开发环境</li>
<li>Eclipse CDT：基于Eclipse平台的功能齐全的C和C++集成开发环境</li>
<li>Geany ：轻量级的快速，跨平台的集成开发环境。</li>
<li>IBM VisualAge ：来自IBM的家庭计算机集成开发环境。</li>
<li>Irony-mode：由libclang驱动的用于Emacs的C&#x2F;C++微模式</li>
<li>KDevelop：免费开源集成开发环境</li>
<li>Microsoft Visual Studio ：来自微软的集成开发环境</li>
<li>NetBeans ：主要用于Java开发的的集成开发环境，也支持其他语言，尤其是PHP，C&#x2F;C++和HTML5。</li>
<li>Qt Creator：跨平台的C++，Javascript和QML集成开发环境，也是Qt SDK的一部分。</li>
<li>rtags：C&#x2F;C++的客户端服务器索引，用于 跟基于clang的emacs的集成</li>
<li>Xcode ：由苹果公司开发</li>
<li>YouCompleteMe：一个用于Vim的根据你敲的代码快速模糊搜索并进行代码补全的引擎。</li>
</ul>
<h2 id="构建系统"><a href="#构建系统" class="headerlink" title="构建系统"></a>构建系统</h2><ul>
<li>Bear ：用于为clang工具生成编译[[数据库]]的工具</li>
<li>Biicode：基于文件的简单依赖管理器。</li>
<li>CMake ：跨平台的免费开源软件用于管理软件使用独立编译的方法进行构建的过程。</li>
<li>CPM：基于CMake和Git的C++包管理器</li>
<li>FASTBuild：高性能，开源的构建系统，支持高度可扩展性的编译，缓冲和网络分布。</li>
<li>Ninja ：专注于速度的小型构建系统</li>
<li>Scons ：使用Python scipt 配置的软件构建工具</li>
<li>tundra ：高性能的代码构建系统，甚至对于非常大型的软件项目，也能提供最好的增量构建次数。</li>
<li>tup：基于文件的构建系统，用于后台监控变化的文件。</li>
</ul>
<h2 id="静态代码分析"><a href="#静态代码分析" class="headerlink" title="静态代码分析"></a>静态代码分析</h2><blockquote>
<p>提高质量，减少瑕疵的代码分析工具列表</p>
</blockquote>
<ul>
<li>Cppcheck ：静态C&#x2F;C++代码分析工具</li>
<li>include-what-you-use ：使用clang进行代码分析的工具，可以#include在C和C++文件中。</li>
<li>OCLint ：用于C，C++和Objective-C的静态源代码分析工具，用于提高质量，减少瑕疵。</li>
<li>Clang Static Analyzer：查找C，C++和Objective-C程序bug的源代码分析工具</li>
<li>List of tools for static code analysis ：来自维基百科的静态代码分析工具列表W</li>
</ul>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4" title="头像" alt="头像"></a><div class="post-copyright__author_name">ZEROKO14</div><div class="post-copyright__author_desc">zeroko14's blog</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://che77a38.github.io/posts/C++%E5%9F%BA%E7%A1%80/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://che77a38.github.io/posts/C++%E5%9F%BA%E7%A1%80/')">C++基础</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://che77a38.github.io/posts/C++%E5%9F%BA%E7%A1%80/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=C++基础&amp;url=https://che77a38.github.io/posts/C++%E5%9F%BA%E7%A1%80/&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://che77a38.github.io" target="_blank">ZEROKO14的个人博客</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"></div></div></div><div class="post_share"><div class="social-share" data-image="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/WPF/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info"></div></div></a></div><div class="next-post pull-right"><a href="/posts/CSharp%E5%85%A5%E9%97%A8/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">CSharp入门</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description">欢迎来到ZEROKO14的个人博客</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">ZEROKO14</h1><div class="author-info__desc">zeroko14's blog</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/che77a38" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">C++概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%80%A7%E5%92%8C%E6%A0%87%E5%87%86"><span class="toc-number">1.1.</span> <span class="toc-text">可移植性和标准</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84c-%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.2.</span> <span class="toc-text">简单的c++程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%EF%BC%9A"><span class="toc-number">1.3.</span> <span class="toc-text">注意：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#c-%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B2%A1%E6%9C%89-h%EF%BC%9F"><span class="toc-number">1.3.1.</span> <span class="toc-text">c++头文件为什么没有.h？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#using-namespace-std-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.3.2.</span> <span class="toc-text">using namespace std 是什么?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E6%80%9D%E6%83%B3"><span class="toc-number">1.4.</span> <span class="toc-text">面向过程思想</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3"><span class="toc-number">1.5.</span> <span class="toc-text">面向对象思想</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-number">1.5.1.</span> <span class="toc-text">面向对象三大特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E7%89%B9%E6%80%A7"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">封装特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%89%B9%E6%80%A7"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">继承特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%89%B9%E6%80%A7"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">多态特性</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E5%AF%B9C%E7%9A%84%E6%89%A9%E5%B1%95"><span class="toc-number">2.</span> <span class="toc-text">C++对C的扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.1.</span> <span class="toc-text">::作用域运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E9%99%90%E5%AE%9A%E5%90%8D%E5%AD%97%E6%9F%A5%E6%89%BE"><span class="toc-number">2.1.1.</span> <span class="toc-text">无限定名字查找</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8D%E5%AD%97%E6%8E%A7%E5%88%B6"><span class="toc-number">2.2.</span> <span class="toc-text">名字控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4-namespace"><span class="toc-number">2.2.1.</span> <span class="toc-text">C++命名空间(namespace)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%BD%BF%E7%94%A8%E8%AF%AD%E6%B3%95"><span class="toc-number">2.2.2.</span> <span class="toc-text">命名空间使用语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">创建一个命名空间:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#using%E5%A3%B0%E6%98%8E"><span class="toc-number">2.2.3.</span> <span class="toc-text">using声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#using%E7%BC%96%E8%AF%91%E6%8C%87%E4%BB%A4"><span class="toc-number">2.2.4.</span> <span class="toc-text">using编译指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E5%AF%B9C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%A2%9E%E5%BC%BA%E4%BB%A5%E5%8F%8A%E6%89%A9%E5%B1%95"><span class="toc-number">2.3.</span> <span class="toc-text">C++对C语言的增强以及扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E6%A3%80%E6%B5%8B%E5%A2%9E%E5%BC%BA"><span class="toc-number">2.3.1.</span> <span class="toc-text">全局变量检测增强</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A3%80%E6%B5%8B%E5%A2%9E%E5%BC%BA"><span class="toc-number">2.3.2.</span> <span class="toc-text">函数检测增强</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%A3%80%E6%B5%8B%E5%A2%9E%E5%BC%BA"><span class="toc-number">2.3.3.</span> <span class="toc-text">类型转换检测增强</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#struct%E5%A2%9E%E5%BC%BA"><span class="toc-number">2.3.4.</span> <span class="toc-text">struct增强</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bool%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%89%A9%E5%B1%95"><span class="toc-number">2.3.5.</span> <span class="toc-text">bool数据类型扩展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6%E5%A2%9E%E5%BC%BA"><span class="toc-number">2.3.6.</span> <span class="toc-text">三目运算符增强</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.3.6.1.</span> <span class="toc-text">[左值和右值概念]</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-C-%E4%B8%ADconst%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.3.7.</span> <span class="toc-text">C&#x2F;C++中const的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#C%E4%B8%AD%E7%9A%84const"><span class="toc-number">2.3.7.1.</span> <span class="toc-text">C中的const</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E4%B8%AD%E7%9A%84const"><span class="toc-number">2.3.7.2.</span> <span class="toc-text">C++中的const</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-C-%E4%B8%ADconst%E5%BC%82%E5%90%8C%E6%80%BB%E7%BB%93"><span class="toc-number">2.3.7.3.</span> <span class="toc-text">C&#x2F;C++中const异同总结</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E5%B1%9E%E6%80%A7%E5%8C%BA%E5%88%AB"><span class="toc-number">2.3.7.3.1.</span> <span class="toc-text">链接属性区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E5%8C%BA%E5%88%AB"><span class="toc-number">2.3.7.3.2.</span> <span class="toc-text">修改区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#C-%E4%B8%ADconst%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">2.3.7.3.3.</span> <span class="toc-text">C++中const分配内存的情况</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%BD%E9%87%8F%E4%BB%A5const%E6%9B%BF%E6%8D%A2-define"><span class="toc-number">2.4.</span> <span class="toc-text">尽量以const替换#define</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8-reference"><span class="toc-number">2.5.</span> <span class="toc-text">引用(reference)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">2.5.1.</span> <span class="toc-text">引用基本用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-number">2.5.2.</span> <span class="toc-text">函数中的引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%81%9A%E5%8F%82%E6%95%B0"><span class="toc-number">2.5.2.1.</span> <span class="toc-text">引用做参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%81%9A%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">2.5.2.2.</span> <span class="toc-text">引用做返回值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">2.5.3.</span> <span class="toc-text">引用的本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8"><span class="toc-number">2.5.4.</span> <span class="toc-text">指针引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E5%BC%95%E7%94%A8"><span class="toc-number">2.5.5.</span> <span class="toc-text">常量引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0-inline-function"><span class="toc-number">2.6.</span> <span class="toc-text">内联函数(inline function)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E7%9A%84%E5%BC%95%E5%87%BA"><span class="toc-number">2.6.1.</span> <span class="toc-text">内联函数的引出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.6.2.</span> <span class="toc-text">内联函数基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-number">2.6.3.</span> <span class="toc-text">内联函数和编译器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0"><span class="toc-number">2.7.</span> <span class="toc-text">函数的默认参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%8D%A0%E4%BD%8D%E5%8F%82%E6%95%B0"><span class="toc-number">2.8.</span> <span class="toc-text">函数的占位参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD-overload"><span class="toc-number">2.9.</span> <span class="toc-text">函数重载(overload)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">2.9.1.</span> <span class="toc-text">函数重载基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">2.9.2.</span> <span class="toc-text">函数重载实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#extern-%E2%80%9CC%E2%80%9D%E6%B5%85%E6%9E%90"><span class="toc-number">2.9.3.</span> <span class="toc-text">extern “C”浅析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%88%E6%9E%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A"><span class="toc-number">2.9.3.1.</span> <span class="toc-text">终极解决方案：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.10.</span> <span class="toc-text">类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%B0%81%E8%A3%85"><span class="toc-number">2.10.1.</span> <span class="toc-text">类的封装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">2.10.1.1.</span> <span class="toc-text">封装:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-number">2.10.1.2.</span> <span class="toc-text">访问权限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%BD%E9%87%8F%E5%B0%86%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E8%AE%BE%E7%BD%AE%E4%B8%BAprivate"><span class="toc-number">2.10.1.3.</span> <span class="toc-text">尽量将成员变量设置为private</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84"><span class="toc-number">2.10.2.</span> <span class="toc-text">对象的构造和析构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">2.10.2.1.</span> <span class="toc-text">构造函数和析构函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%86%E7%B1%BB%E5%8F%8A%E8%B0%83%E7%94%A8"><span class="toc-number">2.10.2.1.1.</span> <span class="toc-text">构造函数的分类及调用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%A0%E5%8F%82%E6%9E%84%E9%80%A0%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F%E6%B3%A8%E6%84%8F%E7%82%B9%EF%BC%9A%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">2.10.2.1.2.</span> <span class="toc-text">无参构造调用方式注意点：（重点）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%89%E5%8F%82%E6%9E%84%E9%80%A0%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">2.10.2.1.3.</span> <span class="toc-text">有参构造调用方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B91"><span class="toc-number">2.10.2.1.4.</span> <span class="toc-text">[注意事项1]</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B92"><span class="toc-number">2.10.2.1.5.</span> <span class="toc-text">[注意事项2]</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B93"><span class="toc-number">2.10.2.1.6.</span> <span class="toc-text">[注意事项3]</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA"><span class="toc-number">2.10.2.2.</span> <span class="toc-text">析构函数的调用时机</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E8%B0%83%E7%94%A8%E6%9E%90%E6%9E%84%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%90%8E%E6%9E%9C"><span class="toc-number">2.10.2.2.1.</span> <span class="toc-text">显示调用析构带来的后果</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA"><span class="toc-number">2.10.2.3.</span> <span class="toc-text">拷贝构造函数的调用时机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E8%A7%84%E5%88%99"><span class="toc-number">2.10.2.4.</span> <span class="toc-text">构造函数自动生成规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">2.10.2.5.</span> <span class="toc-text">深拷贝和浅拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">2.10.2.5.1.</span> <span class="toc-text">浅拷贝</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">2.10.2.5.2.</span> <span class="toc-text">深拷贝</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#explicit%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">2.10.2.6.</span> <span class="toc-text">explicit关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="toc-number">2.10.2.7.</span> <span class="toc-text">初始化列表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E6%88%90%E5%91%98"><span class="toc-number">2.10.3.</span> <span class="toc-text">类对象作为成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA"><span class="toc-number">2.10.4.</span> <span class="toc-text">动态对象创建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#C%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E6%96%B9%E6%B3%95"><span class="toc-number">2.10.4.1.</span> <span class="toc-text">C动态分配内存方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#new-operator"><span class="toc-number">2.10.4.1.1.</span> <span class="toc-text">new operator</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#malloc%E5%92%8Cnew%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.10.4.1.1.1.</span> <span class="toc-text">malloc和new的区别</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#placement-new%E6%9C%BA%E5%88%B6"><span class="toc-number">2.10.4.1.2.</span> <span class="toc-text">placement new机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#delete-operator"><span class="toc-number">2.10.4.1.3.</span> <span class="toc-text">delete operator</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E6%95%B0%E7%BB%84%E7%9A%84new%E5%92%8Cdelete"><span class="toc-number">2.10.4.1.4.</span> <span class="toc-text">用于数组的new和delete</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-number">2.10.4.1.5.</span> <span class="toc-text">[注意]</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8new%E5%92%8Cdelete%E9%87%87%E7%94%A8%E7%9B%B8%E5%90%8C%E5%BD%A2%E5%BC%8F"><span class="toc-number">2.10.4.1.6.</span> <span class="toc-text">使用new和delete采用相同形式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E7%B1%BB%E5%92%8C%E5%B1%80%E9%83%A8%E7%B1%BB"><span class="toc-number">2.10.5.</span> <span class="toc-text">嵌套类和局部类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%EF%BC%88static%EF%BC%89"><span class="toc-number">2.11.</span> <span class="toc-text">静态成员（static）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">2.11.1.</span> <span class="toc-text">静态成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">2.11.2.</span> <span class="toc-text">静态成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%B1%9E%E6%80%A7"><span class="toc-number">2.11.3.</span> <span class="toc-text">const静态成员属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.11.4.</span> <span class="toc-text">静态成员实现单例模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E5%88%9D%E6%8E%A2"><span class="toc-number">2.12.</span> <span class="toc-text">C++面向对象模型初探</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">2.12.1.</span> <span class="toc-text">成员变量和函数的存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this%E6%8C%87%E9%92%88"><span class="toc-number">2.12.2.</span> <span class="toc-text">this指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#this%E6%8C%87%E9%92%88%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">2.12.2.1.</span> <span class="toc-text">this指针工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#this%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.12.2.2.</span> <span class="toc-text">this指针的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">2.12.2.3.</span> <span class="toc-text">空指针访问成员函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E5%85%B3%E9%94%AE%E8%AF%8D-const"><span class="toc-number">2.12.3.</span> <span class="toc-text">常量关键词(const)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#const%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">2.12.3.1.</span> <span class="toc-text">const修饰成员函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#const%E4%BF%AE%E9%A5%B0%E5%AF%B9%E8%B1%A1-%E5%B8%B8%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.12.3.2.</span> <span class="toc-text">const修饰对象(常对象)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8B%E5%85%83"><span class="toc-number">2.12.4.</span> <span class="toc-text">友元</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E8%AF%AD%E6%B3%95"><span class="toc-number">2.12.4.1.</span> <span class="toc-text">友元语法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">2.12.5.</span> <span class="toc-text">运算符重载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%EF%BC%9A"><span class="toc-number">2.12.5.1.</span> <span class="toc-text">基本语法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E8%BD%BD%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.12.5.2.</span> <span class="toc-text">可重载的运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">2.12.5.3.</span> <span class="toc-text">加号运算符重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A6%E7%A7%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.12.5.4.</span> <span class="toc-text">左移运算符&lt;&lt;重载</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%96%B9%E5%BC%8F%E9%87%8D%E8%BD%BD%E5%B7%A6%E7%A7%BB%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%9A"><span class="toc-number">2.12.5.4.1.</span> <span class="toc-text">成员函数方式重载左移运算符：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0%E6%96%B9%E5%BC%8F%E9%87%8D%E8%BD%BD%E5%B7%A6%E7%A7%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.12.5.4.2.</span> <span class="toc-text">全局函数方式重载左移运算符</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%A2%9E%E8%87%AA%E5%87%8F-%E2%80%93-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">2.12.5.5.</span> <span class="toc-text">自增自减(++&#x2F;–)运算符重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E8%BF%90%E7%AE%97%E7%AC%A6-%E3%80%81-%E9%87%8D%E8%BD%BD"><span class="toc-number">2.12.5.6.</span> <span class="toc-text">指针运算符(*、-&gt;)重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6-%E9%87%8D%E8%BD%BD"><span class="toc-number">2.12.5.7.</span> <span class="toc-text">赋值运算符&#x3D;重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E6%A0%87%E8%BF%90%E7%AE%97%E7%AC%A6-%E9%87%8D%E8%BD%BD"><span class="toc-number">2.12.5.8.</span> <span class="toc-text">下标运算符[]重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">2.12.5.9.</span> <span class="toc-text">关系运算符重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6-%E9%87%8D%E8%BD%BD"><span class="toc-number">2.12.5.10.</span> <span class="toc-text">函数调用运算符()重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E8%A6%81%E9%87%8D%E8%BD%BD-%E3%80%81"><span class="toc-number">2.12.5.11.</span> <span class="toc-text">不要重载&amp;&amp;、||</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E6%80%BB%E7%BB%93"><span class="toc-number">2.12.5.12.</span> <span class="toc-text">运算符重载总结</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%99%84%E5%BD%95%EF%BC%9A%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E7%BB%93%E5%90%88%E6%80%A7"><span class="toc-number">2.12.5.12.1.</span> <span class="toc-text">附录：运算符和结合性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">2.12.6.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.12.6.1.</span> <span class="toc-text">继承基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="toc-number">2.12.6.2.</span> <span class="toc-text">派生类访问控制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E5%9F%BA%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">2.12.6.2.1.</span> <span class="toc-text">虚基类的构造函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">2.12.7.</span> <span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%88%B6%E7%B1%BB%E5%BC%95%E7%94%A8-%E6%8C%87%E5%90%91%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">2.12.7.1.</span> <span class="toc-text">父类引用&#x2F;指向子类对象的四种方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81%E5%8E%9F%E7%90%86"><span class="toc-number">2.12.7.2.</span> <span class="toc-text">动态多态原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3"><span class="toc-number">2.12.7.2.1.</span> <span class="toc-text">原理详解</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%90%91%E4%B8%8A%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%8F%8A%E9%97%AE%E9%A2%98"><span class="toc-number">2.12.7.2.1.1.</span> <span class="toc-text">向上类型转换及问题</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BF%9F%E7%BB%91%E5%AE%9A%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88%E5%8E%9F%E7%90%86"><span class="toc-number">2.12.7.2.1.2.</span> <span class="toc-text">迟绑定实现方案原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E8%AF%A6%E8%A7%A3"><span class="toc-number">2.12.7.3.</span> <span class="toc-text">内存布局详解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E7%BB%A7%E6%89%BF%E4%B8%AD%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">2.12.7.3.1.</span> <span class="toc-text">单继承中虚函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">2.12.7.3.2.</span> <span class="toc-text">多重继承中的虚函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E4%B8%AD%E5%90%8C%E6%97%B6%E5%AD%98%E5%9C%A8%E8%99%9A%E7%BB%A7%E6%89%BF%E5%92%8C%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">2.12.7.3.3.</span> <span class="toc-text">多重继承中同时存在虚继承和虚函数</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E8%99%9A%E8%A1%A8%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">2.12.7.3.3.1.</span> <span class="toc-text">多继承中的虚表内存布局</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E5%AE%9E%E9%99%85%E5%BC%80%E5%8F%91%E6%84%8F%E4%B9%89"><span class="toc-number">2.12.7.4.</span> <span class="toc-text">多态的实际开发意义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">2.12.7.5.</span> <span class="toc-text">纯虚函数和抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">2.12.7.5.0.1.</span> <span class="toc-text">纯虚函数和多继承</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%AA%E6%9C%89%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">2.12.7.5.0.2.</span> <span class="toc-text">只有纯虚函数的抽象类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%9E%90%E6%9E%84%E5%92%8C%E7%BA%AF%E8%99%9A%E6%9E%90%E6%9E%84"><span class="toc-number">2.12.7.6.</span> <span class="toc-text">虚析构和纯虚析构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%86%99-%E9%87%8D%E8%BD%BD-%E9%87%8D%E5%AE%9A%E4%B9%89-%E5%8C%BA%E5%88%AB"><span class="toc-number">2.12.7.7.</span> <span class="toc-text">重写 重载 重定义 区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E4%B8%8E%E5%88%AB%E7%9A%84%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8C%BA%E5%88%AB%E7%9B%98%E7%82%B9"><span class="toc-number">2.12.7.8.</span> <span class="toc-text">多态与别的语言的区别盘点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E5%9F%9F"><span class="toc-number">2.13.</span> <span class="toc-text">位域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF"><span class="toc-number">2.14.</span> <span class="toc-text">模板</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-number">2.14.1.</span> <span class="toc-text">函数模板</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E5%8C%BA%E5%88%AB"><span class="toc-number">2.14.1.1.</span> <span class="toc-text">函数模板和普通函数区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E8%A7%84%E5%88%99"><span class="toc-number">2.14.1.2.</span> <span class="toc-text">函数模板和普通函数的调用规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90"><span class="toc-number">2.14.1.3.</span> <span class="toc-text">函数模板机制原理剖析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%88%86%E6%96%87%E4%BB%B6%E7%BC%96%E5%86%99"><span class="toc-number">2.14.1.4.</span> <span class="toc-text">函数模板分文件编写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%8C%96"><span class="toc-number">2.14.1.5.</span> <span class="toc-text">函数模板特化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="toc-number">2.14.2.</span> <span class="toc-text">类模板</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%81%9A%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">2.14.2.1.</span> <span class="toc-text">类模板做函数参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%B4%BE%E7%94%9F"><span class="toc-number">2.14.2.2.</span> <span class="toc-text">类模板和派生</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E6%B4%BE%E7%94%9F%E6%99%AE%E9%80%9A%E7%B1%BB"><span class="toc-number">2.14.2.2.1.</span> <span class="toc-text">类模板派生普通类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E6%B4%BE%E7%94%9F%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="toc-number">2.14.2.2.2.</span> <span class="toc-text">类模板派生类模板</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%AD%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%B1%BB%E5%A4%96%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.14.2.2.3.</span> <span class="toc-text">类模板中的成员函数类外实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%88%86%E6%96%87%E4%BB%B6%E7%BC%96%E5%86%99"><span class="toc-number">2.14.2.2.4.</span> <span class="toc-text">类模板的分文件编写</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%92%8C%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">2.14.2.2.5.</span> <span class="toc-text">类模板和静态成员</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%AD%E7%9A%84%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="toc-number">2.14.2.2.6.</span> <span class="toc-text">类模板中的友元函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E6%A8%A1%E6%9D%BF%E7%B1%BB"><span class="toc-number">2.14.2.2.7.</span> <span class="toc-text">动态数组模板类</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6dynamicArray-h"><span class="toc-number">2.14.2.2.7.1.</span> <span class="toc-text">头文件dynamicArray.h</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%BA%90%E6%96%87%E4%BB%B6dynamicArray-hpp"><span class="toc-number">2.14.2.2.7.2.</span> <span class="toc-text">源文件dynamicArray.hpp</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#main%E6%96%87%E4%BB%B6main-cpp"><span class="toc-number">2.14.2.2.7.3.</span> <span class="toc-text">main文件main.cpp</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%8C%96"><span class="toc-number">2.14.2.3.</span> <span class="toc-text">类模板特化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0"><span class="toc-number">2.14.3.</span> <span class="toc-text">模板模板参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.15.</span> <span class="toc-text">类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-static-cast"><span class="toc-number">2.15.1.</span> <span class="toc-text">静态类型转换(static_cast)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-dynamic-cast"><span class="toc-number">2.15.2.</span> <span class="toc-text">动态类型转换(dynamic_cast)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E8%BD%AC%E6%8D%A2-const-cast"><span class="toc-number">2.15.3.</span> <span class="toc-text">常量转换(const_cast)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E6%96%B0%E8%A7%A3%E9%87%8A%E8%BD%AC%E6%8D%A2-reinterpret-cast"><span class="toc-number">2.15.4.</span> <span class="toc-text">重新解释转换(reinterpret_cast)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">2.16.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.16.1.</span> <span class="toc-text">异常的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#c-%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6%E7%9B%B8%E6%AF%94C%E8%AF%AD%E8%A8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">2.16.1.1.</span> <span class="toc-text">c++异常机制相比C语言异常处理的优势?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">2.16.2.</span> <span class="toc-text">异常基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E4%B8%A5%E6%A0%BC%E7%B1%BB%E5%9E%8B%E5%8C%B9%E9%85%8D"><span class="toc-number">2.16.2.1.</span> <span class="toc-text">异常严格类型匹配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E8%A7%A3%E6%97%8B-unwinding"><span class="toc-number">2.16.2.2.</span> <span class="toc-text">栈解旋(unwinding)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E6%8E%A5%E5%8F%A3%E5%A3%B0%E6%98%8E"><span class="toc-number">2.16.3.</span> <span class="toc-text">异常接口声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%8F%98%E9%87%8F%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.16.4.</span> <span class="toc-text">异常变量生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%9A%E6%80%81%E4%BD%BF%E7%94%A8"><span class="toc-number">2.16.5.</span> <span class="toc-text">异常的多态使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%8E%9F%E7%90%86"><span class="toc-number">2.16.6.</span> <span class="toc-text">异常原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BA%86%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E7%9A%84C-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="toc-number">2.16.6.1.</span> <span class="toc-text">使用了异常处理机制的C++函数调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E5%9B%9E%E9%80%80%EF%BC%88stack-unwind%EF%BC%89"><span class="toc-number">2.16.6.2.</span> <span class="toc-text">栈回退（stack unwind）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7"><span class="toc-number">2.16.6.3.</span> <span class="toc-text">异常捕获</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-number">2.16.6.4.</span> <span class="toc-text">抛出异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.16.6.5.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Windows%E4%B8%AD%E7%9A%84%E7%BB%93%E6%9E%84%E5%8C%96%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">2.16.6.6.</span> <span class="toc-text">Windows中的结构化异常处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E9%94%80%E5%88%86%E6%9E%90"><span class="toc-number">2.16.6.7.</span> <span class="toc-text">开销分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E6%A0%87%E5%87%86%E5%BC%82%E5%B8%B8%E5%BA%93"><span class="toc-number">2.16.7.</span> <span class="toc-text">C++标准异常库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%BA%93%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.16.7.1.</span> <span class="toc-text">标准库介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84%E5%BC%82%E5%B8%B8%E7%B1%BB"><span class="toc-number">2.16.7.2.</span> <span class="toc-text">编写自己的异常类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84%E5%BC%82%E5%B8%B8%E7%B1%BB%EF%BC%9F"><span class="toc-number">2.16.7.2.1.</span> <span class="toc-text">如何编写自己的异常类？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Function-try-block"><span class="toc-number">2.16.8.</span> <span class="toc-text">Function-try-block</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8"><span class="toc-number">2.16.9.</span> <span class="toc-text">异常安全</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">2.17.</span> <span class="toc-text">C++输入和输出流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E6%B5%81%E7%B1%BB%E5%BA%93%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">2.17.1.</span> <span class="toc-text">流的概念和流类库的结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8Eiostream%E7%B1%BB%E5%BA%93%E6%9C%89%E5%85%B3%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-number">2.17.2.</span> <span class="toc-text">与iostream类库有关的头文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8iostream%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84%E6%B5%81%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.17.3.</span> <span class="toc-text">在iostream头文件中定义的流对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%A8iostream%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%AD%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.17.3.0.1.</span> <span class="toc-text">在iostream头文件中重载运算符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86I-O%E6%B5%81"><span class="toc-number">2.17.4.</span> <span class="toc-text">标准I&#x2F;O流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#cout%E6%B5%81%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.17.4.1.</span> <span class="toc-text">cout流对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cerr%E6%B5%81%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.17.4.2.</span> <span class="toc-text">cerr流对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#clog%E6%B5%81%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.17.4.3.</span> <span class="toc-text">clog流对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E6%B5%81"><span class="toc-number">2.17.5.</span> <span class="toc-text">标准输入流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">2.17.6.</span> <span class="toc-text">标准输出流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA"><span class="toc-number">2.17.6.1.</span> <span class="toc-text">格式化输出</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%B5%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9C%89%E5%85%B3%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">2.17.6.1.1.</span> <span class="toc-text">使用流对象的有关成员函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E7%AC%A6%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA"><span class="toc-number">2.17.6.1.2.</span> <span class="toc-text">控制符格式化输出</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%87%A0%E7%82%B9%E8%AF%B4%E6%98%8E-%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">2.17.6.1.3.</span> <span class="toc-text">对程序的几点说明(注意点)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99"><span class="toc-number">2.17.7.</span> <span class="toc-text">文件读写</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%B5%81%E7%B1%BB%E5%92%8C%E6%96%87%E4%BB%B6%E6%B5%81%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.17.7.1.</span> <span class="toc-text">文件流类和文件流对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6"><span class="toc-number">2.17.7.2.</span> <span class="toc-text">C++打开文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6"><span class="toc-number">2.17.7.3.</span> <span class="toc-text">C++关闭文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E5%AF%B9ASCII%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C"><span class="toc-number">2.17.7.4.</span> <span class="toc-text">C++对ASCII文件的读写操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E7%A7%8DASCII%E8%AF%BB%E5%86%99%E6%96%B9%E5%BC%8F"><span class="toc-number">2.17.7.4.1.</span> <span class="toc-text">4种ASCII读写方式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E5%AF%B9%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C"><span class="toc-number">2.17.7.5.</span> <span class="toc-text">C++对二进制文件的读写操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0read%E5%92%8Cwrite%E8%AF%BB%E5%86%99%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6"><span class="toc-number">2.17.7.6.</span> <span class="toc-text">用成员函数read和write读写二进制文件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%AD%E8%A8%80"><span class="toc-number">2.18.</span> <span class="toc-text">断言</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E4%B8%8EC%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">3.</span> <span class="toc-text">C++与C性能分析</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%86C%E6%BA%90%E4%BB%A3%E7%A0%81%E5%B0%81%E8%A3%85%E6%88%90C-%E7%B1%BB%E4%BB%A3%E7%A0%81"><span class="toc-number">4.</span> <span class="toc-text">将C源代码封装成C++类代码</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%A3%80%E6%B5%8B%E7%9F%A5%E8%AF%86%E7%82%B9-%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7%E6%B3%A8%E6%84%8F%E7%82%B9%E7%AF%87"><span class="toc-number">5.</span> <span class="toc-text">内存泄露检测知识点(调试技巧注意点篇)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#VC%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9%E2%80%9C%E5%9F%BA%E6%9C%AC%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A3%80%E6%9F%A5%E2%80%9D%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">6.</span> <span class="toc-text">VC编译选项“基本运行时检查”的作用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93"><span class="toc-number">7.</span> <span class="toc-text">C++如何使用第三方库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#homebrew"><span class="toc-number">7.1.</span> <span class="toc-text">homebrew</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E5%90%88cmake%E4%BD%BF%E7%94%A8%E5%BC%80%E5%8F%91%E5%8C%85"><span class="toc-number">7.1.1.</span> <span class="toc-text">配合cmake使用开发包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vcpkg%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">7.2.</span> <span class="toc-text">vcpkg包管理器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85"><span class="toc-number">7.2.1.</span> <span class="toc-text">下载与安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">7.2.2.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E6%88%90%E4%BD%BF%E7%94%A8"><span class="toc-number">7.2.3.</span> <span class="toc-text">集成使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8ECMAKE%E9%85%8D%E5%90%88%E4%BD%BF%E7%94%A8"><span class="toc-number">7.2.4.</span> <span class="toc-text">与CMAKE配合使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vcpkg%E4%B8%8Ehomebrew%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.2.5.</span> <span class="toc-text">vcpkg与homebrew的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#boost%E5%BA%93"><span class="toc-number">8.</span> <span class="toc-text">boost库</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E9%80%9A%E7%94%A8%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E5%92%8C%E5%BA%93"><span class="toc-number">9.</span> <span class="toc-text">C++通用开源框架和库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD"><span class="toc-number">9.1.</span> <span class="toc-text">人工智能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-number">9.2.</span> <span class="toc-text">异步事件循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9F%B3%E9%A2%91"><span class="toc-number">9.3.</span> <span class="toc-text">音频</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF"><span class="toc-number">9.4.</span> <span class="toc-text">生物信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E5%92%8C%E5%BD%92%E6%A1%A3%E5%BA%93"><span class="toc-number">9.5.</span> <span class="toc-text">压缩和归档库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">9.6.</span> <span class="toc-text">并发执行和多线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%86%E7%A0%81%E5%AD%A6"><span class="toc-number">9.7.</span> <span class="toc-text">密码学</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">9.8.</span> <span class="toc-text">数据库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E5%BA%93"><span class="toc-number">9.9.</span> <span class="toc-text">调试库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E5%BD%A2%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2"><span class="toc-number">9.10.</span> <span class="toc-text">图形用户界面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E5%BD%A2"><span class="toc-number">9.11.</span> <span class="toc-text">图形</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86"><span class="toc-number">9.12.</span> <span class="toc-text">图像处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BD%E9%99%85%E5%8C%96"><span class="toc-number">9.13.</span> <span class="toc-text">国际化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E5%BF%97"><span class="toc-number">9.14.</span> <span class="toc-text">日志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0"><span class="toc-number">9.15.</span> <span class="toc-text">机器学习</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6"><span class="toc-number">9.16.</span> <span class="toc-text">数学</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E5%AA%92%E4%BD%93"><span class="toc-number">9.17.</span> <span class="toc-text">多媒体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C"><span class="toc-number">9.18.</span> <span class="toc-text">网络</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%AD%A6"><span class="toc-number">9.19.</span> <span class="toc-text">物理学</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6"><span class="toc-number">9.20.</span> <span class="toc-text">机器人学</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97"><span class="toc-number">9.21.</span> <span class="toc-text">科学计算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%84%9A%E6%9C%AC"><span class="toc-number">9.22.</span> <span class="toc-text">脚本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">9.23.</span> <span class="toc-text">序列化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%86%E9%A2%91"><span class="toc-number">9.24.</span> <span class="toc-text">视频</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-number">9.25.</span> <span class="toc-text">虚拟机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Web%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6"><span class="toc-number">9.26.</span> <span class="toc-text">Web应用框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#XML"><span class="toc-number">9.27.</span> <span class="toc-text">XML</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E9%A1%B9%E6%B7%B7%E6%9D%82"><span class="toc-number">9.28.</span> <span class="toc-text">多项混杂</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-number">9.29.</span> <span class="toc-text">编译器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E7%BA%BFC-C-%E7%BC%96%E8%AF%91%E5%99%A8%E5%88%97%E8%A1%A8"><span class="toc-number">9.30.</span> <span class="toc-text">在线C&#x2F;C++编译器列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-C-%E8%B0%83%E8%AF%95%E5%99%A8%E5%88%97%E8%A1%A8"><span class="toc-number">9.31.</span> <span class="toc-text">C&#x2F;C++调试器列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-C-%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%EF%BC%88IDE%EF%BC%89%E5%88%97%E8%A1%A8"><span class="toc-number">9.32.</span> <span class="toc-text">C&#x2F;C++集成开发环境（IDE）列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9F"><span class="toc-number">9.33.</span> <span class="toc-text">构建系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">9.34.</span> <span class="toc-text">静态代码分析</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/avalonia/" title="avalonia">avalonia</a><time datetime="2024-09-11T14:51:13.000Z" title="发表于 2024-09-11 22:51:13">2024-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/%E8%A7%86%E9%A2%91%E6%95%88%E6%9E%9C/" title="PR">PR</a><time datetime="2024-07-18T07:06:08.330Z" title="发表于 2024-07-18 15:06:08">2024-07-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/%E5%89%8D%E7%AB%AF/" title="WEB前端">WEB前端</a><time datetime="2024-07-18T07:06:08.323Z" title="发表于 2024-07-18 15:06:08">2024-07-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/slidev/" title="slidev">slidev</a><time datetime="2024-07-18T07:06:08.319Z" title="发表于 2024-07-18 15:06:08">2024-07-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="C++多线程">C++多线程</a><time datetime="2024-07-18T07:05:59.794Z" title="发表于 2024-07-18 15:05:59">2024-07-18</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2024 By <a class="footer-bar-link" href="/" title="ZEROKO14" target="_blank">ZEROKO14</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu"></a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">57</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">48</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">6</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size: 0.88rem;">C#<sup>3</sup></a><a href="/tags/C/" style="font-size: 0.88rem;">C++<sup>5</sup></a><a href="/tags/CSS/" style="font-size: 0.88rem;">CSS<sup>1</sup></a><a href="/tags/CSharp/" style="font-size: 0.88rem;">CSharp<sup>1</sup></a><a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 0.88rem;">C语言<sup>1</sup></a><a href="/tags/FPS/" style="font-size: 0.88rem;">FPS<sup>1</sup></a><a href="/tags/HTML/" style="font-size: 0.88rem;">HTML<sup>1</sup></a><a href="/tags/JavaScript/" style="font-size: 0.88rem;">JavaScript<sup>1</sup></a><a href="/tags/MFC/" style="font-size: 0.88rem;">MFC<sup>1</sup></a><a href="/tags/PE/" style="font-size: 0.88rem;">PE<sup>1</sup></a><a href="/tags/QT/" style="font-size: 0.88rem;">QT<sup>1</sup></a><a href="/tags/WPF/" style="font-size: 0.88rem;">WPF<sup>3</sup></a><a href="/tags/ai/" style="font-size: 0.88rem;">ai<sup>1</sup></a><a href="/tags/cmake/" style="font-size: 0.88rem;">cmake<sup>1</sup></a><a href="/tags/doxygen/" style="font-size: 0.88rem;">doxygen<sup>1</sup></a><a href="/tags/git/" style="font-size: 0.88rem;">git<sup>1</sup></a><a href="/tags/json/" style="font-size: 0.88rem;">json<sup>1</sup></a><a href="/tags/linux/" style="font-size: 0.88rem;">linux<sup>1</sup></a><a href="/tags/next/" style="font-size: 0.88rem;">next<sup>1</sup></a><a href="/tags/ppt/" style="font-size: 0.88rem;">ppt<sup>1</sup></a><a href="/tags/slidev/" style="font-size: 0.88rem;">slidev<sup>1</sup></a><a href="/tags/vue/" style="font-size: 0.88rem;">vue<sup>1</sup></a><a href="/tags/xml/" style="font-size: 0.88rem;">xml<sup>1</sup></a><a href="/tags/yaml/" style="font-size: 0.88rem;">yaml<sup>1</sup></a><a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 0.88rem;">代码规范<sup>1</sup></a><a href="/tags/%E5%86%85%E6%A0%B8/" style="font-size: 0.88rem;">内核<sup>2</sup></a><a href="/tags/%E5%86%85%E6%A0%B8%E7%9B%B8%E5%85%B3/" style="font-size: 0.88rem;">内核相关<sup>5</sup></a><a href="/tags/%E5%8A%A0%E8%A7%A3%E5%AF%86/" style="font-size: 0.88rem;">加解密<sup>1</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 0.88rem;">多线程<sup>1</sup></a><a href="/tags/%E5%BC%80%E5%8F%91/" style="font-size: 0.88rem;">开发<sup>4</sup></a><a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 0.88rem;">数学<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 0.88rem;">数据库<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 0.88rem;">数据结构<sup>1</sup></a><a href="/tags/%E6%9E%B6%E6%9E%84/" style="font-size: 0.88rem;">架构<sup>1</sup></a><a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 0.88rem;">正则表达式<sup>1</sup></a><a href="/tags/%E7%9B%91%E6%8E%A7/" style="font-size: 0.88rem;">监控<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 0.88rem;">算法<sup>1</sup></a><a href="/tags/%E7%AE%A1%E7%90%86/" style="font-size: 0.88rem;">管理<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 0.88rem;">网络<sup>2</sup></a><a href="/tags/%E9%80%86%E5%90%91/" style="font-size: 0.88rem;">逆向<sup>2</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.cbd.int/mathjax@3.2.2/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.cbd.int/mermaid@10.2.4/dist/mermaid.min.js').then(runMermaid)
  }

  anzhiyu.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>