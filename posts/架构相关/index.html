<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>架构 | ZEROKO14的个人博客</title><meta name="keywords" content="架构"><meta name="author" content="ZEROKO14"><meta name="copyright" content="ZEROKO14"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#18171d"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="架构"><meta name="application-name" content="架构"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#18171d"><meta property="og:type" content="article"><meta property="og:title" content="架构"><meta property="og:url" content="https://che77a38.github.io/posts/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/index.html"><meta property="og:site_name" content="ZEROKO14的个人博客"><meta property="og:description" content="此处记录架构相关的知识   最宏观的架构盘点 分层架构(LAYERED): 通过层次分离确保系统的可维护性 优点:低层可复用 缺点:在高性能应用程序中的性能很差,因为通过多个层来满足业务请求的效率不高 适用场景: 通常用于构建一般的桌面应用程序以及相对简单的web应用程序  客户端服务器模式 缺点:"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4"><meta property="article:author" content="ZEROKO14"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4"><meta name="description" content="此处记录架构相关的知识   最宏观的架构盘点 分层架构(LAYERED): 通过层次分离确保系统的可维护性 优点:低层可复用 缺点:在高性能应用程序中的性能很差,因为通过多个层来满足业务请求的效率不高 适用场景: 通常用于构建一般的桌面应用程序以及相对简单的web应用程序  客户端服务器模式 缺点:"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://che77a38.github.io/posts/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2024/07/27/125766904/ba62475f396df9de3316a08ed9e65d86_5680958632268053399..png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":true,"limitCount":50,"languages":{"author":"作者: ZEROKO14","link":"链接: ","source":"来源: ZEROKO14的个人博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'ZEROKO14的个人博客',
  title: '架构',
  postAI: '',
  pageFillDescription: '最宏观的架构盘点, 领域驱动设计, 失血模型, 贫血模型, 充血模型, 胀血模型, DDD分层架构模型, 解决90%问题的异步架构, 异步架构的技术选型, 事件驱动架构, 消息队列, 三种消息传递模式详解, 重试机制, 接口架构, 统一接口架构, 架构模式, 软件开发设计哲学, 函数内部设计建议, 函数式编程, 实现前提, 纯函数, 定义, 纯函数的优点, 无状态和数据不可变, 无状态, 数据不可变, 高阶函数, 常用高阶函数, 组合函数和管道函数, 偏函数与柯里化, 柯里化, 案例, 单子x2F例子x2F函子, Monad, Functor和Applicative, Functor, Applicative, 惰性求值, 架构相关库盘点, 消息队列框架, 依赖注入容器, 容器的作用, 实现一个简易容器, 依赖注入的实现此处记录架构相关的知识最宏观的架构盘点分层架构通过层次分离确保系统的可维护性优点低层可复用缺点在高性能应用程序中的性能很差因为通过多个层来满足业务请求的效率不高适用场景通常用于构建一般的桌面应用程序以及相对简单的应用程序客户端服务器模式缺点服务器可能成为性能瓶颈和单点故障适用场景在线应用程序如电子邮件共享文档系统和银行业务模型视图控制器模式事件驱动架构通过组件间的松耦合实现高灵活性事件总线模式现代企业软件通常构建为分布式系统可以为异步到达的与大量事件相关的消息提供服务在事件总线上事件源将消息发布到特定的通道监听器订阅特定的通道监听器收到所订阅的通道中的消息通知缺点因为所有消息都通过相同的总线传输这种模式的可伸缩性是一个问题适用场景开发电子商务应用程序和通知服务中管道过滤模式单个事件触发一系列处理步骤每个步骤执行特定的功能将复杂消息流转换为唯一的简单纯文本顺序消息流而不需要额外的数据字段管道和过滤器体系结构将较大的处理任务划分为一系列较小的独立处理步骤或过滤器这些处理步骤和过滤器通过管道互相连接适用场景常用于连续过滤器执行词法分析解析语义分析和代码编译器中微内核架构将核心功能与插件分离提高系统的可拓展性微服务架构通过服务的独立开发和部署提升系统的敏捷性现代程序复杂性越来越高单体应用可能会变得过于庞大和复杂无法有效地支持和部署解决方案就是微服务架构每个服务都可以独立的部署和拓展并且有自己的边界不同的服务器可以由不同的编程语言编写管理自己的数据库并由不同的团队开发单体架构将所有组件打包成一个单元简化开发和部署过程代理模式这种模式用解耦的组件来构造分布式系统这些组件可以通过远程服务调用互相交互代理组件负责协调组件之间的通信服务器将其功能发布给代理客户端从代理请求服务然后代理将客户端重定向到其注册中心的服务代理模式允许对象的动态更改添加删除和重定位使请求分发对开发人员透明适用场景常用于消息代理软件如点对点模式这种模式中每个组件被称为节点节点既可以作为向其他节点请求服务的客户端也可以作为向其他节点提供服务的服务器模式支持分布式计算优点具有很强的健壮性和可拓展性缺点由于节点之间是自愿合作因此服务质量无法得到保证此外安全性无法保证系统性能往往依赖于节点的数量适用场景常用于文件共享网络以及基于加密货币的产品如比特币黑板模式对于那些没有确定解决方案策略的问题这种模式非常有用由个部分组成黑板数据结构按照与应用程序相关的层次来组织并解决问题的数据知识源通过不断地改变黑板数据来解决问题知识源通过不断改变黑板数据来解决问题知识源包含独立的与应用程序相关的知识知识源之间不直接进行通讯他们之间的交互只通过黑板来完成控制组件完全由黑板的状态驱动黑板状态的改变决定了需要使用的特定知识优点很容易拓展数据空间的结构缺点然而修改数据空间的结构是困难的因为所有应用程序都会受到影响适用场景常用于语音识别蛋白质结构识别主从模式由主和从组成主组件将工作分配给从组件并根据从组件返回的结果计算出最终结果优点准确性服务的执行委托给具有不同实现的不同从服务器执行缺点只能应用于可分解的问题适用场景常用于将主数据库视为权威的源数据库并将数据库同步到从库领域驱动设计这类理论都是由软件设计领域的大牛如提出来的领域模型分为大类失血模型贫血模型充血模型胀血模型血指的是的层内容在这四种模型当中失血模型和胀血模型应该是不被提倡的而贫血模型和充血模型从技术上来说都是可行的但是我个人仍然主张使用贫血模型其理由虽然贫血模型的确实不够但只包含属于它本身的领域逻辑不包含持久化逻辑将有效的隔离和屏蔽了持久化技术进而可以对持久化技术进行灵活的替换贫血模型中提出的按照是否依赖持久化进行划分这种标准是非常确定的不会引起开发团队设计上的争议失血模型领域对象模型仅仅包含对象属性的定义和操作对象属性的方法所有的业务逻辑完全由层业务逻辑层中的服务类来完成这种类在中叫在中叫优点领域对象结构简单缺点肿胀的业务服务代码逻辑难于理解和维护无法良好的应对复杂业务逻辑和场景贫血模型领域对象模型包含对象属性的定义和操作对象属性的方法并包含了对象的行为例如就像一个完整的人具有一些属性如姓名性别年龄等还具有一些能力如走路吃饭恋爱等这样才是一个完整的对象但不包含依赖层持久层的业务逻辑这部分依赖于层的业务逻辑将会放到层业务逻辑层中的服务类来实现组合逻辑也由服务类负责可以看出贫血模型中的领域对象是不依赖于持久层的代码架构层次结构是是依赖的行为优点层次结构清楚各层之间单向依赖对于只有少量业务逻辑的应用来说使用起来非常自然开发迅速易于理解缺点无法良好的应对非常复杂逻辑和场景充血模型领域对象模型包含对象属性的定义和操作对象属性的方法并包含了大多数相关的业务逻辑也包含了依赖于持久层的业务逻辑层是很薄的一层仅仅简单封装少量业务逻辑以及控制事务权限逻辑等不和层打交道所以使用充血模型的领域对象是依赖于持久层的代码架构层次结构是优点更符合的原则层很薄符合单一职责不像在贫血模型里面那样包含所有的业务逻辑太过沉重只充当的角色不和打交道缺点什么样的逻辑应该放在中什么样的业务逻辑应该放在中这是很含糊的即使划分好了业务逻辑由于分散在和层中不能更好的分模块开发熟悉业务逻辑的开发人员需要渗透到中去而在又包含了持久化对于开发者来说这十分混乱其次因为要控制事务并且为上层提供一个统一的服务调用入口点它就必须把在里实现的业务逻辑全部重新包装一遍完全属于重复劳动胀血模型领域对象模型包含对象属性的定义和操作对象属性的方法并包含了所有相关的的业务逻辑也包含了不想关的其它应用逻辑如授权事务等胀血模型取消了层业务逻辑层只剩下和两层在的上面封装事务授权逻辑等优点简化了代码分层结构也算符合面向对象设计缺点取消了层业务逻辑层在的上面封装事务授权等很多本不应该属于领域对象的逻辑使业务逻辑再次进行到混论的状态引起了模型的不稳定代码理解和维护性差分层架构模型它包括用户接口层应用层领域层和基础层分层架构各层的职责边界非常清晰又能有条不紊地分层协作用户接口层面向前端提供服务适配面向资源层提供资源适配这一层聚集了接口适配相关的功能应用层职责实现服务组合和编排适应业务流程快速变化的需求这一层聚集了应用服务和事件相关的功能领域层实现领域的核心业务逻辑这一层聚集了领域模型的聚合聚合根实体值对象领域服务和事件等领域对象以及它们组合所形成的业务能力基础层贯穿所有层为各层提供基础资源服务这一层聚集了各种底层资源相关的服务和能力分层架构的一个重要原则是每层只能与位于其下方的层发生耦合分层架构可以简单分为两种即严格分层架构和松散分层架构在严格分层架构中某层只能与位于其直接下方的层发生耦合而在松散分层架构中则允许某层与它的任意下方层发生耦合分层架构的优点在一书中给出了答案开发人员可以只关注整个结构中的某一层可以很容易的用新的实现来替换原有层次的实现可以降低层与层之间的依赖有利于标准化有利于各层逻辑的复用适当的分层体系结构将开发层面进行隔离这些层不受其他层的更改的影响从而使重构更加容易划分任务并定义单独的层是架构师面临的挑战当需求很好地适应了模式时这些层将易于解耦或分层开发使用场景需要快速构建的新应用程序需要严格的可维护性和可测试性标准的应用解决问题的异步架构降低代码的复杂度对功能组件进行解耦开发的过程中遇到的问题盘点业务逻辑冲突的处理规则数据完整性的保护机制超时规则重试规则诸如此类的问题起码占到了代码开发的异步解决一切问题和这类代码能删除等待这个行为统一管理和分配每一个步骤的执行管理池只负责管理任务池负责分配这些资源来处理任务重试池灵活分配资源当遇到接口故障的时候可以直接暂停分配资源给这些重试支付的任务好处在于可以灵活的分配资源去独立处理每一个任务的每一个步骤异步架构的技术选型打造这种异步的任务流水线最需要解决的就是负责登记任务跟踪进度分配资源和进行调度的这一部分最好的解决方案就是消息队列框架比如说事件驱动架构事件驱动的核心是触发机制和推送机制消息队列三种消息传递模式详解图中的生产者状态和消费者状态指的是各自保存消息传递的状态信息以便在失败或重试时恢复到正确的状态最多一次消息可能丢失但不会重复适用于对可靠性要求低的场景至少一次消息不会丢失但可能会重复适用于对消息丢失不可接受的场景精确一次消息既不会丢失也不会重复适用于对可靠性和一致性要求高的场景盘点生产者与消费者之间的消息传递行为以及这些模式的可靠性和特点最多一次传递描述生产者发送消息后不会尝试再次发送即便消息丢失这意味着消息可能会被消费者成功接收到也可能会在传输中丢失风险消息可能会丢失生产者并不重试发送应用场景适用于一些对数据完整性要求不高的场景比如不需要重试的通知至少一次传递描述生产者在发送消息后保存状态并尝试重发消息直到收到消费者的确认这会确保消费者至少会收到一次消息风险消费者可能会接收到重复消息因为生产者在未确认的情况下会多次重发应用场景常用于对消息丢失不能容忍但能处理重复消息的场景比如日志系统或审计系统精确一次传递描述这是最强的消息传递语义保证生产者和消费者都对消息进行状态保存以确保消息恰好传递一次消息不会丢失也不会重复风险无重复也无丢失但需要较复杂的实现通常需要使用事务性操作应用场景适用于对消息传递的正确性有严格要求的场景如金融交易系统账务系统等精确一次传递是指在数据传输或消息传递过程中确保每条消息只被处理一次且仅处理一次的特性这一特性在分布式系统消息队列和数据库等场景中非常重要因为它能有效避免重复处理和数据丢失的问题理解精确一次传递的原理可以从以下几个方面进行分析消息标识每条消息通常会有一个唯一的标识符接收方在处理消息时会记录已处理的消息以避免重复处理幂等性在接收方的处理逻辑中应该设计成幂等的即多次处理同一条消息的结果是相同的这样即使消息被重复处理也不会产生不一致的状态事务机制在发送和接收消息的过程中通常会使用事务来确保操作的原子性例如在数据库操作中可以通过事务来确保数据的一致性和完整性确认机制发送方在发送消息后会等待接收方的确认只有在收到确认后才会认为消息成功传递这可以减少消息丢失的风险重试机制如果发送方没有收到确认它会重新发送消息通过合理的重试策略可以确保消息最终被成功传递状态管理系统需要维护一定的状态信息以跟踪消息的发送和处理情况这样可以避免在系统故障或网络问题时造成的数据丢失或重复处理总之精确一次传递的实现需要结合多个技术手段和设计原则以确保在各种情况下都能保证消息的唯一性和一致性重试机制展示了几种回退策略在重试时间线上的表现横轴为回退时间纵轴表示重试次数回退策略常用于网络请求或分布式系统中的重试机制以避免频繁请求或冲突图片列出了几种常见的回退策略并展示了它们在不同时间点的表现无回退这条线是平坦的表示在失败时系统不会等待而是立刻重试这种方法容易造成网络或系统的过载常量回退这条线也是平坦的表明每次重试之间的等待时间是固定的例如每次都等待相同的时间间隔虽然这种策略避免了无间隔的重试但对于某些情况来说它的效率可能不够高线性回退这条线呈现出斜率逐渐增大的趋势表示每次重试的间隔时间逐渐增加但增加幅度是线性的线性回退意味着每次重试等待的时间都会按固定的增量递增斐波那契回退这条线表示每次重试的间隔时间按照斐波那契数列增长相比线性回退它的增长更加渐进且在初期增长较为平缓二次回退这条线表示每次重试的间隔时间按二次方的规律增长随着时间推移间隔时间会迅速增加这种方法可以有效避免高频重试对系统的冲击指数回退这条线表示每次重试的间隔时间呈指数增长最初增长较慢但后期增长非常快指数回退常用于网络重试中特别是应对高并发时指数增加等待时间可以减轻系统压力多项式回退这条线的增长速度最快多项式回退的增长速度比指数回退更快间隔时间的增加幅度更加剧烈一般用于系统对重试频率的容忍度极低的场景总结和适合简单场景且系统负载较低时使用和是中间方案随着重试次数的增加系统等待时间也逐渐增加适用于大多数实际应用和适合在高负载或高并发的情况下使用能够显著减少系统压力避免频繁重试接口架构统一接口架构前端的变动往往是频繁的琐碎的由此会波及到后端的部分就很容易形成任务进度上的瓶颈统一接口架构一次性解决了这个问题每个页面的信息都可以在一个请求里传达清楚结构的定义就是统一前后端交流的语言后端要实现数据结构模型和翻译器很多自动化框架从数据库的生成接口的所有的数据结构和翻译器可以用生成文档可能的缺陷抛弃了就是抛弃了几十年互联网基础设施所提供的强大的缓存能力合并所有的接口会让权限管理和限速限量等功能开发难度大大提升架构模式系统架构模式是软件系统设计中的高级模式它提供了结构化和解决复杂问题的框架和策略旨在提高系统的可扩展性可维护性灵活性以及模块化常见的系统架构模式有以下几种层次化架构模式描述将系统分为多个层每一层都只与其相邻的层进行交互典型的分层结构包括表示层业务逻辑层数据访问层数据库层等用途适用于标准化的企业应用程序和开发示例模式三层架构表示层业务逻辑层数据层微服务架构模式描述将系统拆分为多个独立的可部署的微服务每个微服务专注于特定的业务功能并通过轻量级的通信如或消息队列进行交互用途适用于需要高度扩展性和可部署独立组件的大型分布式系统示例亚马逊等使用的微服务架构事件驱动架构模式描述基于事件机制进行异步通信系统组件对特定的事件进行监听和响应事件生产者和事件消费者通过消息传递中间件解耦用途适用于需要快速响应变化解耦复杂依赖的系统常见于金融系统监控系统示例发布订阅模式消息队列如微内核架构模式描述系统的核心功能保持固定扩展功能通过插件或附加模块来提供微内核负责管理和通信而插件负责具体的业务功能用途适用于需要灵活扩展插件化功能的系统如文本编辑器等示例浏览器的插件机制面向服务架构模式描述系统由多个松耦合的服务组成每个服务通过标准协议如或提供业务功能服务可以被复用并通过服务总线进行集成用途适用于跨企业或跨应用集成的系统示例企业服务总线服务架构管道过滤器架构模式描述将系统的处理任务划分为多个独立的步骤每个步骤被称为过滤器它们通过管道串联每个过滤器接收输入处理数据并传递输出给下一个过滤器用途适用于数据处理流水线流媒体处理等场景示例管道等命令的组合图像处理流水线共享数据库架构模式描述多个服务或组件共享同一个数据库彼此通过访问同一数据库中的表来进行通信这种方式通过数据库实现数据一致性和持久化用途适用于需要多个系统访问同一数据源的场景示例企业级应用程序的多模块数据共享空间分区架构模式描述通过将应用程序的处理和存储分区到不同的物理空间以便系统能够水平扩展所有组件共享数据和计算负载避免单点瓶颈用途适用于需要大规模扩展的实时高性能系统如电商平台社交网络示例分布式缓存系统等主从架构模式描述主服务器负责接收请求并将任务分配给从服务器每个从服务器执行任务并将结果返回给主服务器主从结构中从服务器通常是副本或负载均衡节点用途适用于需要高可用性和负载均衡的分布式系统示例主从复制主从结构代理架构模式描述通过代理来间接访问目标对象代理可以控制过滤或增强对目标对象的访问用途适用于需要在访问目标对象之前进行控制或优化的场景示例虚拟代理延迟加载远程代理分布式对象访问保护代理访问控制分层缓存架构模式描述将缓存层作为独立于应用和数据库的层用于存储经常访问的数据应用程序先访问缓存如果数据不在缓存中再从数据库中获取用途适用于高并发访问高性能数据读取的场景示例缓存策略分区架构模式描述通过水平或垂直分割数据和任务来分配负载每个分区负责处理特定的数据或任务并且可以独立扩展用途适用于需要水平扩展处理海量数据的场景示例分布式数据库中的分区机制中介者架构模式描述通过一个中介对象来协调多个子系统或模块之间的通信和交互避免模块之间的直接依赖用途适用于模块复杂需要集中控制通信的系统示例消息中间件如机场塔台控制系统代理客户机架构模式描述客户端发起请求服务器响应请求客户端和服务器通过网络进行通信服务器通常处理资源密集型任务而客户端负责用户交互用途适用于典型的网络应用场景示例服务器和浏览器服务器和客户端架构模式描述基于协议的一种风格系统以无状态的方式进行交互使用统一的接口资源通过表示操作通过方法实现用途适用于应用程序和分布式系统示例大多数现代都基于架构无服务器架构模式描述不需要显式管理服务器开发人员将函数部署到云端云提供商负责自动扩展维护和运行环境常用于事件驱动和按需执行的场景用途适用于事件驱动的应用程序如实时处理调用批处理任务示例架构模式描述将读取操作查询与写入操作命令分离针对这两种操作使用不同的模型避免读写模型的相互影响用途适用于高并发高可用系统尤其是读多写少的场景示例在电商系统中订单系统使用来优化读写性能总结系统架构模式为设计软件系统提供了多种标准化的解决方案每种模式针对不同的系统特性和需求提供相应的结构和设计思路选择合适的架构模式需要考虑系统的规模性能要求扩展性可维护性以及业务需求软件开发设计哲学原则该原则强调系统设计应尽可能简单避免不必要的复杂性简单的设计更容易理解维护和扩展原则原则主张在编写代码时不要为未来可能需要的功能提前做准备只实现当前需求避免不必要的复杂性和代码膨胀原则是五个面向对象设计原则的缩写分别是单一职责原则一个类应该只有一个原因引起变化开闭原则软件实体类模块函数等应该对扩展开放对修改关闭里氏替换原则子类对象应该能够替换父类对象而不影响程序的正确性接口隔离原则不应强迫任何客户端依赖于它们不使用的接口依赖倒置原则高层模块不应依赖于低层模块二者应依赖于抽象不要重复自己强调在代码中避免重复原则强调在系统中同一种信息或逻辑应该只存在一个地方其所指的重复包括但不限于代码重复相同的代码片段在多个地方出现逻辑重复相同的业务逻辑在不同的模块中实现数据重复相同的数据在多个地方存储关注点分离该原则主张将不同的关注点或功能分开以提高系统的模块化程度和可维护性迪米特法则该原则建议一个对象应尽量少地了解其他对象强调对象之间的低耦合性组合优于继承该原则提倡使用对象组合来实现功能而不是通过类继承这有助于提高代码的灵活性和可重用性这些原则共同构成了现代软件开发的设计哲学旨在提高代码的可维护性可读性和灵活性函数内部设计建议确保参数有效性函数入口处的参数检查对指针类型参数或容器进行空检查对整数浮点数等类型参数进行范围检查减少重复代码原则提取重复部分为辅助函数处理异常局部变量初始化合理利用早退出优化循环结构循环中尽量减少不必要的操作如将不变的表达式移到循环外明确函数职责单一职责原则若函数内部逻辑过于复杂考虑将其拆分成多个小函数减少嵌套层级越多可读性越差函数式编程函数式编程简称近些年函数式以其优雅简单的特点开始重新风靡整个编程界主流语言在设计的时候无一例外都会更多的参考函数式特性表达式原生支持命令式编程一步一步执行原始操作逐步实现目标更加底层和繁琐声明式编程侧重于使用工具简化操作通过高层次的描述目标来实现功能函数式编程输入声明式编程的一种重点在于如何制作工具编程世界中我们需要处理的其实也只有数据和关系而关系就是函数或者说是一种映射而这种映射关系是可以组合的函数式编程其实就是强调在编程过程中把更多的关注点放在如何去构建关系函数式编程就像第三次工业革命前两次分别为命令式编程和面向对象编程从演算深入了解函数式编程的函数式编程参考参考书籍与中的函数式编程参考中的函数式编程实现前提函数是一等公民这是函数式编程得以实现的前提因为我们基本的操作都是在操作函数这个特性意味着函数与其他数据类型一样处于平等地位可以赋值给其他变量可以作为参数传入另一个函数可以作为别的函数的返回值纯函数纯函数是函数式编程的基石纯函数是指在给定相同输入的情况下将始终返回相同输出且没有任何可观察的副作用的函数定义输出完全取决于输入没有副作用副作用在我们函数中最主要的功能当然是根据输入返回结果而在函数中我们最常见的副作用就是随意操纵外部变量使全局状态变化改变其输入参数如果输入参数是个引用类型会导致副作用执行任何操作注意纯函数并非完全不能读写外部的数据如果外部数据可控那么也可以读写相关理解参考数据不可变章节作为对比不纯函数有如下特征输入参数以外的因素会影响输出可能导致副作用纯函数的优点其优点也正是为什么引入纯函数的原因并行化纯函数可以并行化即它们可以同时执行充分利用多个核心或分布式计算环境这是因为纯函数没有副作用使得它们可以安全地并发执行而不影响总体结果惰性求值所谓惰性执行指的是函数只在需要的时候执行即不产生无意义的中间变量函数式编程跟命令式编程最大的区别就在于几乎没有中间变量它从头到尾都在写函数只有在真正需要时才会被计算记忆化纯函数可以被记忆化即函数的输出被缓存并在同样的输入再次出现时被重复使用这项技术消除了一次性计算的需要减少执行时间和提高了总体性能记忆化特别适合于处理昂贵的计算或操作通过存储纯函数的结果可以避免冗余的计算并专心于更重要的任务易于测试纯函数易于测试因为它们的输出是确定性的即它们总是返回相同的结果给定相同的输入这使得编写单元测试变得简单因为输出是可预测的不依赖于外部状态无状态和数据不可变无状态无状态主要是强调对于一个函数不管你何时运行它都应该像第一次运行一样给定相同的输入给出相同的输出完全不依赖外部状态的变化数据不可变比如说外界变量是个变量的话那么该函数依旧是个纯函数如果在递归中要共享一个外部变量可是使用这种方式其他代码递归调用该代码实现了一种机制即如果不存在则在函数体内初始化空间高阶函数高阶函数在函数式编程中高阶函数是指可以满足以下任一条件的函数接收一个或多个函数作为参数在这种情况下高阶函数可以利用其他函数来执行某些操作这使得函数的行为可以变得动态和可配置返回一个函数作为结果高阶函数可以生成新的函数有时候也称为工厂函数这允许创建可复用和灵活的代码结构高阶函数是函数式编程的核心概念之一高阶函数可以帮助提高代码的可重用性和模块化因为它们允许程序员将行为抽象出来并动态地组合不同的功能这种灵活性使得程序更容易维护和扩展通过高阶函数我们可以实现诸如事件处理回调机制装饰器策略模式等设计模式从而使代码更加简洁和易于理解常用高阶函数等常见的高阶函数功能说明将函数应用于集合中的每个元素生成一个新集合过滤集合中的元素只保留满足条件的元素使用累积函数将集合归约为单个值对集合中的每个元素执行指定操作检查集合中是否存在至少一个满足条件的元素检查集合中是否所有元素都满足条件返回集合中第一个满足条件的元素组合函数和管道函数常规的链式调用也可以达到函数组合的效果但是链式调用有个很苛刻的条件那就是返回值必须为也就是说链式调用实际上是一种面向对象的思想管道函数正向数据流方向更符合人类的阅读习惯组合函数反向数据流方向更符合函数式编程理论中的组合原则这是因为数学函数组合通常以这种从右到左的方式定义中使用实现组合使用组合函数偏函数与柯里化通过把已知函数的一个或多个参数设定为特定值的方法创建新函数的概念称为偏函数应用偏的意思是在计算函数结果时只需传递部分参数而不需要传递所有参数柯里化柯里化是偏函数中的一个特例柯里化每次只固定一个参数柯里化的必要性为了使用高阶函数统一参数的个数等情况因此柯里化是必须的案例下面展示偏函数和柯里化的案例可以逐个接收参数并在参数个数达到原函数所需的数量时调用原函数柯里化偏函数偏函数和柯里化各自的适用场景当有一个要绑定其参数的特定函数时偏函数比较有用当函数可以有任意多个参数时柯里化很实用下面内容还没很明白单子例子函子单子例子简单理解是一台可以一步一步进行工作的机器它会在你完成一步工作之后根据结果自动决定下一步去做什么例子假设你在盒子里找东西如果找到继续处理下一个步骤如果没找到就停止这就是的工作过程它帮你顺序处理一系列操作可以不停地打包打开盒子非常适合处理可能失败或者有风险的步骤和简单理解就像一个有弹性的手套你可以把手函数放进去操作其中的东西而不直接接触它想象一下数据是放在盒子中的允许你在不打开这个盒子的情况下对数据进行修改例子想象你有一个盒子比如一个列表或是一个选项然后你有一个功能去增大里面的所有东西使用你可以不用打开盒子而是将这个增大功能传给盒子它自己去处理简单理解就像多条生产线上的机器抓手可以同时加工多个零件它不仅能对盒子中的每个元素作同样的操作还能把多个盒子里的东西配对起来进行操作例子继续上面的比喻如果你有两个盒子一个装着数字另一个装着的功能你可以用把数字盒子和功能盒子结合起来得到结果盒子惰性求值架构相关库盘点消息队列框架依赖注入容器依赖注入简称容器是一种用于管理对象之间依赖关系的设计模式和工具它的基本原理是在程序运行时通过容器自动为对象注入所需要的依赖而不需要由对象自己创建或管理这些依赖在更简单的术语中依赖注入容器帮助你将对象的创建与对象的使用分开让你不需要手动处理对象间的依赖关系容器会自动完成这一过程容器的作用依赖注入容器如等会管理这些依赖关系并确保类的实例在需要时能够自动获取所依赖的对象它将这些依赖关系保存在容器内部并提供一种机制来注入这些依赖注入的方式构造函数注入依赖通过类的构造函数传入方法注入依赖通过类中的某个方法传入字段注入依赖通过类的字段通常是类的成员变量传入容器的作用注册组件开发者将对象或服务通常称为或服务注册到容器中告诉容器这个类需要哪些依赖创建对象当需要创建对象时容器会根据已注册的信息自动为对象注入依赖项管理生命周期容器不仅负责对象的创建还可能负责对象的销毁依赖的管理等依赖注入容器的好处解耦对象不再直接负责创建它依赖的对象而是通过容器来管理减少了类之间的耦合便于测试可以通过模拟对象来进行单元测试不需要担心依赖项的具体实现灵活性可以动态地调整和替换依赖方便管理和扩展系统生命周期管理容器可以管理对象的生命周期确保每个对象在合适的时机被创建和销毁实现一个简易容器自建简易容器将对象设置到依赖注入容器中避免重复添加并且线程安全泛型版本这样可以在初始化的时候只传一个参数从依赖注入容器中获取对象的泛型版本这样可以在获取时免传参数用于存储对象和类型字典实际上不是安全的下面改成使用线程安全的字典引入泛型接口后改成如下使用方式用于判断两个对象实际上是否是同一个引入泛型接口后改成如下使用方式开始测试依赖注入的关键就是我问你要类型你给我实例更详细的依赖注入容器可以参考开源的的代码依赖注入的实现上面代码只体现了一个容器但没有实现类似构造函数注入的特性实现的核心原理在于依赖注入容器通过反射分析类的构造函数和参数类型然后自动匹配容器中注册的依赖对象依赖注入容器通过反射和递归依赖解析来实现容器会在获取对象时首先分析该类型的构造函数查找其依赖的参数类型并递归地从容器中获取这些依赖项然后通过构造函数注入这些依赖从而实现自动注入这是依赖注入容器的核心特性之一也是它与手动创建对象的区别之一入门反射',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-08-19 14:10:13',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://th.bing.com/th/id/OIP.wtmjepfWPBvn26uz7s18dgHaHa?rs=1&amp;pid=ImgDetMain"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">ZEROKO14的个人博客</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AI/" style="font-size: 1.05rem;">AI<sup>1</sup></a><a href="/tags/C/" style="font-size: 1.05rem;">C#<sup>3</sup></a><a href="/tags/C/" style="font-size: 1.05rem;">C++<sup>5</sup></a><a href="/tags/CSS/" style="font-size: 1.05rem;">CSS<sup>1</sup></a><a href="/tags/CSharp/" style="font-size: 1.05rem;">CSharp<sup>1</sup></a><a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 1.05rem;">C语言<sup>1</sup></a><a href="/tags/FPS/" style="font-size: 1.05rem;">FPS<sup>1</sup></a><a href="/tags/HTML/" style="font-size: 1.05rem;">HTML<sup>1</sup></a><a href="/tags/JavaScript/" style="font-size: 1.05rem;">JavaScript<sup>1</sup></a><a href="/tags/MFC/" style="font-size: 1.05rem;">MFC<sup>1</sup></a><a href="/tags/PE/" style="font-size: 1.05rem;">PE<sup>1</sup></a><a href="/tags/QT/" style="font-size: 1.05rem;">QT<sup>1</sup></a><a href="/tags/WPF/" style="font-size: 1.05rem;">WPF<sup>3</sup></a><a href="/tags/ai/" style="font-size: 1.05rem;">ai<sup>1</sup></a><a href="/tags/cmake/" style="font-size: 1.05rem;">cmake<sup>1</sup></a><a href="/tags/doxygen/" style="font-size: 1.05rem;">doxygen<sup>1</sup></a><a href="/tags/git/" style="font-size: 1.05rem;">git<sup>1</sup></a><a href="/tags/linux/" style="font-size: 1.05rem;">linux<sup>1</sup></a><a href="/tags/nas/" style="font-size: 1.05rem;">nas<sup>1</sup></a><a href="/tags/next/" style="font-size: 1.05rem;">next<sup>1</sup></a><a href="/tags/ppt/" style="font-size: 1.05rem;">ppt<sup>1</sup></a><a href="/tags/python/" style="font-size: 1.05rem;">python<sup>1</sup></a><a href="/tags/slidev/" style="font-size: 1.05rem;">slidev<sup>1</sup></a><a href="/tags/vue/" style="font-size: 1.05rem;">vue<sup>1</sup></a><a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 1.05rem;">代码规范<sup>1</sup></a><a href="/tags/%E5%86%85%E6%A0%B8/" style="font-size: 1.05rem;">内核<sup>2</sup></a><a href="/tags/%E5%86%85%E6%A0%B8%E7%9B%B8%E5%85%B3/" style="font-size: 1.05rem;">内核相关<sup>5</sup></a><a href="/tags/%E5%8A%A0%E8%A7%A3%E5%AF%86/" style="font-size: 1.05rem;">加解密<sup>1</sup></a><a href="/tags/%E5%9F%BA%E7%A1%80/" style="font-size: 1.05rem;">基础<sup>6</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 1.05rem;">多线程<sup>1</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F/" style="font-size: 1.05rem;">并发模式<sup>1</sup></a><a href="/tags/%E5%BC%80%E5%8F%91/" style="font-size: 1.05rem;">开发<sup>4</sup></a><a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 1.05rem;">数学<sup>1</sup></a><a href="/tags/%E6%9D%82%E9%A1%B9/" style="font-size: 1.05rem;">杂项<sup>1</sup></a><a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 1.05rem;">正则表达式<sup>1</sup></a><a href="/tags/%E7%89%A9%E7%90%86/" style="font-size: 1.05rem;">物理<sup>1</sup></a><a href="/tags/%E7%9B%91%E6%8E%A7/" style="font-size: 1.05rem;">监控<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 1.05rem;">网络<sup>3</sup></a><a href="/tags/%E9%80%86%E5%90%91/" style="font-size: 1.05rem;">逆向<sup>5</sup></a><a href="/tags/%E9%AD%94%E6%B3%95/" style="font-size: 1.05rem;">魔法<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/09/"><span class="card-archive-list-date">九月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/02/"><span class="card-archive-list-date">二月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/12/"><span class="card-archive-list-date">十二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/11/"><span class="card-archive-list-date">十一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/09/"><span class="card-archive-list-date">九月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">七月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">14</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/06/"><span class="card-archive-list-date">六月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/04/"><span class="card-archive-list-date">四月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url">技术</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E6%9E%B6%E6%9E%84/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>架构</span></a></span></div></div><h1 class="post-title" itemprop="name headline">架构</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-06-02T08:23:39.382Z" title="发表于 2024-06-02 16:23:39">2024-06-02</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-08-19T06:10:13.921Z" title="更新于 2025-08-19 14:10:13">2025-08-19</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="架构"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为新加坡"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>新加坡</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://che77a38.github.io/posts/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/"><header><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url">技术</a><a href="/tags/%E6%9E%B6%E6%9E%84/" tabindex="-1" itemprop="url">架构</a><h1 id="CrawlerTitle" itemprop="name headline">架构</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">ZEROKO14</span><time itemprop="dateCreated datePublished" datetime="2024-06-02T08:23:39.382Z" title="发表于 2024-06-02 16:23:39">2024-06-02</time><time itemprop="dateCreated datePublished" datetime="2025-08-19T06:10:13.921Z" title="更新于 2025-08-19 14:10:13">2025-08-19</time></header><p>此处记录架构相关的知识</p>
<span id="more"></span>

<h1 id="最宏观的架构盘点"><a href="#最宏观的架构盘点" class="headerlink" title="最宏观的架构盘点"></a>最宏观的架构盘点</h1><ul>
<li><p><strong>分层架构(LAYERED)</strong>: 通过层次分离确保系统的可维护性</p>
<p>优点:低层可复用</p>
<p>缺点:在高性能应用程序中的性能很差,因为通过多个层来满足业务请求的效率不高</p>
<p>适用场景: 通常用于构建一般的桌面应用程序以及相对简单的web应用程序</p>
</li>
<li><p><strong>客户端服务器模式</strong></p>
<p>缺点: 服务器可能成为性能瓶颈和单点故障</p>
<p>适用场景: 在线应用程序,如电子邮件,共享文档系统和银行业务</p>
</li>
<li><p><strong>模型视图控制器模式</strong></p>
</li>
<li><p><strong>事件驱动架构</strong>: 通过组件间的松耦合实现高灵活性</p>
</li>
<li><p><strong>事件总线模式</strong>: 现代企业软件通常构建为分布式系统,可以为异步到达的与大量事件相关的消息提供服务.在事件总线上,事件源将消息发布到特定的通道,监听器订阅特定的通道,监听器收到所订阅的通道中的消息通知</p>
<p>缺点: 因为所有消息都通过相同的总线传输,这种模式的可伸缩性是一个问题</p>
<p>适用场景: Android开发,电子商务应用程序和通知服务中</p>
</li>
<li><p><strong>管道过滤模式(PIPE-FILTER)</strong>: 单个事件触发一系列处理步骤,每个步骤执行特定的功能.将复杂消息流转换为唯一的简单纯文本顺序消息流,而不需要额外的数据字段.管道和过滤器体系结构将较大的处理任务划分为一系列较小的独立处理步骤或过滤器,这些处理步骤和过滤器通过管道互相连接</p>
<p>适用场景: 常用于连续过滤器执行词法分析,解析语义分析和代码编译器中</p>
</li>
<li><p><strong>微内核架构</strong>: 将核心功能与插件分离,提高系统的可拓展性</p>
</li>
<li><p><strong>微服务架构</strong>: 通过服务的独立开发和部署提升系统的敏捷性</p>
<p>现代程序复杂性越来越高,单体应用可能会变得过于庞大和复杂,无法有效地支持和部署.解决方案就是微服务架构,每个服务都可以<strong>独立的部署和拓展</strong>,并且有自己的API边界.不同的服务器可以由不同的编程语言编写,管理自己的数据库,并由不同的团队开发                                                                                                                                                                                                                                                                        </p>
</li>
<li><p><strong>单体架构</strong>: 将所有组件打包成一个单元,简化开发和部署过程</p>
</li>
<li><p><strong>代理模式</strong>: 这种模式用解耦的组件来构造分布式系统,这些组件可以通过远程服务调用互相交互.代理组件负责协调组件之间的通信,服务器将其功能发布给代理,客户端从代理请求服务,然后代理将客户端重定向到其注册中心的服务.代理模式允许对象的动态更改,添加删除和重定位,使请求分发对开发人员透明</p>
<p>适用场景: 常用于消息代理软件,如Kafka,rabbit mq</p>
</li>
<li><p><strong>点对点模式</strong>(PEER-TO-PEER): 这种模式中,每个组件被称为节点.节点既可以作为向其他节点请求服务的客户端,也可以作为向其他节点提供服务的服务器.p2p模式支持分布式计算</p>
<p>优点:具有很强的健壮性和可拓展性</p>
<p>缺点: 由于节点之间是自愿合作,因此服务质量无法得到保证,此外安全性无法保证,系统性能往往依赖于节点的数量</p>
<p>适用场景: 常用于文件共享网络,以及基于加密货币的产品如比特币</p>
</li>
<li><p><strong>黑板模式(BLACKBOARD)</strong>:对于那些没有确定解决方案策略的问题,这种模式非常有用.由3个部分组成:</p>
<ol>
<li>黑板数据结构: 按照与应用程序相关的层次来组织并解决问题的数据,知识源通过不断地改变黑板数据来解决问题,知识源通过不断改变黑板数据来解决问题</li>
<li>知识源: 包含独立的,与应用程序相关的知识,知识源之间不直接进行通讯,他们之间的交互只通过黑板来完成</li>
<li>控制组件: 完全由黑板的状态驱动,黑板状态的改变决定了需要使用的特定知识</li>
</ol>
<p>优点: 很容易拓展数据空间的结构</p>
<p>缺点: 然而修改数据空间的结构是困难的,因为所有应用程序都会受到影响</p>
<p>适用场景: 常用于语音识别,蛋白质结构识别</p>
</li>
<li><p><strong>主从模式(MASTER-SLAVE)</strong>: 由主和从组成.主组件将工作分配给从组件,并根据从组件返回的结果计算出最终结果</p>
<p>优点:准确性,服务的执行委托给具有不同实现的不同从服务器执行</p>
<p>缺点: 只能应用于可分解的问题</p>
<p>适用场景: 常用于将主数据库视为权威的源数据库,并将数据库同步到从库</p>
</li>
</ul>
<h1 id="领域驱动设计"><a href="#领域驱动设计" class="headerlink" title="领域驱动设计"></a>领域驱动设计</h1><p>这类理论都是由软件设计领域的大牛(如Martin Fowler)提出来的</p>
<p>领域模型分为4大类</p>
<ul>
<li><a href="#%E5%A4%B1%E8%A1%80%E6%A8%A1%E5%9E%8B">失血模型</a></li>
<li><a href="#%E8%B4%AB%E8%A1%80%E6%A8%A1%E5%9E%8B">贫血模型</a></li>
<li><a href="#%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B">充血模型</a>   </li>
<li><a href="#%E8%83%80%E8%A1%80%E6%A8%A1%E5%9E%8B">胀血模型</a></li>
</ul>
<p><strong>“血”指的是Domain Object的Domain层内容</strong></p>
<p><strong>在这四种模型当中，失血模型和胀血模型应该是不被提倡的。而贫血模型和充血模型从技术上来说，都是可行的。但是我个人仍然主张使用贫血模型。其理由：</strong></p>
<ul>
<li>虽然贫血模型的Domain Object确实不够rich，但Domain Object只包含属于它本身的领域逻辑，不包含持久化逻辑，将有效的隔离和屏蔽了持久化技术，进而可以对持久化技术进行灵活的替换。</li>
<li>贫血模型中提出的按照是否依赖持久化进行划分，这种标准是非常确定的，不会引起开发团队设计上的争议。</li>
</ul>
<h2 id="失血模型"><a href="#失血模型" class="headerlink" title="失血模型"></a>失血模型</h2><p><strong>Domain Object（领域对象）</strong>模型仅仅包含<strong>对象属性的定义</strong>和操作对象属性的<strong>getter&#x2F;setter方法</strong>，<strong>所有的业务逻辑完全由Business Logic层(业务逻辑层)中的服务类来完成。</strong>这种类在java中叫POJO，在.NET中叫POCO</p>
<ul>
<li><p>优点</p>
<p>领域对象结构简单</p>
</li>
<li><p>缺点</p>
<p>肿胀的业务服务代码逻辑,难于理解和维护</p>
<p>无法良好的应对复杂业务逻辑和场景</p>
</li>
</ul>
<h2 id="贫血模型"><a href="#贫血模型" class="headerlink" title="贫血模型"></a>贫血模型</h2><p><strong>Domain Object（领域对象）</strong>模型包含<strong>对象属性的定义</strong>和操作对象属性的<strong>getter&#x2F;setter方法</strong>并<strong>包含了对象的行为</strong>（例如：<strong>就像一个完整的人，具有一些属性如姓名、性别、年龄等，还具有一些能力，如走路、吃饭、恋爱等，这样才是一个完整的对象），</strong> 但<strong>不包含依赖Dao层(持久层)的业务逻辑</strong>。这部分依赖于Dao层的业务逻辑将会放到<strong>Business Logic层</strong>（业务逻辑层）中的<strong>服务类来实现</strong>，<strong>组合逻辑也由服务类负责</strong>。可以看出，<strong>贫血模型中的领域对象是不依赖于持久层的</strong>。<strong>代码架构层次结构是</strong>： <strong>Client-&gt; Business Facade Service -&gt; Business Logic Service(<strong>Business Logic Service是依赖Domain Object的行为</strong>) -&gt; Data Access Service</strong></p>
<ul>
<li><p>优点</p>
<p>层次结构清楚,各层之间单向依赖</p>
<p>对于只有少量业务逻辑的应用来说,使用起来非常自然</p>
<p>开发迅速,易于理解</p>
</li>
<li><p>缺点</p>
<p>无法良好的应对非常复杂逻辑和场景</p>
</li>
</ul>
<h2 id="充血模型"><a href="#充血模型" class="headerlink" title="充血模型"></a>充血模型</h2><p><strong>Domain Object（领域对象）</strong>模型包含<strong>对象属性的定义</strong>和操作对象属性的<strong>getter&#x2F;setter方法</strong>并<strong>包含了大多数相关的业务逻辑，也包含了依赖于持久层的业务逻辑， Business Logic层是很薄的一层，仅仅简单封装少量业务逻辑以及控制事务、权限逻辑等，不和DAO层打交道</strong>。所以<strong>，使用充血模型的领域对象是依赖于持久层的。代码架构层次结构是</strong>： <strong>Client-&gt; Business Facade Service -&gt; Business Logic Service</strong> <strong>-&gt; Domain Object -&gt; Data Access Service</strong></p>
<ul>
<li><p>优点</p>
<p>更符合OO的原则</p>
<p>Business Logic层很薄,<strong>符合单一职责，不像在贫血模型里面那样包含所有的业务逻辑太过沉重，</strong>只充当Facade的角色，不和DAO打交道</p>
</li>
<li><p>缺点</p>
<p>什么样的逻辑应该放在Domain Object中，什么样的业务逻辑应该放在Business Logic中，这是很含糊的。即使划分好了业务逻辑，由于分散在Business Logic和Domain Object层中，不能更好的分模块开发。熟悉业务逻辑的开发人员需要渗透到Domain Logic中去，而在Domian Logic又包含了持久化，对于开发者来说这十分混乱。 </p>
<p>其次，因为Business Logic要控制事务并且为上层提供一个统一的服务调用入口点，它就必须把在Domain Logic里实现的业务逻辑全部重新包装一遍，完全属于重复劳动。</p>
</li>
</ul>
<h2 id="胀血模型"><a href="#胀血模型" class="headerlink" title="胀血模型"></a>胀血模型</h2><p><strong>Domain Object（领域对象）</strong>模型包含<strong>对象属性的定义</strong>和操作对象属性的<strong>getter&#x2F;setter方法</strong>并<strong>包含了所有相关的的业务逻辑，也包含了不想关的其它应用逻辑（如授权、事务等）。</strong>胀血模型<strong>取消了Business Logic层(业务逻辑层)<strong>，</strong>只剩下Domain Object和DAO两层</strong>，在Domain Object的Domain Logic上面<strong>封装事务，授权逻辑等</strong>。</p>
<ul>
<li><p>优点</p>
<p>简化了代码分层结构</p>
<p>也算符合面向对象设计</p>
</li>
<li><p>缺点</p>
<p>取消了Business Logic层(业务逻辑层)，在Domain Object的Domain Logic上面封装事务，授权等很多本不应该属于领域对象的逻辑，使业务逻辑再次进行到混论的状态，引起了Domain Object模型的不稳定</p>
<p>代码理解和维护性差</p>
</li>
</ul>
<h1 id="DDD分层架构模型"><a href="#DDD分层架构模型" class="headerlink" title="DDD分层架构模型"></a>DDD分层架构模型</h1><p><strong>它包括用户接口层、应用层、领域层和基础层，分层架构各层的职责边界非常清晰，又能有条不紊地分层协作。</strong></p>
<ul>
<li><strong>用户接口层</strong>：面向前端提供服务适配，面向资源层提供资源适配。这一层聚集了接口适配相关的功能。</li>
<li><strong>应用层职责</strong>：实现服务组合和编排，适应业务流程快速变化的需求。这一层聚集了应用服务和事件相关的功能。</li>
<li><strong>领域层</strong>：实现领域的核心业务逻辑。这一层聚集了领域模型的聚合、聚合根、实体、值对象、领域服务和事件等领域对象，以及它们组合所形成的业务能力。</li>
<li><strong>基础层</strong>：贯穿所有层，为各层提供基础资源服务。这一层聚集了各种底层资源相关的服务和能力。</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202501160934966.png" alt="image-20250116093436059" style="zoom: 33%;" />

<p>分层架构的<strong>一个重要原则是每层只能与位于其下方的层发生耦合。</strong></p>
<p><strong>分层架构可以简单分为两种，即严格分层架构和松散分层架构</strong>。在<strong>严格分层架构</strong>中，<strong>某层只能与位于其直接下方的层发生耦合</strong>，而在<strong>松散分层架构中</strong>，则允许<strong>某层与它的任意下方层发生耦合</strong>。</p>
<p><strong>分层架构的优点，Martin Fowler在《Patterns of Enterprise Application Architecture》一书中给出了答案：</strong></p>
<ol>
<li>开发人员可以只关注整个结构中的某一层</li>
<li>可以很容易的用新的实现来替换原有层次的实现</li>
<li>可以降低层与层之间的依赖</li>
<li>有利于标准化</li>
<li>有利于各层逻辑的复用</li>
</ol>
<p><strong>适当的分层体系结构将开发层面进行隔离，这些层不受其他层的更改的影响，从而使重构更加容易。</strong>划分任务并定义单独的层是架构师面临的挑战。当需求很好地适应了模式时，这些层将易于解耦或分层开发。</p>
<p><strong>使用场景：</strong></p>
<ul>
<li>需要快速构建的新应用程序</li>
<li>需要严格的可维护性和可测试性标准的应用</li>
</ul>
<h1 id="解决90-问题的异步架构"><a href="#解决90-问题的异步架构" class="headerlink" title="解决90%问题的异步架构"></a>解决90%问题的异步架构</h1><p>降低代码的复杂度</p>
<p>对功能组件进行解耦</p>
<p>The forward Logic is only about 10% of your code，everything else is 90%.         – Michael Stonebraker</p>
<p>开发的过程中遇到的问题盘点:</p>
<ul>
<li>业务逻辑冲突的处理规则</li>
<li>数据完整性的保护机制</li>
<li>超时规则</li>
<li>重试规则</li>
</ul>
<p>诸如此类的问题起码占到了代码开发的90%</p>
<p>异步解决一切问题</p>
<blockquote>
<p>async和await这类代码能删除”等待”这个行为,统一管理和分配每一个步骤的执行</p>
</blockquote>
<ul>
<li>管理池 master: 只负责管理</li>
<li>任务池 slaves: 负责分配这些资源来处理任务</li>
<li>重试池 retry: 灵活分配资源,当遇到接口故障的时候,可以直接暂停分配资源给这些重试支付的任务</li>
</ul>
<p>好处在于可以灵活的分配资源去独立处理每一个任务的每一个步骤</p>
<h2 id="异步架构的技术选型"><a href="#异步架构的技术选型" class="headerlink" title="异步架构的技术选型"></a>异步架构的技术选型</h2><p>打造这种异步的任务流水线,最需要解决的就是负责登记任务,跟踪进度,分配资源和进行调度的这一部分,最好的解决方案就是消息队列框架</p>
<p>比如说RabbitMQ,Kafka</p>
<h1 id="事件驱动架构"><a href="#事件驱动架构" class="headerlink" title="事件驱动架构"></a>事件驱动架构</h1><p>事件驱动的核心是触发机制(trigger)和推送机制(pub&#x2F;sub)</p>
<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><h1 id="三种消息传递模式详解"><a href="#三种消息传递模式详解" class="headerlink" title="三种消息传递模式详解"></a>三种消息传递模式详解</h1><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202409081116297.png" alt="image-20240908111620780"></p>
<p>图中的“生产者状态”和“消费者状态”指的是各自保存消息传递的状态信息，以便在失败或重试时恢复到正确的状态。</p>
<ul>
<li><strong>最多一次</strong>：消息可能丢失，但不会重复，适用于对可靠性要求低的场景。</li>
<li><strong>至少一次</strong>：消息不会丢失，但可能会重复，适用于对消息丢失不可接受的场景。</li>
<li><strong>精确一次</strong>：消息既不会丢失也不会重复，适用于对可靠性和一致性要求高的场景。</li>
</ul>
<p>盘点生产者与消费者之间的消息传递行为，以及这些模式的可靠性和特点</p>
<ol>
<li><p><strong>最多一次传递（At-most-once delivery）</strong>：</p>
<p>描述：生产者发送消息后，不会尝试再次发送，即便消息丢失。这意味着消息可能会被消费者成功接收到，也可能会在传输中丢失。</p>
<p>风险：消息可能会<strong>丢失</strong>，生产者并不重试发送。</p>
<p>应用场景：适用于一些对数据完整性要求不高的场景，比如不需要重试的通知。</p>
</li>
<li><p><strong>至少一次传递（At-least-once delivery）</strong>：</p>
<p>描述：生产者在发送消息后，保存状态并尝试重发消息，直到收到消费者的确认。这会确保消费者至少会收到一次消息。</p>
<p>风险：消费者可能会<strong>接收到重复消息</strong>，因为生产者在未确认的情况下会多次重发。</p>
<p>应用场景：常用于对消息丢失不能容忍，但能处理重复消息的场景，比如日志系统或审计系统。</p>
</li>
<li><p><strong>精确一次传递（Exactly-once delivery）</strong>：</p>
<p>描述：这是最强的消息传递语义，保证生产者和消费者都对消息进行状态保存，以确保消息<strong>恰好传递一次</strong>。消息不会丢失，也不会重复。</p>
<p>风险：无重复也无丢失，但需要较复杂的实现（通常需要使用事务性操作）。</p>
<p>应用场景：适用于对消息传递的正确性有严格要求的场景，如金融交易系统、账务系统等。</p>
</li>
</ol>
<blockquote>
<p><strong>“精确一次传递”（Exactly-once delivery）</strong>是指在数据传输或消息传递过程中，确保每条消息只被处理一次且仅处理一次的特性。这一特性在分布式系统、消息队列和数据库等场景中非常重要，因为它能有效避免重复处理和数据丢失的问题。</p>
<p>理解“精确一次传递”的原理，可以从以下几个方面进行分析：</p>
<ol>
<li><p><strong>消息标识</strong>：每条消息通常会有一个唯一的标识符（ID），接收方在处理消息时会记录已处理的消息ID，以避免重复处理。</p>
</li>
<li><p><strong>幂等性</strong>：在接收方的处理逻辑中，应该设计成幂等的，即多次处理同一条消息的结果是相同的。这样，即使消息被重复处理，也不会产生不一致的状态。</p>
</li>
<li><p><strong>事务机制</strong>：在发送和接收消息的过程中，通常会使用事务来确保操作的原子性。例如，在数据库操作中，可以通过事务来确保数据的一致性和完整性。</p>
</li>
<li><p><strong>确认机制</strong>：发送方在发送消息后，会等待接收方的确认（acknowledgment），只有在收到确认后，才会认为消息成功传递。这可以减少消息丢失的风险。</p>
</li>
<li><p><strong>重试机制</strong>：如果发送方没有收到确认，它会重新发送消息。通过合理的重试策略，可以确保消息最终被成功传递。</p>
</li>
<li><p><strong>状态管理</strong>：系统需要维护一定的状态信息，以跟踪消息的发送和处理情况，这样可以避免在系统故障或网络问题时造成的数据丢失或重复处理。</p>
</li>
</ol>
<p>总之，精确一次传递的实现需要结合多个技术手段和设计原则，以确保在各种情况下都能保证消息的唯一性和一致性。</p>
</blockquote>
<h1 id="重试机制"><a href="#重试机制" class="headerlink" title="重试机制"></a>重试机制</h1><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202409081119824.png" alt="image-20240908111924396"></p>
<p>展示了几种<strong>回退（Backoff）策略</strong>在<strong>重试时间线（Retry timeline）上的表现，横轴为回退时间（Backoff time）</strong>，纵轴表示<strong>重试次数（Retry timeline）</strong>。回退策略常用于网络请求或分布式系统中的重试机制，以避免频繁请求或冲突。图片列出了几种常见的回退策略，并展示了它们在不同时间点的表现：</p>
<ol>
<li><p><strong>No Backoff（无回退）</strong>：</p>
<p>这条线是平坦的，表示在失败时，系统不会等待，而是立刻重试。这种方法容易造成网络或系统的过载。</p>
</li>
<li><p><strong>Constant Backoff（常量回退）</strong>：</p>
<p>这条线也是平坦的，表明每次重试之间的等待时间是固定的，例如每次都等待相同的时间间隔。虽然这种策略避免了无间隔的重试，但对于某些情况来说，它的效率可能不够高。</p>
</li>
<li><p><strong>Linear Backoff（线性回退）</strong>：</p>
<p>这条线呈现出斜率逐渐增大的趋势，表示每次重试的间隔时间逐渐增加，但增加幅度是线性的。线性回退意味着每次重试等待的时间都会按固定的增量递增。</p>
</li>
<li><p><strong>Fibonacci Backoff（斐波那契回退）</strong>：</p>
<p>这条线表示每次重试的间隔时间按照斐波那契数列增长。相比线性回退，它的增长更加渐进，且在初期增长较为平缓。</p>
</li>
<li><p><strong>Quadratic Backoff（二次回退）</strong>：</p>
<p>这条线表示每次重试的间隔时间按二次方的规律增长。随着时间推移，间隔时间会迅速增加，这种方法可以有效避免高频重试对系统的冲击。</p>
</li>
<li><p><strong>Exponential Backoff（指数回退）</strong>：</p>
<p>这条线表示每次重试的间隔时间呈指数增长。最初增长较慢，但后期增长非常快。指数回退常用于网络重试中，特别是应对高并发时，指数增加等待时间可以减轻系统压力。</p>
</li>
<li><p><strong>Polynomial Backoff（多项式回退）</strong>：</p>
<p>这条线的增长速度最快。多项式回退的增长速度比指数回退更快，间隔时间的增加幅度更加剧烈。一般用于系统对重试频率的容忍度极低的场景。</p>
</li>
</ol>
<p><strong>总结：</strong></p>
<ul>
<li><strong>No Backoff</strong> 和 <strong>Constant Backoff</strong> 适合简单场景，且系统负载较低时使用。</li>
<li><strong>Linear</strong>、<strong>Fibonacci</strong> 和 <strong>Quadratic Backoff</strong> 是中间方案，随着重试次数的增加，系统等待时间也逐渐增加，适用于大多数实际应用。</li>
<li><strong>Exponential</strong> 和 <strong>Polynomial Backoff</strong> 适合在高负载或高并发的情况下使用，能够显著减少系统压力，避免频繁重试。</li>
</ul>
<h1 id="接口架构"><a href="#接口架构" class="headerlink" title="接口架构"></a>接口架构</h1><h2 id="统一接口架构"><a href="#统一接口架构" class="headerlink" title="统一接口架构"></a>统一接口架构</h2><p>前端的变动往往是频繁的,琐碎的,由此会波及到后端的部分,就很容易形成任务进度上的瓶颈</p>
<p>统一接口架构一次性解决了这个问题,每个页面的http信息都可以在一个http请求里传达清楚</p>
<p>结构的定义就是统一前后端交流的语言</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202409082120846.png" alt="image-20240908212030970" style="zoom: 25%;" />

<p>后端要实现数据结构模型和翻译器</p>
<p>很多自动化框架从数据库的schema生成接口的所有的数据结构和翻译器</p>
<ul>
<li>APOLLO</li>
<li>Prisma</li>
<li>HASURA</li>
<li>PostGraphile</li>
</ul>
<p>可以用swagger生成API文档</p>
<p>可能的缺陷:</p>
<ul>
<li>抛弃了rest API就是抛弃了几十年互联网基础设施所提供的强大的缓存能力</li>
<li>合并所有的接口会让权限管理和限速限量等功能开发难度大大提升</li>
</ul>
<h1 id="架构模式"><a href="#架构模式" class="headerlink" title="架构模式"></a>架构模式</h1><p>系统架构模式（Architectural Patterns）是软件系统设计中的高级模式，它提供了结构化和解决复杂问题的框架和策略，旨在提高系统的可扩展性、可维护性、灵活性以及模块化。常见的系统架构模式有以下几种：</p>
<ol>
<li><p><strong>层次化架构模式（Layered Architecture Pattern）</strong></p>
<ul>
<li><strong>描述</strong>：将系统分为多个层，每一层都只与其相邻的层进行交互。典型的分层结构包括表示层（UI）、业务逻辑层（Business Logic）、数据访问层（Data Access）、数据库层等。</li>
<li><strong>用途</strong>：适用于标准化的企业应用程序和Web开发。</li>
<li><strong>示例</strong>：MVC（Model-View-Controller）模式，三层架构（表示层、业务逻辑层、数据层）。</li>
</ul>
</li>
<li><p><strong>微服务架构模式（Microservices Architecture Pattern）</strong></p>
<ul>
<li><strong>描述</strong>：将系统拆分为多个独立的、可部署的微服务，每个微服务专注于特定的业务功能，并通过轻量级的通信（如HTTP或消息队列）进行交互。</li>
<li><strong>用途</strong>：适用于需要高度扩展性和可部署独立组件的大型分布式系统。</li>
<li><strong>示例</strong>：亚马逊、Netflix等使用的微服务架构。</li>
</ul>
</li>
<li><p><strong>事件驱动架构模式（Event-Driven Architecture Pattern）</strong></p>
<ul>
<li><strong>描述</strong>：基于事件机制进行异步通信，系统组件对特定的事件进行监听和响应。事件生产者（Publisher）和事件消费者（Subscriber）通过消息传递中间件解耦。</li>
<li><strong>用途</strong>：适用于需要快速响应变化、解耦复杂依赖的系统，常见于金融系统、监控系统。</li>
<li><strong>示例</strong>：发布&#x2F;订阅模式（Publish&#x2F;Subscribe）、消息队列（如Kafka、RabbitMQ）。</li>
</ul>
</li>
<li><p><strong>微内核架构模式（Microkernel Architecture Pattern）</strong></p>
<ul>
<li><strong>描述</strong>：系统的核心功能保持固定，扩展功能通过插件或附加模块来提供。微内核负责管理和通信，而插件负责具体的业务功能。</li>
<li><strong>用途</strong>：适用于需要灵活扩展、插件化功能的系统，如文本编辑器、IDE等。</li>
<li><strong>示例</strong>：Eclipse IDE、浏览器的插件机制。</li>
</ul>
</li>
<li><p><strong>面向服务架构模式（Service-Oriented Architecture, SOA）</strong></p>
<ul>
<li><strong>描述</strong>：系统由多个松耦合的服务组成，每个服务通过标准协议（如SOAP或REST）提供业务功能。服务可以被复用，并通过服务总线（ESB）进行集成。</li>
<li><strong>用途</strong>：适用于跨企业或跨应用集成的系统。</li>
<li><strong>示例</strong>：企业服务总线（ESB）、Web服务架构。</li>
</ul>
</li>
<li><p><strong>管道-过滤器架构模式（Pipes and Filters Pattern）</strong></p>
<ul>
<li><strong>描述</strong>：将系统的处理任务划分为多个独立的步骤，每个步骤被称为“过滤器”，它们通过“管道”串联。每个过滤器接收输入、处理数据并传递输出给下一个过滤器。</li>
<li><strong>用途</strong>：适用于数据处理流水线、流媒体处理等场景。</li>
<li><strong>示例</strong>：Unix管道（grep、sort、awk等命令的组合）、图像处理流水线。</li>
</ul>
</li>
<li><p><strong>共享数据库架构模式（Shared Database Architecture Pattern）</strong></p>
<ul>
<li><strong>描述</strong>：多个服务或组件共享同一个数据库，彼此通过访问同一数据库中的表来进行通信。这种方式通过数据库实现数据一致性和持久化。</li>
<li><strong>用途</strong>：适用于需要多个系统访问同一数据源的场景。</li>
<li><strong>示例</strong>：企业级应用程序的多模块数据共享。</li>
</ul>
</li>
<li><p><strong>空间分区架构模式（Space-Based Architecture Pattern）</strong></p>
<ul>
<li><strong>描述</strong>：通过将应用程序的处理和存储分区到不同的物理空间，以便系统能够水平扩展。所有组件共享数据和计算负载，避免单点瓶颈。</li>
<li><strong>用途</strong>：适用于需要大规模扩展的实时、高性能系统，如电商平台、社交网络。</li>
<li><strong>示例</strong>：分布式缓存系统、Amazon DynamoDB等。</li>
</ul>
</li>
<li><p><strong>主从架构模式（Master-Slave Architecture Pattern）</strong></p>
<ul>
<li><strong>描述</strong>：主服务器（Master）负责接收请求并将任务分配给从服务器（Slave），每个从服务器执行任务并将结果返回给主服务器。主从结构中，从服务器通常是副本或负载均衡节点。</li>
<li><strong>用途</strong>：适用于需要高可用性和负载均衡的分布式系统。</li>
<li><strong>示例</strong>：MySQL主从复制、Redis主从结构。</li>
</ul>
</li>
<li><p><strong>代理架构模式（Proxy Architecture Pattern）</strong></p>
<ul>
<li><strong>描述</strong>：通过代理（Proxy）来间接访问目标对象，代理可以控制、过滤、或增强对目标对象的访问。</li>
<li><strong>用途</strong>：适用于需要在访问目标对象之前进行控制或优化的场景。</li>
<li><strong>示例</strong>：虚拟代理（延迟加载）、远程代理（分布式对象访问）、保护代理（访问控制）。</li>
</ul>
</li>
<li><p><strong>分层缓存架构模式（Cache-Aside Architecture Pattern）</strong></p>
<ul>
<li><strong>描述</strong>：将缓存层作为独立于应用和数据库的层，用于存储经常访问的数据。应用程序先访问缓存，如果数据不在缓存中，再从数据库中获取。</li>
<li><strong>用途</strong>：适用于高并发访问、高性能数据读取的场景。</li>
<li><strong>示例</strong>：Memcached、Redis缓存策略。</li>
</ul>
</li>
<li><p><strong>分区架构模式（Partitioned Architecture Pattern）</strong></p>
<ul>
<li><strong>描述</strong>：通过水平或垂直分割数据和任务来分配负载。每个分区负责处理特定的数据或任务，并且可以独立扩展。</li>
<li><strong>用途</strong>：适用于需要水平扩展、处理海量数据的场景。</li>
<li><strong>示例</strong>：Hadoop、分布式数据库中的分区机制。</li>
</ul>
</li>
<li><p><strong>中介者架构模式（Mediator Architecture Pattern）</strong></p>
<ul>
<li><strong>描述</strong>：通过一个中介对象来协调多个子系统或模块之间的通信和交互，避免模块之间的直接依赖。</li>
<li><strong>用途</strong>：适用于模块复杂、需要集中控制通信的系统。</li>
<li><strong>示例</strong>：消息中间件（如RabbitMQ）、机场塔台控制系统。</li>
</ul>
</li>
<li><p><strong>代理-客户机架构模式（Client-Server Architecture Pattern）</strong></p>
<ul>
<li><strong>描述</strong>：客户端发起请求，服务器响应请求。客户端和服务器通过网络进行通信。服务器通常处理资源密集型任务，而客户端负责用户交互。</li>
<li><strong>用途</strong>：适用于典型的网络应用场景。</li>
<li><strong>示例</strong>：Web服务器和浏览器、FTP服务器和客户端。</li>
</ul>
</li>
<li><p><strong>REST架构模式（Representational State Transfer, REST）</strong></p>
<ul>
<li><strong>描述</strong>：基于HTTP协议的一种风格，系统以无状态的方式进行交互，使用统一的接口，资源通过URI表示，操作通过HTTP方法（GET, POST, PUT, DELETE）实现。</li>
<li><strong>用途</strong>：适用于Web应用程序和分布式系统。</li>
<li><strong>示例</strong>：大多数现代Web API都基于REST架构。</li>
</ul>
</li>
<li><p><strong>无服务器架构模式（Serverless Architecture Pattern）</strong></p>
<ul>
<li><strong>描述</strong>：不需要显式管理服务器，开发人员将函数部署到云端，云提供商负责自动扩展、维护和运行环境。常用于事件驱动和按需执行的场景。</li>
<li><strong>用途</strong>：适用于事件驱动的应用程序，如实时处理、API调用、批处理任务。</li>
<li><strong>示例</strong>：AWS Lambda、Google Cloud Functions。</li>
</ul>
</li>
<li><p><strong>CQRS（Command Query Responsibility Segregation）架构模式</strong></p>
<ul>
<li><strong>描述</strong>：将读取操作（查询）与写入操作（命令）分离，针对这两种操作使用不同的模型，避免读写模型的相互影响。</li>
<li><strong>用途</strong>：适用于高并发、高可用系统，尤其是读多写少的场景。</li>
<li><strong>示例</strong>：在电商系统中，订单系统使用CQRS来优化读写性能。</li>
</ul>
</li>
</ol>
<p><strong>总结：</strong></p>
<p>系统架构模式为设计软件系统提供了多种标准化的解决方案，每种模式针对不同的系统特性和需求提供相应的结构和设计思路。选择合适的架构模式需要考虑系统的规模、性能要求、扩展性、可维护性以及业务需求。</p>
<h1 id="软件开发设计哲学"><a href="#软件开发设计哲学" class="headerlink" title="软件开发设计哲学"></a>软件开发设计哲学</h1><ol>
<li><p><strong>KISS原则（Keep It Simple, Stupid）</strong>：</p>
<p>该原则强调系统设计应尽可能简单，避免不必要的复杂性。简单的设计更容易理解、维护和扩展。</p>
</li>
<li><p><strong>YAGNI原则（You Aren’t Gonna Need It）</strong>：</p>
<p>YAGNI原则主张在编写代码时，不要为未来可能需要的功能提前做准备。只实现当前需求，避免不必要的复杂性和代码膨胀。</p>
</li>
<li><p><strong>SOLID原则</strong>：</p>
<p>SOLID是五个面向对象设计原则的缩写，分别是：</p>
<ul>
<li><strong>S</strong>ingle Responsibility Principle（单一职责原则）：一个类应该只有一个原因引起变化。</li>
<li><strong>O</strong>pen&#x2F;Closed Principle（开闭原则）：软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。</li>
<li><strong>L</strong>iskov Substitution Principle（里氏替换原则）：子类对象应该能够替换父类对象，而不影响程序的正确性。</li>
<li><strong>I</strong>nterface Segregation Principle（接口隔离原则）：不应强迫任何客户端依赖于它们不使用的接口。</li>
<li><strong>D</strong>ependency Inversion Principle（依赖倒置原则）：高层模块不应依赖于低层模块，二者应依赖于抽象。</li>
</ul>
</li>
<li><p><strong>DRY（Don’t Repeat Yourself）</strong>：</p>
<ul>
<li>不要重复自己，强调在代码中避免重复。</li>
</ul>
<blockquote>
<p>DRY原则强调在系统中同一种信息或逻辑应该只存在一个地方</p>
<p>其所指的重复,包括但不限于:</p>
<ul>
<li><strong>代码重复</strong>：相同的代码片段在多个地方出现。</li>
<li><strong>逻辑重复</strong>：相同的业务逻辑在不同的模块中实现。</li>
<li><strong>数据重复</strong>：相同的数据在多个地方存储。</li>
</ul>
</blockquote>
</li>
<li><p><strong>Separation of Concerns（关注点分离）</strong>：</p>
<ul>
<li>该原则主张将不同的关注点或功能分开，以提高系统的模块化程度和可维护性。</li>
</ul>
</li>
<li><p><strong>Law of Demeter（迪米特法则）</strong>：</p>
<ul>
<li>该原则建议一个对象应尽量少地了解其他对象，强调对象之间的低耦合性。</li>
</ul>
</li>
<li><p><strong>Composition over Inheritance（组合优于继承）</strong>：</p>
<ul>
<li>该原则提倡使用对象组合来实现功能，而不是通过类继承。这有助于提高代码的灵活性和可重用性。</li>
</ul>
</li>
</ol>
<p>这些原则共同构成了现代软件开发的设计哲学，旨在提高代码的可维护性、可读性和灵活性。</p>
<h1 id="函数内部设计建议"><a href="#函数内部设计建议" class="headerlink" title="函数内部设计建议"></a>函数内部设计建议</h1><ol>
<li><p>确保参数有效性</p>
<p>函数入口处的参数检查</p>
<ul>
<li>对指针类型参数或容器进行空检查</li>
<li>对整数浮点数等类型参数进行范围检查</li>
</ul>
</li>
<li><p>减少重复代码(DRY原则)</p>
<p>提取重复部分为辅助函数</p>
</li>
<li><p>处理异常</p>
</li>
<li><p>局部变量初始化</p>
</li>
<li><p>合理利用早退出(Guard Clauses)</p>
</li>
<li><p>优化循环结构</p>
<p>循环中,尽量减少不必要的操作,如将不变的表达式移到循环外</p>
</li>
<li><p>明确函数职责(单一职责原则)</p>
<p>若函数内部逻辑过于复杂,考虑将其拆分成多个小函数</p>
</li>
<li><p>减少嵌套</p>
<p>层级越多,可读性越差</p>
</li>
</ol>
<h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><p>函数式编程（ Functional Programming，简称 FP）</p>
<p>近些年，函数式以其优雅，简单的特点开始重新风靡整个编程界，主流语言在设计的时候无一例外都会更多的参考函数式特性（ Lambda 表达式，原生支持 map ，reduce ……）</p>
<ul>
<li><p>命令式编程  一步一步执行原始操作,逐步实现目标,更加底层和繁琐</p>
</li>
<li><p>声明式编程  侧重于使用工具简化操作,通过高层次的描述目标来实现功能</p>
</li>
<li><p>函数式编程  输入声明式编程的一种,重点在于如何制作工具</p>
<p>编程世界中,我们需要处理的其实也只有“数据”和“关系”,而关系就是函数,或者说是一种映射，而这种映射关系是可以组合的,函数式编程其实就是强调在编程过程中把更多的关注点放在如何去<strong>构建关系</strong></p>
</li>
</ul>
<p>函数式编程就像第三次工业革命，前两次分别为命令式编程（Imperative programming）和面向对象编程（Object Oriented Programming）</p>
<p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2022/10/13/dive-into-functional-programming-01.html">从λ演算深入了解函数式编程</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903936378273799?searchId=2024011715430298E411B538C3892FDFCD#heading-30">js的函数式编程参考</a></p>
<p><a target="_blank" rel="noopener" href="https://mostly-adequate.gitbook.io/mostly-adequate-guide">参考书籍</a></p>
<p>[[C++11与14#C++中的函数式编程|参考C++中的函数式编程]]</p>
<h2 id="实现前提"><a href="#实现前提" class="headerlink" title="实现前提"></a>实现前提</h2><p><strong>函数是“一等公民” (First-Class Functions)</strong></p>
<p>这是函数式编程得以实现的<strong>前提</strong>，因为我们基本的操作都是在操作函数。</p>
<p>这个特性意味着函数与其他数据类型一样，处于平等地位</p>
<ul>
<li>可以赋值给其他变量</li>
<li>可以作为参数，传入另一个函数</li>
<li>可以作为别的函数的返回值</li>
</ul>
<h2 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h2><p><strong>纯函数是函数式编程的基石</strong><br>$$<br>纯函数是指在给定相同输入的情况下，将始终返回相同输出且没有任何可观察的副作用的函数。<br>$$</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202411081150204.webp" alt="img"></p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li>输出完全取决于输入 </li>
<li>没有副作用</li>
</ul>
<blockquote>
<p><strong>副作用</strong>:</p>
<p>在我们函数中最主要的功能当然是根据输入<strong>返回结果</strong>，而在函数中我们最常见的副作用就是<strong>随意操纵外部变量</strong></p>
<ul>
<li><p>使全局状态变化</p>
</li>
<li><p>改变其输入参数</p>
<p>如果输入参数是个引用类型,会导致副作用</p>
</li>
<li><p>执行任何IO操作</p>
</li>
</ul>
<p><strong>注意</strong> 纯函数并非完全不能读写外部的数据,如果外部数据可控,那么也可以读写</p>
<p><a href="#%E6%95%B0%E6%8D%AE%E4%B8%8D%E5%8F%AF%E5%8F%98">相关理解参考数据不可变章节</a></p>
</blockquote>
<p>作为对比,不纯函数有如下特征:</p>
<ul>
<li>输入参数以外的因素会影响输出</li>
<li>可能导致副作用</li>
</ul>
<h3 id="纯函数的优点"><a href="#纯函数的优点" class="headerlink" title="纯函数的优点"></a>纯函数的优点</h3><p>其优点也正是为什么引入纯函数的原因</p>
<ul>
<li><p><strong>并行化</strong></p>
<p>纯函数可以并行化，即它们可以同时执行，充分利用多个 CPU 核心或分布式计算环境。这是因为纯函数没有副作用，使得它们可以安全地并发执行，而不影响总体结果。</p>
</li>
<li><p><strong>惰性求值</strong></p>
<p>所谓惰性执行指的是函数只在需要的时候执行，即不产生无意义的中间变量。函数式编程跟命令式编程最大的区别就在于几乎没有中间变量，它从头到尾都在写函数，只有在真正需要时才会被计算</p>
</li>
<li><p><strong>记忆化</strong></p>
<p>纯函数可以被记忆化，即函数的输出被缓存并在同样的输入再次出现时被重复使用。这项技术消除了一次性计算的需要，减少执行时间和提高了总体性能。</p>
<p>记忆化特别适合于处理昂贵的计算或 I&#x2F;O 操作。通过存储纯函数的结果，可以避免冗余的计算并专心于更重要的任务。</p>
</li>
<li><p><strong>易于测试</strong></p>
<p>纯函数易于测试，因为它们的输出是确定性的，即它们总是返回相同的结果，给定相同的输入。这使得编写单元测试变得简单，因为输出是可预测的，不依赖于外部状态。</p>
</li>
</ul>
<h3 id="无状态和数据不可变"><a href="#无状态和数据不可变" class="headerlink" title="无状态和数据不可变"></a>无状态和数据不可变</h3><h4 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h4><p><strong>无状态：</strong> 主要是强调对于一个函数，不管你何时运行，它都应该像第一次运行一样，给定相同的输入，给出相同的输出，完全不依赖外部状态的变化。</p>
<h4 id="数据不可变"><a href="#数据不可变" class="headerlink" title="数据不可变"></a>数据不可变</h4><p>比如说,外界变量是个const变量的话,那么该函数依旧是个纯函数</p>
<p>如果在递归中要共享一个外部变量,可是使用这种方式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">cache</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(cache)</span><br><span class="line">    cache=&#123;&#125;;</span><br><span class="line">  <span class="comment">//其他代码,递归调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该JS代码实现了一种机制，即如果cache不存在，则在函数体内初始化空间</p>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>高阶函数(High-Order Function)</p>
<p>在函数式编程中，高阶函数是指可以满足以下任一条件的函数：</p>
<ol>
<li><strong>接收一个或多个函数作为参数</strong>：在这种情况下，高阶函数可以利用其他函数来执行某些操作。这使得函数的行为可以变得动态和可配置。</li>
<li><strong>返回一个函数作为结果</strong>：高阶函数可以生成新的函数，有时候也称为工厂函数。这允许创建可复用和灵活的代码结构。</li>
</ol>
<p>高阶函数是函数式编程的核心概念之一</p>
<ul>
<li>高阶函数可以帮助提高代码的可重用性和模块化，因为它们允许程序员将行为抽象出来并动态地组合不同的功能。这种灵活性使得程序更容易维护和扩展。</li>
<li>通过高阶函数，我们可以实现诸如事件处理、回调机制、装饰器、策略模式等设计模式，从而使代码更加简洁和易于理解</li>
</ul>
<h3 id="常用高阶函数"><a href="#常用高阶函数" class="headerlink" title="常用高阶函数"></a>常用高阶函数</h3><p><code>map</code>，<code>filter</code>，<code>reduce</code>等常见的高阶函数</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>Python</th>
<th>C#</th>
<th>C++ (STL)</th>
<th>JavaScript</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Map</td>
<td><code>map()</code></td>
<td><code>Select()</code></td>
<td><code>std::transform()</code></td>
<td><code>Array.map()</code></td>
<td>将函数应用于集合中的每个元素，生成一个新集合</td>
</tr>
<tr>
<td>Filter</td>
<td><code>filter()</code></td>
<td><code>Where()</code></td>
<td><code>std::copy_if()</code></td>
<td><code>Array.filter()</code></td>
<td>过滤集合中的元素，只保留满足条件的元素</td>
</tr>
<tr>
<td>Reduce</td>
<td><code>reduce()</code> from <code>functools</code></td>
<td><code>Aggregate()</code></td>
<td><code>std::reduce()</code></td>
<td><code>Array.reduce()</code></td>
<td>使用累积函数将集合归约为单个值</td>
</tr>
<tr>
<td>For Each</td>
<td><code>for</code> loop or list comprehension</td>
<td><code>ForEach()</code></td>
<td><code>std::for_each()</code></td>
<td><code>Array.forEach()</code></td>
<td>对集合中的每个元素执行指定操作</td>
</tr>
<tr>
<td>Any</td>
<td><code>any()</code></td>
<td><code>Any()</code></td>
<td><code>std::any_of()</code></td>
<td><code>Array.some()</code></td>
<td>检查集合中是否存在至少一个满足条件的元素</td>
</tr>
<tr>
<td>All</td>
<td><code>all()</code></td>
<td><code>All()</code></td>
<td><code>std::all_of()</code></td>
<td><code>Array.every()</code></td>
<td>检查集合中是否所有元素都满足条件</td>
</tr>
<tr>
<td>Find</td>
<td><code>next()</code> with generator expression</td>
<td><code>FirstOrDefault()</code></td>
<td><code>std::find_if()</code></td>
<td><code>Array.find()</code></td>
<td>返回集合中第一个满足条件的元素</td>
</tr>
</tbody></table>
<h3 id="组合函数和管道函数"><a href="#组合函数和管道函数" class="headerlink" title="组合函数和管道函数"></a>组合函数和管道函数</h3><p>常规的链式调用也可以达到函数组合的效果,但是链式调用有个很苛刻的条件,那就是返回值必须为this,也就是说链式调用实际上是一种面向对象的思想</p>
<ul>
<li><p>管道函数(pipe)</p>
<p>正向数据流方向</p>
<p>更符合人类的阅读习惯</p>
</li>
<li><p>组合函数(compose)</p>
<p>反向数据流方向</p>
<p>更符合函数式编程理论中的组合原则,这是因为数学函数组合通常以这种从右到左的方式定义</p>
</li>
</ul>
<p>js中使用reduce实现组合:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">compose</span> = (<span class="params">...fns</span>) =&gt; <span class="function">(<span class="params">x</span>) =&gt;</span></span><br><span class="line">  fns.<span class="title function_">reduceRight</span>(<span class="function">(<span class="params">acc, fn</span>) =&gt;</span> <span class="title function_">fn</span>(acc), x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用组合函数</span></span><br><span class="line"><span class="keyword">const</span> combinedFunction = <span class="title function_">compose</span>(subtract, multiply, add);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">combinedFunction</span>(<span class="number">5</span>)); <span class="comment">// ((5 + 1) * 2) - 3 = 9</span></span><br></pre></td></tr></table></figure>

<h2 id="偏函数与柯里化"><a href="#偏函数与柯里化" class="headerlink" title="偏函数与柯里化"></a>偏函数与柯里化</h2><p>partial function</p>
<p>通过把已知函数的一个或多个参数设定为特定值的方法创建新函数的概念称为偏函数应用</p>
<p>偏的意思是，在计算函数结果时，只需传递部分参数，而不需要传递所有参数</p>
<h3 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h3><p>柯里化是偏函数中的一个特例</p>
<p>柯里化每次只固定一个参数</p>
<p>柯里化的必要性: 为了使用高阶函数,统一参数的个数等情况,因此柯里化是必须的</p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>下面展示偏函数和柯里化的案例</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">curry</span> = (<span class="params">fun, arg</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!arg) &#123;</span><br><span class="line">        arg = [];</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//可以逐个接收参数并在参数个数达到原函数所需的数量时调用原函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">input</span>) =&gt;</span> &#123;</span><br><span class="line">        arg.<span class="title function_">push</span>(input);</span><br><span class="line">        <span class="keyword">if</span> (arg.<span class="property">length</span> &gt;= fun.<span class="property">length</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">fun</span>(...arg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">curry</span>(fun, arg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//柯里化</span></span><br><span class="line"><span class="keyword">const</span> curriedAdd = <span class="title function_">curry</span>(add);</span><br><span class="line"><span class="keyword">var</span> result = <span class="title function_">curriedAdd</span>(<span class="number">1</span>)(<span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);<span class="comment">//3</span></span><br><span class="line"><span class="comment">//偏函数</span></span><br><span class="line"><span class="keyword">const</span> partialAdd = <span class="title function_">curry</span>(add, [<span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">var</span> result2 = <span class="title function_">partialAdd</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result2);<span class="comment">//5</span></span><br></pre></td></tr></table></figure>

<p>偏函数和柯里化各自的适用场景</p>
<ul>
<li>当有一个要绑定其参数的特定函数时, 偏函数比较有用</li>
<li>当函数可以有任意多个参数时, 柯里化很实用</li>
</ul>
<hr>
<p>下面内容还没很明白</p>
<h2 id="单子-例子-函子"><a href="#单子-例子-函子" class="headerlink" title="单子&#x2F;例子&#x2F;函子"></a>单子&#x2F;例子&#x2F;函子</h2><p>单子(Monad)</p>
<p>例子(Maybe Monad)</p>
<h3 id="Monad"><a href="#Monad" class="headerlink" title="Monad"></a>Monad</h3><ul>
<li><strong>简单理解</strong>：Monad 是一台可以一步一步进行工作的机器。它会在你完成一步工作之后，根据结果自动决定下一步去做什么。</li>
<li><strong>例子</strong>：假设你在盒子里找东西，如果找到继续处理下一个步骤，如果没找到，就停止。这就是 Monad 的工作过程，它帮你顺序处理一系列操作，可以不停地“打包打开盒子”，非常适合处理可能失败或者有风险的步骤。</li>
</ul>
<h2 id="Functor和Applicative"><a href="#Functor和Applicative" class="headerlink" title="Functor和Applicative"></a>Functor和Applicative</h2><h3 id="Functor"><a href="#Functor" class="headerlink" title="Functor"></a>Functor</h3><ul>
<li><strong>简单理解</strong>：Functor 就像一个有弹性的手套，你可以把手（函数）放进去操作其中的东西，而不直接接触它。想象一下数据是放在盒子中的，Functor 允许你在不打开这个盒子的情况下对数据进行修改。</li>
<li><strong>例子</strong>：想象你有一个 “盒子”（比如一个列表或是一个选项 <code>Maybe</code>），然后你有一个功能去增大里面的所有东西。使用 Functor，你可以不用打开盒子，而是将这个“增大功能”传给盒子，它自己去处理。</li>
</ul>
<h3 id="Applicative"><a href="#Applicative" class="headerlink" title="Applicative"></a>Applicative</h3><ul>
<li><strong>简单理解</strong>：Applicative 就像多条生产线上的机器抓手，可以同时加工多个零件。它不仅能对盒子中的每个元素作同样的操作，还能把多个盒子里的东西配对起来进行操作。</li>
<li><strong>例子</strong>：继续上面的比喻，如果你有两个盒子，一个装着数字，另一个装着 <code>+1</code> 的功能，你可以用 Applicative 把数字盒子和功能盒子结合起来，得到结果盒子。</li>
</ul>
<h2 id="惰性求值"><a href="#惰性求值" class="headerlink" title="惰性求值"></a>惰性求值</h2><h1 id="架构相关库盘点"><a href="#架构相关库盘点" class="headerlink" title="架构相关库盘点"></a>架构相关库盘点</h1><h2 id="消息队列框架"><a href="#消息队列框架" class="headerlink" title="消息队列框架"></a>消息队列框架</h2><p>RabbitMQ</p>
<p>Kafka</p>
<h1 id="依赖注入容器"><a href="#依赖注入容器" class="headerlink" title="依赖注入容器"></a>依赖注入容器</h1><p><strong>依赖注入（Dependency Injection，简称DI）容器</strong>是一种用于管理对象之间依赖关系的设计模式和工具</p>
<p>它的基本原理是在程序运行时，通过容器自动为对象注入所需要的依赖，而不需要由对象自己创建或管理这些依赖。</p>
<p>在更简单的术语中，<strong>依赖注入容器帮助你将对象的创建与对象的使用分开</strong>，让你<strong>不需要手动处理对象间的依赖关系，容器会自动完成这一过程</strong></p>
<h2 id="容器的作用"><a href="#容器的作用" class="headerlink" title="容器的作用"></a>容器的作用</h2><p>依赖注入容器（如 Spring、Guice、Dagger 等）会管理这些依赖关系，并确保类的实例在需要时能够自动获取所依赖的对象。它将这些依赖关系保存在容器内部，并提供一种机制来“注入”这些依赖。</p>
<p><strong>注入的方式</strong></p>
<ul>
<li><strong>构造函数注入</strong>：依赖通过类的构造函数传入。</li>
<li><strong>方法注入</strong>：依赖通过类中的某个方法传入。</li>
<li><strong>字段注入</strong>：依赖通过类的字段（通常是类的成员变量）传入。</li>
</ul>
<p><strong>容器的作用</strong></p>
<ul>
<li><strong>注册组件</strong>：开发者将对象或服务（通常称为“bean”或“服务”）注册到容器中，告诉容器这个类需要哪些依赖。</li>
<li><strong>创建对象</strong>：当需要创建对象时，容器会根据已注册的信息自动为对象注入依赖项。</li>
<li><strong>管理生命周期</strong>：容器不仅负责对象的创建，还可能负责对象的销毁，依赖的管理等。</li>
</ul>
<blockquote>
<p><strong>依赖注入容器的好处</strong></p>
<ol>
<li><strong>解耦</strong>：对象不再直接负责创建它依赖的对象，而是通过容器来管理，减少了类之间的耦合。</li>
<li><strong>便于测试</strong>：可以通过模拟对象来进行单元测试，不需要担心依赖项的具体实现。</li>
<li><strong>灵活性</strong>：可以动态地调整和替换依赖，方便管理和扩展系统。</li>
<li><strong>生命周期管理</strong>：容器可以管理对象的生命周期，确保每个对象在合适的时机被创建和销毁。</li>
</ol>
</blockquote>
<h3 id="实现一个简易容器"><a href="#实现一个简易容器" class="headerlink" title="实现一个简易容器"></a>实现一个简易容器</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自建简易容器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Container</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 将对象设置到依赖注入容器中</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;type&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;obj&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Set</span>(<span class="params">Type type, <span class="built_in">object</span> obj</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// InnerDictionary[type] = obj;</span></span><br><span class="line">        InnerDictionary.TryAdd(type, obj);<span class="comment">//避免重复添加,并且线程安全</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 泛型版本,这样可以在初始化的时候只传一个参数</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name=&quot;T&quot;&gt;</span><span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;obj&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Set</span>&lt;<span class="title">T</span>&gt;(<span class="params">T obj</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Set(<span class="keyword">typeof</span>(T), obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 从依赖注入容器中获取对象</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">Get</span>(<span class="params">Type type</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> InnerDictionary[type];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Get的泛型版本,这样可以在获取时免传参数</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name=&quot;T&quot;&gt;</span><span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">Get</span>&lt;<span class="title">T</span>&gt;()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (T)Get(<span class="keyword">typeof</span>(T));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于存储对象和类型,字典实际上不是安全的,下面改成使用线程安全的字典</span></span><br><span class="line">    <span class="comment">// private Dictionary&lt;Type, object&gt; InnerDictionary &#123; get; &#125; = new();</span></span><br><span class="line">    ConcurrentDictionary&lt;Type, <span class="built_in">object</span>&gt; InnerDictionary &#123; <span class="keyword">get</span>; &#125; = <span class="keyword">new</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">set</span>; <span class="keyword">get</span>; &#125; = <span class="string">&quot;zeroko&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Container _container = <span class="keyword">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Init</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Foo foo0 = <span class="keyword">new</span> Foo();</span><br><span class="line">        Foo foo1 = <span class="keyword">new</span> Foo();</span><br><span class="line">        Foo foo2 = <span class="keyword">new</span> Foo();</span><br><span class="line">        <span class="comment">// _container.Set(typeof(Foo), foo);//引入泛型Set接口后改成如下使用方式</span></span><br><span class="line">        <span class="comment">// _container.Set(foo);</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> n = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">var</span> taskList = <span class="keyword">new</span> List&lt;Task&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> foo = i &lt; n / <span class="number">2</span> ? foo1 : foo2;</span><br><span class="line">            <span class="keyword">var</span> task = Task.Run(() =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                _container.Set(foo);</span><br><span class="line">            &#125;);</span><br><span class="line">            taskList.Add(task);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        Task.WaitAll(taskList.ToArray());</span><br><span class="line">        <span class="keyword">var</span> fx = _container.Get&lt;Foo&gt;();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">object</span>.ReferenceEquals(fx, foo1))<span class="comment">//用于判断两个对象实际上是否是同一个</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;foo1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;foo2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Use</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Foo foo = _container.Get(typeof(Foo)) as Foo;//引入泛型Get接口后改成如下使用方式</span></span><br><span class="line">        <span class="keyword">var</span> foo = _container.Get&lt;Foo&gt;();</span><br><span class="line">        Console.WriteLine(foo.Name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;开始测试&quot;</span>);</span><br><span class="line">        Init();</span><br><span class="line">        Use();</span><br><span class="line">      	<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>依赖注入的关键就是,<strong>我问你要类型,你给我实例</strong></p>
<p>更详细的依赖注入容器可以参考开源的simpleIOC的代码</p>
<h2 id="依赖注入的实现"><a href="#依赖注入的实现" class="headerlink" title="依赖注入的实现"></a>依赖注入的实现</h2><p><a href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E5%AE%B9%E5%99%A8">上面代码</a>只体现了一个容器,但没有实现类似构造函数注入的特性</p>
<p>实现的核心原理在于: 依赖注入容器通过反射分析类的构造函数和参数类型,然后自动匹配容器中注册的依赖对象</p>
<p>依赖注入容器通过 <strong>反射</strong> 和 <strong>递归依赖解析</strong> 来实现。容器会在获取对象时，首先分析该类型的构造函数，查找其依赖的参数类型，并递归地从容器中获取这些依赖项，然后通过构造函数注入这些依赖，从而实现自动注入。这是依赖注入容器的核心特性之一，也是它与手动创建对象的区别之一。</p>
<p>[[CSharp入门#CSharp 反射]]</p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4" title="头像" alt="头像"></a><div class="post-copyright__author_name">ZEROKO14</div><div class="post-copyright__author_desc">zeroko14's blog</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://che77a38.github.io/posts/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://che77a38.github.io/posts/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/')">架构</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://che77a38.github.io/posts/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=架构&amp;url=https://che77a38.github.io/posts/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3/&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://che77a38.github.io" target="_blank">ZEROKO14的个人博客</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E6%9E%B6%E6%9E%84/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>架构<span class="tagsPageCount">1</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/%E8%BD%AF%E8%80%83%E7%9B%B8%E5%85%B3/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">软考</div></div></a></div><div class="next-post pull-right"><a href="/posts/colab/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">colab</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description">欢迎来到ZEROKO14的个人博客</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">ZEROKO14</h1><div class="author-info__desc">zeroko14's blog</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/che77a38" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E5%AE%8F%E8%A7%82%E7%9A%84%E6%9E%B6%E6%9E%84%E7%9B%98%E7%82%B9"><span class="toc-number">1.</span> <span class="toc-text">最宏观的架构盘点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.</span> <span class="toc-text">领域驱动设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%B1%E8%A1%80%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text">失血模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%AB%E8%A1%80%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.2.</span> <span class="toc-text">贫血模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.3.</span> <span class="toc-text">充血模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%80%E8%A1%80%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.4.</span> <span class="toc-text">胀血模型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DDD%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">DDD分层架构模型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A7%A3%E5%86%B390-%E9%97%AE%E9%A2%98%E7%9A%84%E5%BC%82%E6%AD%A5%E6%9E%B6%E6%9E%84"><span class="toc-number">4.</span> <span class="toc-text">解决90%问题的异步架构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%9E%B6%E6%9E%84%E7%9A%84%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B"><span class="toc-number">4.1.</span> <span class="toc-text">异步架构的技术选型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%9E%B6%E6%9E%84"><span class="toc-number">5.</span> <span class="toc-text">事件驱动架构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">6.</span> <span class="toc-text">消息队列</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3"><span class="toc-number">7.</span> <span class="toc-text">三种消息传递模式详解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6"><span class="toc-number">8.</span> <span class="toc-text">重试机制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E6%9E%B6%E6%9E%84"><span class="toc-number">9.</span> <span class="toc-text">接口架构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%9F%E4%B8%80%E6%8E%A5%E5%8F%A3%E6%9E%B6%E6%9E%84"><span class="toc-number">9.1.</span> <span class="toc-text">统一接口架构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F"><span class="toc-number">10.</span> <span class="toc-text">架构模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6"><span class="toc-number">11.</span> <span class="toc-text">软件开发设计哲学</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E8%AE%BE%E8%AE%A1%E5%BB%BA%E8%AE%AE"><span class="toc-number">12.</span> <span class="toc-text">函数内部设计建议</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-number">13.</span> <span class="toc-text">函数式编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%89%8D%E6%8F%90"><span class="toc-number">13.1.</span> <span class="toc-text">实现前提</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%AF%E5%87%BD%E6%95%B0"><span class="toc-number">13.2.</span> <span class="toc-text">纯函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">13.2.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%AF%E5%87%BD%E6%95%B0%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">13.2.2.</span> <span class="toc-text">纯函数的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E7%8A%B6%E6%80%81%E5%92%8C%E6%95%B0%E6%8D%AE%E4%B8%8D%E5%8F%AF%E5%8F%98"><span class="toc-number">13.2.3.</span> <span class="toc-text">无状态和数据不可变</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E7%8A%B6%E6%80%81"><span class="toc-number">13.2.3.1.</span> <span class="toc-text">无状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%B8%8D%E5%8F%AF%E5%8F%98"><span class="toc-number">13.2.3.2.</span> <span class="toc-text">数据不可变</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="toc-number">13.3.</span> <span class="toc-text">高阶函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="toc-number">13.3.1.</span> <span class="toc-text">常用高阶函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E5%87%BD%E6%95%B0%E5%92%8C%E7%AE%A1%E9%81%93%E5%87%BD%E6%95%B0"><span class="toc-number">13.3.2.</span> <span class="toc-text">组合函数和管道函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%81%8F%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9F%AF%E9%87%8C%E5%8C%96"><span class="toc-number">13.4.</span> <span class="toc-text">偏函数与柯里化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%AF%E9%87%8C%E5%8C%96"><span class="toc-number">13.4.1.</span> <span class="toc-text">柯里化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-number">13.4.2.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E5%AD%90-%E4%BE%8B%E5%AD%90-%E5%87%BD%E5%AD%90"><span class="toc-number">13.5.</span> <span class="toc-text">单子&#x2F;例子&#x2F;函子</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Monad"><span class="toc-number">13.5.1.</span> <span class="toc-text">Monad</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Functor%E5%92%8CApplicative"><span class="toc-number">13.6.</span> <span class="toc-text">Functor和Applicative</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Functor"><span class="toc-number">13.6.1.</span> <span class="toc-text">Functor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Applicative"><span class="toc-number">13.6.2.</span> <span class="toc-text">Applicative</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC"><span class="toc-number">13.7.</span> <span class="toc-text">惰性求值</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3%E5%BA%93%E7%9B%98%E7%82%B9"><span class="toc-number">14.</span> <span class="toc-text">架构相关库盘点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%A1%86%E6%9E%B6"><span class="toc-number">14.1.</span> <span class="toc-text">消息队列框架</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%AE%B9%E5%99%A8"><span class="toc-number">15.</span> <span class="toc-text">依赖注入容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">15.1.</span> <span class="toc-text">容器的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E5%AE%B9%E5%99%A8"><span class="toc-number">15.1.1.</span> <span class="toc-text">实现一个简易容器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">15.2.</span> <span class="toc-text">依赖注入的实现</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/%E7%89%A9%E7%90%86/" title="物理">物理</a><time datetime="2025-09-29T01:48:42.561Z" title="发表于 2025-09-29 09:48:42">2025-09-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/%E5%B7%A5%E4%B8%9A%E7%9B%B8%E5%85%B3/" title="工业相关">工业相关</a><time datetime="2025-02-14T03:04:40.761Z" title="发表于 2025-02-14 11:04:40">2025-02-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9B%B8%E5%85%B3/" title="嵌入式相关">嵌入式相关</a><time datetime="2025-02-14T03:04:40.761Z" title="发表于 2025-02-14 11:04:40">2025-02-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/" title="操作系统">操作系统</a><time datetime="2024-12-16T01:38:01.470Z" title="发表于 2024-12-16 09:38:01">2024-12-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/%E8%AE%A1%E7%BB%84/" title="计算机组成原理">计算机组成原理</a><time datetime="2024-12-16T01:38:01.470Z" title="发表于 2024-12-16 09:38:01">2024-12-16</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2025 By <a class="footer-bar-link" href="/" title="ZEROKO14" target="_blank">ZEROKO14</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu"></a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">74</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">57</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">6</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AI/" style="font-size: 0.88rem;">AI<sup>1</sup></a><a href="/tags/C/" style="font-size: 0.88rem;">C#<sup>3</sup></a><a href="/tags/C/" style="font-size: 0.88rem;">C++<sup>5</sup></a><a href="/tags/CSS/" style="font-size: 0.88rem;">CSS<sup>1</sup></a><a href="/tags/CSharp/" style="font-size: 0.88rem;">CSharp<sup>1</sup></a><a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 0.88rem;">C语言<sup>1</sup></a><a href="/tags/FPS/" style="font-size: 0.88rem;">FPS<sup>1</sup></a><a href="/tags/HTML/" style="font-size: 0.88rem;">HTML<sup>1</sup></a><a href="/tags/JavaScript/" style="font-size: 0.88rem;">JavaScript<sup>1</sup></a><a href="/tags/MFC/" style="font-size: 0.88rem;">MFC<sup>1</sup></a><a href="/tags/PE/" style="font-size: 0.88rem;">PE<sup>1</sup></a><a href="/tags/QT/" style="font-size: 0.88rem;">QT<sup>1</sup></a><a href="/tags/WPF/" style="font-size: 0.88rem;">WPF<sup>3</sup></a><a href="/tags/ai/" style="font-size: 0.88rem;">ai<sup>1</sup></a><a href="/tags/cmake/" style="font-size: 0.88rem;">cmake<sup>1</sup></a><a href="/tags/doxygen/" style="font-size: 0.88rem;">doxygen<sup>1</sup></a><a href="/tags/git/" style="font-size: 0.88rem;">git<sup>1</sup></a><a href="/tags/linux/" style="font-size: 0.88rem;">linux<sup>1</sup></a><a href="/tags/nas/" style="font-size: 0.88rem;">nas<sup>1</sup></a><a href="/tags/next/" style="font-size: 0.88rem;">next<sup>1</sup></a><a href="/tags/ppt/" style="font-size: 0.88rem;">ppt<sup>1</sup></a><a href="/tags/python/" style="font-size: 0.88rem;">python<sup>1</sup></a><a href="/tags/slidev/" style="font-size: 0.88rem;">slidev<sup>1</sup></a><a href="/tags/vue/" style="font-size: 0.88rem;">vue<sup>1</sup></a><a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 0.88rem;">代码规范<sup>1</sup></a><a href="/tags/%E5%86%85%E6%A0%B8/" style="font-size: 0.88rem;">内核<sup>2</sup></a><a href="/tags/%E5%86%85%E6%A0%B8%E7%9B%B8%E5%85%B3/" style="font-size: 0.88rem;">内核相关<sup>5</sup></a><a href="/tags/%E5%8A%A0%E8%A7%A3%E5%AF%86/" style="font-size: 0.88rem;">加解密<sup>1</sup></a><a href="/tags/%E5%9F%BA%E7%A1%80/" style="font-size: 0.88rem;">基础<sup>6</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 0.88rem;">多线程<sup>1</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F/" style="font-size: 0.88rem;">并发模式<sup>1</sup></a><a href="/tags/%E5%BC%80%E5%8F%91/" style="font-size: 0.88rem;">开发<sup>4</sup></a><a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 0.88rem;">数学<sup>1</sup></a><a href="/tags/%E6%9D%82%E9%A1%B9/" style="font-size: 0.88rem;">杂项<sup>1</sup></a><a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 0.88rem;">正则表达式<sup>1</sup></a><a href="/tags/%E7%89%A9%E7%90%86/" style="font-size: 0.88rem;">物理<sup>1</sup></a><a href="/tags/%E7%9B%91%E6%8E%A7/" style="font-size: 0.88rem;">监控<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 0.88rem;">网络<sup>3</sup></a><a href="/tags/%E9%80%86%E5%90%91/" style="font-size: 0.88rem;">逆向<sup>5</sup></a><a href="/tags/%E9%AD%94%E6%B3%95/" style="font-size: 0.88rem;">魔法<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.cbd.int/mathjax@3.2.2/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.cbd.int/mermaid@10.2.4/dist/mermaid.min.js').then(runMermaid)
  }

  anzhiyu.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>