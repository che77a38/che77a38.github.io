<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>C++11与14 | ZEROKO14的个人博客</title><meta name="keywords" content="C++"><meta name="author" content="ZEROKO14"><meta name="copyright" content="ZEROKO14"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#18171d"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="C++11与14"><meta name="application-name" content="C++11与14"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#18171d"><meta property="og:type" content="article"><meta property="og:title" content="C++11与14"><meta property="og:url" content="https://che77a38.github.io/posts/C++11%E4%B8%8E14/index.html"><meta property="og:site_name" content="ZEROKO14的个人博客"><meta property="og:description" content="C++11到C++20的新特性解析   c++11特性可以参考 C++标准介绍优秀的c++知识库:cppreference C++标准演化  C++98(1.0)    正式版本 C++03(TR1) C++11(2.0)   正式版本 C++14 C++17 C++20 C++23  编译器对C+"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4"><meta property="article:author" content="ZEROKO14"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4"><meta name="description" content="C++11到C++20的新特性解析   c++11特性可以参考 C++标准介绍优秀的c++知识库:cppreference C++标准演化  C++98(1.0)    正式版本 C++03(TR1) C++11(2.0)   正式版本 C++14 C++17 C++20 C++23  编译器对C+"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://che77a38.github.io/posts/C++11%E4%B8%8E14/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2024/07/27/125766904/ba62475f396df9de3316a08ed9e65d86_5680958632268053399..png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":true,"limitCount":50,"languages":{"author":"作者: ZEROKO14","link":"链接: ","source":"来源: ZEROKO14的个人博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'ZEROKO14的个人博客',
  title: 'C++11与14',
  postAI: '',
  pageFillDescription: 'C++标准介绍, 确认支持C++标准, 各版本新增特性, C++ 11, C++ 14, C++ 17, C++ 20, 新的基础类型, long long类型, 新字符类型, char16_tx2Fchar32_t, u16stringx2Fu32string, wchar_t, char8_t, 函数封装与绑定, function类, mem_fn函数, bind函数, 类型转换, 确定的表达式求值顺序, 字面量优化, 十六进制浮点字面量, 二进制整数字面量, 单引号作为整数分隔符, 原生字符串字面量, 用户自定义字面量, 数据对齐相关, alignof运算符, alignas说明符, 其他关于对齐字节长度的支持, 使用new分配指定对齐长度的对象, 属性说明符和标准属性, 属性说明符, 使用using打开属性的命名空间, 标准属性, noreturn, carries_dependency, deprecated, fallthrough, nodiscard, maybe_unused, likelyx2Funlikely, no_unique_address, 新增预处理器功能和宏, 头文件可用宏, 特性测试宏, 属性测试运算宏, 语言功能特性测试宏, 标准库功能特性测试宏, 参数不为空宏, 协程, 协程的理解, 有栈协程, 无栈协程, C++20协程, 命名空间相关, 内联命名空间, 嵌套命名空间, 嵌套内联命名空间, 拓展的inline说明符, 内联变量, 内联非常量静态成员变量, 函数返回类型后置, 默认实参, 右值引用, 左值引用和右值引用, 值类别, 左值转换为右值, 基本的转换方式, 使用stdmove, 移动语义, move函数, 万能引用, 万能引用的规则, 完美转发, 自定义支持移动的类, 非静态成员默认初始化, 可变参数模板, 函数案例, 类案例, 递归继承, 递归复合, 并存问题, 模版表达式中的空格, nullptr, nullptr_t, 三向比较, 返回类型, 对基础类型的支持, 自动生成比较函数, auto关键字, auto关键字的特性, 推导规则, auto占位符使用, 一致性初始化, initializer_listltTgt, 使用, initializer_list原理, 初始化列表不支持隐式缩窄转换, 指定初始化, 语法要求, 委托构造函数, 委托模板构造函数, 继承构造函数, 基本语法, 相关规则, 强枚举类型, 三个新特性, 基本语法, 枚举类型的列表初始化, 使用using打开强枚举类型, 聚合类型, 聚合类型的初始化, 小括号列表初始化, 基于范围的for循环, begin和end函数不必返回相同类型, 意义, 临时范围表达式初始化语句, 实现一个支持基于范围的for循环的类, 支持初始化语句的if和switch, if, switch, static_assert声明, 使用方法, 单参数static_assert, 互斥锁, x3Ddefaultx2Fx3Ddelete, 非受限联合类型, uncaught_exceptions, noexcept, 用noexcept解决移动构造问题, noexcept和throw的差别, 默认使用noexcept的函数, 使用noexcept的时机, 异常规范作为类型的一部分, overridex2Ffinal, override, final, 声明类, 声明虚函数, 局部数组可用变量初始化大小, decltype, 使用方式, 推导规则, decltype和auto配合使用, 主要作用, 声明返回类型, 用于元编程, 传递lambda表达式的类型, 类型别名与别名模板, 别名模板, Lambda表达式, Lambdas的一些注意点, 无状态Lambda表达式, 捕获[*this]和[x3Dthis], 模板语法的泛型lambda表达式, constexpr lambda, Lambdas案例细节, Lambdas原理, 函数对象（难点）, 谓词, 内建函数对象, 函数对象适配器, 函数对象适配器bind1st和bind2nd, 取反适配器not1和not2, 函数指针适配器 ptr_fun, 成员函数适配器 mem_fun_ref和mem_fun, mem_fun_ref, mem_fun, 智能指针, auto_ptr, auto_ptr的局限性, 复制或者赋值都会改变资源的所有权, 不支持对象数组的内存管理, unique_ptr, auto_ptr与unique_ptr智能指针的内存管理陷阱, shared_ptr, 常用api, 构造函数, 使用智能指针管理对象数组, shared_ptr工作原理, shared_ptr模拟代码, shared_ptr使用陷阱, weak_ptr, 结构化绑定, 绑定原生数组, 绑定到结构体和类对象, 绑定到元组和类元组的对象, 结构化绑定的原理, 绑定的访问权限问题, 常量表达式, 常量表达式函数, 约束条件(C++11标准), 约束条件新标准(C++14标准), 约束条件拓展(C++20), constexpr lambdas表达式, 常量表达式构造函数, 作用于自定义类型, 约束条件, 意义, if constexpr, consteval, constinit, 使用constinit检查常量初始化规则, 线程局部存储, 线程局部存储的内存地址, 线程局部存储对象初始化和销毁, tuple, 线程, stl新容器, C++谷歌代码规范, Boost, filesystem, emplace, C++17三剑客, optional, 创建一个 optional 的方法, 访问 optional 对象中数据的方法, 判断option对象是否有值, 销毁optino对象中的值, C++中的函数式编程, 纯函数, 高阶函数, 常用的高阶函数, 组合函数与管道函数, 组合函数的实现, 管道函数的实现, 偏函数与柯里化, 实现柯里化, 闭包, C++23到的新特性解析特性可以参考标准介绍优秀的知识库标准演化正式版本正式版本编译器对的支持情况两个层面的新特性语言标准库确认支持标准程序内部由下面的宏标识标准查询标准库各版本新增特性关键字关键字字面值关键字相关基于范围的循环表达式标准库函数智能指针右值引用容器拓展了表达式更加泛型支持拓展了类型推导至任意函数只支持返回类型的弃用关键字拓展了至等的函数只能包含一个表达式嵌套内联变量模板参数推导元组类实现两个元素的组合它实现多个类模板表示一个类型安全的联合体引用包装器变长参数模板结构化绑定函数多值返回时用合成非类型模板参数可传入类的静态成员在和中可进行初始化初始化如对象时可用花括号进行对其成员进行赋值简化多层命名空间的写法表达式可捕获的值但及其成员为只读十六进制的单精度浮点数继承与改写构造函数表示继承的构造函数当模板参数为非类型时可用自动推导类型判断有没有包含某文件用于语句块内表示会执行下一个或表示函数的返回值没有被接收在编译时会出现警告即便没使用也不警告用于声明具有特定约束条件的模板类型声明一个数值类型的范围库协程模块新的基础类型类型以及类型先后在加入和加入由于编译器兼容因此之前之后也能使用该类型引入新的字面量后缀以及为类型的最大值编译器对字面量默认以位进行处理上面例子中不写的话值会变成因此需要编译器按照位处理字面量则需要用到此后结果为恢复正常判断最大值最小值最大值最小值针对是这样新字符类型对应位长度对应位长度字符串前缀好好你好世界你好世界还有两个特殊基础类型和和是引入的用于存储和编码的字符串的类型编程常用字符类型因为的大部分都有这个的版本但是该类型不常用的原因是对于跨平台不友好在上和上的字符长度是不确定的对应的字符串是对应引入的新类型之前使用对应的字符串类型为字符串前缀之后的标准做法编译成功编译失败需要编译失败需要字符串前缀在实际开发中可以考虑使用现有的开源库如库它提供了丰富的支持包括对不同编码的字符串操作字符编码字符集转换字符编码的转换参考此处函数封装与绑定标准库中提供了一些函数包装的模板他们可以对函数或调用对象进行包装方便在其他函数中调用类头文件中用于代替函数指针并且远比函数指针强大可以作为所有函数的接口包括函数函数对象成员函数等所有一切函数定义如下使用案例还可以用于封装类的成员函数只需要第一个参数类型为类的引用线性函数类使用封装类的成员函数封装成员变量实现了一种叫做类型擦除的模式即通过单个通用接口来使用各种具体的类型函数如果是指向类成员也可以使用参数是指向类成员的指针返回值是一个可调用的包装器例子给赋值为调用的方法并传入和作为参数调用方法并传入作为参数函数在中函数是一个函数模板用于创建函数对象也称为函数符或函数器函数的主要作用是将一个可调用对象函数函数指针成员函数函数对象等和其参数绑定在一起形成一个新的可调用对象这种绑定的过程可以延迟函数调用允许我们在稍后的时间点调用这个函数对象并传递参数定义下面是函数的一般用法和示例实际上调用在这个示例中函数将函数和参数绑定在一起创建了一个新的函数对象通过调用实际上会调用函数函数的一些特点和用法包括可以绑定任意可调用对象包括自由函数成员函数函数指针等可以绑定部分参数即在创建函数对象时只传递部分参数稍后再传递剩余的参数可以改变参数的顺序通过占位符等指定参数的位置返回的函数对象可以拷贝移动和赋值可以存储和延迟调用函数在标准中引入并位于头文件中它是实现函数绑定和延迟调用的重要工具可以简化代码并提高灵活性也可以使用变量来传入这是值传入调用的时候的值为此代码执行时候的值引用传入调用的时候的值是什么就是什么实现原理简化版的实现实际的函数会更加复杂因为它支持更多的特性如绑定成员函数占位符引用传递等底层实现会涉及到更多的模板元编程技术例如参数包展开递归模板等具体的实现细节可能会因不同的标准库而有所不同但基本思想是相似的如果你对函数的底层实现原理感兴趣可以查阅标准库实现的源代码如或等这些源代码中会展示函数更复杂和完整的实现细节类型转换引入的针对类型的转换函数如下将字符串转换为整数将字符串转换为长整数将字符串转换为长长整数将字符串转换为无符号长整数将字符串转换为无符号长长整数将字符串转换为单精度浮点数将字符串转换为双精度浮点数将字符串转换为长双精度浮点数确定的表达式求值顺序才具体说明此前由编译器确定函数表达式中的参数会在函数体内的语句执行之前被求值都是表达式但是要注意函数的参数之间的顺序依然是不确定的后缀表达式和移位运算符求值总是从左往右赋值表达式求值总是从右往左的等等表达式的内存分配总是会优先于构造函数中参数的求值重载运算符的表达式的求值顺序应由与之相应内置运算符的求值顺序确定字面量优化十六进制浮点字面量和引入二进制整数字面量引入前缀和单引号作为整数分隔符引入目的是让数字看起来比较好辨识单引号整数分隔符对于十进制八进制十六进制二进制整数都是有效的十六进制八进制二进制原生字符串字面量引入这种字符串字面值使用的语法允许在字符串中包含特殊字符而无需转义方便处理包含大量转义字符的字符串这种特性在处理正则表达式文件路径等场景中非常有用如果字符串中包含小括号和引号的组合可能会导致编译器对原生字符串的解析出错为了避免这种情况可以在原始字符串字面值的开头和结尾添加自定义的定界符以确保编译器能够正确解析字符串这样即使字符串中包含小括号和引号的组合编译器也能正确识别字符串的开始和结束语法为自定义定界符自定义定界符以下是一个示例演示如何在原始字符串字面值中使用自定义定界符来避免编译器解析错误输出为上述代码中的是自定义的可以自己想写什么写什么用户自定义字面量引入允许用户自定义字面量只需要定义一个字面量运算符函数基本语法双引号和之间必须有空格但改规则在中被删除了标准表示应该以下划线开始把没有下划线的标识符保留给标准库使用输出字面量函数运算符的参数规则整形或者没有参数直接拿实参作为字面量浮点或者没有参数直接拿实参作为字面量字符串字符数据对齐相关和首先需要先了解一下不可忽视的数据对齐问题语言入门结构体字节对齐结构体字节对齐有关于设置结构体字节对齐长度的方式内存对齐的原因是因为硬件需要首当其冲的就是我们的对数据对齐有迫切的需要提高性能通常来说好的数据对齐长度和访问数据总线的宽度有关系比如访问位的数据总线就会期待数据是按照位对齐的另外对于数据对齐引发错误的情况通常发生在架构上架构对数据对齐更严格除了外还有其他硬件也需求硬件对齐比如通过访问硬盘就会要求数据必须是对齐的运算符用于获取类型的对齐长度不能用于对象先看看之前有一些通过宏来获取类型的对齐长度之后也能用各大厂商编译器提供了获取类型或对象对齐长度的函数如因此标准引入统一了用法使用案例注意只能处理类型不能处理对象即使使用获得类型也不准确因为使用获取的类型是默认对齐长度的类型因此这种情况还是需要使用编译器厂商提供的方法说明符用于设置类型或者常量表达式的对齐长度先看看之前各大编译器提供的设置对齐长度的方法之后也能用例如输出均为规则如果将用于结构体该结构体整体就会以该数值来对齐结构体如果修改结构体成员的对齐长度那么结构体整体的对齐长度也会发生变化因为结构体整体的对齐长度总是大于或等于他最大的成员的对齐长度使用案例结构体大小结构体对齐长度结构体大小结构体对齐长度结构体大小结构体对齐长度结构体大小结构体对齐长度编译错误对齐不能设置为小于默认对齐标准库也提供了一些方法其他关于对齐字节长度的支持引入获取类型的对齐字节长度分配一块指定对齐字节长度和大小的内存获取参数类型中对齐字节长度最严格的对齐字节数最大作为分配内存的对齐字节长度使用分配指定对齐长度的对象支持分配指定对齐长度的对象运算符接受一个类型的参数来获得分配对象需要的对齐字节长度运算符的声明发生了变化是由编译器自动填充的程序员不需要关心属性说明符和标准属性属性说明符之前和提供的属性语法引入了属性说明符语法进一步扩展了这一特性基本语法需要多个属性时指定命名空间简易例子基本规则属性可以出现在整个声明之前或者直接更在被声明的对象之后组合起来的规则为属性说明符总是声明位于其之前的对象而在整个声明之前的属性则会声明语句中所有声明的对象效果为若程序不符合属性要求编译器将会发出警告使用打开属性的命名空间引入有命名空间的情况或使用标准属性声明函数不会返回允许跨函数传递内存依赖项标记实体为弃用在语句中提示编译器直落行为是故意的声明函数的返回值不应该被舍弃声明实体可能不会被使用表示某条路径更加有可能或没可能用于优化通常用于语句指示数据成员不需要唯一地址等等声明函数不会返回允许跨函数传递内存依赖项它通常用于弱内存顺序架构平台上多线程程序优化避免编译器生成不必要的内存栅栏指令微处理器架构属于弱内存顺序架构平台和的和处理器系列不属于带有此属性实体被声明为弃用如果使用弃用的实体编译会给出系统警告中引入在语句的上下文中提示编译器直落行为是故意的声明函数的返回值不应该被舍弃可以声明在函数或类或枚举类型上但是声明到类或枚举类型上时只有被当成函数的返回值时才会生效使用该函数时如果不处理返回值将被警告引入声明实体可能不会被使用引入的通常用于语句中表示某条路径更加有可能或没可能让编译器可以进行优化声明在标签或语句上属性允许编译器对该属性所在的执行路径相对于其他执行路径更可能的进行优化允许编译器对该属性所在的执行路径相对于其他执行路径更不可能的进行优化引入指示编译器该数据成员不需要唯一地址通常用于数据成员类型只有成员函数没有成员变量的类型不加结果为加结果为新增预处理器功能和宏头文件可用宏头文件判断某个头文件是否能被包含进来注意他不关心头文件是否已经被导入特性测试宏对于代码库的作者因为有了特性测试宏可以根据客户端开发环境适配不同的代码功能让自己的代码库能更高效的使用在更多的环境上属性测试运算宏属性指示编译器是否支持某种属性该属性可以是标准属性也可以是编译器特有的属性前者展开为属性添加进标准的年份与月份后者展开为非零值语言功能特性测试宏如果支持将展开为引入特性的年月标准库功能特性测试宏参数不为空宏引入可变参数不为空时才展开可变参数宏的问题打印案例展开后有问题多了一个逗号可变参数不为空时才展开协程协程的理解协程是一种可以被挂起和恢复的函数它提供了一种创建异步代码的方法如今协程已经成为大多数语言的标配尽管名称可能不同但它们都可以被划分为两大类有栈协程可以任意嵌套函数中被挂起每一个协程都会有自己的调用栈一般的协程使用栈内存来存储数据无栈协程如以及中的协程不可以任意嵌套函数中被挂起无栈协程不具备数据栈此处有栈和无栈的含义不是指协程在运行时是否需要栈对于大多数语言来说一个函数调用另一个函数总是存在调用栈的而是指协程是否可以在其任意嵌套函数中被挂起此处的嵌套函数读者可以理解为子函数匿名函数等显然有栈协程是可以的而无栈协程则不可以这也决定了有栈协程被挂起时的自由度要比无栈协程高协程的目的一份不需要将生产者或是消费者重写为状态机就可以移植的代码一个隐式的状态机有栈协程有栈协程是可以在其任意嵌套函数中被挂起的实现一个协程的关键点在于如何保存恢复和切换上下文已知函数运行在调用栈上如果将一个函数作为协程我们很自然地联想到保存上下文即是保存从这个函数及其嵌套函数的连续的栈帧存储的值以及此时寄存器存储的值恢复上下文即是将这些值分别重新写入对应的栈帧和寄存器而切换上下文无非是保存当前正在运行的函数的上下文恢复下一个将要运行的函数的上下文有栈协程便是这种朴素思想下的产物切换上下文无非是保存当前正在运行的函数的上下文恢复下一个将要运行的函数的上下文于是我们可以基于上述两段汇编构造一个函数分别传入构造好的上下文即可实现切换为了方便使用我们可以将封装成函数在这个函数里简单实现了不同函数的调度逻辑于是一个简单的例子便完成了相关代码可以参考此处有栈协程则是通过切换整个栈帧来实现上下文切换每个协程都有自己独立的栈空间允许它们在任何地方挂起和恢复执行这些协程可以自由地执行递归或其他复杂的控制流进程与线程模拟线程切换曾经写过一段这样原理的代码用于通过单线程模拟多线程实际上就是有栈协程相关部分可以参考此处无栈协程相比于有栈协程直接切换栈帧的思路无栈协程在不改变函数调用栈的情况下采用类似生成器的思路实现了上下文切换无栈协程如基于生成器的实现则不使用独立的栈空间而是利用生成器的特性来实现上下文切换无栈协程的基本思路是将函数的状态如局部变量和执行位置保存在生成器的内部状态中而不是在栈帧中这样切换协程时只需保存和恢复生成器的状态而不需要处理复杂的栈帧结构无栈协程的一种实现虽然有多线程以及可读性等诸多问题但确实是无栈协程有栈协程被挂起时的自由度要比无栈协程高有栈协程在兼容现有的同步代码时异常方便而无栈协程的兼容性基本为零总不可能给所有同步代码都加上吧无栈协程原理无栈协程其实现原理是将执行的方法编译为一个状态机实现的时候不需要在临时栈和系统栈直接拷贝现场因此无栈协程的效率和占用的资源更少当然有栈协程的代码会更加的简单易读协程协程就是一个可以挂起执行稍后再恢复执行的函数只要一个函数包含或关键字则它就是协程协程是函数的泛化协程允许函数被暂停并在之后恢复执行引入的协程属于无栈协程它们通过编译器的支持使用状态机的方式在不改变函数调用栈的情况下进行协程切换每个协程通过等关键字实现挂起和恢复不会为每个协程分配独立的栈协程技术规范带给了我们什么个新的关键字和几个新的类型在命名空间中一个通用的机制库的开发者可以用它和协程交互并定制他们的行为一个语言设施它使得编写异步代码更简单协程提供的设施可以看作是一个用于协程的低级汇编语言这些设施很难以安全的方式直接使用它更倾向于给库的开发者让他们可以编写出应用程序开发者可以安全使用的高级抽象协程没有定义协程的语义它没有定义如何产生返回给调用者的值它没有定义传递给语句的返回值要做什么以及如何处理传递出协程的异常它没有定义协程应该在哪个线程上恢复协程定义了两种类型的接口接口和接口接口规定了一些和协程自身行为相关的方法库的开发者可以定制当协程被调用时的行为当协程返回时的行为正常返回或未处理的异常以及定制协程内任何和表达式的行为接口规定了一些控制表达式语义的方法当一个值被时这部分代码将被翻译为一系列对象的方法这使得可以规定是否要暂停当前协程在暂停协程后是否要执行一些逻辑在协程恢复执行后是否要产生表达式的结果接口主要用于定制协程本身的行为例如协程的调用返回以及内部的和表达式的行为接口主要用于控制表达式的语义包括决定是否暂停协程在暂停后和恢复后的相关逻辑处理它们共同作用于协程以实现协程的各种功能和行为定制提供暂停协程的能力允许协程被恢复执行协程函数返回值的类型必须是一个自定义类型并且这个自定义类型需要按照一定的格式来定义可参考链接有更充分的讲解翻译版原文版协程开始时在协程的状态对象分配内存后调用的构造函数为协程的状态对象分配内存失败时构造成功后开始执行在以上函数后执行协程结束前执行出现未经处理的异常时执行时执行跟二选一时执行也暴露出多个接口用于控制协程的行为获取协程的状态与不同的是里的接口需要我们填写实现里的接口是给编译器调用的的接口不需要我们填写实现我们可以直接调用接口作用从对象创建一个检查协程是否运行完毕检查当前句柄是否是一个恢复协程的执行恢复协程的执行同上销毁协程获取协程的对象返回的指针从指针导入一个基于的编译选项进行讲解拓展了标准库提供了一些辅助库下面代码使用了微软协程库的特性命名空间相关引入内联命名空间与嵌套命名空间内联命名空间把子命名空间的元素导入到父命名空间中注意这个关键字不能用到第一层的命名空间中调用的是中的主要作用方便库的开发者管理代码升级代码后无缝地提供给使用者当我们想去修改升级这个函数的时候版本换成版本最好的方式就是使用内联命名空间本来是在版本的的只需要将关键字转移到版本的上则达成修改其他代码无需修改并且保留了原始版本代码嵌套命名空间主要是用来减少命名空间带来的代码冗余这种方式是嵌套的嵌套的命名空间中定义了一个函数嵌套内联命名空间才支持等同于拓展的说明符内联变量引入了内联变量在中内联变量是指使用关键字声明的变量使用关键字声明的变量会被视为内联变量编译器会尝试将其直接嵌入到调用它的地方而不是分配内存空间给该变量这样可以减少函数调用的开销提高程序的执行效率需要注意的是内联变量的定义必须在所有使用该变量的地方可见否则会导致链接错误基础内联函数内联变量知识点跳转除了内联命名空间与嵌套命名空间中对的新拓展外还拓展了用于定义非常量静态成员变量的用法内联非常量静态成员变量非常量静态成员变量的问题声明和定义必须分开即定义必须在类外定义在类外常量静态数据成员可以一次性完成声明和定义从开始标准引入了内联定义静态数据成员的方式解决了中定义静态成员变量繁琐的问题基本语法即使将类的定义作为头文件包含在多个源文件中也不会有任何问题让编译器可以聪明的选择首次出现的变量进行定义和初始化这种特性符合说明符提案文档中的一句话说明符可以应用于变量和函数声明为内联的变量和函数具有相同的语义他们一方面可以在多个翻译单元中定义另一方面又必须在每个使用他的翻译单元中定义并且行为就像同一个变量函数返回类型后置基本语法一般用于推导函数模板返回类型默认实参参考默认实参可以不写参数名默认实参在声明中可传递可能有点绕看下面解释形参包前可以直接写默认实参版本引入了函数的默认实参可以不写参数名的特性在函数声明中所有在拥有默认实参的形参之后的形参必须拥有在这个或同一作用域中先前的声明中所提供的默认实参你可能觉得很绕其实说白了就是说你可以给任何形参默认实参但是你需要在当前作用域提前给你已经声明了默认实参的形参后面的形参默认实参比如除非该形参是从某个形参包展开得到的或是函数形参包如没错还有很多点略详情点击参考右值引用提出的一个非常重要的概念它的出现不仅完善了的语法改善了在数据转移时的执行效率减少了非必要复制同时还增强了的模板能力中对影响最深远的特性就是右值引用首先区分左值和右值判断对象能否取地址可以取地址的为左值不可以取地址的为右值所谓的左值一般是指一个指向特定内存具有名称的值具名对象它有一个相对稳定的内存地址并且有一段较长的生命周期而右值则是不指向稳定内存的地址匿名值不具名对象它的生命周期很短通常都是暂时性的通俗理解左值就是可以找到的东西可以重复使用和修改右值就是用完就丢的东西在表达式中一旦计算出来就没有持久性通常是表达式的结果在中引入左值和右值的概念主要是为了优化和区分对象的生命周期比如如果编译器知道某个对象是右值它可以安全地将其移动或优化而不用保留它的完整生命周期简单区分此处的为右值竟然通过编译但没什么意义输出输出竟然可以对临时对象赋值但没什么意义临时对象也是右值原本对右值不能取编译错误可以理解为想取返回的东西的地址编译错误当右值出现于赋值运算符右侧时我们认为对其资源进行偷取搬移而非拷贝是合理的因此必须有语法让我们在调用端告诉编译器这是个右值必须有语法让我们在被调用端写出一个专门处理右值的所谓移动构造函数于是乎引入了右值引用左值引用和右值引用常量左值引用编译错误编译成功右值引用语法右值引用引入了移动语义值类别分为种泛左值和右值泛左值通过计算评估能够确定对象位域或函数的标识的表达式简单理解就是具名对象分为种左值纯右值和将亡值纯右值通过计算评估能够用于初始化对象和位域或者能够计算运算符操作数的值的表达式简单理解为是为了初始化其他对象的将亡值资源可以被重用的对象和位域通常是因为它们接近生命周期的末尾另外也有可能是经过右值引用的转换产生的左值和将亡值统称为泛左值纯右值和将亡值统称为右值左值转换为右值基本的转换方式编译失败编译成功使用函数详解与使用函数效果一致是一个模板元函数是标准引入的一个类型转换工具位于头文件中用于移除参数类型的引用修饰符例如如果的类型是将返回移动语义当一个右值复制拷贝构造的时候若被拷贝对象是一个右值或者是一个临时对象的时候原本的做法非常不聪明更高效的做法是将马上要被销毁的临时对象的资源内容移动到目标对象中说请尽管移动我直接把的内容偷过来也会被移动返回超高效使用示例现在原对象变成空壳子不能再使用它的值右值引用的语法是右值引用允许我们获取对临时对象的引用从而在不拷贝的情况下对它们进行操作函数是一个函数其主要目的是将任何类型的变量无条件地转化为右值用于实现移动语义减少不必要的拷贝开销和内存开销例如将一个左值传入时可以使用来实现真正的转移避免额外的拷贝操作用可以理解为的资源将被偷取总之要注意看到参数可以用把它移走被移动后的对象不要再使用它的值如果对象后面还要用就不要移动它函数的原理学习的时候可以利用是一个编译选项用于告诉编译器不要优化构造函数通常情况下编译器会尝试对构造函数进行优化例如通过返回值优化来避免不必要的拷贝操作使用该选项可以禁用这种优化强制执行构造函数的拷贝操作这在某些情况下可能有用例如在调试时需要确保每次构造函数都被调用通过观察发现移动语义可以将函数中的局部变量返回出来观察汇编代码会发现实际上根本没有进入到函数内而是在进入函数前就定义了局部变量意思就是本应在最里层的局部变量定义到了外面这样当然就可以返回了移动构造函数以及移动赋值运算符函数的类中因此新增的默认函数移动构造是一门既省内存又高效的绝学但使用不当可能会导致走火入魔使用场景当你的对象持有大量资源内存文件句柄等当你知道源对象马上就要销毁时在容器操作中需要频繁移动对象时移动构造函数注意移动构造函数必须标记为这样容器才敢放心大胆地使用它移动赋值运算符函数移动构造函数移动赋值运算符函数可以参考这个链接查看汇编第一个图是浅拷贝流程中间的图是原来的深拷贝流程右图是移动流程即偷一个生动形象的动词注意打断了原本对象和空间的联系加入了移动语义的类中编译器隐式声明的特殊成员图一览规则总结默认构造析构赋值拷贝赋值移动拷贝构造拷贝移动默认都会自动由编译器生成用户定义了任何构造函数则默认构造函数不会自动生成用户定义了拷贝构造和拷贝赋值函数或析构函数任一则移动语义两个函数不会自动生成用户定义了移动语义两个函数任一则复制语义两个函数不会自动生成非常重要的一点只要是使用了构造函数即使是使用的移动构造函数也会在该对象生命周期结束的时候自动调用析构函数根据调用的构造函数的次数来决定一个使用移动构造函数的例子注意调用了两次析构函数一个案例移动构造函数移动赋值操作符使用调用移动构造函数的现在为调用了两次析构函数万能引用万能引用是针对模板而来的最大的目的是为了让你的函数中传入的参数可以左值也可以是右值常量左值引用既可以引用左值又可以引用右值是一个几乎万能的引用但可惜由于其常量性导致它的使用范围收到一些限制因此此处介绍的万能引用是真正意义上的万能的引用右值引用模板万能引用具体类型的符号表示右值引用模板的符号表示万能引用所谓的万能引用是因为发生了类型推导在和的初始化过程中都会发生类型的推导如果已经有一个确定的类型比如则是右值引用在这个推导过程中初始化的源对象如果是一个左值则目标对象会推导出左值引用反之如果源对象是一个右值则会推导出右值引用不过无论如何都会是一个引用类型万能引用能如此灵活地引用对象实际上是因为在中添加了一套引用叠加推导的规则引用折叠在这套规则中规定了在不同的引用类型互相作用的情况下应该如何推导出最终类型为右值引用为万能引用为右值引用为万能引用万能引用既可以是一个左值引用也可以是一个右值引用这个能力是通过模板形参的推导完成的万能引用最重要的一个应用是完美转发万能引用的规则万能引用使用了一套叫做引用折叠的规则即不同引用类型叠加后的推导结果类模板型实际类型最终类型类模板型和实际类型均有引用符则按照数量少的引用符确定最终类型类模板型和实际类型有一个有引用符则按照有引用符的数量来确定最终类型或者另一个记忆方式按照优先级来罗列有左值引用则最终类型为左值引用优先级最高有右值引用则最终类型为右值引用值得一提的是万能引用的形式必须是或者而不能是必须在初始化的时候被直接推导出来若在推导中出现中间过程则不是一个万能引用完美转发为什么需要完美转发在中有时我们编写的模板函数只是为了中转调用另一个函数但是模板函数中的参数通常无法保持原始的左值或右值状态这会导致性能问题或意外行为因此我们需要一种机制来让模板函数能正确地转发参数为了解决在函数模板中传递参数时保持参数的值类别或不变的问题下面三种方式都不是完美转发都有各自的问题执行过程中会执行构造函数因为是按值转发即在转发过程中会额外发生一次临时对象的复制解决了上面效率的问题但是不能转发右值能转发右值了但是即使传左值也无法修改了完美转发原来是左值转发后也是左值原来是右值转发后也是右值传入的是左值的话在此处会和右值折叠还是左值传入的是右值的话在此处会和右值折叠还是右值这里必须是因为只有可以推导出右值显示使用类型转换进行转发不是一个便携的方法在的标准库中提供了一个函数模板在函数内部也是使用进行类型转化使用转发语义会表达得更加清晰用于在模板函数中完美转发参数它有条件地将变量转化为右值只有当输入的变量是右值时才会将其转化为右值引用如果输入的变量是左值那么将输入的变量转化成左值通常用于保留原始变量的左值和右值属性此处详解完美转发的必要性参数直接传递调用传入左值传入右值问题无论传入的是左值还是右值都只调用了这是因为在模板函数中参数被默认视为左值即使我们传递的是右值也失去了右值特性导致效率低下没有调用的移动版本下面使用完美转发使用完美转发传入左值传入右值进一步泛华将也泛化通用函数模板可以处理任意类型的通用转发函数模板完美转发保留左值右值属性传入左值传入右值传入左值传入右值自定义支持移动的类完整写法参考字符数构造函数构造指针地址为使用引入的复制字符串内容拷贝构造函数构造指针地址为先检查是否自我赋值如果是则直接返回释放原有内存分配新的字符数组以存储复制的字符串内容并包含一个空终止符的位置使用复制字符串内容不包括空终止符赋值构造函数构造指针地址为返回当前对象的引用转移所有权移动构造转移所有权自我赋值检查切断与先前的联系移动赋值运算符析构成功函数释放地址为经过析构函数测试如下输出如下构造函数构造指针地址为拷贝构造函数构造指针地址为析构成功函数释放地址为析构成功函数释放地址为测试如下输出如下构造函数构造指针地址为移动构造析构成功函数释放地址为经过析构函数非静态成员默认初始化从开始声明非静态数据成员的同时可以直接对其使用等号或大括号进行初始化以前只有类型为整形或者枚举类型的常量静态数据成员才可以进行这种默认初始化另外从开始允许我们对数据成员的基础位域位域进行默认初始化了可变参数模板基础模板基础模板知识点参阅关键词就是一个所谓的包用于模版参数就是模版参数包用于函数参数类型就是函数参数类型包用于函数参数就是函数参数包使用这种语法能兼容两个变化点模板参数的两个点参数个数本质是利用参数个数逐一递减的特性实现递归函数调用使用函数模板完成参数类型本质是利用参数个数逐一递减导致参数类型也逐一递减的的特性实现递归继承或递归复合使用类模板完成设计函数的时候当希望函数参数是类型不同个数也不同的时候采用可变参数模板当希望函数参数只有个数不同类型相同的时候可以采用但是调用的时候需要多写一对这种情况也可以使用可变参数模板只需要在定义参数为包的函数时使第一个参数的类型固定而不是模板类型函数案例针对下面的情况可以为任意数量包含个的参数并且每个参数可以是任何类型的为一包类型的一包参数用于查看包中的个数但函数的参数为个时因为个参数没办法拆分为所以会走即作为递归的终止条件可以这么理解在左边表示定义在后边表示使用表示定义类型包表示使用类型包使用类型包定义类型包的实例使用实例应该更复杂的版本要求是传入什么类型就输出什么类型用符号来占位表示本身找到占位符退出前继续打印接下来的跳过百分比符号可变参数模板求和案例超级类案例下面的案例是元组可以任意指定多个不同类型的成员构造出一个对象递归继承实现方式是通过可变参数模板实现的递归继承流程可描述为将类模板的类型分为一包先定义一个类型为第一个参数的类型使该类继承自类型为一包的类型的类下方代码下面有贴继承链下面案例是元组模板的声明用于告诉编译器有一个名为的模板类存在但具体的实现将在后面的代码中提供作为终止条件的空类递归继承定义的继承类型构造函数初始化列表表示调用父类的构造函数定义函数前也可以写成这种声明方法返回类型后置写法定义函数后转型为这是一个巧妙的函数通过该函数作为桥梁用于访问所有元素定义成员变量参照如下的继承链理解下图使用代替表示继承使用上面案例的情况如下获得获得获得递归复合层层复合下面案例是元组模板的声明用于告诉编译器有一个名为的模板类存在但具体的实现将在后面的代码中提供作为终止条件的空类定义的继承类型构造函数初始化列表表示调用父类的构造函数定义函数前也可以写成这种声明方法返回类型后置写法定义函数后转型为这是一个巧妙的函数通过该函数作为桥梁用于访问所有元素定义成员变量如下图罗列了每个类型的成员变量类型层层组合关系并存问题上面这种情况参数为包和包的两个重载函数可以并存注意当调用函数传入多个参数时参数为包比包更特化调用的是包那个函数即因此当他们共同存在的时候参数为包的函数就永远不会被调用到了可变参数模版的作用递归模版表达式中的空格每个版本的都支持从开始支持是引入的空指针常量用于代替或者赋值给空指针是一个类型的纯右值例子如下有两个函数调用哪个函数调用调用调用顾名思义的类型是一个与具有相同类型的类型用处为了在代码中使用更具有语义的类型例如可以使用来声明接受空指针的函数参数或返回类型以增加代码的清晰度和可读性三向比较在中引入了太空船运算符它是一种三向比较运算符用于比较两个值这个运算符返回一个特殊的值表示两个值之间的关系这个值可以是负整数零或正整数分别表示第一个值小于等于或大于第二个值太空船运算符的语法如下其中的值为负整数如果小于零如果等于正整数如果大于通过这个运算符可以用一个单一的运算符来处理所有六种传统比较操作小于小于等于等于大于大于等于和不等于这个运算符对于排序和比较操作非常有用可以简化代码并提高可读性注意运算符的返回值只能与和自身类型来比较如果同其他数值比较编译器会报错编译成功为变异失败的结果不能与除以外的数值比较返回类型运算符的返回值有三种类型严格相等相等并且可替换算相等非严格相等相等但不可替换算相等比如大小写不同的字符串非严格相等相等但不可替换算相等多了一个可以毫无比较关系的选项对基础类型的支持对两个算数类型的操作数对各操作数进行一般算术转换然后进行比较其中整形的比较结果为浮点型的比较结果为对于两个底层类型不同的枚举类型则无法编译对于其中一个操作数为类型的情况另外一个操作数必须也是类型否则无法编译比较结果为不支持比较的两个操作数为数组的情况会导致编译错误对于其中一个操作数为指针类型的情况需要另一个操作数是同样类型的指针或者是可以转换为相同类型的指针最终比较结果为自动生成比较函数规定当用户为自定义类型声明了三向比较运算符那么编译器会为其自动生成四种运算符函数前提是使用减少了开发者的工作量用户自定义类型中如果实现了运算符函数该类的三向比较中将自动生成合适的比较代码关键字表示任意类型声明变量时根据初始化表达式自动推断该变量的类型声明函数时函数返回值的占位符一大用处是当类型非常长或非常复杂的时候使用合理使用可以减少代码冗余非常长如非常复杂如关键字的特性从左往右的推导从左往右会先被推导为类型因此后半段会报错使用表达能力更强的类型此处会推导出的类型为而不是类型虽然这里的条件表达式最终返回的是不能声明非静态成员变量之前无法声明形参推导规则按值初始化忽略限定符即和两种推导出为类型按引用初始化忽略引用是类型万能引用推导为类型为数组或者函数会推导为指向相应类型的指针推导为指向类型的指针列表初始化该项在标准和其之前的标准有区别这里只提之后的标准直接使用列表初始化列表里必须是单个元素则推导为元素的类型多个元素编译无法通过使用等号赋值的列表初始化推导的类型是占位符使用从开始支持使用来推导函数的返回类型此时不需要使用返回类型后置的语法返回类型推导要求统一返回类型如果在中返回多个不同类型编译无法通过表达式的形参中使用开始支持给增加了一定的泛型能力非类型模板形参占位符开始支持与配合使用详情一致性初始化列表初始化的主要目的是让容器如同数组一般的被初始化传统初始化方式主要是两种使用括号初始化的方式叫做直接初始化使用等号初始化的方式叫做拷贝初始化现在任何变量的初始化都可以用一个共通语法设置初值他也分为直接初始化和拷贝初始化直接初始化拷贝初始化编号下面有讲解编号代码下面有讲解其实是利用一个事实编译器看到便做出一个它关联到一个调用函数例如构造函数时该内的元素可被编译器分解逐一传给函数但若函数参数就是个调用者不会分解逐一传给函数而是作为一个传入编号代码这形成一个背后有个调用时编译器找到了一个接受的构造函数所有容器都有这种构造函数编号代码这形成一个这形成一个背后有个调用构造函数时该内的个元素被分解传给构造函数并无任何构造函数接受参数初始化列表不填任何东西会被初始化若是指针则初始化为未被初始化被初始化为未被初始化初始化为初始化列表不允许大空间到小空间的转换收缩尽管是但没有收缩上面的在中是使用为了支持用户定义类型的初始化列表概念提供了类模板它可用于支持通过值列表进行初始化或者在任何其他只需要处理值列表的地方使用传给的一定必须也是个或者形式优先级问题如果同时有两个函数或者当执行会优先调用后者对容器的影响如今所有容器都接受指定任意数量的值用于构建或赋值或或和也可以接受任意参数要注意的是创建临时的空间大小为的里面的值是不确定的创建临时的空间里面的值是的原理内部的实现实际上是对的引用头指针和长度没有包含因此如果复制产生的另一个双方是同一个的引用初始化列表不支持隐式缩窄转换列表初始化由宽类型转为窄类型编译无法通过编译成功传统变量初始化支持隐式缩窄转换指定初始化为了提高数据成员初始化的可读性和灵活性标准引入了指定初始化的特性语言在标准就已经支持该功能了基本语法语法要求必须是一个聚合类型数据成员必须是非静态数据成员数据成员最多只能被初始化一次非静态数据成员的初始化必须按照声明的顺序进行针对联合体中的数据成员只能初始化一次不能同时指定不能嵌套指定初始化数据成员一旦使用指定初始化就不能混用其他方法对数据成员初始化了禁止对数组使用指定初始化委托构造函数引入了委托构造函数的概念允许一个构造函数调用同一个类的另一个构造函数来完成初始化为了简洁化冗余的构造函数传统构造方式如下此处调用了赋值构造函数此处调用了默认构造函数委托构造方式委托构造函数委托构造函数委托构造函数代理构造函数被委托方注意事项每个构造函数都可以委托另一个构造为代理不要递归循环委托委托构造函数的执行顺序是代理构造函数的初始化列表代理构造函数体委托构造函数体若在代理构造函数执行完成后委托构造函数主体抛出异常则自动调用该类的析构函数标准规定代理构造函数执行完成就算构造完成因此委托构造函数主体抛出异常必然会导致对象的析构若构造函数为委托构造函数那么其初始化列表不能对数据成员和基类进行初始化委托模板构造函数这种泛型能力可以有效减少构造函数的代码直接将代理构造函数的具体实现交给容器完成委托构造函数使用和初始化列表一样的基础机制处理异常若函数块在委托构造函数上而它调用的代理构造函数成功完成但之后该委托构造函数的函数体抛出了异常则将在进入函数块的任何子句之前完成此对象的析构函数若异常在代理构造函数的初始化列表或函数主体中被抛出委托构造函数主体将不再执行后序代码交给执行继承构造函数引入用于解决继承关系中构造函数的冗余默认构造函数会自动调用父类的默认构造函数基本语法继承构造函数相关规则派生类是隐式继承基类的构造函数所以只有在程序中使用了这些构造函数编译器才会为派生类生成继承构造函数的代码派生类不会继承基类的默认构造函数和拷贝构造函数继承构造函数不会影响派生类默认构造函数的隐式声明在派生类中声明签名相同的构造函数会禁止继承相应的构造函数继承构造函数但由于上一句不会继承代码派生类继承多个签名相同的构造函数会导致编译失败多继承多个签名相同的构造函数导致编译失败继承构造函数的基类构造函数如果是私有将不继承该函数强枚举类型语言入门枚举枚举类型有两个问题枚举类型可以隐式转换为整形由于有隐式转换为整形可以对枚举类型的值进行比较不合理无法指定枚举类型的底层类型中返回可以认为的底层是微软编译器返回可以认为的底层是输出是为了解决上述问题引入了强枚举类型三个新特性枚举标识符属于强枚举类型的作用域枚举标识符不会隐式转换为整形能指定强枚举类型的底层类型底层类型默认为类型基本语法关键词编译失败找不到的定义编译失败比较的类型不同编译失败无法隐式转换为类型指定类型方式如下指定类型为枚举类型的列表初始化标准开始对有底层类型的枚举类型对象可以直接使用列表初始化编译成功编译失败编译失败编译失败使用打开强枚举类型标准拓展让功能可以打开强枚举类型的命名空间打开强枚举类型的命名空间这样就不需要写的方式来表明枚举值而直接可以使用聚合类型的聚合类型概念是在标准中引入的引入这一概念的目的是为了提供一种简洁的方法来初始化结构体和类的成员以解决在早期版本中在初始化复杂数据结构时的冗长和不便通过聚合类型可以使用统一的初始化语法来初始化结构体和类的成员使代码更加简洁和易读聚合类型需要满足的条件没有用户提供的构造函数改成了没有用户声明的构造函数区别在于即使声明为显示删除构造函数或者显示默认构造函数都会将结构体改变为非聚合类型没有私有和受保护的非静态数据成员没有虚函数在新标准的拓展中如果类存在继承关系额外满足条件必须是的基类不能是私有或者受保护的基类必须是非虚继承注意聚合类型的要求没有要求基类必须是聚合类型输出如下聚合类型的初始化可以直接使用尖括号初始化总是假设基类是一种在所有数据成员之前声明的特殊成员聚合类型的初始化开始禁止受保护权限的构造函数在聚合类型初始化过程中被调用因此会导致编译错误解决方式很简单提供一个公有权限的构造函数就可以了这个改成类型就可以访问或者用下面的方式修改编译错误不可访问通过上面注释的两种方式解决小括号列表初始化后允许使用带小括号的列表初始化聚合类型对象小括号也支持了原本小括号初始化会优先查找相应参数的构造函数但是由于聚合类型不能有用户自定义的构造函数因此会编译失败但是允许小括号初始化结果与使用尖括号一致值得注意的是聚合类型的小括号列表初始化支持缩窄转换这是普通列表初始化所不支持的基于范围的循环的一种语法糖这种语法只适用于支持迭代器迭代器访问的容器本质上可以支持数组或对象对于对象必须满足以下个条件中的任意一个对象定义了和成员函数定义了以对象类型为参数的和普通函数规定了和函数不必返回相同类型范围声明形如范围表达式可以是数组或者是对象对象尤其指支持迭代器操作的容器其实本质上就是如下代码也由于其本质是属于隐式转换该构造函数不能隐式类型转换此处会报错不存在从类型到类型的转换原因正是因为隐含的执行失败语法糖的其他例子下面的方式才可以真正修改值如果在循环过程中确认不会修改引用对象那么推荐在范围声明中加上限定符以帮助编译器生成更加高效的代码和函数不必返回相同类型规定了和函数不必返回相同类型中编译器针对这种特殊写法自动生成的伪代码这一句就要求了和必须是同一个返回类型编译器针对这种特殊写法自动生成的伪代码分开接收了和函数的返回值类型意义虽然标准容器如等的和返回相同的类型但并非所有的组件都如此和迭代器的返回普通的输入迭代器但返回一个特殊的默认构造的迭代器用于表示流结束更大的意义在于支持自定义范围类型在某些自定义类型中和返回不同类型是合理且必要的例如只读范围返回一个可变迭代器而返回一个不可变迭代器半开区间返回一个普通迭代器而返回一个哨兵值这种模式在处理流式数据或异步数据源时尤为常见返回哨兵输出临时范围表达式初始化语句允许在范围声明之前可以先执行初始化语句实现一个支持基于范围的循环的类条件该类型必须有一组和其类型相关的和函数他们可以是类的成员函数也可以是独立函数和函数需要返回一组类似迭代器的对象并且这组对象必须支持和运算符符号自定义类开始迭代器结束迭代器创建一个对象使用基于范围的循环遍历对象在这个示例中我们定义了一个名为的类它包含了开始和结束范围通过在类中实现和方法我们使得对象可以被用于基于范围的循环在主函数中我们创建了一个对象并使用基于范围的循环遍历了这个对象并输出了结果支持初始化语句的和从开始和支持初始化语句基本语法初始化语句中声明的变量生命周期将会伴随整个代码块常用方法互斥锁这行代码创建了一个对象它会在构造时锁住所表示的对象然后在作用域结束时自动释放锁这代码使整个作用域内对共享资源的访问是互斥的基本语法声明基础断言运行时断言是在头文件中引入的运行时断言是一种在运行时检查条件是否为真的机制如果条件为假程序将以错误消息终止运行时断言的缺点只有在程序运行到断言出才能给出断言的判断因此引入了声明编译阶段就能确定正确与否静态断言用于在程序编译阶段评估常量表达式并对返回的表达式断言对静态断言的要求所有处理必须在编译期间执行不允许有空间或时间上的运行时成本必须具有简单的语法断言失败可以显示丰富的错误诊断信息可以在命名空间类或代码块内使用失败的断言会在编译阶段报错使用方法基本语法常量表达式诊断消息字符串常量表达式为假的时候终止程序并打印诊断消息字符串单参数标准支持单参数即不用传参诊断消息字符串函数内部默认为常量表达式的字符串本身互斥锁和都是引入的内容因此它们通常可以在头文件中找到因此为了使用和您需要包含头文件引入标准允许编译器为类自动添加一些函数这些函数被称为类的特殊成员函数如下默认构造函数析构函数拷贝构造函数拷贝赋值运算符移动构造函数移动赋值运算符声明任何构造函数都会抑制默认构造函数的添加上面除了析构函数之外其余的都是构造函数如果你加上编译器就会给你生成如果有的话一个默认版本如果加上表示不要编译器给我生成默认版本拷贝构造函数构造函数右值引用拷贝赋值函数赋值函数类中会给函数的无参构造函数拷贝构造函数拷贝赋值构造函数自动生成默认版本的定义浅拷贝在后多了两种会自动生成的构造函数总共五种俗称这种默认生成的构造函数全是且的用于之外是无意义的可用于任何函数身上只能用于函数注意不要同时使用和此句无法编译通过因为显示调用执行了函数却被掉了此句可以编译通过非受限联合类型语言入门共用体联合体传统联合类型的成员类型不能是一个非平凡类型成员类型不能有自定义的构造函数无法编译通过于是以后非受限联合类型得到了支持若联合类型中存在非平凡类型则该联合体的构造和析构函数将被隐式删除必须在联合体中定义构造和析构函数存在非平凡类型成员必须提供构造函数存在非平凡类型成员必须提供析构函数非平凡类型非平凡类型这样可以保证使用没有问题但使用其他成员又怎么办呢此处使用基础机制机制来初始化构造和什么都不做非平凡类型非平凡类型使用手动调用析构函数使用手动调用析构函数中的联合类型使用率过低了解即可在中引入用于获取当前存在的未捕获异常的数量这个功能常在析构函数资源管理类或执行清理操作时用于防止在异常处理中再抛异常检查是否有未捕获的异常如果存在未捕获的异常仅做清理不抛出异常若无未捕获异常正常关闭文件可能抛出异常强制引发异常为了替代用于函数声明的异常规范功能而提出的一个新的关键字移动语义出来之前就够用了移动语义有个问题就是出现异常的时候会导致移动的对象和被移动的对象都出问题解决方式关键词常量表达式常量表达式的结果会被转换成一个类型的值该值为表示函数不会抛出异常反之则能抛出异常而不带常量表达式的相当于声明了即不会抛出异常上下两种方式相等表示一定没有异常作为运算符的情况不仅仅是说明符也是运算符输出可以用来阻止异常的传播和扩散作用于模板时则增强了的泛型编程的能力更大的用处就是保证程序的安全因此出于安全考虑标准中类的析构函数默认为但是如果程序员显式地为析构函数指定了或者类的基类或成员有的析构函数析构函数就不会再保持默认值提高效率移动构造函数默认为可以去除一些异常处理机制提高效率带参数语法用解决移动构造问题阻止会抛出异常的移动简单粗暴直接让移动有风险的对象代码直接编译阶段报错总体来说这段代码实现了一个泛型的交换函数并使用静态断言和关键字来确保交换操作的安全性和效率更聪明的方法让编译器自己选择更适合的版本一个泛型函数它根据类型是否支持无异常移动语义来决定采用不同的交换策略优先采用移动语义以提高效率同时确保在移动操作可能抛出异常的情况下能够回退到安全但可能较慢的拷贝交换方式通过移动交换通过拷贝交换是标准库中定义的一个模板类它主要用于模板元编程这个类模板的主要作用是存储编译期已知的类型为的常量值并且可以通过其成员变量在运行时访问该常量和的差别相同的结果不同的机制相同的结果和机制被移除默认使用的函数五大会自动生成的函数都会默认使用类型默认构造函数默认拷贝构造函数默认赋值函数默认移动构造函数默认移动赋值函数另外上面对应的这些函数在类型的基类和成员中也具有声明另外还有默认带有声明的函数类的析构函数运算符用于释放运算符分配的内存空间使用的时机一定不会出现异常的函数函数虽然可能抛出异常但是这是绝对不能接受的否者程序应该直接终止比如类中的移动相关函数异常规范作为类型的一部分定义的函数指针变量为之前通过编译及以后的标准无法通过编译用于让编译器检查是否符合重写规则应用在虚函数身上表示对虚函数的覆写改写重写重载通常是指在同一个类中有两个或两个以上的函数函数名相同但函数签名不同即有不同的形参重写意思更接近覆盖指派生类覆盖了基类的虚函数隐藏指基类成员函数无论他是否为虚函数当派生类出现同名函数时若派生类函数签名不同于基类函数则基类函数会被隐藏若派生类函数签名与基类函数相同则需要确认基类函数是否为虚函数若为虚函数就是重写否则就是隐藏下面四个全都报错为使用声明的成员函数不能重写基类成员想要重写但拼写错误函数签名不一致函数签名不一致不是虚函数不是重载可以用于声明虚函数也可以用于声明类声明类阻止类被作为基类表明为最终继承类声明虚函数阻止派生类函数去继承此类的虚函数表明为最终覆写虚函数不能再往下覆写了局部数组可用变量初始化大小之后使局部数组可以直接使用变量初始化大小原本编译时常量就可以为变量初始化大小是一个模板参数它在编译时就已经确定了值因此可以用来初始化类的成员变量的数组长度这样使用是合法的使用编译时常量初始化数组长度这样使用是合法的使用编译时常量初始化数组长度这样使用是非法的错误不是一个编译时常量现在支持如下语法但注意只能在函数内部定义的数组中使用不能作为类的成员变量或全局变量使用用于获取表达式的类型在中可以通过得到类型名的一串字符串但是获取到的类型只是字符串无法真正使用该类型并且各编译器返回的字符串还不相同虽然彼时有些编译器支持可以实现此功能但并非标准上面这行等价于正是可以实现类似的功能并且同时具备完备的兼容性使用方式定义了一个与变量相同类型的变量在之前上面代码可以理解成如下推导规则其中的类型为的推导规则有五条如果是一个未加括号的标识符表达式结构化绑定除外或者未加括号的类成员访问则推断出的类型是的类型如果并不存在这样的类型或者是一组重载函数则无法进行推导潜台词就是下面其他规则都是带括号的如果是一个函数调用或者仿函数调用那么推断出的类型是其返回值的类型如果是一个类型为的左值则是如果是一个类型为的将亡值则是除去以上情况则是限定符的推导通常情况下所推导的类型会同步的限定符当是未加括号的成员变量时父对象表达式的限定符会被忽略符合规则推导类型为符合规则类型为符合规则类型为因为限定符规则的第二条因此未同步对象带有的限定符符合规则因为是一个左值又因为带有限定符所以类型被推导为的引用类型即的类型如果想打印出来观察可以配合使用来观察比如打印出来为打印出来为和配合使用用的推导表达式规则来推导按照的推导规则推导为按照的推导规则推导为为非类型模板形参占位符主要作用声明返回类型返回类型为后的结果的类型上面这种情况想要实现的效果编译无法通过因为编译器从左到右识别到的时候他还不知道和是什么因此编译报错又出现了一种新语法如下让编译器找类型紧接着的符号与编译器表明类型这种语法和定义的方式很像下面是表达式的定义方式用于元编程该函数针对容器当我们手上有类型的时候可以取其面对对象可以取其类的类型因为现在我们有了工具下面是故意设计本测试函数为接受任意参数假设他接受的是容器获取他的类型又该如何获取由于编译器见到的时候还无法确定他是什么所以要加辅助编译器认识是个类型然后使用将该类型起别名为是容器的一个成员类型别名用于表示容器中存储的元素类型在容器中通常用于定义容器内元素的类型方便编写通用的泛型代码另外针对这种容器还有可以获取其键的类型取中元素的类型来定义变量传递表达式的类型面对我们手上往往只有对象没有类型要获得其类型就得借助于定义需要用到上面表达式的类型创建一个名为的容器对象其中元素的类型是使用作为排序比较函数如果传入的值不是报错会特别晦涩难懂即上文中的括号中的对于自定义排序函数来说一个普通的函数还是更直观类型别名与别名模板类似关键字对该关键词赋予了新的意义基本语法定义一个类型等同于这种语法超脱于的地方就在于别名模板也是他诞生的原因别名模板定义使用这里的类型被传入了别名模版中与下面相等使用和无法达到类似的效果用只能达到这种程度需要注意的是别名模版不能基础函数模特化函数模板特化与基础类模板特化类模板特化表达式看起来像一个函数实际上是一个对象中的表达式用于定义并创建匿名的函数对象以简化编程工作表达式最简形式下面的函数是把表达式写成内联函数其实是定义了一个类定义该类的仿函数函数体如下代码定义为这个类的对象如果用变量接收接收到的是一个匿名的函数对象调用函数对象上面写法与下面写法等同定义一个类并创建对象并且调用该函数对象的仿函数表达式完整构成简单理解部分用于指定哪些变量应被捕获并以何种方式捕获捕获可以分为按值捕获和按引用捕获最简单也最具代表性的两种用法按值捕获是将外部变量的副本存储在中按引用捕获是将外部变量的引用存储在中表示该项可选三个可选项只要有一个存在就必须写小括号函数对象参数捕获列表标识一个的开始这部分必须存在不能省略函数对象参数是传递给编译器自动生成的函数对象类的构造函数的函数对象参数只能使用那些到定义为止时所在作用范围内可见的局部变量包括所在类的这里指明局部变量的原因是因为全局变量本来就可以在类中被使用如果使用全局变量或者变量一般会被编译器警告函数对象参数有以下形式空没有使用任何函数对象参数函数体内可以使用所在作用范围内所有可见的局部变量包括所在类的并且是值传递方式相当于编译器自动为我们按值传递了所有局部变量函数体内可以使用所在作用范围内所有可见的局部变量包括所在类的并且是引用传递方式相当于编译器自动为我们按引用传递了所有局部变量函数体内可以使用所在类中的成员变量将按值进行传递按值进行传递时函数体内不能修改传递进来的的拷贝因为默认情况下函数是的要修改传递进来的的拷贝可以添加修饰符将按引用进行传递将按值进行传递按引用进行传递除和按引用进行传递外其他参数都按值进行传递除和按值进行传递外其他参数都按引用进行传递标准开始定义了广义捕获分为下面两种简单捕获上方介绍的为简单捕获初始化捕获的作用域为表达式中操作符重载函数参数标识重载的操作符的参数没有参数时这部分可以省略参数可以通过按值如和按引用如两种方式进行传递注意是要带类型的开始类型还可以使用可修改标示符声明这部分可以省略按值传递函数对象参数时加上修饰符后才可以修改按值传递进来的拷贝注意是能修改拷贝而不是值本身函数返回值返回值类型标识函数返回值的类型当返回值为或者函数体中只有一处的地方此时编译器可以自动推断出返回值类型时这部分可以省略是函数体标识函数的实现这部分不能省略但函数体可以为空很重要的一点利用获取表达式的类型的一些注意点无状态表达式从开始对于无状态表达式是可以构造和赋值的即可以隐式转换为函数指针解决了无法就地编写内嵌函数的尴尬问题捕捉上下文变量即捕获列表中是否有东西不管实际函数体中有没有用到上下文变量只要不活了上下文变量都属于有状态在需要函数回调为参数的函数中非常有用捕获和拷贝对象是为了区分模板语法的泛型表达式从开始可以使用下面语法从开始表达式在条件允许的情况下都会隐式声明为详情跳转表达式案例细节值传递引用传递以及值传递三种情况的比较如下值传递输出内容如下引用传递输出内容如下值传递此处报错不可修改报错原理表达式出现的契机正是用来代替被临时定义使用的可调用对象我们可以把表达式理解为一个未命名的函数但他又不同于一般的函数他有一个很大的特点就是可以捕获状态但又不需要声明一个新的类来保存状态而其实在编译器内部对表达式的处理就是生成了一个未命名的类并通过表达式生成该未命名类的未命名函数对象因此对于那些我们只要用一次的简短的函数或函数对象来说利用表达式能极大的增强代码的封装性和可读性表达式是一个函数对象在定义一个表达式的时候相当于编译器为我们定义了一个临时的类该类重载了函数调用运算符同时对于引用捕获的变量编译器无须在产生的类中将其存储为数据成员而只需要存储引用而对于值捕获的变量由于其需要被拷贝到中因此这种产生的类就必须为每个值捕获的变量建立对应的数据成员同时创建构造函数若将一个变量初始化为一个表达式则相当于初始化了一个该临时类的对象而在调用的时候就相当于调用了该类的函数重载运算符参考下面相当于生成了上面的类编译器会生成一个类类似于上面定义的类函数对象难点重载函数调用操作符的类其对象常称为函数对象即它们是行为类似函数的对象也叫仿函数其实就是重载操作符使得类对象可以像函数那样调用注意函数对象仿函数是一个类不是一个函数函数对象仿函数重载了操作符使得它可以像函数一样调用分类假定某个类有一个重载的而且重载的要求获取一个参数我们就将这个类称为一元仿函数相反如果重载的要求获取两个参数就将这个类称为二元仿函数函数对象的作用主要是什么提供的算法往往都有两个版本其中一个版本表现出最常用的某种运算另一版本则允许用户通过参数的形式来指定所要采取的策略注意定义函数对象类的时候不能使用小括号定义无论构造函数任何情况都是错的如这样是错的而应该是但如果存在带参构造函数可以使用来定义函数对象是重载了函数调用符号的类函数对象重载了操作符的类实例化的对象可以像普通函数那样调用可以有参数可以有返回值函数对象超出了普通函数的概念可以保存函数的调用状态调用次数函数对象作为参数参数匿名函数对象总结函数对象通常不定义构造函数和析构函数所以在构造和析构时不会发生任何问题避免了函数调用的运行时问题函数对象超出普通函数的概念函数对象可以有自己的状态函数对象可内联编译性能好用函数指针几乎不可能模版函数对象使函数对象具有通用性这也是它的优势之一谓词谓词是指普通函数或重载的返回值是类型的函数对象仿函数如果接受一个参数那么叫做一元谓词如果接受两个参数那么叫做二元谓词谓词可作为一个判断式一元谓词与二元谓词的案例含表达式一元谓词一元谓词该函数在中没有找到找到了二元谓词二元谓词默认从小到大使用函数对象改变算法策略排序从大到小匿名对象也可以填回调函数上面的遍历显示也可以用函数是遍历函数其中的第三个参数时表达式本质上就是匿名函数表达式代表表达式标志函数参数列表函数体内建函数对象内建了一些函数对象分为算数类函数对象关系运算类函数对象逻辑运算类仿函数这些仿函数所产生的对象用法和一般函数完全相同当然我们还可以产生无名的临时对象来履行函数功能使用内建函数对象需要引入头文件个算数类函数对象除了是一元运算其他都是二元运算加法仿函数减法仿函数乘法仿函数除法仿函数取模仿函数取反仿函数个关系运算类函数对象每一种都是二元运算等于不等于大于大于等于小于小于等于逻辑运算类运算函数为一元运算其余为二元运算逻辑与逻辑或逻辑非内建函数对象举例取反仿函数加法仿函数大于仿函数大于仿函数函数对象适配器函数对象适配器和现在我有这个需求在遍历容器的时候我希望将容器中的值全部加上用户输入的数之后显示出来怎么做我们直接给函数对象绑定参数编译阶段就会报错如果我们想使用绑定适配器需要我们自己的函数对象继承或者根据我们函数对象是一元函数对象还是二元函数对象自己建的函数对象写适配器要三个操作利用或进行绑定继承参数类型参数类型返回值类型或加注意内建的函数对象不需要写这些其实想写也没法写内置的嘛利用函数指针适配器和成员函数适配器转换成的函数对象也不需要写同样也没法写继承必须加函数适配器由用户输入请输入起始值绑定总结和区别将参数绑定为函数对象的第一个参数将参数绑定为函数对象的第二个参数作用将二元函数对象转为一元函数对象所以或如果要和其他适配器嵌套比如需要用的是因为已经转换为一元函数对象取反适配器和取反适配器返回第一个大于的迭代器返回第一个小于迭代器自定义输入并且使用内建函数对象没找到找到排序二元函数对象对一元函数对象取反对二元函数对象取反函数指针适配器函数指针适配器把一个普通的函数指针适配成函数对象成员函数适配器和如果容器存放的是对象指针那么用如果容器中存放的是对象实体那么用打印函数成员函数姓名年龄利用将内部成员函数适配成员函数指针要表示和普通函数指针只要写函数名有区别创建数据智能指针原理智能指针主要用于管理在堆上分配的内存它将普通的指针封装为一个栈对象这意味着智能指针本身是在栈上的但它所管理的内存是在堆上分配的当智能指针本身被回收以后会将智能指针上管理的内存释放优点自动内存管理智能指针可以自动处理内存的分配和释放避免了内存泄漏和悬空指针的问题避免手动释放内存使用智能指针可以避免手动释放内存的麻烦减少了出错的可能性安全性智能指针通常会在其生命周期结束时自动释放内存避免了因忘记释放内存而导致的内存泄漏方便性智能指针提供了类似于原始指针的使用方式但又具有自动内存管理的功能使得代码更加简洁和易读智能指针参考手册头文件智能指针的用途帮助管理内存可以做到自动释放内存避免忘记释放而造成内存泄露允许多个智能指针指向同一个空间使用引用计数来跟踪资源的生命周期多个类共享指针存在这么一个问题每个类都存储了指针地址的一个拷贝如果其中一个类删除了这个指针其它类并不知道这个指针已经失效此时就会出现野指针的现象为了解决这一问题我们可以使用引用指针来计数仅当检测到引用计数为时才主动删除这个数据只能一个智能指针指向同一个空间不能进行复制或共享资源可以通过移动语义转移资源所有权是为了配合而引入的一种智能指针它指向一个由管理的对象而不影响所指对象的生命周期也就是将一个绑定到一个不会改变的引用计数它是一种用于解决循环引用时产生死锁问题的智能指针不拥有资源所有权不能直接访问所管理的资源在功能上类似于普通指针比较大的区别是弱引用能检测到所管理的对象是否已经被释放从而避免访问非法内存在中移除已被取代使用和这两个函数提供了一种更安全和高效的方式来创建智能指针避免了手动调用可以通过函数获取一个有效的如果原始的已经释放了资源则返回空指针的局限性复制或者赋值都会改变资源的所有权被抛弃的主要原因由于类型本身支持释放自己所以这个类型实际上没什么意义赋值给后首先会先将自己原先托管的指针释放掉然后接收托管所托管的指针然后所托管的指针制也就是托管了托管的指针而放弃了托管赋值后运行时报错段错误内存访问越界如果替换为在编译的时候会报错因为中的拷贝赋值运算符是删除了的若改为那么会和上面案例一样报内存访问越界问题因为已经释放跟一样可以赋值但是需要使用修饰使得程序员知道后果不支持对象数组的内存管理不能这样定义报错没有与参数列表匹配的构造函数用更严谨的取代了不支持移动语义不支持对象数组的内存管理支持移动语义并且支持对象数组的内存管理会自动调用函数去释放内存支持这样定义除了上面指出的两点外的其余用法都与用法一致与智能指针的内存管理陷阱可以通过下面的方式破坏排他性智能指针的内存管理陷阱托管指针接管指针时会先取消的托管然后再对的托管都会在最后被释放导致两次释放同一个对象的错误三种初始化方式以作为案例直接使用构造函数括号里是赋予的初始值由于接受指针参数的构造函数是的因此不能将指针隐式转换为使用括号里是赋予的初始值直接赋值的内存空间引用计数会原本的内存空间引用计数会是中引入的一个函数编译时需要指定常用获取指针值虽然可以获得原始值但我们不应该这一指针也不应该用它赋值初始化另一个智能指针当将原生指针传给后就应该让接管这一指针而不再直接操作原生指针智能指向的内存的引用次数有几个智能指针指向这块内存对智能指针进行重置操作使智能指针原有的指向修改为新的指向该函数会首先将原有的内存的引用计数减当减小到的时候就会释放内存其实就是重新赋值使用可以交换两个智能指针管理的内存对象构造函数空的可以指向类型为的对象定义同时指向类型为的对象空的可以指向类型为的数组对象后支持指向类型为的数组对象后支持空的接受一个类型的删除器使用释放内存这种情况仅用于自动执行释放操作定义指向类型为的对象接受一个类型的删除器使用删除器来释放内存使用智能指针管理对象数组是个类不加参数的话只会释放一个这种方式释放内存对不可用编译器会报错还是推荐用下面的方式这样的话也就可以释放全部对象数组智能指针可以像普通指针那样使用智能指针可以像普通指针那样使用的原因在于因为其里面重载了和运算符返回普通对象而返回指针对象工作原理是一种智能指针它使用引用计数的方式来自动管理所指向对象的生命周期当多个共享同一个对象时它们会共同维护一个引用计数主要规则如下创建一个时初始引用计数为当一个被复制或拷贝赋值给另一个时目标会增加源所指向对象的引用计数当一个被销毁如离开作用域时它会减少所指向对象的引用计数当一个对象的引用计数降至时会自动释放该对象调用其析构函数并回收其占用的内存模拟代码由于利用引用计数的方式因为引用计数算是临界资源所以对其的操作必须通过互斥量进行保护进行原子操作保护临界资源释放资源增加引用计数赋值拷贝增加引用计数先释放可能持有的资源增加引用计数增加引用计数释放资源减去一次引用计数判断是否需要释放资源真正的最后释放锁指向管理资源的指针引用计数指针互斥锁使用陷阱作为被管控的对象的成员时小心因循环引用造成内存泄漏构造函数析构函数构造函数析构函数陷阱用法此时和的引用计数都是为了解决循环引用的问题循环引用也就是相互之间都有引用计数关系使得对象无法真正被释放的问题解决循环引用的原理在引用计数的时候将和指针修改成智能指针即可原理就是和时的和不会增加和的引用计数结构化绑定标准引入结构化绑定允许将一个结构体或元组的成员绑定到单独的变量中以便更方便地访问和操作这些成员接受多个返回值关键词标识符列表绑定原生数组绑定到结构体和类对象结构体或类的非静态公有数据成员包括继承来的成员必须和标识符列表中的别名的个数相同有另外的修改输出为绑定到元组和类元组的对象需要满足条件这是一种方向指导而不是具体的代码首先需要满足是一个符合语法的表达式并且该表达式获得的整数值与标识符列表中的别名个数相同其次类型还需要保证也是一个符合语法的表达式其中是小于的整数表达式代表了类型中第个元素的类型最后类型必须存在合法的成员函数模板或者函数模板其中是小于的整数是类型的实例和返回的是实例中第个元素的值结构化绑定是基于编译器能直接访问其公有非静态数据成员而实现的如果想自己实现这种结构化绑定的机制可能需要借助其他技术或等待未来标准对反射等特性更完善的支持也有说法是可以对任意对象做结构化绑定前提是要编写额外代码此处有存疑下面是一种间接模拟的方式并非原生地为自定义类型提供了结构化绑定支持以及之前的标准并未直接支持对所有自定义类型的结构化绑定功能提供一个返回的方法这种方式可以访问私有成员避免了绑定的访问权限问题很实用的一种情形案例如下目前这种做法可以做到让返回值更富有语意并且可以很方便的扩展如果要增加一个新的返回值只需要扩展现有的结构体就可以了正如上文所说在中对于多返回值更建议使用或这样做能让返回值的语意更加明确结构化绑定的原理在结构化绑定中编译器会根据限定符生成一个等号右边对象的匿名副本而绑定的对象正是这个副本而非原对象本身另外这里的别名就真的是单纯的别名别名的类型和绑定目标对象的子对象类型相同绑定的访问权限问题对于私有或保护成员即使在友元函数内也无法直接通过结构化绑定访问它们编译成功编译失败无法绑定到非公共的成员结构化绑定无法绑定到私有成员常量表达式以前没有一种方法可以保证编译期间确定常量和函数的计算结果的详情参考下面视频无法保证编译器确定的常量触发编译错误因为编译器认为必须是运行期才能确定下来的于是引入了关键字一个用说明符声明的变量或数据成员要求该值必须在编译器计算与的对比如下定义和初始化成功编译失败无法用初始化常量表达式函数常量表达式函数的返回值可以在编译阶段那就计算出来常量表达式函数约束条件标准函数必须返回一个值所以它的返回类型不能是函数体必须只有一条语句其中必须也是一个常量表达式函数使用之前必须有定义函数必须用声明即使成功定义了常量表达式函数也不一定最终就在编译器求值因为传入的实参如果不是常量表达式常量表达式函数会退化为普通函数约束条件新标准标准函数体允许声明变量除了没有初始化的和变量函数允许出现和语句不能使用语句函数允许所有的循环语句包括函数可以修改生命周期和常量表达式相同的对象函数的返回值可以声明为修饰的成员函数不再具有属性约束条件拓展标准明确允许在常量表达式中使用虚函数允许在中进行平凡的默认初始化允许在函数中出现可以出现但没有意义因为语句用于处理运行时的异常而函数在编译时就会被求值不会引发运行时异常因此编译器通常会在编译时检查函数的代码是否会引发异常并在有可能引发异常的情况下导致编译错误因此在函数中使用是没有意义的允许在中更改联合类型的有效成员允许和出现在常量表达式中进一步拓展暂略表达式从开始表达式在条件允许的情况下都会隐式声明为常量表达式构造函数作用于自定义类型编译失败编译失败无法在编译阶段计算使用常量表达式构造函数约束条件构造函数必须用修饰构造函数初始化列表里必须是常量表达式构造函数的函数体必须为空意义常量表达式用于构造函数的意义主要体现在优化和安全性方面编译时常量化如果一个构造函数使用常量表达式初始化对象的某些成员变量那么在编译时就可以计算出这些值这有助于在编译时捕获潜在的错误并减少运行时开销提高性能通过使用常量表达式程序在运行时需要做的计算减少了因为某些结果已经在编译时得到这降低了程序的执行时间特别是在资源受限的系统中这种优化尤为重要代码安全性因为常量表达式在编译时计算有助于确保代码的一致性和安全性它可以防止某些类型的错误例如未经初始化的数据使用不可变性常量对象或只读数据成员可以用常量表达式进行初始化这确保了对象一旦创建其状态就不能再被改变增加了对象的不可变性这也使得代码更易于推理和测试元编程支持在现代中使用关键字的能力支持了一些更高级的编程技巧如模板元编程这使得开发者可以编写出更通用灵活和高效的代码的条件必须是编译器能确定结果的常量表达式条件结果一旦确定编译器将只编译符合条件的代码块编译失败不是常量表达式成功编译是引入的一个新关键字用于强制声明一个编译时求值的函数是非强制性的由编译器决定是否在编译器就执行计算而是确保函数在编译器就执行计算用法与一致是引入的一个新关键字用于声明在程序启动时初始化的变量它确保在程序启动时初始化变量以避免静态初始化顺序问题使用可以提高程序的可靠性和可移植性当一个变量被声明为时它要求该变量必须在编译时用常量表达式进行初始化而且只能在声明时初始化不能在运行时再次赋值解决因为静态初始化顺序错误导致问题例如假设有两个静态对象和分别存在两个不同的源文件中其中一个对象的构造函数依赖于对象现在我们有的可能性会出错因为哪个对象先构造决定了是否有错为了避免这种问题发生我们通常希望使用常量初始化程序去初始化静态变量不幸的是常量初始化的规则很复杂需要一种方法帮我们完成检查工作当不符合常量初始化时可以在编译阶段报错于是引入了关键词使用检查常量初始化规则用于具有静态存储持续时间的变量声明上它要求变量是常量初始化编译成功全局变量具有静态存储持续编译成功静态变量具有静态存储持续编译失败局部变量是动态分配的或者要求变量具有常量表达式初始化程序可以不写的编译错误不是一个常量表达式初始化程序编译成功线程局部存储将对象内存和线程关联起来对象在线程开始时分配内存在线程结束时释放内存每个对象相对线程是独立的并且不会相互干扰线程局部存储原本是操作系统层面的概念使用的是和全局变量静态变量等一样的存储空间但是的变量是线程私有的每个线程都有自己的副本而全局变量和静态变量则是所有线程共享的和都有各自的方法管理线程局部存储分配未被使用的线程局部空间的索引获取索引指向的空间的值设置索引指向的空间的值释放索引指向的线程局部空间分配未被使用的线程局部空间的索引获取索引指向的空间的值设置索引指向的空间的值释放索引指向的线程局部空间编译器对线程局部存储的支持之前方式不统一后统一了标准关键词放在变量声明前表示为线程局部存储基本语法被声明的变量在行为上非常像静态变量只不过多了线程属性他能够解决全局变量和静态变量在多线程程序中存在的问题典型的例子为的多线程安全问题一个多线程程序线程正准备获取错误码另一个线程修改了错误码这时候线程获取到的错误码就不合理了为了解决这个问题标准将重新定义为线程独立变量线程局部存储的内存地址线程局部存储只定义了生命周期而没有定义访问性即可以获取线程局部存储变量的地址并将这个地址传递给其他线程并且其他线程可以在变量生命周期内自由使用该变量但这样做意义不大并且风险性大容易导致未定义行为造成程序崩溃线程局部存储的地址是运行时被计算出来的和全局变量地址是编译时确定的因此线程局部存储的地址不是一个常量因此无法和常量表达式结合线程局部存储对象初始化和销毁对于同一个线程中线程局部存储对象只会被初始化一次即使被多次调用有点类似静态变量只会在全局初始化一次线程局部存储对象的销毁通常发生在线程销毁的时刻头文件从标准开始引入的内容属于标准库的一部分用于代表一个固定数量的异质对象的集合线程语言级线程支持关于并发引入了好多新东西这里按照如下顺序介绍相关相关相关相关相关相关相关相关相关之前可能使用来创建线程繁琐且不易读引入了来创建线程支持对线程或者新容器谷歌代码规范开源项目风格指南曾作为一个技术规范存在并且在库中有一个成熟的实现随着的发布文件系统库成为标准库的一部分使得程序员能够在不依赖第三方库的情况下进行跨平台的文件系统操作针对顺序容器引入了三个新成员在容器开头直接构造新元素在指定位置直接构造新元素代表了直接调用构造函数直接不传参数相当于调用无参构造函数即在栈上就地构造在容器末尾直接构造新元素定义版本版本添加了返回值版本说明符具体条件这三个操作与操作相同但这些操作是构造元素而不是拷贝元素在插入时由于我们传的是右值其调用了构造和移动构造而只调用了构造函数也就是说是在插入位置直接构造元素而不是和一样先是构造好再移动或复制到插入位置这样做的优势就是能够减少一次移动构造或拷贝构造优势性能优化避免了不必要的临时对象创建和拷贝操作直接构造参数直接传递给对象的构造函数如果是空的话相当于直接在栈上构造完美转发保持参数的值类型和引用类型后和返回对新构造元素的引用三剑客可存在可不存在包装器任意类型类型安全的联合体可以存储指定类型中的一个头文件引入之前的版本可以通过实现几乎相同的功能包装可以为空的类型类模板管理一个可选的容纳值既可以存在也可以不存在的值一种常见的使用情况是一个可能失败的函数的返回值与其他手段如相比良好地处理构造开销高昂的对象并更加可读因为它显式表达意图的内存管理是自动的当的生命周期结束时它所持有的值会被自动释放具体来说当对象被销毁时如果它包含一个值即状态为有值那么这个值的析构函数会被调用从而释放相关资源如果它没有值状态为无值则不会有任何资源释放操作引入是中提供的没有值的的表达形式等同于创建一个的方法空允许你在对象的存储空间中直接构造值避免了不必要的拷贝或移动操作用来指示原位构造对象拷贝赋值使用方法也可以将一个类型对象置入一个已经存在的对象中访问对象中数据的方法跟迭代器的使用类似访问没有的的行为是未定义的当没有时调用该方法将异常当没有调用该方法时将使用传入的默认值判断对象是否有值使用函数来询问此时是否有值可以显式地转化为型变量来显示他此时是否拥有一个有意义的值有值销毁对象中的值方法销毁存储在中的值并将其值为空中的函数式编程首先需要了解架构相关函数式编程函数式编程的思想纯函数在中实现一个纯函数但又要递归而递归的过程中需要利用一个共享空间来在递归函数中共用同时需要保持纯函数的性质呢比如说斐波那契数列求值带有缓存功能的递归斐波那契函数如果没有提供缓存则新建一个缓存检查缓存中是否已有结果基本情况递归计算并存储结果在缓存中虽然使用到了空间但不依赖外部高阶函数是一个高阶函数因为它接受另一个函数作为参数在函数中我们通过表达式将一个简单的操作传递给来处理向量中的每个元素定义高阶函数接收一个函数作为参数使用表达式作为高阶函数的参数常用的高阶函数将给定范围内的每个元素通过某种转换函数转换为一个新的值通常用于对容器中的元素进行批量操作使用将中的每个元素平方导出为复制满足某个条件的元素到一个新的容器通常用于过滤操作使用将中所有偶数复制到是插入到末尾迭代器需要头文件对指定范围内的元素进行累积求值通常用于总和乘积或其他累积操作需要这个头文件使用计算所有元素的乘积对指定范围内的元素进行聚合运算需要这个头文件使用计算元素总和使用自定义操作符乘法使用并行执行策略仅在支持并行的系统中有效接受一个可选的执行策略参数顺序执行默认并行执行并行且无序执行对指定范围内的每个元素执行某个操作使用对每个元素执行操作检查指定范围内是否存在至少一个满足给定谓词条件的元素返回或使用检查是否存在偶数检查指定范围内的所有元素是否都满足给定谓词条件返回或使用检查是否所有元素都是偶数在指定范围内查找第一个满足给定谓词条件的元素返回指向该元素的迭代器如果未找到返回结束迭代器使用查找第一个偶数组合函数与管道函数组合函数的实现函数可以将多个函数组合成一个新的函数从右到左执行基础模板结束递归组合递归组合函数示例函数相当于输出因为也可以使用实现管道函数的实现函数将多个函数从左到右组合可以认为它是的逆序实现基础模板结束递归组合递归组合函数示例函数相当于输出因为也可以使用来实现函数使用效率不如递归方式的实现偏函数与柯里化实现柯里化辅助函数检查是否可以调用函数参数类型为内部模板函数尝试调用并返回如果可以被调用则返回内部模板函数如果无法调用则返回静态常量布尔值表示是否可以被调用通过调用函数来判断通用的柯里化函数返回一个函数该函数接受任意数量的参数如果可以被调用则直接调用并返回结果如果不能被调用则返回一个新的柯里化函数该函数将当前参数与后续参数一起传递给使用案例也可以直接使用有了通用的柯里化函数后就可以配合各种高阶函数如组合使用闭包在中闭包是一个能够捕获并存储其所在作用域中的变量的函数对象闭包主要通过引入的表达式来实现通过表达式提供了一种简洁且强大的方式来创建闭包这使得编写高阶函数和处理回调变得更加方便高阶函数是指接受一个或多个函数作为参数或返回一个函数作为结果的函数在函数式编程中高阶函数是一个核心概念但它同样适用于其他编程范式包括面向对象编程和过程式编程以下是高阶函数的一些特性和例子高阶函数的特性接受函数作为参数高阶函数可以接受一个或多个函数作为参数这使得它能够对传入的函数进行操作如在不同的上下文中调用它们返回函数作为结果高阶函数可以返回一个函数作为结果这样可以生成新的函数或延迟计算高阶函数在很多场景下非常有用例如回调函数在事件驱动编程中高阶函数可以用来注册和调用回调函数函数组合高阶函数可以用来组合多个函数使代码更加模块化和可重用装饰器在中装饰器是一种特殊的高阶函数用于修改或增强另一个函数的行为在中当按引用捕获一个局部变量并在该变量的作用域之外访问它时会导致未定义行为按引用捕获捕获了的引用但在返回后被销毁这里捕获的已经无效执行将导致未定义行为在这个例子中当返回时局部变量已经被销毁因此捕获的引用不再有效执行会导致未定义行为使用智能指针解决生命周期问题为了解决这个问题可以使用或来管理捕获的变量使其在需要时仍然有效按值传递捕获智能指针输出输出值得注意的是在中闭包不会产生类似于中按引用捕获局部变量在作用域之外执行导致未定义行为的问题的闭包捕获的是变量的引用且的垃圾回收机制会确保闭包中引用的变量在闭包存在期间不会被销毁如果希望在中实现类似闭包的效果在使用时不需要额外的括号我们可以通过返回一个对象来实现这个对象可以重载赋值运算符和类型转换运算符从而实现类似闭包的行为重载赋值运算符重载类型转换运算符使用来管理数据的生命周期创建闭包获取闭包修改外部数据输出修改闭包中的数据输出参考起步链接',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-01-26 22:28:52',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://th.bing.com/th/id/OIP.wtmjepfWPBvn26uz7s18dgHaHa?rs=1&amp;pid=ImgDetMain"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">ZEROKO14的个人博客</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size: 1.05rem;">C#<sup>2</sup></a><a href="/tags/C/" style="font-size: 1.05rem;">C++<sup>5</sup></a><a href="/tags/CSS/" style="font-size: 1.05rem;">CSS<sup>1</sup></a><a href="/tags/CSharp/" style="font-size: 1.05rem;">CSharp<sup>1</sup></a><a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 1.05rem;">C语言<sup>1</sup></a><a href="/tags/FPS/" style="font-size: 1.05rem;">FPS<sup>1</sup></a><a href="/tags/HTML/" style="font-size: 1.05rem;">HTML<sup>1</sup></a><a href="/tags/JavaScript/" style="font-size: 1.05rem;">JavaScript<sup>1</sup></a><a href="/tags/MFC/" style="font-size: 1.05rem;">MFC<sup>1</sup></a><a href="/tags/PE/" style="font-size: 1.05rem;">PE<sup>1</sup></a><a href="/tags/QT/" style="font-size: 1.05rem;">QT<sup>1</sup></a><a href="/tags/WPF/" style="font-size: 1.05rem;">WPF<sup>2</sup></a><a href="/tags/ai/" style="font-size: 1.05rem;">ai<sup>1</sup></a><a href="/tags/cmake/" style="font-size: 1.05rem;">cmake<sup>1</sup></a><a href="/tags/doxygen/" style="font-size: 1.05rem;">doxygen<sup>1</sup></a><a href="/tags/git/" style="font-size: 1.05rem;">git<sup>1</sup></a><a href="/tags/json/" style="font-size: 1.05rem;">json<sup>1</sup></a><a href="/tags/linux/" style="font-size: 1.05rem;">linux<sup>1</sup></a><a href="/tags/nas/" style="font-size: 1.05rem;">nas<sup>1</sup></a><a href="/tags/next/" style="font-size: 1.05rem;">next<sup>1</sup></a><a href="/tags/ppt/" style="font-size: 1.05rem;">ppt<sup>1</sup></a><a href="/tags/slidev/" style="font-size: 1.05rem;">slidev<sup>1</sup></a><a href="/tags/vue/" style="font-size: 1.05rem;">vue<sup>1</sup></a><a href="/tags/xml/" style="font-size: 1.05rem;">xml<sup>1</sup></a><a href="/tags/yaml/" style="font-size: 1.05rem;">yaml<sup>1</sup></a><a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 1.05rem;">代码规范<sup>1</sup></a><a href="/tags/%E5%86%85%E6%A0%B8/" style="font-size: 1.05rem;">内核<sup>2</sup></a><a href="/tags/%E5%86%85%E6%A0%B8%E7%9B%B8%E5%85%B3/" style="font-size: 1.05rem;">内核相关<sup>5</sup></a><a href="/tags/%E5%8A%A0%E8%A7%A3%E5%AF%86/" style="font-size: 1.05rem;">加解密<sup>1</sup></a><a href="/tags/%E5%9F%BA%E7%A1%80/" style="font-size: 1.05rem;">基础<sup>2</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 1.05rem;">多线程<sup>1</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F/" style="font-size: 1.05rem;">并发模式<sup>1</sup></a><a href="/tags/%E5%BC%80%E5%8F%91/" style="font-size: 1.05rem;">开发<sup>4</sup></a><a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 1.05rem;">数学<sup>1</sup></a><a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 1.05rem;">正则表达式<sup>1</sup></a><a href="/tags/%E7%9B%91%E6%8E%A7/" style="font-size: 1.05rem;">监控<sup>1</sup></a><a href="/tags/%E7%A1%AC%E7%BC%96%E7%A0%81/" style="font-size: 1.05rem;">硬编码<sup>1</sup></a><a href="/tags/%E7%AE%A1%E7%90%86/" style="font-size: 1.05rem;">管理<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 1.05rem;">网络<sup>3</sup></a><a href="/tags/%E9%80%86%E5%90%91/" style="font-size: 1.05rem;">逆向<sup>2</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/02/"><span class="card-archive-list-date">二月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/12/"><span class="card-archive-list-date">十二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/11/"><span class="card-archive-list-date">十一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/09/"><span class="card-archive-list-date">九月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">七月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">14</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/06/"><span class="card-archive-list-date">六月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/04/"><span class="card-archive-list-date">四月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">十一月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">27</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url">技术</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/C/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>C++</span></a></span></div></div><h1 class="post-title" itemprop="name headline">C++11与14</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-11-28T12:18:36.720Z" title="发表于 2023-11-28 20:18:36">2023-11-28</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-01-26T14:28:52.895Z" title="更新于 2025-01-26 22:28:52">2025-01-26</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="C++11与14"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为新加坡"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>新加坡</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://che77a38.github.io/posts/C++11%E4%B8%8E14/"><header><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url">技术</a><a href="/tags/C/" tabindex="-1" itemprop="url">C++</a><h1 id="CrawlerTitle" itemprop="name headline">C++11与14</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">ZEROKO14</span><time itemprop="dateCreated datePublished" datetime="2023-11-28T12:18:36.720Z" title="发表于 2023-11-28 20:18:36">2023-11-28</time><time itemprop="dateCreated datePublished" datetime="2025-01-26T14:28:52.895Z" title="更新于 2025-01-26 22:28:52">2025-01-26</time></header><p>C++11到C++20的新特性解析</p>
<span id="more"></span>

<p><a target="_blank" rel="noopener" href="https://i.baiy.cn/mobile/index.html">c++11特性可以参考</a></p>
<h1 id="C-标准介绍"><a href="#C-标准介绍" class="headerlink" title="C++标准介绍"></a>C++标准介绍</h1><p>优秀的c++知识库:<a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5">cppreference</a></p>
<p>C++标准演化</p>
<ul>
<li><strong>C++98(1.0)</strong>    正式版本</li>
<li>C++03(TR1)</li>
<li><strong>C++11(2.0)</strong>   正式版本</li>
<li>C++14</li>
<li>C++17</li>
<li>C++20</li>
<li>C++23</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/compiler_support/11">编译器对C++11的支持情况</a></p>
<p>两个层面的新特性</p>
<ul>
<li>语言<ul>
<li>Variadic Templates</li>
<li>move Semantics</li>
<li>auto</li>
<li>Range-base for loop</li>
<li>Initializer list</li>
<li>Lambdas</li>
<li>…</li>
</ul>
</li>
<li>标准库<ul>
<li>type_traits</li>
<li>unordered_set</li>
<li>forward_list</li>
<li>array</li>
<li>tuple</li>
<li>Con-currency</li>
<li>regex</li>
<li>thread</li>
<li>bitset</li>
<li>…</li>
</ul>
</li>
</ul>
<h2 id="确认支持C-标准"><a href="#确认支持C-标准" class="headerlink" title="确认支持C++标准"></a>确认支持C++标准</h2><p>程序内部由下面的宏标识C++标准</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __cplusplus 201103L</span></span><br><span class="line"><span class="comment">//C++98</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __cplusplus 199711L</span></span><br><span class="line"><span class="comment">//查询C++标准库</span></span><br><span class="line">cout&lt;&lt;__cplusplus&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<h1 id="各版本新增特性"><a href="#各版本新增特性" class="headerlink" title="各版本新增特性"></a>各版本新增特性</h1><h2 id="C-11"><a href="#C-11" class="headerlink" title="C++ 11"></a>C++ 11</h2><ul>
<li><a href="#auto%E5%85%B3%E9%94%AE%E5%AD%97">auto关键字</a></li>
<li><a href="#decltype">decltype关键字</a></li>
<li><a href="#nullptr">nullptr字面值</a></li>
<li><a href="#%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F">constexpr关键字</a></li>
<li><a href="#function%E7%B1%BB">function相关</a></li>
<li><a href="#%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84for%E5%BE%AA%E7%8E%AF">基于范围的for循环</a></li>
<li><a href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F">Lambda表达式</a></li>
<li><a href="#%E4%B8%80%E8%87%B4%E6%80%A7%E5%88%9D%E5%A7%8B%E5%8C%96">initializer_list</a></li>
<li><a href="#bind%E5%87%BD%E6%95%B0">标准库bind函数</a></li>
<li><a href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88">智能指针shared_ptr,unique_ptr</a></li>
<li><a href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8">右值引用&amp;&amp;</a></li>
<li>STL容器<code>std::array，std::forward_list，std::unordered_map，std::unordered_set</code></li>
</ul>
<h2 id="C-14"><a href="#C-14" class="headerlink" title="C++ 14"></a>C++ 14</h2><ul>
<li>拓展了lambda表达式，更加泛型：支持auto</li>
<li>拓展了类型推导至任意函数：C11只支持lambda返回类型的auto</li>
<li>弃用关键字 <code>[[deprecated]]</code></li>
</ul>
<h2 id="C-17"><a href="#C-17" class="headerlink" title="C++ 17"></a>C++ 17</h2><ul>
<li><p>拓展了constexpr至switch if等：C++11的constexpr函数只能包含一个表达式</p>
</li>
<li><p>typename 嵌套</p>
</li>
<li><p>inline 内联变量</p>
</li>
<li><p>模板参数推导</p>
</li>
<li><p>元组类 <code>std::tuple</code>：<code>std::pair</code>实现两个元素的组合，它实现多个</p>
</li>
<li><p>类模板<code>std::variant</code>表示一个类型安全的联合体。</p>
</li>
<li><p>引用包装器 std::reference_wrapper</p>
</li>
<li><p><a href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF">变长参数模板</a></p>
</li>
<li><p><a href="#%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A">结构化绑定（函数多值返回时用{}合成struct）</a></p>
</li>
<li><p>非类型模板参数可传入类的静态成员</p>
</li>
<li><p><a href="#%E6%94%AF%E6%8C%81%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AF%AD%E5%8F%A5%E7%9A%84if%E5%92%8Cswitch">在if和switch中可进行初始化</a></p>
</li>
<li><p>初始化（如struct）对象时，可用花括号进行对其成员进行赋值</p>
</li>
<li><p><a href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9B%B8%E5%85%B3">简化多层命名空间的写法</a></p>
</li>
<li><p>lambda表达式可捕获<code>*this</code>的值，但this及其成员为只读</p>
</li>
<li><p>十六进制的单精度浮点数</p>
</li>
<li><p>继承与改写构造函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> B1::B1;<span class="comment">//表示继承B1的构造函数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当模板参数为非类型时，可用auto自动推导类型</p>
</li>
<li><p>判断有没有包含某文件__has_include</p>
</li>
<li><p><code>[[fallthrough]]</code>用于switch语句块内，表示会执行下一个case或default</p>
</li>
<li><p><code>[[nodiscard]]</code>表示函数的返回值没有被接收，在编译时会出现警告。</p>
</li>
<li><p><code>[[maybe_unused]]</code>即便没使用也不警告</p>
</li>
</ul>
<h2 id="C-20"><a href="#C-20" class="headerlink" title="C++ 20"></a>C++ 20</h2><ul>
<li><p>concept用于声明具有特定约束条件的模板类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个数值类型的concept</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> number = std::is_arithmetic&lt;T&gt;::value;</span><br></pre></td></tr></table></figure>
</li>
<li><p>范围库（Ranges Library）</p>
</li>
<li><p><a href="#C++20%E5%8D%8F%E7%A8%8B">协程（Coroutines）</a></p>
</li>
<li><p>模块（modules）</p>
</li>
</ul>
<h1 id="新的基础类型"><a href="#新的基础类型" class="headerlink" title="新的基础类型"></a>新的基础类型</h1><h2 id="long-long类型"><a href="#long-long类型" class="headerlink" title="long long类型"></a>long long类型</h2><p>以及unsigned long long类型</p>
<p>先后在C99加入和C++11加入</p>
<p>由于编译器兼容C&#x2F;C++,因此C++11之前C99之后也能使用该类型</p>
<ul>
<li><p>引入新的字面量后缀(LL以及ULL)</p>
<p><strong>LL</strong>  : <code>long long x=2147483647LL+1</code>;(2147483647为$2^31-1$,int类型的最大值)</p>
<p>编译器对字面量默认以32位进行处理,上面例子中不写LL的话,值会变成-2147483648,因此需要编译器按照64位处理字面量则需要用到<code>LL</code>,此后结果为2147483648,恢复正常</p>
</li>
<li><p>判断最大值最小值</p>
<ul>
<li>最大值: <code>std::numeric_limits&lt;long long&gt;::max()</code></li>
<li>最小值: <code>std::numeric_limits&lt;long long&gt;::min()</code></li>
<li>针对unsigned long long是这样:<code>std::numeric_limits&lt;unsigned long long&gt;::max()</code></li>
</ul>
</li>
</ul>
<h2 id="新字符类型"><a href="#新字符类型" class="headerlink" title="新字符类型"></a>新字符类型</h2><h3 id="char16-t-char32-t"><a href="#char16-t-char32-t" class="headerlink" title="char16_t&#x2F;char32_t"></a>char16_t&#x2F;char32_t</h3><ul>
<li><code>char16_t</code>	对应UTF16   16位长度</li>
<li><code>char32_t</code>    对应UTF32   32位长度</li>
</ul>
<p><strong>字符串前缀</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char16_t</span> utf16c=<span class="string">u&#x27;好&#x27;</span>;</span><br><span class="line"><span class="type">char32_t</span> urf32c=<span class="string">u&#x27;好&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char16_t</span> utf16[]=<span class="string">u&quot;你好世界&quot;</span>;</span><br><span class="line"><span class="type">char32_t</span> utf32[]=<span class="string">u&quot;你好世界&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>还有两个特殊基础类型:<a href="#wchar_t">wchar_t</a>和<a href="#char8_t">char8_t</a></p>
<h4 id="u16string-u32string"><a href="#u16string-u32string" class="headerlink" title="u16string&#x2F;u32string"></a>u16string&#x2F;u32string</h4><p><code>std::u16string</code> 和 <code>std::u32string</code> 是 C++11 引入的用于存储 UTF-16 和 UTF-32 编码的字符串的类型</p>
<h3 id="wchar-t"><a href="#wchar-t" class="headerlink" title="wchar_t"></a>wchar_t</h3><p>windows编程常用字符类型,因为windows的API大部分都有这个wchar的版本</p>
<p>但是该类型不常用的,原因是对于跨平台不友好,在windows上和linux上的字符长度是不确定的</p>
<p>对应的字符串是wstring</p>
<h3 id="char8-t"><a href="#char8-t" class="headerlink" title="char8_t"></a>char8_t</h3><p>对应utf8</p>
<p>C++20引入的新类型</p>
<p>c++20之前使用char</p>
<p>对应的字符串类型为u8string</p>
<p><strong>字符串前缀</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++20之后的标准做法</span></span><br><span class="line"><span class="type">char8_t</span> c8a[]=<span class="string">u8&quot;test&quot;</span>;</span><br><span class="line"><span class="type">char8_t</span> c8=<span class="string">u8&#x27;c&#x27;</span>;</span><br><span class="line"><span class="comment">//C++17编译成功,C++20编译失败,需要char8_t</span></span><br><span class="line"><span class="type">char</span> c8a[]=<span class="string">u8&quot;test&quot;</span>;</span><br><span class="line"><span class="type">char</span> c8=<span class="string">u8&#x27;c&#x27;</span>;</span><br><span class="line"><span class="comment">//C++20编译失败,需要字符串前缀u8</span></span><br><span class="line"><span class="type">char8_t</span> c8a[]=<span class="string">&quot;test&quot;</span>;</span><br><span class="line"><span class="type">char8_t</span> c8=<span class="string">&#x27;c&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>在实际开发中，可以考虑使用现有的开源库，如 ICU（International Components for Unicode）库，它提供了丰富的 Unicode 支持，包括对不同编码的字符串操作。</p>
<p>[[字符编码#字符集转换|字符编码的转换参考此处]]</p>
<h1 id="函数封装与绑定"><a href="#函数封装与绑定" class="headerlink" title="函数封装与绑定"></a>函数封装与绑定</h1><p>STL标准库中提供了一些函数包装的模板,他们可以对函数或调用对象进行包装,方便在其他函数中调用</p>
<h2 id="function类"><a href="#function类" class="headerlink" title="function类"></a>function类</h2><p>头文件: <code>&lt;functional&gt;</code>中</p>
<blockquote>
<p>用于代替函数指针,并且远比函数指针强大,<strong>可以作为所有函数的接口</strong>,包括函数,函数对象,成员函数等所有一切函数</p>
</blockquote>
<p>定义如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">R</span>,<span class="keyword">class</span>... Args&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">function</span>&lt;<span class="built_in">R</span>(Args...)&gt;;</span><br></pre></td></tr></table></figure>

<p>使用案例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">multiply</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function&lt;<span class="type">double</span>(<span class="type">double</span>, <span class="type">double</span>)&gt; func1 = multiply;</span><br><span class="line"><span class="type">double</span> res = <span class="built_in">func1</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">std::cout &lt;&lt; res &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>function还可以用于封装类的成员函数,只需要<strong>第一个参数类型为类的引用</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线性函数类</span></span><br><span class="line"><span class="keyword">struct</span> Linear</span><br><span class="line">&#123;</span><br><span class="line">	Linear(<span class="built_in">float</span> k, <span class="built_in">float</span> b) : k_(k), b_(b) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="built_in">float</span> <span class="title">f</span>(<span class="params"><span class="built_in">float</span> x</span>)</span> &#123; <span class="keyword">return</span> k_ * x + b_; &#125;</span><br><span class="line">	<span class="built_in">float</span> k_;</span><br><span class="line">	<span class="built_in">float</span> b_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用function封装类的成员函数</span></span><br><span class="line">function&lt;<span class="built_in">float</span>(Linear &amp;, <span class="built_in">float</span>)&gt; func2 = &amp;Linear::f;</span><br><span class="line"><span class="function">Linear <span class="title">l</span>(<span class="params"><span class="number">1.2</span>, <span class="number">3.4</span></span>)</span>;</span><br><span class="line"><span class="built_in">float</span> res2 = func2(l, <span class="number">5</span>);</span><br><span class="line">cout &lt;&lt; res2 &lt;&lt; endl;<span class="comment">//6  9.4</span></span><br><span class="line"><span class="comment">//封装成员变量</span></span><br><span class="line">function&lt;<span class="built_in">float</span>(Linear &amp;)&gt; k = &amp;Linear::k_;</span><br><span class="line">std::cout &lt;&lt; k(l) &lt;&lt; std::endl;<span class="comment">//1.2</span></span><br></pre></td></tr></table></figure>

<p>function实现了一种叫做<strong>类型擦除的模式</strong>,即<strong>通过单个通用接口来使用各种具体的类型</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">add</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Substract</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">float</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b)</span> </span>&#123; <span class="keyword">return</span> a - b; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::map&lt;<span class="type">char</span>, function&lt;<span class="type">double</span>(<span class="type">double</span>, <span class="type">double</span>)&gt;&gt; calaulator&#123;</span><br><span class="line">		&#123;<span class="string">&#x27;+&#x27;</span>, add&#125;,</span><br><span class="line">		&#123;<span class="string">&#x27;-&#x27;</span>, <span class="built_in">Substract</span>()&#125;,</span><br><span class="line">		&#123;<span class="string">&#x27;*&#x27;</span>, [](<span class="type">double</span> a, <span class="type">double</span> b)</span><br><span class="line">		 &#123; <span class="keyword">return</span> a * b; &#125;&#125;&#125;;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; calaulator[<span class="string">&#x27;+&#x27;</span>](<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; endl;<span class="comment">//3</span></span><br><span class="line">	cout &lt;&lt; calaulator[<span class="string">&#x27;-&#x27;</span>](<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; endl;<span class="comment">//-1</span></span><br><span class="line">	cout &lt;&lt; calaulator[<span class="string">&#x27;*&#x27;</span>](<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; endl;<span class="comment">//2</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="mem-fn函数"><a href="#mem-fn函数" class="headerlink" title="mem_fn函数"></a>mem_fn函数</h2><p>如果是指向类成员,也可以使用mem_fn</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> M,<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="title">mem_fn</span><span class="params">(M T::* pm)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数是指向类成员的指针,返回值是一个可调用的包装器</p>
<p>例子:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">float</span> w;</span><br><span class="line">	<span class="function"><span class="type">float</span> <span class="title">calculate</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b)</span> </span>&#123; <span class="keyword">return</span> w * a + w * b; &#125;</span><br><span class="line">	Foo &amp;<span class="keyword">operator</span>+=(<span class="type">float</span> a)</span><br><span class="line">	&#123;</span><br><span class="line">		w += a;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;w=&quot;</span> &lt;&lt; w &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Foo f&#123;<span class="number">1.0</span>&#125;; <span class="comment">// 给w赋值为1</span></span><br><span class="line">	<span class="keyword">auto</span> memfn = <span class="built_in">mem_fn</span>(&amp;Foo::calculate);</span><br><span class="line">	<span class="type">float</span> res = <span class="built_in">memfn</span>(f, <span class="number">1.0</span>, <span class="number">2.0</span>); <span class="comment">// 调用foo的calculate方法，并传入1.0和2.0作为参数</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;res=&quot;</span> &lt;&lt; res &lt;&lt; endl;	<span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> op_add_assign = <span class="built_in">mem_fn</span>(&amp;Foo::<span class="keyword">operator</span>+=);</span><br><span class="line">	<span class="keyword">auto</span> f2 = <span class="built_in">op_add_assign</span>(f, <span class="number">1.0</span>); <span class="comment">// 调用operator+=方法，并传入1.0作为参数</span></span><br><span class="line">	f<span class="number">2.</span><span class="built_in">print</span>();<span class="comment">// 2</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h2><p>在C++中，<code>std::bind</code>函数是一个<strong>函数模板</strong>，用于创建函数对象（也称为函数符或函数器）。<code>std::bind</code>函数的主要作用是将一个可调用对象（函数、函数指针、成员函数、函数对象等）和其参数绑定在一起，形成一个新的可调用对象。这种绑定的过程可以延迟函数调用，允许我们在稍后的时间点调用这个函数对象，并传递参数。</p>
<p>定义:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F,<span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="title">bind</span><span class="params">(F&amp;&amp; f,Args&amp;&amp;... args)</span></span>;</span><br></pre></td></tr></table></figure>

<p>下面是<code>std::bind</code>函数的一般用法和示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printSum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum: &quot;</span> &lt;&lt; a + b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> func = std::<span class="built_in">bind</span>(printSum, <span class="number">10</span>, std::placeholders::_1);</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">20</span>); <span class="comment">// 实际上调用 printSum(10, 20)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::bind</code>函数将<code>printSum</code>函数和参数10、20绑定在一起，创建了一个新的函数对象<code>func</code>。通过调用<code>func()</code>，实际上会调用<code>printSum(10, 20)</code>函数。</p>
<p><code>std::bind</code>函数的一些特点和用法包括：</p>
<ul>
<li>可以绑定任意可调用对象，包括自由函数、成员函数、函数指针等。</li>
<li>可以绑定部分参数，即在创建函数对象时只传递部分参数，稍后再传递剩余的参数。</li>
<li>可以改变参数的顺序，通过占位符<code>std::placeholders::_1</code>、<code>std::placeholders::_2</code>等指定参数的位置。</li>
<li>返回的函数对象可以拷贝、移动和赋值，可以存储和延迟调用。</li>
</ul>
<p><code>std::bind</code>函数在C++11标准中引入，并位于<code>&lt;functional&gt;</code>头文件中。它是实现函数绑定和延迟调用的重要工具，可以简化代码并提高灵活性。</p>
<p><strong>也可以使用变量来传入</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = <span class="built_in">bind</span>(sum,<span class="number">1</span>,<span class="number">2</span>,n);<span class="comment">//这是值传入,调用f的时候,n的值为此代码执行时候的n值</span></span><br><span class="line"><span class="keyword">auto</span> f = <span class="built_in">bind</span>(sum,<span class="number">1</span>,<span class="number">2</span>,std::<span class="built_in">cref</span>(n));<span class="comment">//引用传入,调用f的时候,n的值是什么就是什么</span></span><br></pre></td></tr></table></figure>

<p><strong>实现原理</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简化版的 bind 实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Func, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">my_bind</span><span class="params">(Func func, Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [=](<span class="keyword">auto</span>... moreArgs) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">func</span>(args..., moreArgs...);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printSum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum: &quot;</span> &lt;&lt; a + b + c &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实际的<code>std::bind</code>函数会更加复杂，因为它支持更多的特性，如绑定成员函数、占位符、引用传递等。底层实现会涉及到更多的模板元编程技术，例如参数包展开、递归模板等。具体的实现细节可能会因不同的标准库而有所不同，但基本思想是相似的。</p>
<p>如果你对<code>std::bind</code>函数的底层实现原理感兴趣，可以查阅C++标准库实现的源代码，如GNU libstdc++或LLVM libc++等。这些源代码中会展示<code>std::bind</code>函数更复杂和完整的实现细节。</p>
</blockquote>
<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><p>C++11引入的针对string类型的转换函数如下:</p>
<ul>
<li><code>int std::stoi(const std::string&amp; str, size_t* pos = 0, int base = 10)</code>：将字符串转换为整数</li>
<li><code>long std::stol(const std::string&amp; str, size_t* pos = 0, int base = 10)</code>：将字符串转换为长整数</li>
<li><code>long long std::stoll(const std::string&amp; str, size_t* pos = 0, int base = 10)</code>：将字符串转换为长长整数</li>
<li><code>unsigned long std::stou(const std::string&amp; str, size_t* pos = 0, int base = 10)</code>：将字符串转换为无符号长整数</li>
<li><code>unsigned long long std::stoull(const std::string&amp; str, size_t* pos = 0, int base = 10)</code>：将字符串转换为无符号长长整数</li>
<li><code>float std::stof(const std::string&amp; str, size_t* pos = 0)</code>：将字符串转换为单精度浮点数</li>
<li><code>double std::stod(const std::string&amp; str, size_t* pos = 0)</code>：将字符串转换为双精度浮点数</li>
<li><code>long double std::stold(const std::string&amp; str, size_t* pos = 0)</code>：将字符串转换为长双精度浮点数</li>
</ul>
<h1 id="确定的表达式求值顺序"><a href="#确定的表达式求值顺序" class="headerlink" title="确定的表达式求值顺序"></a>确定的表达式求值顺序</h1><p> C++17才具体说明,此前由编译器确定</p>
<ul>
<li><p>函数表达式中的参数会在函数体内的语句执行之前被求值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">foo</span>(a,b,c);<span class="comment">//a,b,c都是表达式</span></span><br></pre></td></tr></table></figure>

<p>但是要注意函数的参数之间的顺序依然是不确定的</p>
</li>
<li><p>后缀表达式和移位运算符求值总是<strong>从左往右</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">E1[E2]</span><br><span class="line">E<span class="number">1.E2</span></span><br><span class="line">E<span class="number">1.</span>*E2</span><br><span class="line">E1-&gt;*E2</span><br><span class="line">E1&lt;&lt;E2</span><br><span class="line">E1&gt;&gt;E2</span><br></pre></td></tr></table></figure>
</li>
<li><p>赋值表达式求值总是<strong>从右往左</strong>的</p>
<p><code>= += -= *= /= 等等</code></p>
</li>
<li><p>new表达式的内存分配总是会优先于构造函数中参数的求值</p>
</li>
<li><p>重载运算符的表达式的求值顺序应由与之相应内置运算符的求值顺序确定</p>
</li>
</ul>
<h1 id="字面量优化"><a href="#字面量优化" class="headerlink" title="字面量优化"></a>字面量优化</h1><h2 id="十六进制浮点字面量"><a href="#十六进制浮点字面量" class="headerlink" title="十六进制浮点字面量"></a>十六进制浮点字面量</h2><p><code>hexfloat</code>和<code>defaultfloat</code></p>
<p>C++17引入</p>
<h2 id="二进制整数字面量"><a href="#二进制整数字面量" class="headerlink" title="二进制整数字面量"></a>二进制整数字面量</h2><p>C++14引入</p>
<p>前缀<code>0b</code>和<code>0B</code></p>
<h2 id="单引号作为整数分隔符"><a href="#单引号作为整数分隔符" class="headerlink" title="单引号作为整数分隔符"></a>单引号作为整数分隔符</h2><p>C++14引入,目的是让数字看起来比较好辨识  </p>
<p>单引号整数分隔符对于十进制,八进制,十六进制,二进制整数都是有效的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> x = <span class="number">123&#x27;456</span>;</span><br><span class="line"><span class="built_in">static_assert</span>(x==<span class="number">0x1e&#x27;240</span>);<span class="comment">//十六进制</span></span><br><span class="line"><span class="built_in">static_assert</span>(x==<span class="number">036&#x27;11&#x27;00</span>);<span class="comment">//八进制</span></span><br><span class="line"><span class="built_in">static_assert</span>(x==<span class="number">0b11&#x27;110&#x27;001&#x27;001&#x27;000&#x27;000</span>);<span class="comment">//二进制</span></span><br></pre></td></tr></table></figure>

<h2 id="原生字符串字面量"><a href="#原生字符串字面量" class="headerlink" title="原生字符串字面量"></a>原生字符串字面量</h2><p>C++11引入</p>
<p>这种字符串字面值使用<code>R&quot;()&quot;</code>的语法，<strong>允许在字符串中包含特殊字符而无需转义</strong>，方便处理包含大量转义字符的字符串。这种特性在处理正则表达式、文件路径等场景中非常有用。</p>
<blockquote>
<p>如果字符串中包含小括号和引号的组合，可能会导致编译器对原生字符串的解析出错。为了避免这种情况，可以在原始字符串字面值的开头和结尾添加自定义的定界符，以确保编译器能够正确解析字符串。这样即使字符串中包含小括号和引号的组合，编译器也能正确识别字符串的开始和结束。  语法为: <code>R&quot;自定义定界符()自定义定界符&quot;</code></p>
<p>以下是一个示例，演示如何在原始字符串字面值中使用自定义定界符来避免编译器解析错误：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* rawString = <span class="string">R&quot;###(This is a raw string with &quot;quotes&quot; and (parentheses))###&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; rawString &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出为:</span></span><br><span class="line"><span class="comment">//This is a raw string with &quot;quotes&quot; and (parentheses)</span></span><br></pre></td></tr></table></figure>

<p>上述代码中的<code>###</code>是自定义的,可以自己想写什么写什么</p>
</blockquote>
<h2 id="用户自定义字面量"><a href="#用户自定义字面量" class="headerlink" title="用户自定义字面量"></a>用户自定义字面量</h2><p>C++11引入</p>
<p>允许用户自定义字面量,只需要定义一个字面量运算符函数</p>
<p>基本语法:  <code>return_type operator&quot;&quot; identifier(params)</code></p>
<ul>
<li>双引号和identifier之间必须有空格,但改规则在C++14中被删除了</li>
<li>标准表示identifier应该以下划线<code>_</code>开始,把没有下划线的标识符保留给标准库使用</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="type">long</span> <span class="type">double</span> <span class="keyword">operator</span><span class="string">&quot;&quot;</span> _mm(<span class="type">long</span> <span class="type">double</span> x)&#123;<span class="keyword">return</span> x/<span class="number">1000</span>;&#125;;</span><br><span class="line"><span class="type">long</span> <span class="type">double</span> <span class="keyword">operator</span><span class="string">&quot;&quot;</span> _m(<span class="type">long</span> <span class="type">double</span> x)&#123;<span class="keyword">return</span> x;&#125;;</span><br><span class="line"><span class="type">long</span> <span class="type">double</span> <span class="keyword">operator</span><span class="string">&quot;&quot;</span> _km(<span class="type">long</span> <span class="type">double</span> x)&#123;<span class="keyword">return</span> x*<span class="number">1000</span>;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout&lt;&lt;<span class="number">1.0</span>_mm&lt;&lt;endl;</span><br><span class="line">  cout&lt;&lt;<span class="number">1.0</span>_m&lt;&lt;endl;</span><br><span class="line">  cout&lt;&lt;<span class="number">1.0</span>_km&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//0.001</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//1000</span></span><br></pre></td></tr></table></figure>

<p>字面量函数运算符的参数规则:</p>
<ul>
<li>整形    <code>unsigned long long/const char*</code> 或者没有参数,直接拿实参作为字面量</li>
<li>浮点    <code>long double/const char*</code>或者没有参数,直接拿实参作为字面量</li>
<li>字符串   <code>const char*</code></li>
<li>字符     <code>char</code></li>
</ul>
<h1 id="数据对齐相关"><a href="#数据对齐相关" class="headerlink" title="数据对齐相关"></a>数据对齐相关</h1><p><code>alignas</code>和<code>alignof</code></p>
<blockquote>
<p>首先需要先了解一下不可忽视的数据对齐问题   [[C语言入门#结构体字节对齐|结构体字节对齐(有关于设置结构体字节对齐长度的方式)]]</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202403111353056.png" alt="image-20240311135314575" style="zoom: 67%;" />

<p>内存对齐的原因是因为硬件需要,首当其冲的就是cpu.我们的cpu对数据对齐有迫切的需要(提高性能),通常来说好的数据对齐长度和cpu访问数据总线的宽度有关系.比如cpu访问32位的数据总线,就会期待数据是按照32位对齐的.另外,对于数据对齐引发错误的情况,通常发生在arm架构上(arm架构对数据对齐更严格).除了cpu外,还有其他硬件也需求硬件对齐,比如通过DMA访问硬盘,就会要求数据必须是4k对齐的</p>
</blockquote>
<h2 id="alignof运算符"><a href="#alignof运算符" class="headerlink" title="alignof运算符"></a>alignof运算符</h2><p>用于获取<strong>类型</strong>的对齐长度(不能用于对象)</p>
<blockquote>
<p>先看看C++11之前有一些通过宏来获取类型的对齐长度(C++11之后也能用),各大厂商编译器提供了获取<strong>类型或对象</strong>对齐长度的函数,如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MSVC </span></span><br><span class="line"><span class="keyword">auto</span> x1=__alignof(<span class="type">int</span>);</span><br><span class="line"><span class="keyword">auto</span> x2=__alignof(<span class="built_in">void</span>(*)());</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">cout&lt;&lt;__alignof(a)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//GCC</span></span><br><span class="line"><span class="keyword">auto</span> x3=__alignof__(<span class="type">int</span>);</span><br><span class="line"><span class="keyword">auto</span> x4=__alignof__(<span class="built_in">void</span>(*)());</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">cout&lt;&lt;__alignof__(a)&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>因此C++11标准引入alignof统一了用法</p>
</blockquote>
<p><strong>使用案例</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x1=<span class="built_in">alignof</span>(<span class="type">int</span>);</span><br><span class="line"><span class="keyword">auto</span> x2=<span class="built_in">alignof</span>(<span class="built_in">void</span>(*)());</span><br></pre></td></tr></table></figure>

<p>注意:<strong><code>alignof</code>只能处理类型,不能处理对象</strong>,即使使用decltype获得类型也不准确,因为使用<strong>decltype获取的类型是默认对齐长度的类型</strong>.因此这种情况还是需要使用编译器厂商提供的方法</p>
<h2 id="alignas说明符"><a href="#alignas说明符" class="headerlink" title="alignas说明符"></a>alignas说明符</h2><p>用于设置<strong>类型或者常量表达式</strong>的对齐长度</p>
<blockquote>
<p>先看看C++11之前各大编译器提供的设置对齐长度的方法(C++11之后也能用),例如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MSVC</span></span><br><span class="line"><span class="type">short</span> x1;</span><br><span class="line">__declspec(<span class="built_in">align</span>(<span class="number">8</span>)) <span class="type">short</span> x2;</span><br><span class="line">cout&lt;&lt;__alignof(x1)&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;__alignof(x2)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//GCC</span></span><br><span class="line"><span class="type">short</span> x3;</span><br><span class="line">__attribute__((<span class="built_in">aligned</span>(<span class="number">8</span>))) <span class="type">short</span> x4;</span><br><span class="line">cout&lt;&lt;__alignof(x3)&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;__alignof(x4)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出均为:</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//8</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>规则:</p>
<ul>
<li>如果将alignas用于结构体,该结构体整体就会以该数值来对齐结构体</li>
<li>如果修改结构体成员的对齐长度,那么结构体整体的对齐长度也会发生变化,因为结构体整体的对齐长度总是大于或等于他最大的成员的对齐长度</li>
</ul>
<p><strong>使用案例</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结构体大小: 16   结构体对齐长度: 8</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span>&#123;</span><br><span class="line">	<span class="type">char</span> a1;<span class="comment">//1</span></span><br><span class="line">  <span class="type">int</span> a2;<span class="comment">//4</span></span><br><span class="line">  <span class="comment">//3</span></span><br><span class="line">  <span class="type">double</span> a3;<span class="comment">//8</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体大小: 32   结构体对齐长度: 16</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X1</span>&#123;</span><br><span class="line">	<span class="built_in">alignas</span>(<span class="number">16</span>) <span class="type">char</span> a1;<span class="comment">//16</span></span><br><span class="line">  <span class="built_in">alignas</span>(<span class="type">double</span>) <span class="type">int</span> a2;<span class="comment">//8</span></span><br><span class="line">  <span class="type">double</span> a3;<span class="comment">//8</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体大小: 16   结构体对齐长度: 16</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">16</span>) X2&#123;</span><br><span class="line">	<span class="type">char</span> a1;<span class="comment">//1</span></span><br><span class="line">  <span class="type">int</span> a2;<span class="comment">//4</span></span><br><span class="line">  <span class="comment">//3</span></span><br><span class="line">  <span class="type">double</span> a3;<span class="comment">//8</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体大小: 32   结构体对齐长度: 16</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">16</span>) X3&#123;</span><br><span class="line">  <span class="built_in">alignas</span>(<span class="number">8</span>) <span class="type">char</span> a1;<span class="comment">//8</span></span><br><span class="line">  <span class="built_in">alignas</span>(<span class="type">double</span>) <span class="type">int</span> a2;<span class="comment">//8</span></span><br><span class="line">  <span class="type">double</span> a3;<span class="comment">//8</span></span><br><span class="line">  <span class="comment">//8</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译错误</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">4</span>) X4&#123;<span class="comment">//对齐不能设置为小于默认对齐</span></span><br><span class="line">  <span class="built_in">alignas</span>(<span class="number">8</span>) <span class="type">char</span> a1;</span><br><span class="line">  <span class="built_in">alignas</span>(<span class="type">double</span>) <span class="type">int</span> a2;</span><br><span class="line">  <span class="type">double</span> a3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标准库也提供了一些方法</p>
<h2 id="其他关于对齐字节长度的支持"><a href="#其他关于对齐字节长度的支持" class="headerlink" title="其他关于对齐字节长度的支持"></a>其他关于对齐字节长度的支持</h2><p>C++11引入</p>
<ul>
<li><p><code>alignment_of</code></p>
<p>获取类型的对齐字节长度</p>
</li>
<li><p><code>aligned_storage</code></p>
<p>分配一块指定对齐字节长度和大小的内存</p>
</li>
<li><p><code>aligned_union</code></p>
<p>获取参数类型中对齐字节长度最严格的(对齐字节数最大)作为分配内存的对齐字节长度</p>
</li>
</ul>
<h2 id="使用new分配指定对齐长度的对象"><a href="#使用new分配指定对齐长度的对象" class="headerlink" title="使用new分配指定对齐长度的对象"></a>使用new分配指定对齐长度的对象</h2><p>C++17支持new分配指定对齐长度的对象</p>
<p>new运算符接受一个<code>align_val_t</code>类型的参数来获得分配对象需要的对齐字节长度</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//new运算符的声明发生了变化</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span>,<span class="type">align_val_t</span>)</span></span>;</span><br><span class="line"><span class="type">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span>,<span class="type">align_val_t</span>);</span><br><span class="line"><span class="comment">//align_val_t是由编译器自动填充的,程序员不需要关心</span></span><br></pre></td></tr></table></figure>

<h1 id="属性说明符和标准属性"><a href="#属性说明符和标准属性" class="headerlink" title="属性说明符和标准属性"></a>属性说明符和标准属性</h1><h2 id="属性说明符"><a href="#属性说明符" class="headerlink" title="属性说明符"></a>属性说明符</h2><p>C++11之前,GCC和MSVC提供的属性语法:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GCC</span></span><br><span class="line">__attribute__((attribute-list))</span><br><span class="line">  </span><br><span class="line"><span class="comment">//MSVC</span></span><br><span class="line">__declspec(attribute_list)</span><br></pre></td></tr></table></figure>

<p>C++11引入了属性说明符语法，C++17进一步扩展了这一特性</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本语法</span></span><br><span class="line">[[attr]] </span><br><span class="line">[[attr1,attr2,<span class="built_in">attr3</span>(args)]] <span class="comment">//需要多个属性时</span></span><br><span class="line">[[<span class="keyword">namespace</span>::<span class="built_in">attr</span>(args)]]<span class="comment">//指定命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//简易例子</span></span><br><span class="line">[[attr1]] <span class="keyword">class</span> </span><br><span class="line">[[attr2]] X &#123;<span class="type">int</span> i;&#125; </span><br><span class="line">a,b[[attr3]];</span><br></pre></td></tr></table></figure>

<p><strong>基本规则</strong></p>
<p>属性可以出现在整个声明之前,或者直接更在被声明的对象之后,组合起来的规则为:</p>
<p><strong>属性说明符总是声明位于其之前的对象,而在整个声明之前的属性,则会声明语句中所有声明的对象</strong></p>
<p>效果为: 若程序不符合属性要求,编译器将会发出警告</p>
<h2 id="使用using打开属性的命名空间"><a href="#使用using打开属性的命名空间" class="headerlink" title="使用using打开属性的命名空间"></a>使用using打开属性的命名空间</h2><p>C++17引入</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有命名空间的情况</span></span><br><span class="line">[[gnu::always_inline,gnu::hot,gnu::<span class="type">const</span>,nodiscard]] <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//或</span></span><br><span class="line">[[gnu::always_inline]][[gnu::hot]][[gnu::<span class="type">const</span>]][[nodiscard]] <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//使用using</span></span><br><span class="line">[[<span class="keyword">using</span> gnu:always_inline,hot,<span class="type">const</span>]][[nodiscard]] <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">f</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="标准属性"><a href="#标准属性" class="headerlink" title="标准属性"></a>标准属性</h2><ul>
<li><a href="#noreturn">noreturn</a>: 声明函数不会返回</li>
<li><a href="#carries_dependency">carries_dependency</a>: 允许跨函数传递内存依赖项</li>
<li><a href="#deprecated">deprecated</a>: 标记实体为弃用</li>
<li><a href="#fallthrough">fallthrough</a>: 在switch语句中提示编译器直落行为是故意的</li>
<li><a href="#nodiscard">nodiscard</a>: 声明函数的返回值不应该被舍弃</li>
<li><a href="#maybe_unused">maybe_unused</a>: 声明实体可能不会被使用</li>
<li><a href="#likely/unlikely">likely&#x2F;unlikely</a>: 表示某条路径更加有可能或没可能，用于优化,通常用于switch语句</li>
<li><a href="#no_unique_address">no_unique_address</a>: 指示数据成员不需要唯一地址</li>
<li>等等</li>
</ul>
<h3 id="noreturn"><a href="#noreturn" class="headerlink" title="noreturn"></a>noreturn</h3><p>声明函数不会返回</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[noreturn]] <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="carries-dependency"><a href="#carries-dependency" class="headerlink" title="carries_dependency"></a>carries_dependency</h3><p>允许跨函数传递内存依赖项,它通常用于弱内存顺序架构平台上多线程程序优化,避免编译器生成不必要的内存栅栏指令</p>
<p>powerPC微处理器架构属于弱内存顺序架构平台,Intel和amd的x86和x64处理器系列不属于</p>
<h3 id="deprecated"><a href="#deprecated" class="headerlink" title="deprecated"></a>deprecated</h3><p>带有此属性实体被声明为<strong>弃用</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[deprecated]] <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> [[deprecated]] X&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>如果使用弃用的实体,编译会给出系统警告: <code>deprecated(&quot;xxx was deprecated&quot;)</code></p>
<h3 id="fallthrough"><a href="#fallthrough" class="headerlink" title="fallthrough"></a>fallthrough</h3><p>C++17中引入:在switch语句的上下文中提示编译器直落行为是故意的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(a)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      <span class="built_in">bar</span>();</span><br><span class="line">      [[fallthrough]];</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      <span class="built_in">bar</span>();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="nodiscard"><a href="#nodiscard" class="headerlink" title="nodiscard"></a>nodiscard</h3><p>声明函数的返回值不应该被舍弃</p>
<p>可以声明在函数或类或枚举类型上,但是声明到类或枚举类型上时只有被当成函数的返回值时才会生效</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> [[nodiscar]] X&#123;&#125;;</span><br><span class="line">[[nodiscard]] <span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line"><span class="function">x <span class="title">bar</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">X</span>();&#125;;<span class="comment">//使用该函数时如果不处理返回值将被警告</span></span><br></pre></td></tr></table></figure>

<h3 id="maybe-unused"><a href="#maybe-unused" class="headerlink" title="maybe_unused"></a>maybe_unused</h3><p>C++17引入,声明实体可能不会被使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> a[[maybe_unused]],<span class="type">int</span> b[[maybe_unused]])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="likely-unlikely"><a href="#likely-unlikely" class="headerlink" title="likely&#x2F;unlikely"></a>likely&#x2F;unlikely</h3><p>C++20引入的,通常用于switch语句中,表示某条路径更加有可能或没可能让编译器可以进行优化</p>
<ul>
<li>声明在标签或语句上</li>
<li>likely属性允许编译器对该属性所在的执行路径相对于其他执行路径更可能的进行优化</li>
<li>unlikely允许编译器对该属性所在的执行路径相对于其他执行路径更不可能的进行优化</li>
</ul>
<h3 id="no-unique-address"><a href="#no-unique-address" class="headerlink" title="no_unique_address"></a>no_unique_address</h3><p>C++20引入,指示编译器该数据成员不需要唯一地址</p>
<p>通常用于数据成员类型只有成员函数,没有成员变量的类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Empty</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span>&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  [[no_unique_address]] Empty e;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">X x;</span><br><span class="line">cout&lt;&lt;<span class="built_in">sizeof</span>(x)&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&amp;((X*)<span class="number">0</span>)-&gt;i&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&amp;((X*)<span class="number">0</span>)-&gt;e&lt;&lt;endl;</span><br><span class="line"><span class="comment">//不加[[no_unique_address]]结果为:</span></span><br><span class="line"><span class="comment">//8</span></span><br><span class="line"><span class="comment">//0</span></span><br><span class="line"><span class="comment">//4</span></span><br><span class="line"><span class="comment">//加[[no_unique_address]]结果为:</span></span><br><span class="line"><span class="comment">//4</span></span><br><span class="line"><span class="comment">//0</span></span><br><span class="line"><span class="comment">//0</span></span><br></pre></td></tr></table></figure>

<h1 id="新增预处理器功能和宏"><a href="#新增预处理器功能和宏" class="headerlink" title="新增预处理器功能和宏"></a>新增预处理器功能和宏</h1><h2 id="头文件可用宏"><a href="#头文件可用宏" class="headerlink" title="头文件可用宏"></a>头文件可用宏</h2><p><code>__has_include(&lt;头文件&gt;)</code></p>
<p>判断某个头文件是否能被包含进来(注意他不关心头文件是否已经被导入)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> __has_include(<span class="string">&lt;optional&gt;</span>)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;optional&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> have_optional 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __has_include(<span class="string">&lt;experimental/optional&gt;</span>)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;experimental/optional&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> have_optional 1</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> experimental_optional 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> have_optional 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="特性测试宏"><a href="#特性测试宏" class="headerlink" title="特性测试宏"></a>特性测试宏</h2><p>对于代码库的作者,因为有了特性测试宏,可以根据客户端开发环境适配不同的代码功能,让自己的代码库能更高效的使用在更多的环境上</p>
<h3 id="属性测试运算宏"><a href="#属性测试运算宏" class="headerlink" title="属性测试运算宏"></a>属性测试运算宏</h3><p><code>__has_cpp_attribute(属性);</code></p>
<p>指示编译器是否支持某种属性,该属性可以是标准属性,也可以是编译器特有的属性,前者展开为属性添加进标准的年份与月份,后者展开为非零值</p>
<h3 id="语言功能特性测试宏"><a href="#语言功能特性测试宏" class="headerlink" title="语言功能特性测试宏"></a>语言功能特性测试宏</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202403111740054.png" alt="image-20240311174001059" style="zoom:67%;" />

<p>如果支持,将展开为引入特性的年月</p>
<h3 id="标准库功能特性测试宏"><a href="#标准库功能特性测试宏" class="headerlink" title="标准库功能特性测试宏"></a>标准库功能特性测试宏</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202403111741969.png" alt="image-20240311174123807" style="zoom:67%;" />

<h2 id="参数不为空宏"><a href="#参数不为空宏" class="headerlink" title="参数不为空宏"></a>参数不为空宏</h2><p><code>__VA_OPT__</code></p>
<p>c+20引入</p>
<p>可变参数不为空时才展开</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可变参数宏的问题:打印案例</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(msg, ...) printf(<span class="string">&quot;[&quot;</span> __FILE__ <span class="string">&quot;:%d]&quot;</span> msg,__LINE__,__VA_ARGS__)</span></span><br><span class="line"><span class="built_in">LOG</span>(<span class="string">&quot;Hello 2020&quot;</span>);</span><br><span class="line"><span class="comment">//展开后有问题,多了一个逗号</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[&quot;</span> __FILE__ <span class="string">&quot;:%d]&quot;</span> <span class="string">&quot;Hello 2020&quot;</span>,__LINE__,);</span><br><span class="line"></span><br><span class="line"><span class="comment">//可变参数不为空时才展开__VA_OPT__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(msg, ...) printf(<span class="string">&quot;[&quot;</span> __FILE__ <span class="string">&quot;:%d]&quot;</span> msg,__LINE__ __VA_OPT__(,) __VA_ARGS__)</span></span><br></pre></td></tr></table></figure>

<h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><h2 id="协程的理解"><a href="#协程的理解" class="headerlink" title="协程的理解"></a>协程的理解</h2><p>协程是一种<strong>可以被挂起和恢复的函数</strong>,它提供了一种创建异步代码的方法</p>
<p>如今协程已经成为大多数语言的标配,尽管名称可能不同,但它们都可以被划分为两大类</p>
<ul>
<li><p>有栈(stackful)协程     可以任意嵌套函数中被挂起</p>
<p>每一个协程都会有自己的调用栈（一般的协程使用栈内存来存储数据）</p>
</li>
<li><p>无栈(stackless)协程,如async&#x2F;await以及C++20中的协程     不可以任意嵌套函数中被挂起</p>
<p>无栈协程不具备数据栈</p>
</li>
</ul>
<p>此处<strong>「有栈」</strong>和<strong>「无栈」</strong>的含义不是指协程在运行时是否需要栈，对于大多数语言来说，一个函数调用另一个函数，总是存在调用栈的；而是指协程是否可以在其<strong>任意</strong>嵌套函数中被挂起，此处的嵌套函数读者可以理解为子函数、匿名函数等。显然有栈协程是可以的，而无栈协程则不可以.这也决定了有栈协程被挂起时的自由度要比无栈协程高</p>
<blockquote>
<p>协程的目的:一份不需要将生产者或是消费者重写为状态机就可以移植的代码,一个隐式的状态机</p>
</blockquote>
<h3 id="有栈协程"><a href="#有栈协程" class="headerlink" title="有栈协程"></a>有栈协程</h3><p>有栈协程是可以在其任意嵌套函数中被挂起的</p>
<p>实现一个协程的关键点在于如何保存、恢复和切换上下文。已知函数运行在调用栈上；如果将一个函数作为协程，我们很自然地联想到，保存上下文即是保存从这个函数及其嵌套函数的（连续的）栈帧存储的值，以及此时寄存器存储的值；恢复上下文即是将这些值分别重新写入对应的栈帧和寄存器；而切换上下文无非是保存当前正在运行的函数的上下文，恢复下一个将要运行的函数的上下文。有栈协程便是这种朴素思想下的产物。</p>
<p>切换上下文无非是保存当前正在运行的函数的上下文，恢复下一个将要运行的函数的上下文。于是我们可以基于上述两段汇编构造一个<code>void swap_ctx(char **current, char **next)</code>函数，分别传入<code>char **init_ctx(char *func)</code>构造好的上下文即可实现切换。为了方便使用，我们可以将<code>swap_ctx()</code>封装成<code>yield()</code>函数，在这个函数里简单实现了不同函数的调度逻辑。于是一个简单的例子便完成了   <a target="_blank" rel="noopener" href="https://github.com/mthli/blog/tree/master/content/blog/stackful-stackless">相关代码可以参考此处</a></p>
<p>有栈协程则是通过切换整个栈帧来实现上下文切换。<strong>每个协程都有自己独立的栈空间</strong>，允许它们在任何地方挂起和恢复执行。这些协程可以自由地执行递归或其他复杂的控制流。</p>
<p>[[进程与线程#模拟线程切换|曾经写过一段这样原理的代码用于通过单线程模拟多线程实际上就是有栈协程,相关部分可以参考此处]]</p>
<h3 id="无栈协程"><a href="#无栈协程" class="headerlink" title="无栈协程"></a>无栈协程</h3><p>相比于有栈协程直接切换栈帧的思路，无栈协程在不改变函数调用栈的情况下，采用类似生成器（generator）的思路实现了上下文切换</p>
<blockquote>
<p>无栈协程（如基于生成器的实现）则不使用独立的栈空间，而是利用生成器的特性来实现上下文切换。无栈协程的基本思路是将函数的状态（如局部变量和执行位置）保存在生成器的内部状态中，而不是在栈帧中。这样，切换协程时只需保存和恢复生成器的状态，而不需要处理复杂的栈帧结构。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://mthli.xyz/coroutines-in-c/">无栈协程的一种实现,虽然有多线程以及可读性等诸多问题,但确实是无栈协程</a></p>
<p>有栈协程被挂起时的自由度要比无栈协程高,有栈协程在兼容现有的同步代码时异常方便；而无栈协程的兼容性基本为零,总不可能给所有同步代码都加上 async&#x2F;await 吧</p>
<blockquote>
<p><strong>无栈协程原理</strong></p>
<p>无栈协程其实现原理是将执行的方法编译为一个状态机，实现的时候不需要在临时栈和系统栈直接拷贝现场。因此无栈协程的效率和占用的资源更少。当然，有栈协程的代码会更加的简单易读。</p>
</blockquote>
<h2 id="C-20协程"><a href="#C-20协程" class="headerlink" title="C++20协程"></a>C++20协程</h2><p>协程(Coroutines)就是一个可以挂起执行，稍后再恢复执行的函数。只要一个函数包含 <code>co_await</code>、<code>co_yield</code> 或 <code>co_return</code> 关键字，则它就是协程。</p>
<p>协程是函数的泛化，协程允许函数被暂停（suspended），并在之后恢复（resumed）执行。</p>
<p>C++20 引入的协程属于<a href="#%E6%97%A0%E6%A0%88%E5%8D%8F%E7%A8%8B">无栈协程（stackless coroutine）</a>。它们通过编译器的支持，使用状态机的方式在不改变函数调用栈的情况下进行协程切换。每个协程通过 co_await、co_yield 等关键字实现挂起和恢复，不会为每个协程分配独立的栈。</p>
<blockquote>
<p>C++20协程TS(Technical Specification技术规范)带给了我们什么:</p>
<ul>
<li>3个新的关键字：<code>co_await</code>、<code>co_yield</code>和<code>co_return</code></li>
<li>几个新的类型（在<code>std::experimental</code>命名空间中）：<ul>
<li><code>coroutine_handle&lt;P&gt;</code></li>
<li><code>coroutine_traits&lt;Ts...&gt;</code></li>
<li><code>suspend_always</code></li>
<li><code>suspend_never</code></li>
</ul>
</li>
<li>一个通用的机制，库的开发者可以用它和协程交互，并定制他们的行为。</li>
<li>一个语言设施，它使得编写异步代码更简单。</li>
</ul>
<p>C++协程TS提供的设施可以看作是一个用于协程的<em>低级汇编语言</em>。这些设施很难以安全的方式直接使用，它更倾向于给库的开发者，让他们可以编写出应用程序开发者可以安全使用的高级抽象。</p>
<p>协程TS没有定义<strong>协程的语义</strong>。它没有定义<strong>如何产生返回给调用者的值</strong>。它没有定义<strong>传递给<code>co_return</code>语句的返回值要做什么</strong>，以及<strong>如何处理传递出协程的异常</strong>。它没有定义<strong>协程应该在哪个线程上恢复</strong>。</p>
<p>协程TS定义了两种类型的接口：<strong>Promise</strong>接口和<strong>Awaitable</strong>接口。</p>
<p><strong>Promise</strong>接口规定了一些和协程自身行为相关的方法。库的开发者可以定制：当协程被调用时的行为，当协程返回时的行为（正常返回或未处理的异常），以及定制协程内任何<code>co_await</code>和<code>co_yield</code>表达式的行为。</p>
<p><strong>Awaitable</strong>接口规定了一些控制<code>co_await</code>表达式语义的方法。当一个值被<code>co_await</code>时，这部分代码将被翻译为一系列awaitable对象的方法，这使得可以规定：是否要暂停当前协程，在暂停协程后是否要执行一些逻辑，在协程恢复执行后是否要产生<code>co_await</code>表达式的结果。</p>
<ul>
<li>Promise 接口主要用于定制协程本身的行为，例如协程的调用、返回以及内部的 co_await 和 co_yield 表达式的行为。</li>
<li>Awaitable 接口主要用于控制 co_await 表达式的语义，包括决定是否暂停协程、在暂停后和恢复后的相关逻辑处理。</li>
</ul>
<p>它们共同作用于协程，以实现协程的各种功能和行为定制。</p>
</blockquote>
<ul>
<li>co_await: 提供暂停协程的能力,允许协程被恢复执行</li>
</ul>
<p>协程函数返回值的类型，必须是一个自定义类型，并且这个自定义类型需要按照一定的格式来定义</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43669941/article/details/122737510">可参考链接,有更充分的讲解,翻译版</a>   <a target="_blank" rel="noopener" href="https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await">原文版</a>  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;coroutine&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCoroutine</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 协程开始时，在协程的状态对象分配内存后，调用promise_type的构造函数</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">		T value;</span><br><span class="line">		<span class="comment">// 为协程的状态对象分配内存失败时</span></span><br><span class="line">		<span class="function"><span class="type">static</span> <span class="keyword">auto</span> <span class="title">get_return_object_on_allocation_failure</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> MyCoroutine&#123; <span class="literal">nullptr</span> &#125;; &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 构造成功后开始执行</span></span><br><span class="line">		<span class="function"><span class="keyword">auto</span> <span class="title">get_return_object</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> MyCoroutine&#123; handle::<span class="built_in">from_promise</span>(*<span class="keyword">this</span>) &#125;; &#125;</span><br><span class="line">		<span class="comment">// 在以上函数后执行</span></span><br><span class="line">		<span class="function"><span class="keyword">auto</span> <span class="title">initial_suspend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> std::suspend_always&#123;&#125;; &#125;</span><br><span class="line">		<span class="comment">// 协程结束前执行</span></span><br><span class="line">		<span class="function"><span class="keyword">auto</span> <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> std::suspend_always&#123;&#125;; &#125;</span><br><span class="line">		<span class="comment">// 出现未经处理的异常时执行</span></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> std::<span class="built_in">terminate</span>();&#125;</span><br><span class="line">		<span class="comment">// co_return 时执行，return_void跟return_value二选一</span></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">return_void</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">		<span class="comment">//int return_value(int result) &#123; this.result = reslut; &#125;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//co_yield时执行</span></span><br><span class="line">		<span class="function"><span class="keyword">auto</span> <span class="title">yield_value</span><span class="params">(T value )</span> </span>&#123;<span class="keyword">this</span>-&gt;value=value; <span class="keyword">return</span> std::suspend_always&#123;&#125;; &#125;</span><br><span class="line"></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">using</span> handle = std::coroutine_handle&lt;promise_type&gt;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	handle hCoroutine;</span><br><span class="line">	<span class="built_in">MyCoroutine</span>(handle handle) :<span class="built_in">hCoroutine</span>(handle) &#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//int result;</span></span><br><span class="line">	<span class="built_in">MyCoroutine</span>(MyCoroutine&amp;&amp; other)<span class="keyword">noexcept</span> :<span class="built_in">hCoroutine</span>(other.hCoroutine) &#123; other.hCoroutine = <span class="literal">nullptr</span>; &#125;</span><br><span class="line">	~<span class="built_in">MyCoroutine</span>() &#123; <span class="keyword">if</span> (hCoroutine) hCoroutine.<span class="built_in">destroy</span>(); &#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">MoveNext</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> hCoroutine &amp;&amp; (hCoroutine.<span class="built_in">resume</span>(), !hCoroutine.<span class="built_in">done</span>()); &#125;</span><br><span class="line">	<span class="function">T <span class="title">GetValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> hCoroutine.<span class="built_in">promise</span>().value; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">MyCoroutine&lt;<span class="type">int</span>&gt; <span class="title">task</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (a &lt;= <span class="number">10</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">co_yield</span> a;</span><br><span class="line">		a++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyCoroutine&lt;<span class="type">int</span>&gt; fun = <span class="built_in">task</span>();</span><br><span class="line">	<span class="keyword">while</span> (fun.<span class="built_in">MoveNext</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; fun.<span class="built_in">GetValue</span>()&lt;&lt;endl;</span><br><span class="line">			<span class="comment">//getchar();</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">9</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>coroutine_handle也暴露出多个接口，用于控制协程的行为、获取协程的状态，与promise_type不同的是，promise_type里的接口需要我们填写实现，promise_type里的接口是给编译器调用的。coroutine_handle的接口不需要我们填写实现，我们可以直接调用。</p>
<table>
<thead>
<tr>
<th>coroutine_handle接口</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>from_promise()</td>
<td>从promise对象创建一个coroutine_handle</td>
</tr>
<tr>
<td>done()</td>
<td>检查协程是否运行完毕</td>
</tr>
<tr>
<td>operator bool</td>
<td>检查当前句柄是否是一个coroutie</td>
</tr>
<tr>
<td>operator()</td>
<td>恢复协程的执行</td>
</tr>
<tr>
<td>resume</td>
<td>恢复协程的执行（同上）</td>
</tr>
<tr>
<td>destroy</td>
<td>销毁协程</td>
</tr>
<tr>
<td>promise</td>
<td>获取协程的promise对象</td>
</tr>
<tr>
<td>address</td>
<td>返回coroutine_handle的指针</td>
</tr>
<tr>
<td>from_address</td>
<td>从指针导入一个coroutine_handle</td>
</tr>
</tbody></table>
<p>基于MSVC的await编译选项进行讲解</p>
<ul>
<li>拓展了标准库,提供了一些辅助库</li>
</ul>
<p>下面代码使用了微软协程库的特性 co_await </p>
<h1 id="命名空间相关"><a href="#命名空间相关" class="headerlink" title="命名空间相关"></a>命名空间相关</h1><p>C++17引入内联命名空间与嵌套命名空间</p>
<h2 id="内联命名空间"><a href="#内联命名空间" class="headerlink" title="内联命名空间"></a>内联命名空间</h2><p>把子命名空间的元素导入到父命名空间中</p>
<p>注意: inline这个关键字不能用到第一层的命名空间中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Parent&#123;</span><br><span class="line">  <span class="keyword">namespace</span> Child1&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;Child1::foo()&quot;</span>&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="keyword">inline</span> <span class="keyword">namespace</span> Child2&#123;</span><br><span class="line">  		<span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123; cout&lt;&lt;<span class="string">&quot;Child2::foo()&quot;</span> &lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Parent::Child1::<span class="built_in">foo</span>();</span><br><span class="line">	Parent::<span class="built_in">foo</span>();<span class="comment">//调用的是Child2中的foo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>主要作用</strong> : <strong>方便库的开发者管理代码,升级代码后无缝地提供给使用者.<strong>当我们想去修改升级这个函数的时候,版本1换成版本2,最好的方式就是使用</strong>内联命名空间</strong>,本来inline是在版本1的namespace的,只需要将inline关键字转移到版本2的namespace上,则达成修改,其他代码无需修改,并且保留了原始版本代码</p>
</blockquote>
<h2 id="嵌套命名空间"><a href="#嵌套命名空间" class="headerlink" title="嵌套命名空间"></a>嵌套命名空间</h2><p>主要是用来<strong>减少命名空间带来的代码冗余</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A::B::C &#123;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span></span>&#123;<span class="keyword">return</span>  <span class="number">5</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这种方式是A嵌套的B嵌套的C命名空间中定义了一个foo函数</span></span><br></pre></td></tr></table></figure>

<h2 id="嵌套内联命名空间"><a href="#嵌套内联命名空间" class="headerlink" title="嵌套内联命名空间"></a>嵌套内联命名空间</h2><p><strong>C++20</strong>才支持</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A::B&#123;</span><br><span class="line">  <span class="keyword">inline</span>  <span class="keyword">namespace</span> C&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">5</span>;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">namespace</span> A::B::<span class="keyword">inline</span> C&#123;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">5</span>;&#125;s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="拓展的inline说明符"><a href="#拓展的inline说明符" class="headerlink" title="拓展的inline说明符"></a>拓展的inline说明符</h1><h2 id="内联变量"><a href="#内联变量" class="headerlink" title="内联变量"></a>内联变量</h2><p>C++17引入了内联变量</p>
<blockquote>
<p>在C++中，内联变量是指使用<code>inline</code>关键字声明的变量。使用<code>inline</code>关键字声明的变量会被视为内联变量，编译器会尝试将其直接嵌入到调用它的地方，而不是分配内存空间给该变量。这样可以减少函数调用的开销，提高程序的执行效率。需要注意的是，内联变量的定义必须在所有使用该变量的地方可见，否则会导致链接错误。</p>
</blockquote>
<p>[[C++基础#内联函数(inline function)|内联变量知识点跳转]]</p>
<p>除了<a href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9B%B8%E5%85%B3">内联命名空间与嵌套命名空间</a>中对inline的新拓展外,inline还拓展了用于定义非常量静态成员变量的用法</p>
<h2 id="内联非常量静态成员变量"><a href="#内联非常量静态成员变量" class="headerlink" title="内联非常量静态成员变量"></a>内联非常量静态成员变量</h2><p>非常量静态成员变量的问题:声明和定义必须分开,即定义必须在类外</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">static</span> string text;</span><br><span class="line">&#125;;</span><br><span class="line">string X::text&#123;<span class="string">&quot;hello&quot;</span>&#125;;<span class="comment">//定义在类外</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>常量静态数据成员可以一次性完成声明和定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> num&#123;<span class="number">5</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>从C++17开始标准引入了内联定义静态数据成员的方式:解决了C++中定义静态成员变量繁琐的问题</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本语法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  	<span class="keyword">inline</span> <span class="type">static</span> string text&#123;<span class="string">&quot;hello&quot;</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>即使将类X的定义作为头文件包含在多个源文件中也不会有任何问题</p>
<p>让编译器可以聪明的选择首次出现的变量进行定义和初始化,这种特性符合inline说明符提案文档中的一句话:inline说明符可以应用于变量和函数.声明为内联的变量和函数具有相同的语义,他们一方面可以在多个翻译单元中定义,另一方面又必须在每个使用他的翻译单元中定义,并且行为就像同一个变量</p>
</blockquote>
<h1 id="函数返回类型后置"><a href="#函数返回类型后置" class="headerlink" title="函数返回类型后置"></a>函数返回类型后置</h1><p>基本语法:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202402281631338.png" alt="image-20240228162952146"></p>
<p>一般用于推导函数模板返回类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">test</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>-&gt;<span class="type">int</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="默认实参"><a href="#默认实参" class="headerlink" title="默认实参"></a>默认实参</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/588948013">参考</a></p>
<ul>
<li>默认实参可以不写参数名</li>
<li>默认实参在声明中可传递(可能有点绕,看下面解释)</li>
<li><a href="%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF">形参包</a>前可以直接写默认实参</li>
<li></li>
</ul>
<p>C++11版本引入了函数的<strong>默认实参可以不写参数名</strong>的特性。<code>void f(int=3);</code></p>
<p>在函数声明中，所有在拥有默认实参的形参<strong>之后的形参</strong>必须拥有<strong>在这个或同一作用域中先前的声明中所提供的默认实参。你可能觉得很绕，其实说白了就是说，你可以给任何形参默认实参，但是，你需要在当前作用域提前给你已经声明了默认实参的形参后面的形参默认实参。比如:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span> = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>=<span class="number">6</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> = <span class="number">4</span>,<span class="type">int</span>,<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123; std::cout &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; b &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>();<span class="comment">//4 6 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除非该形参是从某个形参包展开得到的或是函数形参包,如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f_</span><span class="params">(<span class="type">int</span> n = <span class="number">6</span>, Args...args)</span> </span>&#123;<span class="comment">//没错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有很多点,略,详情点击<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/588948013">参考</a></p>
<h1 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h1><blockquote>
<p>C++11提出的一个非常重要的概念,它的出现不仅完善了C++的语法,改善了C++在数据转移时的执行效率(减少了非必要复制),同时还增强了c++的模板能力</p>
<p>c++11中对C++影响最深远的特性就是<strong>右值引用</strong></p>
</blockquote>
<p><strong>首先区分左值和右值</strong></p>
<ul>
<li>判断对象能否取地址  可以取地址的为左值,不可以取地址的为右值</li>
<li>所谓的左值一般是指一个指向特定内存具有名称的值(具名对象),它有一个相对稳定的内存地址,并且有一段较长的生命周期.而右值则是不指向稳定内存的地址匿名值(不具名对象),它的生命周期很短,通常都是暂时性的</li>
</ul>
<blockquote>
<p><strong>通俗理解</strong>：</p>
<ul>
<li><p><strong>左值就是“可以找到的东西”，可以重复使用和修改</strong></p>
</li>
<li><p><strong>右值就是“用完就丢的东西”，在表达式中一旦计算出来就没有持久性</strong></p>
<p>通常是表达式的结果</p>
</li>
</ul>
<p>在 C++ 中引入左值和右值的概念，主要是为了优化和区分<strong>对象的生命周期</strong>。比如，如果编译器知道某个对象是右值，它可以安全地将其移动或优化，而不用保留它的完整生命周期。</p>
</blockquote>
<p>简单区分:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">9</span>;</span><br><span class="line"><span class="type">int</span> b=<span class="number">4</span>;</span><br><span class="line">a+b=<span class="number">42</span>;<span class="comment">//[Error]</span></span><br><span class="line"><span class="comment">//此处的a+b为右值</span></span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">s2</span><span class="params">(<span class="string">&quot;World&quot;</span>)</span></span>;</span><br><span class="line">s1+s2=s2;<span class="comment">//竟然通过编译,但没什么意义</span></span><br><span class="line">cout&lt;&lt;s1&lt;&lt;endl;<span class="comment">//输出:Hello</span></span><br><span class="line">cout&lt;&lt;s2&lt;&lt;endl;<span class="comment">//输出:World</span></span><br><span class="line"><span class="built_in">string</span>()=<span class="string">&quot;World&quot;</span>;<span class="comment">//竟然可以对临时对象赋值,但没什么意义</span></span><br><span class="line"><span class="comment">//临时对象也是右值</span></span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原本对右值不能取reference</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">5</span>;&#125;</span><br><span class="line"><span class="type">int</span> *p=&amp;<span class="built_in">foo</span>();<span class="comment">//编译错误,可以理解为想取foo返回的东西的地址</span></span><br><span class="line"><span class="built_in">foo</span>()=<span class="number">7</span>;<span class="comment">//编译错误</span></span><br></pre></td></tr></table></figure>

<p>当右值出现于赋值运算符右侧时,我们认为对其资源进行偷取&#x2F;搬移(move),而非拷贝(copy)是合理的</p>
<p>因此</p>
<ol>
<li>必须有语法让我们在<strong>调用端</strong>告诉编译器,这是个右值</li>
<li>必须有语法让我们在<strong>被调用端</strong>写出一个专门处理右值的所谓移动构造函数</li>
</ol>
<p>于是乎,引入了<strong>右值引用</strong></p>
<h2 id="左值引用和右值引用"><a href="#左值引用和右值引用" class="headerlink" title="左值引用和右值引用"></a>左值引用和右值引用</h2><ul>
<li><p>常量左值引用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;x1 = <span class="number">7</span>;<span class="comment">//编译错误</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;x1 = <span class="number">11</span>;<span class="comment">//编译成功</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>右值引用语法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;&amp;k = <span class="number">11</span>; </span><br></pre></td></tr></table></figure></li>
</ul>
<p>右值引用引入了<a href="#%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89">移动语义</a></p>
<h3 id="值类别"><a href="#值类别" class="headerlink" title="值类别"></a>值类别</h3><ul>
<li><p>分为2种: 泛左值(glvalue)和右值(rvalue)</p>
<p>泛左值: 通过计算评估能够确定对象位域或函数的标识的表达式(简单理解就是具名对象)</p>
</li>
<li><p>分为3种: 左值,纯右值和将亡值</p>
<p>纯右值: 通过计算评估,能够用于初始化对象和位域或者能够计算运算符操作数的值的表达式(简单理解为是为了初始化其他对象的)</p>
<p>将亡值: 资源可以被重用的对象和位域,通常是因为它们接近生命周期的末尾,另外也有可能是经过右值引用的转换产生的</p>
</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202402282025472.png" alt="image-20240228202527981" style="zoom: 50%;" />

<ul>
<li>左值和将亡值统称为泛左值	</li>
<li>纯右值和将亡值统称为右值</li>
</ul>
<h3 id="左值转换为右值"><a href="#左值转换为右值" class="headerlink" title="左值转换为右值"></a>左值转换为右值</h3><h4 id="基本的转换方式"><a href="#基本的转换方式" class="headerlink" title="基本的转换方式"></a>基本的转换方式</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> &amp;&amp;k1=i;	<span class="comment">//编译失败</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;k2=<span class="keyword">static_cast</span>&lt;<span class="type">int</span>&amp;&amp;&gt;i;	<span class="comment">//编译成功</span></span><br></pre></td></tr></table></figure>

<h4 id="使用std-move"><a href="#使用std-move" class="headerlink" title="使用std::move"></a>使用std::move</h4><p><a href="#move%E5%87%BD%E6%95%B0">move函数详解</a>  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static_cast</span>&lt;remove_reference&lt;<span class="keyword">decltype</span>(arg)&gt;::type&amp;&amp;&gt;(arg)</span><br><span class="line">  <span class="comment">//与使用move函数效果一致</span></span><br><span class="line"><span class="built_in">move</span>(arg)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>remove_reference&lt;&gt;</code>：<code>remove_reference</code> 是一个模板元函数，是 C++11 标准引入的一个类型转换工具，位于 <code>&lt;type_traits&gt;</code> 头文件中,用于移除参数类型的引用修饰符。例如，如果 <code>arg</code> 的类型是 <code>int&amp;</code>，<code>remove_reference&lt;int&amp;&gt;::type</code> 将返回 <code>int</code></p>
</blockquote>
<h2 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h2><blockquote>
<p>当一个右值复制</p>
<p>拷贝构造的时候,若被拷贝对象是一个右值或者是一个临时对象的时候,原本的做法非常不聪明.更高效的做法是将马上要被销毁的临时对象的资源内容移动到目标对象中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">make_greeting</span><span class="params">(string &amp;&amp;name)</span> <span class="comment">// name说:&quot;请尽管移动我!&quot;</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string result = <span class="string">&quot;Hello, &quot;</span>;</span><br><span class="line">    result += std::<span class="built_in">move</span>(name);</span><br><span class="line">    <span class="comment">// 直接把name的内容&quot;偷&quot;过来</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    <span class="comment">// result也会被移动返回,超高效!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line">  string greeting = <span class="built_in">make_greeting</span>(std::<span class="built_in">move</span>(name));</span><br><span class="line">  cout &lt;&lt; greeting &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 现在原对象name变成&quot;空壳子&quot;,不能再使用它的值</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>右值引用的语法是</strong> <code>T&amp;&amp;</code>。右值引用允许我们获取对临时对象的引用，从而在<strong>不拷贝</strong>的情况下对它们进行操作</p>
<h3 id="move函数"><a href="#move函数" class="headerlink" title="move函数"></a>move函数</h3><p><code>std::move</code> 是一个函数，其主要目的是将<strong>任何类型的变量无条件地转化为右值</strong>。</p>
<ul>
<li><p>用于实现<strong>移动语义</strong>，减少不必要的拷贝开销和内存开销。</p>
</li>
<li><p>例如，将一个左值传入 <code>push_back</code> 时，可以使用 <code>std::move</code> 来实现真正的转移，避免额外的拷贝操作：</p>
</li>
<li><pre><code class="cpp">std::vector&lt;std::string&gt; vec;
std::string x = &quot;abcd&quot;;
vec.push_back(std::move(x));//用move可以理解为x的资源将被&quot;偷&quot;取
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">总之要注意:</span><br><span class="line"></span><br><span class="line">- 看到`T&amp;&amp;`参数,可以用`std::move`把它移走 ✅</span><br><span class="line">- 被移动后的对象不要再使用它的值 ❌</span><br><span class="line">- 如果对象后面还要用,就不要移动它 ⚠️</span><br><span class="line"></span><br><span class="line">move函数的原理</span><br><span class="line"></span><br><span class="line">&gt; 学习的时候,可以利用:`-fno-elide-constructors`是一个编译 选项，用于告诉编译器不要优化构造函数。通常情况下，编译器会尝试对构造函数进行优化，例如通过返回值优化（Return Value Optimization）来避免不必要的拷贝操作。使用该选项可以禁用这种优化，强制执行构造函数的拷贝操作。这在某些情况下可能有用，例如在调试时需要确保每次构造函数都被调用。</span><br><span class="line"></span><br><span class="line">通过观察发现:移动语义可以将函数中的局部变量返回出来,观察汇编代码会发现,实际上根本没有进入到函数内,而是在进入函数前就定义了局部变量.意思就是本应在最里层的局部变量定义到了外面,这样当然就可以返回了</span><br><span class="line"></span><br><span class="line">### 移动构造函数以及移动赋值运算符函数</span><br><span class="line"></span><br><span class="line">C++的类中因此新增的默认函数:</span><br><span class="line"></span><br><span class="line">&gt; 移动构造是一门既省内存又高效的绝学，但使用不当可能会导致&quot;走火入魔&quot;</span><br><span class="line">&gt;</span><br><span class="line">&gt; 使用场景</span><br><span class="line">&gt;</span><br><span class="line">&gt; 1. 当你的对象持有大量资源（内存、文件句柄等）</span><br><span class="line">&gt; 2. 当你知道源对象马上就要销毁时</span><br><span class="line">&gt; 3. 在容器操作中需要频繁移动对象时</span><br><span class="line"></span><br><span class="line">- 移动构造函数</span><br><span class="line"></span><br><span class="line">  注意：移动构造函数必须标记为 noexcept，这样STL容器才敢放心大胆地使用它</span><br><span class="line"></span><br><span class="line">- 移动赋值运算符函数</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">myClass(myClass&amp;&amp; other) noexcept&#123;&#125;//移动构造函数</span><br><span class="line">myClass&amp; operator=(const myClass&amp;&amp; other) noexcept&#123;&#125;//移动赋值运算符函数</span><br><span class="line">&#123;</span><br><span class="line">	//...</span><br><span class="line">  return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://godbolt.org/z/h3x8dnT17">可以参考这个链接查看汇编</a></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202403151551774.png" alt="image" style="zoom:50%;" /><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202403151540801.png" alt="image-20240315154008986" style="zoom: 50%;" /><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202403151540101.png" alt="image-20240315154047447" style="zoom:50%;" /></p>
<p>第一个图是浅拷贝流程,中间的图是原来的深拷贝流程,右图是移动流程,即<strong>偷</strong>(一个生动形象的动词,注意打断了原本对象和空间的联系)</p>
<p>加入了移动语义的类中,<strong>编译器隐式声明的特殊成员图</strong>一览:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202403201303881.png" alt="特殊成员函数"></p>
<p>规则总结:</p>
<ul>
<li>默认构造,析构,赋值拷贝,赋值移动,拷贝构造,拷贝移动默认都会自动由编译器生成</li>
<li><strong>用户定义了任何构造函数,则默认构造函数不会自动生成</strong></li>
<li>用户定义了拷贝构造和拷贝赋值函数或析构函数任一,则移动语义两个函数不会自动生成</li>
<li>用户定义了移动语义两个函数任一,则复制语义两个函数不会自动生成</li>
</ul>
<p><strong>非常重要的一点</strong>: 只要是使用了构造函数,即使是使用的移动构造函数,也会在该对象生命周期结束的时候,自动调用析构函数(根据调用的构造函数的次数来决定)</p>
<blockquote>
<p>一个使用移动构造函数的例子:(注意调用了两次析构函数)</p>
<p><strong>一个案例</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyObject</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyObject</span>() : <span class="built_in">data</span>(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Default Constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyObject</span>(<span class="type">int</span> value) : <span class="built_in">data</span>(<span class="keyword">new</span> <span class="built_in">int</span>(value)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Regular Constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">MyObject</span>(MyObject&amp;&amp; other)<span class="keyword">noexcept</span> : <span class="built_in">data</span>(other.data) &#123;</span><br><span class="line">        other.data = <span class="literal">nullptr</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Move Constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 移动赋值操作符</span></span><br><span class="line">    MyObject&amp; <span class="keyword">operator</span>=(MyObject&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="keyword">delete</span> data;</span><br><span class="line">            data = other.data;</span><br><span class="line">            other.data = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Move Assignment Operator&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    ~<span class="built_in">MyObject</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> data;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Destructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printData</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Data: &quot;</span> &lt;&lt; *data &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Data is null&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyObject <span class="title">obj1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    obj<span class="number">1.</span><span class="built_in">printData</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">MyObject <span class="title">obj2</span><span class="params">(std::move(obj1))</span></span>;  <span class="comment">// 使用std::move调用移动构造函数</span></span><br><span class="line">    obj<span class="number">2.</span><span class="built_in">printData</span>();</span><br><span class="line">    </span><br><span class="line">    obj<span class="number">1.</span><span class="built_in">printData</span>();  <span class="comment">// obj1的data现在为null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Regular Constructor</span></span><br><span class="line"><span class="comment">Data: 10</span></span><br><span class="line"><span class="comment">Move Constructor</span></span><br><span class="line"><span class="comment">Data: 10</span></span><br><span class="line"><span class="comment">Data is null</span></span><br><span class="line"><span class="comment">Destructor          &lt;--调用了两次析构函数</span></span><br><span class="line"><span class="comment">Destructor</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="万能引用"><a href="#万能引用" class="headerlink" title="万能引用"></a>万能引用</h2><p><strong>万能引用</strong>是针对<strong>模板</strong>而来的</p>
<p><strong>最大的目的是为了让你的函数中传入的参数可以左值也可以是右值</strong></p>
<p>常量左值引用既可以引用左值又可以引用右值,是一个几乎万能的引用,但可惜由于其常量性,导致它的使用范围收到一些限制.因此此处介绍的万能引用是真正意义上的”万能”的引用</p>
<p><a href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8">右值引用</a>  –模板-&gt;  万能引用:</p>
<ul>
<li><p>具体类型的&amp;&amp;符号表示右值引用</p>
</li>
<li><p>模板的&amp;&amp;符号表示<a href="#%E4%B8%87%E8%83%BD%E5%BC%95%E7%94%A8">万能引用</a></p>
</li>
</ul>
<blockquote>
<p>所谓的万能引用是因为发生了类型推导，在T&amp;&amp;和auto&amp;&amp;的初始化过程中都会发生类型的推导，如果已经有一个确定的类型，比如int &amp;&amp;，则是右值引用。在这个推导过程中，初始化的源对象如果是一个左值，则目标对象会推导出左值引用；反之如果源对象是一个右值，则会推导出右值引用，不过无论如何都会是一个引用类型。<br>万能引用能如此灵活地引用对象，实际上是因为在C++11中添加了一套引用叠加推导的规则——<a href="#%E4%B8%87%E8%83%BD%E5%BC%95%E7%94%A8%E7%9A%84%E8%A7%84%E5%88%99">引用折叠</a>。在这套规则中规定了在不同的引用类型互相作用的情况下应该如何推导出最终类型</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> &amp;&amp;i)</span></span>&#123;&#125;<span class="comment">//i为右值引用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(T &amp;&amp;t)</span></span>&#123;&#125;  <span class="comment">//t为万能引用</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> &amp;&amp;x=<span class="built_in">get_val</span>();<span class="comment">//x为右值引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> &amp;&amp;y=<span class="built_in">get_val</span>();<span class="comment">//y为万能引用</span></span><br></pre></td></tr></table></figure>

<p>万能引用既可以是一个左值引用,也可以是一个右值引用,这个能力是通过模板形参的推导完成的</p>
<p>万能引用最重要的一个应用是<a href="#%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91">完美转发</a></p>
<h3 id="万能引用的规则"><a href="#万能引用的规则" class="headerlink" title="万能引用的规则"></a>万能引用的规则</h3><p>万能引用使用了一套叫做<strong>引用折叠</strong>的规则,即不同引用类型叠加后的推导结果</p>
<table>
<thead>
<tr>
<th>类模板型</th>
<th>T实际类型</th>
<th>最终类型</th>
</tr>
</thead>
<tbody><tr>
<td>T&amp;</td>
<td>R</td>
<td>R&amp;</td>
</tr>
<tr>
<td>T&amp;</td>
<td>R&amp;</td>
<td>R&amp;</td>
</tr>
<tr>
<td>T&amp;</td>
<td>R&amp;&amp;</td>
<td>R&amp;</td>
</tr>
<tr>
<td>T&amp;&amp;</td>
<td>R</td>
<td>R&amp;&amp;</td>
</tr>
<tr>
<td>T&amp;&amp;</td>
<td>R&amp;</td>
<td>R&amp;</td>
</tr>
<tr>
<td>T&amp;&amp;</td>
<td>R&amp;&amp;</td>
<td>R&amp;&amp;</td>
</tr>
</tbody></table>
<ul>
<li>类模板型和T实际类型均有引用符,则按照数量少的引用符确定最终类型</li>
<li>类模板型和T实际类型有一个有引用符,则按照有引用符的数量来确定最终类型</li>
</ul>
<p>或者另一个记忆方式:(按照优先级来罗列)</p>
<ol>
<li>有左值引用,则最终类型为左值引用(优先级最高)</li>
<li>有右值引用,则最终类型为右值引用</li>
</ol>
<p>值得一提的是万能引用的形式必须是<code>T&amp;&amp;</code>或者<code>auto&amp;&amp;</code>,而不能是<code>vector&lt;T&gt;&amp;&amp;</code>,必须在初始化的时候被直接推导出来,若在推导中出现中间过程,则不是一个万能引用</p>
<h3 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h3><blockquote>
<p><strong>为什么需要完美转发？</strong></p>
<p>在 C++ 中，有时我们编写的模板函数只是为了“<strong>中转调用另一个函数</strong>”。但是，模板函数中的参数通常无法保持原始的左值或右值状态，这会导致性能问题或意外行为。因此，我们需要一种机制来<strong>让模板函数能正确地转发参数</strong>。</p>
<p>为了解决在函数模板中传递参数时保持参数的值类别（lvalue 或 rvalue）不变的问题</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面三种方式都不是完美转发,都有各自的问题:</span></span><br><span class="line"><span class="comment">//执行过程中会执行构造函数,因为是按值转发,即在转发过程中会额外发生一次临时对象的复制</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">normal_forwarding1</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">show_type</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解决了上面效率的问题,但是不能转发右值</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">normal_forwarding2</span><span class="params">(T &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">show_type</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//能转发右值了,但是即使传左值也无法修改了</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">normal_forwarding3</span><span class="params">(<span class="type">const</span> T &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">show_type</span>(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>完美转发</strong></p>
<p>原来是左值,转发后也是左值;原来是右值,转发后也是右值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">perfect_forwarding</span><span class="params">(T &amp;&amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//t传入的是左值的话,在此处会和右值折叠还是左值</span></span><br><span class="line">  <span class="comment">//t传入的是右值的话,在此处会和右值折叠还是右值</span></span><br><span class="line">  <span class="built_in">show_type</span>(<span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(t));<span class="comment">//这里必须是T&amp;&amp;,因为只有T&amp;&amp;可以推导出右值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//显示使用static_cast类型转换进行转发不是一个便携的方法.在C++11的标准库中提供了一个std::forward函数模板,在函数内部也是使用static_cast进行类型转化</span></span><br><span class="line"><span class="comment">//使用forward转发语义会表达得更加清晰</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">perfect_forwarding</span><span class="params">(T &amp;&amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">show_type</span>(std::forward&lt;T&gt;(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>std::forward</code> 用于在模板函数中<strong>完美转发</strong>参数。</li>
<li>它有条件地将变量转化为右值，只有当输入的变量是右值时，才会将其转化为右值引用；如果输入的变量是左值，那么 <code>forward</code> 将输入的变量转化成左值。</li>
<li>通常用于保留原始变量的左值和右值属性。</li>
</ul>
<p>此处详解完美转发的必要性:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Process by const lvalue reference\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(std::string&amp;&amp; str)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Process by rvalue reference (move semantics)\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forward_to_process</span><span class="params">(T arg)</span> </span>&#123;  <span class="comment">// 参数直接传递</span></span><br><span class="line">    <span class="built_in">process</span>(arg);                 <span class="comment">// 调用 process</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string text = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    forward_to_process(text);           <span class="comment">// 传入左值</span></span><br><span class="line">    forward_to_process(std::<span class="built_in">move</span>(text)); <span class="comment">// 传入右值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Process by const lvalue reference</span></span><br><span class="line"><span class="comment">//Process by const lvalue reference</span></span><br></pre></td></tr></table></figure>

<p><strong>问题</strong>：无论传入的是左值还是右值，<code>forward_to_process</code> 都只调用了 <code>process(const std::string&amp;)</code>。这是因为在模板函数中，参数 arg 被默认视为左值，即使我们传递的是右值，也失去了右值特性，导致效率低下（没有调用 <code>process(std::string&amp;&amp;)</code> 的移动版本）。</p>
<p>下面使用完美转发:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Process by const lvalue reference\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(std::string&amp;&amp; str)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Process by rvalue reference (move semantics)\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forward_to_process</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(std::forward&lt;T&gt;(arg));  <span class="comment">// 使用 std::forward 完美转发</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string text = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    forward_to_process(text);           <span class="comment">// 传入左值</span></span><br><span class="line">    forward_to_process(std::<span class="built_in">move</span>(text)); <span class="comment">// 传入右值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Process by const lvalue reference</span></span><br><span class="line"><span class="comment">//Process by rvalue reference (move semantics)</span></span><br></pre></td></tr></table></figure>

<p>进一步泛华,将process也泛化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用 process 函数模板，可以处理任意类型的 T</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_lvalue_reference_v&lt;T&gt;)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Processing lvalue reference of type &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Processing rvalue reference of type &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用转发函数模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">call_process</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(std::forward&lt;T&gt;(arg));  <span class="comment">// 完美转发，保留左值/右值属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string text = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="type">int</span> number = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">call_process</span>(text);           <span class="comment">// 传入 std::string 左值</span></span><br><span class="line">    <span class="built_in">call_process</span>(std::<span class="built_in">move</span>(text)); <span class="comment">// 传入 std::string 右值</span></span><br><span class="line">    <span class="built_in">call_process</span>(number);          <span class="comment">// 传入 int 左值</span></span><br><span class="line">    <span class="built_in">call_process</span>(<span class="number">100</span>);             <span class="comment">// 传入 int 右值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Processing lvalue reference of type std::string&amp;</span></span><br><span class="line"><span class="comment">//Processing rvalue reference of type std::string</span></span><br><span class="line"><span class="comment">//Processing lvalue reference of type int&amp;</span></span><br><span class="line"><span class="comment">//Processing rvalue reference of type int</span></span><br></pre></td></tr></table></figure>

<h2 id="自定义支持移动的类"><a href="#自定义支持移动的类" class="headerlink" title="自定义支持移动的类"></a>自定义支持移动的类</h2><p>完整写法参考</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span>&#123;</span><br><span class="line">    <span class="type">char</span>* p;</span><br><span class="line">    <span class="type">int</span> length;<span class="comment">//字符数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyString</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">char</span> *cs)&#123;</span><br><span class="line">        length = <span class="built_in">strlen</span>(cs);</span><br><span class="line">        p = <span class="keyword">new</span> <span class="type">char</span>[length<span class="number">+1</span>];</span><br><span class="line">        <span class="built_in">memcpy</span>(p, cs, length + <span class="number">1</span>);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;构造函数,构造指针地址为&quot;</span>&lt;&lt;(<span class="type">void</span>*)p &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> MyString &amp;other) : <span class="built_in">length</span>(other.length)</span><br><span class="line">    &#123;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="type">char</span>[length + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 使用c++17引入的std::copy_n复制字符串内容</span></span><br><span class="line">        std::<span class="built_in">copy_n</span>(other.p, length + <span class="number">1</span>, p);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;拷贝构造函数,构造指针地址为&quot;</span>&lt;&lt;(<span class="type">void</span>*)p &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    MyString &amp;<span class="keyword">operator</span>=(<span class="type">const</span> MyString &amp;other) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 先检查是否自我赋值，如果是则直接返回*this</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放原有内存</span></span><br><span class="line">        <span class="keyword">delete</span>[] p;</span><br><span class="line">        <span class="comment">// 分配新的字符数组以存储复制的字符串内容，并包含一个空终止符的位置</span></span><br><span class="line">        length = other.length;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="type">char</span>[length + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用std::copy_n复制字符串内容，不包括空终止符</span></span><br><span class="line">        std::<span class="built_in">copy_n</span>(other.p, length<span class="number">+1</span>, p);</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;赋值构造函数,构造指针地址为&quot;</span>&lt;&lt;(<span class="type">void</span>*)p &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 返回当前对象的引用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MyString</span>(MyString &amp;&amp; other) <span class="keyword">noexcept</span>:<span class="built_in">p</span>(other.p),<span class="built_in">length</span>(other.length)<span class="comment">//转移所有权</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;移动构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">        other.p=<span class="literal">nullptr</span>;</span><br><span class="line">        other.length=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MyString &amp;<span class="keyword">operator</span>=(MyString &amp;&amp; other)<span class="keyword">noexcept</span><span class="comment">//转移所有权</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>!=&amp;other)<span class="comment">//自我赋值检查</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p)&#123;<span class="keyword">delete</span>[] p;p=<span class="literal">nullptr</span>;&#125;</span><br><span class="line">            length = other.length;</span><br><span class="line">            p=other.p;</span><br><span class="line">            other.p=<span class="literal">nullptr</span>;<span class="comment">//切断与先前的联系</span></span><br><span class="line">            other.length=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;移动赋值运算符&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">MyString</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;析构成功函数,释放地址为:&quot;</span>&lt;&lt;(<span class="type">void</span>*)p&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">delete</span>[] p;</span><br><span class="line">            p=<span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;经过析构函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> MyString&amp; str) &#123;</span><br><span class="line">        os &lt;&lt;  str.p;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//==========================</span></span><br><span class="line"><span class="comment">//测试如下:</span></span><br><span class="line"><span class="function">MyString <span class="title">s</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">MyString s2=s;</span><br><span class="line">cout&lt;&lt;s2&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//输出如下:</span></span><br><span class="line">构造函数,构造指针地址为<span class="number">0x13a605ea0</span></span><br><span class="line">拷贝构造函数,构造指针地址为<span class="number">0x13a605d30</span></span><br><span class="line">hello</span><br><span class="line">析构成功函数,释放地址为:<span class="number">0x13a605d30</span></span><br><span class="line">析构成功函数,释放地址为:<span class="number">0x13a605ea0</span></span><br><span class="line"><span class="comment">//==========================</span></span><br><span class="line"><span class="comment">//测试2如下:</span></span><br><span class="line"><span class="function">MyString <span class="title">s</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">MyString s2=<span class="built_in">move</span>(s);</span><br><span class="line">cout&lt;&lt;s2&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//输出如下:</span></span><br><span class="line">构造函数,构造指针地址为<span class="number">0x140f041b0</span></span><br><span class="line">移动构造</span><br><span class="line">hello</span><br><span class="line">析构成功函数,释放地址为:<span class="number">0x140f041b0</span></span><br><span class="line">经过析构函数</span><br></pre></td></tr></table></figure>

<h1 id="非静态成员默认初始化"><a href="#非静态成员默认初始化" class="headerlink" title="非静态成员默认初始化"></a>非静态成员默认初始化</h1><p> 从C++11开始,声明<strong>非静态数据成员</strong>的同时,可以直接对其使用<strong>等号或大括号进行初始化</strong></p>
<blockquote>
<p>以前只有类型为整形或者枚举类型的常量静态数据成员才可以进行这种默认初始化</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>&#123;</span><br><span class="line"> <span class="type">int</span> a =<span class="number">0</span> ;</span><br><span class="line"> <span class="type">double</span> b&#123;<span class="number">0</span>&#125;;</span><br><span class="line"> string c&#123;<span class="string">&quot;hello world&quot;</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外从C++20开始,允许我们对数据成员的[[C++基础#位域|位域]]进行默认初始化了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span>&#123;</span><br><span class="line"> <span class="type">int</span> y:<span class="number">8</span>=<span class="number">11</span>; </span><br><span class="line"> <span class="type">int</span> z:<span class="number">4</span>&#123;<span class="number">7</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="可变参数模板"><a href="#可变参数模板" class="headerlink" title="可变参数模板"></a>可变参数模板</h1><p><strong>Variadic Templates</strong></p>
<p>[[C++基础#模板|基础模板知识点参阅]]</p>
<p>关键词: <code>...</code></p>
<p><code>...</code>就是一个所谓的pack(包)</p>
<ul>
<li>用于模版参数就是模版参数包</li>
<li>用于函数参数类型就是函数参数类型包</li>
<li>用于函数参数就是函数参数包</li>
</ul>
<blockquote>
<p>使用这种语法能兼容两个变化点,模板参数的两个点:</p>
<ul>
<li><p>参数个数(variable number)</p>
<p>本质是利用参数个数逐一递减的特性,实现递归函数调用.使用函数模板完成</p>
</li>
<li><p>参数类型(different type)</p>
<p>本质是利用参数个数逐一递减导致参数类型也逐一递减的的特性,实现递归继承或递归复合,使用类模板完成</p>
</li>
</ul>
</blockquote>
<blockquote>
<p>设计函数的时候</p>
<ul>
<li><p>当希望函数参数是类型不同,个数也不同的时候,采用可变参数模板</p>
</li>
<li><p>当希望函数参数只有个数不同,类型相同的时候,可以采用<a href="#%E4%B8%80%E8%87%B4%E6%80%A7%E5%88%9D%E5%A7%8B%E5%8C%96">initializer_list</a>,但是调用的时候需要多写一对<code>&#123;&#125;</code></p>
<p>这种情况也可以使用可变参数模板,只需要在定义 参数为[1+包]的函数时,使第一个参数的类型固定,而不是模板类型.</p>
</li>
</ul>
</blockquote>
<h2 id="函数案例"><a href="#函数案例" class="headerlink" title="函数案例"></a>函数案例</h2><p>针对下面的情况:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> T&amp; firstArg,<span class="type">const</span> Types&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout&lt;&lt;firstArg&lt;&lt;endl;</span><br><span class="line">  <span class="built_in">print</span>(args...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>args可以为任意数量(包含0个)的参数,并且每个参数可以是任何类型的(args为一包类型的一包参数)</p>
<p><code>sizeof...(args)</code>用于<strong>查看包中的个数</strong></p>
<p>但print函数的参数为0个时,因为0个参数没办法拆分为1+0,所以会走<code>void print()</code>,即作为递归的终止条件</p>
<blockquote>
<p>可以这么理解: <code>...</code>在左边表示定义,<code>...</code>在后边表示使用</p>
<p><code>...T</code>表示<strong>定义</strong>T类型包,<code>T...</code>表示<strong>使用</strong>类型包,<code>T... t</code>,使用类型包定义类型包的实例t,<strong>使用</strong>实例应该<code>t...</code></p>
</blockquote>
<p>更复杂的版本:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要求是传入什么类型就输出什么类型,用%符号来占位,%%表示%本身</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(*s)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;*s++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s,T first,Ts... others)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(*s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*s==<span class="string">&#x27;%&#x27;</span>&amp;&amp;*(s<span class="number">+1</span>)!=<span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//找到占位符</span></span><br><span class="line">            cout&lt;&lt;first;</span><br><span class="line">            <span class="comment">//退出前继续打印接下来的</span></span><br><span class="line">            <span class="built_in">myPrint</span>(++s,others...);<span class="comment">//++s跳过百分比符号</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(*s==<span class="string">&#x27;%&#x27;</span>&amp;&amp;*(s<span class="number">+1</span>)==<span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">            s+=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout&lt;&lt;*s++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可变参数模板求和案例</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 超级sum</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">ssum</span><span class="params">(T a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="function">T <span class="title">ssum</span><span class="params">(T a, Ts... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="built_in">ssum</span>(args...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类案例"><a href="#类案例" class="headerlink" title="类案例"></a>类案例</h2><blockquote>
<p>下面的案例是tuple(元组),tuple可以任意指定多个不同类型的成员,构造出一个对象</p>
</blockquote>
<h3 id="递归继承"><a href="#递归继承" class="headerlink" title="递归继承"></a>递归继承</h3><blockquote>
<p>实现方式是通过<a href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF">可变参数模板</a>实现的<strong>递归继承</strong></p>
<p>流程可描述为:将tuple类模板的类型分为[1+一包],先定义一个类型为第一个参数的类型,使该类继承自类型为[一包]的类型的类.(下方代码下面有贴继承链)</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面案例是元组</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Values&gt; <span class="keyword">class</span> <span class="title class_">tuple</span>;<span class="comment">//模板的声明，用于告诉编译器有一个名为`tuple`的模板类存在，但具体的实现将在后面的代码中提供</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">tuple</span>&lt;&gt; &#123;&#125;;<span class="comment">//作为终止条件的空类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head,<span class="keyword">typename</span>... Tail&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">tuple</span>&lt;Head,Tail...&gt;:<span class="keyword">private</span> tuple&lt;Tail...&gt;<span class="comment">//递归继承</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//定义tuple的继承类型</span></span><br><span class="line">	<span class="keyword">typedef</span> tuple&lt;Tail...&gt; inherited;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//构造函数</span></span><br><span class="line">  <span class="built_in">tuple</span>()&#123;&#125;</span><br><span class="line">  <span class="built_in">tuple</span>(Head v,Tail... vtail):<span class="built_in">m_head</span>(v),<span class="built_in">inherited</span>(vtail...)<span class="comment">//初始化列表,inherited(vtail...)表示调用父类的构造函数</span></span><br><span class="line">  &#123;&#125;</span><br><span class="line">  <span class="comment">//定义函数head</span></span><br><span class="line">  <span class="function">Head <span class="title">head</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> m_head;&#125;</span><br><span class="line">  <span class="comment">//C++14前也可以写成这种声明方法(返回类型后置写法):auto head() -&gt; decltype(m_head) &#123; return m_head; &#125;</span></span><br><span class="line">  <span class="comment">//定义函数tail</span></span><br><span class="line">  <span class="function">inherited&amp; <span class="title">tail</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;<span class="comment">//return后转型为inherited,这是一个巧妙的函数,通过该函数作为桥梁用于访问所有元素</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="comment">//定义成员变量m_head</span></span><br><span class="line">  Head m_head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>参照如下的继承链理解:(下图使用 <code>&#123;&#125;</code> 代替 <code>&lt;&gt;</code>) (<code>a-&gt;b</code>表示a继承b)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph BT</span><br><span class="line">    tuple1[&quot;tuple&#123; int, float, string&#125;&quot;] --&gt; tuple2[&quot;tuple &#123;float, string&#125;&quot;]</span><br><span class="line">    tuple2 --&gt; tuple3[&quot;tuple&#123; string&#125;&quot;]</span><br><span class="line">    tuple3 --&gt; tuple4[&quot;tuple&#123;&#125;&quot;]</span><br></pre></td></tr></table></figure>

<p>使用上面案例的情况如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">tuple&lt;<span class="type">int</span>,<span class="type">float</span>,string&gt; <span class="title">t</span><span class="params">(<span class="number">41</span>,<span class="number">6.3</span>,<span class="string">&quot;nico&quot;</span>)</span></span>;</span><br><span class="line">t.<span class="built_in">head</span>();   <span class="comment">//--&gt;获得41</span></span><br><span class="line">t.<span class="built_in">tail</span>().<span class="built_in">head</span>();  <span class="comment">//--&gt;获得6.3</span></span><br><span class="line">t.<span class="built_in">tail</span>().<span class="built_in">tail</span>().<span class="built_in">head</span>();   <span class="comment">//--&gt;获得&quot;nico&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="递归复合"><a href="#递归复合" class="headerlink" title="递归复合"></a>递归复合</h3><p>层层复合</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面案例是元组</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Values&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">tuple</span>; <span class="comment">// 模板的声明，用于告诉编译器有一个名为`tuple`的模板类存在，但具体的实现将在后面的代码中提供</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">tuple</span>&lt;&gt;</span><br><span class="line">&#123;</span><br><span class="line">&#125;; <span class="comment">// 作为终止条件的空类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Head, <span class="keyword">typename</span>... Tail&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">tuple</span>&lt;Head, Tail...&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义tuple的继承类型</span></span><br><span class="line">    <span class="keyword">typedef</span> tuple&lt;Tail...&gt; composited;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">tuple</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">tuple</span>(Head v, Tail... vtail) : <span class="built_in">m_head</span>(v), <span class="built_in">m_tail</span>(vtail...) <span class="comment">// 初始化列表,inherited(vtail...)表示调用父类的构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义函数head</span></span><br><span class="line">    <span class="function">Head <span class="title">head</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_head; &#125;</span><br><span class="line">    <span class="comment">// C++14前也可以写成这种声明方法(返回类型后置写法):auto head() -&gt; decltype(m_head) &#123; return m_head; &#125;</span></span><br><span class="line">    <span class="comment">// 定义函数tail</span></span><br><span class="line">    <span class="function">composited&amp; <span class="title">tail</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_tail; &#125; <span class="comment">// return后转型为inherited,这是一个巧妙的函数,通过该函数作为桥梁用于访问所有元素</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 定义成员变量m_head</span></span><br><span class="line">    Head m_head;</span><br><span class="line">    composited m_tail;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如下图罗列了每个类型的成员变量类型,层层组合关系</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202403131631115.png" alt="image-20240313163117150" style="zoom: 67%;" />

<h2 id="并存问题"><a href="#并存问题" class="headerlink" title="并存问题"></a>并存问题</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> T&amp; firstArg,<span class="type">const</span> Types&amp;... args)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Types&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> Types&amp;... args)</span></span></span><br></pre></td></tr></table></figure>

<p>上面这种情况参数为[1+包]和[包]的两个重载函数可以并存</p>
<p>注意:当调用print函数传入多个参数时,<strong>参数为[1+包] 比 [包] 更特化</strong>,调用的是[1+包]那个函数,即 <code>void print(const T&amp; firstArg,const Types&amp;... args)</code>.因此当他们共同存在的时候,参数为[包]的函数就永远不会被调用到了.</p>
<p>可变参数模版的作用:1.递归</p>
<h1 id="模版表达式中的空格"><a href="#模版表达式中的空格" class="headerlink" title="模版表达式中的空格"></a>模版表达式中的空格</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;list&lt;<span class="type">int</span>&gt; &gt;;    <span class="comment">//每个C++版本的都支持</span></span><br><span class="line">vecot&lt;list&lt;<span class="type">int</span>&gt;&gt;;    <span class="comment">//从C++11开始支持</span></span><br></pre></td></tr></table></figure>

<h1 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h1><blockquote>
<p>nullptr是C++11引入的空指针常量用于代替NULL或者0赋值给空指针</p>
<p>是一个nullptr_t类型的纯右值</p>
</blockquote>
<p>例子如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有两个函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">void</span>*)</span></span>;</span><br><span class="line"><span class="comment">//调用哪个函数?</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">0</span>);				<span class="comment">//调用f(int)</span></span><br><span class="line"><span class="built_in">f</span>(<span class="literal">NULL</span>);    <span class="comment">//调用f(int)</span></span><br><span class="line"><span class="built_in">f</span>(<span class="literal">nullptr</span>); <span class="comment">//调用f(void*)</span></span><br></pre></td></tr></table></figure>

<h2 id="nullptr-t"><a href="#nullptr-t" class="headerlink" title="nullptr_t"></a>nullptr_t</h2><p>顾名思义,<strong>nullptr的类型</strong></p>
<p><code>typedef decltype（nullptr）nullptr_t；</code></p>
<p><code>nullptr_t</code>是一个与 <code>nullptr</code> 具有相同类型的类型。</p>
<p>用处:为了在代码中使用更具有语义的类型,例如:可以使用 <code>nullptr_t</code> 来声明接受空指针的函数参数或返回类型，以增加代码的清晰度和可读性。</p>
<h1 id="三向比较"><a href="#三向比较" class="headerlink" title="三向比较"></a>三向比较</h1><p>在C++20中引入了太空船运算符<code>&lt;=&gt;</code>，它是一种三向比较运算符，用于比较两个值。这个运算符返回一个特殊的值，表示两个值之间的关系。这个值可以是负整数、零或正整数，分别表示第一个值小于、等于或大于第二个值。 太空船运算符的语法如下：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">result</span> = expression1 &lt;=&gt; expression2<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>其中，result的值为： </p>
<ul>
<li>负整数：如果expression1小于expression2。</li>
<li>零：如果expression1等于expression2。 </li>
<li>正整数：如果expression1大于expression2。</li>
</ul>
<blockquote>
<p>通过这个运算符，可以用一个单一的运算符来处理所有六种传统比较操作：小于、小于等于、等于、大于、大于等于和不等于。</p>
</blockquote>
<p>这个运算符对于排序和比较操作非常有用，可以简化代码并提高可读性。</p>
<p>注意:运算符<code>&lt;=&gt;</code>的返回值只能与0和自身类型来比较,如果同其他数值比较,编译器会报错</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span>=<span class="number">7</span>&lt;=&gt;<span class="number">11</span>&lt;<span class="number">0</span>;<span class="comment">//编译成功,b为true</span></span><br><span class="line"><span class="type">bool</span> b=<span class="number">7</span>&lt;=&gt;<span class="number">11</span>&lt;<span class="number">100</span>;<span class="comment">//变异失败,&lt;=&gt;的结果不能与除0以外的数值比较</span></span><br></pre></td></tr></table></figure>

<h2 id="返回类型"><a href="#返回类型" class="headerlink" title="返回类型"></a>返回类型</h2><p><code>&lt;=&gt;</code>运算符的返回值有三种类型</p>
<ol>
<li>strong_ordering      严格相等:相等并且可替换算相等</li>
<li>weak_ordering       非严格相等:相等但不可替换算相等,比如大小写不同的字符串</li>
<li>partial_ordering	 非严格相等:相等但不可替换算相等,多了一个可以毫无比较关系的选项</li>
</ol>
<h2 id="对基础类型的支持"><a href="#对基础类型的支持" class="headerlink" title="对基础类型的支持"></a>对基础类型的支持</h2><ol>
<li>对两个算数类型的操作数,对各操作数进行一般算术转换,然后进行比较,其中整形的比较结果为<code>strong_ordering</code>,浮点型的比较结果为<code>partial_ordering</code></li>
<li>对于两个底层类型不同的枚举类型,则无法编译</li>
<li>对于其中一个操作数为bool类型的情况,另外一个操作数必须也是bool类型,否则无法编译,比较结果为<code>strong_ordering</code></li>
<li>不支持比较的两个操作数为数组的情况,会导致编译错误</li>
<li>对于其中一个操作数为指针类型的情况,需要另一个操作数是同样类型的指针,或者是可以转换为相同类型的指针,最终比较结果为<code>strong_ordering</code></li>
</ol>
<h2 id="自动生成比较函数"><a href="#自动生成比较函数" class="headerlink" title="自动生成比较函数"></a>自动生成比较函数</h2><p><strong>C++20规定,当用户为自定义类型声明了三向比较运算符,那么编译器会为其自动生成<code>&lt;,&gt;,&lt;=,&gt;=</code>四种运算符函数（前提是使用 <code>= default</code>），减少了开发者的工作量</strong> </p>
<p><strong>用户自定义类型中,如果实现了<code>&lt;,==</code>运算符函数,该类的三向比较中将自动生成合适的比较代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strong_ordering <span class="built_in">operator</span>&lt;=&gt;(<span class="type">const</span> MyType&amp;) <span class="type">const</span>=<span class="keyword">default</span>;</span><br></pre></td></tr></table></figure>

<h1 id="auto关键字"><a href="#auto关键字" class="headerlink" title="auto关键字"></a>auto关键字</h1><p><strong>auto</strong>表示任意类型</p>
<p>声明变量时根据初始化表达式自动推断该变量的类型,声明函数时函数返回值的占位符</p>
<blockquote>
<p>auto一大用处是当类型非常长或非常复杂的时候使用,合理使用auto可以减少代码冗余</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非常长,如:iterator</span></span><br><span class="line">vector&lt;string&gt; v;</span><br><span class="line"><span class="comment">//vector&lt;int&gt;::iterator pos = v.begin();</span></span><br><span class="line"><span class="keyword">auto</span> pos=v.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//非常复杂,如:lambda</span></span><br><span class="line"><span class="keyword">auto</span> l=[](<span class="type">int</span> x)-&gt;<span class="type">bool</span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="auto关键字的特性"><a href="#auto关键字的特性" class="headerlink" title="auto关键字的特性"></a><strong>auto关键字的特性</strong></h2><ul>
<li><p>从左往右的推导</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x=<span class="number">1</span>,y=<span class="number">4.2</span>;</span><br><span class="line"><span class="comment">//从左往右x会先被推导为int类型,因此后半段会报错;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用表达能力更强的类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处会推导出x的类型为double而不是int类型,虽然这里的条件表达式最终返回的是1</span></span><br><span class="line"><span class="keyword">auto</span> x=<span class="literal">true</span>?<span class="number">1</span>:<span class="number">4.2</span>;</span><br><span class="line"><span class="built_in">static_assert</span>(std::is_same&lt;<span class="keyword">decltype</span>(x),<span class="type">double</span>&gt;::value);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>不能声明非静态成员变量</strong></p>
</li>
<li><p><strong>C++20之前无法声明形参</strong></p>
</li>
</ul>
<h2 id="推导规则"><a href="#推导规则" class="headerlink" title="推导规则"></a>推导规则</h2><ul>
<li><p>按值初始化</p>
<p>忽略CV限定符,即const和volatile两种</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">auto</span> j = i;</span><br><span class="line"><span class="comment">//推导出j为int类型</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>按引用初始化</p>
<p>忽略引用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i =<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> &amp;j=i;</span><br><span class="line"><span class="keyword">auto</span> m=j;</span><br><span class="line"><span class="comment">//m是int类型</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>万能引用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i =<span class="number">5</span>;</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; m=i;</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; j=<span class="number">5</span>;</span><br><span class="line"><span class="comment">//auto推导为int类型,j为int&amp;&amp;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>数组或者函数</p>
<p>会推导为指向相应类型的指针</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">auto</span> m = i;</span><br><span class="line"><span class="keyword">auto</span>推导为指向<span class="type">int</span>类型的指针</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="#%E4%B8%80%E8%87%B4%E6%80%A7%E5%88%9D%E5%A7%8B%E5%8C%96">列表初始化</a></p>
<p>该项在C++17标准和其之前的标准有区别,这里只提c++17之后的标准</p>
<ul>
<li><p>直接使用列表初始化</p>
<p>列表里必须是单个元素,则auto推导为元素的类型</p>
<p>多个元素,编译无法通过</p>
</li>
<li><p>使用等号赋值的列表初始化</p>
<p>auto推导的类型是<a href="#%E4%B8%80%E8%87%B4%E6%80%A7%E5%88%9D%E5%A7%8B%E5%8C%96">initializer_list</a></p>
</li>
</ul>
</li>
</ul>
<h2 id="auto占位符使用"><a href="#auto占位符使用" class="headerlink" title="auto占位符使用"></a>auto占位符使用</h2><blockquote>
<p>从<strong>C++14</strong>开始支持使用auto来推导函数的返回类型,此时不需要使用返回类型后置的语法</p>
</blockquote>
<ul>
<li><p><strong>返回类型推导</strong></p>
<p>要求统一返回类型,如果在if else中返回多个不同类型,编译无法通过</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a1,<span class="type">int</span> a2)</span></span>&#123;<span class="keyword">return</span> a1+a2;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>lambda表达式的形参中使用auto</strong></p>
<p>C++14开始支持,给auto增加了一定的泛型能力</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> l=[](<span class="keyword">auto</span> a1,<span class="keyword">auto</span> a2)&#123;<span class="keyword">return</span> a1+a2;&#125;;</span><br><span class="line"><span class="keyword">auto</span> retval=<span class="built_in">l</span>(<span class="number">5</span>,<span class="number">5.0</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>非类型模板形参占位符</strong></p>
<p>C++17开始支持</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">auto</span> N&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout&lt;&lt;N&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><a href="#decltype%E5%92%8Cauto%E9%85%8D%E5%90%88%E4%BD%BF%E7%94%A8">auto与decltype配合使用详情</a></p>
<h1 id="一致性初始化"><a href="#一致性初始化" class="headerlink" title="一致性初始化"></a>一致性初始化</h1><p>Uniform Initialization</p>
<p>列表初始化的主要目的是<strong>让stl容器如同数组一般的被初始化</strong></p>
<blockquote>
<p>传统初始化方式主要是两种</p>
<ul>
<li><p>使用括号初始化的方式叫做<strong>直接初始化</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">8</span>)</span></span>;</span><br><span class="line"><span class="function">C <span class="title">x2</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用等号初始化的方式叫做<strong>拷贝初始化</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">8</span>;</span><br><span class="line">C x2=<span class="number">4</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
<p>现在,<strong>任何变量的初始化都可以用一个共通语法设置初值</strong>: <code>&#123;&#125;</code></p>
<p>他也分为直接初始化和拷贝初始化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> values[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>&#125;;<span class="comment">//直接初始化</span></span><br><span class="line"><span class="comment">//vector&lt;int&gt; v=&#123;2,3,5,7,11,13,17&#125;;//拷贝初始化</span></span><br><span class="line"><span class="comment">//编号1(下面有讲解)</span></span><br><span class="line">vector&lt;string&gt; cities&#123;</span><br><span class="line">  <span class="string">&quot;Berlin&quot;</span>,<span class="string">&quot;New York&quot;</span>,<span class="string">&quot;London&quot;</span>,<span class="string">&quot;Braunschweig&quot;</span>,<span class="string">&quot;Cairo&quot;</span>,<span class="string">&quot;Cologne&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//编号2代码(下面有讲解)</span></span><br><span class="line">complex&lt;<span class="type">double</span>&gt;c&#123;<span class="number">4.0</span>,<span class="number">3.0</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>其实是利用一个事实:编译器看到{t1,t2…tn}便做出一个<code>initializer_list&lt;T&gt;</code>,它关联到一个<code>array&lt;T,n&gt;</code>.调用函数(例如ctor(构造函数))时该array内的元素可被编译器分解逐一传给函数.但若函数参数就是个<code>initializer_list&lt;T&gt;</code>,调用者不会分解逐一传给函数,而是作为一个<code>initializer_list&lt;T&gt;</code>传入</p>
<ul>
<li>编号1代码:这形成一个<code>initializer_list&lt;string&gt;</code>,背后有个<code>array&lt;string,6&gt;</code>.调用<code>vector&lt;string&gt; ctors</code>时编译器找到了一个<code>vector&lt;string&gt; </code>接受<code>initializer_list&lt;string&gt;</code>的构造函数.<strong>所有stl容器都有这种构造函数</strong></li>
<li>编号2代码:这形成一个这形成一个<code>initializer_list&lt;double&gt;</code>,背后有个<code>array&lt;double,2&gt;</code>.调用<code>complex&lt;double&gt; </code>构造函数时该array内的2个元素被分解传给构造函数.<code>complex&lt;double&gt;</code>并无任何构造函数接受<code>initializer_list&lt;double&gt;</code>参数</li>
</ul>
<h2 id="initializer-list"><a href="#initializer-list" class="headerlink" title="initializer_list&lt;T&gt;"></a>initializer_list&lt;T&gt;</h2><p>Initializer Lists</p>
<p>初始化列表不填任何东西会被0初始化(若是指针则初始化为nullptr)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;<span class="comment">//i未被初始化</span></span><br><span class="line"><span class="type">int</span> j&#123;&#125;;<span class="comment">//j被初始化为0</span></span><br><span class="line"><span class="type">int</span>* p;<span class="comment">//p未被初始化</span></span><br><span class="line"><span class="type">int</span>* q&#123;&#125;;<span class="comment">//q初始化为nullptr</span></span><br></pre></td></tr></table></figure>

<p>初始化列表不允许大空间到小空间的转换(narrowing:收缩)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">x1</span><span class="params">(<span class="number">5.3</span>)</span></span>;	<span class="comment">//OK			x1=5</span></span><br><span class="line"><span class="type">int</span> x2 = <span class="number">5.3</span>;		<span class="comment">//OK    x2=5</span></span><br><span class="line"><span class="type">int</span> x3&#123;<span class="number">5.0</span>&#125;;		<span class="comment">//ERROR:narrowing</span></span><br><span class="line"><span class="type">int</span> x4 = &#123;<span class="number">5.3</span>&#125;;		<span class="comment">//ERROR:narrowing</span></span><br><span class="line"><span class="type">char</span> cl&#123;<span class="number">7</span>&#125;;				<span class="comment">//OK 尽管7是int,但没有收缩</span></span><br><span class="line"><span class="type">char</span> c2&#123;<span class="number">99999</span>&#125;;		<span class="comment">//ERROR:narrowing</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v1&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;	<span class="comment">//OK</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v2&#123;<span class="number">1</span>,<span class="number">2.3</span>,<span class="number">4</span>,<span class="number">5.6</span>&#125;;	<span class="comment">//ERROR:narrowing</span></span><br></pre></td></tr></table></figure>

<p>上面的ERROR在gcc中是warning</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>为了支持用户定义类型的初始化列表概念，C++11提供了类模板<code>std::initializer_list</code>。它可用于支持通过值列表进行初始化，或者在任何其他只需要处理值列表的地方使用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(std::initializer_list&lt;<span class="type">int</span>&gt; vals)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="keyword">for</span>(<span class="keyword">auto</span> p=vals.<span class="built_in">begin</span>();p!=vals.<span class="built_in">end</span>();++p)&#123;</span><br><span class="line">			std::cout&lt;&lt;*p&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(&#123;<span class="number">12</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>&#125;);</span><br><span class="line"><span class="comment">//传给initializer_list的,一定必须也是个initializer_list或者&#123;...&#125;形式</span></span><br></pre></td></tr></table></figure>

<p><strong>优先级问题</strong></p>
<p><code>如果同时有两个函数P(int a,int b)或者P(initializer_list&lt;int&gt; initlist)</code>当执行 <code>P q&#123;77,5&#125;;</code>会<strong>优先调用后者</strong></p>
<blockquote>
<p>对[[STL]]容器的影响:如今<strong>所有容器</strong>都接受指定任意数量的值用于构建或赋值或<code>insert()</code>或<code>assign()</code>;<code>max()</code>和<code>min()</code>也可以接受任意参数.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v1&#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">12</span>,<span class="number">34</span>,<span class="number">45</span>,<span class="number">56</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(&#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">69</span>,<span class="number">83</span>,<span class="number">50</span>&#125;)</span></span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v3;</span><br><span class="line">v3 =&#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">13</span>,<span class="number">69</span>,<span class="number">83</span>,<span class="number">50</span>&#125;;</span><br><span class="line">v<span class="number">3.</span><span class="built_in">insert</span>(v<span class="number">3.</span><span class="built_in">begin</span>()<span class="number">+2</span>,&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;);</span><br><span class="line"><span class="built_in">max</span>(&#123;<span class="built_in">string</span>(<span class="string">&quot;Ace&quot;</span>),<span class="built_in">string</span>(<span class="string">&quot;Stacy&quot;</span>),<span class="built_in">string</span>(<span class="string">&quot;Sabrina&quot;</span>),<span class="built_in">string</span>(<span class="string">&quot;Barkley&quot;</span>)&#125;);</span><br><span class="line"><span class="built_in">min</span>(&#123;<span class="number">54</span>,<span class="number">16</span>,<span class="number">48</span>,<span class="number">5</span>&#125;);</span><br><span class="line"><span class="comment">//要注意的是:</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>)<span class="comment">//创建临时的空间大小为1的vector&lt;int&gt;,里面的值是不确定的</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">1</span>&#125;<span class="comment">//创建临时的空间里面的值是1的vector&lt;int&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="initializer-list原理"><a href="#initializer-list原理" class="headerlink" title="initializer_list原理"></a>initializer_list原理</h2><p><strong>initializer_list内部的实现实际上是对array的引用(头指针和长度)</strong>,没有包含array</p>
<p>因此如果复制initializer_list产生的另一个initializer_list,双方是同一个array的引用</p>
<h2 id="初始化列表不支持隐式缩窄转换"><a href="#初始化列表不支持隐式缩窄转换" class="headerlink" title="初始化列表不支持隐式缩窄转换"></a>初始化列表不支持隐式缩窄转换</h2><p><strong>列表初始化由宽类型转为窄类型编译无法通过</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>  x=<span class="number">999</span>;</span><br><span class="line"><span class="type">char</span> c1=x;<span class="comment">//编译成功,传统变量初始化支持隐式缩窄转换</span></span><br><span class="line"><span class="type">char</span> c2&#123;x&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="指定初始化"><a href="#指定初始化" class="headerlink" title="指定初始化"></a>指定初始化</h2><blockquote>
<p>为了提高数据成员初始化的可读性和灵活性</p>
<p>C++20标准引入了<strong>指定初始化</strong>的特性</p>
<p>C语言在C99标准就已经支持该功能了</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本语法</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line">  <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line">Point p&#123;.x = <span class="number">4</span>, .y=<span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="语法要求"><a href="#语法要求" class="headerlink" title="语法要求"></a>语法要求</h3><ol>
<li>必须是一个聚合类型</li>
<li>数据成员必须是非静态数据成员</li>
<li>数据成员最多只能被初始化一次</li>
<li>非静态数据成员的初始化<strong>必须按照声明的顺序</strong>进行</li>
<li>针对联合体中的数据成员只能初始化一次,不能同时指定</li>
<li>不能嵌套指定初始化数据成员</li>
<li>一旦使用指定初始化就不能混用其他方法对数据成员初始化了</li>
<li>禁止对数组使用指定初始化</li>
</ol>
<h1 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h1><blockquote>
<p>C++11引入了委托构造函数的概念，允许一个构造函数调用同一个类的另一个构造函数来完成初始化。</p>
<p>为了简洁化冗余的构造函数</p>
</blockquote>
<p>传统构造方式如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X2</span>() &#123; cout&lt;&lt;<span class="string">&quot;1&quot;</span>&lt;&lt;endl;<span class="built_in">CommonInit</span>(<span class="number">0</span>, <span class="number">0.</span>); &#125;</span><br><span class="line">    <span class="built_in">X2</span>(<span class="type">int</span> a) &#123; <span class="built_in">CommonInit</span>(a, <span class="number">0.</span>); &#125;</span><br><span class="line">    <span class="built_in">X2</span>(<span class="type">double</span> b) &#123; <span class="built_in">CommonInit</span>(<span class="number">0</span>, b); &#125;</span><br><span class="line">    <span class="built_in">X2</span>(<span class="type">int</span> a, <span class="type">double</span> b) &#123; <span class="built_in">CommonInit</span>(a, b); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CommonInit</span><span class="params">(<span class="type">int</span> a, <span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        a_= a;</span><br><span class="line">        b_=b;</span><br><span class="line">        c_=<span class="string">&quot;hello world&quot;</span>;<span class="comment">//此处调用了赋值构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> a_;</span><br><span class="line">    <span class="type">double</span> b_;</span><br><span class="line">    std::string c_;<span class="comment">//此处调用了默认构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>委托构造方式:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">x</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span>  <span class="title">CommonInit</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">double</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">x</span>():<span class="built_in">x</span>(<span class="number">0</span>,<span class="number">0.</span>)&#123;&#125;<span class="comment">//委托构造函数</span></span><br><span class="line">    <span class="built_in">x</span>(<span class="type">int</span> a):<span class="built_in">x</span>(a,<span class="number">0.</span>)&#123;&#125;<span class="comment">//委托构造函数</span></span><br><span class="line">    <span class="built_in">x</span>(<span class="type">double</span> b):<span class="built_in">x</span>(<span class="number">0</span>,b)&#123;&#125;<span class="comment">//委托构造函数</span></span><br><span class="line">    <span class="built_in">x</span>(<span class="type">int</span> a,<span class="type">double</span> b):<span class="built_in">a</span>(a),<span class="built_in">b</span>(b)&#123;<span class="built_in">CommonInit</span>();&#125;<span class="comment">//代理构造函数(被委托方)</span></span><br><span class="line">    ~<span class="built_in">x</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong></p>
<ul>
<li><p>每个构造函数都可以委托另一个构造为代理</p>
</li>
<li><p>不要递归循环委托</p>
</li>
<li><p>委托构造函数的<strong>执行顺序</strong>是:代理构造函数的初始化列表-&gt;代理构造函数体-&gt;委托构造函数体</p>
</li>
<li><p>若在代理构造函数执行完成后,<strong>委托构造函数主体抛出异常,则自动调用该类的析构函数</strong></p>
<p>标准规定,<strong>代理构造函数执行完成就算构造完成</strong>,因此委托构造函数主体抛出异常必然会导致对象的析构</p>
</li>
<li><p><strong>若构造函数为委托构造函数,那么其初始化列表不能对数据成员和基类进行初始化</strong></p>
</li>
</ul>
<h2 id="委托模板构造函数"><a href="#委托模板构造函数" class="headerlink" title="委托模板构造函数"></a>委托模板构造函数</h2><p>这种泛型能力可以有效减少构造函数的代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">x</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; </span></span><br><span class="line"><span class="function">    <span class="title">x</span><span class="params">(T first,T last)</span>:l(first,last)&#123;</span>&#125;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; l;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">x</span>(vector&lt;<span class="type">short</span>&gt;&amp; v):<span class="built_in">x</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>())&#123;&#125;;</span><br><span class="line">    <span class="built_in">x</span>(deque&lt;<span class="type">int</span>&gt;&amp; v):<span class="built_in">x</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>())&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//直接将代理构造函数的具体实现交给stl容器完成</span></span><br></pre></td></tr></table></figure>

<p>委托构造函数使用和初始化列表一样的[[C++基础#Function-try-block|function-try-block机制]]处理异常</p>
<p>若函数 try 块在委托构造函数上，而它调用的代理构造函数成功完成，但之后该委托构造函数的函数体抛出了异常，则将在进入函数 try 块的任何 catch 子句之前完成此对象的析构函数。</p>
<p>若异常在代理构造函数的初始化列表或函数主体中被抛出,委托构造函数主体将不再执行后序代码,交给catch执行.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    std::string m;</span><br><span class="line">    <span class="built_in">S</span>(<span class="type">const</span> std::string&amp; arg) <span class="keyword">try</span> : <span class="built_in">m</span>(arg, <span class="number">100</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;constructed, mn = &quot;</span> &lt;&lt; m &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125; <span class="built_in">catch</span>(<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;arg=&quot;</span> &lt;&lt; arg &lt;&lt; <span class="string">&quot; failed: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125; <span class="comment">// implicit throw; here</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="继承构造函数"><a href="#继承构造函数" class="headerlink" title="继承构造函数"></a>继承构造函数</h1><p>C++11引入,用于解决继承关系中构造函数的冗余</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>():<span class="built_in">x</span>(<span class="number">0</span>),<span class="built_in">y</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> x,<span class="type">double</span> y):<span class="built_in">x</span>(x),<span class="built_in">y</span>(y)&#123;&#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> x):<span class="built_in">x</span>(x),<span class="built_in">y</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">double</span> y):<span class="built_in">x</span>(<span class="number">0</span>),<span class="built_in">y</span>(y)&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">double</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span>:<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derive</span>()&#123;&#125;;<span class="comment">//默认构造函数会自动调用父类的默认构造函数</span></span><br><span class="line">    <span class="built_in">Derive</span>(<span class="type">int</span> x,<span class="type">double</span> y):<span class="built_in">Base</span>(x,y)&#123;&#125;</span><br><span class="line">    <span class="built_in">Derive</span>(<span class="type">int</span> x):<span class="built_in">Base</span>(x)&#123;&#125;</span><br><span class="line">    <span class="built_in">Derive</span>(<span class="type">double</span> y):<span class="built_in">Base</span>(y)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>():<span class="built_in">x</span>(<span class="number">0</span>),<span class="built_in">y</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> x,<span class="type">double</span> y):<span class="built_in">x</span>(x),<span class="built_in">y</span>(y)&#123;&#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> x):<span class="built_in">x</span>(x),<span class="built_in">y</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">double</span> y):<span class="built_in">x</span>(<span class="number">0</span>),<span class="built_in">y</span>(y)&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">double</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span>:<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::Base;<span class="comment">//继承构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="相关规则"><a href="#相关规则" class="headerlink" title="相关规则"></a>相关规则</h2><ul>
<li><p>派生类是隐式继承基类的构造函数,所以只有在程序中使用了这些构造函数,编译器才会为派生类生成继承构造函数的代码</p>
</li>
<li><p>派生类<strong>不会继承</strong>基类的<strong>默认构造函数</strong>和<strong>拷贝构造函数</strong></p>
</li>
<li><p>继承构造函数不会影响派生类默认构造函数的隐式声明</p>
</li>
<li><p>在派生类中<strong>声明签名相同的构造函数会禁止继承</strong>相应的构造函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span>:<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  	<span class="built_in">Derived</span>(<span class="type">int</span> x)&#123;...&#125;</span><br><span class="line">    <span class="keyword">using</span> Base::Base;<span class="comment">//继承构造函数,但由于上一句,不会继承Base(int x):x(x),y(0)&#123;&#125;代码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>派生类继承多个签名相同的构造函数会导致编译失败</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Base1</span>(<span class="type">int</span>)&#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Base2</span>(<span class="type">int</span>)&#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span>:<span class="keyword">public</span> Base1,Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base1::Base1;</span><br><span class="line">  	<span class="keyword">using</span> Base2::Base2;<span class="comment">//多继承,多个签名相同的构造函数导致编译失败</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>继承构造函数的基类构造函数如果是<strong>私有,将不继承该函数</strong></p>
</li>
</ul>
<h1 id="强枚举类型"><a href="#强枚举类型" class="headerlink" title="强枚举类型"></a>强枚举类型</h1><p>[[C语言入门#枚举|枚举类型]]有两个问题</p>
<ol>
<li><p>枚举类型可以隐式转换为整形</p>
<p>由于有隐式转换为整形,可以对枚举类型的值进行比较,不合理</p>
</li>
<li><p>无法指定枚举类型的底层类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">E</span>&#123;</span><br><span class="line">	e1=<span class="number">1</span>,</span><br><span class="line">  e2=<span class="number">2</span>,</span><br><span class="line">  e3=<span class="number">0xfffffff0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">bool</span> b=e1&lt;e3;</span><br><span class="line">  cout&lt;&lt;boolalpha&lt;b&lt;&lt;endl;</span><br><span class="line">  <span class="comment">//gcc中返回true;可以认为E的底层是unsigned int</span></span><br><span class="line">  <span class="comment">//微软编译器返回false;可以认为E的底层是int,输出e3是-16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>为了解决上述问题,C++11引入了强枚举类型</p>
<h2 id="三个新特性"><a href="#三个新特性" class="headerlink" title="三个新特性"></a>三个新特性</h2><ul>
<li>枚举标识符属于强枚举类型的作用域</li>
<li>枚举标识符不会隐式转换为整形</li>
<li>能指定强枚举类型的底层类型,<strong>底层类型默认为int类型</strong></li>
</ul>
<h2 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h2><p>关键词:<code>enum class</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">HighSchool</span>&#123;</span><br><span class="line">  student,</span><br><span class="line">  teacher,</span><br><span class="line">  headmaster</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">University</span>&#123;</span><br><span class="line">	student,</span><br><span class="line">  professor,</span><br><span class="line">  principal</span><br><span class="line">&#125;;</span><br><span class="line">HighSchool x = student;<span class="comment">//编译失败,找不到student的定义</span></span><br><span class="line"><span class="type">bool</span> b=University::student&lt;HighSchool::headmaster;<span class="comment">//编译失败,比较的类型不同</span></span><br><span class="line"><span class="type">int</span> y=University::student;<span class="comment">//编译失败,无法隐式转换为int类型</span></span><br></pre></td></tr></table></figure>

<p><strong>指定类型</strong>方式如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">E</span>:<span class="type">unsigned</span> <span class="type">int</span>&#123;<span class="comment">//指定类型为unsigned int</span></span><br><span class="line">	e1=<span class="number">1</span>,</span><br><span class="line">  e2=<span class="number">2</span>,</span><br><span class="line">  e3=<span class="number">0xfffffff0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="枚举类型的列表初始化"><a href="#枚举类型的列表初始化" class="headerlink" title="枚举类型的列表初始化"></a>枚举类型的列表初始化</h2><blockquote>
<p>C++17标准开始,对<strong>有底层类型的枚举类型对象可以直接使用列表初始化</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span>&#123;</span><br><span class="line">  Red,</span><br><span class="line">  Gree,</span><br><span class="line">  Blue</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Color c&#123;<span class="number">5</span>&#125;;<span class="comment">//编译成功  </span></span><br><span class="line">  Color c1=<span class="number">5</span>;<span class="comment">//编译失败</span></span><br><span class="line">  Color c2=&#123;<span class="number">5</span>&#125;;<span class="comment">//编译失败</span></span><br><span class="line">  <span class="function">Color <span class="title">c3</span><span class="params">(<span class="number">5</span>)</span></span>;<span class="comment">//编译失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用using打开强枚举类型"><a href="#使用using打开强枚举类型" class="headerlink" title="使用using打开强枚举类型"></a>使用using打开强枚举类型</h2><p>C++20标准拓展让using功能可以打开强枚举类型的命名空间</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span>&#123;</span><br><span class="line">  Red,</span><br><span class="line">  Green,</span><br><span class="line">  Blue</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">changeColorToRed</span><span class="params">(Color&amp; c)</span></span>&#123;</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">enum</span> <span class="title class_">Color</span>;<span class="comment">//打开Color强枚举类型的命名空间</span></span><br><span class="line">  c=Red;<span class="comment">//这样就不需要写`Color::Red`的方式来表明枚举值,而直接可以使用Red</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="聚合类型"><a href="#聚合类型" class="headerlink" title="聚合类型"></a>聚合类型</h1><blockquote>
<p>C++的聚合类型概念是在C++11标准中引入的。引入这一概念的目的是为了提供一种简洁的方法来初始化结构体和类的成员，以解决在早期版本中在初始化复杂数据结构时的冗长和不便。通过聚合类型，可以使用统一的初始化语法来初始化结构体和类的成员，使代码更加简洁和易读。</p>
</blockquote>
<p>聚合类型需要满足的条件</p>
<ul>
<li><p><strong>没有用户提供的构造函数</strong></p>
<p>C++20改成了<strong>没有用户声明的构造函数</strong>:区别在于:即使声明为<strong>显示删除</strong>:<code>构造函数=delete;</code>或者<strong>显示默认</strong>:<code>构造函数=default;</code>,都会将结构体改变为非聚合类型</p>
</li>
<li><p><strong>没有私有和受保护的非静态数据成员</strong></p>
</li>
<li><p><strong>没有虚函数</strong></p>
</li>
</ul>
<p>在新标准的拓展中,如果类存在继承关系,额外满足条件:</p>
<ul>
<li>必须是<strong>public的基类</strong>,不能是私有或者受保护的基类</li>
<li>必须是<strong>非虚继承</strong></li>
</ul>
<blockquote>
<p>注意,聚合类型的要求没有要求基类必须是聚合类型</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span>:<span class="keyword">public</span> std::string&#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	cout&lt;&lt;is_aggregate_v&lt;string&gt;&lt;&lt;endl;</span><br><span class="line">  	cout&lt;&lt;is_aggregate_v&lt;MyString&gt;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出如下:</span></span><br><span class="line"><span class="comment">//0</span></span><br><span class="line"><span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<h2 id="聚合类型的初始化"><a href="#聚合类型的初始化" class="headerlink" title="聚合类型的初始化"></a>聚合类型的初始化</h2><p>可以直接使用尖括号初始化,总是假设基类是一种在所有数据成员之前声明的特殊成员</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span>:<span class="keyword">public</span> std::string&#123;&#125;</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  	<span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyStringWithIndex s&#123;&#123;<span class="string">&quot;hello world&quot;</span>&#125;,<span class="number">11</span>&#125;;<span class="comment">//聚合类型的初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C++17开始,禁止受保护权限的构造函数在聚合类型初始化过程中被调用,因此会导致编译错误.解决方式很简单,提供一个公有权限的构造函数就可以了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseData</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> data;&#125;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">BaseData</span>():<span class="built_in">data</span>(<span class="number">11</span>)&#123;&#125;<span class="comment">//这个改成public类型就可以访问,或者用下面的方式修改</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedData</span>:<span class="keyword">public</span> BaseData&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">DerivedData d&#123;&#125;;<span class="comment">//编译错误:BaseData::BaseData()不可访问,通过上面注释的两种方式解决</span></span><br></pre></td></tr></table></figure>

<h2 id="小括号列表初始化"><a href="#小括号列表初始化" class="headerlink" title="小括号列表初始化"></a>小括号列表初始化</h2><p>C++20后允许使用带小括号的列表初始化聚合类型对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span>&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">float</span> f;</span><br><span class="line">&#125;;</span><br><span class="line">X x&#123;<span class="number">11</span>,<span class="number">7.0f</span>&#125;;</span><br><span class="line"><span class="function">X <span class="title">x</span><span class="params">(<span class="number">11</span>,<span class="number">7.0f</span>)</span></span>;<span class="comment">//小括号也支持了</span></span><br><span class="line"><span class="comment">//原本小括号初始化会优先查找相应参数的构造函数,但是由于聚合类型不能有用户自定义的构造函数,因此会编译失败,但是C++20允许小括号初始化,结果与使用尖括号一致</span></span><br></pre></td></tr></table></figure>

<p>值得注意的是:<strong>聚合类型的小括号列表初始化支持缩窄转换</strong>,这是<a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E4%B8%8D%E6%94%AF%E6%8C%81%E9%9A%90%E5%BC%8F%E7%BC%A9%E7%AA%84%E8%BD%AC%E6%8D%A2">普通列表初始化所不支持的</a></p>
<h1 id="基于范围的for循环"><a href="#基于范围的for循环" class="headerlink" title="基于范围的for循环"></a>基于范围的for循环</h1><p>for的一种语法糖</p>
<blockquote>
<p>这种语法只适用于支持[[STL#迭代器|迭代器]]访问的容器</p>
<p>本质上可以支持数组或对象,对于对象必须满足以下2个条件中的任意一个:</p>
<ul>
<li>对象定义了begin和end成员函数</li>
<li>定义了以对象类型为参数的begin和end普通函数</li>
</ul>
<p><a href="#begin%E5%92%8Cend%E5%87%BD%E6%95%B0%E4%B8%8D%E5%BF%85%E8%BF%94%E5%9B%9E%E7%9B%B8%E5%90%8C%E7%B1%BB%E5%9E%8B">C++17规定了begin和end函数不必返回相同类型</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(decl:coll)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//statement;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//decl:范围声明,形如:int a</span></span><br><span class="line"><span class="comment">//coll:范围表达式可以是数组或者是对象,对象尤其指支持迭代器操作的容器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//其实本质上就是如下代码</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> _pos=coll.<span class="built_in">begin</span>();pos!=coll.<span class="built_in">end</span>();++_pos)&#123;</span><br><span class="line">  decl=* _pos;</span><br><span class="line">	<span class="comment">//slatement</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也由于其本质是属于隐式转换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">C</span><span class="params">(<span class="type">const</span> string&amp; s)</span></span>;<span class="comment">//该构造函数不能隐式类型转换</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;string&gt; vs;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">const</span> C&amp; elem: vs)&#123;<span class="comment">//此处会报错:不存在从sting类型到C类型的转换</span></span><br><span class="line">  <span class="comment">//原因正是因为隐含的decl=* _pos;执行失败</span></span><br><span class="line">	cout&lt;&lt;elem&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for语法糖的其他例子:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : &#123;<span class="number">12</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>&#125;)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">double</span>&gt; vec;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> elem:vec)&#123;</span><br><span class="line">  cout&lt;&lt;elem&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面的方式才可以真正修改值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; elem:vec)&#123;</span><br><span class="line">  elem*=<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果在循环过程中确认不会修改引用对象,那么推荐在范围声明中加上const限定符,以帮助编译器生成更加高效的代码</p>
</blockquote>
<h2 id="begin和end函数不必返回相同类型"><a href="#begin和end函数不必返回相同类型" class="headerlink" title="begin和end函数不必返回相同类型"></a>begin和end函数不必返回相同类型</h2><blockquote>
<p>C++17规定了begin和end函数不必返回相同类型</p>
</blockquote>
<ul>
<li><p>C++11中编译器针对这种for特殊写法自动生成的伪代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp;&amp; range=range_expression;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> begin=begin_expr,end=end_expr;begin!=end;++begin)&#123;<span class="comment">//这一句就要求了begin和end必须是同一个返回类型</span></span><br><span class="line">  range_declaration=*begin;</span><br><span class="line">  <span class="comment">//loop_statement</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>C++17编译器针对这种for特殊写法自动生成的伪代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> &amp;&amp; range=range_expression;</span><br><span class="line"><span class="keyword">auto</span> begin=begin_expr;<span class="comment">//分开接收了begin和end函数的返回值类型</span></span><br><span class="line"><span class="keyword">auto</span> end=end_expr;</span><br><span class="line"><span class="keyword">for</span>(;begin!=end;++begin)&#123;</span><br><span class="line">  range_declaration=*begin;</span><br><span class="line">  <span class="comment">//loop_statement</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><p>虽然标准容器（如 std::vector, std::map 等）的 <code>begin()</code> 和 <code>end()</code> 返回相同的类型，但并非所有的 STL 组件都如此</p>
<p><code>std::istream</code> <strong>和</strong> <code>std::ostream</code> <strong>迭代器</strong></p>
<p><code>std::istream_iterator</code> 的 begin() 返回普通的输入迭代器，但 end() 返回一个特殊的默认构造的迭代器，用于表示流结束。</p>
<p>更大的意义在于<strong>支持自定义范围类型</strong></p>
<p>在某些自定义类型中，begin() 和 end() 返回不同类型是合理且必要的。例如：</p>
<ul>
<li><strong>只读范围</strong>：begin() 返回一个可变迭代器（mutable_iterator），而 end() 返回一个不可变迭代器（const_iterator）。</li>
<li><strong>半开区间</strong>：begin() 返回一个普通迭代器，而 end() 返回一个哨兵值（sentinel），这种模式在处理流式数据或异步数据源时尤为常见。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span> &#123;</span><br><span class="line">    <span class="type">int</span> start, end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> <span class="type">int</span>&amp; sentinel) <span class="type">const</span> &#123; <span class="keyword">return</span> value != sentinel; &#125;</span><br><span class="line">        Iterator&amp; <span class="keyword">operator</span>++() &#123; ++value; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">        <span class="type">int</span> <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">Iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> &#123;start&#125;; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> end; &#125; <span class="comment">// 返回哨兵</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x : Range&#123;<span class="number">0</span>, <span class="number">5</span>&#125;) &#123;</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出: 0 1 2 3 4</span></span><br></pre></td></tr></table></figure>

<h2 id="临时范围表达式初始化语句"><a href="#临时范围表达式初始化语句" class="headerlink" title="临时范围表达式初始化语句"></a>临时范围表达式初始化语句</h2><p>C++20允许在范围声明之前可以先执行初始化语句</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt; ints=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;<span class="keyword">auto</span> i:ints)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现一个支持基于范围的for循环的类"><a href="#实现一个支持基于范围的for循环的类" class="headerlink" title="实现一个支持基于范围的for循环的类"></a>实现一个支持基于范围的for循环的类</h2><p>条件</p>
<ul>
<li>该类型必须有一组和其类型相关的begin和end函数,他们可以是类的成员函数也可以是独立函数</li>
<li>begin和end函数需要返回一组类似迭代器的对象,并且这组对象必须支持<code>operator*</code>,<code>operator!=</code>和<code>operator++</code>运算符符号</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义Range类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Range</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Range</span>(<span class="type">int</span> start, <span class="type">int</span> end) : <span class="built_in">start_</span>(start), <span class="built_in">end_</span>(end) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始迭代器</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> start_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结束迭代器</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> end_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> start_;</span><br><span class="line">    <span class="type">int</span> end_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个Range对象</span></span><br><span class="line">    <span class="function">Range <span class="title">r</span><span class="params">(<span class="number">1</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用基于范围的for循环遍历Range对象</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : r) &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们定义了一个名为Range的类，它包含了开始和结束范围。通过在Range类中实现begin()和end()方法，我们使得Range对象可以被用于基于范围的for循环。在主函数中，我们创建了一个Range对象r，并使用基于范围的for循环遍历了这个Range对象并输出了结果。</p>
<h1 id="支持初始化语句的if和switch"><a href="#支持初始化语句的if和switch" class="headerlink" title="支持初始化语句的if和switch"></a>支持初始化语句的if和switch</h1><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><p>从C++17开始,if和switch支持初始化语句</p>
<p>基本语法: <code>if(init;condition)&#123;&#125;</code></p>
<blockquote>
<p>初始化语句中声明的变量生命周期将会伴随整个if-else代码块</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="type">bool</span> b=<span class="built_in">foo</span>();b)&#123;</span><br><span class="line"> 		<span class="comment">//... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常用方法:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mutex mx;<span class="comment">//互斥锁</span></span><br><span class="line"><span class="type">bool</span> shared_flag=<span class="literal">true</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="comment">//std::lock_guard&lt;std::mutex&gt; lock(mx) 这行代码创建了一个 lock_guard 对象，它会在构造时锁住 mx 所表示的 mutex 对象，然后在作用域结束时自动释放锁.这代码使整个if作用域内对共享资源的访问是互斥的</span></span><br><span class="line">		<span class="keyword">if</span>(lock_guard&lt;mutex&gt; <span class="built_in">lock</span>(mx);shared_flag)&#123;<span class="comment">//</span></span><br><span class="line">   		shared_flag=<span class="literal">false</span>; </span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p>基本语法:<code>swtich(init;condition)&#123;&#125;</code></p>
<h1 id="static-assert声明"><a href="#static-assert声明" class="headerlink" title="static_assert声明"></a>static_assert声明</h1><blockquote>
<p>[[C++基础#断言|运行时断言（runtime assert）]]是在 <code>&lt;cassert&gt;</code>头文件中引入的,运行时断言是一种在运行时检查条件是否为真的机制，如果条件为假，程序将以错误消息终止。</p>
</blockquote>
<p>运行时断言的缺点,只有在程序运行到断言出才能给出断言的判断</p>
<p>因此,<strong>C++11引入了static_assert声明</strong>  (编译阶段就能确定正确与否)</p>
<p><strong>静态断言用于在程序编译阶段评估常量表达式,并对返回false的表达式断言</strong></p>
<p>对静态断言的要求</p>
<ul>
<li>所有处理必须在编译期间执行,不允许有空间或时间上的运行时成本</li>
<li>必须具有简单的语法</li>
<li>断言失败可以显示丰富的错误诊断信息</li>
<li>可以在命名空间,类或代码块内使用</li>
<li>失败的断言会在编译阶段报错</li>
</ul>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>基本语法: <code>static_assert(常量表达式,诊断消息字符串);</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>)&gt;=<span class="number">4</span>,<span class="string">&quot;sizeof(int)&gt;=4&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>常量表达式为假的时候,终止程序并打印诊断消息字符串</p>
<h2 id="单参数static-assert"><a href="#单参数static-assert" class="headerlink" title="单参数static_assert"></a>单参数static_assert</h2><p>C++17标准支持单参数static_assert,即不用传参诊断消息字符串,函数内部默认为常量表达式的字符串本身</p>
<h1 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h1><p><code>std::lock_guard</code>和<code>std::mutex</code>都是C++11引入的内容，因此它们通常可以在<code>&lt;mutex&gt;</code>头文件中找到。因此，为了使用<code>std::lock_guard</code>和<code>std::mutex</code>，您需要包含<code>&lt;mutex&gt;</code>头文件。</p>
<h1 id="default-delete"><a href="#default-delete" class="headerlink" title="&#x3D;default&#x2F;&#x3D;delete"></a>&#x3D;default&#x2F;&#x3D;delete</h1><p>C++11引入<code>=default</code>,<code>=delete</code></p>
<blockquote>
<p>C++标准允许编译器为类自动添加一些函数,这些函数被称为:<strong>类的特殊成员函数</strong>,如下:</p>
<ul>
<li>默认构造函数</li>
<li>析构函数</li>
<li>拷贝构造函数</li>
<li>拷贝赋值运算符</li>
<li><a href="#%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8A%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E5%87%BD%E6%95%B0">移动构造函数</a></li>
<li><a href="#%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8A%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E5%87%BD%E6%95%B0">移动赋值运算符</a></li>
</ul>
<p><strong>声明任何构造函数都会抑制默认构造函数的添加</strong>,上面除了析构函数之外,其余的都是构造函数(Big-Five)</p>
</blockquote>
<p>如果你加上<code>=default</code>,编译器就会给你生成(如果有的话)一个默认版本.如果加上<code>=delete</code>表示不要编译器给我生成默认版本</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Zoo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Zoo</span>(<span class="type">int</span> i1,<span class="type">int</span> i2):<span class="built_in">d1</span>(i1),<span class="built_in">d2</span>(i2)&#123;&#125;</span><br><span class="line">  <span class="comment">//拷贝构造函数</span></span><br><span class="line">  <span class="built_in">Zoo</span>(<span class="type">const</span> Zoo&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">  <span class="comment">//move构造函数   右值引用 </span></span><br><span class="line">  <span class="built_in">Zoo</span>(Zoo&amp;&amp;)=<span class="keyword">default</span>;</span><br><span class="line">  <span class="comment">//拷贝赋值函数</span></span><br><span class="line">  Zoo&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Zoo&amp;)=<span class="keyword">default</span>;</span><br><span class="line">  <span class="comment">//move赋值函数</span></span><br><span class="line">  Zoo&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Zoo&amp;&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Zoo</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> d1,d2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>C++类中会给函数的无参构造函数,拷贝构造函数,拷贝赋值构造函数自动生成默认版本的定义(浅拷贝),在C++2.0后多了两种会自动生成的构造函数,总共五种(俗称Big-Five).</p>
<p>p.s. 这种默认生成的构造函数全是public且inline的</p>
</blockquote>
<ul>
<li><code>=default</code>用于Big-Five之外是无意义的</li>
<li><code>=delete</code>可用于任何函数身上(p.s. <code>=0</code>只能用于virtual函数</li>
</ul>
<p>注意:不要同时使用<code>explicit</code>和<code>=delete</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">type</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">type</span>(<span class="type">long</span> <span class="type">long</span>)&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">type</span><span class="params">(<span class="type">long</span>)</span></span>=<span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(type)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">foo</span>(<span class="built_in">type</span>(<span class="number">58L</span>));<span class="comment">//此句无法编译通过,因为显示调用,执行了explicit type(long)=delete;函数,却被delete掉了</span></span><br><span class="line">  <span class="built_in">foo</span>(<span class="number">50L</span>);<span class="comment">//此句可以编译通过</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h1 id="非受限联合类型"><a href="#非受限联合类型" class="headerlink" title="非受限联合类型"></a>非受限联合类型</h1><p>[[C语言入门#共用体(联合体)|传统联合类型]]的成员类型不能是一个非平凡类型(成员类型不能有自定义的构造函数)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">U</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x1;</span><br><span class="line">  <span class="type">float</span> x2;</span><br><span class="line">  string x3;<span class="comment">//无法编译通过</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>于是C++20以后,非受限联合类型得到了支持,若联合类型中存在非平凡类型,则该联合体的构造和析构函数将被隐式删除,<strong>必须在联合体中定义构造和析构函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">U</span>&#123;</span><br><span class="line">  <span class="built_in">U</span>():<span class="built_in">x3</span>()&#123;&#125;<span class="comment">//存在非平凡类型成员,必须提供构造函数</span></span><br><span class="line">  ~<span class="built_in">U</span>()&#123;x<span class="number">3.</span>~<span class="built_in">basic_string</span>();&#125;<span class="comment">//存在非平凡类型成员,必须提供析构函数</span></span><br><span class="line">  <span class="type">int</span> x1;</span><br><span class="line">  <span class="type">float</span> x2;</span><br><span class="line">  string x3;<span class="comment">//非平凡类型</span></span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; x4;<span class="comment">//非平凡类型</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	U u;</span><br><span class="line">  u.x3 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">  cout&lt;&lt;u.x3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样可以保证使用x3没有问题,但使用其他成员又怎么办呢?此处使用[[C++基础#placement new机制|placement new机制]]来初始化构造x3和x4</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">U</span>&#123;</span><br><span class="line">  <span class="built_in">U</span>():<span class="built_in">x3</span>()&#123;&#125;<span class="comment">//什么都不做</span></span><br><span class="line">  ~<span class="built_in">U</span>()&#123;&#125;</span><br><span class="line">  <span class="type">int</span> x1;</span><br><span class="line">  <span class="type">float</span> x2;</span><br><span class="line">  string x3;<span class="comment">//非平凡类型</span></span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; x4;<span class="comment">//非平凡类型</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//使用x3</span></span><br><span class="line"> 	U u;</span><br><span class="line">  <span class="keyword">new</span>(&amp;u.x3) <span class="built_in">string</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">  cout&lt;&lt;u.x3&lt;&lt;endl;</span><br><span class="line">  u.x<span class="number">3.</span>~<span class="built_in">basic_string</span>();<span class="comment">//手动调用析构函数</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//使用x4</span></span><br><span class="line">  <span class="keyword">new</span>(&amp;u.x4) vector&lt;<span class="type">int</span>&gt;;</span><br><span class="line">  u.x<span class="number">4.</span><span class="built_in">push_back</span>(<span class="number">58</span>);</span><br><span class="line">  cout&lt;&lt;u.x4[<span class="number">0</span>]&lt;&lt;endl;</span><br><span class="line">  u.x<span class="number">4.</span>~<span class="built_in">vector</span>();<span class="comment">//手动调用析构函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>C++中的联合类型使用率过低,了解即可</p>
</blockquote>
<h1 id="uncaught-exceptions"><a href="#uncaught-exceptions" class="headerlink" title="uncaught_exceptions"></a>uncaught_exceptions</h1><p><code>std::uncaught_exceptions()</code> 在 C++17 中引入，用于获取当前存在的未捕获异常的数量。这个功能常在析构函数、资源管理类或执行清理操作时用于防止在异常处理中再抛异常。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileWriter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">FileWriter</span><span class="params">(<span class="type">const</span> std::string&amp; filename)</span> : file(filename) &#123;</span></span><br><span class="line">        <span class="keyword">if</span> (!file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to open file&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">const</span> std::string&amp; content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;File not open&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        file &lt;&lt; content &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">FileWriter</span>() &#123;</span><br><span class="line">        <span class="comment">// 检查是否有未捕获的异常</span></span><br><span class="line">        <span class="keyword">if</span> (std::<span class="built_in">uncaught_exceptions</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果存在未捕获的异常，仅做清理，不抛出异常</span></span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Destructor called during stack unwinding. Suppressing exceptions.\n&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 若无未捕获异常，正常关闭文件，可能抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">                file.<span class="built_in">close</span>();</span><br><span class="line">                <span class="keyword">if</span> (file.<span class="built_in">fail</span>()) &#123;</span><br><span class="line">                    std::cerr &lt;&lt; <span class="string">&quot;Failed to close file\n&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::ofstream file;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testFileWriter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="function">FileWriter <span class="title">writer</span><span class="params">(<span class="string">&quot;example.txt&quot;</span>)</span></span>;</span><br><span class="line">        writer.<span class="built_in">write</span>(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">        <span class="comment">// 强制引发异常</span></span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Something went wrong&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception caught: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">testFileWriter</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="noexcept"><a href="#noexcept" class="headerlink" title="noexcept"></a>noexcept</h1><p>C++11 为了替代 <code>throw() 用于函数声明的异常规范功能</code>而提出的一个新的关键字<code>noexcept</code></p>
<blockquote>
<p><a href="#%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89">移动语义</a>出来之前,throw就够用了,移动语义有个问题就是出现异常的时候会导致移动的对象和被移动的对象都出问题,<a href="#%E7%94%A8noexcept%E8%A7%A3%E5%86%B3%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E9%97%AE%E9%A2%98">解决方式</a></p>
</blockquote>
<p>关键词: <code>noexcept(常量表达式)</code> </p>
<p>常量表达式的结果会被转换成一个 bool 类型的值，该值为 true，表示函数不会抛出异常，反之则能抛出异常。而不带常量表达式的 noexcept相当于声明了 noexcept(true)，即不会抛出异常。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="comment">//上下两种方式相等:表示一定没有异常</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="literal">true</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>noexcept作为运算符的情况(noexcept不仅仅是说明符,也是运算符)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">noexcept</span></span>&#123;<span class="keyword">return</span> <span class="number">42</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo1</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">42</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo2</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">42</span>;&#125;</span><br><span class="line">cout&lt;&lt;<span class="built_in">noexcept</span>(<span class="built_in">foo</span>())&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="built_in">noexcept</span>(<span class="built_in">foo1</span>())&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="built_in">noexcept</span>(<span class="built_in">foo2</span>())&lt;&lt;endl;</span><br><span class="line"><span class="comment">//输出:</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//0</span></span><br><span class="line"><span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>noexcept 可以用来阻止异常的传播和扩散</p>
</li>
<li><p>noexcept 作用于模板时，则增强了 c++ 的泛型编程的能力</p>
</li>
<li><p>noexcept 更大的用处就是保证程序的安全。</p>
<p>因此出于安全考虑,C++11 标准中类的析构函数默认为 <code>noexcept(true)</code>。但是，如果程序员显式地为析构函数指定了<br><code>noexcept(false)</code> 或者类的基类或成员有 <code>noexcept(false)</code> 的析构函数，析构函数就不会再保持默认值。</p>
</li>
<li><p>提高效率</p>
<p>移动构造函数默认为 <code>noexcept(true)</code>,可以去除一些异常处理机制,提高效率</p>
</li>
</ul>
<p>带参数语法:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">copy</span><span class="params">(<span class="type">const</span> T&amp;o)</span></span></span><br><span class="line"><span class="function"><span class="title">noexcept</span><span class="params">(is_fundamental&lt;T&gt;::value)</span></span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="用noexcept解决移动构造问题"><a href="#用noexcept解决移动构造问题" class="headerlink" title="用noexcept解决移动构造问题"></a>用noexcept解决移动构造问题</h2><p>阻止会抛出异常的移动</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单粗暴:直接让移动有风险的对象代码直接编译阶段报错</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(T&amp; a,T&amp; b)</span> <span class="title">noexcept</span></span></span><br><span class="line"><span class="function"><span class="params">(<span class="keyword">noexcept</span>(T(move(a))) &amp;&amp;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">noexcept</span>(a.<span class="keyword">operator</span>=(move(b))))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">static_assert</span>(<span class="built_in">noexcept</span>(<span class="built_in">T</span>(<span class="built_in">move</span>(a))) &amp;&amp; <span class="built_in">noexcept</span>(a.<span class="keyword">operator</span>=(<span class="built_in">move</span>(b))));</span><br><span class="line">  <span class="function">T <span class="title">tmp</span><span class="params">(move(a))</span></span>;</span><br><span class="line">  a=<span class="built_in">move</span>(b);</span><br><span class="line">  b-<span class="built_in">move</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//总体来说，这段代码实现了一个泛型的交换函数 `swap`，并使用静态断言和 `noexcept` 关键字来确保交换操作的安全性和效率。</span></span><br></pre></td></tr></table></figure>

<p>更聪明的方法:让编译器自己选择更适合的版本</p>
<blockquote>
<p>一个泛型 <code>swap</code> 函数，它根据类型 <code>T</code> 是否支持无异常移动语义来决定采用不同的交换策略:优先采用移动语义以提高效率，同时确保在移动操作可能抛出异常的情况下能够回退到安全但可能较慢的拷贝交换方式。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过移动交换（move-based swap）</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap_impl</span><span class="params">(T&amp; a,T&amp; b,integral_constant&lt;<span class="type">bool</span>,<span class="literal">true</span>&gt;)</span> <span class="keyword">noexcept</span></span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">tmp</span><span class="params">(move(a))</span></span>;</span><br><span class="line">    a = <span class="built_in">move</span>(b);</span><br><span class="line">    b = <span class="built_in">move</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过拷贝交换（copy-based swap）</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap_impl</span><span class="params">(T&amp; a,T&amp; b,integral_constant&lt;<span class="type">bool</span>,<span class="literal">false</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">tmp</span><span class="params">(a)</span></span>;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(T&amp; a,T&amp; b,integral_constant&lt;<span class="type">bool</span>,<span class="literal">false</span>&gt;)</span></span></span><br><span class="line"><span class="function"><span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(swap_impl(a,b,integral_constant&lt;<span class="type">bool</span>,<span class="keyword">noexcept</span>(T(move(a))) &amp;&amp; <span class="keyword">noexcept</span>(a.<span class="keyword">operator</span>=(move(b)))&gt;())))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">swap_impl</span>(a,b,<span class="built_in">integral_constant</span>&lt;<span class="type">bool</span>,<span class="built_in">noexcept</span>(<span class="built_in">T</span>(<span class="built_in">move</span>(a)))</span><br><span class="line">    &amp;&amp; <span class="built_in">noexcept</span>(a.<span class="keyword">operator</span>=(<span class="built_in">move</span>(b)))&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>std::integral_constant</code> 是 C++ 标准库中定义的一个模板类，它主要用于模板元编程。这个类模板的主要作用是存储编译期已知的、类型为 <code>T</code> 的常量值，并且可以通过其 <code>value</code> 成员变量在运行时访问该常量。</p>
</blockquote>
<h2 id="noexcept和throw的差别"><a href="#noexcept和throw的差别" class="headerlink" title="noexcept和throw的差别"></a>noexcept和throw的差别</h2><ol>
<li>C++11:相同的结果,不同的机制</li>
<li>C++17:相同的结果和机制</li>
<li>C++20:throw被移除</li>
</ol>
<h2 id="默认使用noexcept的函数"><a href="#默认使用noexcept的函数" class="headerlink" title="默认使用noexcept的函数"></a>默认使用noexcept的函数</h2><p>五大会自动生成的函数(big-five),都会默认使用noexcept</p>
<ul>
<li>类型默认构造函数</li>
<li>默认拷贝构造函数</li>
<li>默认赋值函数</li>
<li>默认移动构造函数</li>
<li>默认移动赋值函数.</li>
</ul>
<p>另外,上面对应的<strong>这些函数在类型的基类和成员中也具有noexcept声明</strong></p>
<p>另外还有默认带有noexcept声明的函数:</p>
<ul>
<li><strong>类的析构函数</strong></li>
<li>delete运算符(用于释放 <code>new </code>运算符分配的内存空间)</li>
</ul>
<h2 id="使用noexcept的时机"><a href="#使用noexcept的时机" class="headerlink" title="使用noexcept的时机"></a>使用noexcept的时机</h2><ul>
<li>一定不会出现异常的函数</li>
<li>函数虽然可能抛出异常,但是这是绝对不能接受的,否者程序应该直接终止(比如<a href="#%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8A%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E5%87%BD%E6%95%B0">类中的移动相关函数</a>)</li>
</ul>
<h2 id="异常规范作为类型的一部分"><a href="#异常规范作为类型的一部分" class="headerlink" title="异常规范作为类型的一部分"></a>异常规范作为类型的一部分</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span>(*fp)() <span class="keyword">noexcept</span>=<span class="literal">nullptr</span>;<span class="comment">//定义noexcpt的函数指针变量为fp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="type">int</span> main*()</span><br><span class="line">&#123;</span><br><span class="line">  fp=&amp;foo;<span class="comment">//c++17之前通过编译,c++17及以后的标准无法通过编译</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="override-final"><a href="#override-final" class="headerlink" title="override&#x2F;final"></a>override&#x2F;final</h1><h2 id="override"><a href="#override" class="headerlink" title="override"></a>override</h2><blockquote>
<p>用于让编译器<strong>检查是否符合重写规则</strong></p>
</blockquote>
<p>应用在虚函数身上,表示对虚函数的覆写&#x2F;改写&#x2F;重写</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vfunc</span><span class="params">(<span class="type">int</span>)</span> <span class="keyword">override</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><strong>重载</strong>(overload),通常是指在同一个类中有两个或两个以上的函数,函数名相同,但函数签名不同,即有不同的形参</li>
<li><strong>重写</strong>(override),意思更接近覆盖,指派生类覆盖了基类的虚函数</li>
<li><strong>隐藏</strong>(overwrite),指基类成员函数,无论他是否为虚函数,当派生类出现同名函数时<ul>
<li>若派生类函数签名不同于基类函数,则基类函数会被<strong>隐藏</strong></li>
<li>若派生类函数签名与基类函数相同,则需要确认基类函数是否为虚函数<ul>
<li>若为虚函数,就是<strong>重写</strong></li>
<li>否则就是<strong>隐藏</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">some_func</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">bar</span><span class="params">()</span> <span class="type">const</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">baz</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  	<span class="comment">//下面四个全都报错为:使用 “override”声明的成员函数不能重写基类成员</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">sone_func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125;<span class="comment">//想要重写但拼写错误</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>&amp; x)</span> <span class="keyword">override</span> </span>&#123;&#125;<span class="comment">//函数签名不一致</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">bar</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125;<span class="comment">//函数签名不一致</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">baz</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125;<span class="comment">//不是虚函数,不是重载</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>可以用于声明虚函数,也可以用于声明类</p>
<h3 id="声明类"><a href="#声明类" class="headerlink" title="声明类"></a>声明类</h3><p><strong>阻止类被作为基类</strong>,表明为最终继承类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base1</span> <span class="keyword">final</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived1</span>:Base1&#123;&#125;;<span class="comment">//Error cannot derive from &#x27;final&#x27; base &#x27;Base1&#x27; in derived type &#x27;Derived1&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="声明虚函数"><a href="#声明虚函数" class="headerlink" title="声明虚函数"></a>声明虚函数</h3><p><strong>阻止派生类函数去继承此类的虚函数</strong></p>
<p>表明为最终覆写虚函数,不能再往下覆写了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base2</span>:Base&#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">final</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived2</span>: Base2&#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;<span class="comment">//Error:overriding final function &#x27;virtual void Base2::f()&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="局部数组可用变量初始化大小"><a href="#局部数组可用变量初始化大小" class="headerlink" title="局部数组可用变量初始化大小"></a>局部数组可用变量初始化大小</h1><p>C++11之后使局部数组可以直接使用变量初始化大小</p>
<blockquote>
<p>原本,**编译时常量（compile-time constant)**就可以为变量初始化大小</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> __Tp,<span class="type">size_t</span> _Nm&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">myArray</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp</span><br><span class="line">    <span class="keyword">typedef</span> __Tp*</span><br><span class="line">    <span class="keyword">typedef</span> value_type*</span><br><span class="line">    value_type _M_instance[_Nm ? _Nm:<span class="number">1</span>];</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">return</span> <span class="built_in">iterator</span>(&amp;_M_instance[<span class="number">0</span>];&#125;</span><br><span class="line">    iterator <span class="built_in">end</span>()</span><br><span class="line">    &#123;<span class="keyword">return</span> <span class="built_in">iterator</span>(&amp;_M_instance[_Nm]);&#125;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<p><code>_Nm</code> 是一个模板参数，它在编译时就已经确定了值，因此可以用来初始化类的成员变量的数组长度</p>
<p>这样使用是合法的:<code>myArray&lt;int, 5&gt; arr; *// 使用编译时常量 5 初始化数组长度</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这样使用是合法的:</span></span><br><span class="line">myArray&lt;<span class="type">int</span>, <span class="number">5</span>&gt; arr; <span class="comment">// 使用编译时常量 5 初始化数组长度`</span></span><br><span class="line"><span class="comment">//这样使用是非法的:</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">5</span>;</span><br><span class="line">myArray&lt;<span class="type">int</span>, n&gt; arr; <span class="comment">// 错误：n 不是一个编译时常量</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>现在支持如下语法:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b[a];</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>但注意<strong>只能在函数内部定义的数组中使用，不能作为类的成员变量或全局变量使用。</strong></p>
</blockquote>
<h1 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h1><blockquote>
<p>用于获取表达式的类型</p>
</blockquote>
<p>在c++1.0中可以通过<code>typeid</code>得到类型名的一串字符串</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> std::type_info&amp; type = <span class="built_in">typeid</span>(num);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Type: &quot;</span> &lt;&lt; type.<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p><strong>但是获取到的类型只是字符串,无法真正使用该类型</strong>,并且各编译器返回的字符串还不相同</p>
<p>虽然彼时C++有些编译器支持typeof可以实现此功能,但并非标准</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">typeof</span>(a) b=<span class="number">5</span>;</span><br><span class="line"><span class="comment">//上面这行等价于int b=5;</span></span><br></pre></td></tr></table></figure>

<p><strong>decltype正是可以实现类似typeof的功能,并且同时具备完备的兼容性</strong></p>
<h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string,<span class="type">float</span>&gt; coll;</span><br><span class="line"><span class="keyword">decltype</span>(coll)::value_type elem;<span class="comment">//定义了一个与coll变量相同类型的变量elem</span></span><br><span class="line"><span class="comment">//在C++11之前上面代码可以理解成如下:</span></span><br><span class="line">map&lt;string,<span class="type">float</span>&gt;::value_type elem;</span><br></pre></td></tr></table></figure>

<h2 id="推导规则-1"><a href="#推导规则-1" class="headerlink" title="推导规则"></a>推导规则</h2><p>decltype(e)（其中e的类型为T）的推导规则有五条：</p>
<ol>
<li><p>如果e是一个<strong>未加括号的标识符表达式</strong>（结构化绑定除外）或者未加括号的类成员访问，则decltype(e)推断出的类型是e的类型T。如果并不存在这样的类型，或者e是一组重载函数，则无法进行推导。</p>
<p><em>潜台词就是下面其他规则都是带括号的e:</em></p>
</li>
<li><p>如果e是一个函数调用或者仿函数调用，那么<code>decltype(e)</code>推断出的类型是其返回值的类型</p>
</li>
<li><p>如果e是一个类型为T的左值，则<code>decltype(e)</code>是<code>T&amp;</code></p>
</li>
<li><p>如果e是一个类型为T的将亡值，则<code>decltype(e)</code>是<code>T&amp;&amp;</code></p>
</li>
<li><p>除去以上情况，则<code>decltype(e)</code>是<code>T</code></p>
</li>
</ol>
<p>CV限定符的推导</p>
<ul>
<li>通常情况下,<code>decltype(e)</code>所推导的类型会同步e的cv限定符</li>
<li>当e是<strong>未加括号的成员变量时</strong>,父对象表达式的cv限定符会被忽略</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>&amp;&amp; <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;</span><br><span class="line">  <span class="type">double</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> A* a=<span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">foo</span>());<span class="comment">//符合规则2,推导类型为const int&amp;&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(i);<span class="comment">//符合规则1,类型为int</span></span><br><span class="line"><span class="keyword">decltype</span>(a-&gt;x);<span class="comment">//符合规则1,类型为double,因为cv限定符规则的第二条,因此未同步对象a带有的const限定符</span></span><br><span class="line"><span class="keyword">decltype</span>((a-&gt;x));<span class="comment">//符合规则3,因为a-&gt;x是一个左值,又因为a带有const限定符,所以类型被推导为const double的引用类型,即const double&amp;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>decltype的类型如果想打印出来观察,可以配合typeid使用来观察</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_decltype</span><span class="params">(T x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;decltype(x): &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(<span class="keyword">decltype</span>(x)).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//比如int打印出来为i</span></span><br><span class="line"><span class="comment">//int*打印出来为pi</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="decltype和auto配合使用"><a href="#decltype和auto配合使用" class="headerlink" title="decltype和auto配合使用"></a>decltype和auto配合使用</h2><ul>
<li><p>用decltype的推导表达式规则来推导auto</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x1=(i);<span class="comment">//按照auto的推导规则:x1推导为int</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) x2=(i);<span class="comment">//按照decltype的推导规则:x2推导为int&amp;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>为非类型模板形参占位符</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">templatye&lt;<span class="keyword">decltype</span>(<span class="keyword">auto</span>) N&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout&lt;&lt;N&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="主要作用"><a href="#主要作用" class="headerlink" title="主要作用"></a>主要作用</h2><h3 id="声明返回类型"><a href="#声明返回类型" class="headerlink" title="声明返回类型"></a>声明返回类型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="title">decltype</span><span class="params">(x+y)</span> <span class="title">add</span><span class="params">(T1 x,T2 y)</span></span>;  <span class="comment">//返回类型为x+y后的结果的类型</span></span><br></pre></td></tr></table></figure>

<p>上面这种情况想要实现的效果编译无法通过,因为编译器从左到右识别到<code>x+y</code>的时候,他还不知道x和y是什么,因此编译报错:</p>
<p>C++2.O又出现了一种新语法,如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T1 x,T2 y)</span>-&gt;<span class="title">decltype</span><span class="params">(x+y)</span><span class="comment">//auto让编译器找类型,紧接着的-&gt;符号与编译器表明类型</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种语法和<a href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F">lambdas</a>定义的方式很像,下面是lambdas表达式的定义方式:<br>$$<br>\left[…\right]\left(…\right)\text{mutable}<em>{opt}\ \textit{ throwSpec}</em>{opt}\text{ -&gt; retType}_{opt}\left{…\right}<br>$$</p>
<h3 id="用于元编程"><a href="#用于元编程" class="headerlink" title="用于元编程"></a>用于元编程</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该函数针对容器</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test18_decltype</span><span class="params">(T obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//当我们手上有类型的时候,可以取其inner typedef</span></span><br><span class="line">	map&lt;string,<span class="type">float</span>&gt;::value_type elem1;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//面对对象可以取其类的类型,因为现在我们有了工具decltype</span></span><br><span class="line">  map&lt;string,<span class="type">float</span>&gt; coll;</span><br><span class="line">  <span class="keyword">decltype</span>(coll)::value_type elem2;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//下面是故意设计本测试函数为template function,接受任意参数T obj,假设他接受的是容器,获取他的类型又该如何获取</span></span><br><span class="line">  <span class="function"><span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="title">decltype</span><span class="params">(obj)</span>::iterator iType</span>;</span><br><span class="line">  <span class="comment">//由于编译器见到obj的时候还无法确定他是什么,所以要加typename辅助编译器认识decltype(obj)::iterator是个类型,然后使用typedef将该类型起别名为iType</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>value_type</code>是STL容器的一个成员类型别名，用于表示容器中存储的元素类型。在STL容器中，<code>value_type</code>通常用于定义容器内元素的类型，方便编写通用的泛型代码。另外针对map这种容器,还有<code>key_type</code>可以获取其键的类型</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vecs&#123;&#125;;</span><br><span class="line"><span class="keyword">decltype</span>(vecs)::value_type abc = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//取vector中元素的类型来定义变量</span></span><br></pre></td></tr></table></figure>

<h3 id="传递lambda表达式的类型"><a href="#传递lambda表达式的类型" class="headerlink" title="传递lambda表达式的类型"></a>传递lambda表达式的类型</h3><blockquote>
<p>面对<a href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F">lambda</a>,我们手上往往只有对象,没有类型,要获得其类型,就得借助于decltype</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> cmp=[](<span class="type">const</span> Person&amp; p1,<span class="type">const</span> Person&amp; p2)&#123;</span><br><span class="line">  <span class="keyword">return</span> p<span class="number">1.l</span>astname()&lt;p<span class="number">2.l</span>astname()||(p<span class="number">1.l</span>astname()==p<span class="number">2.l</span>astname()&amp;&amp;p<span class="number">1.f</span>irstname()&lt;p<span class="number">2.f</span>irstname());</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义set需要用到上面lambda表达式的类型</span></span><br><span class="line"><span class="function">set&lt;Person,<span class="title">decltype</span><span class="params">(cmp)</span>&gt; <span class="title">coll</span><span class="params">(cmp)</span></span>;</span><br><span class="line"><span class="comment">//创建一个名为`coll`的`set`容器对象，其中元素的类型是`Person`，使用`cmp`作为排序比较函数</span></span><br></pre></td></tr></table></figure>

<p>p.s. 如果传入的值不是lambda,报错会特别晦涩难懂(即上文中的coll括号中的cmp).对于自定义排序函数来说一个普通的函数还是更直观</p>
<h1 id="类型别名与别名模板"><a href="#类型别名与别名模板" class="headerlink" title="类型别名与别名模板"></a>类型别名与别名模板</h1><p>类似typedef</p>
<p>关键字:using   对该关键词赋予了新的意义</p>
<p>基本语法 <code>using identifier = type-id</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个func类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*func)</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span></span>;</span><br><span class="line">	<span class="comment">//等同于:</span></span><br><span class="line"><span class="keyword">using</span> func=<span class="built_in">void</span>(*)(<span class="type">int</span>,<span class="type">int</span>);</span><br></pre></td></tr></table></figure>

<p>这种语法超脱于typedef的地方就在于<a href="#%E5%88%AB%E5%90%8D%E6%A8%A1%E6%9D%BF">别名模板</a>,也是他诞生的原因</p>
<h2 id="别名模板"><a href="#别名模板" class="headerlink" title="别名模板"></a>别名模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Vec=std::vector&lt;T,MyAlloc&lt;T&gt;&gt;;</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">Vec&lt;<span class="type">int</span>&gt; coll;  <span class="comment">//这里的int类型被传入了别名模版中</span></span><br><span class="line">	<span class="comment">//与下面相等</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>,MyAlloc&lt;<span class="type">int</span>&gt;&gt; coll;</span><br></pre></td></tr></table></figure>

<p>使用<code>#define</code>和<code>typedef</code>无法达到类似的效果</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2//202401041615962.png" alt="image-20240104161539009" style="zoom:50%;" />

<p>用typedef只能达到这种程度</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">int_map</span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> map&lt;<span class="type">int</span>,T&gt; type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	int_map&lt;string&gt;::type int2string;</span><br><span class="line">  int2string[<span class="number">11</span>]=<span class="string">&quot;7&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是:别名模版不能[[C++基础#函数模特化|函数模板特化]]与[[C++基础#类模板特化|类模板特化]]</p>
<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><blockquote>
<p>Lambda看起来像一个函数,实际上是一个<strong>对象</strong></p>
</blockquote>
<p>C++11中的Lambda表达式**用于定义并创建匿名的 <a href="#%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%EF%BC%88%E9%9A%BE%E7%82%B9%EF%BC%89">函数对象</a>**，以简化编程工作。</p>
<blockquote>
<p>Lambda表达式最简形式:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面的函数是把lambda表达式写成内联函数(inline)</span></span><br><span class="line"><span class="comment">//其实是定义了一个类,定义该类的仿函数函数体如下代码,定义为这个类的对象,如果用变量接收,接收到的是一个匿名的函数对象</span></span><br><span class="line"><span class="keyword">auto</span> f=[]&#123;</span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;hello lambda&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用函数对象</span></span><br><span class="line"><span class="built_in">f</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//=======上面写法与下面写法等同=========  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个类并创建对象并且调用该函数对象的仿函数</span></span><br><span class="line">[]&#123;</span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;hello lambda&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>Lambda表达式完整构成</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[capture](parameters) <span class="keyword">mutable</span> -&gt;<span class="keyword">return</span>-type</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// function body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$$<br>\left[…\right]\left(…\right)\text{mutable}<em>{opt}\ \textit{ throwSpec}</em>{opt}\text{ -&gt; retType}_{opt}\left{…\right}<br>$$</p>
<blockquote>
<p>简单理解:</p>
<p>capture部分用于指定哪些变量应被捕获，并以何种方式捕获。捕获可以分为按值捕获（value capture）和按引用捕获（reference capture）。</p>
<p>最简单也最具代表性的两种用法:</p>
<ul>
<li>按值捕获是将外部变量的副本存储在lambda中  <code>[=]</code></li>
<li>按引用捕获是将外部变量的引用存储在lambda中  <code>[&amp;]</code></li>
</ul>
</blockquote>
<p><em>opt表示该项可选,三个可选项只要有一个存在,就必须写小括号</em></p>
<p>① 函数对象参数；</p>
<blockquote>
<p>[]，<strong>捕获列表</strong>:标识一个<strong>Lambda的开始</strong>，这部分必须存在，<strong>不能省略</strong>。函数对象参数是传递给编译器自动生成的函数对象类的构造函数的。函数对象参数只能使用那些到定义Lambda为止时<strong>Lambda所在作用范围内可见的局部变量</strong>（包括Lambda所在类的this）(这里指明局部变量的原因是因为全局变量本来就可以在类中被使用,如果使用全局变量或者static变量,一般会<strong>被编译器警告</strong>)。函数对象参数有以下形式：</p>
</blockquote>
<ul>
<li>空。没有使用任何函数对象参数。</li>
<li>&#x3D;。函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是<strong>值传递方式</strong>（相当于编译器自动为我们按值传递了所有局部变量）。</li>
<li>&amp;。函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是<strong>引用传递方式</strong>（相当于编译器自动为我们按引用传递了所有局部变量）。</li>
<li>this。函数体内可以使用Lambda所在类中的成员变量。</li>
<li>a。将a按值进行传递。按值进行传递时，函数体内不能修改传递进来的a的拷贝，因为默认情况下函数是const的。<strong>要修改传递进来的a的拷贝</strong>，可以添加mutable修饰符。</li>
<li>&amp;a。将a按引用进行传递。</li>
<li>a, &amp;b。将a按值进行传递，b按引用进行传递。</li>
<li>&#x3D;，&amp;a, &amp;b。除a和b按引用进行传递外，其他参数都按值进行传递。</li>
<li>&amp;, a, b。除a和b按值进行传递外，其他参数都按引用进行传递。</li>
</ul>
<p>C++14标准开始定义了<strong>广义捕获</strong>,分为下面两种</p>
<ul>
<li><p>简单捕获(上方介绍的为简单捕获)</p>
</li>
<li><p>初始化捕获</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">auto</span> foo=[r=x<span class="number">+1</span>]&#123;<span class="keyword">return</span> r;&#125;;</span><br><span class="line"><span class="comment">//r的作用域为lambda表达式中</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>② 操作符重载函数参数；</p>
<blockquote>
<p>标识重载的()操作符的参数，没有参数时，这部分可以省略。参数可以通过按值（如：(a,b)）和按引用（如：(&amp;a,&amp;b)）两种方式进行传递。注意是要带类型的,C++14开始类型还可以使用auto.</p>
</blockquote>
<p>③ 可修改标示符；</p>
<blockquote>
<p><code>mutable</code>声明，这部分可以省略。按值传递函数对象参数时，<strong>加上mutable修饰符后，才可以修改按值传递进来的拷贝</strong>（注意是能修改拷贝，而不是值本身）</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QPushButton * myBtn = <span class="keyword">new</span> <span class="built_in">QPushButton</span> (<span class="keyword">this</span>);</span><br><span class="line">QPushButton * myBtn2 = <span class="keyword">new</span> <span class="built_in">QPushButton</span> (<span class="keyword">this</span>);</span><br><span class="line">myBtn2-&gt;<span class="built_in">move</span>(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line"><span class="type">int</span> m = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">connect</span>(myBtn,&amp;QPushButton::clicked,<span class="keyword">this</span>,[m] ()<span class="keyword">mutable</span> &#123; m = <span class="number">20</span>; <span class="built_in">qDebug</span>() &lt;&lt; m; &#125;);</span><br><span class="line"><span class="built_in">connect</span>(myBtn2,&amp;QPushButton::clicked,<span class="keyword">this</span>,[=] () &#123; <span class="built_in">qDebug</span>() &lt;&lt; m; &#125;);</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; m;</span><br></pre></td></tr></table></figure>

<p>④ 函数返回值；</p>
<blockquote>
<p>-&gt;返回值类型，标识函数返回值的类型，当返回值为void，或者函数体中只有一处return的地方（此时编译器可以自动推断出返回值类型）时，这部分可以省略。</p>
</blockquote>
<p>⑤ 是函数体；</p>
<p>{}，标识函数的实现，这部分不能省略，但函数体可以为空。</p>
<p><strong>很重要的一点</strong>: <a href="#%E4%BC%A0%E9%80%92lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%B1%BB%E5%9E%8B">利用decltype获取lambda表达式的类型</a></p>
<h2 id="Lambdas的一些注意点"><a href="#Lambdas的一些注意点" class="headerlink" title="Lambdas的一些注意点"></a>Lambdas的一些注意点</h2><h3 id="无状态Lambda表达式"><a href="#无状态Lambda表达式" class="headerlink" title="无状态Lambda表达式"></a>无状态Lambda表达式</h3><p>从C++20开始,对于<strong>无状态Lambda表达式</strong>是可以构造和赋值的</p>
<p>即可以隐式转换为函数指针</p>
<p>解决了无法就地编写内嵌函数的尴尬问题</p>
<blockquote>
<p>捕捉上下文变量(即捕获列表<code>[]</code>中是否有东西)，不管实际函数体中有没有用到上下文变量，只要不活了上下文变量都属于<strong>有状态 lambda</strong> </p>
<p>在需要函数回调为参数的函数中非常有用</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">void</span>(*)())</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">f</span>([]&#123;&#125;;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="捕获-this-和-this"><a href="#捕获-this-和-this" class="headerlink" title="捕获[*this]和[&#x3D;,this]"></a>捕获[*this]和[&#x3D;,this]</h3><ul>
<li><code>[*this]</code>:拷贝this对象</li>
<li><code>[=,this]</code>:是为了区分<code>[=,*this]</code></li>
</ul>
<h3 id="模板语法的泛型lambda表达式"><a href="#模板语法的泛型lambda表达式" class="headerlink" title="模板语法的泛型lambda表达式"></a>模板语法的泛型lambda表达式</h3><p>从C++20开始,可以使用下面语法:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f=[]&lt;<span class="keyword">typename</span> T&gt;(vector&lt;T&gt; vector)&#123;&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="constexpr-lambda"><a href="#constexpr-lambda" class="headerlink" title="constexpr lambda"></a>constexpr lambda</h3><p>从C++17开始,lambda表达式在<strong>条件允许的情况下</strong>都会隐式声明为<code>constexpr</code></p>
<p>[详情跳转](#constexpr lambdas表达式)</p>
<h2 id="Lambdas案例细节"><a href="#Lambdas案例细节" class="headerlink" title="Lambdas案例细节"></a>Lambdas案例细节</h2><p>mutable值传递,引用传递,以及值传递,三种情况的比较如下: </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mutable值传递</span></span><br><span class="line"><span class="type">int</span> id = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [id]()<span class="keyword">mutable</span>&#123;</span><br><span class="line">  cout&lt;&lt;id&lt;&lt;endl;</span><br><span class="line">  ++id;</span><br><span class="line">&#125;;</span><br><span class="line">id = <span class="number">42</span>;</span><br><span class="line"><span class="built_in">f</span>();</span><br><span class="line"><span class="built_in">f</span>();</span><br><span class="line"><span class="built_in">f</span>();</span><br><span class="line">cout&lt;&lt;id&lt;&lt;endl;</span><br><span class="line"><span class="comment">//输出内容如下:</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//引用传递</span></span><br><span class="line"><span class="type">int</span> id = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [&amp;id]()&#123;</span><br><span class="line">  cout&lt;&lt;id&lt;&lt;endl;</span><br><span class="line">  ++id;</span><br><span class="line">&#125;;</span><br><span class="line">id = <span class="number">42</span>;</span><br><span class="line"><span class="built_in">f</span>();</span><br><span class="line"><span class="built_in">f</span>();</span><br><span class="line"><span class="built_in">f</span>();</span><br><span class="line">cout&lt;&lt;id&lt;&lt;endl;</span><br><span class="line"><span class="comment">//输出内容如下:</span></span><br><span class="line"><span class="number">42</span></span><br><span class="line"><span class="number">43</span></span><br><span class="line"><span class="number">44</span></span><br><span class="line"><span class="number">45</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//值传递</span></span><br><span class="line"><span class="type">int</span> id = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [id]()&#123;</span><br><span class="line">  cout&lt;&lt;id&lt;&lt;endl;</span><br><span class="line">  ++id;<span class="comment">//此处报错,不可修改</span></span><br><span class="line">&#125;;</span><br><span class="line">id = <span class="number">42</span>;</span><br><span class="line"><span class="built_in">f</span>();</span><br><span class="line"><span class="built_in">f</span>();</span><br><span class="line"><span class="built_in">f</span>();</span><br><span class="line">cout&lt;&lt;id&lt;&lt;endl;</span><br><span class="line"><span class="comment">//报错:[Error] increment of read-only variable &#x27;id&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="Lambdas原理"><a href="#Lambdas原理" class="headerlink" title="Lambdas原理"></a>Lambdas原理</h2><p> <strong>lambda 表达式出现的契机，正是用来代替被临时定义使用的可调用对象，我们可以把 lambda 表达式理解为一个未命名的函数，但他又不同于一般的函数，他有一个很大的特点就是可以捕获状态，但又不需要声明一个新的类来保存状态，而其实在编译器内部对 lambda 表达式的处理就是生成了一个未命名的类，并通过 lambda 表达式生成该未命名类的未命名函数对象。因此对于那些我们只要用一次的简短的函数或函数对象来说，利用 lambda 表达式能极大的增强代码的封装性和可读性</strong></p>
<p>lambda 表达式是一个<strong>函数对象</strong>，在定义一个 lambda 表达式的时候，相当于编译器为我们定义了一个临时的类，该类重载了函数调用运算符，同时对于引用捕获的变量，编译器无须在 lambda 产生的类中将其存储为数据成员,而只需要存储引用，而对于值捕获的变量，由于其需要被拷贝到 lambda 中，因此这种 lambda 产生的类就必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数。若将一个变量初始化为一个 lambda 表达式，则相当于初始化了一个该临时类的对象，而在调用的时候就相当于调用了该类的函数重载运算符</p>
<p>参考下面:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a) : <span class="built_in">v1</span>(a) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v1;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> v1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//相当于生成了上面👆🏻的类</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> v1 = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 编译器会生成一个类，类似于上面定义的类A</span></span><br><span class="line">    <span class="keyword">auto</span> f = [v1]()-&gt; <span class="type">int</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> v1;</span><br><span class="line">    &#125;;</span><br><span class="line">    v1++;</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="函数对象（难点）"><a href="#函数对象（难点）" class="headerlink" title="函数对象（难点）"></a>函数对象（难点）</h2><p>重载函数调用操作符的类，其对象常称为<strong>函数对象（function object）</strong>，即它们是行为类似函数的对象，也叫<strong>仿函数(functor)</strong>,其实就是重载“()”操作符，使得类对象可以像函数那样调用。</p>
<p>注意：</p>
<ol>
<li>函数对象(仿函数)是一个类，不是一个函数。</li>
<li>函数对象(仿函数)重载了”() ”操作符使得它可以像函数一样调用。</li>
</ol>
<p>分类:假定某个类有一个重载的operator()，而且重载的operator()要求获取一个参数，我们就将这个类称为“一元仿函数”（unary functor）；相反，如果重载的operator()要求获取两个参数，就将这个类称为“<strong>二元仿函数</strong>”（binary functor）。</p>
<p>函数对象的作用主要是什么？<strong>STL提供的算法往往都有两个版本，其中一个版本表现出最常用的某种运算，另一版本则允许用户通过template参数的形式来指定所要采取的策略。</strong></p>
<p><strong>注意: 定义函数对象类的时候,不能使用小括号定义(无论构造函数任何情况都是错的),如:<code>baz b();</code>,这样是错的,而应该是:<code>baz b;</code>,但如果存在带参构造函数,可以使用<code>baz b(123);</code>来定义</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数对象是重载了函数调用符号的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MyPrint</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_Num = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> m_Num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">		m_Num++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数对象</span></span><br><span class="line"><span class="comment">//重载了()操作符的类实例化的对象，可以像普通函数那样调用,可以有参数 ，可以有返回值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyPrint myPrint;</span><br><span class="line">	<span class="built_in">myPrint</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数对象超出了普通函数的概念，可以保存函数的调用状态</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyPrint myPrint;</span><br><span class="line">	<span class="built_in">myPrint</span>(<span class="number">20</span>);</span><br><span class="line">	<span class="built_in">myPrint</span>(<span class="number">20</span>);</span><br><span class="line">	<span class="built_in">myPrint</span>(<span class="number">20</span>);</span><br><span class="line">	cout &lt;&lt; myPrint.m_Num &lt;&lt; endl;<span class="comment">//调用次数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doBusiness</span><span class="params">(MyPrint print,<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">print</span>(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数对象作为参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//参数1：匿名函数对象</span></span><br><span class="line">	<span class="built_in">doBusiness</span>(<span class="built_in">MyPrint</span>(),<span class="number">30</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ol>
<li>函数对象通常不定义构造函数和析构函数，所以在构造和析构时不会发生任何问题，避免了函数调用的运行时问题。</li>
<li>函数对象超出普通函数的概念，函数对象可以有自己的状态</li>
<li>函数对象可内联编译，性能好。用函数指针几乎不可能</li>
<li>模版函数对象使函数对象具有通用性，这也是它的优势之一</li>
</ol>
<h3 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h3><blockquote>
<p>谓词是指<strong>普通函数</strong>或<strong>重载的operator()<strong>返回值是bool类型的函数对象(仿函数)。如果operator接受一个参数，那么叫做</strong>一元谓词</strong>,如果接受两个参数，那么叫做<strong>二元谓词</strong>，谓词可作为一个判断式。</p>
</blockquote>
<p><strong>一元谓词与二元谓词的案例：</strong>(含lambda表达式)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一元谓词</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GreaterThenFive</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> num)</span><span class="comment">//一元谓词</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> num &gt; <span class="number">5</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>;i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//该函数在&lt;algorithm&gt;中</span></span><br><span class="line">	 vector&lt;<span class="type">int</span>&gt;::iterator it =  <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">GreaterThenFive</span>());</span><br><span class="line">	 <span class="keyword">if</span> (it == v.<span class="built_in">end</span>())</span><br><span class="line">	 &#123;</span><br><span class="line">		 cout &lt;&lt; <span class="string">&quot;没有找到&quot;</span> &lt;&lt; endl;</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="keyword">else</span></span><br><span class="line">	 &#123;</span><br><span class="line">		 cout &lt;&lt; <span class="string">&quot;找到了: &quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二元谓词</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCompare</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span><span class="comment">//二元谓词</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> num1 &gt; num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">90</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//默认从小到大</span></span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>();it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;----------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//使用函数对象改变算法策略，排序从大到小</span></span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(),<span class="built_in">MyCompare</span>());<span class="comment">//MyCompare()匿名对象,也可以填回调函数</span></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//-----------------上面的遍历显示也可以用for_each函数----------------</span></span><br><span class="line">    <span class="comment">//for_each是遍历函数，其中的第三个参数时lambda表达式，本质上就是匿名函数。</span></span><br><span class="line">    <span class="comment">//lambda表达式：[]代表lambda表达式标志，()函数参数列表，&#123;&#125;函数体。</span></span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),[](<span class="type">int</span> val)&#123;cout&lt;&lt;val&lt;&lt;<span class="string">&quot; &quot;</span>;&#125;)</span><br><span class="line">    <span class="comment">//----------------------------------------------------------------</span></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内建函数对象"><a href="#内建函数对象" class="headerlink" title="内建函数对象"></a>内建函数对象</h3><p>STL内建了一些函数对象。分为:算数类函数对象,关系运算类函数对象，逻辑运算类仿函数。这些仿函数所产生的对象，用法和一般函数完全相同，当然我们还可以产生无名的临时对象来履行函数功能。使用内建函数对象，需要引入头文件#include<functional>。</p>
<ul>
<li>6个算数类函数对象,除了negate是一元运算，其他都是二元运算。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; T plus&lt;T&gt;<span class="comment">//加法仿函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; T minus&lt;T&gt;<span class="comment">//减法仿函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; T multiplies&lt;T&gt;<span class="comment">//乘法仿函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; T divides&lt;T&gt;<span class="comment">//除法仿函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; T modulus&lt;T&gt;<span class="comment">//取模仿函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; T negate&lt;T&gt;<span class="comment">//取反仿函数</span></span><br></pre></td></tr></table></figure>

<ul>
<li>6个关系运算类函数对象,每一种都是二元运算。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="type">bool</span> equal_to&lt;T&gt;<span class="comment">//等于</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="type">bool</span> not_equal_to&lt;T&gt;<span class="comment">//不等于</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="type">bool</span> greater&lt;T&gt;<span class="comment">//大于</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="type">bool</span> greater_equal&lt;T&gt;<span class="comment">//大于等于</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="type">bool</span> less&lt;T&gt;<span class="comment">//小于</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="type">bool</span> less_equal&lt;T&gt;<span class="comment">//小于等于</span></span><br></pre></td></tr></table></figure>

<ul>
<li>逻辑运算类运算函数,not为一元运算，其余为二元运算。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="type">bool</span> logical_and&lt;T&gt;<span class="comment">//逻辑与</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="type">bool</span> logical_or&lt;T&gt;<span class="comment">//逻辑或</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="type">bool</span> logical_not&lt;T&gt;<span class="comment">//逻辑非</span></span><br></pre></td></tr></table></figure>

<p>内建函数对象举例:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取反仿函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	negate&lt;<span class="type">int</span>&gt; n;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">n</span>(<span class="number">50</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加法仿函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	plus&lt;<span class="type">int</span>&gt; p;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">p</span>(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大于仿函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());<span class="comment">//大于仿函数</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数对象适配器"><a href="#函数对象适配器" class="headerlink" title="函数对象适配器"></a>函数对象适配器</h3><h4 id="函数对象适配器bind1st和bind2nd"><a href="#函数对象适配器bind1st和bind2nd" class="headerlink" title="函数对象适配器bind1st和bind2nd"></a>函数对象适配器bind1st和bind2nd</h4><blockquote>
<p>现在我有这个需求 在遍历容器的时候，我希望将容器中的值全部加上用户输入的数之后显示出来，怎么做？我们直接给函数对象绑定参数 编译阶段就会报错for_each(v.begin(), v.end(), bind2nd(myprint(),100));</p>
</blockquote>
<p>如果我们想使用绑定适配器,需要<strong>我们自己的函数对象继承 unary_function或者 binary_function根据我们函数对象是一元函数对象 还是二元函数对象</strong></p>
<p><strong>自己建的函数对象</strong>写bind1st bind2nd适配器要<strong>三个操作</strong>：</p>
<ol>
<li>利用bind1st或bind2nd进行绑定</li>
<li>继承public：binary_function&lt;参数1类型，参数2类型，返回值类型&gt;或 unary_function</li>
<li>加const</li>
</ol>
<p><strong>【注意】</strong>内建的函数对象不需要写这些2,3(其实想写也没法写，内置的嘛)。利用函数指针适配器和成员函数适配器转换成的函数对象也不需要写2,3（同样也没法写…）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span> :<span class="keyword">public</span> binary_function&lt;<span class="type">int</span>,<span class="type">int</span>,<span class="type">void</span>&gt;<span class="comment">//继承binary_function</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1,<span class="type">int</span> v2)</span> <span class="type">const</span><span class="comment">//const必须加</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;v1 = : &quot;</span> &lt;&lt; v1 &lt;&lt; <span class="string">&quot; v2 = :&quot;</span> &lt;&lt;v2  &lt;&lt; <span class="string">&quot; v1+v2 = :&quot;</span> &lt;&lt; (v1 + v2) &lt;&lt; endl;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//1、函数适配器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//由用户输入</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入起始值：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	cin &gt;&gt; x;</span><br><span class="line"></span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">bind1st</span>(<span class="built_in">MyPrint</span>(), x));<span class="comment">//绑定</span></span><br><span class="line">	<span class="comment">//for_each(v.begin(), v.end(), bind2nd( MyPrint(),x ));</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：  bind1st和bind2nd区别?</p>
<ol>
<li>bind1st ： 将参数绑定为函数对象的第一个参数</li>
<li>bind2nd ： 将参数绑定为函数对象的第二个参数</li>
</ol>
<p>bind1st bind2nd作用：<strong>将二元函数对象转为一元函数对象</strong></p>
<p>所以bind1st或bind2nd如果要和其他适配器嵌套，比如需要用的是not1，因为已经转换为一元函数对象</p>
<h4 id="取反适配器not1和not2"><a href="#取反适配器not1和not2" class="headerlink" title="取反适配器not1和not2"></a>取反适配器not1和not2</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GreaterThenFive</span>:<span class="keyword">public</span> unary_function&lt;<span class="type">int</span>,<span class="type">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="type">int</span> v)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v &gt; <span class="number">5</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、取反适配器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector &lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">// 	vector&lt;int&gt;::iterator it =  find_if(v.begin(), v.end(), GreaterThenFive()); //返回第一个大于5的迭代器</span></span><br><span class="line"><span class="comment">//	vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(),  not1(GreaterThenFive())); //返回第一个小于5迭代器</span></span><br><span class="line">	<span class="comment">//自定义输入（并且使用内建函数对象）</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">not1</span> ( <span class="built_in">bind2nd</span>(<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;(),<span class="number">5</span>)));</span><br><span class="line">	<span class="keyword">if</span> (it == v.<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;没找到&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//排序  二元函数对象</span></span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">not2</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;()));</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">int</span> val)&#123;cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//not1 对一元函数对象取反</span></span><br><span class="line"><span class="comment">//not2 对二元函数对象取反</span></span><br></pre></td></tr></table></figure>

<h4 id="函数指针适配器-ptr-fun"><a href="#函数指针适配器-ptr-fun" class="headerlink" title="函数指针适配器 ptr_fun"></a>函数指针适配器 ptr_fun</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyPrint03</span><span class="params">(<span class="type">int</span> v,<span class="type">int</span> v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; v + v2&lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、函数指针适配器   ptr_fun</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector &lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ptr_fun( )把一个普通的函数指针适配成函数对象</span></span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>( <span class="built_in">ptr_fun</span>( MyPrint03 ), <span class="number">100</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="成员函数适配器-mem-fun-ref和mem-fun"><a href="#成员函数适配器-mem-fun-ref和mem-fun" class="headerlink" title="成员函数适配器 mem_fun_ref和mem_fun"></a>成员函数适配器 mem_fun_ref和mem_fun</h4><ol>
<li>如果容器存放的是对象指针，  那么用mem_fun</li>
<li>如果容器中存放的是对象实体，那么用mem_fun_ref</li>
</ol>
<h5 id="mem-fun-ref"><a href="#mem-fun-ref" class="headerlink" title="mem_fun_ref"></a>mem_fun_ref</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		m_Name = name;</span><br><span class="line">		m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//打印函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;成员函数:&quot;</span> &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; m_Name &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Plus100</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_Age += <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyPrint04</span><span class="params">(Person &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt;  p.m_Name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector &lt;Person&gt;v;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">	v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p4);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//for_each(v.begin(), v.end(), MyPrint04);</span></span><br><span class="line">	<span class="comment">//利用 mem_fun_ref 将Person内部成员函数适配</span></span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">mem_fun_ref</span>(&amp;Person::ShowPerson));<span class="comment">//成员函数指针要&amp;Person::ShowPerson表示，和普通函数指针只要写函数名有区别</span></span><br><span class="line"><span class="comment">// 	for_each(v.begin(), v.end(), mem_fun_ref(&amp;Person::Plus100));</span></span><br><span class="line"><span class="comment">// 	for_each(v.begin(), v.end(), mem_fun_ref(&amp;Person::ShowPerson));</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="mem-fun"><a href="#mem-fun" class="headerlink" title="mem_fun"></a>mem_fun</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test05</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;Person*&gt; v1;</span><br><span class="line">	<span class="comment">//创建数据</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	v<span class="number">1.</span><span class="built_in">push_back</span>(&amp;p1);</span><br><span class="line">	v<span class="number">1.</span><span class="built_in">push_back</span>(&amp;p2);</span><br><span class="line">	v<span class="number">1.</span><span class="built_in">push_back</span>(&amp;p3);</span><br><span class="line">	v<span class="number">1.</span><span class="built_in">push_back</span>(&amp;p4);</span><br><span class="line"></span><br><span class="line">	for_each(v<span class="number">1.</span><span class="built_in">begin</span>(), v<span class="number">1.</span><span class="built_in">end</span>(), <span class="built_in">mem_fun</span>(&amp;Person::ShowPerson));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><blockquote>
<p>原理:智能指针主要用于管理在堆上分配的内存，它将普通的指针封装为一个栈对象。这意味着智能指针本身是在栈上的，但它所管理的内存是在堆上分配的。当智能指针本身被回收以后,会将智能指针上管理的内存释放</p>
<p>优点:</p>
<ol>
<li>自动内存管理：智能指针可以自动处理内存的分配和释放，避免了内存泄漏和悬空指针的问题。 </li>
<li>避免手动释放内存：使用智能指针可以避免手动释放内存的麻烦，减少了出错的可能性。</li>
<li>安全性：智能指针通常会在其生命周期结束时自动释放内存，避免了因忘记释放内存而导致的内存泄漏。</li>
<li>方便性：智能指针提供了类似于原始指针的使用方式，但又具有自动内存管理的功能，使得代码更加简洁和易读。</li>
</ol>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/memory">智能指针参考手册</a></p>
<p>头文件   <strong><code>#include &lt;memory&gt;</code></strong></p>
<p>智能指针的用途: 帮助管理内存,可以做到自动释放内存,避免忘记释放而造成内存泄露</p>
<ul>
<li><p><strong><code>shared_ptr</code></strong>   允许多个智能指针指向同一个空间,使用引用计数来跟踪资源的生命周期</p>
<p>多个类共享指针存在这么一个问题：每个类都存储了指针地址的一个拷贝，如果其中一个类删除了这个指针，其它类并不知道这个指针已经失效，此时就会出现野指针的现象。为了解决这一问题，我们可以使用引用指针来计数，仅当检测到引用计数为0时，才主动删除这个数据</p>
</li>
<li><p><strong><code>unique_ptr</code></strong>   只能一个智能指针指向同一个空间,不能进行复制或共享资源,可以通过移动语义转移资源所有权</p>
</li>
<li><p><strong><code>weak_ptr</code></strong>    <code>weak_ptr</code> 是为了配合 <code>shared_ptr</code> 而引入的一种智能指针，它指向一个由 <code>shared_ptr</code> 管理的对象而不影响所指对象的生命周期，也就是，将一个 <code>weak_ptr</code> 绑定到一个 <code>shared_ptr</code> 不会改变 <code>shared_ptr</code> 的引用计数。它是一种用于解决 <code>shared_ptr</code> <strong>循环引用</strong>时产生死锁问题的智能指针。</p>
<p>不拥有资源所有权，不能直接访问所管理的资源。</p>
<p>在功能上类似于普通指针，比较大的区别是，弱引用能检测到所管理的对象是否已经被释放，从而避免访问非法内存</p>
</li>
<li><p><code>auto_ptr</code>  在C++11中移除,已被<code>unique_ptr</code>取代</p>
</li>
</ul>
<p>使用 <code>std::make_shared </code>和 <code>std::make_unique</code>:这两个函数提供了一种更安全和高效的方式来创建智能指针，避免了手动调用 <code>new</code> </p>
<h2 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a>auto_ptr</h2><p>可以通过<code>lock()</code>函数获取一个有效的<code>std::shared_ptr</code>，如果原始的<code>std::shared_ptr</code> 已经释放了资源，则返回空指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="function">weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp</span><span class="params">(p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(shared_ptr&lt;<span class="type">int</span>&gt; np = wp.<span class="built_in">lock</span>())</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="auto-ptr的局限性"><a href="#auto-ptr的局限性" class="headerlink" title="auto_ptr的局限性"></a>auto_ptr的局限性</h3><h4 id="复制或者赋值都会改变资源的所有权"><a href="#复制或者赋值都会改变资源的所有权" class="headerlink" title="复制或者赋值都会改变资源的所有权"></a>复制或者赋值都会改变资源的所有权</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// auto_ptr 被C++11抛弃的主要原因</span></span><br><span class="line"><span class="function">auto_ptr&lt;string&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;I&#x27;m Li Ming!&quot;</span>))</span></span>;<span class="comment">//由于string类型本身支持释放自己,所以这个类型实际上没什么意义</span></span><br><span class="line"><span class="function">auto_ptr&lt;string&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;I&#x27;m age 22.&quot;</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1：&quot;</span> &lt;&lt; p<span class="number">1.</span><span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2：&quot;</span> &lt;&lt; p<span class="number">2.</span><span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// p2赋值给p1后，首先p1会先将自己原先托管的指针释放掉，然后接收托管p2所托管的指针，</span></span><br><span class="line"><span class="comment">// 然后p2所托管的指针制NULL，也就是p1托管了p2托管的指针，而p2放弃了托管。</span></span><br><span class="line">p1 = p2;	</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1 = p2 赋值后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1：&quot;</span> &lt;&lt; p<span class="number">1.</span><span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2：&quot;</span> &lt;&lt; p<span class="number">2.</span><span class="built_in">get</span>() &lt;&lt; endl;<span class="comment">//运行时报错:段错误,内存访问越界</span></span><br></pre></td></tr></table></figure>

<p>如果替换auto_ptr为unique_ptr,<code>p1 = p2;</code>在编译的时候会报错,因为unique_ptr中的拷贝赋值运算符是删除了的,若unique_ptr改为:<code>p1 = move(p2);</code>,那么会和上面案例一样报,内存访问越界问题,因为p2已经释放.</p>
<p>跟auto_ptr一样可以赋值,但是需要使用move修饰，<strong>使得程序员知道后果</strong></p>
<h4 id="不支持对象数组的内存管理"><a href="#不支持对象数组的内存管理" class="headerlink" title="不支持对象数组的内存管理"></a>不支持对象数组的内存管理</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt;<span class="type">int</span>[]&gt; <span class="title">array</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>])</span></span>;	<span class="comment">// 不能这样定义</span></span><br><span class="line"><span class="comment">//报错:没有与参数列表匹配的构造函数</span></span><br></pre></td></tr></table></figure>

<h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><p>C++11用更严谨的unique_ptr 取代了auto_ptr</p>
<ul>
<li>auto_ptr不支持移动语义</li>
<li>auto_ptr不支持对象数组的内存管理</li>
</ul>
<p>unique_ptr支持移动语义,并且支持对象数组的内存管理</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 会自动调用delete [] 函数去释放内存</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>[]&gt; <span class="title">array</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>])</span></span>;	<span class="comment">// 支持这样定义</span></span><br></pre></td></tr></table></figure>

<p>除了上面指出的两点外,unique_ptr的其余用法都与auto_ptr用法一致</p>
<h3 id="auto-ptr与unique-ptr智能指针的内存管理陷阱"><a href="#auto-ptr与unique-ptr智能指针的内存管理陷阱" class="headerlink" title="auto_ptr与unique_ptr智能指针的内存管理陷阱"></a>auto_ptr与unique_ptr智能指针的内存管理陷阱</h3><p>可以通过下面的方式破坏排他性</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;string&gt; p1;</span><br><span class="line">string *str = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;智能指针的内存管理陷阱&quot;</span>);</span><br><span class="line">p<span class="number">1.</span><span class="built_in">reset</span>(str); <span class="comment">// p1托管str指针</span></span><br><span class="line"></span><br><span class="line">unique_ptr&lt;string&gt; p2;</span><br><span class="line">p<span class="number">2.</span><span class="built_in">reset</span>(str); <span class="comment">// p2接管str指针时，会先取消p1的托管，然后再对str的托管</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//p1,p2都会在最后被释放,导致两次释放同一个对象的错误</span></span><br></pre></td></tr></table></figure>

<h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><p><strong>三种初始化方式</strong></p>
<p>以<code>shared_ptr</code>作为案例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接使用构造函数(括号里是赋予的初始值)</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">	<span class="comment">//由于接受指针参数的构造函数是explicit的，因此不能将指针隐式转换为shared_ptr:</span></span><br><span class="line">	shared_ptr&lt;<span class="type">int</span>&gt; p1 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>); <span class="comment">// err</span></span><br><span class="line"><span class="comment">//使用make_shared(括号里是赋予的初始值)</span></span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; ptr1 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//直接赋值(ptr1的内存空间引用计数会+1,prt2原本的内存空间引用计数会-1)</span></span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; ptr2 = ptr1;</span><br></pre></td></tr></table></figure>

<p>p.s.  <code>make_unique</code> 是 C++14 中引入的一个函数,编译时需要指定<code>-std=c++14</code></p>
<h3 id="常用api"><a href="#常用api" class="headerlink" title="常用api"></a>常用api</h3><ul>
<li><p><code>get()</code>: 获取指针值</p>
<p>虽然可以获得原始值,但我们不应该delete这一指针，也不应该用它赋值&#x2F;初始化另一个智能指针；当将原生指针传给shared_ptr后，就应该让shared_ptr接管这一指针，而不再直接操作原生指针。</p>
</li>
<li><p><code>use_count()</code>: 智能指向的内存的引用次数(有几个智能指针指向这块内存)</p>
</li>
<li><p><code>reset()</code>: 对智能指针进行重置操作,使智能指针原有的指向修改为新的指向,该函数会首先将原有的内存的引用计数减1,当减小到0的时候就会释放内存.其实就是重新赋值:<code>p.reset(new int(1024));</code></p>
</li>
</ul>
<p>使用swap可以交换两个智能指针管理的内存对象</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ul>
<li><p><code>shared_ptr&lt; T &gt; sp1;</code> 空的shared_ptr，可以指向类型为T的对象</p>
</li>
<li><p><code>shared_ptr&lt; T &gt; sp2(new T());</code> 定义shared_ptr,同时指向类型为T的对象</p>
</li>
<li><p><code>shared_ptr&lt;T[]&gt; sp4;</code> 空的shared_ptr，可以指向类型为T[]的数组对象 <strong>C++17后支持</strong></p>
</li>
<li><p><code>shared_ptr&lt;T[]&gt; sp5(new T[] &#123; … &#125;);</code> 指向类型为T的数组对象 <strong>C++17后支持</strong></p>
</li>
<li><p><code>shared_ptr&lt; T &gt; sp6(NULL, D());</code> &#x2F;&#x2F;空的shared_ptr，接受一个D类型的删除器，使用D释放内存</p>
<p>p.s. 这种情况仅用于自动执行释放操作</p>
</li>
<li><p><code>shared_ptr&lt; T &gt; sp7(new T(), D());</code> &#x2F;&#x2F;定义shared_ptr,指向类型为T的对象，接受一个D类型的删除器，使用D删除器来释放内存</p>
</li>
</ul>
<h3 id="使用智能指针管理对象数组"><a href="#使用智能指针管理对象数组" class="headerlink" title="使用智能指针管理对象数组"></a>使用智能指针管理对象数组</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AA是个类</span></span><br><span class="line"><span class="function">shared_ptr&lt;AA&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> AA[<span class="number">5</span>],[](AA *p)&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">delete</span>[] p;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;<span class="comment">//不加lamda参数的话,只会释放一个</span></span><br><span class="line"><span class="comment">//这种方式释放内存对unique_ptr不可用,编译器会报错,还是推荐用下面的方式</span></span><br><span class="line"><span class="function">shared_ptr&lt;AA[]&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> AA[<span class="number">5</span>])</span></span>;<span class="comment">//这样的话也就可以释放全部对象数组</span></span><br></pre></td></tr></table></figure>

<p>智能指针可以像普通指针那样使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//智能指针test</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;test-&gt;debug：&quot;</span> &lt;&lt; test-&gt;<span class="built_in">getDebug</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;(*test).debug：&quot;</span> &lt;&lt; (*test).<span class="built_in">getDebug</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>可以像普通指针那样使用的原因在于:因为其里面重载了 <code>*</code> 和 <code>-&gt;</code> 运算符， <code>*</code> 返回普通对象(<code>return (*get())</code>)，而 <code>-&gt;</code> 返回指针对象(<code>return get()</code>)</p>
<h3 id="shared-ptr工作原理"><a href="#shared-ptr工作原理" class="headerlink" title="shared_ptr工作原理"></a>shared_ptr工作原理</h3><p><code>std::shared_ptr</code> 是一种智能指针，它使用引用计数的方式来自动管理所指向对象的生命周期。当多个 <code>shared_ptr</code> 共享同一个对象时，它们会共同维护一个引用计数。主要规则如下：</p>
<ul>
<li>创建一个 <code>shared_ptr</code> 时，初始引用计数为 1。</li>
<li>当一个 <code>shared_ptr</code> 被复制或拷贝赋值给另一个 <code>shared_ptr</code> 时，目标 <code>shared_ptr</code> 会增加源 <code>shared_ptr</code> 所指向对象的引用计数。</li>
<li>当一个 <code>shared_ptr</code> 被销毁（如离开作用域）时，它会减少所指向对象的引用计数。</li>
<li>当一个对象的引用计数降至 0 时，<code>std::shared_ptr</code> 会自动释放该对象，调用其析构函数，并回收其占用的内存。</li>
</ul>
<h3 id="shared-ptr模拟代码"><a href="#shared-ptr模拟代码" class="headerlink" title="shared_ptr模拟代码"></a>shared_ptr模拟代码</h3><p>由于<strong>利用引用计数的方式: 因为引用计数算是临界资源， 所以对其的操作必须通过互斥量进行保护, 进行原子操作(保护临界资源)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">namespace test &#123;</span><br><span class="line">	template &lt;class T&gt;</span><br><span class="line">	class shared_ptr &#123;</span><br><span class="line">	public:</span><br><span class="line">		shared_ptr(T* ptr = nullptr) </span><br><span class="line">			: _ptr(ptr)</span><br><span class="line">			, _pmtx(new mutex)</span><br><span class="line">			, _pRefCount(new int(1))</span><br><span class="line">		&#123;&#125;</span><br><span class="line">		~shared_ptr() &#123;</span><br><span class="line">			Release();		//释放资源</span><br><span class="line">		&#125;</span><br><span class="line">		//增加引用计数, 赋值拷贝</span><br><span class="line">		shared_ptr(const shared_ptr&lt;T&gt;&amp; sp)</span><br><span class="line">			: _ptr(sp._ptr)</span><br><span class="line">			, _pRefCount(sp._pRefCount)</span><br><span class="line">			, _pmtx(sp._pmtx) &#123;</span><br><span class="line">			AddRefCount();//增加引用计数</span><br><span class="line">		&#125;</span><br><span class="line">		shared_ptr&lt;T&gt;&amp; operator=(shared_ptr&lt;T&gt;&amp; sp) &#123;</span><br><span class="line">			if (this != &amp;sp) &#123;</span><br><span class="line">				Release();//先释放可能持有的资源</span><br><span class="line">				_ptr = sp._ptr;</span><br><span class="line">				_pmtx = sp._pmtx;</span><br><span class="line">				_pRefCount = sp._pRefCount;</span><br><span class="line">				AddRefCount();//增加引用计数</span><br><span class="line">			&#125;</span><br><span class="line">			return *this;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		int UseCount() &#123; </span><br><span class="line">			return *_pRefCount; </span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		T* Get() &#123;</span><br><span class="line">			return _ptr;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		T&amp; operator*() &#123;</span><br><span class="line">			return *_ptr;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		T* operator-&gt;() &#123;</span><br><span class="line">			return _ptr;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">	private:</span><br><span class="line">		void AddRefCount() &#123;//增加引用计数</span><br><span class="line">			_pmtx-&gt;lock();</span><br><span class="line">			++(*_pRefCount);</span><br><span class="line">			_pmtx-&gt;unlock();</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		void Release() &#123;//释放资源, 减去一次引用计数</span><br><span class="line">			bool deleteFlag = 0;//判断是否需要释放资源, 真正的delete</span><br><span class="line">			_pmtx-&gt;lock();</span><br><span class="line">			if (--(*_pRefCount) == 0) &#123;</span><br><span class="line">				delete _ptr;</span><br><span class="line">				delete _pRefCount;</span><br><span class="line">				deleteFlag = 1;</span><br><span class="line">			&#125;</span><br><span class="line">			_pmtx-&gt;unlock();</span><br><span class="line"> </span><br><span class="line">			if (deleteFlag) &#123;</span><br><span class="line">				delete _pmtx;//最后释放锁</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">	private:</span><br><span class="line">		T* _ptr;//指向管理资源的指针</span><br><span class="line">		int* _pRefCount;//引用计数指针</span><br><span class="line">		mutex* _pmtx;//互斥锁</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="shared-ptr使用陷阱"><a href="#shared-ptr使用陷阱" class="headerlink" title="shared_ptr使用陷阱"></a>shared_ptr使用陷阱</h3><p>shared_ptr作为被管控的对象的成员时，小心因<strong>循环引用造成内存泄漏</strong>!</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boy</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Boy</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Boy 构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Boy</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;~Boy 析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setGirlFriend</span><span class="params">(shared_ptr&lt;Girl&gt; _girlFriend)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;girlFriend = _girlFriend;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	shared_ptr&lt;Girl&gt; girlFriend;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Girl</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Girl 构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Girl</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;~Girl 析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setBoyFriend</span><span class="params">(shared_ptr&lt;Boy&gt; _boyFriend)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;boyFriend = _boyFriend;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	shared_ptr&lt;Boy&gt; boyFriend;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useTrap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">shared_ptr&lt;Boy&gt; <span class="title">spBoy</span><span class="params">(<span class="keyword">new</span> Boy())</span></span>;</span><br><span class="line">	<span class="function">shared_ptr&lt;Girl&gt; <span class="title">spGirl</span><span class="params">(<span class="keyword">new</span> Girl())</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 陷阱用法</span></span><br><span class="line">	spBoy-&gt;<span class="built_in">setGirlFriend</span>(spGirl);</span><br><span class="line">	spGirl-&gt;<span class="built_in">setBoyFriend</span>(spBoy);</span><br><span class="line">	<span class="comment">// 此时boy和girl的引用计数都是2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">useTrap</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><p><strong>为了解决shared_ptr循环引用的问题, 循环引用, 也就是相互之间都有引用计数关系</strong>,使得对象无法真正被释放的问题</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202410281119788.png" alt="img"></p>
<ul>
<li>shared_ptr解决循环引用的原理:  在引用计数的时候将  <code>_pre</code> 和  <code>_next</code>指针修改成weak_ptr智能指针即可</li>
<li>原理就是，<code>node1-&gt;_next = node2;</code>和<code>node2-&gt;_prev = node1;</code>时weak_ptr的<code>_next</code>和<code>_prev</code>不会增加 node1和node2的引用计数。</li>
</ul>
<h1 id="结构化绑定"><a href="#结构化绑定" class="headerlink" title="结构化绑定"></a>结构化绑定</h1><p>C++17标准引入。结构化绑定允许将一个结构体或元组的成员绑定到单独的变量中，以便更方便地访问和操作这些成员</p>
<p>接受多个返回值</p>
<p>关键词: <code>auto[标识符列表]</code></p>
<h2 id="绑定原生数组"><a href="#绑定原生数组" class="headerlink" title="绑定原生数组"></a>绑定原生数组</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span>[x,y,z] = a;</span><br><span class="line">cout&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;y&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;z&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<h2 id="绑定到结构体和类对象"><a href="#绑定到结构体和类对象" class="headerlink" title="绑定到结构体和类对象"></a>绑定到结构体和类对象</h2><p>结构体或类的非静态公有数据成员(包括继承来的成员)必须和标识符列表中的别名的个数相同(C++20有另外的修改)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BindBase</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a=<span class="number">42</span>;</span><br><span class="line">    <span class="type">double</span> b=<span class="number">11.7</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BindTest</span>:<span class="keyword">public</span> BindBase&#123;&#125;;</span><br><span class="line"></span><br><span class="line">BindTest bt;</span><br><span class="line"><span class="keyword">auto</span>[x,y] = bt;</span><br><span class="line">cout&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;y&lt;&lt;endl;</span><br><span class="line"><span class="comment">//输出为:</span></span><br><span class="line"><span class="comment">//42</span></span><br><span class="line"><span class="comment">//11.7</span></span><br></pre></td></tr></table></figure>

<h2 id="绑定到元组和类元组的对象"><a href="#绑定到元组和类元组的对象" class="headerlink" title="绑定到元组和类元组的对象"></a>绑定到元组和类元组的对象</h2><p>需要满足条件(这是一种方向指导,而不是具体的代码)</p>
<ol>
<li>首先需要满足<code>tuple_size&lt;T&gt;::value</code>是一个符合语法的表达式,并且该表达式获得的整数值与标识符列表中的别名个数相同</li>
<li>其次,类型T还需要保证<code>tuple_elementM&lt;i,T&gt;::type</code>也是一个符合语法的表达式,其中i是小于<code>tuple_size&lt;T&gt;::value</code>的整数,表达式代表了类型T中第i个元素的类型;</li>
<li>最后,类型T必须存在合法的成员函数模板<code>get&lt;i&gt;()</code>或者函数模板<code>get&lt;i&gt;(t)</code>,其中i是小于<code>tuple_size&lt;T&gt;::value</code>的整数,t是类型T的实例,<code>get&lt;i&gt;()</code>和<code>get&lt;i&gt;(t)</code>返回的是实例t中第i个元素的值</li>
</ol>
<blockquote>
<p>结构化绑定是基于编译器能直接访问其公有非静态数据成员而实现的.如果想自己实现这种结构化绑定的机制,可能需要借助其他技术或等待未来C++标准对反射等特性更完善的支持。(也有说法是可以对任意对象做结构化绑定,前提是要编写额外代码,此处有存疑)</p>
</blockquote>
<p>下面是一种间接模拟的方式,并非原生地为自定义类型提供了结构化绑定支持。C++20以及之前的标准并未直接支持对所有自定义类型的结构化绑定功能。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyType</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x=<span class="number">1</span>;</span><br><span class="line">    std::string y=<span class="string">&quot;haha&quot;</span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供一个返回std::tuple的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">as_tuple</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">tie</span>(x, y, z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> z=<span class="number">0.1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     MyType tt;</span><br><span class="line">    <span class="keyword">auto</span> [x,y,z]=tt.<span class="built_in">as_tuple</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式可以访问私有成员,避免了<a href="#%E7%BB%91%E5%AE%9A%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98">绑定的访问权限问题</a></p>
<p>很实用的一种情形案例如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Out</span> &#123;</span><br><span class="line">    string out1 &#123; <span class="string">&quot;&quot;</span> &#125;;</span><br><span class="line">    string out2 &#123; <span class="string">&quot;&quot;</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">pair&lt;<span class="type">bool</span>, Out&gt; <span class="title">func</span><span class="params">(<span class="type">const</span> string&amp; in)</span> </span>&#123;</span><br><span class="line">    Out o;</span><br><span class="line">    <span class="keyword">if</span> (in.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="literal">false</span>, o &#125;;</span><br><span class="line">    o.out1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    o.out2 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="literal">true</span>, o &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> [status, o] = <span class="built_in">func</span>(<span class="string">&quot;hi&quot;</span>); status) &#123;</span><br><span class="line">        cout &lt;&lt; o.out1 &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; o.out2 &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>目前这种做法可以做到让返回值更富有语意，并且可以很方便的扩展，如果要增加一个新的返回值，只需要扩展现有的结构体就可以了。正如上文所说，在 <a target="_blank" rel="noopener" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-out-multi">CppCoreGuidelines</a> 中对于多返回值更建议使用 tuple 或 struct ，这样做能让返回值的语意更加明确</p>
<h2 id="结构化绑定的原理"><a href="#结构化绑定的原理" class="headerlink" title="结构化绑定的原理"></a>结构化绑定的原理</h2><p>在结构化绑定中编译器会根据限定符生成一个等号右边对象的匿名副本,而绑定的对象正是这个副本而非原对象本身.另外这里的别名就真的是单纯的别名,别名的类型和绑定目标对象的子对象类型相同</p>
<h2 id="绑定的访问权限问题"><a href="#绑定的访问权限问题" class="headerlink" title="绑定的访问权限问题"></a>绑定的访问权限问题</h2><blockquote>
<p>对于私有或保护成员，即使在友元函数内也无法直接通过结构化绑定访问它们</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a&#123;&#125;;</span><br><span class="line">    <span class="keyword">auto</span> x = a.i;<span class="comment">//编译成功</span></span><br><span class="line">    <span class="keyword">auto</span>[y] = a;<span class="comment">//编译失败:无法绑定到非公共的 成员 “A::i&quot;:结构化绑定无法绑定到私有成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="常量表达式"><a href="#常量表达式" class="headerlink" title="常量表达式"></a>常量表达式</h1><blockquote>
<p>C++11以前没有一种方法可以保证编译期间确定常量和函数的计算结果的(详情参考下面视频)</p>
<p>无法保证编译器确定的常量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_index0</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_index1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> index0=<span class="built_in">get_index0</span>();<span class="comment">//触发编译错误,因为编译器认为index0必须是运行期才能确定下来的</span></span><br></pre></td></tr></table></figure>

<p>于是引入了 <code>constexpr</code>关键字</p>
</blockquote>
<p>一个用constexpr说明符声明的变量或数据成员,要求该值必须在编译器计算</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> x=<span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//与const的对比如下:</span></span><br><span class="line"><span class="type">int</span> x1=<span class="number">42</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> x2 = x1;<span class="comment">//定义和初始化成功</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x1 =<span class="number">42</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> x2 = x1;<span class="comment">//编译失败,x2无法用x1初始化</span></span><br></pre></td></tr></table></figure>

<h2 id="常量表达式函数"><a href="#常量表达式函数" class="headerlink" title="常量表达式函数"></a>常量表达式函数</h2><p>常量表达式函数的返回值可以在编译阶段那就计算出来</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常量表达式函数</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x*x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="约束条件-C-11标准"><a href="#约束条件-C-11标准" class="headerlink" title="约束条件(C++11标准)"></a>约束条件(C++11标准)</h3><ul>
<li>函数必须返回一个值,所以它的返回类型不能是void</li>
<li>函数体必须只有一条语句:<code>return expr</code>,其中expr必须也是一个常量表达式</li>
<li>函数使用之前必须有定义</li>
<li>函数必须用constexpr声明</li>
</ul>
<p>即使成功定义了常量表达式函数,也不一定最终就在编译器求值,因为<strong>传入的实参如果不是常量表达式,常量表达式函数会退化为普通函数</strong></p>
<h3 id="约束条件新标准-C-14标准"><a href="#约束条件新标准-C-14标准" class="headerlink" title="约束条件新标准(C++14标准)"></a>约束条件新标准(C++14标准)</h3><ul>
<li>函数体允许声明变量,除了没有初始化的,static和<a href="#%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%AD%98%E5%82%A8">thread_local变量</a></li>
<li>函数允许出现if和switch语句,不能使用go语句</li>
<li>函数允许所有的循环语句,包括<code>for,while,do-while</code></li>
<li>函数可以修改生命周期和常量表达式相同的对象</li>
<li>函数的返回值可以声明为void</li>
<li>constexpr修饰的成员函数不再具有const属性</li>
</ul>
<h3 id="约束条件拓展-C-20"><a href="#约束条件拓展-C-20" class="headerlink" title="约束条件拓展(C++20)"></a>约束条件拓展(C++20)</h3><ul>
<li><p>c++20标准明确允许在常量表达式中使用虚函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">constexpr</span> <span class="keyword">virtual</span> <span class="type">int</span> <span class="title">f</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">constexpr</span> X x;</span><br><span class="line">  <span class="type">int</span> i=x.<span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>允许在constexpr中进行平凡的默认初始化</p>
</li>
<li><p>允许在constexpr函数中出现try-catch</p>
<p>可以出现try-catch,但没有意义，因为 try-catch 语句用于处理运行时的异常，而 constexpr 函数在编译时就会被求值，不会引发运行时异常。因此，编译器通常会在编译时检查 constexpr 函数的代码是否会引发异常，并在有可能引发异常的情况下导致编译错误。因此，在 constexpr 函数中使用 try-catch 是没有意义的。</p>
</li>
<li><p>允许在constexpr中更改联合类型的有效成员</p>
</li>
<li><p>允许dynamic_cast和typeid出现在常量表达式中</p>
</li>
</ul>
<blockquote>
<p>C++23进一步拓展:暂略</p>
</blockquote>
<h3 id="constexpr-lambdas表达式"><a href="#constexpr-lambdas表达式" class="headerlink" title="constexpr lambdas表达式"></a>constexpr lambdas表达式</h3><p>从C++17开始,lambda表达式在<strong>条件允许的情况下</strong>都会隐式声明为<code>constexpr</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> []()&#123;<span class="keyword">return</span> <span class="number">58</span>;&#125;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> get_size = [](<span class="type">int</span> i)&#123;<span class="keyword">return</span> i*<span class="number">2</span>;&#125;;</span><br><span class="line"><span class="type">char</span> buffer1[<span class="built_in">foo</span>()]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">char</span> buffer2[<span class="built_in">get_size</span>(<span class="number">5</span>)]=&#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="常量表达式构造函数"><a href="#常量表达式构造函数" class="headerlink" title="常量表达式构造函数"></a>常量表达式构造函数</h2><h3 id="作用于自定义类型"><a href="#作用于自定义类型" class="headerlink" title="作用于自定义类型"></a>作用于自定义类型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">X</span>():<span class="built_in">x1</span>(<span class="number">5</span>)&#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x1;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> x1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">constexpr</span> X x;<span class="comment">//编译失败</span></span><br><span class="line"><span class="type">char</span> buffer[x.<span class="built_in">get</span>()] = &#123;<span class="number">0</span>&#125;;<span class="comment">//编译失败,x.get()无法在编译阶段计算</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//==========使用常量表达式构造函数========</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="title">X</span><span class="params">()</span>:x1(<span class="number">5</span>)&#123;</span>&#125;</span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">get</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x1;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> x1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">constexpr</span> X x;</span><br><span class="line"><span class="type">char</span> buffer[x.<span class="built_in">get</span>()] = &#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="约束条件"><a href="#约束条件" class="headerlink" title="约束条件"></a>约束条件</h3><ul>
<li>构造函数必须用constexpr修饰</li>
<li>构造函数初始化列表里必须是常量表达式</li>
<li>构造函数的函数体必须为空</li>
</ul>
<h3 id="意义-1"><a href="#意义-1" class="headerlink" title="意义"></a>意义</h3><p>常量表达式用于构造函数的意义主要体现在优化和安全性方面</p>
<ol>
<li><strong>编译时常量化</strong>：如果一个构造函数使用常量表达式初始化对象的某些成员变量，那么在编译时就可以计算出这些值。这有助于在编译时捕获潜在的错误，并减少运行时开销。</li>
<li><strong>提高性能</strong>：通过使用常量表达式，程序在运行时需要做的计算减少了，因为某些结果已经在编译时得到。这降低了程序的执行时间，特别是在资源受限的系统中，这种优化尤为重要。</li>
<li><strong>代码安全性</strong>：因为常量表达式在编译时计算，有助于确保代码的一致性和安全性。它可以防止某些类型的错误，例如未经初始化的数据使用。</li>
<li><strong>不可变性</strong>：常量对象或只读数据成员可以用常量表达式进行初始化，这确保了对象一旦创建，其状态就不能再被改变，增加了对象的不可变性。这也使得代码更易于推理和测试。</li>
<li><strong>元编程支持</strong>：在现代C++中，使用<code>constexpr</code>关键字的能力支持了一些更高级的编程技巧，如模板元编程。这使得开发者可以编写出更通用、灵活和高效的代码。</li>
</ol>
<h2 id="if-constexpr"><a href="#if-constexpr" class="headerlink" title="if constexpr"></a>if constexpr</h2><p><code>if constexpr</code>的条件必须是编译器能确定结果的常量表达式</p>
<p>条件结果一旦确定,编译器将<strong>只编译符合条件的代码块</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">check1</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">if</span> <span class="title">constexpr</span><span class="params">(i&gt;<span class="number">0</span>)</span></span>&#123;<span class="comment">//编译失败,不是常量表达式</span></span><br><span class="line">   	<span class="comment">//... </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">constexpr</span><span class="params">(<span class="keyword">sizeof</span>(<span class="type">int</span>)&gt;<span class="keyword">sizeof</span>(<span class="type">char</span>))</span></span>&#123;<span class="comment">//成功编译</span></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="consteval"><a href="#consteval" class="headerlink" title="consteval"></a>consteval</h2><blockquote>
<p>consteval是C++20引入的一个新关键字，用于强制声明一个编译时求值的函数</p>
</blockquote>
<p>constexpr是非强制性的,由编译器决定是否在编译器就执行计算</p>
<p>而consteval是确保函数在编译器就执行计算,用法与constexpr一致</p>
<h2 id="constinit"><a href="#constinit" class="headerlink" title="constinit"></a>constinit</h2><blockquote>
<p>constinit是C++20引入的一个新关键字，用于声明<strong>在程序启动时初始化的const变量</strong>。它确保在程序启动时初始化const变量，以避免静态初始化顺序问题。使用constinit可以提高程序的可靠性和可移植性。当一个变量被声明为 <code>constinit</code> 时，它<strong>要求该变量必须在编译时用常量表达式进行初始化</strong>，而且只能在声明时初始化，<strong>不能在运行时再次赋值</strong>。</p>
<p>解决因为静态初始化顺序错误导致问题.例如:假设有两个静态对象x和y,分别存在两个不同的源文件中,其中一个对象x的构造函数依赖于对象y.现在我们有50%的可能性会出错.因为哪个对象先构造决定了是否有错,为了避免这种问题发生,我们通常希望使用常量初始化程序去初始化静态变量,不幸的是常量初始化的规则很复杂,需要一种方法帮我们完成检查工作.当不符合常量初始化时,可以在编译阶段报错.于是C++20引入了constinit关键词</p>
</blockquote>
<h3 id="使用constinit检查常量初始化规则"><a href="#使用constinit检查常量初始化规则" class="headerlink" title="使用constinit检查常量初始化规则"></a>使用constinit检查常量初始化规则</h3><ul>
<li><p>用于具有静态存储持续时间的变量声明上,它要求变量是常量初始化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constinit</span> <span class="type">int</span> x=<span class="number">11</span>;<span class="comment">//编译成功,全局变量具有静态存储持续</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">constinit</span> <span class="type">static</span> <span class="type">int</span> y=<span class="number">42</span>;<span class="comment">//编译成功,静态变量具有静态存储持续</span></span><br><span class="line">  <span class="keyword">constinit</span> <span class="type">int</span> z=<span class="number">7</span>;<span class="comment">//编译失败,局部变量是动态分配的</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>或者要求变量具有常量表达式初始化程序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">f</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">g</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;&#125;<span class="comment">//const可以不写的</span></span><br><span class="line"><span class="keyword">constinit</span> <span class="type">const</span> <span class="type">char</span>* str1 = <span class="built_in">f</span>();<span class="comment">//编译错误,f()不是一个常量表达式初始化程序</span></span><br><span class="line"><span class="keyword">constinit</span> <span class="type">const</span> <span class="type">char</span>* str2 = <span class="built_in">g</span>();<span class="comment">//编译成功</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="线程局部存储"><a href="#线程局部存储" class="headerlink" title="线程局部存储"></a>线程局部存储</h1><p>将对象内存和线程关联起来,对象在线程开始时分配内存,在线程结束时释放内存.每个对象相对线程是独立的,并且不会相互干扰</p>
<p>线程局部存储（Thread Local Storage，TLS）原本是操作系统层面的概念</p>
<blockquote>
<p>TLS使用的是和全局变量、静态变量等一样的存储空间，但是TLS的变量是线程私有的，每个线程都有自己的副本，而全局变量和静态变量则是所有线程共享的。</p>
</blockquote>
<p>Windows和Linux都有各自的方法管理线程局部存储</p>
<ul>
<li>Windows<ul>
<li>TlsAlloc   分配未被使用的线程局部空间的索引</li>
<li>TlsGetValue   获取索引指向的空间的值</li>
<li>TlsSetValue   设置索引指向的空间的值</li>
<li>TlsFree    释放索引指向的线程局部空间</li>
</ul>
</li>
<li>Linux<ul>
<li>pthread_key_create   分配未被使用的线程局部空间的索引</li>
<li>pthread_getsepcific   获取索引指向的空间的值</li>
<li>pthread_setspecific   设置索引指向的空间的值</li>
<li>pthread_key_delete    释放索引指向的线程局部空间</li>
</ul>
</li>
</ul>
<p>编译器对线程局部存储的支持(C++11之前,方式不统一)</p>
<ul>
<li><p>GCC&amp;CLANG</p>
<p>__thread</p>
</li>
<li><p>MSVC</p>
<p>__declspec(thread)</p>
</li>
</ul>
<p><strong>C++11后统一了标准</strong></p>
<p>关键词:<code>thread_local</code>  放在变量声明前表示为线程局部存储</p>
<p>基本语法:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span>&#123;</span><br><span class="line">	<span class="keyword">thread_local</span> <span class="type">static</span> <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">thread_local</span> X a;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">thread_local</span> X b; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>被thread_local声明的变量<strong>在行为上非常像静态变量,只不过多了线程属性</strong>,他能够解决全局变量和静态变量在多线程程序中存在的问题</p>
<p>典型的例子为:errno的多线程安全问题.一个多线程程序A线程,正准备获取错误码,另一个线程B修改了错误码,这时候线程A获取到的错误码就不合理了,为了解决这个问题,C++11标准将errno重新定义为线程独立变量</p>
</blockquote>
<h2 id="线程局部存储的内存地址"><a href="#线程局部存储的内存地址" class="headerlink" title="线程局部存储的内存地址"></a>线程局部存储的内存地址</h2><ul>
<li>线程局部存储只定义了生命周期,而没有定义访问性.即可以获取线程局部存储变量的地址,并将这个地址传递给其他线程,并且其他线程可以在变量生命周期内自由使用该变量.但这样做意义不大并且风险性大容易导致未定义行为造成程序崩溃</li>
<li>线程局部存储的地址是<strong>运行时</strong>被计算出来的(static和全局变量地址是编译时确定的),因此线程局部存储的地址不是一个常量,因此无法和<a href="#%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F">常量表达式</a>结合</li>
</ul>
<h2 id="线程局部存储对象初始化和销毁"><a href="#线程局部存储对象初始化和销毁" class="headerlink" title="线程局部存储对象初始化和销毁"></a>线程局部存储对象初始化和销毁</h2><ul>
<li><p>对于同一个线程中线程局部存储对象只会被初始化一次,即使被多次调用</p>
<p>有点类似静态变量只会在全局初始化一次</p>
</li>
<li><p>线程局部存储对象的销毁通常发生在线程销毁的时刻</p>
</li>
</ul>
<h1 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h1><p>头文件: <code>#include &lt;tuple&gt;</code></p>
<p>从C++11标准开始引入的内容，属于C++标准库的一部分,用于代表一个固定数量的异质对象的集合。</p>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><blockquote>
<p>语言级线程支持</p>
</blockquote>
<p>c++11关于并发引入了好多新东西，这里按照如下顺序介绍：</p>
<ul>
<li>std::thread相关</li>
<li>std::mutex相关</li>
<li>std::lock相关</li>
<li>std::atomic相关</li>
<li>std::call_once相关</li>
<li>volatile相关</li>
<li>std::condition_variable相关</li>
<li>std::future相关</li>
<li>async相关</li>
</ul>
<p>c++11之前可能使用pthread_xxx来创建线程，繁琐且不易读，c++11引入了std::thread来创建线程，支持对线程join或者detach</p>
<h1 id="stl新容器"><a href="#stl新容器" class="headerlink" title="stl新容器"></a>stl新容器</h1><h1 id="C-谷歌代码规范"><a href="#C-谷歌代码规范" class="headerlink" title="C++谷歌代码规范"></a>C++谷歌代码规范</h1><p><a target="_blank" rel="noopener" href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/">Google开源项目风格指南</a></p>
<h1 id="Boost"><a href="#Boost" class="headerlink" title="Boost"></a>Boost</h1><h2 id="filesystem"><a href="#filesystem" class="headerlink" title="filesystem"></a>filesystem</h2><blockquote>
<p>曾作为一个技术规范存在，并且在Boost库中有一个成熟的实现——Boost.Filesystem。随着C++17的发布，文件系统库成为标准库的一部分，使得C++程序员能够在<strong>不依赖第三方库的情况下进行跨平台的文件系统操作</strong>。</p>
</blockquote>
<h1 id="emplace"><a href="#emplace" class="headerlink" title="emplace"></a>emplace</h1><p>C++11针对顺序容器引入了三个新成员</p>
<ul>
<li><p>emplace_front</p>
<p>在容器开头直接构造新元素</p>
</li>
<li><p>emplace</p>
<p>在指定位置直接构造新元素</p>
<p>代表了直接调用构造函数</p>
<p>直接不传参数,相当于调用无参构造函数,即在栈上就地构造</p>
</li>
<li><p>emplace_back</p>
<p>在容器末尾直接构造新元素</p>
</li>
</ul>
<p>定义:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Container</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ContainerClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// C++11 版本</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span>... Args&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">emplace_back</span><span class="params">(Args&amp;&amp;... args)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// C++17 版本 - 添加了返回值</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span>... Args&gt;</span><br><span class="line">    <span class="function">reference <span class="title">emplace_back</span><span class="params">(Args&amp;&amp;... args)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// C++20 版本 - noexcept 说明符</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span>... Args&gt;</span><br><span class="line">    <span class="function">reference <span class="title">emplace_back</span><span class="params">(Args&amp;&amp;... args)</span> <span class="title">noexcept</span><span class="params">(<span class="comment">/* 具体条件 */</span>)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>这三个操作与push_front,insert,push_back操作相同,但这些操作是构造元素,而不是拷贝元素</p>
<p>insert在插入时，由于我们传的是右值，其调用了构造和移动构造，而emplace只调用了构造函数。也就是说，emplace是在插入位置直接构造元素，而不是和insert一样，先是构造好，再移动或复制到插入位置。这样做的优势就是能够减少一次移动构造或拷贝构造。</p>
<p><strong>优势</strong></p>
<ul>
<li><p>性能优化：避免了不必要的临时对象创建和拷贝操作</p>
</li>
<li><p>直接构造：参数直接传递给对象的构造函数,如果是空的话相当于直接在栈上构造</p>
</li>
<li><p>完美转发：保持参数的值类型和引用类型</p>
<p>C++17 后，emplace_back 和 emplace_front 返回对新构造元素的引用</p>
</li>
</ul>
<h1 id="C-17三剑客"><a href="#C-17三剑客" class="headerlink" title="C++17三剑客"></a>C++17三剑客</h1><ul>
<li>optional  可存在可不存在包装器</li>
<li>any   任意类型</li>
<li>vairant  类型安全的联合体，可以存储指定类型中的一个</li>
</ul>
<h2 id="optional"><a href="#optional" class="headerlink" title="optional"></a>optional</h2><p>头文件:<code>&lt;optional&gt;</code></p>
<p>C++17引入,C++ 17 之前的版本可以通过 <code>boost::optional</code> 实现几乎相同的功能。</p>
<p>包装可以为空的类型</p>
<p>类模板 <code>std::optional</code> 管理一个<em>可选</em> ﻿的容纳值，既可以存在也可以不存在的值。</p>
<p>一种常见的 <code>optional</code> 使用情况是一个可能失败的函数的返回值。与其他手段，如 <code>std::pair&lt;T, bool&gt;</code> 相比，<code>optional</code> 良好地处理构造开销高昂的对象，并更加可读，因为它显式表达意图</p>
<p>optional的<strong>内存管理是自动的</strong>，当 <code>std::optional </code>的生命周期结束时，它所持有的值会被自动释放。 具体来说，当 <code>std::optional </code>对象被销毁时，如果它包含一个值（即状态为“有值”），那么这个值的析构函数会被调用，从而释放相关资源。如果它没有值（状态为“无值”），则不会有任何资源释放操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span>  <span class="comment">// 引入std::optional</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function">std::optional&lt;<span class="type">double</span>&gt; <span class="title">getValue</span><span class="params">(<span class="type">bool</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.52</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="literal">nullopt</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> value = <span class="built_in">getValue</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (value.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; *value &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;No value&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>std::nullopt</strong> 是 C++ 17 中提供的没有值的 optional 的表达形式，等同于 { } </p>
<h3 id="创建一个-optional-的方法"><a href="#创建一个-optional-的方法" class="headerlink" title="创建一个 optional 的方法"></a>创建一个 optional 的方法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空 optiolal</span></span><br><span class="line">optional&lt;<span class="type">int</span>&gt; oEmpty;</span><br><span class="line">optional&lt;<span class="type">float</span>&gt; oFloat = <span class="literal">nullopt</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">optional&lt;<span class="type">int</span>&gt; <span class="title">oInt</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">optional <span class="title">oIntDeduced</span><span class="params">(<span class="number">10</span>)</span></span>;  <span class="comment">// type deduction</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// make_optional</span></span><br><span class="line"><span class="keyword">auto</span> oDouble = std::<span class="built_in">make_optional</span>(<span class="number">3.0</span>);</span><br><span class="line"><span class="keyword">auto</span> oComplex = make_optional&lt;complex&lt;<span class="type">double</span>&gt;&gt;(<span class="number">3.0</span>, <span class="number">4.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// in_place(允许你在std::optional对象的存储空间中直接构造值，避免了不必要的拷贝或移动操作,用来指示原位构造对象)</span></span><br><span class="line">optional&lt;complex&lt;<span class="type">double</span>&gt;&gt; o7&#123;in_place, <span class="number">3.0</span>, <span class="number">4.0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// initializer list</span></span><br><span class="line">optional&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">oVec</span>(in_place, &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝赋值</span></span><br><span class="line"><span class="keyword">auto</span> oIntCopy = oInt;</span><br></pre></td></tr></table></figure>

<p>使用<code>emplace(Args...)</code>方法也可以将一个<code>T</code>类型对象置入一个已经存在的<code>std::optional</code>对象中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> optVec = std::make_optional&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;(<span class="number">3</span>, <span class="number">22</span>);</span><br><span class="line">std::set&lt;<span class="type">int</span>&gt; ints&#123;<span class="number">7</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">741</span>&#125;;</span><br><span class="line">optVec.<span class="built_in">emplace</span>(std::<span class="built_in">begin</span>(ints), std::<span class="built_in">end</span>(ints));</span><br></pre></td></tr></table></figure>

<h3 id="访问-optional-对象中数据的方法"><a href="#访问-optional-对象中数据的方法" class="headerlink" title="访问 optional 对象中数据的方法"></a>访问 optional 对象中数据的方法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 跟迭代器的使用类似，访问没有 value 的 optional 的行为是未定义的</span></span><br><span class="line">cout &lt;&lt; (*ret).out1 &lt;&lt; endl; </span><br><span class="line">cout &lt;&lt; ret-&gt;out1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当没有 value 时调用该方法将 throws std::bad_optional_access 异常</span></span><br><span class="line">cout &lt;&lt; ret.<span class="built_in">value</span>().out1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当没有 value 调用该方法时将使用传入的默认值</span></span><br><span class="line">Out defaultVal;</span><br><span class="line">cout &lt;&lt; ret.<span class="built_in">value_or</span>(defaultVal).out1 &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h3 id="判断option对象是否有值"><a href="#判断option对象是否有值" class="headerlink" title="判断option对象是否有值"></a>判断option对象是否有值</h3><p>使用<code>has_value()</code>函数来询问<code>std::optional</code>此时是否有值</p>
<p>可以显式地转化为<code>bool</code>型变量来显示他此时是否拥有一个有意义的值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::optional&lt;<span class="type">unsigned</span>&gt; opt = <span class="built_in">firstEvenNumberIn</span>(text);</span><br><span class="line">  <span class="keyword">if</span> (opt) &#123;</span><br><span class="line">    <span class="comment">//有值</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="销毁optino对象中的值"><a href="#销毁optino对象中的值" class="headerlink" title="销毁optino对象中的值"></a>销毁optino对象中的值</h3><p><code>reset()</code>方法销毁存储在<code>std::optional</code>中的值，并将其值为空</p>
<h1 id="C-中的函数式编程"><a href="#C-中的函数式编程" class="headerlink" title="C++中的函数式编程"></a>C++中的函数式编程</h1><p>首先需要了解[[架构相关#函数式编程|函数式编程的思想]]</p>
<h2 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h2><p>在C++中实现一个纯函数,但又要递归,而递归的过程中需要利用一个共享空间来在递归函数中共用,同时需要保持纯函数的性质呢?比如说斐波那契数列求值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带有缓存功能的递归斐波那契函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fibonacci</span><span class="params">(<span class="type">int</span> n, std::unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; *cache = <span class="literal">nullptr</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 如果没有提供缓存，则新建一个缓存</span></span><br><span class="line">	std::unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; tempCache;</span><br><span class="line">	<span class="keyword">if</span> (!cache)</span><br><span class="line">	&#123;</span><br><span class="line">		cache = &amp;tempCache;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查缓存中是否已有结果</span></span><br><span class="line">	<span class="keyword">auto</span> it = cache-&gt;<span class="built_in">find</span>(n);</span><br><span class="line">	<span class="keyword">if</span> (it != cache-&gt;<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> it-&gt;second;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 基本情况</span></span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> n;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 递归计算，并存储结果在缓存中</span></span><br><span class="line">	<span class="type">int</span> result = <span class="built_in">fibonacci</span>(n - <span class="number">1</span>, cache) + <span class="built_in">fibonacci</span>(n - <span class="number">2</span>, cache);</span><br><span class="line">	(*cache)[n] = result;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> number = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> result = <span class="built_in">fibonacci</span>(number);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Fibonacci of &quot;</span> &lt;&lt; number &lt;&lt; <span class="string">&quot; is: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>虽然使用到了空间,但不依赖外部</p>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p><code>applyFunction</code>是一个高阶函数，因为它接受另一个函数作为参数。在<code>main</code>函数中，我们通过lambda表达式将一个简单的操作传递给<code>applyFunction</code>来处理向量中的每个元素</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义高阶函数，接收一个函数作为参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">applyFunction</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; vec, std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; func)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> value : vec) &#123;</span><br><span class="line">        <span class="built_in">func</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用lambda表达式作为高阶函数的参数</span></span><br><span class="line">    <span class="built_in">applyFunction</span>(numbers, [](<span class="type">int</span> n) &#123;</span><br><span class="line">        std::cout &lt;&lt; n * <span class="number">2</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常用的高阶函数"><a href="#常用的高阶函数" class="headerlink" title="常用的高阶函数"></a>常用的高阶函数</h3><ul>
<li><p>transform</p>
<p>将给定范围内的每个元素通过某种转换函数转换为一个新的值，通常用于对容器中的元素进行批量操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用std::transform将numbers中的每个元素平方,导出为square</span></span><br><span class="line">std::<span class="built_in">transform</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), square.<span class="built_in">begin</span>(), [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x * x; &#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>copy_if</p>
<p>复制满足某个条件的元素到一个新的容器，通常用于过滤操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用std::copy_if将numbers中所有偶数复制到evens</span></span><br><span class="line">std::<span class="built_in">copy_if</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), std::<span class="built_in">back_inserter</span>(evens), [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">0</span>; &#125;);</span><br><span class="line"><span class="comment">//back_inserter是插入到末尾迭代器,需要&lt;iterator&gt;头文件</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>accumulate</p>
<p>对指定范围内的元素进行累积求值，通常用于总和、乘积或其他累积操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span>  <span class="comment">// std::accumulate需要这个头文件</span></span></span><br><span class="line"><span class="comment">// 使用std::accumulate计算所有元素的乘积</span></span><br><span class="line"><span class="type">int</span> product = std::<span class="built_in">accumulate</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">1</span>, [](<span class="type">int</span> accumulated, <span class="type">int</span> current) &#123; <span class="keyword">return</span> accumulated * current; &#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>reduce</p>
<p>对指定范围内的元素进行聚合运算</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span>   <span class="comment">// std::reduce需要这个头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用std::reduce计算元素总和</span></span><br><span class="line"><span class="type">int</span> sum = std::<span class="built_in">reduce</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用自定义操作符（乘法）</span></span><br><span class="line"><span class="type">int</span> product = std::<span class="built_in">reduce</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">1</span>, std::multiplies&lt;&gt;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用并行执行策略 (仅在支持并行的系统中有效)</span></span><br><span class="line"><span class="type">int</span> parallel_sum = std::<span class="built_in">reduce</span>(std::execution::par, numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p><code>std::reduce</code> 接受一个可选的执行策略参数</p>
<ul>
<li><code>std::execution::seq</code>: 顺序执行(默认)</li>
<li><code>std::execution::par</code>: 并行执行</li>
<li><code>std::execution::par_unseq</code>: 并行且无序执行</li>
</ul>
</li>
<li><p>for_each</p>
<p>对指定范围内的每个元素执行某个操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用std::for_each对每个元素执行操作</span></span><br><span class="line">std::for_each(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), [](<span class="type">int</span> &amp;n) &#123; n *= <span class="number">2</span>; &#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>any_of</p>
<p>检查指定范围内是否存在至少一个满足给定谓词条件的元素。返回<code>true</code>或<code>false</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用std::any_of检查是否存在偶数</span></span><br><span class="line"><span class="type">bool</span> has_even = std::<span class="built_in">any_of</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), [](<span class="type">int</span> n) &#123; <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">0</span>; &#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>all_of</p>
<p>检查指定范围内的所有元素是否都满足给定谓词条件。返回<code>true</code>或<code>false</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用std::all_of检查是否所有元素都是偶数</span></span><br><span class="line"><span class="type">bool</span> all_even = std::<span class="built_in">all_of</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), [](<span class="type">int</span> n) &#123; <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">0</span>; &#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>find_if</p>
<p>在指定范围内查找第一个满足给定谓词条件的元素。返回指向该元素的迭代器。如果未找到，返回结束迭代器。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用std::find_if查找第一个偶数</span></span><br><span class="line"><span class="keyword">auto</span> it = std::<span class="built_in">find_if</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), [](<span class="type">int</span> n) &#123; <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">0</span>; &#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="组合函数与管道函数"><a href="#组合函数与管道函数" class="headerlink" title="组合函数与管道函数"></a>组合函数与管道函数</h3><h4 id="组合函数的实现"><a href="#组合函数的实现" class="headerlink" title="组合函数的实现"></a>组合函数的实现</h4><p><code>compose</code>函数可以将多个函数组合成一个新的函数，从右到左执行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基础模板，结束递归组合</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">compose</span><span class="params">(F&amp;&amp; f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::forward&lt;F&gt;(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归组合函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Rest&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">compose</span><span class="params">(F&amp;&amp; f, Rest&amp;&amp;... rest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [f = std::forward&lt;F&gt;(f), rest = <span class="built_in">compose</span>(std::forward&lt;Rest&gt;(rest)...)](<span class="keyword">auto</span>&amp;&amp;... args) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">f</span>(<span class="built_in">rest</span>(std::forward&lt;<span class="keyword">decltype</span>(args)&gt;(args)...));</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">increment</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> composed = <span class="built_in">compose</span>(increment, square); <span class="comment">// 相当于 increment(square(x))</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">composed</span>(<span class="number">4</span>) &lt;&lt; std::endl; <span class="comment">// 输出：17，因为 (4^2) + 1 = 17</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以使用reduce实现:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Funcs&gt;</span><br><span class="line"><span class="function">T <span class="title">compose</span><span class="params">(T input, Funcs... funcs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;std::function&lt;T(T)&gt;&gt; funcVector = &#123;funcs...&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reverse the order of functions for compose behavior</span></span><br><span class="line">    std::<span class="built_in">reverse</span>(funcVector.<span class="built_in">begin</span>(), funcVector.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">reduce</span>(</span><br><span class="line">        funcVector.<span class="built_in">begin</span>(), funcVector.<span class="built_in">end</span>(), input,</span><br><span class="line">        [](T acc, <span class="type">const</span> std::function&lt;<span class="built_in">T</span>(T)&gt; &amp;func)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">func</span>(acc);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="管道函数的实现"><a href="#管道函数的实现" class="headerlink" title="管道函数的实现"></a>管道函数的实现</h4><p><code>pipe</code>函数将多个函数从左到右组合。可以认为它是<code>compose</code>的逆序实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基础模板，结束递归组合</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">pipe</span><span class="params">(F&amp;&amp; f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::forward&lt;F&gt;(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归组合函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Rest&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">pipe</span><span class="params">(F&amp;&amp; f, Rest&amp;&amp;... rest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [f = std::forward&lt;F&gt;(f), rest = <span class="built_in">pipe</span>(std::forward&lt;Rest&gt;(rest)...)](<span class="keyword">auto</span>&amp;&amp;... args) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rest</span>(<span class="built_in">f</span>(std::forward&lt;<span class="keyword">decltype</span>(args)&gt;(args)...));</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">increment</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> piped = <span class="built_in">pipe</span>(square, increment); <span class="comment">// 相当于 increment(square(x))</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">piped</span>(<span class="number">4</span>) &lt;&lt; std::endl; <span class="comment">// 输出：17，因为 (4^2) + 1 = 17</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以使用<code>reduce</code>来实现:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pipe函数使用std::reduce</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Funcs&gt;</span><br><span class="line"><span class="function">T <span class="title">pipe</span><span class="params">(T input, Funcs... funcs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::vector&lt;std::function&lt;T(T)&gt;&gt; funcVector = &#123;funcs...&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> std::<span class="built_in">reduce</span>(</span><br><span class="line">		funcVector.<span class="built_in">begin</span>(), funcVector.<span class="built_in">end</span>(), input,</span><br><span class="line">		[](T acc, <span class="type">const</span> std::function&lt;<span class="built_in">T</span>(T)&gt; &amp;func)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">func</span>(acc);</span><br><span class="line">		&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效率不如递归方式的实现</p>
<h2 id="偏函数与柯里化"><a href="#偏函数与柯里化" class="headerlink" title="偏函数与柯里化"></a>偏函数与柯里化</h2><h3 id="实现柯里化"><a href="#实现柯里化" class="headerlink" title="实现柯里化"></a>实现柯里化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 辅助函数：检查是否可以调用函数F，参数类型为Args</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_callable</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 内部模板函数：尝试调用F并返回std::true_type</span></span><br><span class="line">	<span class="comment">// 如果F可以被调用，则返回std::true_type</span></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... As&gt;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="keyword">auto</span> <span class="title">test</span><span class="params">(<span class="type">int</span>)</span></span></span><br><span class="line"><span class="function">		-&gt; <span class="title">decltype</span><span class="params">(std::declval&lt;T&gt;()(std::declval&lt;As&gt;()...), std::true_type&#123;&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 内部模板函数：如果无法调用F，则返回std::false_type</span></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span>, <span class="keyword">typename</span>...&gt;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="keyword">auto</span> <span class="title">test</span><span class="params">(...)</span> -&gt; std::false_type</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 静态常量布尔值，表示F是否可以被调用</span></span><br><span class="line">	<span class="comment">// 通过调用test函数来判断</span></span><br><span class="line">	<span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = <span class="keyword">decltype</span>(<span class="built_in">test</span>&lt;F, Args...&gt;(<span class="number">0</span>))::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用的柯里化函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">curry</span><span class="params">(F f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 返回一个lambda函数，该函数接受任意数量的参数</span></span><br><span class="line">	<span class="keyword">return</span> [f](<span class="keyword">auto</span> &amp;&amp;...args)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 如果F可以被调用，则直接调用F并返回结果</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">constexpr</span> (is_callable&lt;F, <span class="keyword">decltype</span>(args)...&gt;::value)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">f</span>(std::forward&lt;<span class="keyword">decltype</span>(args)&gt;(args)...);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果F不能被调用，则返回一个新的柯里化函数</span></span><br><span class="line">		<span class="comment">// 该函数将当前参数与后续参数一起传递给F</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">curry</span>([f, args...](<span class="keyword">auto</span> &amp;&amp;...rest)</span><br><span class="line">						 &#123; <span class="keyword">return</span> <span class="built_in">f</span>(args..., std::forward&lt;<span class="keyword">decltype</span>(rest)&gt;(rest)...); &#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用案例:</span></span><br><span class="line"><span class="keyword">auto</span> add = [](<span class="type">int</span> a, <span class="type">int</span> b)&#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line"><span class="keyword">auto</span> curriedAdd = <span class="built_in">curry</span>(add);</span><br><span class="line"><span class="type">int</span> result = <span class="built_in">curriedAdd</span>(<span class="number">3</span>)(<span class="number">4</span>); <span class="comment">// 3 + 4 = 7</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Curried add result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">//也可以直接使用</span></span><br><span class="line"><span class="type">int</span> result2 = <span class="built_in">curriedAdd</span>(<span class="number">3</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<p>有了通用的柯里化函数后,就可以配合各种高阶函数,如组合使用</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>在C++中，闭包（closure）是一个能够捕获并存储其所在作用域中的变量的函数对象（function object）。闭包主要通过C++11引入的<a href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F">Lambda表达式</a>来实现。</p>
<p>通过lambda表达式，C++提供了一种简洁且强大的方式来创建闭包，这使得编写高阶函数和处理回调变得更加方便。</p>
<blockquote>
<p>高阶函数（Higher-Order Function）是指接受一个或多个函数作为参数，或返回一个函数作为结果的函数。在函数式编程中，高阶函数是一个核心概念，但它同样适用于其他编程范式，包括面向对象编程和过程式编程。</p>
<p>以下是高阶函数的一些特性和例子：</p>
<p><strong>高阶函数的特性</strong></p>
<ol>
<li><strong>接受函数作为参数</strong>：高阶函数可以接受一个或多个函数作为参数。这使得它能够对传入的函数进行操作，如在不同的上下文中调用它们。</li>
<li><strong>返回函数作为结果</strong>：高阶函数可以返回一个函数作为结果。这样可以生成新的函数，或延迟计算。</li>
</ol>
<p>高阶函数在很多场景下非常有用，例如：</p>
<ul>
<li><strong>回调函数</strong>：在事件驱动编程中，高阶函数可以用来注册和调用回调函数。</li>
<li><strong>函数组合</strong>：高阶函数可以用来组合多个函数，使代码更加模块化和可重用。</li>
<li><strong>装饰器</strong>：在Python中，装饰器是一种特殊的高阶函数，用于修改或增强另一个函数的行为。</li>
</ul>
</blockquote>
<p>在C++中当按引用捕获一个局部变量并在该变量的作用域之外访问它时，会导致未定义行为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::function&lt;<span class="title">void</span><span class="params">()</span>&gt; <span class="title">createLambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按引用捕获 x</span></span><br><span class="line">    <span class="keyword">auto</span> lambda = [&amp;x]() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Inside lambda, x: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lambda; <span class="comment">// lambda捕获了x的引用，但x在createLambda返回后被销毁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> lambda = <span class="built_in">createLambda</span>();</span><br><span class="line">    <span class="comment">// 这里 lambda 捕获的 x 已经无效，执行将导致未定义行为</span></span><br><span class="line">    <span class="built_in">lambda</span>(); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，当createLambda返回时，局部变量x已经被销毁，因此lambda捕获的引用不再有效，执行lambda会导致未定义行为。</p>
<p><strong>使用智能指针解决生命周期问题</strong></p>
<p>为了解决这个问题，可以使用std::shared_ptr或std::unique_ptr来管理捕获的变量，使其在lambda需要时仍然有效：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::function&lt;<span class="title">void</span><span class="params">()</span>&gt; <span class="title">createLambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> x = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按值传递qv捕获智能指针</span></span><br><span class="line">    <span class="keyword">auto</span> lambda = [x]() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Inside lambda, x: &quot;</span> &lt;&lt; *x &lt;&lt; std::endl;</span><br><span class="line">        (*x)++;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lambda;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> lambda = <span class="built_in">createLambda</span>();</span><br><span class="line">    <span class="built_in">lambda</span>(); <span class="comment">// 输出 &quot;Inside lambda, x: 10&quot;</span></span><br><span class="line">    <span class="built_in">lambda</span>(); <span class="comment">// 输出 &quot;Inside lambda, x: 11&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>值得注意的是:</strong></p>
<p>在JavaScript中，闭包不会产生类似于C++中按引用捕获局部变量在作用域之外执行导致未定义行为的问题。JavaScript的闭包捕获的是变量的引用，且JavaScript的垃圾回收机制会确保闭包中引用的变量在闭包存在期间不会被销毁。</p>
</blockquote>
<p>如果希望在C++中实现类似JavaScript闭包的效果在使用时不需要额外的括号，我们可以通过返回一个对象来实现。这个对象可以重载赋值运算符和类型转换运算符，从而实现类似JavaScript闭包的行为。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Closure</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Closure</span>(std::shared_ptr&lt;<span class="type">int</span>&gt; data) : <span class="built_in">data</span>(data) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载赋值运算符</span></span><br><span class="line">    Closure&amp; <span class="keyword">operator</span>=(<span class="type">int</span> value) &#123;</span><br><span class="line">        *data = value;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载int类型转换运算符</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用shared_ptr来管理数据的生命周期</span></span><br><span class="line">    <span class="keyword">auto</span> data = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建闭包</span></span><br><span class="line">    <span class="keyword">auto</span> closure = [data]() <span class="keyword">mutable</span> -&gt; Closure &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Closure</span>(data);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取闭包</span></span><br><span class="line">    <span class="keyword">auto</span> getData = <span class="built_in">closure</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改外部数据</span></span><br><span class="line">    getData = <span class="number">20</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Data from closure: &quot;</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(getData) &lt;&lt; std::endl; <span class="comment">// 输出: 20</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改闭包中的数据</span></span><br><span class="line">    getData = <span class="number">30</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Data from closure after modification: &quot;</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(getData) &lt;&lt; std::endl; <span class="comment">// 输出: 30</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-23"><a href="#C-23" class="headerlink" title="C++23"></a>C++23</h1><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/NGn5CiQFsn9eGm_bJXoGZg">C++23参考起步链接</a></p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4" title="头像" alt="头像"></a><div class="post-copyright__author_name">ZEROKO14</div><div class="post-copyright__author_desc">zeroko14's blog</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://che77a38.github.io/posts/C++11%E4%B8%8E14/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://che77a38.github.io/posts/C++11%E4%B8%8E14/')">C++11与14</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://che77a38.github.io/posts/C++11%E4%B8%8E14/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=C++11与14&amp;url=https://che77a38.github.io/posts/C++11%E4%B8%8E14/&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://che77a38.github.io" target="_blank">ZEROKO14的个人博客</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/C/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>C++<span class="tagsPageCount">5</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">字符编码</div></div></a></div><div class="next-post pull-right"><a href="/posts/C++%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7%E7%9B%98%E7%82%B9/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">C++相关工具盘点</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/posts/C++%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7%E7%9B%98%E7%82%B9/" title="C++相关工具盘点"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-04-22</div><div class="title">C++相关工具盘点</div></div></a></div><div><a href="/posts/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="C++多线程"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-07-18</div><div class="title">C++多线程</div></div></a></div><div><a href="/posts/mac%E5%8F%8Alinux_C++%E7%8E%AF%E5%A2%83/" title="mac及linux C++环境配置"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-07-16</div><div class="title">mac及linux C++环境配置</div></div></a></div><div><a href="/posts/opencv/" title="opencv"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-04-29</div><div class="title">opencv</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://avatars.githubusercontent.com/u/27732581?s=400&amp;u=303b2c0e2118ad20406f8d718e885bcf99fc8bf8&amp;v=4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description">欢迎来到ZEROKO14的个人博客</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">ZEROKO14</h1><div class="author-info__desc">zeroko14's blog</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/che77a38" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E6%A0%87%E5%87%86%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">C++标准介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AE%E8%AE%A4%E6%94%AF%E6%8C%81C-%E6%A0%87%E5%87%86"><span class="toc-number">1.1.</span> <span class="toc-text">确认支持C++标准</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%84%E7%89%88%E6%9C%AC%E6%96%B0%E5%A2%9E%E7%89%B9%E6%80%A7"><span class="toc-number">2.</span> <span class="toc-text">各版本新增特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#C-11"><span class="toc-number">2.1.</span> <span class="toc-text">C++ 11</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-14"><span class="toc-number">2.2.</span> <span class="toc-text">C++ 14</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-17"><span class="toc-number">2.3.</span> <span class="toc-text">C++ 17</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-20"><span class="toc-number">2.4.</span> <span class="toc-text">C++ 20</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%B0%E7%9A%84%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">新的基础类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#long-long%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.</span> <span class="toc-text">long long类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B0%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.</span> <span class="toc-text">新字符类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#char16-t-char32-t"><span class="toc-number">3.2.1.</span> <span class="toc-text">char16_t&#x2F;char32_t</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#u16string-u32string"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">u16string&#x2F;u32string</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wchar-t"><span class="toc-number">3.2.2.</span> <span class="toc-text">wchar_t</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#char8-t"><span class="toc-number">3.2.3.</span> <span class="toc-text">char8_t</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%B0%81%E8%A3%85%E4%B8%8E%E7%BB%91%E5%AE%9A"><span class="toc-number">4.</span> <span class="toc-text">函数封装与绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#function%E7%B1%BB"><span class="toc-number">4.1.</span> <span class="toc-text">function类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mem-fn%E5%87%BD%E6%95%B0"><span class="toc-number">4.2.</span> <span class="toc-text">mem_fn函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bind%E5%87%BD%E6%95%B0"><span class="toc-number">4.3.</span> <span class="toc-text">bind函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">5.</span> <span class="toc-text">类型转换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E9%A1%BA%E5%BA%8F"><span class="toc-number">6.</span> <span class="toc-text">确定的表达式求值顺序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E9%9D%A2%E9%87%8F%E4%BC%98%E5%8C%96"><span class="toc-number">7.</span> <span class="toc-text">字面量优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E6%B5%AE%E7%82%B9%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">7.1.</span> <span class="toc-text">十六进制浮点字面量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B4%E6%95%B0%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">7.2.</span> <span class="toc-text">二进制整数字面量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E5%BC%95%E5%8F%B7%E4%BD%9C%E4%B8%BA%E6%95%B4%E6%95%B0%E5%88%86%E9%9A%94%E7%AC%A6"><span class="toc-number">7.3.</span> <span class="toc-text">单引号作为整数分隔符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%94%9F%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">7.4.</span> <span class="toc-text">原生字符串字面量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">7.5.</span> <span class="toc-text">用户自定义字面量</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AF%B9%E9%BD%90%E7%9B%B8%E5%85%B3"><span class="toc-number">8.</span> <span class="toc-text">数据对齐相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#alignof%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">8.1.</span> <span class="toc-text">alignof运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#alignas%E8%AF%B4%E6%98%8E%E7%AC%A6"><span class="toc-number">8.2.</span> <span class="toc-text">alignas说明符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%85%B3%E4%BA%8E%E5%AF%B9%E9%BD%90%E5%AD%97%E8%8A%82%E9%95%BF%E5%BA%A6%E7%9A%84%E6%94%AF%E6%8C%81"><span class="toc-number">8.3.</span> <span class="toc-text">其他关于对齐字节长度的支持</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8new%E5%88%86%E9%85%8D%E6%8C%87%E5%AE%9A%E5%AF%B9%E9%BD%90%E9%95%BF%E5%BA%A6%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">8.4.</span> <span class="toc-text">使用new分配指定对齐长度的对象</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E8%AF%B4%E6%98%8E%E7%AC%A6%E5%92%8C%E6%A0%87%E5%87%86%E5%B1%9E%E6%80%A7"><span class="toc-number">9.</span> <span class="toc-text">属性说明符和标准属性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E8%AF%B4%E6%98%8E%E7%AC%A6"><span class="toc-number">9.1.</span> <span class="toc-text">属性说明符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8using%E6%89%93%E5%BC%80%E5%B1%9E%E6%80%A7%E7%9A%84%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">9.2.</span> <span class="toc-text">使用using打开属性的命名空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%B1%9E%E6%80%A7"><span class="toc-number">9.3.</span> <span class="toc-text">标准属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#noreturn"><span class="toc-number">9.3.1.</span> <span class="toc-text">noreturn</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#carries-dependency"><span class="toc-number">9.3.2.</span> <span class="toc-text">carries_dependency</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#deprecated"><span class="toc-number">9.3.3.</span> <span class="toc-text">deprecated</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fallthrough"><span class="toc-number">9.3.4.</span> <span class="toc-text">fallthrough</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nodiscard"><span class="toc-number">9.3.5.</span> <span class="toc-text">nodiscard</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#maybe-unused"><span class="toc-number">9.3.6.</span> <span class="toc-text">maybe_unused</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#likely-unlikely"><span class="toc-number">9.3.7.</span> <span class="toc-text">likely&#x2F;unlikely</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#no-unique-address"><span class="toc-number">9.3.8.</span> <span class="toc-text">no_unique_address</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%B0%E5%A2%9E%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E5%8A%9F%E8%83%BD%E5%92%8C%E5%AE%8F"><span class="toc-number">10.</span> <span class="toc-text">新增预处理器功能和宏</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6%E5%8F%AF%E7%94%A8%E5%AE%8F"><span class="toc-number">10.1.</span> <span class="toc-text">头文件可用宏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E6%80%A7%E6%B5%8B%E8%AF%95%E5%AE%8F"><span class="toc-number">10.2.</span> <span class="toc-text">特性测试宏</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E6%B5%8B%E8%AF%95%E8%BF%90%E7%AE%97%E5%AE%8F"><span class="toc-number">10.2.1.</span> <span class="toc-text">属性测试运算宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E8%A8%80%E5%8A%9F%E8%83%BD%E7%89%B9%E6%80%A7%E6%B5%8B%E8%AF%95%E5%AE%8F"><span class="toc-number">10.2.2.</span> <span class="toc-text">语言功能特性测试宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%BA%93%E5%8A%9F%E8%83%BD%E7%89%B9%E6%80%A7%E6%B5%8B%E8%AF%95%E5%AE%8F"><span class="toc-number">10.2.3.</span> <span class="toc-text">标准库功能特性测试宏</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%B8%8D%E4%B8%BA%E7%A9%BA%E5%AE%8F"><span class="toc-number">10.3.</span> <span class="toc-text">参数不为空宏</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B"><span class="toc-number">11.</span> <span class="toc-text">协程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">11.1.</span> <span class="toc-text">协程的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E6%A0%88%E5%8D%8F%E7%A8%8B"><span class="toc-number">11.1.1.</span> <span class="toc-text">有栈协程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E6%A0%88%E5%8D%8F%E7%A8%8B"><span class="toc-number">11.1.2.</span> <span class="toc-text">无栈协程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-20%E5%8D%8F%E7%A8%8B"><span class="toc-number">11.2.</span> <span class="toc-text">C++20协程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9B%B8%E5%85%B3"><span class="toc-number">12.</span> <span class="toc-text">命名空间相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">12.1.</span> <span class="toc-text">内联命名空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">12.2.</span> <span class="toc-text">嵌套命名空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E5%86%85%E8%81%94%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">12.3.</span> <span class="toc-text">嵌套内联命名空间</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8B%93%E5%B1%95%E7%9A%84inline%E8%AF%B4%E6%98%8E%E7%AC%A6"><span class="toc-number">13.</span> <span class="toc-text">拓展的inline说明符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%8F%98%E9%87%8F"><span class="toc-number">13.1.</span> <span class="toc-text">内联变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E8%81%94%E9%9D%9E%E5%B8%B8%E9%87%8F%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">13.2.</span> <span class="toc-text">内联非常量静态成员变量</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E5%90%8E%E7%BD%AE"><span class="toc-number">14.</span> <span class="toc-text">函数返回类型后置</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%AE%9E%E5%8F%82"><span class="toc-number">15.</span> <span class="toc-text">默认实参</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">16.</span> <span class="toc-text">右值引用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">16.1.</span> <span class="toc-text">左值引用和右值引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%BC%E7%B1%BB%E5%88%AB"><span class="toc-number">16.1.1.</span> <span class="toc-text">值类别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8F%B3%E5%80%BC"><span class="toc-number">16.1.2.</span> <span class="toc-text">左值转换为右值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BD%AC%E6%8D%A2%E6%96%B9%E5%BC%8F"><span class="toc-number">16.1.2.1.</span> <span class="toc-text">基本的转换方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8std-move"><span class="toc-number">16.1.2.2.</span> <span class="toc-text">使用std::move</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89"><span class="toc-number">16.2.</span> <span class="toc-text">移动语义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#move%E5%87%BD%E6%95%B0"><span class="toc-number">16.2.1.</span> <span class="toc-text">move函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%87%E8%83%BD%E5%BC%95%E7%94%A8"><span class="toc-number">16.3.</span> <span class="toc-text">万能引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%87%E8%83%BD%E5%BC%95%E7%94%A8%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-number">16.3.1.</span> <span class="toc-text">万能引用的规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91"><span class="toc-number">16.3.2.</span> <span class="toc-text">完美转发</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%94%AF%E6%8C%81%E7%A7%BB%E5%8A%A8%E7%9A%84%E7%B1%BB"><span class="toc-number">16.4.</span> <span class="toc-text">自定义支持移动的类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E9%BB%98%E8%AE%A4%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">17.</span> <span class="toc-text">非静态成员默认初始化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-number">18.</span> <span class="toc-text">可变参数模板</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A1%88%E4%BE%8B"><span class="toc-number">18.1.</span> <span class="toc-text">函数案例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E6%A1%88%E4%BE%8B"><span class="toc-number">18.2.</span> <span class="toc-text">类案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E7%BB%A7%E6%89%BF"><span class="toc-number">18.2.1.</span> <span class="toc-text">递归继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%A4%8D%E5%90%88"><span class="toc-number">18.2.2.</span> <span class="toc-text">递归复合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%AD%98%E9%97%AE%E9%A2%98"><span class="toc-number">18.3.</span> <span class="toc-text">并存问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E7%89%88%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E7%9A%84%E7%A9%BA%E6%A0%BC"><span class="toc-number">19.</span> <span class="toc-text">模版表达式中的空格</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#nullptr"><span class="toc-number">20.</span> <span class="toc-text">nullptr</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#nullptr-t"><span class="toc-number">20.1.</span> <span class="toc-text">nullptr_t</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E5%90%91%E6%AF%94%E8%BE%83"><span class="toc-number">21.</span> <span class="toc-text">三向比较</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B"><span class="toc-number">21.1.</span> <span class="toc-text">返回类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%94%AF%E6%8C%81"><span class="toc-number">21.2.</span> <span class="toc-text">对基础类型的支持</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E6%AF%94%E8%BE%83%E5%87%BD%E6%95%B0"><span class="toc-number">21.3.</span> <span class="toc-text">自动生成比较函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#auto%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">22.</span> <span class="toc-text">auto关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#auto%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">22.1.</span> <span class="toc-text">auto关键字的特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A8%E5%AF%BC%E8%A7%84%E5%88%99"><span class="toc-number">22.2.</span> <span class="toc-text">推导规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#auto%E5%8D%A0%E4%BD%8D%E7%AC%A6%E4%BD%BF%E7%94%A8"><span class="toc-number">22.3.</span> <span class="toc-text">auto占位符使用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">23.</span> <span class="toc-text">一致性初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#initializer-list"><span class="toc-number">23.1.</span> <span class="toc-text">initializer_list&lt;T&gt;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">23.2.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#initializer-list%E5%8E%9F%E7%90%86"><span class="toc-number">23.3.</span> <span class="toc-text">initializer_list原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E4%B8%8D%E6%94%AF%E6%8C%81%E9%9A%90%E5%BC%8F%E7%BC%A9%E7%AA%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">23.4.</span> <span class="toc-text">初始化列表不支持隐式缩窄转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">23.5.</span> <span class="toc-text">指定初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E8%A6%81%E6%B1%82"><span class="toc-number">23.5.1.</span> <span class="toc-text">语法要求</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">24.</span> <span class="toc-text">委托构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A7%94%E6%89%98%E6%A8%A1%E6%9D%BF%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">24.1.</span> <span class="toc-text">委托模板构造函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">25.</span> <span class="toc-text">继承构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">25.1.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E8%A7%84%E5%88%99"><span class="toc-number">25.2.</span> <span class="toc-text">相关规则</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%BA%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">26.</span> <span class="toc-text">强枚举类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">26.1.</span> <span class="toc-text">三个新特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-1"><span class="toc-number">26.2.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">26.3.</span> <span class="toc-text">枚举类型的列表初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8using%E6%89%93%E5%BC%80%E5%BC%BA%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">26.4.</span> <span class="toc-text">使用using打开强枚举类型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%81%9A%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">27.</span> <span class="toc-text">聚合类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%9A%E5%90%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">27.1.</span> <span class="toc-text">聚合类型的初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E6%8B%AC%E5%8F%B7%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">27.2.</span> <span class="toc-text">小括号列表初始化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84for%E5%BE%AA%E7%8E%AF"><span class="toc-number">28.</span> <span class="toc-text">基于范围的for循环</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#begin%E5%92%8Cend%E5%87%BD%E6%95%B0%E4%B8%8D%E5%BF%85%E8%BF%94%E5%9B%9E%E7%9B%B8%E5%90%8C%E7%B1%BB%E5%9E%8B"><span class="toc-number">28.1.</span> <span class="toc-text">begin和end函数不必返回相同类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%84%8F%E4%B9%89"><span class="toc-number">28.1.1.</span> <span class="toc-text">意义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B4%E6%97%B6%E8%8C%83%E5%9B%B4%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AF%AD%E5%8F%A5"><span class="toc-number">28.2.</span> <span class="toc-text">临时范围表达式初始化语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%94%AF%E6%8C%81%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84for%E5%BE%AA%E7%8E%AF%E7%9A%84%E7%B1%BB"><span class="toc-number">28.3.</span> <span class="toc-text">实现一个支持基于范围的for循环的类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AF%AD%E5%8F%A5%E7%9A%84if%E5%92%8Cswitch"><span class="toc-number">29.</span> <span class="toc-text">支持初始化语句的if和switch</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#if"><span class="toc-number">29.1.</span> <span class="toc-text">if</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#switch"><span class="toc-number">29.2.</span> <span class="toc-text">switch</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#static-assert%E5%A3%B0%E6%98%8E"><span class="toc-number">30.</span> <span class="toc-text">static_assert声明</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">30.1.</span> <span class="toc-text">使用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E5%8F%82%E6%95%B0static-assert"><span class="toc-number">30.2.</span> <span class="toc-text">单参数static_assert</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">31.</span> <span class="toc-text">互斥锁</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#default-delete"><span class="toc-number">32.</span> <span class="toc-text">&#x3D;default&#x2F;&#x3D;delete</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%9E%E5%8F%97%E9%99%90%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">33.</span> <span class="toc-text">非受限联合类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#uncaught-exceptions"><span class="toc-number">34.</span> <span class="toc-text">uncaught_exceptions</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#noexcept"><span class="toc-number">35.</span> <span class="toc-text">noexcept</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8noexcept%E8%A7%A3%E5%86%B3%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E9%97%AE%E9%A2%98"><span class="toc-number">35.1.</span> <span class="toc-text">用noexcept解决移动构造问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#noexcept%E5%92%8Cthrow%E7%9A%84%E5%B7%AE%E5%88%AB"><span class="toc-number">35.2.</span> <span class="toc-text">noexcept和throw的差别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8noexcept%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">35.3.</span> <span class="toc-text">默认使用noexcept的函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8noexcept%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="toc-number">35.4.</span> <span class="toc-text">使用noexcept的时机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E8%A7%84%E8%8C%83%E4%BD%9C%E4%B8%BA%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86"><span class="toc-number">35.5.</span> <span class="toc-text">异常规范作为类型的一部分</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#override-final"><span class="toc-number">36.</span> <span class="toc-text">override&#x2F;final</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#override"><span class="toc-number">36.1.</span> <span class="toc-text">override</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final"><span class="toc-number">36.2.</span> <span class="toc-text">final</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E7%B1%BB"><span class="toc-number">36.2.1.</span> <span class="toc-text">声明类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">36.2.2.</span> <span class="toc-text">声明虚函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E6%95%B0%E7%BB%84%E5%8F%AF%E7%94%A8%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A4%A7%E5%B0%8F"><span class="toc-number">37.</span> <span class="toc-text">局部数组可用变量初始化大小</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#decltype"><span class="toc-number">38.</span> <span class="toc-text">decltype</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">38.1.</span> <span class="toc-text">使用方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A8%E5%AF%BC%E8%A7%84%E5%88%99-1"><span class="toc-number">38.2.</span> <span class="toc-text">推导规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#decltype%E5%92%8Cauto%E9%85%8D%E5%90%88%E4%BD%BF%E7%94%A8"><span class="toc-number">38.3.</span> <span class="toc-text">decltype和auto配合使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8"><span class="toc-number">38.4.</span> <span class="toc-text">主要作用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B"><span class="toc-number">38.4.1.</span> <span class="toc-text">声明返回类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E5%85%83%E7%BC%96%E7%A8%8B"><span class="toc-number">38.4.2.</span> <span class="toc-text">用于元编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E9%80%92lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">38.4.3.</span> <span class="toc-text">传递lambda表达式的类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%E4%B8%8E%E5%88%AB%E5%90%8D%E6%A8%A1%E6%9D%BF"><span class="toc-number">39.</span> <span class="toc-text">类型别名与别名模板</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%AB%E5%90%8D%E6%A8%A1%E6%9D%BF"><span class="toc-number">39.1.</span> <span class="toc-text">别名模板</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">40.</span> <span class="toc-text">Lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Lambdas%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">40.1.</span> <span class="toc-text">Lambdas的一些注意点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E7%8A%B6%E6%80%81Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">40.1.1.</span> <span class="toc-text">无状态Lambda表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8D%95%E8%8E%B7-this-%E5%92%8C-this"><span class="toc-number">40.1.2.</span> <span class="toc-text">捕获[*this]和[&#x3D;,this]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95%E7%9A%84%E6%B3%9B%E5%9E%8Blambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">40.1.3.</span> <span class="toc-text">模板语法的泛型lambda表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#constexpr-lambda"><span class="toc-number">40.1.4.</span> <span class="toc-text">constexpr lambda</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lambdas%E6%A1%88%E4%BE%8B%E7%BB%86%E8%8A%82"><span class="toc-number">40.2.</span> <span class="toc-text">Lambdas案例细节</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lambdas%E5%8E%9F%E7%90%86"><span class="toc-number">40.3.</span> <span class="toc-text">Lambdas原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%EF%BC%88%E9%9A%BE%E7%82%B9%EF%BC%89"><span class="toc-number">40.4.</span> <span class="toc-text">函数对象（难点）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%93%E8%AF%8D"><span class="toc-number">40.4.1.</span> <span class="toc-text">谓词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="toc-number">40.4.2.</span> <span class="toc-text">内建函数对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">40.4.3.</span> <span class="toc-text">函数对象适配器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8bind1st%E5%92%8Cbind2nd"><span class="toc-number">40.4.3.1.</span> <span class="toc-text">函数对象适配器bind1st和bind2nd</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%96%E5%8F%8D%E9%80%82%E9%85%8D%E5%99%A8not1%E5%92%8Cnot2"><span class="toc-number">40.4.3.2.</span> <span class="toc-text">取反适配器not1和not2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E9%80%82%E9%85%8D%E5%99%A8-ptr-fun"><span class="toc-number">40.4.3.3.</span> <span class="toc-text">函数指针适配器 ptr_fun</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E9%80%82%E9%85%8D%E5%99%A8-mem-fun-ref%E5%92%8Cmem-fun"><span class="toc-number">40.4.3.4.</span> <span class="toc-text">成员函数适配器 mem_fun_ref和mem_fun</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#mem-fun-ref"><span class="toc-number">40.4.3.4.1.</span> <span class="toc-text">mem_fun_ref</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#mem-fun"><span class="toc-number">40.4.3.4.2.</span> <span class="toc-text">mem_fun</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">41.</span> <span class="toc-text">智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#auto-ptr"><span class="toc-number">41.1.</span> <span class="toc-text">auto_ptr</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#auto-ptr%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">41.1.1.</span> <span class="toc-text">auto_ptr的局限性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E6%88%96%E8%80%85%E8%B5%8B%E5%80%BC%E9%83%BD%E4%BC%9A%E6%94%B9%E5%8F%98%E8%B5%84%E6%BA%90%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83"><span class="toc-number">41.1.1.1.</span> <span class="toc-text">复制或者赋值都会改变资源的所有权</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E6%94%AF%E6%8C%81%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">41.1.1.2.</span> <span class="toc-text">不支持对象数组的内存管理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unique-ptr"><span class="toc-number">41.2.</span> <span class="toc-text">unique_ptr</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#auto-ptr%E4%B8%8Eunique-ptr%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E9%99%B7%E9%98%B1"><span class="toc-number">41.2.1.</span> <span class="toc-text">auto_ptr与unique_ptr智能指针的内存管理陷阱</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#shared-ptr"><span class="toc-number">41.3.</span> <span class="toc-text">shared_ptr</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8api"><span class="toc-number">41.3.1.</span> <span class="toc-text">常用api</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">41.3.2.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%AE%A1%E7%90%86%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84"><span class="toc-number">41.3.3.</span> <span class="toc-text">使用智能指针管理对象数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shared-ptr%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">41.3.4.</span> <span class="toc-text">shared_ptr工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shared-ptr%E6%A8%A1%E6%8B%9F%E4%BB%A3%E7%A0%81"><span class="toc-number">41.3.5.</span> <span class="toc-text">shared_ptr模拟代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shared-ptr%E4%BD%BF%E7%94%A8%E9%99%B7%E9%98%B1"><span class="toc-number">41.3.6.</span> <span class="toc-text">shared_ptr使用陷阱</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#weak-ptr"><span class="toc-number">41.4.</span> <span class="toc-text">weak_ptr</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A"><span class="toc-number">42.</span> <span class="toc-text">结构化绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%94%9F%E6%95%B0%E7%BB%84"><span class="toc-number">42.1.</span> <span class="toc-text">绑定原生数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A%E5%88%B0%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E7%B1%BB%E5%AF%B9%E8%B1%A1"><span class="toc-number">42.2.</span> <span class="toc-text">绑定到结构体和类对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A%E5%88%B0%E5%85%83%E7%BB%84%E5%92%8C%E7%B1%BB%E5%85%83%E7%BB%84%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">42.3.</span> <span class="toc-text">绑定到元组和类元组的对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">42.4.</span> <span class="toc-text">结构化绑定的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98"><span class="toc-number">42.5.</span> <span class="toc-text">绑定的访问权限问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">43.</span> <span class="toc-text">常量表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%87%BD%E6%95%B0"><span class="toc-number">43.1.</span> <span class="toc-text">常量表达式函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F%E6%9D%A1%E4%BB%B6-C-11%E6%A0%87%E5%87%86"><span class="toc-number">43.1.1.</span> <span class="toc-text">约束条件(C++11标准)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F%E6%9D%A1%E4%BB%B6%E6%96%B0%E6%A0%87%E5%87%86-C-14%E6%A0%87%E5%87%86"><span class="toc-number">43.1.2.</span> <span class="toc-text">约束条件新标准(C++14标准)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F%E6%9D%A1%E4%BB%B6%E6%8B%93%E5%B1%95-C-20"><span class="toc-number">43.1.3.</span> <span class="toc-text">约束条件拓展(C++20)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#constexpr-lambdas%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">43.1.4.</span> <span class="toc-text">constexpr lambdas表达式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">43.2.</span> <span class="toc-text">常量表达式构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E4%BA%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B"><span class="toc-number">43.2.1.</span> <span class="toc-text">作用于自定义类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F%E6%9D%A1%E4%BB%B6"><span class="toc-number">43.2.2.</span> <span class="toc-text">约束条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%84%8F%E4%B9%89-1"><span class="toc-number">43.2.3.</span> <span class="toc-text">意义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#if-constexpr"><span class="toc-number">43.3.</span> <span class="toc-text">if constexpr</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#consteval"><span class="toc-number">43.4.</span> <span class="toc-text">consteval</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#constinit"><span class="toc-number">43.5.</span> <span class="toc-text">constinit</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8constinit%E6%A3%80%E6%9F%A5%E5%B8%B8%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E8%A7%84%E5%88%99"><span class="toc-number">43.5.1.</span> <span class="toc-text">使用constinit检查常量初始化规则</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%AD%98%E5%82%A8"><span class="toc-number">44.</span> <span class="toc-text">线程局部存储</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%AD%98%E5%82%A8%E7%9A%84%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80"><span class="toc-number">44.1.</span> <span class="toc-text">线程局部存储的内存地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%AD%98%E5%82%A8%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%94%80%E6%AF%81"><span class="toc-number">44.2.</span> <span class="toc-text">线程局部存储对象初始化和销毁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tuple"><span class="toc-number">45.</span> <span class="toc-text">tuple</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">46.</span> <span class="toc-text">线程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#stl%E6%96%B0%E5%AE%B9%E5%99%A8"><span class="toc-number">47.</span> <span class="toc-text">stl新容器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E8%B0%B7%E6%AD%8C%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83"><span class="toc-number">48.</span> <span class="toc-text">C++谷歌代码规范</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Boost"><span class="toc-number">49.</span> <span class="toc-text">Boost</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#filesystem"><span class="toc-number">49.1.</span> <span class="toc-text">filesystem</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#emplace"><span class="toc-number">50.</span> <span class="toc-text">emplace</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-17%E4%B8%89%E5%89%91%E5%AE%A2"><span class="toc-number">51.</span> <span class="toc-text">C++17三剑客</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#optional"><span class="toc-number">51.1.</span> <span class="toc-text">optional</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA-optional-%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">51.1.1.</span> <span class="toc-text">创建一个 optional 的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE-optional-%E5%AF%B9%E8%B1%A1%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">51.1.2.</span> <span class="toc-text">访问 optional 对象中数据的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%ADoption%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E6%9C%89%E5%80%BC"><span class="toc-number">51.1.3.</span> <span class="toc-text">判断option对象是否有值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%80%E6%AF%81optino%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84%E5%80%BC"><span class="toc-number">51.1.4.</span> <span class="toc-text">销毁optino对象中的值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-number">52.</span> <span class="toc-text">C++中的函数式编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%AF%E5%87%BD%E6%95%B0"><span class="toc-number">52.1.</span> <span class="toc-text">纯函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="toc-number">52.2.</span> <span class="toc-text">高阶函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="toc-number">52.2.1.</span> <span class="toc-text">常用的高阶函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E5%87%BD%E6%95%B0%E4%B8%8E%E7%AE%A1%E9%81%93%E5%87%BD%E6%95%B0"><span class="toc-number">52.2.2.</span> <span class="toc-text">组合函数与管道函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">52.2.2.1.</span> <span class="toc-text">组合函数的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">52.2.2.2.</span> <span class="toc-text">管道函数的实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%81%8F%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9F%AF%E9%87%8C%E5%8C%96"><span class="toc-number">52.3.</span> <span class="toc-text">偏函数与柯里化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%9F%AF%E9%87%8C%E5%8C%96"><span class="toc-number">52.3.1.</span> <span class="toc-text">实现柯里化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">52.4.</span> <span class="toc-text">闭包</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-23"><span class="toc-number">53.</span> <span class="toc-text">C++23</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/%E5%B7%A5%E4%B8%9A%E7%9B%B8%E5%85%B3/" title="工业相关">工业相关</a><time datetime="2025-02-14T03:04:40.761Z" title="发表于 2025-02-14 11:04:40">2025-02-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/%E8%AE%A1%E7%BB%84/" title="计算机组成原理">计算机组成原理</a><time datetime="2024-12-16T01:38:01.470Z" title="发表于 2024-12-16 09:38:01">2024-12-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/" title="网络架构">网络架构</a><time datetime="2024-11-18T06:17:01.282Z" title="发表于 2024-11-18 14:17:01">2024-11-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/avalonia/" title="avalonia">avalonia</a><time datetime="2024-09-11T14:51:13.000Z" title="发表于 2024-09-11 22:51:13">2024-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/%E8%A7%86%E9%A2%91%E6%95%88%E6%9E%9C/" title="PR">PR</a><time datetime="2024-07-18T07:06:08.330Z" title="发表于 2024-07-18 15:06:08">2024-07-18</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2025 By <a class="footer-bar-link" href="/" title="ZEROKO14" target="_blank">ZEROKO14</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu"></a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">60</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">50</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">6</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size: 0.88rem;">C#<sup>2</sup></a><a href="/tags/C/" style="font-size: 0.88rem;">C++<sup>5</sup></a><a href="/tags/CSS/" style="font-size: 0.88rem;">CSS<sup>1</sup></a><a href="/tags/CSharp/" style="font-size: 0.88rem;">CSharp<sup>1</sup></a><a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 0.88rem;">C语言<sup>1</sup></a><a href="/tags/FPS/" style="font-size: 0.88rem;">FPS<sup>1</sup></a><a href="/tags/HTML/" style="font-size: 0.88rem;">HTML<sup>1</sup></a><a href="/tags/JavaScript/" style="font-size: 0.88rem;">JavaScript<sup>1</sup></a><a href="/tags/MFC/" style="font-size: 0.88rem;">MFC<sup>1</sup></a><a href="/tags/PE/" style="font-size: 0.88rem;">PE<sup>1</sup></a><a href="/tags/QT/" style="font-size: 0.88rem;">QT<sup>1</sup></a><a href="/tags/WPF/" style="font-size: 0.88rem;">WPF<sup>2</sup></a><a href="/tags/ai/" style="font-size: 0.88rem;">ai<sup>1</sup></a><a href="/tags/cmake/" style="font-size: 0.88rem;">cmake<sup>1</sup></a><a href="/tags/doxygen/" style="font-size: 0.88rem;">doxygen<sup>1</sup></a><a href="/tags/git/" style="font-size: 0.88rem;">git<sup>1</sup></a><a href="/tags/json/" style="font-size: 0.88rem;">json<sup>1</sup></a><a href="/tags/linux/" style="font-size: 0.88rem;">linux<sup>1</sup></a><a href="/tags/nas/" style="font-size: 0.88rem;">nas<sup>1</sup></a><a href="/tags/next/" style="font-size: 0.88rem;">next<sup>1</sup></a><a href="/tags/ppt/" style="font-size: 0.88rem;">ppt<sup>1</sup></a><a href="/tags/slidev/" style="font-size: 0.88rem;">slidev<sup>1</sup></a><a href="/tags/vue/" style="font-size: 0.88rem;">vue<sup>1</sup></a><a href="/tags/xml/" style="font-size: 0.88rem;">xml<sup>1</sup></a><a href="/tags/yaml/" style="font-size: 0.88rem;">yaml<sup>1</sup></a><a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 0.88rem;">代码规范<sup>1</sup></a><a href="/tags/%E5%86%85%E6%A0%B8/" style="font-size: 0.88rem;">内核<sup>2</sup></a><a href="/tags/%E5%86%85%E6%A0%B8%E7%9B%B8%E5%85%B3/" style="font-size: 0.88rem;">内核相关<sup>5</sup></a><a href="/tags/%E5%8A%A0%E8%A7%A3%E5%AF%86/" style="font-size: 0.88rem;">加解密<sup>1</sup></a><a href="/tags/%E5%9F%BA%E7%A1%80/" style="font-size: 0.88rem;">基础<sup>2</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 0.88rem;">多线程<sup>1</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F/" style="font-size: 0.88rem;">并发模式<sup>1</sup></a><a href="/tags/%E5%BC%80%E5%8F%91/" style="font-size: 0.88rem;">开发<sup>4</sup></a><a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 0.88rem;">数学<sup>1</sup></a><a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 0.88rem;">正则表达式<sup>1</sup></a><a href="/tags/%E7%9B%91%E6%8E%A7/" style="font-size: 0.88rem;">监控<sup>1</sup></a><a href="/tags/%E7%A1%AC%E7%BC%96%E7%A0%81/" style="font-size: 0.88rem;">硬编码<sup>1</sup></a><a href="/tags/%E7%AE%A1%E7%90%86/" style="font-size: 0.88rem;">管理<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 0.88rem;">网络<sup>3</sup></a><a href="/tags/%E9%80%86%E5%90%91/" style="font-size: 0.88rem;">逆向<sup>2</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.cbd.int/mathjax@3.2.2/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.cbd.int/mermaid@10.2.4/dist/mermaid.min.js').then(runMermaid)
  }

  anzhiyu.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>