---
title: 网络编程
tags: 网络
categories: 技术





---

# 网络基础

- OSI七层,TCP/IP四层模型结构
- 常见网络协议格式
- 网络字节序和主机字节序之间的转换(大端法和小端法)
- tcp服务器端/客户端通信流程

<!-- more -->

## 分层模型

### 网络分层OSI 7层模型

**OSI**是Open System Interconnection的缩写, 意为开放式系统互联. 国际标准化组织(ISO)制定了OSI模型, 该模型定义了不同计算机互联的标准, 是设计和描述计算机网络通信的基本框架.

![image-20220729162142546](https://raw.githubusercontent.com/che77a38/blogImage2/main/202207291621467.png)

1. **物理层**---双绞线，光纤（传输介质），将**模拟信号转换为数字信号**(通过调制解调器modemn)
2. **数据链路层**---**数据校验**，定义了**网络传输的基本单位**-**帧**     [ARP,RARP协议](#以太网帧格式)
3. **网络层**---定义网络，两台机器之间**传输的路径选择点到点的传输**    IP协议
4. **传输层**---传输数据 TCP，UDP，**端到端的传输** (不需要考虑中间经过的点)    TCP,UDP协议
5. **会话层**---通过传输层建立数据传输的通道.    
6. **表示层**---编解码，翻译工作.
7. **应用层**---为客户提供各种应用服务，email服务，ftp服务，ssh服务 

详解

| 分层       | 功能                                                         |
| ---------- | ------------------------------------------------------------ |
| 物理层     | 主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输，到达目的地后再转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。 |
| 数据链路层 | 定义了如何让格式化数据以帧为单位进行传输，以及如何让控制对物理介质的访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输。如：串口通信中使用到的115200、8、N、1 |
| 网络层     | 在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。 |
| 传输层     | 定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。 |
| 会话层     | 通过传输层(端口号：传输端口与接收端口)建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名）。 |
| 表示层     | 可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码(EBCDIC)，而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。 |
| 应用层     | 是最靠近用户的OSI层。这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务。 |

### TCP/IP  4层模型

上面的OSI模型只是一个理想模型,实际上现在应用的是TCP/IP四层模型

TCP/IP网络协议栈分为应用层（Application）、传输层（Transport）、网络层（Network）和链路层（Link）四层

![image-20220729165744363](https://raw.githubusercontent.com/che77a38/blogImage2/main/202207291657925.png)![image-20220729165801715](https://raw.githubusercontent.com/che77a38/blogImage2/main/202207291658851.png)

分层的含义如下图:

传输层及其以下的机制由内核提供，应用层由用户进程提供（后面将介绍如何使用socket API编写应用程序），应用程序对通讯数据的含义进行解释，而传输层及其以下处理通讯的细节，将数据从一台计算机通过一定的路径发送到另一台计算机。应用层数据通过协议栈发到网络上时，每层协议都要加上一个数据首部（header），称为封装（Encapsulation），如下图所示：

![image-20220801153019809](https://raw.githubusercontent.com/che77a38/blogImage2/main/202208011530002.png)

通信过程: 其实就是发送端层层打包, 接收方层层解包.

<img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202208011525225.png" alt="image-20220801152504753" />

不同的协议层对数据包有不同的称谓，在传输层叫做**段（segment）**，在网络层叫做**数据报（datagram）**，在链路层叫做**帧（frame）**。数据封装成帧后发到传输介质上，到达目的主机后每层协议再剥掉相应的首部，最后将应用层数据交给应用程序处理。

### TCP/IP协议分层通讯全过程

<img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202208011625011.png" alt="image-20220801162510989" style="zoom: 67%;" /><img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202208011625682.png" alt="image-20220801162514898" style="zoom: 67%;" />

​		链路层有以太网、令牌环网等标准，链路层负责网卡设备的驱动、帧同步（即从网线上检测到什么信号算作新帧的开始）、冲突检测（如果检测到冲突就自动重发）、数据差错校验等工作。交换机是工作在链路层的网络设备，可以在不同的链路层网络之间转发数据帧（比如十兆以太网和百兆以太网之间、以太网和令牌环网之间），由于不同链路层的帧格式不同，交换机要将进来的数据包拆掉链路层首部重新封装之后再转发。

​		链路层有以太网、令牌环网等标准，链路层负责网卡设备的驱动、帧同步（即从网线上检测到什么信号算作新帧的开始）、冲突检测（如果检测到冲突就自动重发）、数据差错校验等工作。交换机是工作在链路层的网络设备，可以在不同的链路层网络之间转发数据帧（比如十兆以太网和百兆以太网之间、以太网和令牌环网之间），由于不同链路层的帧格式不同，交换机要将进来的数据包拆掉链路层首部重新封装之后再转发。
​		网络层的IP协议是构成Internet的基础。Internet上的主机通过IP地址来标识，Inter-net上有大量路由器负责根据IP地址选择合适的路径转发数据包，数据包从Internet上的源主机到目的主机往往要经过十多个路由器。路由器是工作在第三层的网络设备，同时兼有交换机的功能，可以在不同的链路层接口之间转发数据包，因此路由器需要将进来的数据包拆掉网络层和链路层两层首部并重新封装。IP协议不保证传输的可靠性，数据包在传输过程中可能丢失，可靠性可以在上层协议或应用程序中提供支持。
​		网络层负责点到点（ptop，point-to-point）的传输（这里的“点”指主机或路由器），而传输层负责端到端（etoe，end-to-end）的传输（这里的“端”指源主机和目的主机）。传输层可选择TCP或UDP协议。
TCP是一种面向连接的、可靠的协议，有点像打电话，双方拿起电话互通身份之后就建立了连接，然后说话就行了，这边说的话那边保证听得到，并且是按说话的顺序听到的，说完话挂机断开连接。也就是说TCP传输的双方需要首先建立连接，之后由TCP协议保证数据收发的可靠性，丢失的数据包自动重发，上层应用程序收到的总是可靠的数据流，通讯之后关闭连接。
​		UDP是无连接的传输协议，不保证可靠性，有点像寄信，信写好放到邮筒里，既不能保证信件在邮递过程中不会丢失，也不能保证信件寄送顺序。使用UDP协议的应用程序需要自己完成丢包重发、消息排序等工作。
​		目的主机收到数据包后，如何经过各层协议栈最后到达应用程序呢？其过程如下图所示：

![image-20220801162904659](https://raw.githubusercontent.com/che77a38/blogImage2/main/202208011629493.png)

​		以太网驱动程序首先根据以太网首部中的“上层协议”字段确定该数据帧的有效载荷（payload，指除去协议首部之外实际传输的数据）是IP、ARP还是RARP协议的数据报，然后交给相应的协议处理。假如是IP数据报，IP协议再根据IP首部中的“上层协议”字段确定该数据报的有效载荷是TCP、UDP、ICMP还是IGMP，然后交给相应的协议处理。假如是TCP段或UDP段，TCP或UDP协议再根据TCP首部或UDP首部的“端口号”字段确定应该将应用层数据交给哪个用户进程。IP地址是标识网络中不同主机的地址，而端口号就是同一台主机上标识不同进程的地址，IP地址和端口号合起来标识网络中唯一的进程。

​		虽然IP、ARP和RARP数据报都需要以太网驱动程序来封装成帧，但是从功能上划分，ARP和RARP属于链路层，IP属于网络层。虽然ICMP、IGMP、TCP、UDP的数据都需要IP协议来封装成数据报，但是从功能上划分，ICMP、IGMP与IP同属于网络层，TCP和UDP属于传输层。

## 协议

**协议事先约定好, 大家共同遵守的一组规则**, 如交通信号灯.从应用程序的角度看, 协议可理解为**数据传输和数据解释的规则**;可以简单的理解为各个主机之间进行通信所使用的共同语言.

当原始协议经过不断增加完善改进, 最终形成了一个稳定的完整的传输协议, 被广泛应用于各种文件传输, 该协议逐渐就成了一个**标准协议**.

几种常见的标准协议

- **传输层** 常见协议有TCP/UDP协议。
- **应用层** 常见的协议有HTTP协议，FTP协议。
- **网络层** 常见协议有IP协议、ICMP协议、IGMP协议。
- **网络接口层** 常见协议有ARP协议、RARP协议。

TCP协议注重数据的传输。http协议着重于数据的解释。

**具体协议含义**

- `TCP传输控制协议`（Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议。
- `UDP用户数据报协议`（User Datagram Protocol）是OSI参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。
- `HTTP超文本传输协议`（Hyper Text Transfer Protocol）是互联网上应用最为广泛的一种网络协议。
- `FTP文件传输协议`（File Transfer Protocol）
- `IP协议是因特网互联协议`（Internet Protocol）
- `ICMP协议`是Internet控制报文协议（Internet Control Message Protocol）它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。
- `IGMP协议`是 Internet 组管理协议（Internet Group Management Protocol），是因特网协议家族中的一个组播协议。该协议运行在主机和组播路由器之间。
- `ARP协议`是正向地址解析协议（Address Resolution Protocol），通过已知的IP，寻找对应主机的MAC地址。
- `RARP`是反向地址转换协议，通过MAC地址确定IP地址。

## 网络相关名词

#### 设备相关

- 路由（名词）
  数据包从源地址到目的地址所经过的路径，由一系列路由节点组成。
- 路由（动词）
  某个路由节点为数据包选择投递方向的选路过程。

**路由节点**

一个具有路由能力的主机或路由器，它维护一张路由表，通过查询路由表来决定向哪个接口发送数据包。

##### 以太网交换机工作原理

> 以太网交换机是基于以太网传输数据的交换机，以太网采用共享总线型传输媒体方式的局域网。以太网交换机的结构是每个端口都直接与主机相连，并且一般都工作在全双工方式。交换机能同时连通许多对端口，使每一对相互通信的主机都能像独占通信媒体那样，进行无冲突地传输数据。
> 以太网交换机工作于OSI网络参考模型的第二层（即数据链路层），是一种基于MAC（Media Access Control，介质访问控制）地址识别、完成以太网数据帧转发的网络设备。

交换机刚启动时，MAC地址表中无表项。当接入PC的时候，交换机开始进行[学习MAC地址](https://zhuanlan.zhihu.com/p/122241071).

交换机对数据帧的转发与过滤:

- 单播帧的转发：

  ![](https://raw.githubusercontent.com/che77a38/blogImage2/main/202208151208471.jpeg)

  - PCA发出目的到PCD的单播数据帧
  - 交换机根据帧中的目的地址，从相应的端口E1/0/4发送出去
  - 交换机不在其他端口上转发此单播数据帧

- 广播、组播和未知单播帧的转发：

  ![img](https://raw.githubusercontent.com/che77a38/blogImage2/main/202208151213890.jpeg)

  ​			交换机会把广播、组播和未知单播帧从所有其他端口发送出去（除了接收到帧的端口）

[交换机原理详解跳转](https://zhuanlan.zhihu.com/p/122241071)

##### 路由表(Routing Table)

在计算机网络中，路由表或称路由择域信息库（RIB）是一个存储在路由器或者联网计算机中的电子表格（文件）或类数据库。路由表存储着指向特定网络地址的路径。

##### 路由条目

路由表中的一行，每个条目主要由**目的网络地址(Destination)、子网掩码(Genmask)、下一跳地址(GateWay)、发送接口(Iface)**四部分组成，如果要发送的数据包的目的网络地址匹配路由表中的某一行，就按规定的接口发送到下一跳地址。

##### 缺省路由条目

路由表中的最后一行，主要由下一跳地址和发送接口两部分组成，当目的地址与路由表中其它行都不匹配时，就按缺省路由条目规定的接口发送到下一跳地址。

##### 路由器工作原理

> 路由器（Router）是连接因特网中各局域网、广域网的设备，它会根据信道的情况自动选择和设定路由，以最佳路径，按前后顺序发送信号的设备。
> 传统地，路由器工作于OSI七层协议中的第三层，其主要任务是接收来自一个网络接口的数据包，根据其中所含的目的地址，决定转发到下一个目的地址。因此，路由器首先得在转发路由表中查找它的目的地址，若找到了目的地址，就在数据包的帧格前添加下一个MAC地址，同时IP数据包头的TTL（Time To Live）域也开始减数， 并重新计算校验和。当数据包被送到输出端口时，它需要按顺序等待，以便被传送到输出链路上。
> 路由器在工作时能够按照某种路由通信协议查找设备中的路由表。如果到某一特定节点有一条以上的路径，则基本预先确定的路由准则是选择最优（或最经济）的传输路径。由于各种网络段和其相互连接情况可能会因环境变化而变化，因此路由情况的信息一般也按所使用的路由信息协议的规定而定时更新。
> 网络中，每个路由器的基本功能都是按照一定的规则来动态地更新它所保持的路由表，以便保持路由信息的有效性。为了便于在网络间传送报文，路由器总是先按照预定的规则把较大的数据分解成适当大小的数据包，再将这些数据包分别通过相同或不同路径发送出去。当这些数据包按先后秩序到达目的地后，再把分解的数据包按照一定顺序包装成原有的报文形式。路由器的分层寻址功能是路由器的重要功能之一，该功能可以帮助具有很多节点站的网络来存储寻址信息，同时还能在网络间截获发送到远地网段的报文，起转发作用；选择最合理的路由，引导通信也是路由器基本功能；多协议路由器还可以连接使用不同通信协议的网络段，成为不同通信协议网络段之间的通信平台。
> 路由和交换之间的主要区别就是交换发生在OSI参考模型第二层（数据链路层），而路由发生在第三层，即网络层。这一区别决定了路由和交换在移动信息的过程 中需使用不同的控制信息，所以两者实现各自功能的方式是不同的。

![img](https://raw.githubusercontent.com/che77a38/blogImage2/main/202208151132125.png)

如上图图所示：路由器A和B是经过配置的路由在他们的路由表中就保存了相应的网段和接口，如果主机1.1要发送数据包给主机3.1：

1. 因为IP地址不在同一网段，主机就会将数据包发送给本网段的网关路由器A。
2. 路由器A接收到数据包，查看数据包IP首部中的目标IP地址，在查找自己的路由表。数据包的目标IP地址是3.1.属于3.0网段路由器A在路由表中查到3.0网段转发的接口是S0接口。于是，路由器就将数据包从S0接口转发出去。
3. 每个路由器但是按这个步骤去转发数据的，直到到达了路由器B,用同样的方法，从E0口转发出去，主机3.1接受到这个数据包。

[同网段和不同网段主机通信的区别就在于]  **同网段直接查找主机，而不同网段需要将数据包发送给网关。**

### 其他名词

[集线器](https://baike.baidu.com/item/%E9%9B%86%E7%BA%BF%E5%99%A8/214614?fr=aladdin)

#### 半双工/全双工

- Full-duplex（全双工）全双工是在通道中同时双向数据传输的能力。
- Half-duplex（半双工）在通道中同时只能沿着一个方向传输数据。

#### DNS服务器

DNS 是**域名系统 (Domain Name System)** 的缩写，是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个**分布式数据库**，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP地址串。
它是由解析器以及域名服务器组成的。域名服务器是指保存有该网络中所有主机的域名和对应IP地址，并**具有将域名转换为IP地址功能**的服务器。

操作系统中可通过`hosts`文件手动设置如何解析域名

- Linux/Mac: `/etc/hosts`
- Windows: `C:\Windows\System32\drivers\etc\hosts`

hosts文件格式: `IP地址  域名`(#行表示注释)

#### 局域网(LAN)

local area network，一种覆盖一座或几座大楼、一个校园或者一个厂区等地理区域的小范围的计算机网。

1. 覆盖的地理范围较小，只在一个相对独立的局部范围内联，如一座或集中的建筑群内。
2. 使用专门铺设的传输介质进行联网，数据传输速率高（10Mb/s～10Gb/s）
3. 通信延迟时间短，可靠性较高
4. 局域网可以支持多种传输介质

#### 广域网(WAN)

wide area network，一种用来实现不同地区的局域网或城域网的互连，可提供不同地区、城市和国家之间的计算机通信的远程计算机网。
覆盖的范围比局域网（LAN）和城域网（MAN）都广。广域网的通信子网主要使用**分组交换技术**。
广域网的通信子网可以利用公用分组交换网、卫星通信网和无线分组交换网，它将分布在不同地区的局域网或计算机系统互连起来，达到资源共享的目的。如互联网是世界范围内最大的广域网。

1. 适应大容量与突发性通信的要求；
2. 适应综合业务服务的要求；
3. 开放的设备接口与规范化的协议；
4. 完善的通信服务与网络管理。

#### MTU

MTU:通信术语 **最大传输单元（Maximum Transmission Unit，MTU）**
是指一种通信协议的某一层上面所能通过的最大数据包大小（以字节为单位）。最大传输单元这个参数通常与通信接口有关（网络接口卡、串口等）。

以下是一些协议的MTU：

FDDI协议：4352字节
以太网（Ethernet）协议：1500字节
PPPoE（ADSL）协议：1492字节
X.25协议（Dial Up/Modem）：576字节
Point-to-Point：4470字节 

## 网络相关命令

ping命令

**查看网络信息**

-  mac/Linux: `ifconfig`  (interface configuration)  
- windows: `ipconfig`
- linux下还可以使用 `nmcli` 命令(NetworkManager)(部分linux系统需要安装)

**查询路由表**

- Windows: `route print`
- Mac: `netstat -rn`
- Linux: `route -n`

<img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202208151503698.jpeg" alt="截屏2022-08-15 15.02.37" style="zoom:33%;" />

**查询经过的路由器信息**

- Mac/Linux: `traceroute + IP/域名`
- Linux: `tracepath + IP/域名`
- Windows: `tracert + IP/域名`

**打印公网ip**

Linux/Mac: `echo "cat</dev/tcp/ns1.dnspod.net/6666"|bash`

## 网络程序的设计模式

### C/S设计模式

传统的网络应用设计模式，客户机(client)/服务器(server)模式。需要在通讯两端各自部署客户机和服务器来完成数据通信。

优点:

- 客户端在本机上可以保证性能, 可以将数据缓存到本地, 提高数据的传输效率, 提高用户体验效果.
- 客户端和服务端程序都是由同一个开发团队开发, 协议选择比较灵活.

缺点:

- 服务器和客户端都需要开发，工作量相对较大, 调试困难, 开发周期长;
- 从用户的角度看, 需要将客户端安装到用户的主机上, 对用户主机的安全构成威胁.

### B/S设计模式

浏览器(browser)/服务器(server)模式。只需在一端部署服务器，而另外一端使用每台PC都默认配置的浏览器即可完成数据的传输。

优点:

- 无需安装客户端, 可以使用标准的浏览器作为客户端;
- 只需要开发服务器，工作量相对较小;
- 由于采用标准的客户端, 所以移植性好, 不受平台限制.
- 相对安全，不用安装软件

缺点:

- 由于没有客户端, 数据缓冲不尽人意, 数据传输有限制, 用户体验较差;
- 通信协议选择只能使用HTTP协议，协议选择不够灵活;

> 对于C/S模式来说，其优点明显。客户端位于目标主机上可以保证性能，将数据缓存至客户端本地，从而提高数据传输效率。且，一般来说客户端和服务器程序由一个开发团队创作，所以他们之间所采用的协议相对灵活。可以在标准协议的基础上根据需求裁剪及定制。例如，腾讯公司所采用的通信协议，即为ftp协议的修改剪裁版。
> 	因此，传统的网络应用程序及较大型的网络应用程序都首选C/S模式进行开发。如，知名的网络游戏魔兽世界。3D画面，数据量庞大，使用C/S模式可以提前在本地进行大量数据的缓存处理，从而提高观感。
> 	C/S模式的缺点也较突出。由于客户端和服务器都需要有一个开发团队来完成开发。工作量将成倍提升，开发周期较长。另外，从用户角度出发，需要将客户端安插至用户主机上，对用户主机的安全性构成威胁。这也是很多用户不愿使用C/S模式应用程序的重要原因。
>
> ​	B/S模式相比C/S模式而言，由于它没有独立的客户端，使用标准浏览器作为客户端，其工作开发量较小。只需开发服务器端即可。另外由于其采用浏览器显示数据，因此移植性非常好，不受平台限制。如早期的偷菜游戏，在各个平台上都可以完美运行。
> ​	B/S模式的缺点也较明显。由于使用第三方浏览器，因此网络应用支持受限。另外，没有客户端放到对方主机上，缓存数据不尽如人意，从而传输数据量受到限制。应用的观感大打折扣。第三，必须与浏览器一样，采用标准http协议进行通信，协议选择不灵活。
> ​	因此在开发过程中，模式的选择由上述各自的特点决定。根据实际需求选择应用程序设计模式。

## tcp原理

### 三次握手四次挥手

建立连接需要三次握手,断开连接需要四次挥手

![image-20220817131155533](https://raw.githubusercontent.com/che77a38/blogImage2/main/202208171311906.png)<img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202208021259348.png" alt="image-20220802125922013" style="zoom: 67%;" />

> 段2的箭头上标着SYN, 8000(0), ACK1001, ，表示该段中的SYN位置1，32位序号是8000，该段不携带有效载荷（数据字节数为0），ACK位置1，32位确认序号是1001，带有一个mss（Maximum Segment Size，最大报文长度）选项值为1024。

SYS----->synchronous
ACK----->acknowledgement	
FIN------>finish

ACK表示确认序号, 确认序号的值是对方发送的`序号值+数据的长度`, 	特别注意的是**SYN和FIN本身也会占用一位**.

#### 建立三次握手的过程

1. 客户端发送一个带SYN标志的TCP报文到服务器。这是三次握手过程中的段1

   > 客户端发出段1，SYN位表示连接请求。序号是1000，这个序号在网络通讯中用作临时的地址，每发一个数据字节，这个序号要加1，这样在接收端可以根据序号排出数据包的正确顺序，也可以发现丢包的情况，另外，规定SYN位和FIN位也要占一个序号，这次虽然没发数据，但是由于发了SYN位，因此下次再发送应该用序号1001。mss表示最大段尺寸，如果一个段太大，封装成帧后超过了链路层的最大帧长度，就必须在IP层分片，为了避免这种情况，客户端声明自己的最大段尺寸，建议服务器端发来的段不要超过这个长度。

2. 服务器端回应客户端，是三次握手中的第2个报文段，同时带ACK标志和SYN标志。它表示对刚才客户端SYN的回应；同时又发送SYN给客户端，询问客户端是否准备好进行数据通讯

   > 服务器发出段2，也带有SYN位，同时置ACK位表示确认，确认序号是1001，表示“我接收到序号1000及其以前所有的段，请你下次发送序号为1001的段”，也就是应答了客户端的连接请求，同时也给客户端发出一个连接请求，同时声明最大尺寸为1024。

3. 客户必须再次回应服务器端一个ACK报文，这是报文段3

   > 客户端发出段3，对服务器的连接请求进行应答，确认序号是8001。在这个过程中，客户端和服务器分别给对方发了连接请求，也应答了对方的连接请求，其中服务器的请求和应答在一个段中发出，因此一共有三个段用于建立连接，称为“三方握手（three-way-handshake）”。在建立连接的同时，双方协商了一些信息，例如双方发送序号的初始值、最大段尺寸等。

在TCP通讯中，如果一方收到另一方发来的段，读出其中的目的端口号，发现本机并没有任何进程使用这个端口，就会应答一个包含RST位的段给另一方。例如，服务器并没有任何进程使用8080端口，我们却用telnet客户端去连接它，服务器收到客户端发来的SYN段就会应答一个RST段，客户端的telnet程序收到RST段后报告错误`Connection refused`

#### 数据传输的过程

1. 客户端发出段4，包含从序号1001开始的20个字节数据
2. 服务器发出段5，确认序号为1021，对序号为1001-1020的数据表示确认收到，同时请求发送序号1021开始的数据，服务器在应答的同时也向客户端发送从序号8001开始的10个字节数据，这称为piggyback
3. 客户端发出段6，对服务器发来的序号为8001-8010的数据表示确认收到，请求发送序号8011开始的数据

在数据传输过程中，**ACK和确认序号是非常重要的**，应用程序交给TCP协议发送的数据会暂存在TCP层的发送缓冲区中，发出数据包给对方之后，只有收到对方应答的ACK段才知道该数据包确实发到了对方，可以从发送缓冲区中释放掉了，如果因为网络故障丢失了数据包或者丢失了对方发回的ACK段，经过等待超时后TCP协议自动将发送缓冲区中的数据包重发。

#### 关闭连接（四次挥手）的过程

由于TCP连接是**全双工**的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。

1. 客户端发出段7，FIN位表示关闭连接的请求
2. 服务器发出段8，应答客户端的关闭连接请求
3. 服务器发出段9，其中也包含FIN位，向客户端发送关闭连接请求
4. 客户端发出段10，应答服务器的关闭连接请求

![image-20220817151120112](https://raw.githubusercontent.com/che77a38/blogImage2/main/202208171511230.png)

建立连接的过程是三方握手，而关闭连接通常需要4个段，**服务器的应答和关闭连接请求通常不合并在一个段中，因为有连接半关闭的情况，这种情况下客户端关闭连接之后就不能再发送数据给服务器了**，但是服务器还可以发送数据给客户端，直到服务器也关闭连接为止。

当双方刚好同时关闭的时候(概率很低),是存在`ACK`和`FIN,ACK`包合并为同一个发送的情况的,**这种情况只需要三步挥手**便结束了.

**[重点的问题理解]**

1. 为什么四次挥手中,被动被请求关闭连接的一方要发送**一个确认包和一个请求关闭连接包,**而不能仅仅发一个请求连接包?

   因为第一个确认包仅仅表示收到了对方关闭连接的请求,但自身却还可能有未发送完的数据,第二个请求关闭连接包才真正表示自身的发送也完成可以关闭了.即表示第一个包和第二个包之间依然可以发送未发送完的数据包.

2. 为什么最先请求关闭连接的一方在第四次挥手发送确认包后还要**等待2倍MSL时间**?

   1. 让四次挥手的过程更可靠, 确保最后一个发送给对方的ACK到达;
   
      若对方没有收到ACK应答, 对方会再次发送FIN请求关闭, 此时在2MS时间内被动关闭方仍然可以发送ACK给对方
   
      补充解释:发送的ACK有可能丢失,如果ACK丢失,另一方会重发关闭连接请求包,两个MSL时间可以大幅度增加接收到重发的关闭连接请求包的情况的可能.但是情况依旧不完美,因为重发的关闭请求包也存在丢失的可能,如果也丢失了,重发的时间又超过了2倍MSL时间,那么他将等不到发回来的确定包,即等不到关闭的时机.(脑补应该用心跳包解决)
   
   2. 为了保证在2MS时间内, 不能启动相同的SOCKET-PAIR.
   
      ​		`TIME_WAIT`一定是出现在主动关闭的一方, 也就是说2MS是针对主动关闭一方来说的;由于TCP有可能存在丢包重传, 丢包重传若发给了已经断开连接之后相同的socket-pair(该连接是新建的, 与原来的socket-pair完全相同, 双方使用的是相同的IP和端口), 这样会对之后的连接造成困扰, 严重可能引起程序异常.因此很多操作系统实现的时候, 只要端口被占用, 服务就不能启动.通过这个方式尽可能解决该程序异常. (实际上服务端每次都是使用的同一个端口,而客户端一般设置为由内核分配随机端口,会避免这种问题发生.因此实际上很难发生这样的情况)
   

### tcp状态转换

socket-pair的概念: 客户端与服务端连接其实是一个连接对, 可以通过使用`netstat -anp | grep 端口号`进行查看(linux)

![image-20220823115550841](https://raw.githubusercontent.com/che77a38/blogImage2/main/202208231155852.png)

说明: 上图中粗线表示主动方, 虚线表示被动方, 细线部分表示一些特殊情况

![image-20220823115705716](https://raw.githubusercontent.com/che77a38/blogImage2/main/202208231157549.png)

**三次握手过程**

客户端-->服务端

- 客户端:`SYN_SENT`    ---     connect()

- 服务端: 

  `LISTEN`    ---     listen() 

  `SYN_RCVD`     ---     收到连接请求的时候状态转换

**数据传输过程中**

状态不会发生变化,一直都是`ESTABLISHED`状态

**四次挥手过程**

客户端<-->服务端

- 主动关闭方

  `FIN_WAIT_1`    ---     close()

  `FIN_WAIT_2`    ---     收到被动接收方确认断开连接请求的时候状态转换

  `TIME_WAIT`      ---     收到被动接收方的断开请求时候的状态转换

- 被动关闭方

  `CLOSE_WAIT`     ---     收到断开连接请求的时候状态转换

  `LAST_ACK`    ---     close()

主动关闭的Socket端会进入`TIME_WAIT`状态，并且持续2MSL时间长度，MSL就是**`maximum segment lifetime`(最大分节生命期）**，这是一个IP数据包能在互联网上生存的最长时间，超过这个时间将在网络中消失。

### 滑动窗口

主要作用: 滑动窗口主要是进行流量控制的.
见下图:如果发送端发送的速度较快，接收端接收到数据后处理的速度较慢，而接收缓冲区的大小是固定的，就会导致接收缓冲区满而丢失数据。TCP协议通过“滑动窗口（Sliding Window）”机制解决这一问题。

![image-20220817160708623](https://raw.githubusercontent.com/che77a38/blogImage2/main/202208171607253.png)

1.	发送端发起连接，声明最大段尺寸是1460，初始序号是0，窗口大小是4K，表示“我的接收缓冲区还有4K字节空闲，你发的数据不要超过4K”。接收端应答连接请求，声明最大段尺寸是1024，初始序号是8000，窗口大小是6K。发送端应答，三方握手结束。
2.	发送端发出段4-9，每个段带1K的数据，发送端根据窗口大小知道接收端的缓冲区满了，因此停止发送数据。
3.	接收端的应用程序提走2K数据，接收缓冲区又有了2K空闲，接收端发出段10，在应答已收到6K数据的同时声明窗口大小为2K。
4.	接收端的应用程序又提走2K数据，接收缓冲区有4K空闲，接收端发出段11，重新声明窗口大小为4K。
5.	发送端发出段12-13，每个段带2K数据，段13同时还包含FIN位。
6.	接收端应答接收到的2K数据（6145-8192），再加上FIN位占一个序号8193，因此应答序号是8194，连接处于半关闭状态，接收端同时声明窗口大小为2K。
7.	接收端的应用程序提走2K数据，接收端重新声明窗口大小为4K。
8.	接收端的应用程序提走剩下的2K数据，接收缓冲区全空，接收端重新声明窗口大小为6K。
9.	接收端的应用程序在提走全部数据后，决定关闭连接，发出段17包含FIN位，发送端应答，连接完全关闭。

win表示告诉对方我这边缓冲区大小是多少, mss表示告诉对方我这边最多一次可以接收多少数据, 你最好不要超过这个长度.

在客户端给服务端发包的时候, 不一定是非要等到服务端返回响应包, 由于客户端知道服务端的窗口大小, 所以可以持续多次发送, 当发送数据达到对方窗口大小了就不再发送, 需要等到对方进行处理, 对方处理之后可继续发送.

mss和MTU的区别

- `MTU`: 最大传输单元  Maximum Transmission Unit，MTU）
  是指一种通信协议的某一层上面所能通过的最大数据包大小（以字节为	单位). 最大传输单元这个参数通常与通信接口有关（网络接口卡、串	口等), 这个值如果设置为太大会导致丢包重传的时候重传的数据量较大, 	图中的最大值是1500, 其实是一个经验值.

- `mss`: 最大报文长度

  只是在建立连接的时候, 告诉对方我最大能够接收多少数据, 在数据通信的过程中就没有mss了.

从这个例子还可以看出，发送端是一K一K地发送数据，而接收端的应用程序可以两K两K地提走数据，当然也有可能一次提走3K或6K数据，或者一次只提走几个字节的数据。也就是说，应用程序所看到的数据是一个整体，或说是一个流（stream），在底层通讯中这些数据可能被拆成很多数据包来发送，但是一个数据包有多少字节对应用程序是不可见的，因此TCP协议是面向流的协议。而UDP是面向消息的协议，每个UDP段都是一条消息，应用程序必须以消息为单位提取数据，不能一次提取任意字节的数据，这一点和TCP是很不同的。

## 以太网帧格式

以太网帧格式就是**包装在网络接口层(数据链路层)的协议**

*以太网帧的类型为     0x0806: 表示 ARP 类型;0X8035 表示 RARP 类型*

![image-20220801160410607](https://raw.githubusercontent.com/che77a38/blogImage2/main/202208011604164.png)

> 其中的源地址和目的地址是指网卡的硬件地址（也叫MAC地址），长度是48位，是在网卡出厂时固化的。可在shell中使用ifconfig命令查看，“HWaddr 00:15:F2:14:9E:3F”部分就是硬件地址。协议字段有三种值，分别对应IP、ARP、RARP。帧尾是CRC校验码。
> 以太网帧中的数据长度规定最小46字节，最大1500字节，**ARP和RARP数据包的长度不够46字节，要在后面补填充位**(填充位的内容没有定义，与具体实现相关)。最大值1500称为**以太网的最大传输单元（MTU）**，不同的网络类型有不同的MTU，如果一个数据包从以太网路由到拨号链路上，数据包长度大于拨号链路的MTU，则需要对数据包进行分片（fragmentation）。ifconfig命令输出中也有“MTU:1500”。注意，MTU这个概念指数据帧中有效载荷的最大长度，不包括帧头长度。

以ARP为例介绍以太网帧格式

### ARP数据报格式

地址解析协议ARP  (Address Resolution Protocol)

​		在网络通讯时，源主机的应用程序知道目的主机的IP地址和端口号，却不知道目的主机的硬件地址，而数据包首先是被网卡接收到再去处理上层协议的，如果接收到的数据包的硬件地址与本机不符，则直接丢弃。因此在通讯前必须获得目的主机的硬件地址。ARP协议就起到这个作用。源主机发出ARP请求，询问“IP地址是192.168.0.1的主机的硬件地址是多少”，并将这个请求广播到本地网段（**以太网帧首部的硬件地址填FF:FF:FF:FF:FF:FF表示广播**），目的主机接收到广播的ARP请求，发现其中的IP地址与本机相符，则发送一个ARP应答数据包给源主机，将自己的硬件地址填写在应答包中。
​		每台主机都维护一个ARP缓存表，可以用`arp -a`命令查看。缓存表中的表项有过期时间（一般为20分钟），如果20分钟内没有再次使用某个表项，则该表项失效，下次还要发ARP请求来获得目的主机的硬件地址。

ARP数据报的格式如下所示：

![image-20220801161139071](https://raw.githubusercontent.com/che77a38/blogImage2/main/202208011611692.png)

源MAC地址、目的MAC地址在以太网首部和ARP请求中各出现一次，对于链路层为以太网的情况是多余的，但如果链路层是其它类型的网络则有可能是必要的。**硬件类型指链路层网络类型**，1为以太网，**协议类型指要转换的地址类型**，0x0800为IP地址，后面两个地址长度对于以太网地址和IP地址分别为6和4（字节），**op字段为1表示ARP请求，op字段为2表示ARP应答。**

目的端mac地址是通过发送端发送ARP广播, 接收到该ARP数据的主机先判断是否是自己的IP, 若是则应答一个ARP应答报文, 并将mac地址填入应答报文中; 若目的IP不是自己的主机IP, 则直接丢弃该ARP请求报文.

![image-20220801170907341](https://raw.githubusercontent.com/che77a38/blogImage2/main/202208011709059.png)

如上图所示,**ARP协议**目的:解决同一个局域网上的主机或路由器的ip地址和硬件地址的映射问题

### 抓包命令

抓包命令: `tcpdump -ntx`

![image-20220802154101644](https://raw.githubusercontent.com/che77a38/blogImage2/main/202208021541290.png)

思考题：如果源主机和目的主机不在同一网段，ARP请求的广播帧无法穿过路由器，源主机如何与目的主机通信？

那么就要通过ARP找到一个位于本局域网上的某个路由器的硬件地址,然后把分组发送个这个路由器,让这个路由器把分组转发给下一个网络,剩下的工作就由下一个网络来做

### IP段格式

IP协议是TCP/IP协议族的基石，它为上层提供无状态、无连接、不可靠的服务

- 无状态：指IP通信双方不同步传输数据的状态信息，因此所有IP数据报的发送，传输，接收都是相互独立的。这种服务最大缺点是无法处理乱序和重复的IP数据报。优点是简单高效，和UDP协议与HTTP协议相同，都是无状态协议。
- 无连接：指IP通信双方都不长久的维持对方的任何信息。这表示上层协议每次发送数据，都需要明确指定对方的IP地址。
- 不可靠：指IP协议不能IP数据报能准确到达接收端，只是会尽最大努力。一旦发送失败，就通知上层协议，而不会试图重发。

![image-20220801173138936](https://raw.githubusercontent.com/che77a38/blogImage2/main/202208011731994.png)

- **4位版本号**：指定IP协议的版本，对于IPv4来说，其值为4，其它IPv4扩展版本则具有不同的版本号（如SIP协议和PIP协议）
- **4位头部长度**：表示IP头部有多少个32bit字（4字节）。因为4位最大15，所以IP头部最长为60字节。
- **8位服务类型**：3位优先级权字段（现已被忽略），4位TOS字段和1位保留字段（必须置0）.4位TOS字段分别表示：最小延迟，最大吞吐量、最高可靠性和最小费用，其中最多1个能置为1。
- **16位总长度**：指整个IP数据包的长度，字节为单位。最长65535字节，由于长度超过MTU的数据报将被分片传输，所以实际传输的长度没有达到最大值。
- **16位标识**：唯一标识主机发送的每个数据报。初始值由系统随机生成，每发送一个数据报，其值加一。该值在数据报分片时被复制到每个分片中，因此**同一个数据报的所有分片标识值都相同**
- **3位标志**：第一位保留，第二位表示是否禁止分片，如果设置了该位，IP数据报长度超过MTU将被丢弃，返回错误。第三位表示更多分片，除了最后一个分片，其它都要置它为1.
- **13位分片偏移**：该分片相较于原始IP数据报开始处（仅指数据部分）的偏移。实际偏移值是该值左移3位得到。因此除了最后一个分片，每个分片的数据部分长度必须是8的整数倍。
- **8位生存时间**：数据报到达目的地之前允许经过的路由器跳数。每经过一个路由，该值减一，为0时被丢弃。并返回TCMP错误报文。
- **8位协议**：用于区分上层协议。ICMP为1，TCP为6，UDP为17。
- **16位头部校验和**：由发送端填充，接收端对其使用CRC算法检验数据是否被损坏。
- **32位源端IP地址**：标识数据报的发送端。在传输过程中保持不变
- **32位源目的端IP地址**：标识数据报的接收端。在传输过程中保持不变
- **选项字段**：可变长的可选信息，最多40字节。可用的IP选项有：
  - 记录路由：将数据包经由的所有路由器IP填入该段。
  - 时间戳：将数据报在每个路由器被转发时的时间填入该段。
  - 松散源路由选择：指定路由器IP地址列表，数据报发送过程中必须经过其中所有路由器
  - 严格源路由选择：类似上面，数据报只能经过被指定的路由器。

/////////////////////////////////////////////未解决///////////////////////////////

思考题：想一想，前面讲了以太网帧中的最小数据长度为46字节，不足46字节的要用填充字节补上，那么如何界定这46字节里前多少个字节是IP、ARP或RARP数据报而后面是填充字节？

#### ip分片

当IP数据报的长度超过帧的MTU时，它将被分片传输。分片可能发生在发送端，也可能发生在中转路由器上，而且在传输过程中可能被多次分片，只有在最终目标机器上，这些分片才会在内核中被IP模块重新组装。

IP头部中的数据报标识、标志、和片偏移为IP的分片和重组提供了足够的信息。

一个数据报的每个分片都具有自己的IP头部，且具有相同的标识，但具有不同的片偏移，除了最后一个分片之外都设置了MF标志。

**ip路由的工作模式**

![image-20220802164931881](https://raw.githubusercontent.com/che77a38/blogImage2/main/202208021649196.png)

IP模块收到来自数据链路层的IP数据报，首先对数据报的头部做CRC校验，无误后开始分析头部具体信息。

如果IP数据报头部设置了源站选路选项，则IP模块调用数据报转发子模块来处理该数据报。

如果该数据报的头部目标IP地址是本机的某个IP地址，或者广播地址，则IP模块根据数据报协议字段来决定发送给哪个上层应用。如果不是本机，则掉用数据报转发子模块来处理该数据报。

数据报转发模块检查系统是否允许转发，不允许则丢弃。允许则将该数据报执行一些操作，就将它交给IP数据报输出模块。

IP数据报根据路由表计算下一跳路由。

IP输出队列存放所有等待发送的IP数据报。

#### 路由机制

1. 查找路由表中和数据报的目标IP完全匹配的主机IP地址，如果找到，就直接使用该项，没有就到第二步
2. 查找路由表中和目标IP具有相同的网路ID的IP地址，如Gateway，有就使用，否则来到第三步
3. 选择默认路由项，这一般为网关。

执行`route`命令可查看路由表

![image-20220802165344800](https://raw.githubusercontent.com/che77a38/blogImage2/main/202208021653124.png)

- `Destination`：目标网络或主机
- `Gateway`：网关地址，*表示目标与本机在同一个网络上，不需要路由。
- `Genmask`：网络掩码
- `Flags`：路由标志，U：该路由活动，H：该路由目标是一个主机，G：该路由目标是网关，D：该路由是重定向产生的，M：该路由被重定向修改过
- `Metric`：路由距离，达到目标网络所需的中转数
- `Ref`：路由项被引用的次数
- `Use`：该路由项被使用的次数
- `Iface`：该路由对应的输出网卡接口

#### IPv6

IPv6由40个字节的固定头部和可变长的扩展头部组成。

![image-20220802165506044](https://raw.githubusercontent.com/che77a38/blogImage2/main/202208021655270.png)

- 4位版本号：IP协议版本，IPv6值为6
- 8位通信类型：指示数据通信类型和优先级
- 20位流标志：用于某些对连接服务质量有特殊要求的通信。
- 16位净荷长度：指IPv6扩展头部和应用程序数据长度之和，不包含固定头部长度
- 8位下一个包头：指紧跟IPv6固定头部的包头类型，如扩展头或上层协议。
- 8位跳数限制：和IPv4的TTL含义相同
- 后两项IP地址：IPv6地址一般用16进制字符串表示，用‘:’分割为8组，每组两个字节。

### UDP数据报格式

无连接的,不安全,不可靠的

> UDP（UserDatagramProtocol）是一个简单的面向消息的传输层协议，尽管UDP提供标头和有效负载的完整性验证（通过校验和），但它不保证向上层协议提供消息传递，并且UDP层在发送后不会保留UDP 消息的状态。因此，UDP有时被称为不可靠的数据报协议。如果需要传输可靠性，则必须在用户应用程序中实现。
>
> UDP使用具有**最小协议机制**的简单无连接通信模型。UDP提供数据完整性的校验和，以及用于在数据报的源和目标寻址不同函数的端口号。它没有握手对话，因此将用户的程序暴露在底层网络的任何不可靠的方面。如果在网络接口级别需要纠错功能，应用程序可以使用为此目的设计的传输控制协议（TCP）。

- UDP是基于IP的简单协议，不可靠的协议。

- UDP的优点：简单，轻量化。

- UDP的缺点：没有流控制，没有应答确认机制，不能解决丢包、重发、错序问题。

  并不是所有使用UDP协议的应用层都是不可靠的，应用程序可以自己实现可靠的数据传输，通过增加确认和重传机制，所以使用UDP 协议最大的特点就是速度快。

其他特点:

- UDP **没有拥塞控制**

  网络出现的拥塞不会使源主机的发送速率降低。这对某些实时应用是很重要的。

- UDP 支持**一对一、一对多、多对一和多对多**的交互通信。

**[UDP的应用]**      UDP协议一般作为流媒体应用、语音交流、视频会议所使用的传输层协议，还有许多基于互联网的电话服务使用的VOIP（基于IP的语音）也是基于UDP运行的.这些**实时应用**要求源主机以恒定的速率发送数据，并且允许在网络出现拥塞时丢失一部分数据，但却不允许数据有太大的时延。UDP 协议正好适合这种要求。

#### UDP头部格式

![image-20220801175246809](https://raw.githubusercontent.com/che77a38/blogImage2/main/202208011752367.png)

- 通过IP地址来确定网络环境中的唯一的一台主机;
- 主机上使用端口号来区分不同的应用程序.  
- [IP+端口] 唯一确定 [一台主机上的一个应用程序].

> `/etc/services`中列出了所有规定的服务端口和对应的传输层协议，这是由IANA（Internet Assigned Numbers Authority）规定的，其中有些服务既可以用TCP也可以用UDP，为了清晰，IANA规定这样的服务采用相同的TCP或UDP默认端口号，而另外一些TCP和UDP的相同端口号却对应不同的服务。
>
> 很多服务有规定的端口号，然而客户端程序的端口号却不必是规定的，往往是每次运行客户端程序时由系统自动分配一个空闲的端口号，用完就释放掉，称为ephemeral的端口号

​		发送端的UDP协议层只管把应用层传来的数据封装成段交给IP协议层就算完成任务了，如果因为网络故障该段无法发到对方，UDP协议层也不会给应用层返回任何错误信息。

​		接收端的UDP协议层只管把收到的数据根据端口号交给相应的应用程序就算完成任务了，如果发送端发来多个数据包并且在网络上经过不同的路由，到达接收端时顺序已经错乱了，UDP协议层也不保证按发送时的顺序交给应用层。
通常接收端的UDP协议层将收到的数据放在一个固定大小的缓冲区中等待应用程序来提取和处理，如果应用程序提取和处理的速度很慢，而发送端发送的速度很快，就会丢失数据包，UDP协议层并不报告这种错误。

​		因此，使用UDP协议的应用程序必须考虑到这些可能的问题并实现适当的解决方案，例如等待应答、超时重发、为数据包编号、流量控制等。一般使用UDP协议的应用程序实现都比较简单，只是发送一些对可靠性要求不高的消息，而不发送大量的数据。例如，基于UDP的TFTP协议一般只用于传送小文件（所以才叫trivial的ftp），而基于TCP的FTP协议适用于各种文件的传输。

举例:

```c
//基于UDP的TFTP协议帧
//以太网首部
00 05 5d 67 d0 b1 00 05 5d 61 58 a8 08 00
//IP首部
45 00
00 53 93 25 00 00 80 11 25 ec c0 a8 00 37 c0 a8
00 01
//UDP首部
05 d4 00 45 00 3f ac 40
//TFTP协议
00 01 'c'':''\''q'
'w''e''r''q''.''q''w''e'00 'n''e''t''a''s''c''i'
'i'00 'b''l''k''s''i''z''e'00 '5''1''2'00 't''i'
'm''e''o''u''t'00 '1''0'00 't''s''i''z''e'00 '0'
//TFTP是基于文本的协议，各字段之间用字节0分隔，开头的00 01表示请求读取一个文件，接下来的各字段是：
```

![image-20220802170722364](https://raw.githubusercontent.com/che77a38/blogImage2/main/202208021707586.png)

wireshark抓包

![image-20220802172344382](https://raw.githubusercontent.com/che77a38/blogImage2/main/202208021723238.png)

#### udp连接机制

![image-20220802171337336](https://raw.githubusercontent.com/che77a38/blogImage2/main/202208021713870.png)

服务器在特定端口上收到UDP 数据包时，将通过以下两个步骤进行响应

- 服务器首先检查是否有任何当前侦听指定端口请求的程序正在运行。
- 如果该端口上没有程序正在接收数据包，则服务器将以 ICMP (ping) 数据包作为响应，以告知发送方目标不可达。

导致>>**UDP洪水攻击**     解决方案:大多数操作系统限制ICMP 数据包的响应速率

### TCP数据流格式

稳定的, 安全的, 可靠的    [TCP原理跳转](#tcp原理)

![image-20220802171257567](https://raw.githubusercontent.com/che77a38/blogImage2/main/202208021713235.png)

- TCP协议用于**1对1**，即不能用于基于广播和多播的应用程序
- TCP连接双方的**收发数据次数不一定相同**，即发送多次的数据包，可能会被对方1次全部接收
- TCP在发送数据报后，必须得到接收方的应答，才认为传输成功，所以是**可靠的**
- TCP采用**超时重传**机制，超过时间没收到应答，就会重新发送。

#### tcp头部结构

![image-20220802125922013](https://raw.githubusercontent.com/che77a38/blogImage2/main/202208021259348.png)

- 16位端口号：指定数据从哪个端口来，发送到哪个端口。

- 32位序号：一次TCP通信中，每段字节流的编号。如A与B通信，第一个报文中，序列值被系统初始化为随机值，之后的传输（A到B），该序号值将被设定为初始值加上第一个字节在整个字节流中的偏移。

- 32位确认号：用作对另一方发送的TCP报文段的响应，其值是收到的TCP报文段序号值加一。

- 4位头部长度：标识该TCP头部有多少个32bit字（4字节），即最长为60字节

- 6位标志位：

  ​	- `URG`：标识紧急指针是否有效

  ​	- `ACK`：标识确认号是否有效

  ​	- `PSH`：提示接收端应立即从TCP接收缓存区中读走数据

  ​	- `RST`：表示要求对方重新建立连接

  ​	- `SYN`：表示请求建立一个连接

  ​	- `FIN`：通知对方关闭连接

- 16位窗口大小：TCP流量控制的一个手段，告诉对方本地TCP接收缓存区还能容纳多少字节的数据

- 16位校验和：由发送端填充，接收端对TCP报文段执行CRC算法校验数据是否损坏。

- 16位紧急指针：正的偏移量，它和序号字段的值相加表示最后一个紧急数据的下一个字节序号

- [选项](#典型选项结构)：为可变长的可选信息

##### 典型选项结构

![image-20220802174222523](https://raw.githubusercontent.com/che77a38/blogImage2/main/202208021742241.png)

- kind：说明选项的类型
- length：选项的总长度
- info：选项的具体信息

常见TCP的7种选项：

![image-20220802174327208](https://raw.githubusercontent.com/che77a38/blogImage2/main/202208021743928.png)

kind的常见类型解释

1. kind=0：选项表结束
2. kind=1：空操作，一般用于将TCP选项的总长度填充为4字节的整数倍
3. kind=2：最大报文段长度选项，初次连接，双方通过此选项协商最大报文长度，TCP通常设置此为MTU-40字节，避免被分片
4. kind=3：窗口扩大因子选项。TCP头部通知窗口为N，扩大因子为M，则实际接收通知窗口为N*(2的M次方)，且只能出现在同步报文段中，否则被忽略
5. kind=4：选择性确定（Selective Acknowledge，SACK）。如果某个TCP报文段丢失，则TCP模块会重传最后被确认的TCP报文段后续所有报文段。而该选项则可解决这种问题。
6. kind=5：SACK实际工作选项。告诉发送端本端已经收到的数据块，从而让发送端只发送丢失的数据
7. kind=8：时间戳。提供通信双方较为精确的回路时间。

#### TCP连接机制

/////////////////////////////////

tcp协议未完待续

///////////////////////////////////

## ip地址转换

下面函数名的理解:

p->表示点分十进制的字符串形式
to->到
n->表示network网络

### inet_pton函数

将字符串形式的点分十进制IP转换为大端模式的网络IP(整形4字节数)

```c
int inet_pton(int af, const char *src, void *dst);
//inet_pton(AF_INET, "127.0.0.1", &serv.sin_addr.s_addr);
```

参数说明:
		`af`: AF_INET或AF_INET6,分别对应ipv4和ipv6
		`src`: 字符串形式的点分十进制的IP地址
		`dst`: 存放转换后的变量的地址

### inet_ntop函数

网络IP转换为字符串形式的点分十进制的IP

```c
const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);
```

参数说明:
		`af`: AF_INET
		`src`: 网络的整形的IP地址
		`dst`: 转换后的IP地址,一般为字符串数组
		`size`: dst的长度
返回值: 
		成功--返回指向dst的指针
		失败--返回NULL, 并设置errno

## 网络字节序

- 大端: 低位地址存放高位数据, 高位地址存放低位数据(网络字节序)
- 小端: 低位地址存放低位数据, 高位地址存放高位数据

数据的高低位:右边为低位,左边为高位,`E.g.  0x1234,34为低位数据,12为高位数据`

网络传输用的是大端法, 如果机器用的是小端法, 则需要进行大小端的转换.

### 大小端转换

```c
  #include <arpa/inet.h>
       uint32_t htonl(uint32_t hostlong);
       uint16_t htons(uint16_t hostshort);
       uint32_t ntohl(uint32_t netlong);
       uint16_t ntohs(uint16_t netshort);
//函数名的h表示主机host, n表示网络network, s表示short, l表示long
```

上述的几个函数, 如果本来不需要转换函数内部就不会做转换.

# socket编程

传统的进程间通信借助内核提供的IPC机制进行, 但是只能限于本机通信, 若要跨机通信, 就必须使用网络通信.( 本质上借助内核-内核提供了socket伪文件的机制实现通信----实际上是使用文件描述符), 这就需要用到内核提供给用户的socket API函数库.因为socket的伪文件机制, 所以可以使用文件描述符相关的函数read write

如下图, 一个文件描述符操作两个缓冲区, 这点跟管道是不同的, 管道是两个文件描述符操作一个内核缓冲区.

![image-20220803110150586](https://raw.githubusercontent.com/che77a38/blogImage2/main/202208031101069.png)

## 相关结构体

socket编程用到的重要的结构体:`struct sockaddr`

![image-20220803114648128](https://raw.githubusercontent.com/che77a38/blogImage2/main/202208031146839.png)

sockaddr结果参数使用sockaddr_in结构体变量来填充就可以了,内部划分得更细致

```c
//struct sockaddr结构说明:
   struct sockaddr {
        sa_family_t sa_family;
        char     sa_data[14];
   }
//struct sockaddr_in结构:
struct sockaddr_in {
         sa_family_t    sin_family; /* address family: AF_INET */
         in_port_t      sin_port;   /* port in network byte order */
         struct in_addr sin_addr;   /* internet address */
   };

   /* Internet address. */
   struct in_addr {
         uint32_t  s_addr;     /* address in network byte order */
   };	 //网络字节序IP--大端模式

//通过man 7 ip可以查看相关说明
```

> **sockaddr_in**在[头文件](https://so.csdn.net/so/search?q=头文件&spm=1001.2101.3001.7020)`#include<netinet/in.h>或#include <arpa/inet.h>`中定义
>
> 有时候没有包括#include <netinet/in.h> ，而包括#include <arpa/inet.h>，在server端和client端一般要将端口号从主机序转换成网络序，那么需要htons( )函数就需要头文件 #include <arpa/inet.h>，就自然不用另一个了。可以通过编译啦。
>
> 查询函数所需的头文件用 `man htons`命令
>
> 但是有些系统是需要netinet/in.h而不能是arpa/inet.h

## 主要函数

- [socket函数](#socket函数)
- [bind函数](#bind函数)
- [listen函数](#listen函数)
- [accept函数](#accept函数)
- [connect函数](#connect函数)
- [读写相关函数](#读写相关函数)

![image-20220803145641364](https://raw.githubusercontent.com/che77a38/blogImage2/main/202208031456553.png)

### socket函数

创建socket

```c
int socket(int domain, int type, int protocol);
```

参数说明:
		`domain`: 协议版本
				`AF_INET` IPV4
				`AF_INET6` IPV6
				`AF_UNIX`  `AF_LOCAL`本地套接字使用
		`type`:协议类型
				`SOCK_STREAM` 流式, 默认使用的协议是TCP协议
				`SOCK_DGRAM`  报式, 默认使用的是UDP协议
		`protocal`: 
				一般填0, 表示使用对应类型的默认协议.
返回值: 
		成功: 返回一个大于0的文件描述符
		失败: 返回-1, 并设置errno

当调用socket函数以后, **返回一个文件描述符, 内核会提供与该文件描述符相对应的读和写缓冲区**, **同时还有两个队列, 分别是请求连接队列和已连接队列.**

### bind函数

将socket文件描述符和IP,PORT绑定

```c
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
```

参数说明:
		`socket`: 调用socket函数返回的文件描述符
		`addr`: 本地服务器的IP地址和PORT, 

```c
struct sockaddr_in serv;
serv.sin_family = AF_INET;
serv.sin_port = htons(8888);
//serv.sin_addr.s_addr = htonl(INADDR_ANY);
//INADDR_ANY: 表示使用本机任意有效的可用IP(服务器可以插狠多张网卡)
inet_pton(AF_INET, "127.0.0.1", &serv.sin_addr.s_addr);
```

​		`addrlen`: addr变量的占用的内存大小 
返回值: 
​		成功: 返回0
​		失败: 返回-1, 并设置errno

### listen函数

将套接字由主动态变为被动态

```c
int listen(int sockfd, int backlog);
```

参数说明:
		`sockfd`: 调用socket函数返回的文件描述符
		`backlog`: 同时请求连接的最大个数(还未建立连接) ,最大是128
返回值:
		成功: 返回0
		失败: 返回-1, 并设置errno

### accept函数

获得一个连接, 若当前没有连接则会阻塞等待.

```c
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);	
```

函数参数:
		`sockfd`: 调用socket函数返回的文件描述符
		`addr`: **传出参数**, **保存客户端的地址信息** 
		`addrlen`: 传入传出参数,  addr变量所占内存空间大小
返回值:
		成功: 返回一个新的**文件描述符,用于和客户端通信**
		失败: 返回-1, 并设置errno值.

accept函数是一个**阻塞函数**, 若没有新的连接请求, 则一直阻塞.
从已连接队列中获取一个新的连接, 并获得一个新的文件描述符, 该文件描述符用于和客户端通信.  (**内核会负责将请求队列中的连接拿到已连接队列中**)

### connect函数

连接服务器

```c
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
```

函数参数:  *(和bind函数参数类型一样)*
		`sockfd`: 调用socket函数返回的文件描述符
		`addr`: 服务端的地址信息
		`addrlen`: addr变量的内存大小
返回值:
		成功: 返回0
		失败: 返回-1, 并设置errno值

### 读写相关函数

读取数据和发送数据:

```c
ssize_t read(int fd, void *buf, size_t count);
ssize_t write(int fd, const void *buf, size_t count);
ssize_t recv(int sockfd, void *buf, size_t len, int flags);
ssize_t send(int sockfd, const void *buf, size_t len, int flags);	
//对应recv和send这两个函数flags直接填0就可以了.
//阻塞状态下,read返回0表示客户端断开连接,读取完毕
```

注意: 如果写**缓冲区已满, write也会阻塞**, read读操作的时候, 若**读缓冲区没有数据会引起阻塞**.

## 测试工具

### `nc`命令

以客户端的方式连接小工具

ubuntu系统安装方式: `sudo apt-get -y install netcat-traditional`
$$
nc\;\;ip地址\;端口号
$$
例如:  `nc  192.168.0.2  8888`

### `netstat`命令

测试过程中可以使用`netstat`命令查看监听状态和连接状态
netstat命令: 

- `a`表示显示所有,
- `n`表示显示的时候以数字的方式来显示
- `p`表示显示进程信息(进程名和进程PID)

一般用 `netstat -anp | grep 端口号`来查看该端口对应的连接情况

![截屏2022-08-05 15.51.04](https://raw.githubusercontent.com/che77a38/blogImage2/main/202208051551664.jpeg)

`netstat -tunlp`命令查看网络连接情况,仅服务器

![截屏2022-08-05 15.49.14](https://raw.githubusercontent.com/che77a38/blogImage2/main/202208051552433.jpeg)

`ESTABLISHED`表示链接建立了

mac下`netstat`命令为简化版,用`lsof`命令取而代之

![截屏2022-08-05 15.54.43](https://raw.githubusercontent.com/che77a38/blogImage2/main/202208051556513.jpeg)

## 案例

### 服务器开发流程

![image-20220803145641364](https://raw.githubusercontent.com/che77a38/blogImage2/main/202208031456553.png)

1. 创建socket,返回一个文件描述符lfd -- [`socket()`](#socket函数)

      ​	-- **该文件描述符用于监听客户端连接**

2. 将lfd和IP PORT进行绑定 -- [`bind()`](#bind函数)

3. 将lfd由主动变为被动监听 -- [`listen()`](#listen函数)

4. 接受一个新的连接,得到一个文件描述符  -- [`accept()`](#accept函数)

      ​	-- **该文件描述符是用于和客户端进行通信的**

5. [读写](#读写相关函数)

6. 关闭文件描述符 -- `close(lfd)   close(cfd)`

### 客户端开发流程

1. 创建socket,返回一个文件描述符cfd  -- [`socket()`](#socket函数)

   ​	---该文件描述符是用于和服务端通信

2. 连接服务器 --[`connect()`](#connect函数)

3. [读写](#读写相关函数)

4. 关闭文件描述符 -- `close(fd)`

由于客户端不需要固定的端口号，因此不必调用`bind()`，客户端的端口号由内核自动分配。注意，客户端不是不允许调用`bind()`，只是没有必要调用`bind()`固定一个端口号，服务器也不是必须调用`bind()`，但如果服务器不调用`bind()`，内核会自动给服务器分配监听端口，每次启动服务器时端口号都不一样，客户端要连接服务器就会遇到麻烦。

### linux/Mac代码

#### 服务器

```c
#include <arpa/inet.h>
#include <sys/socket.h>
#include<iostream>
#include <unistd.h>
#include <string.h>
#include <sys/types.h> 
using namespace std;

int main(int argc,char** argv)
{
    int lfd = socket(AF_INET,SOCK_STREAM,0);
    std::cout<<"lfd:"<<lfd<<std::endl;
    struct sockaddr_in serv;
    bzero(&serv,sizeof(serv));
    serv.sin_family = AF_INET;
    serv.sin_port = htons(23456);
    serv.sin_addr.s_addr = htonl(INADDR_ANY);//表示使用本地任意可用iP
    bind(lfd,(sockaddr*)&serv,sizeof(serv));
    
    listen(lfd,2);
    std::cout<<"等待客户端链接..."<<std::endl;
    int fd =accept(lfd,NULL,NULL);//不关心连接的对方客户端信息
    std::cout<<"客户端已链接"<<std::endl;
    //开始读写
    //char str[]="你好,世界!";
    //send(lfd,str,strlen(str)+1,0);
    //读数据
    char buf[1024];
    while(1)
    {
        memset(buf,0,sizeof(buf));
        int readSize = read(fd,buf,sizeof(buf));
        std::cout<<"readSize:"<<readSize<<std::endl;
        std::cout<<"buf:"<<buf<<std::endl;
    }
    //关闭监听文件描述符和通信文件描述符
    close(lfd);
    close(fd);
    return 0;
}
```

#### 客户端

```c
#include <iostream>
using namespace std;
#include <sys/types.h>          /* See NOTES */
#include <sys/socket.h>
#include <unistd.h>
#include <string.h>
#include <arpa/inet.h>

int main()
{
    int fd = socket(AF_INET,SOCK_STREAM,0);
    cout<<"fd:"<<fd<<endl;
    struct sockaddr_in serv;
    bzero(&serv,sizeof(serv));
    serv.sin_family = AF_INET;
    serv.sin_port = htons(23456);
    inet_pton(AF_INET, "192.168.0.115", &serv.sin_addr.s_addr);
    int iRet = connect(fd,(sockaddr*)&serv,sizeof(serv));
    cout<<"connect iRet:"<<iRet<<endl;
    char buf[999]={0};
    send(fd,"hello world!",strlen("hello world!")+1,0);
    while(1)
    {
        sleep(1);
    }
    close(fd);
    return 0;
}
```

### [windows代码](#https://blog.csdn.net/li_wei_quan/article/details/79665969)

代码上和linux有一定差异,但差异基本不大

#### 服务器

1. 加载套接字库，创建套接字（WSAStartup()/socket()）
2. 绑定套接字到一个IP地址和一个端口上（bind()）
3. 将套接字设置为监听模式等待连接请求（listen()）
4. 请求到来后，接受连接请求，返回一个新的对应于此次连接的套接字（accept()）；
5. 用返回的套接字和客户端进行通信（send()/recv()）
6. 返回，等待另一个连接请求；
7. 关闭套接字，关闭加载的套接字库（closesocket()/WSACleanup()）

```c
#include <stdio.h>    
#include <winsock2.h>    
#pragma comment(lib,"ws2_32.lib")    

int main(int argc, char* argv[])
{
	//初始化WSA    
	WORD sockVersion = MAKEWORD(2, 2);
	WSADATA wsaData;
	if (WSAStartup(sockVersion, &wsaData) != 0)
	{
		return 0;
	}

	//创建套接字    
	SOCKET slisten = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (slisten == INVALID_SOCKET)
	{
		printf("socket error !");
		return 0;
	}

	//绑定IP和端口    
	sockaddr_in sin;
	sin.sin_family = AF_INET;
	sin.sin_port = htons(23456);
	sin.sin_addr.S_un.S_addr = INADDR_ANY;
	if (bind(slisten, (LPSOCKADDR)&sin, sizeof(sin)) == SOCKET_ERROR)
	{
		printf("bind error !");
	}

	//开始监听    
	if (listen(slisten, 5) == SOCKET_ERROR)
	{
		printf("listen error !");
		return 0;
	}

	//循环接收数据    
	SOCKET sClient;
	sockaddr_in remoteAddr;
	int nAddrlen = sizeof(remoteAddr);
	char revData[255];
	while (true)
	{
		printf("等待连接...\n");
		sClient = accept(slisten, (SOCKADDR *)&remoteAddr, &nAddrlen);
		if (sClient == INVALID_SOCKET)
		{
			printf("accept error !");
			continue;
		}
		printf("接受到一个连接：%s \r\n", inet_ntoa(remoteAddr.sin_addr));

		//接收数据    
		int ret = recv(sClient, revData, 255, 0);
		if (ret > 0)
		{
			revData[ret] = 0x00;
			printf(revData);
		}

		//发送数据    
		const char * sendData = "你好，TCP客户端！\n";
		send(sClient, sendData, strlen(sendData), 0);
		closesocket(sClient);
	}
	closesocket(slisten);
	WSACleanup();
	return 0;
}
```

#### 客户端

1. 加载套接字库，创建套接字（WSAStartup()/socket()）
2. 向服务器发出连接请求（connect()）
3. 和服务器进行通信（send()/recv()）
4. 关闭套接字，关闭加载的套接字库（closesocket()/WSACleanup()）

```c
#include<WINSOCK2.H>  
#include<STDIO.H>  
#include<iostream>  
#include <string>
using namespace std;
#pragma comment(lib, "ws2_32.lib")  

int main()
{
	WORD sockVersion = MAKEWORD(2, 2);
	WSADATA data;
	if (WSAStartup(sockVersion, &data) != 0)
	{
		return 0;
	}
	while (true) {
		SOCKET sclient = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
		if (sclient == INVALID_SOCKET)
		{
			cout << WSAGetLastError() << endl;
			printf("invalid socket!");
			return 0;
		}
		sockaddr_in serAddr;
		serAddr.sin_family = AF_INET;
		serAddr.sin_port = htons(23456);
		serAddr.sin_addr.S_un.S_addr = inet_addr("192.168.0.115");
		if (connect(sclient, (sockaddr *)&serAddr, sizeof(serAddr)) == SOCKET_ERROR)
		{  //连接失败   
			cout << WSAGetLastError() << endl;
			printf("connect error !");
			closesocket(sclient);
			getchar();
			return 0;
		}

		string data;
		cin >> data;
		const char * sendData;
		sendData = data.c_str();   //string转const char*   
								   //char * sendData = "你好，TCP服务端，我是客户端\n";  
		send(sclient, sendData, strlen(sendData), 0);
		//send()用来将数据由指定的socket传给对方主机  
		//int send(int s, const void * msg, int len, unsigned int flags)  
		//s为已建立好连接的socket，msg指向数据内容，len则为数据长度，参数flags一般设0  
		//成功则返回实际传送出去的字符数，失败返回-1，错误原因存于error   
		char recData[255];
		int ret = recv(sclient, recData, 255, 0);
		if (ret > 0) {
			recData[ret] = 0x00;
			printf(recData);
		}
		closesocket(sclient);
	}
	WSACleanup();
	return 0;
}
```

## 网络开发的注意点及完整案例

当read读文件描述符为非阻塞状态的时候,若对方没有发送数据,会立刻返回, `errno`设置为 `EAGAIN`,这个错误我们要忽略.

### 防止阻塞被信号打断

像`accept`，`read`, `write` 这样的能够引起阻塞的函数，**若被信号打断，由于信号的优先级较高, 会优先处理信号, 信号处理完成后，会使accept或者read解除阻塞, 然后返回, 此时返回值为 -1，设置errno=EINTR;
errno=ECONNABORTED表示连接被打断,异常.**

阻塞函数在阻塞期间若收到信号,会被信号中断,errno设置为EINTR,这个错误不应该被视为错误.

```c
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <strings.h>

void perr_exit(const char *s)
{
	perror(s);
	exit(-1);
}

int Accept(int fd, struct sockaddr *sa, socklen_t *salenptr)
{
	int n;

again:
	if ((n = accept(fd, sa, salenptr)) < 0) {
		if ((errno == ECONNABORTED) || (errno == EINTR))
			goto again;
		else
			perr_exit("accept error");
	}
	return n;
}

int Bind(int fd, const struct sockaddr *sa, socklen_t salen)
{
    int n;

	if ((n = bind(fd, sa, salen)) < 0)
		perr_exit("bind error");

    return n;
}

int Connect(int fd, const struct sockaddr *sa, socklen_t salen)
{
    int n;

	if ((n = connect(fd, sa, salen)) < 0)
		perr_exit("connect error");

    return n;
}

int Listen(int fd, int backlog)
{
    int n;

	if ((n = listen(fd, backlog)) < 0)
		perr_exit("listen error");

    return n;
}

int Socket(int family, int type, int protocol)
{
	int n;

	if ((n = socket(family, type, protocol)) < 0)
		perr_exit("socket error");

	return n;
}

ssize_t Read(int fd, void *ptr, size_t nbytes)
{
	ssize_t n;

again:
	if ( (n = read(fd, ptr, nbytes)) == -1) {
		if (errno == EINTR)
			goto again;
		else
			return -1;
	}
	return n;
}
//管道写满了,也会阻塞
ssize_t Write(int fd, const void *ptr, size_t nbytes)
{
	ssize_t n;

again:
	if ( (n = write(fd, ptr, nbytes)) == -1) {
		if (errno == EINTR)
			goto again;
		else
			return -1;
	}
	return n;
}

int Close(int fd)
{
    int n;
	if ((n = close(fd)) == -1)
		perr_exit("close error");

    return n;
}

/*参三: 应该读取的字节数*/
ssize_t Readn(int fd, void *vptr, size_t n)
{
	size_t  nleft;              //usigned int 剩余未读取的字节数
	ssize_t nread;              //int 实际读到的字节数
	char   *ptr;

	ptr = (char*)vptr;
	nleft = n;

	while (nleft > 0) {
		if ((nread = read(fd, ptr, nleft)) < 0) {
			if (errno == EINTR)
				nread = 0;
			else
				return -1;
		} else if (nread == 0)
			break;

		nleft -= nread;
		ptr += nread;
	}
	return n - nleft;
}

ssize_t Writen(int fd, const void *vptr, size_t n)
{
	size_t nleft;
	ssize_t nwritten;
	const char *ptr;

	ptr = (const char*)vptr;
	nleft = n;
	while (nleft > 0) {
		if ( (nwritten = write(fd, ptr, nleft)) <= 0) {
			if (nwritten < 0 && errno == EINTR)
				nwritten = 0;
			else
				return -1;
		}

		nleft -= nwritten;
		ptr += nwritten;
	}
	return n;
}

static ssize_t my_read(int fd, char *ptr)
{
	static int read_cnt;
	static char *read_ptr;
	static char read_buf[100];

	if (read_cnt <= 0) {
again:
		if ( (read_cnt = read(fd, read_buf, sizeof(read_buf))) < 0) {
			if (errno == EINTR)
				goto again;
			return -1;
		} else if (read_cnt == 0)
			return 0;
		read_ptr = read_buf;
	}
	read_cnt--;
	*ptr = *read_ptr++;

	return 1;
}

//一个个字符读,效率不行
ssize_t Readline(int fd, void *vptr, size_t maxlen)
{
	ssize_t n, rc;
	char    c, *ptr;

	ptr = (char*)vptr;
	for (n = 1; n < maxlen; n++) {
		if ( (rc = my_read(fd, &c)) == 1) {
			*ptr++ = c;
			if (c  == '\n')//结束标识为\n
				break;
		} else if (rc == 0) {
			*ptr = 0;
			return n - 1;
		} else
			return -1;
	}
	*ptr  = 0;

	return n;
}

int tcp4bind(short port,const char *IP)
{
    struct sockaddr_in serv_addr;
    int lfd = Socket(AF_INET,SOCK_STREAM,0);
    bzero(&serv_addr,sizeof(serv_addr));
    if(IP == NULL){
        //如果这样使用 0.0.0.0,任意ip将可以连接
        serv_addr.sin_addr.s_addr = INADDR_ANY;
    }else{
        if(inet_pton(AF_INET,IP,&serv_addr.sin_addr.s_addr) <= 0){
            perror(IP);//转换失败
            exit(1);
        }
    }
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port   = htons(port);
    Bind(lfd,(struct sockaddr *)&serv_addr,sizeof(serv_addr));
    return lfd;
}
```

头文件

```c
#ifndef __WRAP_H_
#define __WRAP_H_
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <strings.h>

void perr_exit(const char *s);
int Accept(int fd, struct sockaddr *sa, socklen_t *salenptr);
int Bind(int fd, const struct sockaddr *sa, socklen_t salen);
int Connect(int fd, const struct sockaddr *sa, socklen_t salen);
int Listen(int fd, int backlog);
int Socket(int family, int type, int protocol);
ssize_t Read(int fd, void *ptr, size_t nbytes);
ssize_t Write(int fd, const void *ptr, size_t nbytes);
int Close(int fd);
ssize_t Readn(int fd, void *vptr, size_t n);
ssize_t Writen(int fd, const void *vptr, size_t n);
ssize_t my_read(int fd, char *ptr);
ssize_t Readline(int fd, void *vptr, size_t maxlen);
int tcp4bind(short port,const char *IP);
#endif

```

### 粘包

接收缓冲区中,对方发送数据连续发了两次,然后读数据的时候第一次没有读完,剩余的数据在第二次读走了,这种情况就属于粘包.

粘包: 多次数据发送, 收尾相连, 接收端接收的时候不能正确区分第一次发送多少, 第二次发送多少.

本质上是同一个ip端口两种业务的数据的区分问题.

解决方法:

- 方案1: 包头+数据(最推荐)

  如4位的数据长度+数据  -----------> 00101234567890 
  其中0010表示数据长度, 1234567890表示10个字节长度的数据.
  另外, 发送端和接收端可以协商更为复杂的报文结构, 这个报文结	构就相当于双方约定的一个协议.

- 方案2:添加结尾标记

  如结尾最后一个字符为\n \$等.

- 方案3:数据包定长

  如发送方和接收方约定, 每次只发送128个字节的内容, 接收方接收定		长128个字节就可以了.



学习目标

- 熟练掌握TCP状态转换图
- 熟练掌握端口复用的方法
- 了解半关闭的概念和实现方式
- 了解多路IO转接模型
- 熟练掌握select函数的使用
- 熟练使用 `fd_set`相关函数的使用
- 能够编写select多路IO转接模型的代码









## 多并发服务器

如何支持多个客户端   ---  支持多并发的服务器

由于accept和read函数都会阻塞, 如当read的时候, 不能调用accept接受新的连接, 当accept阻塞等待的时候不能read读数据.

两种思路

- [设置非阻塞](#设置非阻塞实现)

  可以将accept和read函数设置为非阻塞, 调用fcntl函数可以将文件描述符设置为非阻塞, 让后再while循环中忙轮询.

- [多进程](#多进程实现)

  让父进程accept接受新连接, 然后fork子进程, 让子进程处理通信, 子进程处理完成后退出, 父进程使用SIGCHLD信号回收子进程.

- [多线程](#多线程实现)

  让主线程接受新连接, 让子线程处理与客户端通信; 使用多线程要将线程设置为分离属性, 让线程在退出之后自己回收资源.

  


### 设置非阻塞实现

```c
//设置文件描述符为非阻塞函数
void setfdUnblock(int fd)
{
     int flag = fcntl(fd, F_GETFL, 0);
    flag|=O_NONBLOCK;
    fcntl(fd, F_SETFL, flag);
}

//服务器端
int main(int argc,char** argv)
{
    vector<int> fds;
    int lfd = socket(AF_INET,SOCK_STREAM,0);
    setfdUnblock(lfd);
    //设置描述符属性为非阻塞
    std::cout<<"lfd:"<<lfd<<std::endl;
    struct sockaddr_in serv;
    bzero(&serv,sizeof(serv));
    serv.sin_family = AF_INET;
    serv.sin_port = htons(23456);
    serv.sin_addr.s_addr = htonl(INADDR_ANY);//表示使用本地任意可用iP
    bind(lfd,(sockaddr*)&serv,sizeof(serv));
    
    listen(lfd,2);
    std::cout<<"等待客户端链接..."<<std::endl;
    again:
    int fd =accept(lfd,NULL,NULL);//不关心连接的对方客户端信息
    if(fd==-1){
        //std::cout<<"获取链接失败"<<fd<<std::endl;
        goto again;
    }
    std::cout<<"客户端已链接:"<<fd<<std::endl;
    //查询是否为已连接客户端,若未连接则记录文件描述符
    if(find(fds.begin(),fds.end(),fd)==fds.end())
    {
        std::cout<<"准备添加的fd:"<<fd<<std::endl;
        setfdUnblock(fd);
        fds.push_back(fd);
    }
    //此处限制只能连接两个
    if (fds.size()<2)
    {
        goto again;
    }
    //开始读写
    //char str[]="你好,世界!";
    //send(lfd,str,strlen(str)+1,0);
    //读数据
    std::cout<<fds.size()<<std::endl;
    for (size_t i = 0; i < fds.size(); i++)
    {
        std::cout<<fds[i]<<std::endl;
        /* code */
    }
    while(1)
    {
        char buf[1024];
        memset(buf,0,sizeof(buf));
        int readSize =0;
        for (size_t i = 0; i < fds.size(); i++)
        {
            readSize = read(fds[i],buf,sizeof(buf));
            if(readSize>0)
            {
                std::cout<<"readSize:"<<readSize<<std::endl;
                std::cout<<"buf:"<<buf<<std::endl;
            }
        }
    }
    //关闭监听文件描述符和通信文件描述符
    close(lfd);
    close(fd);
    return 0;
}
```

此代码实现了接受多个客服端连接并接受客户端发过来的数据的功能.但建立连接的过程必须和读取数据的问题完全分离,即先**建立指定连接数目的连接**,然后再开始通信过程(此后无法继续建立新连接),建立连接和通信是割裂的.开始通信后没有一个好的时机供建立新的连接.如果是客户端通信内容决定建立连接的时机的话就可以用这种方式.(而且也没有好的时机做清理工作)

这种实现方法不是一个好的实现方法

但是其实还有[select方法](#高并发服务器模型select),可以解决上述问题

### 多进程实现

不设置非阻塞状态的话都要考虑[防止阻塞被信号打断](#防止阻塞被信号打断)

1. 注册子进程回收
2. 创建socket,得到一个监听的文件描述符lfd   ---   [socket()](#socket函数)
3. 将lfd和IP和端口port进行绑定   ---   [bind()](#bind函数)
4. 设置监听   ---   [listen()](#listen函数)
5. 进入while循环
   1. 接受新客户端到来 ---   [accept()](#accept函数)
   2. `fork`子进程收发数据
      1. 子进程关闭监听文件描述符后收发数据,最后要设置关闭描述符退出子进程`exit(0);`   ---[read()/write()](#读写相关函数)
      2. 父进程关闭通信文件描述符

下面代码结合了[防止阻塞被信号打断](#防止阻塞被信号打断)的代码

```c
#include<iostream>
using namespace std;
#include<math.h>
#include <time.h>
#include <unistd.h>
#include <dirent.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <signal.h>
 #include <sys/time.h>
 #include <pthread.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include "mysocket.h"//防止堵塞被打断的代码

void sigFunc(int signo)
{
    //对子进程进行回收
    int iRet=0;
    do
    {
       iRet = waitpid(-1,NULL,WNOHANG);
       if(iRet>0)
        std::cout<<"["<<getpid()<<"]主进程回收子进程["<<iRet<<"]"<<std::endl;
    } while ((iRet!=0)&&(iRet!=-1));//只要不是子进程正在运行和无子进程状态即继续循环,防止因为执行期间信号屏蔽产生僵尸进程
    if (iRet==-1)//全部子进程回收完毕
    {
        //std::cout<<"全部子进程回收完毕"<<std::endl;
    }
}

int main2()
{
    while (1)
    {
        char buf[99];
        gets(buf);
        cout<<buf<<endl;
        cout<<kmpSearch(buf,"kill")<<endl;
    }
    return 0;
}

//解析sockaddr_in结构提取[ip:端口]字符串
void acceptClient2Str(struct sockaddr_in* client,char* str)
{
    char sip[16];
    memset(sip,0,sizeof(sip));
    sprintf(str,"%s:%hu",inet_ntop(AF_INET,&client->sin_addr.s_addr,sip,sizeof(sip)),ntohs(client->sin_port));
    //std::cout<<str<<std::endl;
}

//服务器端
int main(int argc,char** argv)
{
    //注册子进程回收====================
    struct sigaction sg;
    sigemptyset(&sg.sa_mask);
    sg.__sigaction_u.__sa_handler=sigFunc;
    sg.sa_flags = 0;
    int iRet= sigaction(SIGCHLD,&sg,NULL);
    if(!iRet)
        std::cout<<"["<<getpid()<<"]主进程回收子进程回调注册成功"<<std::endl;
    //======================================
    int lfd = Socket(AF_INET,SOCK_STREAM,0);
    std::cout<<"lfd:"<<lfd<<std::endl;
    struct sockaddr_in serv;
    bzero(&serv,sizeof(serv));
    serv.sin_family = AF_INET;
    serv.sin_port = htons(23456);
    serv.sin_addr.s_addr = htonl(INADDR_ANY);//表示使用本地任意可用iP
    cout<<Bind(lfd,(sockaddr*)&serv,sizeof(serv))<<endl;
    Listen(lfd,2);
    std::cout<<"等待客户端链接..."<<std::endl;
    struct sockaddr_in client;
    socklen_t len;
    char clientIp[20]={0};
    while (1)
    {
        len = sizeof(client);
        int fd =Accept(lfd,(struct sockaddr*)&client,&len);//不关心连接的对方客户端信息
        int pid = fork();//创建子进程收发数据
        if(pid<0)
        {
            exit(-1);
        }
        else if(pid>0)//父进程
        {
            close(fd);
        }
        else if(pid==0)//子进程
        {
            acceptClient2Str(&client,clientIp);
            std::cout<<"创建子进程["<<getpid()<<"]与["<<clientIp<<"]建立连接"<<std::endl;
            close(lfd);
            while (1)
            {
                char buf[1024];
                memset(buf,0,sizeof(buf));
                int readSize =0;
                readSize = Read(fd,buf,sizeof(buf));
                if(readSize>0)
                {
                    std::cout<<"============["<<getpid()<<"]子进程读["<<clientIp<<"]数据如下:========"<<std::endl;
                    std::cout<<"readSize:"<<readSize<<std::endl;
                    std::cout<<"buf:"<<buf<<std::endl;
                    std::cout<<"==============================================="<<std::endl;
                }
                else if (readSize==0)
                {
                    std::cout<<"["<<clientIp<<"]断开连接"<<std::endl;
                    close(fd);
                    exit(0);
                }
            }
            close(fd);
             exit(0);//退出子进程防止其新建子进程
        }
    }
    close(lfd);
    return 0;
}
```

<img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202208211649152.jpeg" alt="截屏2022-08-21 16.49.03" style="zoom: 33%;" />

### 多线程实现

不设置非阻塞状态的话都要考虑[防止阻塞被信号打断](#防止阻塞被信号打断)

1. 注册子进程回收

2. 创建socket,得到一个监听的文件描述符lfd   ---   [socket()](#socket函数)

3. 将lfd和IP和端口port进行绑定   ---   [bind()](#bind函数)

4. 设置监听   ---   [listen()](#listen函数)

5. 进入while循环

   1. 接受新客户端到来 ---   [accept()](#accept函数)

   2. `pthread_create`创建子线程收发数据

      1. 收发数据   ---[read()/write()](#读写相关函数)
      2. 关闭传入的描述符

   3. `pthread_detach`设置线程为分离属性(退出时自动释放)

**[注意]**  **主线程和子线程共享文件描述符**

```c
#include<iostream>
using namespace std;
#include<math.h>
#include <time.h>
#include <unistd.h>
#include <dirent.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <signal.h>
 #include <sys/time.h>
 #include <pthread.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include "mysocket.h"
#include <iomanip>

//解析sockaddr_in结构提取[ip:端口]字符串
void acceptClient2Str(struct sockaddr_in* client,char* str)
{
    char sip[16];
    memset(sip,0,sizeof(sip));
    sprintf(str,"%s:%hu",inet_ntop(AF_INET,&client->sin_addr.s_addr,sip,sizeof(sip)),ntohs(client->sin_port));
    //std::cout<<str<<std::endl;
}
int a=30;
void* threadFunc(void* fdAddr)
{
   char buf[99]={0};
   int fd = (int64_t)fdAddr;//取得通信用的描述符
   while(1)
   {
        int nRet = read(fd,buf,sizeof(buf));
        if(nRet==0)
        {
            std::cout<<"线程id["<<pthread_self()<<"]退出连接"<<std::endl;
            close(fd);
            break;
            //pthread_exit()该函数也可以
        }
        else if(nRet>0)
        {
            std::cout<<"读到的数据为:"<<buf<<"   长度:"<<nRet<<std::endl;
        }
   }
}

int main(int argc,char** argv)
{
    int cfd = Socket(AF_INET,SOCK_STREAM,0);
    struct sockaddr_in serv;
    serv.sin_family=AF_INET;
    serv.sin_port=htons(23456);
    inet_pton(AF_INET,"127.0.0.1",&serv.sin_addr.s_addr);
    Bind(cfd,(const sockaddr*)&serv,sizeof(serv));
    Listen(cfd,2);
    pthread_t threadID;
    std::cout<<"等待接受连接..."<<std::endl;
    char clientIp[20];
    while(1)
    {
        sockaddr_in client;
        socklen_t len=sizeof(client);
        int fd = Accept(cfd,(sockaddr*)&client,&len);
        acceptClient2Str(&client,clientIp);
        pthread_create(&threadID,NULL,threadFunc,(void*)fd);
        pthread_detach(threadID);//设置线程为分 离属性
        std::cout<<"接收到["<<clientIp<<"]连接,创建线程[0x";
        cout << setbase(16) << (int64_t)threadID<<"]处理"<<endl ;
    }
    return 0;
}
```

## 半关闭状态

如果一方close,另一方没有close,则认为是半关闭状态,处于半关闭状态的时候,可以接受数据,但是不能发送数据.相当于把文件描述符的写缓存区操作关闭了.

注意:半关闭一定是出现在主动关闭的一方

### shutdown函数

```c
int shutdown(int socketfd, int how);
```

- 第一个参数为socket返回的文件描述符
- 第二个参数可以设置为`SHUT_RD/SHUT_WR/SHUT_RDWR`分别表示`关闭接受缓存区/关闭发送缓冲区/都关闭`

返回值:成功返回0;失败返回-1,并设置errno

> **shutdown和close的区别:**
>
> shutdown能够把文件描述符上的读或者写操作关闭,而close关闭文件描述符只是将连接的引用计数的值减1,当减到0就真正关闭文件描述符了.
>
> 如: 调用dup函数或者dup2函数可以复制一个文件描述符, close其中一个并不影响另一个文件描述符,而shutdown就不同了,一旦shutdown了其中一个文件描述符,对所有的文件描述符都有影响(只是关闭了用户层,用户层没法再发了,内核层还是可以发的,tcp四次挥手最后一个ack就是这样理解)

## 端口复用

解决端口复用的问题: `bind error: Address already in use`, 发生这种情况是在服务端主动关闭连接以后, 接着立刻启动就会报这种错误.

测试: 启动服务端和客户端, 然后先关闭服务端, 再次启动服务端, 此时服务端报错: `bind error: Address already in use;` 若是先关闭的客户端, 再关闭的服务端, 此时启动服务端就不会报这个错误.

### setsockopt函数

```c
int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);
```

返回值 : 成功返回0 ; 失败返回-1,并设置errno

```c
//调用案例
setsockopt(lfd,//socket返回的套接字
           SOL_SOCKET,//通用的套接字选项
           SO_REUSEADDR,//如果*optval为0,重用bind中的地址;SO_REUSEPORT这个重用端口的也可以,但用得比较少
           &opt,//根据optname的不同指向一个数据结构或一个整数,比如说一些选项是[int的非0/0]对应[选项启用/禁用]开关.
           sizeof(int));//optval指向的对象的大小
//比如说设置端口复用如下:
int opt = 1;
setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(int));
```

函数说明可参看<<UNIX环境高级编程>>

**由于错误是bind函数报出来的, 该函数调用要放在bind之前, socket之后调用.**

## 心跳包

用于检测长连接是否正常的手段

长连接和短连接的概念:

连接建立之后一直不关闭为**长连接**
连接收发数据完毕之后就关闭为**短连接**

如何检查与对方的网络连接是否正常?
一般心跳包用于长连接.

```c
keepAlive = 1;
setsockopt(listenfd, SOL_SOCKET, SO_KEEPALIVE, (void*)&keepAlive, sizeof(keepAlive));
```

上面为官方提供的方式,由于不能实时的检测网络情况, 一般不用这种方法

**在应用程序中自己定义心跳包,使用灵活,能实时把控**

通信双方需要协商规则(协议)

## 高并发服务器模型select

一种多路io复用技术:同时监听多个文件描述符,将监控的操作交给内核去处理

### select函数

函数介绍: 委托内核监控该文件描述符对应的读,写或者错误事件或者连接请求的发生.(内核收到了告诉程序,避免了accept阻塞)

只要是文件描述符,select函数都可以派上用场.

```c
int select(int nfds, fd_set * readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
```

参数说明: 

- nfds: 最大的文件描述符+1

- readfds: 读文件描述符集合, 是一个传入传出参数

  - 传入: 指的是告诉内核哪些文件描述符需要监控
  - 传出: 指的是内核告诉应用程序哪些文件描述符发生了变化

- writefds: 写文件描述符集合(传入传出参数)

  同上

- execptfds: 异常文件描述符集合(传入传出参数)

  同上

- timeout: 

  - `NULL`--表示永久阻塞, 直到有事件发生
  - `0` --表示不阻塞, 立刻返回, 不管是否有监控的事件发生
  - `>0`--表示阻塞的时长,遇到事件发生或者超时就返回

  返回值: 成功,**返回发生变化的文件描述符的个数**

  ​		失败,返回-1, 并设置errno值.

操作文件描述符集的宏如下:

- `void FD_CLR(int fd, fd_set *set);`

  将fd从set集合中清除.

- `int FD_ISSET(int fd, fd_set *set);`

  功能描述: 判断fd是否在集合中

  返回值: 如果fd在set集合中, 返回1, 否则返回0.

- `void FD_SET(int fd, fd_set *set);`

  将fd设置到set集合中.

- `void FD_ZERO(fd_set *set);`

  初始化set集合(清空).

在linux中的定义位置:`/usr/include/x86_64-linux-gnu/sys/select.h`和`/usr/include/x86_64-linux-gnu/bits/select.h`(最简单的方法就是使用预处理将头文件和宏全部替换掉`gcc -E select.c -o select.i`, 直接就可以看到最终的定义了)

```c
typedef struct
{
long int __fds_bits[1024/(8*8))];//1024对应1024个文件描述符
//long int __fds_bits[16];
}	
```

从上面的文件中可以看出, 这几个宏本质上还是位操作.(与信号集操作类似)

### select开发服务端代码

```c
#include<iostream>
using namespace std;
#include<math.h>
#include <time.h>
#include <unistd.h>
#include <dirent.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <signal.h>
#include <sys/time.h>
#include <pthread.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include "mysocket.h"
#include <iomanip>
#include <sys/select.h>
int main(int argc,char** argv)
{
    int lfd = Socket(AF_INET,SOCK_STREAM,0);
    struct sockaddr_in serv;
    serv.sin_family = AF_INET;
    serv.sin_addr.s_addr = htonl(INADDR_ANY);
    serv.sin_port = htons(23456);
    //设置端口复用
    int opt = 1;
    setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(int));
    Bind(lfd,(struct sockaddr*)&serv,sizeof(serv));
    Listen(lfd,2);
    int maxfd = lfd;//设置给委托内核监控的描述符的范围
    fd_set setReal;
    FD_ZERO(&setReal);
    FD_SET(lfd,&setReal);
    std::cout<<"服务器开启,等待连接"<<std::endl;
    while (1)
    {
        fd_set setR = setReal;
        int fdChangeNum = select(maxfd+1,&setR,NULL,NULL,NULL);//阻塞监控变化,不需要考虑返回0的情况,因为返回>0和<0才会解除堵塞
        if(fdChangeNum<0)
        {
            if(errno==EINTR)//信号被中断
            {
                continue;
            }
            break;//出问题返回(并未做什么完善的处理)
        }
        //有客户端连接请求到来
        if(FD_ISSET(lfd,&setR))//如果lfd有响应
        {
            std::cout<<"客户端连接存在,返回:"<<fdChangeNum<<std::endl;
            int cfd = accept(lfd,NULL,NULL);
            std::cout<<"接受到新的连接,文件描述符为"<<cfd<<std::endl;
            //将cfd加入到委托内核监控中
            FD_SET(cfd,&setReal);
            //调整监控文件描述符范围,将新加入的accept接受到的描述符添加入委托内核监控的范围
            if(maxfd<cfd)
            {
                maxfd = cfd ;
            }
            //如果只有一个描述符变化了,而且是在有客户端连接请求到来的上下文执行中
            //则此处说明只有这一个连接请求导致的描述符变化,因此这样情况下后面代码可以略过
            if(--fdChangeNum==0)//如果只剩最后一个就无需在执行后面了
            {
                continue;
            }
        }
        char str[99]={0};
        //有客户端发数据过来
        for (int i = lfd+1; i <= maxfd; i++)//i表示accept接受的fd
        {
            if(FD_ISSET(i,&setR))
            {
                std::cout<<"数据通信存在,返回值为:"<<fdChangeNum<<std::endl;
                int iRet = Read(i,str,sizeof(str));//有才读,所以不需要考虑堵塞吗
                if(iRet<=0)
                {
                    std::cout<<"断开连接"<<std::endl;
                    close(i);
                    FD_CLR(i,&setReal);
                    continue;
                }
                cout<<"[返回"<<iRet<<"]读到的数据为:"<<str<<endl;
            }            
        }
    }
    close(lfd);
    return 0;
}
```

关于select的思考:

​	问题: 如果有效的文件描述符比较少, 会使循环的次数太多.(大多数都是初始连接一次就)

​	解决办法: 可以将**有效的**(排除了被取消掉的文件描述符)文件描述符放到一个数组当中, 这样遍历效率就高了.(连接不频繁,而通信频繁,也可以针对通信开数组)

**select优点**

- 一个进程可以支持多个客户端
- select支持跨平台

**select缺点**

- 代码编写困难

- 会涉及到用户区到内核区的来回拷贝

- 当客户端多个连接, 但少数活跃的情况, select效率较低

  例如: 作为极端的一种情况, 3-1023文件描述符全部打开, 但是只有1023有发送数据, select就显得效率低下

- 最大支持1024个客户端连接

  select最大支持1024个客户端连接不是有文件描述符表最多可以支持1024个文件描述符限制的, 而是由`FD_SETSIZE=1024`限制的.	

`FD_SETSIZE=1024` fd_set(fd_set这个文件描述符表中一共有1024个bit位)使用了该宏, 当然可以修改内核, 然后再重新编译内核, 一般不建议这么做.

[windows下的select模型外部网页跳转](http://t.zoukankan.com/curo0119-p-8459962.html)

### 练习

编写代码, 让select监控标准输入, 监控网络, 如果标准输入有数据就写入网络, 如果网络有数据就读出网络数据, 然后打印到标准输出. 

```c
int main(int argc,char** argv)
{
    int lfd = Socket(AF_INET,SOCK_STREAM,0);
    struct sockaddr_in serv;
    serv.sin_family = AF_INET;
    serv.sin_addr.s_addr = htonl(INADDR_ANY);
    serv.sin_port = htons(23456);
    //设置端口复用
    int opt = 1;
    setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(int));
    Bind(lfd,(struct sockaddr*)&serv,sizeof(serv));
    Listen(lfd,2);
    std::cout<<"服务器开启,等待连接"<<std::endl;
    int cfd = Accept(lfd,NULL,NULL);
    std::cout<<"接受到新的连接,文件描述符为"<<cfd<<std::endl;
    fd_set setRReal;
    FD_ZERO(&setRReal);
    FD_SET(cfd,&setRReal);
    FD_SET(STDIN_FILENO,&setRReal);
    while (1)
    {
        fd_set setR = setRReal;
        int iRet = select(cfd+1,&setR,NULL,NULL,NULL);
        char str[99]={0};
        if (FD_ISSET(cfd,&setR))//如果网络连接描述符有变化
        {
            int iRet = read(cfd,str,sizeof(str));
            if(iRet<= 0)
                break;
            cout<<str<<endl;
        }
        if(FD_ISSET(STDIN_FILENO,&setR))//如果标准输入有变化
        {
            gets(str);
            strcat(str,"\n");
            write(cfd,str,strlen(str)+1);
        }
    }
    close(cfd);
    close(lfd);
    return 0;
}
```

## poll与epoll

1. 了解poll函数
2. 熟练使用epoll多路IO模型
3. 了解epoll ET/LT触发模式并实现
4. 理解epoll边缘非阻塞模式并实现
5. 了解epoll反应堆模型设计思想
6. 能看懂epoll反应堆模型的实现代码

linux下常用epoll     unix下常用select

效率来看: epoll>poll>select

### 多路IO-poll

跟select类似, 监控内核监控事件,实现多路IO, 但poll不能跨平台

```c
int poll(struct pollfd *fds, nfds_t nfds, int timeout);
```

参数说明

- `fds`: 传入传出参数, 实际上是一个**结构体数组**

  ```c
  struct pollfd 
  {
    int  fd;    /* file descriptor */  //监控的文件描述符
    short events;   /* requested events */ //要监控的事件---不会被修改
    short revents;  /* returned events */  //返回发生变化的事件 ---由内核返回
  };
  ```

  - `fds.fd`: 要监控的文件描述符

  - `fds.events`:(多个之间用或相连)

    `POLLIN`---->读事件

    `POLLOUT`---->写事件 

    `POLLERR`---->异常事件

    `POLLIN|POLLHUP` ---->管道断开连接

    其他更多宏参考 `man 2 poll`

  - `fds.revents`: 返回的事件

- `nfds`: 数组实际有效内容的个数,就是fds数组下标的最大值+1

- `timeout`: 超时时间, 单位是毫秒.

  - `-1`:永久阻塞, 直到监控的事件发生
  - `0`: 不管是否有事件发生, 立刻返回
  - `>0`: 直到监控的事件发生或者超时

**返回值**          

- 成功:**返回就绪事件的个数**
- 失败: 返回-1

若`timeout=0`, poll函数不阻塞,且没有事件发生, 此时返回-1, 并且`errno=EAGAIN`, **这种情况不应视为错误**.

说明

1. 当poll函数返回的时候, 结构体当中的`fd`和`events`没有发生变化, 究竟有没有事件发生由`revents`来判断, 所以**poll是请求和返回分离**.
2. `struct pollfd`结构体中的**fd成员若赋值为-1, 则poll不会监控.**
3. 相对于select, poll没有本质上的改变; 但是**poll可以突破1024的限制.**

**如何突破1024的限制**(开发流程一般是没有权限改的)

在`/proc/sys/fs/file-max`查看一个进程可以打开的socket描述符上限.

如果需要可以修改配置文件: `/etc/security/limits.conf`

加入如下配置信息, 然后重启终端即可生效.

```c
* soft nofile 1024
* hard nofile 100000
//修改的话,直接修改1024处的数字.
//hard表示可以修改的最大限制
```

**代码**

```c
int main(int argc,char** argv)
{
    int lfd = Socket(AF_INET,SOCK_STREAM,0);
    struct sockaddr_in serv;
    serv.sin_family = AF_INET;
    serv.sin_addr.s_addr = htonl(INADDR_ANY);
    serv.sin_port = htons(23456);
    //设置端口复用
    int opt = 1;
    setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(int));
    Bind(lfd,(struct sockaddr*)&serv,sizeof(serv));
    Listen(lfd,2);
    std::cout<<"服务器开启,等待连接"<<std::endl;
    struct pollfd client[1024];
    for (size_t i = 0; i < 1024; i++)//初始化
    {
        client[i].fd = -1;
    }
    int max = 0;
    client[0].fd = lfd;
    client[0].events = POLLIN;
    while (1)
    {
        int iRet = poll(client,max+1,-1);
        if(iRet < 0)
        {
            if (errno == EINTR)
            {
                continue;
            }
            break;
        }
        //有客户端连接请求到来
        if(client[0].revents == POLLIN)
        {
            int cfd = Accept(lfd,NULL,NULL);
            std::cout<<"接受连接成功,fd:"<<cfd<<std::endl;
            //将新文件描述符加入poll监控
            //寻找数组中空出来的位置
            size_t i;
            for (i = 0; i < 1024; i++)
            {
                if (client[i].fd == -1)
                {
                    client[i].fd = cfd;
                    client[i].events = POLLIN;
                    //修改client数组下标最大值
                    if(i>max)
                    {
                        max = i;
                    }
                    break;
                }
            }
            if(i==1024)
            {
                close(cfd);
                continue;
            }
            if(--iRet==0)
                continue;
        }
        //下面是收到客户端发送数据的情况
        char str[99] = {0};
        for (size_t j = 1; j <= max; j++)
        {
             if(client[j].revents == (POLLHUP|POLLIN))//检测到连接断开的方式之一
            {
               //std::cout<<"断开了解"<<std::endl;
            }
            if (client[j].revents & POLLIN)//这里必须是&,如果是==无法检测到其中的连接断开的情况
            {
                int iReadRet = Read(client[j].fd, str, sizeof(str));
                std::cout<<iReadRet<<std::endl;
                if (iReadRet <= 0)//检测到连接断开的方式之二
                {
                    //std::cout<<client[j].revents<<std::endl;
                    std::cout<<"断开连接"<<std::endl;
                    close(client[j].fd);
                    client[j].fd = -1;
                    if (j == max)
                        max--;
                    continue;
                }
                cout << "读到的数据:" << str << endl;
              	if(--iRet == 0)//优化,如果只有一个就无需再遍历了
                    break;
            }
        }
    }
    close(lfd);
    return 0;
}
```

### 多路IO-epoll

将检测文件描述符的变化委托给内核去处理, 然后内核将发生变化的文件描述符对应的事件返回给应用程序.

底层实现是**红黑二叉树**

#### 相关函数	

##### epoll_create函数	

创建一棵epoll数,返回一个树根节点

```c
int epoll_create(int size);
```

**参数**    `size`: 最大节点数, 此参数在linux 2.6.8已被忽略, 但必须传递一个大于0的数.

**返回值**

- 成功: 返回一个大于0的文件描述符, 代表整个树的树根.
- 失败: 返回-1, 并设置errno值.

##### epoll_ctl函数

将要监听的节点在epoll树上添加, 删除和修改

```c
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
```

**参数说明**

- `epfd`: epoll树根
- `op`:
  - EPOLL_CTL_ADD: 添加事件节点到树上
  - EPOLL_CTL_DEL: 从树上删除事件节点
  - EPOLL_CTL_MOD: 修改树上对应的事件节点
- `fd`: 事件节点对应的文件描述符
- `event`: 要操作的事件节点  

```c
typedef union epoll_data {
     void    *ptr;
     int     fd;
     uint32_t   u32;
     uint64_t   u64;
} epoll_data_t;

struct epoll_event {
     uint32_t   events;   /* Epoll events */
     epoll_data_t data;    /* User data variable */
};
```



​     

event.events常用的有:

 EPOLLIN: 读事件

 EPOLLOUT: 写事件

 EPOLLERR: 错误事件

​         EPOLLET: 边缘触发模式

event.fd: 要监控的事件对应的文件描述符





​	int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);

函数说明:等待内核返回事件发生

参数说明:

epfd: epoll树根

events: 传出参数, 其实是一个事件结构体数组

maxevents: 数组大小

timeout:

-1: 表示永久阻塞

0: 立即返回

\>0: 表示超时等待事件

   返回值:

成功: 返回发生事件的个数

失败: 若timeout=0, 没有事件发生则返回; 返回-1, 设置errno值, 





​	epoll_wait的events是一个传出参数, 调用epoll_ctl传递给内核什么值, 当epoll_wait返回的时候, 内核就传回什么值,不会对struct event的结构体变量的值做任何修改.









