---
title: FPS逆向
tags: FPS
categories: 杂项

---

<!-- more -->

[x64dbg快捷键]: https://www.52pojie.cn/thread-227097-1-1.html

fps辅助整体分析

- FPS游戏特性导致的，需要非常高的实时性，不能过度的网络验证
- 绘制部分可以使用透明窗口覆盖在游戏上，非常难以检测
- 自瞄部分，捕捉准星数据，准星路径曲线不规则或有中断（不能平滑，人类操作鼠标非常不圆滑）
- 连续爆头的行为检测行为数据异常等等

# 相关基础

## 角度计算

- tan，cos，sin函数，**参数为弧度**，弧度为π表示180度。
- atan2，acos2，asin2，**返回值为弧度**。

$$
角度=(弧度*180)/π
$$

$$
弧度=(角度*π)/180
$$

[线性代数本质系列]: https://www.bilibili.com/video/BV1ys411472E?spm_id_from=333.999.0.0

向量内积是一个向量在另一个向量上的投影长度乘以另一个向量的长度

```c
//比如：[1,3]和[3,0]的向量内积为：
[1,3]*[3,0]=3+0=3
```

矩阵的乘法：

![image-20220122133019389](https://raw.githubusercontent.com/che77a38/blogImage/main/202201221330618.png)

## 快捷键写法

```c
if(GetKeyState(VK_F1)&1)//VK_F1是键码
{
	//按下F1执行里面的指令,再按下F1停止执行里面的指令
}
```

## 绘制的三种方法

1. hook d3d/opengl
   - 优:完全不闪,代码简单
   - 缺:非常容易被检测
2. 游戏窗口上自行绘制
   - 优:适中
   - 缺:会闪
3. 自己创建窗口,在自己创建的窗口上绘制
   - 优:稳定
   - 缺:麻烦一点,会闪,需要通信

# 3维坐标转屏幕算法

两种坐标求导算法

- 需要矩阵
- 不需要矩阵

## 不需要矩阵

![image-20220122192831457](https://raw.githubusercontent.com/che77a38/blogImage/main/202201221928872.png)
$$
摄像机到准星的距离分辨率=\frac{\frac{屏幕水平分辨率}{2}}{\tan{\frac{水平FOV}{2}}}
\\
\\
\tan{x差角度}=\frac{屏幕的x差分辨率}{摄像机到准星的距离分辨率}
\\
\\
\tan{x差角度}=\frac{屏幕的x差分辨率}{\frac{\frac{屏幕水平分辨率}{2}}{\tan{\frac{水平FOV}{2}}}}
\\
\\
屏幕的x差分辨率=\frac{\frac{屏幕水平分辨率}{2}}{\tan{\frac{水平FOV}{2}}}\times\tan{x差角度}
\\
$$
因为屏幕的左上角为(0,0)，向右为x变大，向下为y变大，因此可知：

**屏幕上指向敌人的x坐标**就是:**屏幕的x差分辨率+水平分辨率/2**

![image-20220122151558943](https://raw.githubusercontent.com/che77a38/blogImage/main/202201221515481.png)
$$
\frac{垂直FOV}{水平FOV}=\frac{垂直分辨率}{水平分辨率}
\\
\\
屏幕的y差分辨率=\frac{\frac{屏幕垂直分辨率}{2}}{\tan{\frac{垂直FOV}{2}}}\times\tan{y差角度}
\\
\\
屏幕的y差分辨率=\frac{\frac{屏幕水平分辨率}{2}}{\tan{\frac{水平FOV}{2}}}\times\tan{y差角度}
$$
**屏幕上指向敌人的y坐标**就是:**屏幕的y差分辨率+垂直分辨率/2**

### **总结**

$$
屏幕坐标X=\frac{\frac{屏幕水平分辨率}{2}}{\tan{\frac{水平FOV}{2}}}\times\tan{x差角度}+\frac{水平分辨率}{2}
\\
\\
屏幕坐标Y=\frac{\frac{屏幕水平分辨率}{2}}{\tan{\frac{水平FOV}{2}}}\times\tan{y差角度}+\frac{垂直分辨率}{2}
\\
$$

算法如下：

```cpp
#define PI 3.1415926

class 坐标结构
{
public:
    int X,Y;
};

float 弧度转角度(float 弧度)
{
    return 弧度*180/PI;
}

float 角度转弧度(float 角度)
{
    return 角度*PI/180;
}

bool 世界坐标转屏幕坐标_非矩阵(坐标结构& 屏幕坐标,float 水平角度差,float 垂直角度差,float 水平FOV)
{
    取窗口信息(水平分辨率，垂直分辨率);//获取屏幕分辨率(伪函数)
    float 摄像机到准星的距离分辨率=水平分辨率/2/(tan(角度转弧度(水平FOV/2)));
    float 高低最大可视角度=弧度转角度(atan2(垂直分辨率/2,摄像机到准星的距离分辨率));
    if (fabs(水平角度差)>水平FOV/2||fabs(垂直角度差)>高低最大可视角度)
    {
        return false;//不在屏幕范围内
    }
    int 水平差=摄像机到准星的距离分辨率*tan(角度转弧度(水平角度差));
    屏幕坐标.X=水平差+水平分辨率/2;
    int 垂直差=摄像机到准星的距离分辨率*tan(角度转弧度(垂直角度差));
    屏幕坐标.Y=垂直差+垂直分辨率/2;
    return true;
}
```

无矩阵方式为:获取人物与目标的世界坐标高度差和世界水平距离来得到人物和目标的夹角,再通过人物准星减去目标夹角(或反过来)来确定准星偏转角度差,再通过准星偏转角度差和游戏宽高分辨率来转换成屏幕坐标进行绘图

这种方式得到的坐标绘制多多少少有误差,下面用到矩阵的方式无误差

## 需要矩阵

矩阵分行主序与列主序,主要是d3d和openGl的区别

- 行主序(openGl)

  ```
  a1 a2 a3 a4          x         a1*x+a2*y+a3*z+a4*w
  b1 b2 b3 b4    乘以  	y  =      b1*x+b2*y+b3*z+b4*w
  c1 c2 c3 c4          z         c1*x+c2*y+c3*z+c4*w
  d1 d2 d3 d4          w         d1*x+d2*y+d3*z+d4*w
  ```

- 列主序(D3D)

  ```
                 a1 b1 c1 d1    a1*x+a2*y+a3*z+a4*w
  x,y,z,w  乘以  a2 b2 c2 d2  =  b1*x+b2*y+b3*z+b4*w
                a3 b3 c3 d3     c1*x+c2*y+c3*z+c4*w
                a4 b4 c4 d4     d1*x+d2*y+d3*z+d4*w
  ```

### 缩放和位移矩阵

```c
//行主序:(openGl)
Sx 0  0  Tx
0  Sy 0  Ty
0  0  Sz Tz
0  0  0  Tw
//列主序:(D3D)
Sx 0  0  0
0  Sy 0  0
0  0  Sz 0
Tx Ty Tz Tw
  
//平移缩放后的坐标如下
                  Sx*x+w*Tx
x,y,z,w乘以列主序= Sy*y+w*Ty
  							 Sz*z+w*Tz
                 w*Tw
```

**[第一结论]** : 行主序最后一列,列主序最后一行,走路,跳,会发生改变,不代表别的动作不改变

### **旋转矩阵**

#### 绕z轴旋转矩阵

```c
绕z轴旋转矩阵(A表示点逆时针旋转角度 或 坐标系顺时针旋转角度)
//行主序
cosA   -sinA  0  0
sinA   cosA   0  0
0      0      1  0
0      0      0  1
//列主序
cosA   sinA   0  0
-sinA  cosA   0  0
0      0      1  0
0      0      0  1

//绕z轴顺时针旋转后的坐标如下:
                 xcosA-ysinA
x,y,z,w乘以列主序= xsinA+yconsA
                 z
                 w
```

**[第二结论]** : 水平转动的情况,行主序第三列不变,列主序第三行不变

#### 绕x轴旋转矩阵

```c
绕x轴旋转矩阵(A表示点逆时针旋转角度 或 坐标系顺时针旋转角度)
//行主序
1  0     0      0
0  conA  -sinA  0
0  sinA  cosA   0
0  0     0      1
//列主序
1  0     0      0
0  conA  sinA   0
0  -sinA cosA   0
0  0     0      1

//绕x轴顺时针旋转后的坐标如下:
                 x
x,y,z,w乘以列主序= -zsinA+yconsA
                 ysinA+zcosA
                 w
```

**[第三结论]** : 高低朝向改变的时候,行主序第一行不变,列主序第一列不变

#### 绕y轴旋转矩阵

```c
//绕y轴旋转矩阵(A表示点逆时针旋转角度 或 坐标系顺时针旋转角度)
//行主序
cosA  0  sinA  0
0     1  0     0
-sinA 0  cosA  0
0     0  0     1
//列主序
cosA  0  -sinA 0
0     1  0     0
sinA  0  cosA  0
0     0  0     1

//绕y轴顺时针旋转后的坐标如下:
                 xcosA+zsinA
x,y,z,w乘以列主序= y
                 -xsinA+zcosA
                 w
```

### 找矩阵总结

- **[第一结论]** : 行主序最后一列,列主序最后一行,走路,跳,会发生改变,不代表别的动作不改变(随便走,不动准星,会有一行或一列4个在变化(如果只朝x或y前进,那么也只改变3个值,即行主序最后一列第一个与列主序最后一行第一个当沿着x或y方向走也不变),跳就只有三个值在一行或一列变化)
- **[第二结论]** : 水平转动的情况,行主序第三列不变,列主序第三行不变
- **[第三结论]** : 高低朝向改变的时候,行主序第一行不变,列主序第一列不变

下面的结论不绝对

- **[第四结论]**矩阵第一个值往往是-1到1之间的
- **[第五结论]**行主序第一行第三个元素是固定的0,列主序第一列的第三个元素是0
- **[第六结论]**开倍镜,第一个值会乘以相应的倍数(这个是绝对的)

[找矩阵实例](# 找矩阵)

### **世界坐标转换为屏幕坐标**

> **剪辑坐标**:理解为三维世界的切片

**NDC坐标**(标准化设备坐标)

就是将剪辑坐标的范围缩小至-1到1,如图:

![img](https://raw.githubusercontent.com/che77a38/blogImage/main/202203211338236.png)

**世界坐标-->剪辑坐标-->NDC坐标**

```c
//世界坐标转换为剪辑坐标(剪辑坐标和分辨率没有任何关系)
//世界坐标  *     矩阵
                a0  a1  a2  a3
x,y,z,w   乘以   a4  a5  a6  a7
                a8  a9  a10 a11
                a12 a13 a14 a15
                  
剪辑坐标x   =   a0*x+a4*y+a8*z+a12*w
剪辑坐标y   =   a1*x+a5*y+a9*z+a13*w
剪辑坐标z   =   a2*x+a6*y+a10*z+a14*w
剪辑坐标w   =   a3*x+a7*y+a11*z+a15*w
//剪辑坐标w如果小于0表示在屏幕外!!!!!!!!!!!!!!!!!!!!!!

//剪辑坐标转换为NDC坐标
NDC.x=剪辑坐标x/剪辑坐标w
NDC.y=剪辑坐标y/剪辑坐标w
NDC.z=剪辑坐标z/剪辑坐标w //无用                 
```

**NDC坐标-->屏幕坐标**

![捕获](https://raw.githubusercontent.com/che77a38/blogImage/main/202203211629382.png)

实际上就是坐标系的转换,NDC坐标系转换成屏幕分辨率坐标系.

<img src="https://raw.githubusercontent.com/che77a38/blogImage/main/202203211712682.jpeg" alt="截屏2022-03-21 17.12.02"  />
$$
\frac{目标点的NDC坐标X}{2}=\frac{屏幕坐标差x}{显示器分辨率宽}
\\
\\
\frac{目标点的NDC坐标y}{2}=\frac{屏幕坐标差y}{显示器分辨率高}
$$

```c
//上面两个公式可知:
目标点的屏幕坐标差x=目标点的NDC坐标X*显示器分辨率宽/2
目标点的屏幕坐标差y=目标点的NDC坐标y*显示器分辨率高/2
```

因此**NDC坐标--->屏幕坐标算法**计算如下:
$$
目标点的屏幕坐标x=\frac{目标点的NDC坐标X\times分辨率宽}{2}+\frac{分辨率宽}{2}
\\
目标点的屏幕坐标y=\frac{分辨率高}{2}-\frac{目标点的NDC坐标y\times分辨率高}{2}
$$
坐标点A和坐标点B均适用,说明四象限全适用.

## 朝向（准星）

准星数据寻找

在fps游戏中，横轴是可以无限原地转圈的，而竖轴上下大概在180度左右，所以Y往往比X更合适用来当作这一数据的突破口。那么假设准星数据做了处理，应该如何找到瞄准call呢？搜索出与准星坐标相关的地址后，移动鼠标进行访问断，就有可能断到相关的函数。

朝向极大概率是浮点数。

需要找到x,y轴坐标对应的朝向。

# FPS 逆向随笔

通常情况下Dx9中会采用4*4的矩阵



![image-20210514115116708](https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210514115116708.png)

 //荒野行动横矩阵第3排，第4列的数，光标朝天看的时候是1，朝地下是-1。（此结论通用性待验证）

补充一个3*4列矩阵

```cpp
X X X x
X X X y
X X X z
0 0 0 比例
3*4（列矩阵）
```

UE4矩阵

```
UE4最常见的两种矩阵
//第一种横矩阵格式（上+下-）（这就是上图中荒野行动那种）
xxx xxx 0 xxxx
xxx xxx 0 xxxx
xxx xxx 0 xxxx
 X   Y 比例 Z
//第二种横矩阵格式(上-下+)
xxx xxx xxxx 0
xxx xxx xxxx 0
xxx xxx xxxx 0
 X   Y   Z  比例
 //特征：除了XYZ，其他所有数值在（-2，+2）间
```

[cf思路]: https://bbs.pediy.com/thread-251836.htm

普通食物4*4横矩阵和竖矩阵的矩阵头在这个区间（-2，+2）

针对自动瞄准，应该如何检测：

1、模拟类自瞄

一、Hook windows所提供的所有按键操作、鼠标操作类接口，函数全部由游戏安全系统接管。

二、既然Hook了相关函数，那么就可以被突破，Hook被还原，还要在代码段上下crc，防止被还原Hook，在crc上多次套crc，多设防御关卡。

三、检测鼠标轨迹和移动速度，没有谁可以一直直线移动鼠标。

2、内存类自瞄

一、Hook windows所提供的所有“写内存”类接口，如WriteProcessMemory（），函数全部由游戏安全系统接管，检测到非自身或者未知程序调用该类型函数对游戏进行操作时，将其踢下线。

二、同模拟类自瞄第二条。

三、同模拟类自瞄第三条。

四、加密鼠标横轴（x坐标），且多个地址同步准星数据，当非法修改了准星位置，即准星数据不同步，即可知道非法修改了内存。

​    那么接下来，同笔者一起分析，透视自瞄究竟是如何实现的呢？

​    其实只要实现了自瞄，就相当于实现了透视，只是需要开发者通过一系列算法将其绘制在屏幕上而已。而实现自瞄，对于有相关工作经验的人来说，也算不上难，一套公式，几乎“通杀”所有FPS。自瞄算法可以简单的分为两种，一种通过玩家坐标和准星位置进行计算，一种为”矩阵自瞄“，计算模型骨骼等等，其实两种自瞄本质意义上区别不大，各有各的好处，只不过第二种更为精准，第一种则更为方便，需要的数据更少。









自己封装内存模块用到的api

1. 打开进程===OpenProcess
2. 打开当前进程===OpenProcess
3. 写内存===WriteProcessMemory
4. 关闭句柄===CloseHandle
5. 读取内存整数===ReadProcessMemory
6. 保护内存===VirtualQueryEx
7. 读内存字节集===ReadProcessMemory
8. 提示自身进程权限===RtlAdjustPrivilege
9. 获取当前进程id===GetCurrentProcessId
10. 取一个窗口的标题===GetWindowTextA
11. 寻找窗口句柄===FindWindowExA
12. 获取窗口客户区===GetClientRect
13. 获取窗口类名===GetClassNameA
14. 终止进程===TerminateProcess
15. 获取快照信息===CreateToolhelp32Snapshot
16. 获取遍历快照的第一个进程===Process32First
17. 获取遍历快照的下一个进程===Process32Next
18. 获取遍历快照的第一个模块===MODULE32First
19. 获取遍历快照的下一个模块===MODULE32Next

```javascript
UE4
Count(环境数量)→  -游戏类型  → 数组Actor
↓                               ↓
Uworld（世界地址）            人物坐标XYZ  血量 阵容  飞天
```



```
X
Y
Z地址"UE4Game-Win64-Shipping.exe"+02CC5F50]+588]+158]+1D8

[[[[[7FF714B28BF0+88+rcx*3*8+8]+10]+50]+270]+158]+1D0==233F0434FE0
```



# CE找数据技巧

找数据技巧：排除栈地址，排除ui上显示的数据信息，排除追踪到服务器模块的情况（如果本机有服务器的话）

大量30~80的字符表示的是ascii字符串，4或C开头的4字节大概率是浮点数

对于服务器和客户端模块都在本地的游戏,使用一些确定是服务器数据的数据来找来源,来源于的模块大概率就是服务器模块



# CS1.6的逆向

## 找内存数据

通过客户端或服务端来搜数据排查服务端的模块是哪一个

找血量数据如下:

![00001](https://raw.githubusercontent.com/che77a38/blogImage/main/202202161531874.png)

只有蓝标数据真正可以修改目标血量,说明这个数据是服务端数据,到x32dbg中下写入断点来确定服务器模块,击中目标的瞬间断到下图位置

![213213123](https://raw.githubusercontent.com/che77a38/blogImage/main/202202161531371.png)

观察红线标记的模块,可知服务器模块应该就是mp.dll,可对其他数据进行下断确定不经过该模块.

回头发现,只有鼠标经过指向目标才变回来的是个基地址,第三行数据往上追的过程中经过了mp.dll模块,因此最终确定到第二行数据才是真是数据,而不是第三行.

在x32dbg中追第二行数据:

![999999999999](https://raw.githubusercontent.com/che77a38/blogImage/main/202202161600416.png)

```c
得出队友血量的地址=[0x1A17CB8]*0x68+0x1A2565C
//可见0x1A17CB8地址存的是2(游戏中鼠标指向不同的人,下标会改变,从0开始),可能是一个下标.敌人存的血量填的是100即0x64,原因是敌人血量不可见,同时也看不到自己的血量(为0)
  因此遍历实体血量:n*0x68+0x1A2565C
```

比对数组项之间的差异,结构体大小为0x68(公式分析得出),-0x30的目的是因为我们找到的有可能并不是数组项的起始地址

![987887](https://raw.githubusercontent.com/che77a38/blogImage/main/202202161654479.png)

0和5下标是边界外,游戏目前数据只有1~4,1,2,4是队友,3是敌人

打死队友发现其对应的生命不归零,因此需要找死亡标志

```c
//假如我们设n*0x68+0x1A2565C-0x68为起始数组项地址(-0x68是为了使后面的偏移项都是正数)
//n*0x68+h1.exe+0x62565C-0x68    n下标从1开始(减掉68使得下标本来"从0开始"变成"从1开始")
+0x4E BYTE  	//阵容,1表示恐怖分子,2表示反恐精英,0是观察者
+0x60	BYTE		//死亡标记:1表示死亡,0表示活着,超出范围的此项也为1
+0x68 DWORD  	//血量,死亡不清零,敌人和自己的血量均没有意义
```

我们还要找坐标的数据结构:

通过反复让敌人行动找到了坐标,锁定才能触发屏闪的位置,不锁定什么反应都没有的情况,下硬件写入断点直接崩溃.

发现必须找到是不锁定的情况下修改坐标人物抖动以下,这个才是真正要找的目标坐标.发现他是一个基地址:h1.exe+1B5A998

并且在其附近发现了目标的名称

下硬件访问断点开始追该地址

断在的两个位置(分别是下图两次标黄)往上追都不好追,追丢了.但可以猜测出最末一层的结构体偏移为0x188

![54646546](https://raw.githubusercontent.com/che77a38/blogImage/main/202202162322962.png)

尝试不直接断坐标数据,而是断前后几个数据之一,断到的位置往上追一层偏移,放开断点后发现上一层偏移的地址中存的值变成了0,即这个地址是个临时的地址,也不能用

尝试在名字下访问断,断下的位置发现有一个基地址偏移,因此大概率是可以追到数据结构的.

![747474](https://raw.githubusercontent.com/che77a38/blogImage/main/202202162313907.png)

上图可知:

```c
//遍历名字算式为:0x2F5A6C8+0x24C*N
//N的范围为0~31,指向为0表示遍历结束
```

确定结构体首地址:

![786474345](https://raw.githubusercontent.com/che77a38/blogImage/main/202202162327528.png)

上图可知坐标比名字大0x84,前面有知道名字的末层偏移是0x188

因此名字的末层偏移为0x104

```c
//因此结构体数组首地址为0x2F5A6C8-0x104=0x2F5A5C4
//所以结构体数组首地址算式为h1.exe+0x1B5A5C4+0x24C*N
//超出人物数量的结构体数组项全为0,加入的人物再把人物删除掉后并不会初始化该数组,但是名称最前面的一个字节会变成00
+0x0  	DWORD		//等于0结束遍历(中间可能出现空坐标,但该项也一定不为空)>>>注意遍历要跳过自己,因为自己该项也是0	
+0x104	ASCII		//名称		名字为空的话,代表这个结构没有玩家,或玩家已死亡
+0x130  ASCII   //人物模型字符串    比如:guerilla,leet等等等等
+0x180  FLOAT   //该数值不断循环从0加到60,仅当处于本人范围内才变化,范围外不变化		可用于判断对应玩家是否处在本人坐标数据获取范围内
+0x188  FLOAT		X坐标   //坐标超出范围不变化,变化说明在范围内;自己的坐标不变化
+0x18C	FLOAT		Y坐标
+0x190	FLOAT		Z坐标		//坐标为0表示该项不存在,观察发现数组不一定是顺序存放
```

由于上面结构并没有本人坐标,因此下面逆向本人坐标

**找本人坐标的时候,其特点是锁定数值后,修改数值,人物产生位移,解除锁定后,动下人物,人物瞬移回来**

另外一种情况是锁定后,修改,不断的人物屏闪,这种内存也能用,但是最好不要下断,太快了,容易崩溃

**要注意移动到一个位置后要等他完全静止才搜变动,因为有些内存更改比较慢(上面非屏闪情况就是这种)**

```c
//本人坐标:(屏闪,非常快)
h1.exe+1B5A528	FLOAT	X坐标
h1.exe+1B5A52C	FLOAT	Y坐标
h1.exe+1B5A530	FLOAT	Z坐标
//不屏闪但慢慢会跳转(3个不同的X坐标)
h1.exe+19E3F28
h1.exe+19f0750
h1.exe+19F4A08
//完全不跳转,也不屏闪,锁定修改后完全没反应(最快)
h1.exe+195FE58
//意外发现朝向数据(但是只可以显示朝向数据,却无法改变准星朝向,本地必然还有一个内存存着真正可以控制准星的数据)
h1.exe+1B5A508	FLOAT	垂直朝向		//范围是-89(向上为负)到89(向下为正)
h1.exe+1B5A50C	FLOAT	水平朝向		//范围是360到0(左到右)
```

在x32dbg中简单观察了一下,初步确认不是来自于mp.dll的服务器数据

利用上面找到的朝向数值来找真正的准星内存:(可以修改准星位置的内存数据)

```c
h1.exe+19E10C4	FLOAT	垂直朝向		//范围是-89(向上为负)到89(向下为正)
h1.exe+19E10C8	FLOAT	水平朝向		//范围是360到0(左到右)
//0的方向是坐标x增大方向,180是坐标x减小的方向
//90的方向是坐标y增大方向,270是坐标y减小的方向
```

## 找矩阵

[找矩阵方法总结](# 找矩阵总结)

按照上述方法找到的矩阵地址为: `0x2c20100`  =  `hl.exe+1820100`

口袋西游逆向参见详见51和53课

# 突袭的逆向

















