---
title: FPS逆向
tags: FPS
categories: 杂项

---



[x64dbg快捷键]: https://www.52pojie.cn/thread-227097-1-1.html

fps辅助整体分析

<!-- more -->

- FPS游戏特性导致的，需要非常高的实时性，不能过度的网络验证
- 绘制部分可以使用透明窗口覆盖在游戏上，非常难以检测
- 自瞄部分，捕捉准星数据，准星路径曲线不规则或有中断（不能平滑，人类操作鼠标非常不圆滑）
- 连续爆头的行为检测行为数据异常等等

# 相关基础

## 角度计算

- tan，cos，sin函数，**参数为弧度**，弧度为π表示180度。
- atan2，acos2，asin2，**返回值为弧度**。

$$
角度=(弧度*180)/π
$$

$$
弧度=(角度*π)/180
$$

[3线性代数本质系列]: https://www.bilibili.com/video/BV1ys411472E?spm_id_from=333.999.0.0

向量内积是一个向量在另一个向量上的投影长度乘以另一个向量的长度

```c
//比如：[1,3]和[3,0]的向量内积为：
[1,3]*[3,0]=3+0=3
```

矩阵的乘法：

![image-20220122133019389](https://raw.githubusercontent.com/che77a38/blogImage/main/202201221330618.png)

## 快捷键写法

```c
if(GetKeyState(VK_F1)&1)//VK_F1是键码
{
	//按下F1执行里面的指令,再按下F1停止执行里面的指令
}
```

## 绘制的三种方法

1. hook d3d/opengl
   - 优:完全不闪,代码简单
   - 缺:非常容易被检测
2. 游戏窗口上自行绘制
   - 优:适中
   - 缺:会闪
3. 自己创建窗口,在自己创建的窗口上绘制
   - 优:稳定
   - 缺:麻烦一点,会闪,需要通信

# 3维坐标转屏幕算法

两种坐标求导算法

- 需要矩阵
- 不需要矩阵

## 不需要矩阵

![image-20220122192831457](https://raw.githubusercontent.com/che77a38/blogImage/main/202201221928872.png)
$$
摄像机到准星的距离分辨率=\frac{\frac{屏幕水平分辨率}{2}}{\tan{\frac{水平FOV}{2}}}
\\
\\
\tan{x差角度}=\frac{屏幕的x差分辨率}{摄像机到准星的距离分辨率}
\\
\\
\tan{x差角度}=\frac{屏幕的x差分辨率}{\frac{\frac{屏幕水平分辨率}{2}}{\tan{\frac{水平FOV}{2}}}}
\\
\\
屏幕的x差分辨率=\frac{\frac{屏幕水平分辨率}{2}}{\tan{\frac{水平FOV}{2}}}\times\tan{x差角度}
\\
$$
因为屏幕的左上角为(0,0)，向右为x变大，向下为y变大，因此可知：

**屏幕上指向敌人的x坐标**就是:**屏幕的x差分辨率+水平分辨率/2**

![image-20220122151558943](https://raw.githubusercontent.com/che77a38/blogImage/main/202201221515481.png)
$$
\frac{垂直FOV}{水平FOV}=\frac{垂直分辨率}{水平分辨率}
\\
\\
屏幕的y差分辨率=\frac{\frac{屏幕垂直分辨率}{2}}{\tan{\frac{垂直FOV}{2}}}\times\tan{y差角度}
\\
\\
屏幕的y差分辨率=\frac{\frac{屏幕水平分辨率}{2}}{\tan{\frac{水平FOV}{2}}}\times\tan{y差角度}
$$
**屏幕上指向敌人的y坐标**就是:**屏幕的y差分辨率+垂直分辨率/2**

### **总结**

$$
屏幕坐标X=\frac{\frac{屏幕水平分辨率}{2}}{\tan{\frac{水平FOV}{2}}}\times\tan{x差角度}+\frac{水平分辨率}{2}
\\
\\
屏幕坐标Y=\frac{\frac{屏幕水平分辨率}{2}}{\tan{\frac{水平FOV}{2}}}\times\tan{y差角度}+\frac{垂直分辨率}{2}
\\
$$

算法如下：

```cpp
#define PI 3.1415926

class 坐标结构
{
public:
    int X,Y;
};

float 弧度转角度(float 弧度)
{
    return 弧度*180/PI;
}

float 角度转弧度(float 角度)
{
    return 角度*PI/180;
}

bool 世界坐标转屏幕坐标_非矩阵(坐标结构& 屏幕坐标,float 水平角度差,float 垂直角度差,float 水平FOV)
{
    取窗口信息(水平分辨率，垂直分辨率);//获取屏幕分辨率(伪函数)
    float 摄像机到准星的距离分辨率=水平分辨率/2/(tan(角度转弧度(水平FOV/2)));
    float 高低最大可视角度=弧度转角度(atan2(垂直分辨率/2,摄像机到准星的距离分辨率));
    if (fabs(水平角度差)>水平FOV/2||fabs(垂直角度差)>高低最大可视角度)
    {
        return false;//不在屏幕范围内
    }
    int 水平差=摄像机到准星的距离分辨率*tan(角度转弧度(水平角度差));
    屏幕坐标.X=水平差+水平分辨率/2;
    int 垂直差=摄像机到准星的距离分辨率*tan(角度转弧度(垂直角度差));
    屏幕坐标.Y=垂直差+垂直分辨率/2;
    return true;
}
```

无矩阵方式为:获取人物与目标的世界坐标高度差和世界水平距离来得到人物和目标的夹角,再通过人物准星减去目标夹角(或反过来)来确定准星偏转**角度差**,再通过准星偏转角度差和游戏宽高分辨率来转换成屏幕坐标进行绘图

这种方式得到的坐标绘制多多少少有误差,下面用到矩阵的方式无误差

## 需要矩阵

[上帝视角看gpu系列(有助于理解矩阵算法)]: https://space.bilibili.com/2055684362/channel/collectiondetail?sid=318149

矩阵分行主序与列主序,主要是d3d和openGl的区别

- 行主序(D3D)

  ```
  a1 a2 a3 a4          x         a1*x+a2*y+a3*z+a4*w
  b1 b2 b3 b4    乘以  	y  =      b1*x+b2*y+b3*z+b4*w
  c1 c2 c3 c4          z         c1*x+c2*y+c3*z+c4*w
  d1 d2 d3 d4          w         d1*x+d2*y+d3*z+d4*w
  ```

- 列主序(openGl)

  ```
                 a1 b1 c1 d1    a1*x+a2*y+a3*z+a4*w
  x,y,z,w  乘以  a2 b2 c2 d2  =  b1*x+b2*y+b3*z+b4*w
                a3 b3 c3 d3     c1*x+c2*y+c3*z+c4*w
                a4 b4 c4 d4     d1*x+d2*y+d3*z+d4*w
  ```

### 缩放和位移矩阵

```c
//行主序:(D3D)
Sx 0  0  Tx
0  Sy 0  Ty
0  0  Sz Tz
0  0  0  Tw
//列主序:(openGl)
Sx 0  0  0
0  Sy 0  0
0  0  Sz 0
Tx Ty Tz Tw
  
//平移缩放后的坐标如下
                  Sx*x+w*Tx
x,y,z,w乘以列主序= Sy*y+w*Ty
  							 Sz*z+w*Tz
                 w*Tw
```

**[第一结论]** : 行主序最后一列,列主序最后一行,走路,跳,会发生改变,不代表别的动作不改变

### **旋转矩阵**

#### 绕z轴旋转矩阵

```c
绕z轴旋转矩阵(A表示点逆时针旋转角度 或 坐标系顺时针旋转角度)
//行主序
cosA   -sinA  0  0
sinA   cosA   0  0
0      0      1  0
0      0      0  1
//列主序
cosA   sinA   0  0
-sinA  cosA   0  0
0      0      1  0
0      0      0  1

//绕z轴顺时针旋转后的坐标如下:
                 xcosA-ysinA
x,y,z,w乘以列主序= xsinA+yconsA
                 z
                 w
```

**[第二结论]** : 水平转动的情况,行主序第三列不变,列主序第三行不变

#### 绕x轴旋转矩阵

```c
绕x轴旋转矩阵(A表示点逆时针旋转角度 或 坐标系顺时针旋转角度)
//行主序
1  0     0      0
0  conA  -sinA  0
0  sinA  cosA   0
0  0     0      1
//列主序
1  0     0      0
0  conA  sinA   0
0  -sinA cosA   0
0  0     0      1

//绕x轴顺时针旋转后的坐标如下:
                 x
x,y,z,w乘以列主序= -zsinA+yconsA
                 ysinA+zcosA
                 w
```

**[第三结论]** : 高低朝向改变的时候,行主序第一行不变,列主序第一列不变

#### 绕y轴旋转矩阵

```c
//绕y轴旋转矩阵(A表示点逆时针旋转角度 或 坐标系顺时针旋转角度)
//行主序
cosA  0  sinA  0
0     1  0     0
-sinA 0  cosA  0
0     0  0     1
//列主序
cosA  0  -sinA 0
0     1  0     0
sinA  0  cosA  0
0     0  0     1

//绕y轴顺时针旋转后的坐标如下:
                 xcosA+zsinA
x,y,z,w乘以列主序= y
                 -xsinA+zcosA
                 w
```

### 矩阵变换总结

[矩阵变换总结]: https://www.cnblogs.com/moxiaotao/p/11205082.html

### **找矩阵总结**

分类

- 行主序(D3D)
- 列主序(openGl)

总结

- **[第一结论]** : 行主序最后一列,列主序最后一行,走路,跳,会发生改变(只影响这行或列),不代表别的动作不改变)
- **[第二结论]** : 水平转动的情况,行主序第三列(或第二列)不变,列主序第三行(或第二行)不变
- **[第三结论]** : 高低朝向改变的时候,行主序第一行不变,列主序第一列不变

下面的结论不绝对

- **[第四结论]**矩阵第一个值往往是-1到1之间的(只有一部分)
- **[第五结论]**行主序第一行第三个(或第二个)元素是固定的0,列主序第一列的第三个(或第二个)元素是0
- **[第六结论]**开倍镜,第一个值会乘以相应的倍数(这个是绝对的)
- **[第七结论]**列主序最后两列前三值相似,行主序最后两行前三值相似(只做参考)
- **[第八结论]**随便走,不动准星,会有一行或一列4个在变化(如果只朝x或y前进,那么也只改变3个值,即行主序最后一列第一个与列主序最后一行第一个当沿着x或y方向走也不变),跳就只有三个值在一行或一列变化[第八结论UE4矩阵不符合,可参考下面的UE4专题]

经验:

- 找矩阵的时候一批次只用确定一次
- 找矩阵的时候,优先找多号码段连排的

**基本步骤**

1. 鼠标移动,搜变动
2. 人物移动,跳跃等搜不变动
3. 如果剩余过多尝试不绝对结论减少数量(风险)
4. 剩余不多数量的情况下,每个打开看看移动是不是四个连着的数据改变,跳跃是不是三个连着的数据改变

[找矩阵实例](# 找矩阵)

### **世界坐标转换为屏幕坐标**

> **剪辑坐标**:理解为三维世界的切片

**NDC坐标**(标准化设备坐标)

就是将剪辑坐标的范围缩小至-1到1,如图:

![img](https://raw.githubusercontent.com/che77a38/blogImage/main/202203211338236.png)

**世界坐标-->剪辑坐标-->NDC坐标**

```c
//世界坐标转换为剪辑坐标(剪辑坐标和分辨率没有任何关系)
//世界坐标  *     矩阵
                a0  a1  a2  a3
x,y,z,w   乘以   a4  a5  a6  a7
                a8  a9  a10 a11
                a12 a13 a14 a15
                  
剪辑坐标x   =   a0*x+a4*y+a8*z+a12*w
剪辑坐标y   =   a1*x+a5*y+a9*z+a13*w
剪辑坐标z   =   a2*x+a6*y+a10*z+a14*w
剪辑坐标w   =   a3*x+a7*y+a11*z+a15*w
//剪辑坐标w如果小于0表示在屏幕外!!!!!!!!!!!!!!!!!!!!!!

//剪辑坐标转换为NDC坐标
NDC.x=剪辑坐标x/剪辑坐标w
NDC.y=剪辑坐标y/剪辑坐标w
NDC.z=剪辑坐标z/剪辑坐标w //无用                 
```

**NDC坐标-->屏幕坐标**

![捕获](https://raw.githubusercontent.com/che77a38/blogImage/main/202203211629382.png)

实际上就是坐标系的转换,NDC坐标系转换成屏幕分辨率坐标系.

<img src="https://raw.githubusercontent.com/che77a38/blogImage/main/202203211712682.jpeg" alt="截屏2022-03-21 17.12.02"  />
$$
\frac{目标点的NDC坐标X}{2}=\frac{屏幕坐标差x}{显示器分辨率宽}
\\
\\
\frac{目标点的NDC坐标y}{2}=\frac{屏幕坐标差y}{显示器分辨率高}
$$

```c
//上面两个公式可知:
目标点的屏幕坐标差x=目标点的NDC坐标X*显示器分辨率宽/2
目标点的屏幕坐标差y=目标点的NDC坐标y*显示器分辨率高/2
```

因此**NDC坐标--->屏幕坐标算法**计算如下:
$$
目标点的屏幕坐标x=\frac{目标点的NDC坐标X\times分辨率宽}{2}+\frac{分辨率宽}{2}
\\
目标点的屏幕坐标y=\frac{分辨率高}{2}-\frac{目标点的NDC坐标y\times分辨率高}{2}
$$
坐标点A和坐标点B均适用,说明四象限全适用.

## 朝向（准星）

准星数据寻找

在fps游戏中，横轴是可以无限原地转圈的，而竖轴上下大概在180度左右，所以Y往往比X更合适用来当作这一数据的突破口。那么假设准星数据做了处理，应该如何找到瞄准call呢？搜索出与准星坐标相关的地址后，移动鼠标进行访问断，就有可能断到相关的函数。

朝向极大概率是浮点数。

需要找到x,y轴坐标对应的朝向。

# 矩阵补充

通常情况下Dx9中会采用4*4的矩阵

这里说的横矩阵是列主序,列矩阵是行主序

![image-20210514115116708](https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210514115116708.png)

 //荒野行动横矩阵第3排，第4列的数，光标朝天看的时候是1，朝地下是-1。（此结论通用性待验证）

补充一个3*4列矩阵

```cpp
X X X x
X X X y
X X X z
0 0 0 比例
3*4（列矩阵）
```

UE4矩阵

```
UE4最常见的两种矩阵
//第一种横矩阵格式（上+下-）（这就是上图中荒野行动那种）
xxx xxx 0 xxxx
xxx xxx 0 xxxx
xxx xxx 0 xxxx
 X   Y 比例 Z
//第二种横矩阵格式(上-下+)
xxx xxx xxxx 0
xxx xxx xxxx 0
xxx xxx xxxx 0
 X   Y   Z  比例
 //特征：除了XYZ，其他所有数值在（-2，+2）间
```

[cf思路]: https://bbs.pediy.com/thread-251836.htm

普通食物4*4横矩阵和竖矩阵的矩阵头在这个区间（-2，+2）

针对自动瞄准，应该如何检测：

1、模拟类自瞄

一、Hook windows所提供的所有按键操作、鼠标操作类接口，函数全部由游戏安全系统接管。

二、既然Hook了相关函数，那么就可以被突破，Hook被还原，还要在代码段上下crc，防止被还原Hook，在crc上多次套crc，多设防御关卡。

三、检测鼠标轨迹和移动速度，没有谁可以一直直线移动鼠标。

2、内存类自瞄

一、Hook windows所提供的所有“写内存”类接口，如WriteProcessMemory（），函数全部由游戏安全系统接管，检测到非自身或者未知程序调用该类型函数对游戏进行操作时，将其踢下线。

二、同模拟类自瞄第二条。

三、同模拟类自瞄第三条。

四、加密鼠标横轴（x坐标），且多个地址同步准星数据，当非法修改了准星位置，即准星数据不同步，即可知道非法修改了内存。

​    那么接下来，同笔者一起分析，透视自瞄究竟是如何实现的呢？

​    其实只要实现了自瞄，就相当于实现了透视，只是需要开发者通过一系列算法将其绘制在屏幕上而已。而实现自瞄，对于有相关工作经验的人来说，也算不上难，一套公式，几乎“通杀”所有FPS。自瞄算法可以简单的分为两种，一种通过玩家坐标和准星位置进行计算，一种为”矩阵自瞄“，计算模型骨骼等等，其实两种自瞄本质意义上区别不大，各有各的好处，只不过第二种更为精准，第一种则更为方便，需要的数据更少。









自己封装内存模块用到的api

1. 打开进程===OpenProcess
2. 打开当前进程===OpenProcess
3. 写内存===WriteProcessMemory
4. 关闭句柄===CloseHandle
5. 读取内存整数===ReadProcessMemory
6. 保护内存===VirtualQueryEx
7. 读内存字节集===ReadProcessMemory
8. 提示自身进程权限===RtlAdjustPrivilege
9. 获取当前进程id===GetCurrentProcessId
10. 取一个窗口的标题===GetWindowTextA
11. 寻找窗口句柄===FindWindowExA
12. 获取窗口客户区===GetClientRect
13. 获取窗口类名===GetClassNameA
14. 终止进程===TerminateProcess
15. 获取快照信息===CreateToolhelp32Snapshot
16. 获取遍历快照的第一个进程===Process32First
17. 获取遍历快照的下一个进程===Process32Next
18. 获取遍历快照的第一个模块===MODULE32First
19. 获取遍历快照的下一个模块===MODULE32Next

```javascript
UE4
Count(环境数量)→  -游戏类型  → 数组Actor
↓                               ↓
Uworld（世界地址）            人物坐标XYZ  血量 阵容  飞天
```



```
X
Y
Z地址"UE4Game-Win64-Shipping.exe"+02CC5F50]+588]+158]+1D8

[[[[[7FF714B28BF0+88+rcx*3*8+8]+10]+50]+270]+158]+1D0==233F0434FE0
```



# CE找数据技巧

找数据技巧：排除栈地址，排除ui上显示的数据信息，排除追踪到服务器模块的情况（如果本机有服务器的话）

大量30~80的字符表示的是ascii字符串，4或C开头的4字节大概率是浮点数

对于服务器和客户端模块都在本地的游戏,使用一些确定是服务器数据的数据来找来源,来源于的模块大概率就是服务器模块

**追任何偏移,如果CE能直接搜索到对应基地址,则可直接使用基地址**

可以通过call内的ret来判断这个call有几个参数,而不仅仅是通过找call前的push数量

## dbg配合ce找下属偏移的高级技巧

**角色对象附近地址的属性都可以直接尝试定位,甚至可以到CE搜所有相同结果,找所有结果中最靠近对象地址附近的结果,然后通过 `所有结果中最靠近对象地址-对象首地址`来得到猜测的偏移.这时候直接在最靠近对象的地址下访问断,看能不能断到偏移就是猜测偏移的地址**   [该技巧使用实例](#骨骼数据)

针对单机游戏如下:

无限子弹通过对子弹数下写入断就可以断到,断到的位置往上翻找子弹数减少1,修改此处可以无限子弹.往上追上层call一定会追到射击call,射击call附近应该有射速相关的参数,可能是射击间隔作为参数,也可能是别的;(老游戏每个枪可能都有一个射击call,但是往上追会追到一个通用的射击call).每个call进行屏蔽,来确定哪个是负责后坐力的,简单粗暴把负责后坐力的nop掉,将call改成`add esp,参数字节数`,就实现了没有后坐力.找无敌可以到血量下写入断点,断到的位置的call很可能就是扣血call,nop掉就不扣血了.放雷的call中,nop掉[所有可能跳过将雷的数量减一放入某地址的操作],就实现了疯狂丢雷无间隔.

------

逆向注意点:下图这样的lea一个堆栈地址的情况,要这么处理

![逆向注意点](https://raw.githubusercontent.com/che77a38/blogImage2/main/202204171641184.jpeg)

# CS1.6的逆向

## 找内存数据

通过客户端或服务端来搜数据排查服务端的模块是哪一个

找血量数据如下:

![00001](https://raw.githubusercontent.com/che77a38/blogImage/main/202202161531874.png)

只有蓝标数据真正可以修改目标血量,说明这个数据是服务端数据,到x32dbg中下写入断点来确定服务器模块,击中目标的瞬间断到下图位置

![213213123](https://raw.githubusercontent.com/che77a38/blogImage/main/202202161531371.png)

观察红线标记的模块,可知服务器模块应该就是mp.dll,可对其他数据进行下断确定不经过该模块.

回头发现,只有鼠标经过指向目标才变回来的是个基地址,第三行数据往上追的过程中经过了mp.dll模块,因此最终确定到第二行数据才是真是数据,而不是第三行.

在x32dbg中追第二行数据:

![999999999999](https://raw.githubusercontent.com/che77a38/blogImage/main/202202161600416.png)

```c
得出队友血量的地址=[0x1A17CB8]*0x68+0x1A2565C
//可见0x1A17CB8地址存的是2(游戏中鼠标指向不同的人,下标会改变,从0开始),可能是一个下标.敌人存的血量填的是100即0x64,原因是敌人血量不可见,同时也看不到自己的血量(为0)
  因此遍历实体血量:n*0x68+0x1A2565C
```

比对数组项之间的差异,结构体大小为0x68(公式分析得出),-0x30的目的是因为我们找到的有可能并不是数组项的起始地址

![987887](https://raw.githubusercontent.com/che77a38/blogImage/main/202202161654479.png)

0和5下标是边界外,游戏目前数据只有1~4,1,2,4是队友,3是敌人

打死队友发现其对应的生命不归零,因此需要找死亡标志

```c
//假如我们设n*0x68+0x1A2565C-0x68为起始数组项地址(-0x68是为了使后面的偏移项都是正数)
//n*0x68+h1.exe+0x62565C-0x68    n下标从1开始(减掉68使得下标本来"从0开始"变成"从1开始")
+0x4E BYTE  	//阵容,1表示恐怖分子,2表示反恐精英,0是观察者
+0x60	BYTE		//死亡标记:1表示死亡,0表示活着,超出范围的此项也为1
+0x68 DWORD  	//血量,死亡不清零,敌人和自己的血量均没有意义
```

我们还要找坐标的数据结构:

通过反复让敌人行动找到了坐标,锁定才能触发屏闪的位置,不锁定什么反应都没有的情况,下硬件写入断点直接崩溃.

发现必须找到是不锁定的情况下修改坐标人物抖动以下,这个才是真正要找的目标坐标.发现他是一个基地址:h1.exe+1B5A998

并且在其附近发现了目标的名称

下硬件访问断点开始追该地址

断在的两个位置(分别是下图两次标黄)往上追都不好追,追丢了.但可以猜测出最末一层的结构体偏移为0x188

![54646546](https://raw.githubusercontent.com/che77a38/blogImage/main/202202162322962.png)

尝试不直接断坐标数据,而是断前后几个数据之一,断到的位置往上追一层偏移,放开断点后发现上一层偏移的地址中存的值变成了0,即这个地址是个临时的地址,也不能用

尝试在名字下访问断,断下的位置发现有一个基地址偏移,因此大概率是可以追到数据结构的.

![747474](https://raw.githubusercontent.com/che77a38/blogImage/main/202202162313907.png)

上图可知:

```c
//遍历名字算式为:0x2F5A6C8+0x24C*N
//N的范围为0~31,指向为0表示遍历结束
```

确定结构体首地址:

![786474345](https://raw.githubusercontent.com/che77a38/blogImage/main/202202162327528.png)

上图可知坐标比名字大0x84,前面有知道名字的末层偏移是0x188

因此名字的末层偏移为0x104

```c
//因此结构体数组首地址为0x2F5A6C8-0x104=0x2F5A5C4
//所以结构体数组首地址算式为h1.exe+0x1B5A5C4+0x24C*N
//超出人物数量的结构体数组项全为0,加入的人物再把人物删除掉后并不会初始化该数组,但是名称最前面的一个字节会变成00
+0x0  	DWORD		//等于0结束遍历(中间可能出现空坐标,但该项也一定不为空)>>>注意遍历要跳过自己,因为自己该项也是0	
+0x104	ASCII		//名称		名字为空的话,代表这个结构没有玩家,或玩家已死亡
+0x130  ASCII   //人物模型字符串    比如:guerilla,leet等等等等
+0x180  FLOAT   //该数值不断循环从0加到60,仅当处于本人范围内才变化,范围外不变化		可用于判断对应玩家是否处在本人坐标数据获取范围内
+0x188  FLOAT		X坐标   //坐标超出范围不变化,变化说明在范围内;自己的坐标不变化
+0x18C	FLOAT		Y坐标
+0x190	FLOAT		Z坐标		//坐标为0表示该项不存在,观察发现数组不一定是顺序存放
```

由于上面结构并没有本人坐标,因此下面逆向本人坐标

**找本人坐标的时候,其特点是锁定数值后,修改数值,人物产生位移,解除锁定后,动下人物,人物瞬移回来**

另外一种情况是锁定后,修改,不断的人物屏闪,这种内存也能用,但是最好不要下断,太快了,容易崩溃

**要注意移动到一个位置后要等他完全静止才搜变动,因为有些内存更改比较慢(上面非屏闪情况就是这种)**

```c
//本人坐标:(屏闪,非常快)
h1.exe+1B5A528	FLOAT	X坐标
h1.exe+1B5A52C	FLOAT	Y坐标
h1.exe+1B5A530	FLOAT	Z坐标
//不屏闪但慢慢会跳转(3个不同的X坐标)
h1.exe+19E3F28
h1.exe+19f0750
h1.exe+19F4A08
//完全不跳转,也不屏闪,锁定修改后完全没反应(最快)
h1.exe+195FE58
//意外发现朝向数据(但是只可以显示朝向数据,却无法改变准星朝向,本地必然还有一个内存存着真正可以控制准星的数据)
h1.exe+1B5A508	FLOAT	垂直朝向		//范围是-89(向上为负)到89(向下为正)
h1.exe+1B5A50C	FLOAT	水平朝向		//范围是360到0(左到右)
```

在x32dbg中简单观察了一下,初步确认不是来自于mp.dll的服务器数据

利用上面找到的朝向数值来找真正的准星内存:(可以修改准星位置的内存数据)

```c
h1.exe+19E10C4	FLOAT	垂直朝向		//范围是-89(向上为负)到89(向下为正)
h1.exe+19E10C8	FLOAT	水平朝向		//范围是360到0(左到右)
//0的方向是坐标x增大方向,180是坐标x减小的方向
//90的方向是坐标y增大方向,270是坐标y减小的方向
```

## 找矩阵

[找矩阵方法总结](# 找矩阵总结)

按照上述方法找到的矩阵地址为: `0x2c20100`  =  `hl.exe+1820100`

![image-20220328171548251](https://raw.githubusercontent.com/che77a38/blogImage2/main/202203281715489.png)

# 口袋西游逆向

口袋西游逆向参见详见51和53课

骨骼和模型不一定有绝对坐标,但是一般都有相对坐标

## 基本数据

```c
//人物数据
[[[D0DF1C]+1C]+28]+3C    //X
[[[D0DF1C]+1C]+28]+40    //Y
[[[D0DF1C]+1C]+28]+44    //Z
[[[D0DF1C]+1C]+28]+560   //X中心点
[[[D0DF1C]+1C]+28]+564   //Y中心点
[[[D0DF1C]+1C]+28]+568   //Z中心点
[[[D0DF1C]+1C]+28]+56C   //X中心点到对顶点的X差
[[[D0DF1C]+1C]+28]+570   //Y中心点到对顶点的Y差
[[[D0DF1C]+1C]+28]+574   //Z中心点到对顶点的Z差
[[[D0DF1C]+1C]+28]+578   //立方体下顶点X坐标(斜对角)
[[[D0DF1C]+1C]+28]+57C   //立方体下顶点Y坐标(斜对角)
[[[D0DF1C]+1C]+28]+580   //立方体下顶点Z坐标(斜对角)
[[[D0DF1C]+1C]+28]+584   //立方体上顶点X坐标(斜对角)
[[[D0DF1C]+1C]+28]+588   //立方体上顶点Y坐标(斜对角)
[[[D0DF1C]+1C]+28]+58C   //立方体上顶点Z坐标(斜对角)

//周围遍历    N为[0,对象数量)
[[[[D0DF1C]+1C]+8]+20]+5C   //对象数量
[[[[[[[D0DF1C]+1C]+8]+20]+58]+N*4]+4]+3C   //周围对象X
[[[[[[[D0DF1C]+1C]+8]+20]+58]+N*4]+4]+40   //周围对象Y
[[[[[[[D0DF1C]+1C]+8]+20]+58]+N*4]+4]+44   //周围对象Z
[[[[[[[D0DF1C]+1C]+8]+20]+58]+N*4]+4]+ED   //死亡标志位,1为死亡(BYTE)
[[[[[[[D0DF1C]+1C]+8]+20]+58]+N*4]+4]+138  //周围对象血量(未被攻击过是0)
[[[[[[[D0DF1C]+1C]+8]+20]+58]+N*4]+4]+2C4  //X中心点
[[[[[[[D0DF1C]+1C]+8]+20]+58]+N*4]+4]+2C8  //Y中心点
[[[[[[[D0DF1C]+1C]+8]+20]+58]+N*4]+4]+2CC  //Z中心点
[[[[[[[D0DF1C]+1C]+8]+20]+58]+N*4]+4]+2D0  //X中心点到对顶点的X差
[[[[[[[D0DF1C]+1C]+8]+20]+58]+N*4]+4]+2D4  //Y中心点到对顶点的Y差
[[[[[[[D0DF1C]+1C]+8]+20]+58]+N*4]+4]+2D8  //Z中心点到对顶点的Z差
[[[[[[[D0DF1C]+1C]+8]+20]+58]+N*4]+4]+2DC  //立方体下顶点X坐标(斜对角)
[[[[[[[D0DF1C]+1C]+8]+20]+58]+N*4]+4]+2E0  //立方体下顶点Y坐标(斜对角)
[[[[[[[D0DF1C]+1C]+8]+20]+58]+N*4]+4]+2E4  //立方体下顶点Z坐标(斜对角)
[[[[[[[D0DF1C]+1C]+8]+20]+58]+N*4]+4]+2E8  //立方体上顶点X坐标(斜对角)
[[[[[[[D0DF1C]+1C]+8]+20]+58]+N*4]+4]+2EC  //立方体上顶点Y坐标(斜对角)
[[[[[[[D0DF1C]+1C]+8]+20]+58]+N*4]+4]+2F0  //立方体上顶点Z坐标(斜对角)
```

![image-20220330172058752](https://raw.githubusercontent.com/che77a38/blogImage2/main/202203301720046.png)

## 找矩阵

[找矩阵方法总结](# 找矩阵总结)

矩阵头地址为:  `[[[ELEMENTCLIENT.EXE+0x90DF1C]+14]+8]+E8`

`[ELEMENTCLIENT.EXE+92E5D0]+E8`  也可以

![image-20220328164120672](https://raw.githubusercontent.com/che77a38/blogImage2/main/202203281641926.png)

# 突袭的逆向

## 基本数据

```c
//目标血2  [[[587c10]+n*4]+0xEC]  n为[0,[587C18]-1]
//人物数据
[587C0C]+28   //X
[587C0C]+2C   //Y
[587C0C]+30   //Z
[587C0C]+34   //水平朝向顺时针递增360
[587C0C]+38   //竖直朝向-90到90,从下到上
[587C0C]+EC   //角色血量(血量小于等于0为死亡)
  
//周围遍历    N为[1,玩家数量)
587C18  //玩家数量
[[587C10]+n*4]+4    //头X
[[587C10]+n*4]+8    //头Y
[[587C10]+n*4]+C    //头Z
[[587C10]+n*4]+28   //X
[[587C10]+n*4]+2C   //Y
[[587C10]+n*4]+30   //Z
[[587C10]+n*4]+34   //水平朝向顺时针递增360
[[587C10]+n*4]+38   //竖直朝向-90到90,从下到上
[[587C10]+n*4]+50   //身高
[[587C10]+n*4]+EC   //角色血量(血量小于等于0为死亡)
//未分析阵营
```

## 找矩阵

[找矩阵方法总结](# 找矩阵总结)

矩阵头地址: `ac_client.exe+17AFE0`

![image-20220328172108435](https://raw.githubusercontent.com/che77a38/blogImage2/main/202203281721643.png)

# UE4逆向

## UE4引擎特点

- 增加新对象时,即更换物品时(物品从不可见无中生有)内存几乎一直在增加
- 世界中所有万物都在数组结构中,存在数组数量(物品从不可见无中生有的情况,数量会增加,游戏只要不退出而是当前地图重新开始,数量也会增加;只有游戏退出或更换地图重新开始,数量才会重置,同时存数组数量的地址也会发生变化)
- 子弹未命中的情况下不会增加实体,子弹只有命中的情况下才会增加实体

数组数量:几乎没有减少的可能,基本上一直在增加

**UE4的坐标特点:**

```c
//坐标的内存数据符合以下规律
x  y  z  0
1  1  1  0
//这个特点不绝对
```

在CE结构对比工具中,因为z后的0和x下的1被合并误识别为double类型,因此是如图:



在内存中:

![image-20220331194527584](https://raw.githubusercontent.com/che77a38/blogImage2/main/202203311945720.png)



```c
//UE4的矩阵的前面不远处都符合(不绝对):
0 0 1 1
1 1 0 0
1 0(全为浮点数)

//1的浮点数在内存中为:0x3F800000
//UE4矩阵在内存中的特征码:(不绝对)
00 00 00 00 00 00 00 00 00 00 80 3F 00 00 80 3F 00 00 80 3F 00 00 80 3F 00 00 00 00 00 00 00 00 00 00 80 3F 00 00 00 00 00 00 00 00 00 00 80 3F 00 00 80 3F 00 00 00 00
```

UE4矩阵:

![image-20220331192721545](https://raw.githubusercontent.com/che77a38/blogImage2/main/202203311927800.png)

- 上图中红框第三列0,0,0,x永远不变.(不绝对)
- 四处走动时,最后一行除了1其他3个都变(沿着x,y走两个值改变);跳跃时,最后一行除了1和第一个,其他两个变(不绝对)
- 第一个值-1.19到+1.19(不绝对)
- 矩阵下方那排都是0,0,0,1?

参考pubg矩阵:

![image-20220402140648459](https://raw.githubusercontent.com/che77a38/blogImage2/main/202204021406705.png)

## Battle Royale Trainer逆向

吃鸡模拟器

### 基本数据

![笔记图](https://raw.githubusercontent.com/che77a38/blogImage2/main/202204051307338.jpeg)

```c
//COUNT 世界数组的项数量(该数组中还包含所有的报废对象,要找个标志加以区分,如果要找到玩家们,还需要玩家标志)
[["BattleRoyaleTrainer-Win64-Shipping.exe"+2AF0FB8]+138]+0xB8//CE取巧
//x64dbg追到头为:
[[[[["BattleRoyaleTrainer-Win64-Shipping.exe"+2AD9F30]+[(["BattleRoyaleTrainer-Win64-Shipping.exe"+2B00648]+40)]的低4字节*3*8]+20]+c0]+138]+0xB8
  
//COUNT地址-8就是:数组起始地址的地址:
[["BattleRoyaleTrainer-Win64-Shipping.exe"+2AF0FB8]+138]+0xB0
//检查发现,本人对象首地址也在该世界数组中
  
//世界中对象首地址:(N为[0,COUNT-1])
[[["BattleRoyaleTrainer-Win64-Shipping.exe"+2AF0FB8]+138]+0xB0]+N*8
  
//坐标地址:
[对象首地址+158]+190   X
[对象首地址+158]+194   Y
[对象首地址+158]+198   Z
[[世界对象数组地址+n*8]+158]+190     X
[[世界对象数组地址+n*8]+158]+194     Y
[[世界对象数组地址+n*8]+158]+198     Z
//宏观解读:
  [世界对象地址+n*8]得到的是对象结构首地址,再+158]进入一个存放了坐标信息的结构首地址.再+190]取到坐标x或y值
  
//因为世界数组项非常杂乱,什么都有,因此需要找人物标志和作废对象标志
//找人物标志.找人物标志首先要知道人物对象首地址,可以是自己的,也可以是敌人;通过自己的数据向上追几层看看有没有多个对象存在(可以通过宏观解读去找可以断到人物的位置)
//通过自己的数据判断是否有访问断点往上追两层可以追到断下几个对象地址的情况(如下图),但由于该游戏x64dbg访问硬断会崩溃,因此采取CE进行访问代码扫描,在到x64dbg中依次分析,以此找到人物对象;再将人物对象和其他对象在CE中做对比分析.
```

![image-20220404182919564](https://raw.githubusercontent.com/che77a38/blogImage2/main/202204041829938.png)

此位置可以断到多个人物对象,通过查看对应坐标可确定是人物对象地址.通过上图黄标处多次断下的rcx可以得到所有人物对象地址.

#### 找人物特征

![笔记图](https://raw.githubusercontent.com/che77a38/blogImage2/main/202204041754643.jpeg)

用ce比对工具如上图(前一组两列是两个人物,后一组是其他对象),黄标处那两个很可能是人物特征

```c
//如果:
	[对象首地址+0]==  BattleRoyaleTrainer-Win64-Shipping.exe + 0x1D45740//虚表,这个条件更稳定更靠谱
//或者
	[对象首地址+0xB9]==0x200(即十进制512)//等等还有很多条件也可以,不止一种标志,比如0x50偏移等等
//则:
	可判断是人物
```

**[ 重点 ]**  **对象首地址+0的位置,代表的指针往往是指向虚表的(在非虚继承的情况下，虚函数表指针是存在于类的顶部的).其一样代表表示对象具有同样的成员函数(即对象具有同样的行为模板),因此[对象首地址+0]是最好用于判断是否同类对象的偏移.**

#### 排除做废对象

![笔记图](https://raw.githubusercontent.com/che77a38/blogImage2/main/202204051047668.jpeg)

类似+0和+18和+35这样的位置都可以判断

我们发现做废对象,虚表指针也会改变,因此只需要使用上面人物标志的判断方式就可以避开做废对象.

#### 人物存活判断

CE搜索找到自身血量的地址,然后通过上面找到的自己对象地址,通过`自己血量地址-自己对象首地址`得到血量偏移**(角色对象附近地址的属性都可以直接这样尝试定位,甚至可以到CE搜所有相同结果,找所有结果中最靠近对象地址附近的结果,然后通过 `所有结果中最靠近对象地址-对象首地址`来得到猜测的偏移.这时候直接在最靠近对象的地址下访问断,看能不能断到偏移就是猜测偏移的地址 )**

血量地址为: `人物对象首地址+0x7CC`

人物死亡后,血量会<=0

#### 武器相关

**人物对象下存在一些数组结构,即地址+数量的组合.找到一个数组刚好和人物身上的武器数相同的数组结构,当把手榴弹掏出来的时候,数组数量还会加1.**

进到数组首地址中,数组形式存储的这几个对象一般是对应1,2,3号键对应的武器.(顺序对应)

**到武器对象下**,可找到诸如射击间隔(射速),武器朝向,后坐力等浮点数数据,还有子弹数等.

**射速和后坐力**等数据往往是武器**创建后就固定的浮点数**

**可通过找武器对象下的浮点数(避开地址类型数据,防止崩溃,同时避开会变化的浮点数,因为那很可能是武器朝向)进行清0后游戏中尝试射击后还原,来找到后坐力,射速数据的位置.**

```c
//射速
武器对象+39C  浮点数   射速(射击的间隔)   炸弹没有该参数,炸弹应该和枪结构不一致
//后坐力
武器对象+680  浮点数   初始上下抖动幅度
武器对象+684  浮点数   后续上下抖动幅度
武器对象+6A4  浮点数   左右抖动幅度
```

#### 骨骼数据

骨骼数据一般存有相对于人物参考点坐标的偏移坐标(人物参考点坐标可能有别于人物位置坐标)

通过身体上坐标变化比较多的身体部位来找骨骼数据

骨骼数据同样在人物对象下

骨骼数据往往是即使人站着的位置不动,骨骼数据也会轻微晃动(人物在微微晃动)

骨骼坐标数据如下:

![捕获](https://raw.githubusercontent.com/che77a38/blogImage2/main/202204061736996.jpeg)

黄标的是骨骼相对人物参考点坐标的偏移坐标;黄标上一行应该是骨骼的朝向信息,上图也可以看出这个骨骼的结构是个数组,每个re数组项占0x30字节.因此外围还存在数组地址和数组数量

**[找的过程]**    找到相对骨骼坐标地址后访问断往上追,追到下面地址处:

00007FF7A1EB25D9地址截图:

![捕获](https://raw.githubusercontent.com/che77a38/blogImage2/main/202204091405305.JPG)

追到此处继续往上追发现非常难追了,尝试用ce分析.      [此处用到的找偏移的理论方法](#dbg配合ce找下属偏移的高级技巧)

rbx有两个值,均到CE中搜索,发现其中一个有存放他的地址离对象首地址非常近.

![捕获](https://raw.githubusercontent.com/che77a38/blogImage2/main/202204091415645.jpeg)

上图猜测偏移结果为378

证实:

![捕获](https://raw.githubusercontent.com/che77a38/blogImage2/main/202204091425024.jpeg)

```c
[[对象头地址+378]+698+[[对象头地址+378]+6DC]*10]+n*30+10  //偏移地址X   n为[1,0x43]
[[对象头地址+378]+698+[[对象头地址+378]+6DC]*10]+n*30+14  //偏移地址Y   n为[1,0x43]
[[对象头地址+378]+698+[[对象头地址+378]+6DC]*10]+n*30+18  //偏移地址Z   n为[1,0x43]
//[[对象头地址+378]+6DC]*10]为0或1,但发现,无论是0还是1都是一样的结果
//数组首地址是存在+698,因此数组数量应该也在附近,果然在+6A0位置看到了68(0x44)
[对象头地址+378]+6A0    //n的数量
```

上面找到的只是相对参考点的偏移坐标,因此需要**人物参考点坐标**.可以在到对象[头地址+378]下去找参考点坐标.按照逻辑猜测应该在这里

```c
[对象头地址+378]+190  //骨骼基准坐标X
[对象头地址+378]+194  //骨骼基准坐标Y
[对象头地址+378]+198  //骨骼基准坐标Z
```

![捕获](https://raw.githubusercontent.com/che77a38/blogImage2/main/202204091521692.jpeg)

骨骼基准坐标大概率比人物位置坐标要低,一般是人物脚下的位置.还是实际到游戏中绘制一下看看是不是骨骼基准坐标最可靠.

### 找朝向

水平朝向值有-PI到+PI,0到360,-1到+1,非常多种.但很少出现特别大的值.

通过CE简单的搜索后,再通过手动修改来确定找到的是不是正确朝向

断到两个点,通过目标对象首地址配合CE找到目标数据  [此处用到的找偏移的理论方法](#dbg配合ce找下属偏移的高级技巧)

```c
[角色头地址+350]+36C    float    //水平朝向地址
//水平朝向值0~360,地图正东为0/360,顺时针递增
[角色头地址+350]+368    float    //垂直朝向地址
//仰角从0~89.9   0为水平值
//俯角从360~270  360为水平值
```

### 找矩阵

![image-20220331192721545](https://raw.githubusercontent.com/che77a38/blogImage2/main/202203311927800.png)

矩阵地址:   `[["BattleRoyaleTrainer-Win64-Shipping.exe"+2ADA268]+24D08*8+8]+0x280`   

其中24D08的来源涉及非常复杂的加密流程,但是他是不变的.

# Unity逆向

Unity一切基于GameObjects对象,他们可以有各种属性(unity中叫做components组件),有像transform的属性,其包含位置,旋转和比例等这样的数据.

unity的脚本由C#编写,建立在方法中,写在不同的类中以继承MonoBehaviour方法.

其中一些方法如下:

- `void Start()`  这个方法只被调用一次
- `void Update()` 这份方法每一个tick被调用一次
- `void FixedUpdate()`  这个方法每一帧被调用一次
- `void OnGUI()`  这是绘制方法

Unity的文件结构

Unity中所有的脚本被编译为两个DLLs,他们被称为 `Assembly-CSharp` 和 `Assembly-CSharp-firstpass`,他们在 `Gamename_Date->Managed` 文件夹中,其他的dll在文件夹中是引擎代码,和其他系统代码

## Unity找数据特殊技巧:

C#语言编译出来的dll中的语言实际上是IL(.NET框架中的中间语言),该语言的文件可以跨平台运行于**mono**虚拟机.**dnspy**可以将IL语言写的文件基本完美反编译出C#源代码.而**il2cpp**的职责是把IL语言的文件转换为原生的系统二进制文件.

如何区分unity游戏是采用il2cpp技术还是不采用il2cpp技术

- exe文件同目录下有GameAssembly.dll的一般为采用了il2cpp技术(Metadata文件夹所在目录没有什么dll),但可以进行加密隐藏该文件,参考原神
- exe所在目录进入xxxData文件夹中的子目录中有个Metadata文件夹所在目录有一大堆dll文件(此时exe文件同目录下没有GameAssembly.dll)即为未采用il2cpp

il2cpp机制将C#中所有类型信息保存到global-metadata.dat的文件,通过解析global-metadata文件,可以获得C#代码中的类型,方法,字段等等信息

unity游戏偏移层级比较多,因此最优先的方法就是hook,在找到人物的基本属性(一般找血量)后找到赋值的汇编段inline hook取对象地址即可,这是最方便的做法

下面是不用hook的前提下快速找到数组:

- 数组和人数一般满足一定的偏移关系(不绝对)
- 而且unity可以直接找到人物的数组,没有其他对象干扰(找其他物品外部的方式似乎是通过找GameObjectManager).因此完全可以**从人数入手**.

```c
//二者关系如下:
0x********+0x??为人数地址
0x********]+0x10+0x4*i为数组
//0x??在32位中大多数情况是0xC,64位大多数情况是0x18
```









## 逃离塔科夫逆向

**[1]**先追人物坐标

经过一个逆向注意点:下图这样的lea一个堆栈地址的情况,要如下图这么处理

![逆向注意点](https://raw.githubusercontent.com/che77a38/blogImage2/main/202204171641184.jpeg)

未能最后,但追到下面的偏移:

```c
[[[[[[rcx+40]+20]+10]+10]+38]+18]    //角色坐标X地址
```

**[2]**追骨骼





中途会遇到F2会崩溃的情况,此时只能使用硬件访问数据断点来断



放开断点前先跟踪往上追的内存,放开断点的时候,如果发现内存中的值骤变了,说明他是个临时的值,这时候,可以用CE搜的方式往上找











# 绘制相关

除了注入后的dll进行gdi绘制外,还有如下绘制方法

## openGl和D3D绘制

简单粗暴,但容易被检测

### opengl

glBegin  开始渲染函数     一个参数 0 - 9  0是画一个点,1画线等等...

glDisable 关闭渲染函数     一个参数

hook  glbegin函数,在hook中利用glDisable函数关闭我们不想让他显示的渲染

检测方面主要是 "CRC的对抗"



## 自建窗口外部绘制

反外挂最艰难的一种绘制方法

优点:不闪烁,检测难度大了

1. 创建一个透明窗口
2. 同步分辨率
3. 透明窗口跟随游戏移动
4. 置顶透明窗口
5. 自己的窗口上画框

框架代码参考 `/Desktop/FPS/csDLL`

窗口特征枚举检测,截图检测( 可以使用`SetWindowDisplayAffinity`防止自己的外部窗口被截图)

## GDI泄露

**[注意点]:  Create出来的GDI对象，都要用DeleteObject来释放；Create出来的DC，都要用DeleteDC来释放，GetDC得出的DC,要用ReleaseDC来释放。**

getDC每次获取到的都不一样,我理解成开了个拷贝.因此即使是getDC(同一个窗口句柄) 多次,也要每一个getDC对应一个releaseDC才能防止gdi对象泄露

## **双缓冲**

[控制台双缓冲原理]: https://blog.csdn.net/NEFU_kadia/article/details/106211471
[easyxy库中有双缓冲相关代码,可惜未开源]: https://blog.csdn.net/NEFU_kadia/article/details/107213480
[gdi双缓冲原理]: https://blog.csdn.net/wuan584974722/article/details/80429967

