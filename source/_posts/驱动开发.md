---
title: 驱动开发
tags: 内核相关
categories: 技术



---

# 驱动开发

**理解**

- SDK   software development kits(软件开发包)   如Visual Studio 2019(v142)
- WDK  windows driver development kits(驱动开发包)  如WindowsKernelModeDriver10.0

<!-- more -->

设置他们的位置在属性-配置属性-常规-平台工具集,但实际上无需手动设置,因为新建什么项目时vs都帮你自动配置好了

## 准备工作

[环境配置参考](https://blog.csdn.net/newnewman80/article/details/90754999)

创建**Empty WDM Driver**项目，生成的Driver Files文件中的**inf后缀文件**可以直接删除

在源文件中添加的必须是.c后缀的C语言文件。

项目配置中：

1. 属性-C/C++中`将警告视为错误`选项设置为否
2. 属性-链接器中`将链接器警告视为错误`设为否

由于使用的是windowsXP作为开发环境，所以要**针对windowsXP进行项目配置，参考链接**：[开发各平台驱动的设置参考](https://blog.csdn.net/Kwansy/article/details/111051265)

如果建立的是KMDF项目的话,除了上述步骤,还可以将属性-Inf2Cat中`Run Inf2Cat`选项设置为否

**制作不同系统的驱动,要设置属性-Driver Settings-Target OS Version设置为对应操作系统**

属性-Driver Settings-Target Platform设置为Desktop

**驱动的开发流程：**

编写代码->生成.sys文件->部署->启动->停止->卸载

驱动程序的测试最好在**虚拟机中**测试，因为一出问题就蓝屏

**DebugView**软件监视选项中要选上**监视核心**

驱动开发的调试：双机调试

```c
//操作系统调试驱动需要打开测试模式
bcdedit /set nointegritychecks on//关闭驱动数字证书检测
bcdedit /set testsigning on//打开测试模式
pause
shutdown -r -t 1000//一秒之后重启系统
```

无论是debug还是release版本的驱动都会带一个测试的签名,测试的签名 只在测试模式下有效.非测试模式下等于没有签名无法加载驱动.

虚拟机设置(防止待机过长屏幕自动关闭时虚拟机出现问题)

右键-显示设置-电源和随眠-屏幕定时关闭调成从不

### 设置双机调试步骤

虚拟机设置中添加串行端口

![xvniji2](https://raw.githubusercontent.com/che77a38/blogImage2/main/202205161418079.jpeg)

**红色线虽然显示是串行端口2,但实际上由于当前只有一个串行端口,所以在虚拟机系统中设置的引导的调试端口应该是com1**

然后如下,到操作系统中添加调试引导项

```c
//操作系统打开双机调试模式
//操作系统添加新引导(管理员启动)
bcdedit /copy {current} /d "win10 x64 debug for windbg"//新建引导选项,新引导的名字随意取
pause
//手动到运行(win+r)输入msconfig回车-选到新建的引导-高级选项-打开调试模式,设置调试端口为多少(可以到虚拟机中设别管理器的串行端口查看,不要受com几的名字影响,顺序是第几个就是com几)
```

![xvniji3](https://raw.githubusercontent.com/che77a38/blogImage2/main/202205161420348.jpeg)

### 设置windbg连接哪个串口

两种方式,1.图形化操作(下面主要介绍的是这种方式)    2.快捷方式设置参数 `-b -k com:pipe,port=\\.\pipe\管道名,resets=0,reconnect -y`

windbg打开后,点击File-Kernel Debug,打开的窗口中选择COM,Port设置为虚拟机中给串行端口设置的命名管道名字,并且勾选Pipe(表示是命名管道)和Reconnect

![xvniji1](https://raw.githubusercontent.com/che77a38/blogImage2/main/202205161420283.jpeg)

### 设置符号

设置添加系统环境变量_NT_SYMBOL_PATH的值为: `srv*c:\symbols*http://msdl.microsoft.com/download/symbols`

强制加载符号命令: `.reload /f`               使用 `lm`可以看到已加载的符号信息

### windbg调试蓝屏dump文件

windbg可用于查看蓝屏的dump文件,dump文件默认位置在 `C:\\Windows\Minidump\`中

在windbg中选择File-Open source file打开蓝屏的dump文件

分析命令: `!analyze -v` (该命令可以看到蓝屏的时候的调用栈)               查看堆栈命令: `kv`

往往是通过调用栈查看问题出在哪里

#### 操作系统设置dump文件生成步骤

此电脑右键属性-高级系统设置-启动和故障恢复处的设置按钮,在该界面做如下修改

- 勾选 `将事件写入系统日志`
- [写入调试信息] 设置为 `核心内存转储`
- 此处也可以设置转储文件的保存位置

![dump](https://raw.githubusercontent.com/che77a38/blogImage2/main/202205171721503.jpeg)

补充

p.s.修复虚拟机花屏:vmtool重新安装,选择修改,去除SVGA驱动(核显驱动),然后重新在虚拟机中安装显卡驱动.

## PDB（Program Debug Database）

什么是PDB文件？

1. PDB文件是在我们编译工程的时候产生的，它是和对应的模块(exe或dll)一起生成出来的。
2. 每个模块编译的时候都可以生成自己的PDB文件。比如.exe/.dll/.sys等等。

PDB文件对应上了位置和函数名。

**windbg如何找到PDB文件？**

```assembly
SRV*D:\Symbols\XP*http://msdl.microsoft.com/download/symbols
;上面可以在后面添加;继续添加本地地址，比如SRV*D:\Symbols\XP*http://msdl.microsoft.com/download/symbols；D:\Symbols
;D:\Symbols\XP是本地路径，
;http://msdl.microsoft.com/download/symbols是网络路径
kd>.reload
;让windbg重新加载PDB
```

**MSB8040错误**

```cpp
 error MSB8040: 此项目需要缓解了 Spectre 漏洞的库。
```

在属性-常规-输出目录-宏中搜索14：

![image-20210825204301335](https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210825204301335.png)

确定需要的是14.29版本

![image-20210825204450485](https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210825204450485.png)

Visual Studio Installer的单个组件中搜索14.29，将黄标全部勾选，点击修改。问题解决！

##  第一个驱动程序

```c
#include <ntddk.h>//winXP驱动开发用此头文件
//#include <ntifs.h>//wdk开发(除了winXP的其他系统)

//卸载函数
VOID DriverUnload(PDRIVER_OBJECT driver)
{
	DbgPrint("停止运行了\n");
}

//入口函数，相当于main函数
NTSTATUS DriverEntry(PDRIVER_OBJECT pdriver, PUNICODE_STRING pReg)
{
	//驱动程序的入口
	DbgPrint("hello world!\n");
	DbgPrint("pdriver:%wZ\r\n",pReg);
	DbgPrint("pReg:%X\r\n",pdriver);
	//设置一个卸载函数，用于退出
	pdriver->DriverUnload = DriverUnload;
	return STATUS_SUCCESS;
}
```

![image-20210825212547927](https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210825212547927.png)

windbg中可以使用dt命令查看对应数据结构的数据

头文件

- `#include <ntddk.h>`     winXP驱动开发用此头文件
- `#include <ntifs.h>`     wdk开发

### 头文件Wdm.h、Ntddk.h 和 Ntifs.h 的组织结构

在 Windows Vista 版本的 WDK 之前，用于驱动程序开发的主要头文件为 Wdm.h、Ntddk.h 和 Ntifs.h，它们包含很多重复声明。

从 Windows Vista 版本的 WDK 开始，Wdm.h、Ntddk.h 和 Ntifs.h 将按层次结构来组织并且不包含重复信息。上层的文件将包含下层的文件。每个函数和结构声明仅出现一次。

**`Ntifs.h` 包含 `Ntddk.h`，而 `Ntddk.h` 又包含 `Wdm.h`。**

## 内核编程基础

### 内核API的使用

1. 在应用层编程我们可以使用WINDOWS提供的各种API函数，只要导入头文件<windows.h>就可以了，但是在内核编程的时候，我们不能像Ring3那样直接使用。微软为内核提供了专门的API，只要在程序中包含相应的头文件就可以使用了，如：#include<ntddk.h>(假设你已经正确安装了WDK)
2. 在应用层编程的时候，我们通过MSDN来了解函数的详细信息，在内核编程的时候，要使用WDK自己的帮助文档。

### 未导出函数的使用

内核函数有三种

1. 有一些是文档有写，也导出了的函数
2. 有一些是文档没写，但导出了的函数
3. 还有一些是文档没写，也没导出的函数，通过自己特征码定位CALL的位置，手动调用

WDK说明文档只包含了内核模块导出的函数，对于未导出的函数，则不能直接使用

如果要使用未导出的函数，只要自己定义一个函数指针，并且为函数指针提供正确的函数地址就可以使用了。有两种办法都可以获取为导出的函数地址：

1. 特征码搜索
2. 解析内核PDB文件

### 基本数据类型

在内核编程的时候，强烈建议大家遵守WDK的编码习惯，不要这么写：unsigned long length；

习惯使用WDK自己的类型：

| WDK的类型 | 含义           |
| --------- | -------------- |
| ULONG     | unsigned long  |
| PULONG    | unsigned long* |
| UCHAR     | unsigned char  |
| PUCHAR    | unsigned char* |
| UINT      | unsigned int   |
| PUNIT     | unsigned int*  |
| VOID      | void           |
| PVOID     | void*          |

### 返回值

大部分内核函数的返回值都是NTSTATUS类型，如：

```c
NTSTATUS PsCreateSystemThread();
NTSTATUS ZwOpenProcess();
NTSTATUS ZwOpenEvent();
```

这个值能说明函数执行的结果，比如：

| 返回宏                        | 代表数值   | 含义                                                         |
| ----------------------------- | ---------- | ------------------------------------------------------------ |
| STATUS_SUCCESS                | 0x00000000 | 成功                                                         |
| STATUS_INVALID_PARAMETER      | 0xC000000D | 参数无效(这个错误出现往往代表出现了很多错误，因此不代表任何意义) |
| STATUS_BUFFER_OVERFLOW        | 0x80000005 | 缓冲区长度不够                                               |
| STATUS_PENDING                |            | 不能算作一个错误，只是文件传输请求未决(异步)                 |
| STATUS_INSUFFICIENT_RESOURCES |            | 资源调用错误                                                 |

当你调用的内核函数，如果返回的结果不是STATUS_SUCCESS，就说明函数执行中遇到了问题，具体是什么问题，可以在ntstatus.h文件中查看。

### 内核函数中的异常处理

**意义不大，该蓝屏还是蓝屏**

在内核中，一个小小的错误就可能导致蓝屏，比如：读写一个无效的内存地址。为了让自己的内核程序更加健壮，强烈建议大家在编写内核程序时，使用异常处。

Windows提供了机构化异常处理机制，一般的编译器都是支持的，如下：

```c
__try{
    //可能出错的代码
}
__except(filter_value){
    //出错时要执行的代码
}
```

出现异常时，可根据filter_value的值来决定程序该如何执行，当filter_value的值为：

| filter_value                     | 含义                                 |
| -------------------------------- | ------------------------------------ |
| EXCEPTION_EXECUTE_HANDLER(1)     | 代码进入except块                     |
| EXCEPTION_CONTINUE_SEARCH(0)     | 不处理异常，由上一层调用函数处理     |
| EXCEPTION_CONTINUE_EXECUTION(-1) | 回去继续执行错误处的代码(基本用不到) |

### 常用的内核内存函数

对内核的使用，主要就是：申请，设置，拷贝以及释放。

| C语言                        | 内核中                    |
| ---------------------------- | ------------------------- |
| malloc                       | ExAllocatePool            |
| memset(内核可用)             | RtlFillMemory             |
| memcpy(内核可用)(非重叠复制) | RtlCopyMemory(非重叠复制) |
| memmove(内核可用)(重叠复制)  | RtlMoveMemory(重叠复制)   |
| free                         | ExFreePool                |

ExAllocatePool已被淘汰，取而代之的是[ExAllocatePoolWithTag](https://docs.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/nf-wdm-exallocatepoolwithtag)

后又在 Windows 10 版本 2004 中被弃用，并已被[ExAllocatePool2](https://docs.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/nf-wdm-exallocatepool2)取代

### 内核字符串种类

- CHAR（char）
- WCHAR（wchar_t）
- ANSI_STRING
- UNICODE_STRING

```c
//ANSI_STRING字符串：
typedef struct _STRING
{
    USHORT Length;//当前字符串的长度
    USHORT MaximumLength;//最大长度
    PCHAR Buffer;//指针
}STRING;

//UNICODE_STRING字符串：
typedef struct _UNICODE_STRING
{
    USHORT Length;
    USHORT MaximumLength;
    PWCHAR Buffer;
}UNICODE_STRING;


UNICODE_STRING abc=RTL_CONSTANT_STRING(L"Hello World!");//要放在全局
DbgPrint("%wZ",&abc);
```

内核中字符串尽量用ANSI_STRING字符串和UNICODE_STRING字符串，通过这种方法能避免使用0结尾，读字符串的时候读Length个字符就可以了，防止访问0蓝屏。

内核字符串常用函数

| ANSI_STRING字符串            | UNICODE_STRING字符串                                    | 含义           |
| ---------------------------- | ------------------------------------------------------- | -------------- |
| RtlInitAnsiString            | RtlInitUnicodeString                                    | 创建字符串     |
| RtlCopyString                | RtlCopyUnicodeString                                    | 复制字符串     |
| RtlCpmpareString             | RtlCpmpareUnicodeString                                 | 比较字符串     |
| RtlAnsiStringToUnicodeString | RtlUnicodeStringToAnsiString                            | 字符串转换     |
| RtlAppendStringToString      | RtlAppendUnicodeToString/RtlAppendUnicodeStringToString | 字符串拼接     |
| RtlFreeAnsiString            | RtlFreeUnicodeString                                    | 销毁字符串     |
| RtlUpperString               | RtlUpcaseUnicodeString                                  | 转换成大写     |
| RtlEqualString               | RtlEqualUnicodeString                                   | 字符串是否相等 |

DbgPrint,KdPrint打印字符串：

| 符号    | 格式说明符              | 类型          |
| ------- | ----------------------- | ------------- |
| %c, %lc | ANSI字符                | char          |
| %C, %wc | 宽字符                  | wchar_t       |
| %d, %i  | 十进制有符号整数        | int           |
| %D      | 十进制_int64            | _int64        |
| %L      | 十六进制的LARGE_INTEGER | LARGE_INTEGER |
| %s, %ls | NULL终止的ANSI字符串    | char*         |
| %S, %ws | NULL终止的宽字符串      | wchar_t*      |
| %Z      | ANSI_STRING字符串       |               |
| %wZ     | UNICODE_STRING字符串    |               |
| %u      | 十进制的ULONG           | ULONG         |
| %x      | 小写字符十六进制的ULONG | ULONG         |
| %X      | 大写字符十六进制的ULONG | ULONG         |
| %p      | 指针Pointer 32/64位     |               |

根据DDK上说明,Unicode格式(%C, %S, %lc, %ls, %wc, %ws, and %wZ)只能在 IRQL = PASSIVE_LEVEL时才能使用.

### 常用的其他内核API函数

| 函数                                | 含义                                                     |
| ----------------------------------- | -------------------------------------------------------- |
| ExAcquireFastMutex                  | 获取一个快速互斥体，用于多线程环境下的同步               |
| ExReleaseFastMutex                  | 快速释放一个互斥体                                       |
| ExRaiseStatus                       | 抛出一个异常，带有一个status值的，代码很深的地方直接报错 |
| ZwCreateFile                        | 创建文件                                                 |
| ZwWriteFile                         | 写入文件                                                 |
| ZwReadFile                          | 读取文件                                                 |
| ZwQueryDirctory                     | 查询目录文件                                             |
| ZwDeviceIoControlFile               | 创建设备io文件                                           |
| ZwCreateKey                         | 创建注册表的键                                           |
| ZwQueryValueKey                     | 创建注册表的键值                                         |
| IoCreateFile                        | 创建文件，比ZwCreateFile更加底层                         |
| IoCreateDevice                      | 创建设备                                                 |
| IoCallDriver                        | 发送一个请求，实际上这个函数可能是由IofCallDriver别名    |
| IoCompleteRequest                   | 完成请求                                                 |
| IoCopyCurrentIrpStackLocationToNext | 将当前IRP请求的栈空间拷贝到下一个栈空间                  |
| IoSkipCurrentIrpStackLocationToNext | 跳过当前IRP栈空间                                        |
| IoGetCurrentIrpStackLocation        | 获得当前IRP栈空间指针                                    |

### IRQL中断请求级别

[IRQL理解]: https://blog.csdn.net/qwq1503/article/details/123732814

处理器在一个IRQL上执行线程代码。IRQL是帮助决定线程如何被中断的。**在同一处理器上，线程只能被更高级别IRQL的线程能中断**。每个处理器都有自己的中断IRQL。我们经常遇见的有四种IRQL级别。“Passive”, “APC”, “Dispatch” and “DIRQL”.

“DriverEntry”将会在PASSIVE_LEVEL被调用。

![image-20211109133128464](https://raw.githubusercontent.com/che77a38/blogImage/main/image-20211109133128464.png)

- **PASSIVE_LEVEL**   无中断

  IRQL最低级别,没有被屏蔽的中断，在这个级别上，线程执行用户模式，可以访问分页内存。DriverEntry、DriverUnload、DispatchRead…等分发函数都处于这个级别,我们创建的线程也是这个级别

- **APC_LEVEL**   软中断

  在这个级别上,只有APC级别的中断被屏蔽，可以访问分页内存。当有APC发生时，处理器提升到APC级别，这样，就屏蔽掉其它APC，为了和APC执行 一些同步，驱动程序可以手动提升到这个级别。比如，如果提升到这个级别，APC就不能调用。在这个级别，APC被禁止了，导致禁止一些I/O完成APC， 所以有一些API不能调用。

  **阻止响应任何APC，而且线程不能被挂起（suspend），为什么不能被挂起？因为操作系统实现线程挂起的方式，就是递交 APC**

- **DISPATCH_LEVEL**  软中断

  这个级别，DPC(延迟过程) 和更低的中断被屏蔽，不能访问分页内存，所有的被访问的内存不能分页。因为只能处理分页内存，所以在这个级别，能够访问的Api大大减少。

- **DIRQL (Device IRQL)**  硬中断

  通常处于高层次的驱动程序不会使用这个IRQL等级，在这个等级上所有的中断都会被忽略。这是IRQL的最高等级。通常使用这个来判断设备的优先级。
  一般的，更高级的驱动在这个级别上不处理IRQL，但是几乎所有的中断被屏蔽，这实际上是IRQL的一个范围，这是一个决定某个驱动有更高的优先级的方法。

### 驱动内核框架

#### Windows的驱动开发模型变迁

- vxd(windows98)
- kdm(windows98~windows2000)
- wdm(再之后)
- wdf(进一步原有基础上封装了一套更简单的API，现在)

#### 内核编程的主要调用源：

1. 入口函数 DriverEntry 和 卸载函数 DriverUnload（单线程环境）
2. 各种分发函数（多线程环境，可以和DriverUnload并发，无法和DriverEntry并发）
3. 处理请求时设置的完成函数（多线程环境）
4. 其他回调函数  ndis（网络相关）（多线程环境）

#### 函数的多线程安全性

1. 可能运行于多线程环境的函数，必须是多线程安全的，只运行于单线程环境的函数，则不需要多线程安全性
2. 如果函数A的所有调用源只运行于同一单线程环境，则函数A也是只运行在单线程环境下。
3. 如果函数A的其中一个调用源是可能运行在多线程环境下的，或者多个调用源可能运行于不同的可并发的多线程环境，而且调用路径上没有采取多线程序列化成单线程的强制措施，则函数A也是可能运行在多线程环境的。
4. 如果函数A所有可能运行于多线程环境的调用路径上，都有多线程序列化成单线程的强制措施，则函数A是运行于单线程环境的。
5. 只使用函数内部资源的，完全不使用全局变量，静态变量或其他全局性资源的函数是多线程安全的。
6. 如果对某个全局变量或者静态变量的所有访问都被强制的同步手段限制为同一时刻只有一个线程访问，则即使使用了这些全局变量或静态变量，对函数的多线程安全性也是没有影响的。

| 调用源                   | 运行环境 | 原因                                                         |
| ------------------------ | -------- | ------------------------------------------------------------ |
| DriverEntry/DriverUnload | 单线程   | 这两个函数由系统集成的单一线程调用。不会出现多线程同时调用的情况 |
| 各种分发函数             | 多线程   | 没有任何文档保证分发函数是不会被多线程同时调用的。此外，分发函数是不会和DriverEntry并发，但可能和DriverUnload并发 |
| 完成函数                 | 多线程   | 完成函数随时可能被未知的线程调用                             |
| 各种NDIS回调函数         | 多线程   | 同上                                                         |
|                          |          |                                                              |

#### 代码的中断级

win32编程是没有中断级这个概念的，但是在内核编程中是有中断级的概念的，我们的程序好像是并发的，但其实是有优先级的，就是中断级

- passive
- dispatch

规则：

1. 如果在调用路径上没有特殊情况（导致中断级的提高或降低），则一个函数执行时的中断和它的调用源的中断级相同
2. 如果在调用路径上有获取自旋锁，则中断级随之升高；如果调用路径上有释放自旋锁，则中断级随之下降。

| 调用源                   | 一般运行中断级 |
| ------------------------ | -------------- |
| DriverUnload/DriverEntry | Passive级      |
| 各种分发函数             | Passive级      |
| 完成函数                 | Dispatch级     |
| 各种NDIS回调函数         | Dispatch级     |

#### WDK中出现的特殊代码

##### IN和OUT

```c
#define IN
#define OUT
```

空定义，只是作为提示函数中参数时输入还是输出的

##### [#pragma alloc_text](https://blog.csdn.net/analogous_love/article/details/47274559)

有时，驱动程序的某些部分必须驻留内存而另一些可以被分页，这就需要一种能控制代码和数据是否分页的方法。通过指导编译器的段分配可以实现这个目的。

#pragma alloc_text：**把驱动程序的单独例程放到特定段中。**

使编译器把代码放到特定段的传统方法是使用alloc_text编译指示。但不是每种编译器都支持这个编译指示

```c
#pragma alloc_text(PAGE, a)
#pragma alloc_text(PAGE, b)
//表示函数a和b都运行在分页内存中，就是有可能被交换到分页池中，程序中一些高等级，例如dispatch 级别的代码当然不能运行在分页内存，这样往往出现BSOD
//如果没有上述指令，则默认位于PAGELK这个节，即不会把内存放入硬盘。
```

**\#pragma alloc_text使用注意**

1. 该编译指示必须跟在函数声明后面而不能在前面。你可以把驱动程序中的所有函数集中到一个头文件中，并在包含该头文件的源文件中，在#include语句的后面使用alloc_text。
2. 该编译指示仅能用于有C连接形式的函数。即，它不能用于类成员函数或 C++源文件中未用extern “C”声明的函数。

```c
#pragma alloc_text(INIT,DriverEntry)//某些代码在驱动程序完成初始化后不再需要，可以直接把它插入到INIT段。
```









## 内核空间与内核模块

### 内核空间

![image-20210826200041917](https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210826200052881.png)

**内核空间中的地址在各个进程中都是一样的。**

内核模块定义全局变量：可在不同进程中查看

**windbg进入对应进程的进程空间**：

```c
kd>!process 0 0//罗列出来的进程信息枚举，将PROCESS后接的地址放入下面的命令
kd>.process XXXXXXXX(上面获取到的地址)
//转到了对应进程的内存空间
```

### 内核模块

![image-20210826200052881](https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210826200052881.png)

1. 硬件种类繁多，不可能做一个兼容所有硬件的内核，所以，微软提供规定的接口格式，让硬件驱动人员按照规定的格式编写“驱动程序”。
2. 这些驱动程序每一个都是一个模块，称为“内核模块”，都可以加载到内核中，**都遵守PE结构**。本质上讲，任意一个.sys文件与内核文件没有区别。

#### DRIVER_OBJECT结构体

定义在wdm.h中。

每个内核模块都有一个对应的结构体，来描述这个模块在内核中的各种信息：位置、大小、名称等等。

```c
kd> dt _DRIVER_OBJECT
nt!_DRIVER_OBJECT
   +0x000 Type             : Int2B//类型
   +0x002 Size             : Int2B//大小
   +0x004 DeviceObject     : Ptr32 _DEVICE_OBJECT//设备对象，这里实际上是一个设备对象的链表的开始。因为DeviceObject中有相关链表信息
   +0x008 Flags            : Uint4B
   +0x00c DriverStart      : Ptr32 Void//驱动被加载到什么地方了，即内核模块的起始地址
   +0x010 DriverSize       : Uint4B//该驱动内核模块的大小
   +0x014 DriverSection    : Ptr32 Void//指向当前驱动的_LDR_DATA_TABLE_ENTRY结构体的指针
   +0x018 DriverExtension  : Ptr32 _DRIVER_EXTENSION//热拔插会用到的相关信息
   +0x01c DriverName       : _UNICODE_STRING//驱动的名字
   +0x024 HardwareDatabase : Ptr32 _UNICODE_STRING//注册表
   +0x028 FastIoDispatch   : Ptr32 _FAST_IO_DISPATCH//某派遣函数，快速IO分发函数
   +0x02c DriverInit       : Ptr32     long //初始化派遣函数
   +0x030 DriverStartIo    : Ptr32     void //某派遣函数
   +0x034 DriverUnload     : Ptr32     void //驱动卸载派遣函数
   +0x038 MajorFunction    : [28] Ptr32     long //包含28个派遣函数地址
       //0编号的IRP对应的派遣函数的地址就存在MajorFunction[0]的位置。
////////////////////////////////_DRIVER_EXTENSION///////////////////////////
ntdll!_DRIVER_EXTENSION//热拔插驱动相关的
   +0x000 DriverObject     : Ptr32 _DRIVER_OBJECT
   +0x004 AddDevice        : Ptr32     long 
   +0x008 Count            : Uint4B
   +0x00c ServiceKeyName   : _UNICODE_STRING
   +0x014 ClientDriverExtension : Ptr32 _IO_CLIENT_EXTENSION
   +0x018 FsFilterCallbacks : Ptr32 _FS_FILTER_CALLBACKS
```

![image-20210828154104796](https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210828154104796.png)

![image-20210828154124934](https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210828154124934.png)

Type，Flags，MajorFunction等等，因为他们是固有特征，尽可能隐藏特征，因为内核文件已经加载到内存里了，所以即使修改了，也不影响正常运行。

#### _LDR_DATA_TABLE_ENTRY结构体

完整版定义见WRK的_KLDR_DATA_TABLE_ENTRY

```c
//所有内核模块的双向链表
kd> dt _LDR_DATA_TABLE_ENTRY
nt!_LDR_DATA_TABLE_ENTRY
   +0x000 InLoadOrderLinks : _LIST_ENTRY//初始化顺序双向链表
   +0x008 InMemoryOrderLinks : _LIST_ENTRY
   +0x010 InInitializationOrderLinks : _LIST_ENTRY
   +0x018 DllBase          : Ptr32 Void//内核模块的起始地址
   +0x01c EntryPoint       : Ptr32 Void
   +0x020 SizeOfImage      : Uint4B//内核模块的大小
   +0x024 FullDllName      : _UNICODE_STRING//完整的内核模块名，实际上就是全路径
   +0x02c BaseDllName      : _UNICODE_STRING//只有内核模块名，如：xxx.sys
   +0x034 Flags            : Uint4B
   +0x038 LoadCount        : Uint2B
   +0x03a TlsIndex         : Uint2B
   +0x03c HashLinks        : _LIST_ENTRY
   +0x03c SectionPointer   : Ptr32 Void
   +0x040 CheckSum         : Uint4B//校验和
   +0x044 TimeDateStamp    : Uint4B
   +0x044 LoadedImports    : Ptr32 Void
   +0x048 EntryPointActivationContext : Ptr32 Void
   +0x04c PatchInformation : Ptr32 Void
     
     //wrk版符号结构
     #ifdef _WIN64
    typedef struct _KLDR_DATA_TABLE_ENTRY
    {
        LIST_ENTRY listEntry;
        ULONG64 __Undefined1;
        ULONG64 __Undefined2;
        ULONG64 __Undefined3;
        ULONG64 NonPagedDebugInfo;
        ULONG64 DllBase;
        ULONG64 EntryPoint;
        ULONG SizeOfImage;
        UNICODE_STRING path;
        UNICODE_STRING name;
        ULONG   Flags;
        USHORT  LoadCount;
        USHORT  __Undefined5;
        ULONG64 __Undefined6;
        ULONG   CheckSum;
        ULONG   __padding1;
        ULONG   TimeDateStamp;
        ULONG   __padding2;
    } KLDR_DATA_TABLE_ENTRY, *PKLDR_DATA_TABLE_ENTRY;
#else
    typedef struct _KLDR_DATA_TABLE_ENTRY
    {
        LIST_ENTRY listEntry;
        ULONG unknown1;
        ULONG unknown2;
        ULONG unknown3;
        ULONG unknown4;
        ULONG unknown5;
        ULONG unknown6;
        ULONG unknown7;
        UNICODE_STRING path;
        UNICODE_STRING name;
        ULONG   Flags;
    } KLDR_DATA_TABLE_ENTRY, *PKLDR_DATA_TABLE_ENTRY;
#endif

//通杀x32和x64版
//这里字节对齐要采用默认，不要按1对齐，这样才符合32位和64位结构体
typedef struct _LDR_DATA_TABLE_ENTRY
{
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	LIST_ENTRY InInitializationOrderLinks;
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	ULONG Flags;
	USHORT LoadCount;
	USHORT TlsIndex;
	union
	{
		LIST_ENTRY HashLinks;
		struct
		{
			PVOID SectionPointer;
			ULONG CheckSum;
		};
	};
	union
	{
		struct
		{
			ULONG TimeDateStamp;
		};
		struct
		{
			PVOID LoadedImports;
		};
	};
	struct _ACTIVATION_CONTEXT * EntryPointActivationContext;
	PVOID PatchInformation;
} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;
```

![image-20210828154334924](https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210828154334924.png)

\_DRIVER_OBJECT结构可以通过DriverSection找到记录所有内核模块简单信息的双向链表，但双向链表没法找回\_DRIVER_OBJECT结构。因此即使是在双向链表中将目标驱动断链了，对于pchunter也依然能找到内核对象，原因是因为pchunter是通过特征码直接索引到\_DRIVER_OBJECT结构来遍历所有内核模块，而非通过该双向链表

### 遍历内核模块作业

**驱动对象遍历，模块隐藏（断链）**

```c
#include <ntddk.h>

unsigned int OldDriverSection= 0;//保存原DriverSection

//卸载函数
VOID DriverUnload(PDRIVER_OBJECT driver)
{
	//恢复原链和原DriverSection
	if (OldDriverSection != 0)
	{
		//恢复原DriverSection
		unsigned int DriverSectionAddr = (unsigned int)driver + 0x014;
		*(unsigned int*)DriverSectionAddr = OldDriverSection;
		//恢复原链
		unsigned int currentIndex = *(unsigned int*)DriverSectionAddr;
		unsigned int lastIndex = *(unsigned int*)(currentIndex + 0x4);
		*(unsigned int*)lastIndex = currentIndex;
		*(unsigned int*)(*(unsigned int*)(currentIndex)+0x4) = currentIndex;

	}
	DbgPrint("停止运行了\n");
}

//内核对象链表遍历
VOID forEachDriverChain(PDRIVER_OBJECT pdriver)
{
	unsigned int DriverSection = (unsigned int)pdriver + 0x014;
	//DbgPrint("DriverSection:%X\n", DriverSection);
	unsigned int beginIndex = *(unsigned int*)DriverSection;
	unsigned int currentIndex = beginIndex;
	DbgPrint("----------------------------------------\r\n");
	do
	{
		PUNICODE_STRING BaseDllName = (PUNICODE_STRING)(currentIndex + 0x02c);
		DbgPrint("%wZ\r\n", BaseDllName);
		currentIndex=*(unsigned int*)currentIndex;

	} while (currentIndex != beginIndex);
	DbgPrint("----------------------------------------\r\n");
}
//内核对象链表断链
VOID BreakDriverChain(PDRIVER_OBJECT pdriver)
{
	unsigned int DriverSectionAddr = (unsigned int)pdriver + 0x014;
	//DbgPrint("DriverSection:%X\n", DriverSection);
	unsigned int currentIndex = *(unsigned int*)DriverSectionAddr;
	unsigned int lastIndex = *(unsigned int*)(currentIndex +0x4);
	*(unsigned int*)lastIndex = *(unsigned int*)(currentIndex);
	*(unsigned int*)(*(unsigned int*)(currentIndex)+0x4) = lastIndex;
	//修正原PDRIVER_OBJECT中的DriverSection指向前一个链表
	OldDriverSection = *(unsigned int*)DriverSectionAddr;
	*(unsigned int*)DriverSectionAddr = lastIndex;
}

//入口函数，相当于main函数
NTSTATUS DriverEntry(PDRIVER_OBJECT pdriver, PUNICODE_STRING pReg)
{
	//驱动程序的入口
	DbgPrint("hello world!\n");
	DbgPrint("pdriver:%wZ\r\n",pReg);
	DbgPrint("pReg:%p\r\n",pdriver);
	DbgPrint("hello world!\n");
	DbgPrint("===============断链前==============\n");
	forEachDriverChain(pdriver);
	BreakDriverChain(pdriver);
	DbgPrint("===============断链后==============\n");
	forEachDriverChain(pdriver);

	//设置一个卸载函数，用于退出
	pdriver->DriverUnload = DriverUnload;
	return STATUS_SUCCESS;
}
```

打印如下：

```c
hello world!
pdriver:\REGISTRY\MACHINE\SYSTEM\ControlSet002\Services\HelloWorld
pReg:81DDCD18
hello world!
===============断链前==============
----------------------------------------
HelloWorld.sys
(null)
ntoskrnl.exe
hal.dll
kdcom.dll
BOOTVID.dll
ACPI.sys
WMILIB.SYS
pci.sys
isapnp.sys
compbatt.sys
BATTC.SYS
intelide.sys
PCIIDEX.SYS
MountMgr.sys
ftdisk.sys
dmload.sys
dmio.sys
PartMgr.sys
vmci.sys
VolSnap.sys
vsock.sys
atapi.sys
disk.sys
CLASSPNP.SYS
fltMgr.sys
sr.sys
KSecDD.sys
Ntfs.sys
NDIS.sys
Mup.sys
agp440.sys
i8042prt.sys
kbdclass.sys
vmmouse.sys
mouclass.sys
serial.sys
serenum.sys
imapi.sys
cdrom.sys
redbook.sys
ks.sys
vmx_svga.sys
VIDEOPRT.SYS
usbuhci.sys
USBPORT.SYS
vmxnet.sys
es1371mp.sys
portcls.sys
drmk.sys
usbehci.sys
CmBatt.sys
intelppm.sys
fsvga.sys
audstub.sys
rasl2tp.sys
ndistapi.sys
ndiswan.sys
raspppoe.sys
raspptp.sys
TDI.SYS
psched.sys
msgpc.sys
ptilink.sys
raspti.sys
rdpdr.sys
termdd.sys
swenum.sys
update.sys
mssmbios.sys
NDProxy.SYS
usbhub.sys
USBD.SYS
gameenum.sys
Fs_Rec.SYS
Null.SYS
Beep.SYS
vga.sys
mnmdd.SYS
RDPCDD.sys
Msfs.SYS
Npfs.SYS
rasacd.sys
ipsec.sys
tcpip.sys
netbt.sys
ws2ifsl.sys
afd.sys
netbios.sys
vmhgfs.sys
rdbss.sys
mrxsmb.sys
Fips.SYS
ipnat.sys
Cdfs.SYS
wanarp.sys
usbccgp.sys
hidusb.sys
HIDCLASS.SYS
HIDPARSE.SYS
BTHUSB.sys
bthport.sys
mouhid.sys
vmusbmouse.sys
dump_atapi.sys
dump_WMILIB.SYS
win32k.sys
Dxapi.sys
watchdog.sys
dxg.sys
dxgthk.sys
vmx_fb.dll
rfcomm.sys
BthEnum.sys
bthpan.sys
ndisuio.sys
wdmaud.sys
sysaudio.sys
mrxdav.sys
vmmemctl.sys
srv.sys
HTTP.sys
Dbgv.sys
----------------------------------------
===============断链后==============
----------------------------------------
Dbgv.sys
(null)
ntoskrnl.exe
hal.dll
kdcom.dll
BOOTVID.dll
ACPI.sys
WMILIB.SYS
pci.sys
isapnp.sys
compbatt.sys
BATTC.SYS
intelide.sys
PCIIDEX.SYS
MountMgr.sys
ftdisk.sys
dmload.sys
dmio.sys
PartMgr.sys
vmci.sys
VolSnap.sys
vsock.sys
atapi.sys
disk.sys
CLASSPNP.SYS
fltMgr.sys
sr.sys
KSecDD.sys
Ntfs.sys
NDIS.sys
Mup.sys
agp440.sys
i8042prt.sys
kbdclass.sys
vmmouse.sys
mouclass.sys
serial.sys
serenum.sys
imapi.sys
cdrom.sys
redbook.sys
ks.sys
vmx_svga.sys
VIDEOPRT.SYS
usbuhci.sys
USBPORT.SYS
vmxnet.sys
es1371mp.sys
portcls.sys
drmk.sys
usbehci.sys
CmBatt.sys
intelppm.sys
fsvga.sys
audstub.sys
rasl2tp.sys
ndistapi.sys
ndiswan.sys
raspppoe.sys
raspptp.sys
TDI.SYS
psched.sys
msgpc.sys
ptilink.sys
raspti.sys
rdpdr.sys
termdd.sys
swenum.sys
update.sys
mssmbios.sys
NDProxy.SYS
usbhub.sys
USBD.SYS
gameenum.sys
Fs_Rec.SYS
Null.SYS
Beep.SYS
vga.sys
mnmdd.SYS
RDPCDD.sys
Msfs.SYS
Npfs.SYS
rasacd.sys
ipsec.sys
tcpip.sys
netbt.sys
ws2ifsl.sys
afd.sys
netbios.sys
vmhgfs.sys
rdbss.sys
mrxsmb.sys
Fips.SYS
ipnat.sys
Cdfs.SYS
wanarp.sys
usbccgp.sys
hidusb.sys
HIDCLASS.SYS
HIDPARSE.SYS
BTHUSB.sys
bthport.sys
mouhid.sys
vmusbmouse.sys
dump_atapi.sys
dump_WMILIB.SYS
win32k.sys
Dxapi.sys
watchdog.sys
dxg.sys
dxgthk.sys
vmx_fb.dll
rfcomm.sys
BthEnum.sys
bthpan.sys
ndisuio.sys
wdmaud.sys
sysaudio.sys
mrxdav.sys
vmmemctl.sys
srv.sys
HTTP.sys
----------------------------------------
停止运行了
```

由上面打印可知HelloWorld.sys成功被隐藏，但pchunter依然可以查找到我们的驱动

**真隐藏（pchunter无法找到）**

```c
#include <ntddk.h>
typedef struct _LDR_DATA_TABLE_ENTRY {
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	LIST_ENTRY InInitializationOrderLinks;
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	ULONG Flags;
	USHORT LoadCount;
	USHORT TlsIndex;
	union {
		LIST_ENTRY HashLinks;
		struct {
			PVOID SectionPointer;
			ULONG CheckSum;
		};
	};
	union {
		struct {
			ULONG TimeDateStamp;
		};
		struct {
			PVOID LoadedImports;
		};
	};
	struct _ACTIVATION_CONTEXT * EntryPointActivationContext;

	PVOID PatchInformation;

} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;

HANDLE hThread;

VOID DriverUnload(PDRIVER_OBJECT pDriver)
{
	KdPrint(("卸载的了"));
}

VOID threadRun(_In_ PVOID StartContext)
{
	KdPrint(("开始执行1\n"));
	LARGE_INTEGER times;
	times.QuadPart = -30 * 1000 * 1000;
	KeDelayExecutionThread(KernelMode, FALSE, &times);
	PDRIVER_OBJECT pDriver = (PDRIVER_OBJECT)StartContext;
	//抹除特征
    pDriver->DriverSize = 0;
	pDriver->DriverSection = NULL;
	pDriver->DriverExtension = NULL;
	pDriver->DriverStart = NULL;
	pDriver->DriverInit = NULL;
	pDriver->FastIoDispatch = NULL;
	pDriver->DriverStartIo = NULL;
	ZwClose(hThread);
	KdPrint(("执行结束1\n"));
}


NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pReg)
{
	KdPrint(("驱动被加载\n"));
	PLDR_DATA_TABLE_ENTRY pList = (PLDR_DATA_TABLE_ENTRY)pDriver->DriverSection;
	PLDR_DATA_TABLE_ENTRY pCur = pList;
	pList = pList->InLoadOrderLinks.Flink;

	pList->InLoadOrderLinks.Blink = pCur->InLoadOrderLinks.Blink;
	pCur->InLoadOrderLinks.Flink = pList;

	pDriver->DriverUnload = DriverUnload;

	PsCreateSystemThread(&hThread, GENERIC_ALL, NULL, NULL, NULL, threadRun, pDriver);

	return STATUS_SUCCESS;
}
```

上面代码可让pchunter也找不到驱动，但此代码只做了抹特征隐藏，却并未恢复特征或手动调用函数卸载驱动。停止驱动的时候会因为信息缺失直接蓝屏。需要一个时间点做恢复特征（不可以在DriverUnload中，因为是还没到该函数就蓝屏了）。

64位下不能直接断链(PG的原因)

MiProcessLoaderEntry，第一个参数是当前链表，第二个参数false表示卸载，true表示插入。该函数模块从链表上移除了，但没有释放内存。

64位用这个函数不会触发PG，不会蓝屏。PG可以理解成就是保护全局变量bu不被直接修改。

**KdPrint和DbgPrint的区别：**

```c
#if DBG
	#define KdPrint(_x_) DbgPrint _x_
#else
	#define KdPrint(_x_)//把KdPrint(_x_)宏替换成什么也没有
//即如下两句在debug模式下含义相同:
KdPrint(("hello World!\n"));
DbgPrint("hello World!\n");
//但在release模式下，KdPrint不会打印。
```

### 驱动键鼠过滤

IoAttachDevice绑定设备

```c
NTSTATUS
IoAttachDevice(
IN PDEVICE_OBJECT SourceDevice,//生成的设备对象
IN PUNICODE_STRING TargetDevice,//目标串口设备名称
OUT PDEVICE_OBJECT *AttachedDevice//【返回被绑定设备指针】的指针
);
```

使用：

```c
UNICODE_STRING com_name = RLT_CONSTANT_STRING(L"\\Device\\Serial0");
NTSTATUS status = IoAttachDevice(com_filter_device,&com_device_name,&attached_device);
```

## 驱动开发中的链表

**常用函数**

- IsListEmpty          判断链表是否为空  
- InitializeListHead  初始化双向链表头  
- InsertHeadList      插入链表头部   
- InsertTailList         插入链表尾部   
- RemoveHeadList  移除头部节点   
- RemoveTailList     移除尾部节点  
- RemoveEntryList  移除当前节点   

[详细说法]: https://blog.csdn.net/m0_46125480/article/details/120587783

链表在驱动中需要处理同步,因为链表涉及到指针操作,一不小心就可能导致蓝屏.

因此驱动开发中数组可以不需要同步处理(多线程写入同一个位置一样可能有问题,但概率没那么大),但链表必须做[同步处理](#完美过掉对象保护钩子)

## 零环与三环通信(常规方式)

常规方式表示微软提供的正常通信方式，还有非常规通信。正常通信方式受到一定限制。

**设备对象**

我们在开发窗口程序的时候，消息被封装成一个结构体：MSG，**在内核开发时，消息被封装成另外一个结构体：IRP**（I/O Request Package输入输出请求包）

在窗口程序中，能够接受消息的只能是窗口对象。在内核中，能够接收IRP消息的只能是设备对象

![image-20210827111116147](https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210827111116147.png)

- **驱动对象**（DRIVER_OBJECT）生成多个设备对象，
- **设备对象**（DEVICE_OBJECT）可以是硬件（硬盘等），也可以是软件，比如NTFS文件系统。它们都属于设备对象。

![image-20210829163134914](https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210829163134914.png)

![sdsad](https://raw.githubusercontent.com/che77a38/blogImage/main/sdsad.jpeg)

### [创建设备对象](https://docs.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/nf-wdm-iocreatedevice)

#### 设备对象结构

```c
typedef struct DECLSPEC_ALIGN(MEMORY_ALLOCATION_ALIGNMENT) _DEVICE_OBJECT
{
    CSHORT Type;//类型
    USHORT Size;//大小
    LONG ReferenceCount;//引用计数
    /*指向驱动程序中驱动对象的指针*/
    struct _DRIVER_OBJECT *DriverObject;//设备所属的驱动对象
    /*指向下一个设备对象的指针*/
    struct _DEVICE_OBJECT *NextDevice;//下一个设备对象，在一个驱动对象中有N个设备，这些设备用这个指针连接起来作为一个单向的链表
    struct _DEVICE_OBJECT *AttachedDevice;
    /*当前IRP结构*/
    struct _IRP *CurrentIrp;
    PIO_TIMER Timer;
    /*设备对象的特性标志*/
    ULONG Flags;
    ULONG Characteristics;
    _volatile PVPB Vpb;
    /*指向设备扩展对象的指针*/
    PVOID DeviceExtension;
    /*指明设备类型*/
    DEVICE_TYPE DeviceType;
    /*堆栈的最小层数*/
    CCHAR StackSize;//IRP栈的大小,用于存放参数的
    union {
        LIST_ENTRY ListEntry;
        WAIT_CONTEXT_BLOCK Wcb;
    } Queue;
    /*内存对齐*/
    ULONG AlignmentRequirement;
    KDEVICE_QUEUE DeviceQueue;
    KDPC Dpc;
    /*
    *下列成员用于支持文件系统的互斥操作
    *以便对文件系统处理线程使用设备的计数保持跟踪
    */
    ULONG ActiveThreadCount;
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    KEVENT DeviceLock;
 
    USHORT SectorSize;
    USHORT Spare1;
 
    struct _DEVOBJ_EXTENSION  *DeviceObjectExtension;
    PVOID  Reserved;
 
} DEVICE_OBJECT;
typedef struct _DEVICE_OBJECT *PDEVICE_OBJECT;
```

#### IoCreateDevice

```c
NTSTATUS IoCreateDevice(
  PDRIVER_OBJECT  DriverObject,//驱动对象指针
  ULONG           DeviceExtensionSize,//指定要为设备对象的设备扩展分配的驱动程序确定的字节数；设备扩展内存的大小，你可以在这申请一块非分页内存，只要设备还在，就都可以用，可以用它代替全局变量。
  PUNICODE_STRING DeviceName,//可选地指向一个缓冲区，该缓冲区包含一个以空字符结尾的 Unicode 字符串，用于命名设备对象。该字符串必须是完整路径名。
  DEVICE_TYPE     DeviceType,//一般用FILE_DEVICE_UNKNOWN，#define FILE_DEVICE_UNKNOWN             0x00000022
  ULONG           DeviceCharacteristics,//基本就是填FILE_DEVICE_SECURE_OPEN
  BOOLEAN         Exclusive,//TRUE代表设备是独占的，FALSE代表该设备是共享的；独享可以防止前面的驱动拦截后面的驱动的派遣函数处理
  PDEVICE_OBJECT  *DeviceObject//【out】二级指针，目的是返回设备对象指针
);

//给某个设备发送IRP请求
NTSTATUS MyDispath(PDEVICE_OBJECT device,PIRP irp);
```

实例：

```c
//创建设备名称
UNICODE_STRING Devicename;
RtlInitUnicodeString(&Devicename,L"\\Device\\MyDevice");//\\Device尽量不要改，为了让驱动文件同一个树结构下，方便统一。该名字是给零环用的，三环通过这个名字是找不到该设备对象的。

//设备对象指针，用于接受
PDEVICE_OBJECT pDeviceObj = NULL;
//创建设备
status = IoCreateDevice(
pDriver,				//当前设备所属的驱动对象
0,
&Devicename,			//设备对象的名称
FILE_DEVICE_UNKNOWN,//不知道什么类型
FILE_DEVICE_SECURE_OPEN,
TRUE,
&pDeviceObj			//【out】设备对象指针
);
if(!NT_SUCCESS(status))//NT_SUCCESS,微软提供的，实际上就是判断status是否大于等于0
{
    DbgPrint("创建设备失败!\n");
    return status;
}
```

### 删除设备对象

```c
IoDeleteDevice(pDeviceObj);//删除设备
```

### 设置交互数据的方式

```c
//如果前面创建设备对象成功，就设置交互数据的方式
pDeviceObj->Flags |= DO_BUFFERED_IO;
```

- **缓冲区方式读写(DO_BUFFERED_IO)**：操作系统将应用程序提供缓冲区的数据复制到内核模式下的地址中。(效率不高，适合小规模数据)
- **直接方式读写(DO_DIRECT_IO)**：操作系统会将用户模式下的缓冲区锁住。然后操作系统将这段缓冲区在内核模式地址再次映射一遍。这样，用户模式的缓冲区和内核模式的缓冲区指向的是同一区域的物理内存。缺点就是要单独占用物理页面。(适合大规模数据，比较浪费物理页)
- **其他方式读写**(在调用IoCreateDevice创建设备后对pDevObj->Flags即不设置DO_BUFFERED_IO，也不设置DO_DIRECT_IO，此时就是其他方式)：在使用其他方式读写设备时，派遣函数直接读写应用程序提供的缓冲区地址。在驱动程序中，直接操作应用程序的缓冲区地址是很危险的**(这种方法须要注意的是ReadFile可能把空指针地址或者非法地址传递给驱动程序，因此驱动程序使用用户模式地址前须要检查是否可读或者可写)**。**只有驱动程序与应用程序运行在相同线程上下文的情况下，才能使用这种方式**。

```c
//读写方式不一样,则读写的位置不一样
if(DeviceObject->Flags&DO_BUFFERED_IO)//缓冲区方式读写
	{
		KdPrint(("Flags:DO_BUFFER_IO\n"));
		pBuffer=Irp->AssociatedIrp.SystemBuffer;
	}
	else if(DeviceObject->Flags&DO_DIRECT_IO)//直接方式读写
	{
		KdPrint(("Flags:DO_DIRECT_IO\n"));
		pBuffer=MmGetSystemAddressForMdl(Irp->MdlAddress);
	}
	else//其他方式读写
	{
		KdPrint(("Flags:Neither\n"));
		pBuffer=Irp->UserBuffer;
	}
//ReadFile和WriteFile方式通信的内核缓冲区长度在IrpStack->Parameters.Read.Length和IrpStack->Parameters.Write.Length中
```

### 创建与卸载符号链接

就是设置一个名字，让三环可以通过这个名字找到设备对象来操作他。

```c
//创建符号链接名称
UNICODE_STRING SymbolicLinkName;
RtlInitUnicodeString(&SymbolicLinkName,L"\\??\\MyTestDriver");
//两个问号代表根目录
//Ring3用CreateFile打开设备时，用"\\\\.\\MyTestDriver"(实际上就是地址要\\.\开始，但是要转义，所以为\\\\.\\)

//创建符号链接
status = IoCreateSymbolicLink(&SymbolicLinkName,&Devicename);
if(status!=STATUS_SUCCESS)
{
    DbgPrint("创建符号链接失败!\n");
    IoDeleteDevice(pDeviceObj);//删除设备
    return status;
}

//卸载符号链接
IoDeleteSymbolicLink(&SymbolicLinkName);
```

特别说明：

1. 设备名称的作用是给内核对象用的，如果要在Ring3访问，必须要有符号链接，其实就是一个别名，没有这个别名，在Ring3不可见
2. **内核模式下，符号链接是以"\??\"开头的，如C盘就是"\??\C:"**
3. **用户模式下，则是以"\\\\.\\\"开头的，如C盘就是"\\\\.\\C:"**

创建设备对象并设置符号链接

```c
#define _LINK_NAME L"\\??\\MyDriver"
NTSTATUS CreateDevice(PDRIVER_OBJECT driver)
{
    NTSTATUS status;
    UNICODE_STRING MyDriver;//驱动字符串
    PDEVICE_OBJECT device = NULL;//用于存放设备对象
    RtlInitUnicodeString(&MyDriver, L"\\DEVICE\\MyDriver");
    status = IoCreateDevice(driver,
        sizeof(driver->DriverExtension),
        &MyDriver,
        FILE_DEVICE_UNKNOWN,
        FILE_DEVICE_SECURE_OPEN,
        FALSE,
        &device
    );
    if (status==STATUS_SUCCESS)
    {
        KdPrint(("zeroko14:kernel:驱动设备对象创建成功\n"));
        UNICODE_STRING uzSymbolName;
        RtlInitUnicodeString(&uzSymbolName, _LINK_NAME);
        status = IoCreateSymbolicLink(&uzSymbolName, &MyDriver);
        if (status == STATUS_SUCCESS)
        {
            KdPrint(("zeroko14:kernel:创建符号链接%wZ成功\n", &uzSymbolName));
        }
        else
        {
            KdPrint(("zeroko14:kernel:创建符号链接%wZ失败  status:%X\n", &uzSymbolName,status));
        }
    }
    else
    {
        KdPrint(("zeroko14:kernel:驱动对象创建失败,删除设备\n"));
        IoDeleteDevice(device);
    }
}
```

### IRP与派遣函数

![image-20210827114410752](https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210827114410752.png)

驱动程序与I/O管理器通信，使用的是IRP，即**I/O请求包**。

#### IRP类型

1. 当应用层通过CreateFile，ReadFile，WriteFile，CloseHandle等函数打开，从设备读取数据，向设备写入数据，关闭设备的时候，会使操作系统分别产生出IRP_MJ_CREATE,IRP_MJ_READ,IRP_MJ_WRITE,IRP_MJ_CLOSE等不同的IRP。

2. 其他类型的IRP

   | IRP类型                                                      | 来源                                |
   | ------------------------------------------------------------ | ----------------------------------- |
   | **IRP_MJ_DEVICE_CONTROL**                                    | DeviceIoControl函数会产生此IRP      |
   | IRP_MJ_POWER                                                 | 在操作系统处理电源信息时，产生此IRP |
   | IRP_MJ_SHUTDOWN                                              | 关闭系统前会产生此IRP               |
   | IRP_MJ_CREATE                                                | 生成请求 CreateFile                 |
   | IRP_MJ_QUERY_INFORMATION                                     | 查询请求                            |
   | IRP_MJ_CLOSE                                                 | 关闭请求 CloseHandle                |
   | IRP_MJ_SET_INFORMATION                                       | 设置请求                            |
   | IRP_MJ_READ                                                  | 从设备得到数据 ReadFile             |
   | IRP_MJ_WRITE                                                 | 传送数据到设备 WriteFile            |
   | [还有很多。。。](https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/irp-major-function-codes) | 。。。                              |

   IRP_MJ_DEVICE_CONTROL是我们用的最多的一种方式，比较灵活。可以拿到三环传过来的消息码，自己设定怎么处理(通过消息码确定)。

3. 每个IRP都对应一个输入输出

##### IRP结构

```c
typedef struct _IRP {
	PMDL              MdlAddress;//是一个MDL的指针，当内核层和用户层采用共享内存的结构传递数据的时候，这个MDL就代表共享的内存信息（共享物理内存，通过MDL映射）。这个成员生效的标记为：DO_DIRECT_IO, METHOD_IN_DIRECT 或者METHOD_OUT_DIRECT.
	ULONG             Flags;
	union {
		struct _IRP*   MasterIrp;
		PVOID          SystemBuffer;
	} AssociatedIrp;
	IO_STATUS_BLOCK   IoStatus;
	KPROCESSOR_MODE   RequestorMode;
	BOOLEAN           PendingReturned;
	BOOLEAN           Cancel;
	KIRQL             CancelIrql;
	PDRIVER_CANCEL    CancelRoutine;
	PVOID             UserBuffer;
	union {
		struct {
			union {
				KDEVICE_QUEUE_ENTRY DeviceQueueEntry;
				struct {
					PVOID    DriverContext[4];
				};
			};
			PETHREAD     Thread;
			LIST_ENTRY   ListEntry;
		} Overlay;
	} Tail;
} IRP, *PIRP;

kd> dt nt!_IRP
   +0x000 Type             : Int2B
   +0x002 Size             : Uint2B
   +0x004 MdlAddress       : Ptr32 _MDL
   +0x008 Flags            : Uint4B
   +0x00c AssociatedIrp    : <unnamed-tag>
   +0x010 ThreadListEntry  : _LIST_ENTRY
   +0x018 IoStatus         : _IO_STATUS_BLOCK
   +0x020 RequestorMode    : Char
   +0x021 PendingReturned  : UChar
   +0x022 StackCount       : Char
   +0x023 CurrentLocation  : Char
   +0x024 Cancel           : UChar
   +0x025 CancelIrql       : UChar
   +0x026 ApcEnvironment   : Char
   +0x027 AllocationFlags  : UChar
   +0x028 UserIosb         : Ptr32 _IO_STATUS_BLOCK
   +0x02c UserEvent        : Ptr32 _KEVENT
   +0x030 Overlay          : <unnamed-tag>
   +0x038 CancelRoutine    : Ptr32     void 
   +0x03c UserBuffer       : Ptr32 Void
   +0x040 Tail             : <unnamed-tag>
```

每个IRP对应一个`IO_STACK_LOCATION结构`,通过下面的函数可以获取到此IRP对应的`IO_STACK_LOCATION结构`

`IoGetCurrentIrpStackLocation`返回一个指向IO_STACK_LOCATION结构的指针，该结构包含驱动程序的 I/O 堆栈位置

![IRP](https://raw.githubusercontent.com/che77a38/blogImage2/main/202204241910209.jpeg)

**上图为DeviceIoControl方式读写**,如果是用ReadFile/WriteFile方式读写,应参考[设置交互数据的方式](#设置交互数据的方式)

注意information设置不正确.案例中,仅传一个整形数据时候,设置到99,导致蓝屏(吃了大亏)

##### IO_STACK_LOCATION结构

[IO_STACK_LOCATION结构详解]: https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ns-wdm-_io_stack_location?redirectedfrom=MSDN

#### 派遣函数

##### 派遣函数在哪里注册呢？

```c
kd> dt _DRIVER_OBJECT
nt!_DRIVER_OBJECT
   +0x000 Type             : Int2B
   +0x002 Size             : Int2B
   +0x004 DeviceObject     : Ptr32 _DEVICE_OBJECT
   +0x008 Flags            : Uint4B
   +0x00c DriverStart      : Ptr32 Void
   +0x010 DriverSize       : Uint4B
....
   +0x030 DriverStartIo    : Ptr32     void 
   +0x034 DriverUnload     : Ptr32     void 		//卸载函数
   +0x038 MajorFunction    : [28] Ptr32     long 	//派遣函数
   //0编号的IRP对应的派遣函数的地址就存在MajorFunction[0]的位置。
```

0编号的IRP对应的派遣函数的地址就存在MajorFunction[0]的位置。

##### 注册派遣函数

```c
NTSTATUS DriverEntry(PDRIVER_OBJECT pDriverObject, PUNICODE_STRING pReg)  
{  
    //设置卸载函数   
    pDriverObject->DriverUnload = 卸载函数;  
  
    //设置派遣函数   
    pDriverObject->MajorFunction[IRP_MJ_CREATE] 	= 派遣函数1; //一般都处理 对应用户层CreateFile
    pDriverObject->MajorFunction[IRP_MJ_CLOSE] 	= 派遣函数2;  //一般都处理  对应用户层CloseHandle
    pDriverObject->MajorFunction[IRP_MJ_WRITE] 	= 派遣函数3;  
    pDriverObject->MajorFunction[IRP_MJ_READ] 	= 派遣函数4;  
    pDriverObject->MajorFunction[IRP_MJ_CLEANUP] 	= 派遣函数5;  
    pDriverObject->MajorFunction[IRP_MJ_SET_INFORMATION] 	= 派遣函数6;  
    pDriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] 	= 派遣函数7;  //一般都处理   对应用户层DeviceIoControl
    pDriverObject->MajorFunction[IRP_MJ_SHUTDOWN] 		= 派遣函数8;  
    pDriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] 	= 派遣函数9;
} 
//派遣函数1~9可以全都一个函数  NTSTATUS 函数名(PDEVICE_OBJECT pDevObj, PIRP pIrp) ,在函数内做区分处理
```

IRP_MJ_MAXIMUM_FUNCTION  派遣函数的最大值宏

#### 派遣函数的格式

```c
NTSTATUS MyDispatchFunction(PDEVICE_OBJECT pDevObj, PIRP pIrp)//PIRP为IRP报文数据结构指针
{
	//处理自己的业务...

	//设置返回状态,返回状态如果不设置，Ring3返回的是失败
	pIrp->IoStatus.Status = STATUS_SUCCESS;	//  三环getlasterror()得到的就是这个值
	pIrp->IoStatus.Information = 0;		//  返回给3环多少个字节的数据 没有填0
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);//表示调用方已完成所有I/O请求处理操作，并将给定的 IRP 返回给 I/O 管理器。将IRP往下派发
	return STATUS_SUCCESS;
} 


//一个派遣函数处理所有情况:
NTSTATUS DeviceIrpCtl(PDEVICE_OBJECT pDevObj, PIRP pIrp)
{
  PIO_STACK_LOCATION irpStackL;
  ULONG CtlCode;
  ULONG InputBuffLength;
  irpStackL=IoGetCurrentIrpStackLocation(pIrp);//获取应用层传来的参数
  switch(irpStackL->MajorFunction)
  {
    case IRP_MJ_DEVICE_CONTROL:
      DbgPrint("用户调用了DeviceIoControl!\n");
      break;
    case IRP_MJ_CREATE:
      DbgPrint("用户调用了CreateFile!\n");
      break;
      case IRP_MJ_CLOSE;
      DbgPrint("用户调用了CloseHandle!\n");
      break;
  }
  pIrp->IoStatus.Status = STATUS_SUCCESS;
  pIrp->IoStatus.Information = 4;//返回给DeviceIoControl中的倒数第二个参数lpButesReturned
  IoCompleteRequest(pIrp,IO_NO_INCREMENT);//调用方已完成所有I/O请求处理操作,并且不增加优先级
  return STATUS_SUCCESS;//返回成功
}
```

[IRP结构详解](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ns-wdm-_irp)

##### **IRP_MJ_DEVICE_CONTROL的派遣函数**

###### CTL操作码

IRP_MJ_DEVICE_CONTROL用到的操作码是个复合数据，微软提供了一个[宏CTL_CODE](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/d4drvif/nf-d4drvif-ctl_code)来组合这个复合数据，如下定义方式：

```c
//该宏的定义
#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \
    ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) \
)
//是个宏，按照函数讲解每个参数
void CTL_CODE(
   DeviceType,//驱动种类，一般是FILE_DEVICE_UNKNOWN
   Function,//提供一个数值，标识其独特性
   Method,//交互数据的方式(要与前面设定的一致)，METHOD_BUFFERED或METHOD_IN_DIRECT或METHOD_OUT_DIRECT或METHOD_NEITHER
   Access//权限，FILE_ANY_ACCESS表示全部权限，或FILE_READ_ACCESS或FILE_WRITE_ACCESS
);
//定义实例：
#define CODE_READ CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define CODE_WRITE CTL_CODE(FILE_DEVICE_UNKNOWN,0x900,METHOD_BUFFERED,FILE_ANY_ACCESS)
```

###### IRP_MJ_DEVICE_CONTROL的派遣函数编写

```c
NTSTATUS ControlCallBack(PDEVICE_OBJECT pDevObj, PIRP pIrp)
{
    PIO_STACK_LOCATION psl = IoGetCurrentIrpStackLocation(pIrp);//获取应用层传来的参数
    ULONG code = psl->Parameters.DeviceIoControl.IoControlCode;//获取派遣过来的CTL操作码
    PVOID systemBuf = pIrp->AssociatedIrp.SystemBuffer;//获取缓存地址(输入输出都靠这个地址)
    ULONG inLen = psl->Parameters.DeviceIoControl.InputBufferLength;//获取输入长度
    ULONG outLen = psl->Parameters.DeviceIoControl.OutputBufferLength;//获取输出长度
    //根据不同的CTL操作码做不同的处理
    switch(code)
    {
        case CODE_READ://注意是以三环视角来看其含义，三环想要读
            //执行想做的事情
            break;
        case CODE_WRITE:
            break;

    }
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);//表示调用方已完成所有I/O请求处理操作，并将给定的 IRP 返回给 I/O 管理器。将IRP往下派发
	return STATUS_SUCCESS;
}
```

- [IoGetCurrentIrpStackLocation详解](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-iogetcurrentirpstacklocation)
- [PIO_STACK_LOCATION结构详解](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ns-wdm-_io_stack_location)

###### 三环写法

**[DeviceIoControl](https://docs.microsoft.com/zh-cn/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol)函数结构**

```c
BOOL DeviceIoControl(
  HANDLE       hDevice,//设备句柄
  DWORD        dwIoControlCode,//CTL操作码
  LPVOID       lpInBuffer,//三环给零环的数据的地址
  DWORD        nInBufferSize,//三环给零环多少字节数据
  LPVOID       lpOutBuffer,//零环给三环的数据到的地址
  DWORD        nOutBufferSize,//零环给三环多少字节数据
  LPDWORD      lpBytesReturned,//零环给三环实际多少字节数据
  LPOVERLAPPED lpOverlapped//异步相关，一般填NULL，略
);
```

内核通信，需要头文件`#include <WinIoCtl.h>`

并且**WinIoCtl.h必须定义到Windows.h的后面**

```c
#define CODE_READ CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define CODE_WRITE CTL_CODE(FILE_DEVICE_UNKNOWN,0x900,METHOD_BUFFERED,FILE_ANY_ACCESS)//基本上都是用METHOD_BUFFERED这种方式

//打开设备
BOOLEAN openDevice(HANDLE *handle)
{
    HANDLE _handle = CreateFileA("\\\\.\\MyTestDriver",GENERIC_READ|GENERIC_WRITE,0,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);//打开设备对象句柄
    *handle=_handle;
	return (int)_handle>0;
}

//关闭设备
CloseHandle(handle);

//发送IRP_MJ_DEVICE_CONTROL
BOOLEAN sendCode(HANDLE hDevice,DWORD code,PVOID inData,ULONG Inlen,PVOID outData,ULONG outLen,LPDWORD resultLen)
{
    return DeviceIoControl(hDevice,code,inData,Inlen,outData,outLen,resultLen,NULL);
}
```

**0-3环常规通信框架：**

```c
#include <ntddk.h>

#define CODE_CHANGE CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define CODE_RESUME CTL_CODE(FILE_DEVICE_UNKNOWN,0x900,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define CODE_READ CTL_CODE(FILE_DEVICE_UNKNOWN,0x1000,METHOD_BUFFERED,FILE_ANY_ACCESS)
UNICODE_STRING SymbolicLinkName;

//卸载函数
VOID DriverUnload(PDRIVER_OBJECT driver)
{
	DbgPrint("停止运行了\n");
}

NTSTATUS MyCreateDispatchFunction(PDEVICE_OBJECT pDevObj, PIRP pIrp)//PIRP为IRP报文数据结构指针
{
	//处理自己的业务...
	DbgPrint("三环连接成功\n");
	//设置返回状态,返回状态如果不设置，Ring3返回的是失败
	pIrp->IoStatus.Status = STATUS_SUCCESS;	//  三环getlasterror()得到的就是这个值
	pIrp->IoStatus.Information = 0;		//  返回给3环多少个字节的数据 没有填0
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);//表示调用方已完成所有I/O请求处理操作，并将给定的 IRP 返回给 I/O 管理器。将IRP往下派发
	return STATUS_SUCCESS;
}
NTSTATUS MyCloseDispatchFunction(PDEVICE_OBJECT pDevObj, PIRP pIrp)//PIRP为IRP报文数据结构指针
{
	//处理自己的业务...
	DbgPrint("三环断开连接成功\n");
	//设置返回状态,返回状态如果不设置，Ring3返回的是失败
	pIrp->IoStatus.Status = STATUS_SUCCESS;	//  三环getlasterror()得到的就是这个值
	pIrp->IoStatus.Information = 0;		//  返回给3环多少个字节的数据 没有填0
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);//表示调用方已完成所有I/O请求处理操作，并将给定的 IRP 返回给 I/O 管理器。将IRP往下派发
	return STATUS_SUCCESS;
}


ULONG current = 0;

NTSTATUS ControlCallBack(PDEVICE_OBJECT pDevObj, PIRP pIrp)
{
	PIO_STACK_LOCATION psl = IoGetCurrentIrpStackLocation(pIrp);
	ULONG code = psl->Parameters.DeviceIoControl.IoControlCode;//获取派遣过来的CTL操作码
	PVOID systemBuf = pIrp->AssociatedIrp.SystemBuffer;//获取缓存地址(输入输出都靠这个地址)
	ULONG inLen = psl->Parameters.DeviceIoControl.InputBufferLength;//获取输入长度
	ULONG outLen = psl->Parameters.DeviceIoControl.OutputBufferLength;//获取输出长度
	//根据不同的CTL操作码做不同的处理
	switch (code)
	{
	case CODE_CHANGE://注意是以三环视角来看其含义，初始化

		break;
	case CODE_RESUME://三环想要反初始化
		
		break;

	case CODE_READ:

		break;
	}
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);//表示调用方已完成所有I/O请求处理操作，并将给定的 IRP 返回给 I/O 管理器。将IRP往下派发
	return STATUS_SUCCESS;
}


//入口函数，相当于main函数
NTSTATUS DriverEntry(PDRIVER_OBJECT pdriver, PUNICODE_STRING pReg)
{
	//设置一个卸载函数，用于退出
	pdriver->DriverUnload = DriverUnload;
	//创建设备名称
	UNICODE_STRING Devicename;
	RtlInitUnicodeString(&Devicename, L"\\Device\\MyDevice");
	//设备对象指针，用于接受
	PDEVICE_OBJECT pDeviceObj = NULL;
	//创建设备
	NTSTATUS status = IoCreateDevice(pdriver,0,&Devicename,FILE_DEVICE_UNKNOWN,FILE_DEVICE_SECURE_OPEN,TRUE,&pDeviceObj	);
	if (!NT_SUCCESS(status))//NT_SUCCESS,微软提供的，实际上就是判断status是否大于等于0
	{
		DbgPrint("创建设备失败!\n");
		return status;
	}
	//如果前面创建设备对象成功，就设置交互数据的方式
	pDeviceObj->Flags |= DO_BUFFERED_IO;
	//创建符号链接名称
	RtlInitUnicodeString(&SymbolicLinkName, L"\\??\\MyTestDriver");
	status = IoCreateSymbolicLink(&SymbolicLinkName, &Devicename);
	if (!NT_SUCCESS(status))
	{
		DbgPrint("创建符号链接失败!\n");
		IoDeleteDevice(pDeviceObj);//删除设备
		return status;
	}
	//设置派遣函数   
	pdriver->MajorFunction[IRP_MJ_CREATE] = MyCreateDispatchFunction;
	pdriver->MajorFunction[IRP_MJ_CLOSE] = MyCloseDispatchFunction;
	pdriver->MajorFunction[IRP_MJ_DEVICE_CONTROL] = ControlCallBack;
	return STATUS_SUCCESS;
}
```

### IRP_MJ_DEVICE_CONTROL交互数据实验

#### R0代码：

```c
#include <ntddk.h>

#define CODE_READ CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define CODE_WRITE CTL_CODE(FILE_DEVICE_UNKNOWN,0x900,METHOD_BUFFERED,FILE_ANY_ACCESS)
UNICODE_STRING SymbolicLinkName;

//卸载函数
VOID DriverUnload(PDRIVER_OBJECT driver)
{
	//删除设备对象
	if (driver->DeviceObject)
	{
		IoDeleteDevice(driver->DeviceObject);//设备对象已挂载在driver中
	}
	if (SymbolicLinkName.Length>0)
	{
		IoDeleteSymbolicLink(&SymbolicLinkName);
	}
	DbgPrint("停止运行了\n");
}

NTSTATUS MyCreateDispatchFunction(PDEVICE_OBJECT pDevObj, PIRP pIrp)//PIRP为IRP报文数据结构指针
{
	//处理自己的业务...
	DbgPrint("三环连接成功\n");
	//设置返回状态,返回状态如果不设置，Ring3返回的是失败
	pIrp->IoStatus.Status = STATUS_SUCCESS;	//  三环getlasterror()得到的就是这个值
	pIrp->IoStatus.Information = 0;		//  返回给3环多少个字节的数据 没有填0
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);//表示调用方已完成所有I/O请求处理操作，并将给定的 IRP 返回给 I/O 管理器。将IRP往下派发
	return STATUS_SUCCESS;
}
NTSTATUS MyCloseDispatchFunction(PDEVICE_OBJECT pDevObj, PIRP pIrp)//PIRP为IRP报文数据结构指针
{
	//处理自己的业务...
	DbgPrint("三环断开连接成功\n");
	//设置返回状态,返回状态如果不设置，Ring3返回的是失败
	pIrp->IoStatus.Status = STATUS_SUCCESS;	//  三环getlasterror()得到的就是这个值
	pIrp->IoStatus.Information = 0;		//  返回给3环多少个字节的数据 没有填0
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);//表示调用方已完成所有I/O请求处理操作，并将给定的 IRP 返回给 I/O 管理器。将IRP往下派发
	return STATUS_SUCCESS;
}

NTSTATUS ControlCallBack(PDEVICE_OBJECT pDevObj, PIRP pIrp)
{
	PIO_STACK_LOCATION psl = IoGetCurrentIrpStackLocation(pIrp);
	ULONG code = psl->Parameters.DeviceIoControl.IoControlCode;//获取派遣过来的CTL操作码
	PVOID systemBuf = pIrp->AssociatedIrp.SystemBuffer;//获取缓存地址(输入输出都靠这个地址)
	ULONG inLen = psl->Parameters.DeviceIoControl.InputBufferLength;//获取输入长度
	ULONG outLen = psl->Parameters.DeviceIoControl.OutputBufferLength;//获取输出长度
	//根据不同的CTL操作码做不同的处理
	switch (code)
	{
	case CODE_READ://注意是以三环视角来看其含义，三环想要读
		//把1234567传给三环读
		memcpy(systemBuf, "1234567", sizeof("1234567"));
		//把零环写入的长度传给三环
		pIrp->IoStatus.Information = sizeof("1234567");
		break;
	case CODE_WRITE:
		//打印三环写入的信息
		DbgPrint("派遣函数:三环传入的信息：%s\n",/*(char*)*/systemBuf);
		break;
	}
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);//表示调用方已完成所有I/O请求处理操作，并且不增加优先级,并将给定的 IRP 返回给 I/O 管理器。将IRP往下派发
	return STATUS_SUCCESS;
}

//入口函数，相当于main函数
NTSTATUS DriverEntry(PDRIVER_OBJECT pdriver, PUNICODE_STRING pReg)
{
	//设置一个卸载函数，用于退出
	pdriver->DriverUnload = DriverUnload;
	//创建设备名称
	UNICODE_STRING Devicename;
	RtlInitUnicodeString(&Devicename, L"\\Device\\MyDevice");
	//设备对象指针，用于接受
	PDEVICE_OBJECT pDeviceObj = NULL;
	//创建设备
	NTSTATUS status = IoCreateDevice(pdriver,0,&Devicename,FILE_DEVICE_UNKNOWN,FILE_DEVICE_SECURE_OPEN,TRUE,&pDeviceObj	);
	if (!NT_SUCCESS(status))//NT_SUCCESS,微软提供的，实际上就是判断status是否大于等于0
	{
		DbgPrint("创建设备失败!\n");
		return status;
	}
	//如果前面创建设备对象成功，就设置交互数据的方式.其实此代码可以不设置,因为项目未使用ReadFile和WriteFile来通信,而是使用DeviceIoControl.
	pDeviceObj->Flags |= DO_BUFFERED_IO;
	//创建符号链接名称
	RtlInitUnicodeString(&SymbolicLinkName, L"\\??\\MyTestDriver");
	status = IoCreateSymbolicLink(&SymbolicLinkName, &Devicename);
	if (!NT_SUCCESS(status))
	{
		DbgPrint("创建符号链接失败!\n");
		IoDeleteDevice(pDeviceObj);//删除设备
		return status;
	}
	//设置派遣函数   
	pdriver->MajorFunction[IRP_MJ_CREATE] = MyCreateDispatchFunction;
	pdriver->MajorFunction[IRP_MJ_CLOSE] = MyCloseDispatchFunction;
	pdriver->MajorFunction[IRP_MJ_DEVICE_CONTROL] = ControlCallBack;
	return STATUS_SUCCESS;
}
```

#### R3代码：

```c
#include"stdafx.h"
#include <stdio.h>
#include <stdlib.h>
#include <Windows.h>
#include <WinIoCtl.h>


#define CODE_READ CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define CODE_WRITE CTL_CODE(FILE_DEVICE_UNKNOWN,0x900,METHOD_BUFFERED,FILE_ANY_ACCESS)

//打开设备
BOOLEAN openDevice(HANDLE *handle)
{
	HANDLE _handle = CreateFileA("\\\\.\\MyTestDriver", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);//打开设备对象句柄
	*handle = _handle;
	return (int)_handle > 0;
}


//发送IRP_MJ_DEVICE_CONTROL
BOOLEAN sendCode(HANDLE hDevice, DWORD code, PVOID inData, ULONG Inlen, PVOID outData, ULONG outLen, LPDWORD resultLen)
{
	return DeviceIoControl(hDevice, code, inData, Inlen, outData, outLen, resultLen, NULL);
}

void main()
{
	HANDLE hDevice;
	char buf[30] = { 0 };
	DWORD realReaded = 0;
	if (!openDevice(&hDevice))
	{
		printf("打开设备对象失败!\r\n");
		return;
	}
    //写数据给R0！！！！！！！！！！！！！！！！！！！！！！
	memcpy(buf,"i am R3",sizeof("i am R3"));
	sendCode(hDevice, CODE_WRITE, buf, 30, NULL, 0, &realReaded);
    
	//读R0数据	！！！！！！！！！！！！！！！！！！！！！！
	//sendCode(hDevice, CODE_READ, NULL, 0, buf, 30, &realReaded);
	
	printf("读到：%s\r\n", buf);
	CloseHandle(hDevice);
	system("pause");
}
```

写数据结果如图：

![image-20210829212010210](https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210829212010210.png)

将`写数据给R0`代码注释，放开`读R0数据`的代码，结果如图：

![image-20210829212159461](https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210829212159461.png)

## 驱动加载

需要头文件 `#include <winsvc.h>`

**加载驱动过程**

1. 用OpenSCManager打开服务控制管理器
2. 用CreateService创建对应服务
3. 如果驱动服务已经创建过,则用OpenService打开服务
4. 用StartService加载启动驱动服务
5. 用QueryServiceStatus获得服务的当前状态
6. 用ControlService停止,暂停,恢复服务
7. 用DeleteService卸载驱动
8. 清理工作,用CloseServiceHandle关闭释放句柄

### 驱动注册/安装

#### [OpenSCManagerA函数](https://docs.microsoft.com/zh-cn/windows/win32/api/winsvc/nf-winsvc-openscmanagera)

```c
//如果函数成功，则返回值是指定服务控制管理器数据库的句柄。
//如果函数失败，则返回值为 NULL。
//打开服务管理器
SC_HANDLE OpenSCManagerA(
  LPCSTR lpMachineName,//目标计算机的名称。如果指针为 NULL 或指向空字符串，则该函数连接到本地计算机上的服务控制管理器。
  LPCSTR lpDatabaseName,//服务控制管理器数据库的名称。此参数应设置为 SERVICES_ACTIVE_DATABASE。如果为 NULL，则打开活动数据库 SERVICES_ACTIVE_DATABASE 数据库。
  DWORD  dwDesiredAccess//权限，SC_MANAGER_ALL_ACCESS 表示所有权限;还有诸如创建服务,枚举服务权限等
);
```

#### 创建服务[CreateServiceA函数](https://docs.microsoft.com/zh-cn/windows/win32/api/winsvc/nf-winsvc-createservicea)

```c
//如果函数成功，则返回值是服务的句柄。
//如果函数失败，则返回值为 NULL。
SC_HANDLE CreateServiceA(
  SC_HANDLE hSCManager,//服务管理器句柄,一般从OpenSCManagerA的返回值获取
  LPCSTR    lpServiceName,//这个服务在注册表中的名字(名字唯一性);服务唯一标识,一般取的是可执行文件名(不带后缀)
  LPCSTR    lpDisplayName,//注册表驱动程序的DisplayName值,显示给别人看的名字(名字不唯一)
  DWORD     dwDesiredAccess,//服务的访问权限，SERVICE_ALL_ACCESS表示所有权限
  DWORD     dwServiceType,//创建什么类型的服务，SERVICE_KERNEL_DRIVER表示内核驱动服务,即表示加载的服务是驱动程序
  DWORD     dwStartType,//创建服务的启动类型，SERVICE_BOOT_START开机启动服务，SERVICE_AUTO_START自动启动服务，SERVICE_DEMAND_START按需启动，即当进程调用StartService函数时由服务控制管理器启动的服务 。
  DWORD     dwErrorControl,//注册表服务的ErrorControl(错误控制).如果此服务无法启动，则错误的严重性以及采取的措施。SERVICE_ERROR_NORMAL表示启动程序在事件日志中记录错误，但继续启动操作。
  LPCSTR    lpBinaryPathName,//服务对应的可执行程序的全路径  如驱动服务:C:\\222\1.sys)。可用GetFullPathNameA函数以及可执行文件名获取
    //后面都为NULL就可以了
  LPCSTR    lpLoadOrderGroup,//服务所在分组的名字
  LPDWORD   lpdwTagId,//分组内该服务的启动顺序
  LPCSTR    lpDependencies,//需要依赖其他服务名的列表
  LPCSTR    lpServiceStartName,//加上下面哪个,表示以什么身份启动服务
  LPCSTR    lpPassword
);
```

`CreateServiceA`函数执行后,`GetLastError()`如果为`ERROR_SERVICE_EXISTS`,则调用`OpenService`

**关闭服务句柄**

```c
CloseServiceHandle(serviceHandle);//serviceHandle为某服务的句柄
//也可以直接调用CloseHandle(serviceHandle);CloseServiceHandle还是会调用CloseHandle
```

### 驱动启动

#### 打开服务[OpenServiceA函数](https://docs.microsoft.com/zh-cn/windows/win32/api/winsvc/nf-winsvc-openservicea)

```c
SC_HANDLE OpenServiceA(
  SC_HANDLE hSCManager,//服务管理器句柄
  LPCSTR    lpServiceName,//服务名字，根据这个服务名字找服务
  DWORD     dwDesiredAccess//权限，SC_MANAGER_ALL_ACCESS表示所有权限
);
```

#### 开始服务[StartServiceA函数](https://docs.microsoft.com/en-us/windows/win32/api/winsvc/nf-winsvc-startservicea)

```c
//如果函数成功，则返回值非零。
//如果函数失败，则返回值为零。
BOOL StartServiceA(
  SC_HANDLE hService,//服务句柄
    //服务函数的参数相关
  DWORD     dwNumServiceArgs,//参数字节数，没有填0
  LPCSTR    *lpServiceArgVectors//如果没有参数，则此参数可以为 NULL。
);
```

### 停止驱动

OpenServiceA后ControlService

#### 控制服务[ControlService函数](https://docs.microsoft.com/en-us/windows/win32/api/winsvc/nf-winsvc-controlservice)

```c
//如果函数成功，则返回值非零。
//如果函数失败，则返回值为零。
BOOL ControlService(
  SC_HANDLE        hService,//服务句柄
  DWORD            dwControl,//控制码,可以停止/暂停/恢复服务，其中SERVICE_CONTROL_STOP表示停止服务的控制码
  LPSERVICE_STATUS lpServiceStatus//指向SERVICE_STATUS结构的指针，该结构接收最新的服务状态信息。返回的信息反映了服务向服务控制管理器报告的最新状态。仅当GetLastError返回以下错误代码之一时，服务控制管理器才会填充结构 ：NO_ERROR、ERROR_INVALID_SERVICE_CONTROL、 ERROR_SERVICE_CANNOT_ACCEPT_CTRL或 ERROR_SERVICE_NOT_ACTIVE。否则，不填充结构。
);
```

### 卸载驱动

OpenServiceA后DeleteService

删除服务[DeleteService函数](https://docs.microsoft.com/en-us/windows/win32/api/winsvc/nf-winsvc-deleteservice)

```c
//如果函数成功，则返回值非零。
//如果函数失败，则返回值为零。
BOOL DeleteService(
  SC_HANDLE hService//服务句柄
);
```

### 驱动加载/启动/停止/卸载案例

```c
//加载驱动封装函数   lpszDriverName是不带后缀的服务唯一标识,sysFileName是带后缀的驱动文件名
BOOL loadDriver(const char* lpszDriverName, const char* sysFileName)
{
	//用于保存.sys的全路径名,得到完整的驱动路径
	char szDriverImagePath[256] = { 0 };
	GetFullPathNameA(sysFileName, 256, szDriverImagePath, NULL);
	myOutPutDebug("加载驱动的全路径名:%s", szDriverImagePath);
	SC_HANDLE hMgr = OpenSCManagerA(NULL, NULL, SC_MANAGER_ALL_ACCESS);
	if (!hMgr)
	{
		myOutPutDebug("OpenSCManagerA失败 ERROR:%d",GetLastError());
		return FALSE;
	}
	SC_HANDLE hSve = CreateServiceA(hMgr,
		lpszDriverName,//驱动在注册表中的名字
		lpszDriverName,//注册表驱动程序的DisplayName值
		SERVICE_START,//加载驱动程序的访问权限,SERVICE_START 或者 SERVICE_ALL_ACCESS
		SERVICE_KERNEL_DRIVER,//表示加载的服务是驱动程序
		SERVICE_DEMAND_START,//注册表驱动程序的Start值   //指定当进程调用StartService函数时由服务控制管理器启动的服务
		SERVICE_ERROR_NORMAL,//SERVICE_ERROR_IGNORE   //注册表驱动程序的ErrorControl值
		szDriverImagePath,//szDriverImagePath注册表驱动程序的全路径  如:C:\\222\1.sys   通过GetFullPathNameA函数获取
		NULL,//GroupOrder HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\GroupOrderList
		NULL,
		NULL,
		NULL,
		NULL
	);
	if (GetLastError()==ERROR_SERVICE_EXISTS)//服务已经存在的话,直接打开该服务
	{
		hSve = OpenServiceA(hMgr, lpszDriverName, SERVICE_START);
	}
	myOutPutDebug("hSve:%X", hSve);
	//此处可以用QueryServiceStatus查询服务状态,来判断是否需要开启服务,可能已经开启了
	bool bRet = StartServiceW(hSve, NULL, NULL);
	if (hSve)
	{
		CloseServiceHandle(hSve);
	}
	if(hMgr)
	{
		CloseServiceHandle(hMgr);
	}
	return bRet;
}

//卸载驱动封装函数
BOOL UnloadDriver(const char* lpszDriverName)
{
	BOOL bRet = FALSE;
	SC_HANDLE hMgr = NULL;//SCM管理器的句柄
	SC_HANDLE hSve = NULL;//NT驱动程序的服务句柄
	SERVICE_STATUS SveSta;
	hMgr = OpenSCManagerA(NULL, NULL, SC_MANAGER_ALL_ACCESS);
	if (!hMgr)
	{
		//打开失败
		bRet = FALSE;
		goto BeforeLeave;
	}
	hSve = OpenServiceA(hMgr, lpszDriverName, SERVICE_ALL_ACCESS);
	if (!hSve)
	{
		//打开失败
		bRet = FALSE;
		goto BeforeLeave;
	}
	//停止服务
	if (!ControlService(hSve,SERVICE_CONTROL_STOP,&SveSta))
	{
		// 停止失败
		bRet = FALSE;
		goto BeforeLeave;
	}
	//卸载服务
	if (!DeleteService(hSve))
	{
		// 卸载失败
		bRet = FALSE;
		goto BeforeLeave;
	}
	bRet = TRUE;
BeforeLeave:
	if (hSve)
	{
		CloseServiceHandle(hSve);
	}
	if (hMgr)
	{
		CloseServiceHandle(hMgr);
	}
	return bRet;
}

//上面两个函数依赖的调试信息输出函数
void myOutPutDebug(const char* pszFormat, ...)
{
	char szbufFormat[0x1000];
	char szbufFormat_withHead[0x1100] = "";
	va_list argList;
	va_start(argList, pszFormat);
	vsprintf_s(szbufFormat, pszFormat, argList);
	strcat_s(szbufFormat_withHead, "zeroko: ");// 加上本人输出头特征
	strcat_s(szbufFormat_withHead, szbufFormat);
	OutputDebugStringA(szbufFormat_withHead);// 编码转换
	va_end(argList);
}

//加载驱动函数使用案例:
loadDriver("driverKMDFempty", "driverKMDFempty.sys");
//卸载驱动函数使用案例:
UnloadDriver("driverKMDFempty");
```





## 全局监听API实验

1. 自己加载驱动
2. 写拷贝(段页知识)
3. R3,R0通信
4. 写HOOK
5. ShellCode

写拷贝的本来流程：

> 当写一个内存的时候先判断到内存是否可写(R/W位是否为1)，若为0，则表示该内存不可写，进入异常，在异常中通过VAD进一步判断其到底是写拷贝还是只读，如果是只读报错；如果是写拷贝，则映射一份新物理页将原内容复制过来，直接写到新物理页上，不影响原物理页。因此你HOOK了一个API只影响你自己的进程，而无法影响别的进程是因为别的进程还是原物理页，并未被你修改。解决方法很简单，找到要hook API的地方将R/W位置1，根本不进异常直接hook原物理页，规避触发写拷贝。

下面代码针对2-9-9-12分页，并且事后未复原。

### R0代码

```c
#include <ntddk.h>

#define CODE_CHANGE CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define CODE_RESUME CTL_CODE(FILE_DEVICE_UNKNOWN,0x900,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define CODE_READ CTL_CODE(FILE_DEVICE_UNKNOWN,0x1000,METHOD_BUFFERED,FILE_ANY_ACCESS)
UNICODE_STRING SymbolicLinkName;

//卸载函数
VOID DriverUnload(PDRIVER_OBJECT driver)
{
	//删除设备对象
	if (driver->DeviceObject)
	{
		IoDeleteDevice(driver->DeviceObject);//设备对象已挂载在driver中
	}
	if (SymbolicLinkName.Length>0)
	{
		IoDeleteSymbolicLink(&SymbolicLinkName);
	}
	DbgPrint("停止运行了\n");
}

NTSTATUS MyCreateDispatchFunction(PDEVICE_OBJECT pDevObj, PIRP pIrp)//PIRP为IRP报文数据结构指针
{
	//处理自己的业务...
	DbgPrint("三环连接成功\n");
	//设置返回状态,返回状态如果不设置，Ring3返回的是失败
	pIrp->IoStatus.Status = STATUS_SUCCESS;	//  三环getlasterror()得到的就是这个值
	pIrp->IoStatus.Information = 0;		//  返回给3环多少个字节的数据 没有填0
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);//表示调用方已完成所有I/O请求处理操作，并将给定的 IRP 返回给 I/O 管理器。将IRP往下派发
	return STATUS_SUCCESS;
}
NTSTATUS MyCloseDispatchFunction(PDEVICE_OBJECT pDevObj, PIRP pIrp)//PIRP为IRP报文数据结构指针
{
	//处理自己的业务...
	DbgPrint("三环断开连接成功\n");
	//设置返回状态,返回状态如果不设置，Ring3返回的是失败
	pIrp->IoStatus.Status = STATUS_SUCCESS;	//  三环getlasterror()得到的就是这个值
	pIrp->IoStatus.Information = 0;		//  返回给3环多少个字节的数据 没有填0
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);//表示调用方已完成所有I/O请求处理操作，并将给定的 IRP 返回给 I/O 管理器。将IRP往下派发
	return STATUS_SUCCESS;
}

ULONG param[5] = {0,0,0,0,0};
//ULONG getESP = 0;

//shellcode写到这里
void __declspec(naked) interruptGate()
{
	__asm
	{
		//通过ESP获取MessageBoxA的参数
		pushfd;
		pushad;
		mov eax, dword ptr ds : [esp + 0x24 + 0xC] ;//获取三环esp
		//mov dword ptr ds : [getESP] , eax;
		lea ecx, param;
		add eax, 4;//跳过call的返回地址
		//获取四个参数填入param全局数组中。
		mov ebx, dword ptr ds : [eax] ;
		mov dword ptr ds : [ecx] , ebx;
		mov ebx, dword ptr ds : [eax+4] ;
		mov dword ptr ds : [ecx+4] , ebx;
		mov ebx, dword ptr ds : [eax+8] ;
		mov dword ptr ds : [ecx+8] , ebx;
		mov ebx, dword ptr ds : [eax + 0xC] ;
		mov dword ptr ds : [ecx + 0xC] , ebx;
		add dword ptr ds : [ecx + 0x10],1
		popad;
		popfd;
		iretd;
		
	}
}

ULONG current = 0;//为了防止打印重复
NTSTATUS ControlCallBack(PDEVICE_OBJECT pDevObj, PIRP pIrp)
{
	PIO_STACK_LOCATION psl = IoGetCurrentIrpStackLocation(pIrp);
	ULONG code = psl->Parameters.DeviceIoControl.IoControlCode;//获取派遣过来的CTL操作码
	PVOID systemBuf = pIrp->AssociatedIrp.SystemBuffer;//获取缓存地址(输入输出都靠这个地址)
	ULONG inLen = psl->Parameters.DeviceIoControl.InputBufferLength;//获取输入长度
	ULONG outLen = psl->Parameters.DeviceIoControl.OutputBufferLength;//获取输出长度
	UCHAR IDT[6] = { 0 };
	UCHAR GDT[6] = { 0 };
	ULONG IDT_BASE = 0;
	ULONG GDT_BASE = 0;
	//根据不同的CTL操作码做不同的处理
	switch (code)
	{
	case CODE_CHANGE://注意是以三环视角来看其含义，初始化
		//填充中断门描述符
		__asm sidt IDT;
		IDT_BASE = *(PULONG)(&IDT[2]); 
		DbgPrint("shellCode地址为:%p\n", interruptGate);
		ULONG firstPart = (((ULONG)interruptGate) & 0xFFFF0000) | 0x0000EE00;
		ULONG secondPart = (((ULONG)interruptGate) & 0x0000FFFF) | 0x00080000;
		DbgPrint("中断门描述符:%p`%p\n", firstPart, secondPart);
		*(PULONG)(IDT_BASE + 32 * 8) = secondPart;
		*(PULONG)(IDT_BASE + 32 * 8 + 4) = firstPart;
		//填充调用门
		__asm sgdt GDT;
		GDT_BASE = *(PULONG)(&GDT[2]);
		ULONG targetAddress = *(ULONG*)systemBuf;//获取三环传过来的要跳转的函数地址
		DbgPrint("targetAddress:%p\n", targetAddress);
		ULONG firstPart_gdt = (((ULONG)targetAddress) & 0xFFFF0000) | 0x0000EC00;
		ULONG secondPart_gdt = (((ULONG)targetAddress) & 0x0000FFFF) | 0x00080000;
		DbgPrint("调用门描述符:%p`%p\n", firstPart_gdt, secondPart_gdt);
		*(PULONG)(GDT_BASE + 9 * 8) = secondPart_gdt;
		*(PULONG)(GDT_BASE + 9 * 8 + 4) = firstPart_gdt;
//下面代码想在驱动中修改PTE却发现PTE是0。
		//改变messageBox所在的物理页属性R/W为1
		//判断systemBuf中是否有内容
		//ULONG targetAddress = *(ULONG*)systemBuf;//获取三环传过来的函数地址
		//DbgPrint("MessageBoxA地址为:%p\n", messageBoxAAddr);
		//ULONG PDI = (messageBoxAAddr >> 21) & 0x1FF;
		////读取PDE
		//ULONG lowPDE = *(ULONG*)(0xC0601000 + 8 * PDI);
		//ULONG highPDE = *(ULONG*)(0xC0601000 + 8 * PDI +4);
		//DbgPrint("PDE为:%p`%p\n", highPDE,lowPDE);
		////读取PTE
		//ULONG PTI= (messageBoxAAddr >> 12)& 0x1FF;
		//ULONG lowPTE = *(ULONG*)(0xC0000000 + 0x1000 * PDI + PTI * 8);
		//ULONG highPTE = *(ULONG*)(0xC0000000+ 0x1000 * PDI + PTI * 8 + 4);
		//DbgPrint("PTE为:%p`%p\n", highPTE, lowPTE);

		break;
	case CODE_RESUME://三环想要反初始化
		//恢复原样
		break;

	case CODE_READ:
		/*DbgPrint("current ESP:%p\n", getESP);
		DbgPrint("param:%p,%p,%p,%p,%p\n", param[0], param[1], param[2], param[3], param[4]);*/
		if(param[4]!= current)
		{
			memcpy(systemBuf, param, 20);
			pIrp->IoStatus.Information = 20;
			current++;
		}
		else
		{
			pIrp->IoStatus.Information = 0;
		}
		break;
	}
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);//表示调用方已完成所有I/O请求处理操作，并将给定的 IRP 返回给 I/O 管理器。将IRP往下派发
	return STATUS_SUCCESS;
}


//入口函数，相当于main函数
NTSTATUS DriverEntry(PDRIVER_OBJECT pdriver, PUNICODE_STRING pReg)
{
	//设置一个卸载函数，用于退出
	pdriver->DriverUnload = DriverUnload;
	//创建设备名称
	UNICODE_STRING Devicename;
	RtlInitUnicodeString(&Devicename, L"\\Device\\MyDevice");
	//设备对象指针，用于接受
	PDEVICE_OBJECT pDeviceObj = NULL;
	//创建设备
	NTSTATUS status = IoCreateDevice(pdriver,0,&Devicename,FILE_DEVICE_UNKNOWN,FILE_DEVICE_SECURE_OPEN,TRUE,&pDeviceObj	);
	if (!NT_SUCCESS(status))//NT_SUCCESS,微软提供的，实际上就是判断status是否大于等于0
	{
		DbgPrint("创建设备失败!\n");
		return status;
	}
	//如果前面创建设备对象成功，就设置交互数据的方式
	pDeviceObj->Flags |= DO_BUFFERED_IO;
	//创建符号链接名称
	RtlInitUnicodeString(&SymbolicLinkName, L"\\??\\MyTestDriver");
	status = IoCreateSymbolicLink(&SymbolicLinkName, &Devicename);
	if (!NT_SUCCESS(status))
	{
		DbgPrint("创建符号链接失败!\n");
		IoDeleteDevice(pDeviceObj);//删除设备
		return status;
	}
	//设置派遣函数   
	pdriver->MajorFunction[IRP_MJ_CREATE] = MyCreateDispatchFunction;
	pdriver->MajorFunction[IRP_MJ_CLOSE] = MyCloseDispatchFunction;
	pdriver->MajorFunction[IRP_MJ_DEVICE_CONTROL] = ControlCallBack;
	

	return STATUS_SUCCESS;
}
```

### R3代码

```c
#include"stdafx.h"
#include <stdio.h>
#include <stdlib.h>
#include <Windows.h>
#include <WinIoCtl.h>

#define CODE_CHANGE CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define CODE_RESUME CTL_CODE(FILE_DEVICE_UNKNOWN,0x900,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define CODE_READ CTL_CODE(FILE_DEVICE_UNKNOWN,0x1000,METHOD_BUFFERED,FILE_ANY_ACCESS)

//打开设备
BOOLEAN openDevice(HANDLE *handle)
{
	HANDLE _handle = CreateFileA("\\\\.\\MyTestDriver", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);//打开设备对象句柄
	*handle = _handle;
	return (int)_handle > 0;
}

//发送IRP_MJ_DEVICE_CONTROL
BOOLEAN sendCode(HANDLE hDevice, DWORD code, PVOID inData, ULONG Inlen, PVOID outData, ULONG outLen, LPDWORD resultLen)
{
	return DeviceIoControl(hDevice, code, inData, Inlen, outData, outLen, resultLen, NULL);
}

DWORD lowPDE,lowPTE;
DWORD highPDE,highPTE;

void __declspec(naked) callGate()
{
	_asm
	{
		pushfd;
		pushad;
		mov ecx,dword ptr ds:[MessageBoxA];
		//get pde
		mov eax,ecx;
		shr eax,21;
		and eax,0x1FF;
		shl eax,3;
		mov edx,dword ptr ds:[0xC0601000+eax];
		mov dword ptr ds:[lowPDE],edx;
		mov edx,dword ptr ds:[0xC0601000+eax+4];
		mov dword ptr ds:[highPDE],edx;
		//get pte
		mov eax,ecx;
		shr eax,12;
		and eax,0xFFFFF;
		shl eax,3;
		mov edi,dword ptr ds:[0xC0000000+eax];
		mov dword ptr ds:[lowPTE],edi;
		mov edx,dword ptr ds:[0xC0000000+eax+4];
		mov dword ptr ds:[highPTE],edx;
		//change R/W in PDE
		or edi,0x2;
		mov dword ptr ds:[0xC0000000+eax],edi
		popad;
		popfd;
		retf;
	}
}

void main()
{
	// MessageBoxA 挂物理页，不这样操作，MessageBoxA的PTE可能是无效的
	__asm
	{
		mov eax, dword ptr ds:[MessageBoxA];
		mov eax,[eax];
	}
	printf("MessageBoxA address:%p\n",MessageBoxA);
	HANDLE hDevice;
	char buf[30] = { 0 };
	DWORD realReaded = 0;
	if (!openDevice(&hDevice))
	{
		printf("打开设备对象失败!\r\n");
		system("pause");
		return;
	}
	*(DWORD*)buf=(DWORD)callGate;
	sendCode(hDevice, CODE_CHANGE, buf, 30, NULL, 0, &realReaded);
	printf("callGate address:%p\n",callGate);
	
	char callCallgate[6]={0,0,0,0,0x48,0};
	_asm
	{
		call fword ptr[callCallgate];
	}
	printf("PDE:%p`%p\n",highPDE,lowPDE);
	printf("PTE:%p`%p\n",highPTE,lowPTE);
	//hook MessageBoxA
	char hookContent[2]={0xCD,0x20};
	memcpy(MessageBoxA,hookContent,2);
	//hook succeed!
	//get R0 info from MessageBoxA
	DWORD current=0;
	while(1)
	{
		sendCode(hDevice, CODE_READ, NULL, 0, buf, 30, &realReaded);
		DWORD* p=(DWORD*)buf;
		if(realReaded>0)
		{
			printf("No.%d MessageBoxA(%p,%p,%p,%p)\n",p[4],p[0],p[1],p[2],p[3]);
			current++;
		}
		Sleep(100);
	}
	CloseHandle(hDevice);
	system("pause");
}
```

成功监听MessageBoxA结果：

![image-20210830211435935](https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210830211435935.png)

[别人的代码参考](https://blog.csdn.net/weixin_41875267/article/details/109692389)

### 重难点

- 跟界面相关的API永远都是**懒加载**的，即没调用不加载，物理页不会挂上去。
- 但是OpenProcess这种，他自己事先就加载好了，挂上了物理页。

## Inline Hook

与R3的Inline Hook完全一样

位置的选择：

1. JMP/CALL指令至少占用5个字节
2. 绕开全局变量（每次的全局变量位置是不确定，因为模块加载的顺序不一致）
3. 根据业务来决定在哪里HOOK，过滤参数？修改返回结果？

思考：

1. 正在hook的瞬间，如何保证多核切换的稳定性
2. 如何绕过硬编码校验检测内联HOOK

## 注册系统回调保护进程

xp不可用

**替代hook的官方手段:回调函数**  (64位未过pg不能inline hook的替代方案)

[基于ObRegisterCallbacks实现的线程和进程监控及其保护]: https://blog.csdn.net/cosmoslife/article/details/113995641
[ObRegisterCallbacks 保护进程对象以及反ObRegisterCallbacks的分析与实现]: https://bbs.pediy.com/thread-248703

**注册系统回调最需要注意的一点就是: 一定要防止回调发生死循环**

### 核心函数ObRegisterCallbacks

**可以为线程、进程和桌面句柄操作注册回调函数**

![regsyscallback](https://raw.githubusercontent.com/che77a38/blogImage2/main/202205291945467.jpeg)

```c
NTSTATUS 
  ObRegisterCallbacks(
    IN POB_CALLBACK_REGISTRATION  CallBackRegistration,
    OUT PVOID  *RegistrationHandle);////返回该系统回调的句柄,卸载时用得上
//NT_SUCCESS(ObRegisterCallbacks的返回值)为1表示成功,否则失败
```

![v2-e07e93bb06ba604bbe332d3bfbc0183a_1440w](https://raw.githubusercontent.com/che77a38/blogImage2/main/202205041101739.jpeg)

> **破解ObRegisterCallbacks函数的使用限制** : 驱动程序必须有数字签名才能使用此函数,通过逆向ObRegisterCallbacks,找到了破解这个限制的方法.经研究,内核通过MmVerifyCallbackFunction验证此回调是否合法,但此函数只是简单的验证了一下DriverObject->DriverSection->Flags的值是不是包含0x20.在驱动的入口函数中添加代码: `PLDR_DATA_TABLE_ENTRY  pobj = (PLDR_DATA_TABLE_ENTRY)DriverObject->DriverSection;DriverObject->Flags |= 0x20; ` (PLDR_DATA_TABLE_ENTRY需要自己定义),即可破解该使用限制
>
> 想要使用ObRegisterCallbacks函数成功,必须在编译器的 **链接器-命令行行中添加**`/INTEGRITYCHECK`   (指定必须在加载时检查二进制映像的签名)
>
> 关于/INTEGRITYCHECK详细信息 https://docs.microsoft.com/zh-cn/cpp/build/reference/integritycheck-require-signature-check?view=msvc-160 

该函数第一个参数指向下面结构

#### OB_CALLBACK_REGISTRATION结构

```c
typedef struct _OB_CALLBACK_REGISTRATION {
  __in USHORT  Version;//一般为OB_FLT_REGISTRATION_VERSION
  __in USHORT  OperationRegistrationCount;//注册回调函数的个数
  __in UNICODE_STRING  Altitude;//决定加载顺序(越大的越早被执行)
  __in PVOID  RegistrationContext;//自定义数据,没有填空
  __in OB_OPERATION_REGISTRATION  *OperationRegistration;//指向_OB_OPERATION_REGISTRATION结构
} OB_CALLBACK_REGISTRATION, *POB_CALLBACK_REGISTRATION;
```

![v2-fe188ac7d8bd77ba391df598072daa18_1440w](https://raw.githubusercontent.com/che77a38/blogImage2/main/202205041103204.jpeg)

[Altitude详解]: https://docs.microsoft.com/en-us/windows-hardware/drivers/ifs/load-order-groups-and-altitudes-for-minifilter-drivers

可见成员又指向_OB_OPERATION_REGISTRATION结构体

#### _OB_OPERATION_REGISTRATION结构体

```c
typedef struct _OB_OPERATION_REGISTRATION {
  __in POBJECT_TYPE  *ObjectType;//针对进程还是线程还是桌面句柄
  __in OB_OPERATION  Operations;//针对什么行为回调
  __in POB_PRE_OPERATION_CALLBACK  PreOperation;//[前]设置自定义的回调函数
  __in POB_POST_OPERATION_CALLBACK  PostOperation;//[后]设置自定义的回调函数
} OB_OPERATION_REGISTRATION, *POB_OPERATION_REGISTRATION;
```

![v2-29347fc67c90d940d2ba3e58702b5035_1440w](https://raw.githubusercontent.com/che77a38/blogImage2/main/202205041105434.jpeg)

[_OB_OPERATION_REGISTRATION结构体详解]: https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ns-wdm-_ob_callback_registration

上述函数第三个参数指向一个自定的回调函数如下

#### 自定义回调函数

```c
//自己起名字
OB_PREOP_CALLBACK_STATUS my_pre_callback(
    PVOID RegistrationContext,//注册回调时传入的自定义数据
    POB_PRE_OPERATION_INFORMATION OperationInformation
)
{
	//想要的操作
  return OB_PREOP_SUCCESS;
}
```

**POB_PRE_OPERATION_INFORMATION结构**

[该结构详解]: https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ns-wdm-_ob_pre_operation_information

```c
typedef struct _OB_PRE_OPERATION_INFORMATION {
  OB_OPERATION                 Operation;
  union {
    ULONG Flags;
    struct {
      ULONG KernelHandle : 1;
      ULONG Reserved : 31;
    };
  };
  PVOID                        Object;//打开句柄的目标对象结构体首地址
  POBJECT_TYPE                 ObjectType;//对象种类
  PVOID                        CallContext;
  POB_PRE_OPERATION_PARAMETERS Parameters;//指向包含操作特定信息的OB_PRE_OPERATION_PARAMETERS的指针。
} OB_PRE_OPERATION_INFORMATION, *POB_PRE_OPERATION_INFORMATION;

//POB_PRE_OPERATION_PARAMETERS结构
typedef union _OB_PRE_OPERATION_PARAMETERS {
  OB_PRE_CREATE_HANDLE_INFORMATION    CreateHandleInformation;//包含特定于正在打开的句柄的信息的OB_PRE_CREATE_HANDLE_INFORMATION结构
  OB_PRE_DUPLICATE_HANDLE_INFORMATION DuplicateHandleInformation;
} OB_PRE_OPERATION_PARAMETERS, *POB_PRE_OPERATION_PARAMETERS;

//OB_PRE_CREATE_HANDLE_INFORMATION结构
typedef struct _OB_PRE_CREATE_HANDLE_INFORMATION {
  ACCESS_MASK DesiredAccess;//一个ACCESS_MASK值，它指定要为句柄授予的访问权限。默认情况下，此成员等于OriginalDesiredAccess，但ObjectPreCallback例程可以修改此值以限制授予的访问权限。
  ACCESS_MASK OriginalDesiredAccess;//一个 ACCESS_MASK 值，它指定为句柄请求的原始访问权限。
} OB_PRE_CREATE_HANDLE_INFORMATION, *POB_PRE_CREATE_HANDLE_INFORMATION;
//此结构可用于控制句柄权限
```

#### 注册系统回调案例

```c
//解锁使用限制
    ldr = (PLDR_DATA)pDriverObject->DriverSection;
    ldr->Flags |= 0x20;

//安装系统回调钩子代码如下
//安装内存保护
HANDLE gs_HandleCallback = NULL;//用来存放返回的句柄,以方便卸载对应功能
BOOLEAN protectProcessStart()
{
    OB_CALLBACK_REGISTRATION ob1_callback_reg = { 0 };
    OB_OPERATION_REGISTRATION ob2_operation = { 0 };
    //初始化ob1_callback_reg
    RtlInitUnicodeString(&ob1_callback_reg.Altitude, L"321000");//加载顺序
    ob1_callback_reg.RegistrationContext = NULL;//自定义数据
    ob1_callback_reg.Version = OB_FLT_REGISTRATION_VERSION;//版本ObGetFilterVersion(); //OB_FLT_REGISTRATION_VERSION
    ob1_callback_reg.OperationRegistrationCount = 1;//注册回调函数的个数
    ob1_callback_reg.OperationRegistration = &ob2_operation;
    //接下来初始化ob2_operation
    ob2_operation.ObjectType = PsProcessType;//OpenProcess OpenThread PsThreadType
    ob2_operation.Operations = OB_OPERATION_HANDLE_CREATE;//针对什么行为回调
    ob2_operation.PostOperation = NULL;//行为发生之后的钩子
    ob2_operation.PreOperation = my_pre_callback;//行为发生之前的钩子,这个函数是自定义的函数
    NTSTATUS ntRet = ObRegisterCallbacks(&ob1_callback_reg, &gs_HandleCallback);//注册回调函数
    KdPrint(("zeroko:sys安装进程保护:gs_HandleCallback=%p,ntRet=%x", gs_HandleCallback,ntRet));
    return ntRet == STATUS_SUCCESS;
}

//卸载系统回调钩子代码如下
//卸载进程保护
void protectProcessEnd()
{
    if (gs_HandleCallback)
    {
        ObUnRegisterCallbacks(gs_HandleCallback);
        gs_HandleCallback = NULL;
        KdPrint(("zeroko:sys卸载进程保护"));
    }
}

//自定义的回调函数
OB_PREOP_CALLBACK_STATUS my_pre_callback(
    PVOID RegistrationContext,
    POB_PRE_OPERATION_INFORMATION OperationInformation
)
{
     //KdPrint(("zeroko:sys pEprocess = %p", OperationInformation->Object));
    if (OperationInformation->KernelHandle)
    {
        //内核层
    }
    else
    {
        //用户层
        //只针对指定目标进程保护
        HANDLE dwTargetPId = PsGetProcessId((PEPROCESS)OperationInformation->Object);//获取目标进程pid
        //KdPrint(("zeroko:sys: 目标pid:%d", dwTargetPId));
        if (isInProtectPidsVec(dwTargetPId))
        {
            ACCESS_MASK newAccess = OperationInformation->Parameters->CreateHandleInformation.OriginalDesiredAccess;//获取原始赋予的权限
            //去除某些权限
            //去除终止进程权限
            newAccess &= ~PROCESS_TERMINATE;
            //去除跨进程读进程权限
            newAccess &= ~PROCESS_VM_READ;
            //去除跨进程写进程权限
            newAccess &= ~PROCESS_VM_WRITE;
            OperationInformation->Parameters->CreateHandleInformation.DesiredAccess = newAccess;//更改要赋予的权限为我们处理过的权限
        }
    }   
    
    return OB_PREOP_SUCCESS;
}
```

### 补充

#### **进程有哪些权限**

即使是任务管理器对进程进行操作,也需要获取对应进程权限才可以操作进程,因此如果用回调函数拦截了目标进程相应句柄的权限,则任务管理器也会无权限操作目标进程.

进程权限如下:

```c
#define PROCESS_TERMINATE                  (0x0001)//终止进程(任务管理器中如果在详细信息中对进程右键选择终止进程就需要用到此权限)  
#define PROCESS_CREATE_THREAD              (0x0002)//创建线程
#define PROCESS_SET_SESSIONID              (0x0004)  
#define PROCESS_VM_OPERATION               (0x0008)  
#define PROCESS_VM_READ                    (0x0010)//跨进程读目标进程 
#define PROCESS_VM_WRITE                   (0x0020)//跨进程写目标进程  
#define PROCESS_DUP_HANDLE                 (0x0040)//复制目标进程的句柄
#define PROCESS_CREATE_PROCESS             (0x0080)//创建进程
#define PROCESS_SET_QUOTA                  (0x0100)//设置一些进程的信息  
#define PROCESS_SET_INFORMATION            (0x0200)  
#define PROCESS_QUERY_INFORMATION          (0x0400)//查询进程的详细信息  
#define PROCESS_SUSPEND_RESUME             (0x0800)//进程挂起和恢复  
#define PROCESS_QUERY_LIMITED_INFORMATION  (0x1000)  
#define PROCESS_SET_LIMITED_INFORMATION    (0x2000)  
#if (NTDDI_VERSION >= NTDDI_VISTA)
#define PROCESS_ALL_ACCESS        (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | \
                                   0xFFFF)
#else
#define PROCESS_ALL_ACCESS        (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | \
                                   0xFFF)
#endif
```

#### 驱动中通过进程对象结构体首地址获取进程名

```c
//下面两个均只能获取到小于15字节的进程名    (EProcess是想获取的目标进程结构体首地址)
char* processName = (char*)EProcess+0x174;//只知道win7可用,不能针对所有操作系统,0x174在部分版本windows系统可能不正确(可能!)
char* processName2 = PsGetProcessImageFileName(EProcess);
//PsGetProcessImageFileName是未导出的函数,需要如下声明:
const char* PsGetProcessImageFileName(PEPROCESS arg1);
```

即可以获取当前进程名(最多显示14个字节)

```c
PsGetProcessImageFileName(PsGetCurrentProcess());
```

获取当前进程pid函数: `PsGetCurrentProcessId`

在系统回调中获取目标进程id

```c
HANDLE pid = PsGetProcessId((PEPROCESS)OperationInformation->OBject);
```

#### 进程id获取进程名

核心函数

- PsLookupProcessByProcessId      ObfDereferenceObject  (成对使用)

```c
const char* GetProcessNameByProcessId(HANDLE ProcessId)
{
    NTSTATUS st = STATUS_UNSUCCESSFUL;
    PEPROCESS ProcessObj = NULL;
    const char* PNameString = NULL;
    st = PsLookupProcessByProcessId(ProcessId, &ProcessObj);
    if (NT_SUCCESS(st))
    {
        PNameString = PsGetProcessImageFileName(ProcessObj);
        ObfDereferenceObject(ProcessObj);
    }
    return PNameString;
}
```

##### 另一种实现方式

这种方式在注册OpenProcess系统回调函数中使用会蓝屏

```c
const char* GetProcessName(ULONG dwPid)
{
    HANDLE ProcessHandle;
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    CLIENT_ID myCid;
    PEPROCESS EProcess;
    const char* PsName = NULL;
    InitializeObjectAttributes(&ObjectAttributes, 0, 0, 0, 0);
    myCid.UniqueProcess = (HANDLE)dwPid;
    myCid.UniqueThread = 0;
    //打开进程,获取句柄
    status = ZwOpenProcess(&ProcessHandle, PROCESS_ALL_ACCESS, &ObjectAttributes,&myCid);//如果在注册OpenProcess系统回调中使用此函数,就会陷入循环无限调用的情况导致堆栈溢出
    if (!NT_SUCCESS(status))
    {
        KdPrint(("zeroko:kernel:打开进程出错\n"));
        return NULL;
    }
    //得到EPROCESS结构,结构中取进程名
    status = ObReferenceObjectByHandle(ProcessHandle,FILE_READ_DATA,0,KernelMode,&EProcess,0);
    if (!NT_SUCCESS(status))
    {
        PsName = PsGetProcessImageFileName(EProcess);
        KdPrint(("zeroko:kernel:PsName is %s", PsName));
        ZwClose(ProcessHandle);
    }
    else
    {
        KdReint(("zeroko:kernel:Get ProcessName error"));
    }
    return PsName;
}
```

NtOpenProcess和ZwOpenProcess对应的函数地址实际上是同一个,只是符号不同.

如果在注册OpenProcess系统回调中使用此函数,就会陷入无限递归的死循环 `NtOpenProcess -> my_pre_callback -> GetProcessName -> NtOpenProcess `,最终导致堆栈溢出蓝屏

#### 驱动中设置断点:

##### 代码的方式下断点

```c
#define DbgBreakPoint __debugbreak
```

使用方式: `DbgBreakPoint();`或者 `__debugbreak();`

##### windbg直接下断点

`bu 模块名!函数名`   例如:  `bu mysys!testFunc`    `bp mysys!testFunc`

### 远程读写绕过系统回调保护

远程读写效率怎么都比不上内部读写

#### 进程挂靠的方式实现

**用到的核心函数**

1. KeStackAttachProcess 进程挂靠  (直接修改CR3应该也可以)
2. KeUnstackDetachProcess 解除进程挂靠

此处为内核申请一个过渡的内核内存,来临时存放要读的数据

##### 读进程

```c
//通过pid读取目标内存,返回实际读到的字节数(用到自定义的KReadProcessMemory函数)
BOOLEAN ReadProcessMemoryByPid(UINT32 dwPid, PVOID pBase, PVOID lpBuffer, UINT32 nSize)
{
    //根据pid获取PEPROCESS OpenProcess
    PEPROCESS Seleted_pEPROCESS = NULL;
    KdPrint(("zeroko:kernel:ReadMemory pid=%d,pBase=%p  lineNo.%d  is in Func:%s\n",dwPid,pBase,__LINE__,__FUNCDNAME__));
    if (PsLookupProcessByProcessId(dwPid,&Seleted_pEPROCESS)==STATUS_SUCCESS)
    {
        BOOLEAN br = KReadProcessMemory(Seleted_pEPROCESS, pBase,nSize, lpBuffer);
        ObDereferenceObject(Seleted_pEPROCESS);
        if (br)
        {
            return TRUE;
        }
    }
    else
    {
        KdPrint(("zeroko:kernel:PsLookupProcessByProcessId Fail...\n"));
    }
    return FALSE;
}

//apc方式系统回调保护读内存(Process 是要读的进程结构体指针,Address是要读的地址,Length是要读的长度,Buffer存放读到哪里)
//不借助于内核层和三环层的常规通信方式
BOOLEAN KReadProcessMemory2(IN PEPROCESS Process, IN PVOID Address, IN UINT32 Length, IN OUT PVOID Buffer)
{
    KAPC_STATE apc_state;
    RtlZeroMemory(&apc_state, sizeof(KAPC_STATE));
    //申请内核空间  在所有进程间通用   (实际上可以不申请空间,如果是零环与三环通信的时候,直接把那个通信缓冲区拿来用就可以了)
    PVOID tmpBuf_Kernel = ExAllocatePool(NonPagedPool, Length);
    if (!tmpBuf_Kernel) {
        KdPrint(("zeroko:kernel:内核空间申请失败\n"));
        return FALSE;
    }
    //也可以改MDL把 进程地址空间  映射到  内核驱动空间
    //中转内存地址中的内容,因为KeStackAttachProcess后,原来的进程R3 Buffer在目标地址里不存在(但如果是直接似乎内核内存,实际上不需要这一步)
    //RtlCopyMemory(tmpBuf_Kernel,Buffer,Length);
    //进入目标进程内存空间
    KdPrint(("zeroko:kernel:附加到目标进程Address = %p  BUffer=%p\n",Address,Buffer));
    KeStackAttachProcess((PVOID)Process, &apc_state);
    //判断目标地址是否可以访问
    BOOLEAN dwRet = MmIsAddressValid(Address);
    if (dwRet)
    {
        //把要读的目标进程中地址对应的内容拷到内核空间中
        RtlCopyMemory(tmpBuf_Kernel, Address, Length);
    }
    else
    {
        KdPrint(("zeroko:kernel:Error Line37\n"));
    }
    //分离目标进程空间,恢复环境
    KeUnstackDetachProcess(&apc_state);
    KdPrint(("zeroko:kernel:分离目标进程\n"));
    //内核内存复制回原进程内存
    RtlCopyMemory(Buffer, tmpBuf_Kernel, Length);
    //释放作为中转站的内核内存
    ExFreePool(tmpBuf_Kernel);
    return dwRet;
}

//apc方式系统回调保护读内存(Process 是要读的进程结构体指针,Address是要读的地址,Length是要读的长度,Buffer存放读到哪里)
//借助于内核层和三环层的常规通信方式
BOOLEAN KReadProcessMemory(IN PEPROCESS Process, IN PVOID Address, IN UINT32 Length, IN OUT PVOID Buffer)
{
    KAPC_STATE apc_state;
    RtlZeroMemory(&apc_state, sizeof(KAPC_STATE));
    //也可以改MDL把 进程地址空间  映射到  内核驱动空间
    //进入目标进程内存空间
    KdPrint(("zeroko:kernel:附加到目标进程Address = %p  BUffer=%p\n", Address, Buffer));
    KeStackAttachProcess((PVOID)Process, &apc_state);
    //判断目标地址是否可以访问
    BOOLEAN dwRet = MmIsAddressValid(Address);
    if (dwRet)
    {
        //把要读的目标进程中地址对应的内容拷到内核空间中
        RtlCopyMemory(Buffer, Address, Length);
    }
    else
    {
        KdPrint(("zeroko:kernel:Error Line37\n"));
    }
    //分离目标进程空间,恢复环境
    KeUnstackDetachProcess(&apc_state);
    //KdPrint(("zeroko:kernel:分离目标进程\n"));
    //内核内存复制回原进程内存
    return dwRet;
}
```

##### 写进程

下面函数**不能写只读内存**

```c
//远程写(不可以写只读内存):将UserBuffer(用户传过来的内容的地址)写入Process进程的Address地址,内容长度为Length
BOOLEAN KWriteProcessMemory(IN PEPROCESS Process, IN PVOID Address, IN UINT32 Length, IN PVOID UserBuffer)
{
    KAPC_STATE apc_state;
    RtlZeroMemory(&apc_state, sizeof(KAPC_STATE));
    //申请内核空间  在所有进程间通用   
    PVOID tmpBuf_Kernel = ExAllocatePool(NonPagedPool, Length);
    if (!tmpBuf_Kernel) {
        KdPrint(("zeroko:kernel:内核空间申请失败\n"));
        return FALSE;
    }
    BOOLEAN dwRet = MmIsAddressValid(UserBuffer);
    if (dwRet)
    {
        RtlCopyMemory(tmpBuf_Kernel, UserBuffer, Length);//真正的写操作
    }
    else
    {
        KdPrint(("zeroko:kernel:UserBuffer memory Error Line37\n"));
        ExFreePool(tmpBuf_Kernel);
        return FALSE;
    }
    //附加要写的目标进程
    KeStackAttachProcess((PVOID)Process, &apc_state);
    dwRet = MmIsAddressValid(Address);
    //写入内存
    if (dwRet)
    {
        RtlCopyMemory(Address, tmpBuf_Kernel, Length);//真正的写操作
    }
    else
    {
        KdPrint(("zeroko:kernel:Error Line37\n"));
    }
    KeUnstackDetachProcess(&apc_state);
    ExFreePool(tmpBuf_Kernel);
    return dwRet;
}

//通过id远程写,用到了自定义的KWriteProcessMemory函数
//对dwPid进程的pBase地址,写长度为nSize的在lpBuffer地址的内存
BOOLEAN WriteProcessMemoryByPid(UINT32 dwPid, PVOID pBase, PVOID lpBuffer, UINT32 nSize)
{
    //根据pid获取PEPROCESS OpenProcess
    PEPROCESS Seleted_pEPROCESS = NULL;
    KdPrint(("zeroko:kernel:WriteMemory pid=%d,pBase=%p  lineNo.%d  is in Func:%s\n", dwPid, pBase, __LINE__, __FUNCDNAME__));
    if (PsLookupProcessByProcessId(dwPid, &Seleted_pEPROCESS) == STATUS_SUCCESS)
    {
        BOOLEAN br = KWriteProcessMemory(Seleted_pEPROCESS, pBase, nSize, lpBuffer);
        ObDereferenceObject(Seleted_pEPROCESS);
        if (br)
        {
            return TRUE;
        }
    }
    else
    {
        KdPrint(("zeroko:kernel:PsLookupProcessByProcessId Fail...\n"));
    }
    return FALSE;
}
```

直接写入只读内存会蓝屏,下面有写只读内存的方式

#### MDL方式

优势:对于大内存远程读取写入有速度优势

上述过渡的内核内存,可以使用MDL映射方式替代:

[MDL映射详解]: https://bbs.pediy.com/thread-260860.htm

**用到的核心函数**

1. IoAllocateMdl   申请映射内存描述信息  IoFreeMdl  释放映射内存描述信息
2. MmBuildMdlForNonPagedPool  把内存标记为非分页内存,防止数据因为内存不足而被迁移到硬盘上
3. MmMapLockedPages  锁定内存映射  MmUnmapLockedPages 解除内存映射锁定

当不再需要 MDL描述的页的时,请调用`MmUnlockPages`将它们解除锁定,然后调用`IoFreeMdl` 来释放它们

##### 读内存

```c
//可以不借助于内核层和三环层的常规通信方式
BOOLEAN KReadProcessMemory3(IN PEPROCESS Process, IN PVOID Address, IN UINT32 Length, IN PVOID UserBuffer)
{
    KAPC_STATE apc_state;
    RtlZeroMemory(&apc_state, sizeof(KAPC_STATE));
    //为UserBuffer创建MDL内存描述
    //创建MDL来读取内存
    PMDL g_pmdl = IoAllocateMdl(UserBuffer, Length, 0, 0, NULL);
    if (!g_pmdl)
    {
        return FALSE;
    }
    //标记为非分页内存,避免置换到硬盘上
    MmBuildMdlForNonPagedPool(g_pmdl);
    //锁定,映射用户内存到内核内存    Mapped指向UserBuffer地址指向的同一个物理内存
    unsigned char* Mapped = (unsigned char*)MmMapLockedPages(g_pmdl, KernelMode);
    if (!Mapped)//映射失败
    {
        IoFreeMdl(g_pmdl);
        return FALSE;
    }
    KeStackAttachProcess((PVOID)Process, &apc_state);
    //判断目标地址是否可访问
    BOOLEAN dwRet = MmIsAddressValid(Address);
    if (dwRet)
    {
        RtlCopyMemory(Mapped, Address, Length);//此处实际上已经拷贝到想要的地址中去了.  写内存只需要调换此处的Mapped和Address
    }
    else
    {
        KdPrint(("zeroko:kernel:Error Line37\n"));
    }
    KeUnstackDetachProcess(&apc_state);
    IoFreeMdl(g_pmdl);
    //MDL清理工作
    //释放MDL相关资源
    MmUnmapLockedPages((PVOID)Mapped, g_pmdl);
    IoFreeMdl(g_pmdl);
    return dwRet;
}
```

##### 写内存

三环是通过 `VirtualProtectEx` 或 `VirtualQueryEx` 函数来修改页面属性来达到写只读内存的目的(E.g. CE修改器就是采取这套方式)

**下面是可以用于写只读内存的驱动实现方式**

核心点是: `MmProbeAndLockPages` 将 `MdlFlags = MDL_WRITE_OPERATION | MDL_ALLOCATED_FIXED_SIZE | MDL_PAGES_LOCKED` 

```c
//可以用于写只读内存    将UserBuffer(用户传过来的内容的地址)写入Process进程的Address地址,内容长度为Length
BOOLEAN KWriteProcessMemory(IN PEPROCESS Process, IN PVOID Address, IN UINT32 Length, IN PVOID UserBuffer)
{
    KAPC_STATE apc_state;
    RtlZeroMemory(&apc_state, sizeof(KAPC_STATE));
    //进程挂靠
    KeStackAttachProcess((PVOID)Process, &apc_state);
    BOOLEAN dwRet = MmIsAddressValid(Address);
    if (!dwRet)
    {
        KdPrint(("zeroko:kernel: ERROR LINE%d\n", __LINE__));
        KeUnstackDetachProcess(&apc_state);
        return FALSE;
    }
   //为UserBuffer创建MDL内存描述
    PMDL g_pmdl = IoAllocateMdl(Address, Length, 0, 0, NULL);
    if (!g_pmdl)
    {
        KdPrint(("zeroko:kernel: ERROR LINE%d\n", __LINE__));
        KeUnstackDetachProcess(&apc_state);
        return FALSE;
    }
    //标记为非分页内存
    MmBuildMdlForNonPagedPool(g_pmdl);
    //设置标志位
    g_pmdl->MdlFlags = MDL_WRITE_OPERATION | MDL_ALLOCATED_FIXED_SIZE | MDL_PAGES_LOCKED; 
    //锁定映射关系
    unsigned char* Mapped = (unsigned char*)MmMapLockedPages(g_pmdl, KernelMode);
    if (!Mapped)
    {
        KdPrint(("zeroko:kernel: ERROR LINE%d\n", __LINE__));
        IoFreeMdl(g_pmdl);
        KeUnstackDetachProcess(&apc_state);
        return FALSE;
    }
    //映射成功后,退出挂靠环境
    KeUnstackDetachProcess(&apc_state);
    RtlCopyMemory(Mapped, UserBuffer, Length);

    //恢复环境
    MmUnmapLockedPages((PVOID)Mapped, g_pmdl);
    IoFreeMdl(g_pmdl);
    return TRUE;
}
```

#### CR0方式写只读内存

内存类型

1. PagedPool   可以被置换到硬盘中,一般存储数据
2. NonPagedPool 不能被置换到硬盘中,驻留在内存中,一般用来存储代码

如果执行代码到PagedPool的内存中很有可能蓝屏

在**内核空间中所有内存都是可读可写可执行的**,故没有类似用户态下的VirtualProtect改变内存属性的函数,但是并**不意味着可以随意执行和改写内存中的代码,要满足2个条件**:

1. 关闭内存写保护  通过操作CR0寄存器实现
2. 提升IRQL级别(防止执行出错)     使用 `KeRaiseIrqlToDpcLevel`和 `KeLowerIrql` 实现

`__readcr0()函数` 需要头文件: `#include <intrin.h>`

```c
//关闭内存写保护和提升IRQL
KIRQL irql = KeRaiseIrqlToDpcLevel();//不提高中断等级无法写CR0
UINT64 cr0 = __readcr0();
cr0 &= 0xfffffffffffeffff;
__writecr0(cr0);
_disable();

//还原  (开启内存写保护)
UINT64 cr0 = __readcr0();
cr0 |= 0x10000;
_enable();
KeLowerIrql(irql);
//内存操作放到二者之间就可以正常操作内存了
```

#### 物理内存读写内存方法

物理内存读写内存速度比较慢,不建议用于频繁地读写内存,**一般用于注入代码**

##### **核心函数**

- `ZwMapViewOfSection` 把物理地址映射到当前进程 
- `ZeUnmapViewOfSection`  取消映射
- `MmGetPhysicalAddress` 虚拟地址转换为物理地址

###### ZwMapViewOfSection

[微软官方文档]: https://docs.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/nf-wdm-zwmapviewofsection

```c
NTSYSAPI NTSTATUS ZwMapViewOfSection(
  [in]                HANDLE          SectionHandle,
  [in]                HANDLE          ProcessHandle,
  [in, out]           PVOID           *BaseAddress,//映射后返回出来的虚拟地址
  [in]                ULONG_PTR       ZeroBits,
  [in]                SIZE_T          CommitSize,//想要映射的字节大小
  [in, out, optional] PLARGE_INTEGER  SectionOffset,//要映射的物理地址
  [in, out]           PSIZE_T         ViewSize,//实际映射的字节大小
  [in]                SECTION_INHERIT InheritDisposition,
  [in]                ULONG           AllocationType,
  [in]                ULONG           Win32Protect
);
```

##### 完整代码

###### 最外层的读写内存接口

```c
//读dwPid中的pBase地址中长nSize的值搭配lpBuffer地址中
BOOLEAN ReadPhysicalMemoryByPid(UINT32 dwPid, PVOID pBase, PVOID lpBuffer, UINT32 nSize)
{
    PVOID physicalAddress = GetPhysicalAddress(dwPid, pBase);
    KdPrint(("zeroko:kernel:获取到的物理地址为%llx\n", physicalAddress));
    if (physicalAddress)
    {
        return ReadPhysicalMemory(physicalAddress, nSize, lpBuffer);
    }
    else
    {
        return FALSE;
    }
}

//将lpBuffer地址中长nSize的值写到dwPid中的pBase地址
BOOLEAN WritePhysicalMemoryByPid(UINT32 dwPid, PVOID pBase, PVOID lpBuffer, UINT32 nSize)
{
    PVOID physicalAddress = GetPhysicalAddress(dwPid, pBase);
    KdPrint(("zeroko:kernel:获取到的物理地址为%llx\n", physicalAddress));
    if (physicalAddress)
    {
        return WritePhysicalMemory(physicalAddress, nSize, lpBuffer);
    }
    else
    {
        return FALSE;
    }
}
```

###### 获取最大物理地址函数

```c
UINT64 g_maxPhysAddress = 0;
//利用cpuid取出 物理地址Bits
//获取最大的物理地址
UINT64 getg_maxPhysAddress(void)
{
    if (g_maxPhysAddress == 0)
    {
        int physicalbits;
        UINT32 r[4]; //四个整数的数组，包含在 EAX、EBX、ECX 和 EDX 中返回的有关 CPU 支持的功能的信息
        __cpuid(r, 0x80000008); //只有r[0]的前 8位和 8至15们有用 后边3个 全保留

        //get max physical address
        physicalbits = r[0] & 0xff;

        g_maxPhysAddress = 0xFFFFFFFFFFFFFFFFULL;
        g_maxPhysAddress = g_maxPhysAddress >> physicalbits; //if physicalbits==36 then g_maxPhysAddress=0x000000000fffffff
        g_maxPhysAddress = ~(g_maxPhysAddress << physicalbits); //<< 36 = 0xfffffff000000000 .  after inverse : 0x0000000fffffffff		
    }
    return g_maxPhysAddress;
}
```

###### 获取物理地址的值函数

```c
//将ProcessId目标进程中的虚拟地址转为物理地址
PVOID GetPhysicalAddress(UINT64 ProcessId, PVOID vBaseAddress)
{
    PEPROCESS selectedProcess;//ProcessId的进程对象
    PHYSICAL_ADDRESS physical;
    physical.QuadPart = 0;//PHYSICAL_ADDRESS实际上就是INT64 8字节
    NTSTATUS ntStatus = STATUS_SUCCESS;
    __try
    {
        if (PsLookupProcessByProcessId((PVOID)(ProcessId), &selectedProcess)==STATUS_SUCCESS)
        {
            KAPC_STATE apc_state;
            RtlZeroMemory(&apc_state, sizeof(apc_state));
            KeStackAttachProcess((PVOID)selectedProcess, &apc_state);//关键地方,附加到指定进程
            __try
            {
                physical = MmGetPhysicalAddress((PVOID)vBaseAddress);//把虚拟地址转换为物理地址
            }
            __finally
            {
                KeUnstackDetachProcess(&apc_state);
            }
            ObDereferenceObject(selectedProcess);
        }
    }
    __except (1)
    {
        ntStatus = STATUS_UNSUCCESSFUL;
    }
    if (ntStatus == STATUS_SUCCESS)
    {
        return (PVOID)physical.QuadPart;//返回物理地址
    }
    return NULL;//失败返回NULL
}
```

###### 物理内存读写函数

**读函数**

```c
//对于分页内存来说，调用MmProbeAndLockPages以及MmGetSystemAddressForMdlSafe来锁定内存页，以防止被page out出去；
//对于非分页内存而言，调用MmBuildMdlForNonPagedPool映射到物理内存上。
//__noop(("zeroko:kernel:Too small map"));
//physicalBase本身就是物理地址
//读取物理地址的值physicalBase,读到output地址中,读bytestoread长度
BOOLEAN ReadPhysicalMemory(char* physicalBase, UINT_PTR bytestoread, void* output)
{
    UNICODE_STRING	physmemString;
    OBJECT_ATTRIBUTES attributes;
    HANDLE	physmem = NULL;
    UCHAR* vaddress; // 用于映射后的虚地址 供访问
    KdPrint(("zeroko:kernel:要读的物理地址为%llx  最大物理地址为%llx \n", physicalBase, getg_maxPhysAddress()));
    //校验是否超过最大物理内存
    if (((UINT64)physicalBase > getg_maxPhysAddress()) || ((UINT64)physicalBase + bytestoread > getg_maxPhysAddress()))
    {
        KdPrint(("zeroko:kernel: Invalid physical address\n"));
        return FALSE;
    }
    __try
    {
        //初始化映射物理内存需要用到的数据
        RtlInitUnicodeString(&physmemString, L"\\device\\physicalmemory");//要访问物理内存,需要用到该设备描述
        InitializeObjectAttributes(&attributes,&physmemString, OBJ_CASE_INSENSITIVE, NULL, NULL);
        NTSTATUS ntStatus = ZwOpenSection(&physmem, SECTION_ALL_ACCESS, &attributes);
        if (ntStatus == STATUS_SUCCESS)
        {
            PHYSICAL_ADDRESS	viewBase;//物理内存地址
            viewBase.QuadPart = (ULONGLONG)(physicalBase);
            KdPrint(("zeroko:kernel:ReadPhysicalMemory:viewBase.QuadPart=%x", viewBase.QuadPart));
            SIZE_T length = bytestoread;
            //映射物理内存地址到当前进程的虚地址空间
            ntStatus = ZwMapViewOfSection(
                physmem,  //sectionhandle
                NtCurrentProcess(), //processhandle (should be -1)
                &vaddress, //BaseAddress 映射产生的虚拟地址
                0L, //ZeroBits
                length, //CommitSize
                &viewBase, //SectionOffset  要映射的物理地址
                &length, //ViewSize
                ViewShare,
                0,
                PAGE_READWRITE);
            //映射成功的话
            if (ntStatus == STATUS_SUCCESS && vaddress != NULL)
            {
                //实际映射的长度大于要写入的内容长度
                if (bytestoread > length)
                {
                    KdPrint(("zeroko:kernel:Too small map\n"));
                }
                else
                {
                    //真正的读操作
                    RtlCopyMemory(output, vaddress, bytestoread);
                }
                //解除映射
                ZwUnmapViewOfSection(NtCurrentProcess(), vaddress);
            }
        }
    }
    __except (1)
    {
        KdPrint(("zeroko:kernel:Failure mapping physical memory"));
    }
    //关闭节对象
    ZwClose(physmem);
    return TRUE;
}
```

**写函数**

```c
//写物理地址函数
//将input地址的长度为nSizeWrite的内存写到physicalBase物理地址中
BOOLEAN WritePhysicalMemory(char* physicalBase, IN UINT_PTR nSizeWrite, IN PVOID input)
{
    UNICODE_STRING	physmemString;
    OBJECT_ATTRIBUTES attributes;
    HANDLE	physmem = NULL;
    UCHAR* vaddress; // 用于映射后的虚地址 供访问
    //校验是否超过最大物理内存
    if (((UINT64)physicalBase > getg_maxPhysAddress()) || ((UINT64)physicalBase + nSizeWrite > getg_maxPhysAddress()))
    {
        KdPrint(("zeroko:kernel: Invalid physical address\n"));
        return FALSE;
    }
    __try
    {
        //初始化映射物理内存需要用到的数据
        RtlInitUnicodeString(&physmemString, L"\\device\\physicalmemory");//要访问物理内存,需要用到该设备描述
        InitializeObjectAttributes(&attributes, &physmemString, OBJ_CASE_INSENSITIVE, NULL, NULL);
        NTSTATUS ntStatus = ZwOpenSection(&physmem, SECTION_ALL_ACCESS, &attributes);
        if (ntStatus == STATUS_SUCCESS)
        {
            PHYSICAL_ADDRESS	viewBase;//物理内存地址
            viewBase.QuadPart = (ULONGLONG)(physicalBase);
          KdPrint(("zeroko:kernel:ReadPhysicalMemory:viewBase.QuadPart=%x", viewBase.QuadPart));
            SIZE_T length = 0x2000;
            //映射物理内存地址到当前进程的虚地址空间
            ntStatus = ZwMapViewOfSection(
                physmem,  //sectionhandle
                NtCurrentProcess(), //processhandle (should be -1)
                &vaddress, //BaseAddress 映射产生的虚拟地址
                0L, //ZeroBits
                length, //CommitSize
                &viewBase, //SectionOffset  要映射的物理地址
                &length, //ViewSize
                ViewShare,
                0,
                PAGE_READWRITE);
            //映射成功的话
            if (ntStatus == STATUS_SUCCESS && vaddress != NULL)
            {
                //实际映射的长度大于要写入的内容长度
                if (nSizeWrite > length)
                {
                    KdPrint(("zeroko:kernel:Too small map\n"));
                }
                else
                {
                    //真正的写操作
                    RtlCopyMemory(vaddress, input, nSizeWrite);
                }
                //解除映射
                ZwUnmapViewOfSection(NtCurrentProcess(), vaddress);
            }
        }
    }
    __except (1)
    {
        KdPrint(("zeroko:kernel:Failure mapping physical memory"));
    }
    //关闭节对象
    ZwClose(physmem);
    return TRUE;
}
```

## 针对对象回调钩子的操作

### 遍历进程/线程对象钩子

**兼容win7~win10**

#### 需要用的自定义结构和变量

```c
//=================================
//下面开始遍历系统回调钩子
//=================================
//需要用到的自定义结构
typedef struct _CALL_BACK_INFO
{
    ULONG64 Unknow;
    ULONG64 Unknow1;
    UNICODE_STRING AltitudeString;//该成员决定执行顺序,越大越早被执行
    LIST_ENTRY NextEntryItemList; //(callbacklist) 跟上面开头的那个一样 存储下一个callbacklist
    ULONG64 Operations;
    PVOID ObHandle; //存储详细的数据 版本号 POB_OPERATION_REGISTRATION AltitudeString 也就是本身节点CALL_BACK_INFO 注销时也使用这个 注意是指针 //CALL_BACK_INFO
    PVOID ObjectType;
    ULONG64 PreCallbackAddr;
    ULONG64 PostCallbackAddr;
}CALL_BACK_INFO, * PCALL_BACK_INFO;

typedef struct _OB_CALLBACK
{
    LIST_ENTRY	ListEntry;//链表结构
    ULONG64		Operations;
    PCALL_BACK_INFO		ObHandle;//该结构指向上面的结构
    ULONG64		ObjTypeAddr;
    ULONG64		PreCall;//前回调函数
    ULONG64		PostCall;//后回调函数
} OB_CALLBACK, * POB_CALLBACK;

static ULONG ObjectCallbackListOffset = 0;//win7的该偏移与win10有差异
extern PSHORT NtBuildNumber;//导出的内部版本号地址
```

#### 遍历回调需要用到的自定义子函数(包含依赖关系)

- `GetVersionAndHardCode`  
- `GetPsLoadedListModule`  获取模块链表头
  - `GetUndocumentFunctionAddress`  通过函数名获取未文档化的函数地址
  - `GetMovPoint`
- `ObGetDriverNameByPoint`   通过地址,获取对应模块的模块名

(上面子函数具备通用性的有文字描述)

```c
//获取版本和对应的硬编码(EnumObRegisterCallBacks函数需要用到的子函数)
BOOLEAN GetVersionAndHardCode()
{
    BOOLEAN b = FALSE;
    switch (*NtBuildNumber)
    {
    case 7600://win7
    case 7601://win7
    {
        ObjectCallbackListOffset = 0xC0;
        b = TRUE;
        break;
    }
    case 9200://win8
    {
        ObjectCallbackListOffset = 0xC8;	//OBJECT_TYPE.CallbackList
        b = TRUE;
        break;
    }
    case 9600://win8
    {
        ObjectCallbackListOffset = 0xC8;	//OBJECT_TYPE.CallbackList
        b = TRUE;
        break;
    }
    default:
        if (*NtBuildNumber > 10000)
        {
            ObjectCallbackListOffset = 0xc8;
            b = TRUE;
        }
        break;
    }
    return b;
}

//获取未文档化的函数  
//win7获取函数链表头需要用到的函数(GetPsLoadedListModule用到的子函数)
PVOID GetUndocumentFunctionAddress(IN PUNICODE_STRING pFunName,
    IN PUCHAR pStartAddress,
    IN UCHAR* pFeatureCode,
    IN ULONG FeatureCodeNum,
    ULONG SerSize,
    UCHAR SegCode,
    ULONG AddNum,
    BOOLEAN ByName)
{
    ULONG dwIndex = 0;
    PUCHAR pFunAddress = NULL;
    ULONG dwCodeNum = 0;
    if (pFeatureCode == NULL)
        return NULL;
    if (FeatureCodeNum >= 15)
        return NULL;
    if (SerSize > 0x1024)
        return NULL;
    if (ByName)
    {
        if (pFunName == NULL || !MmIsAddressValid(pFunName->Buffer))
            return NULL;
        pFunAddress = (PUCHAR)MmGetSystemRoutineAddress(pFunName);
        if (pFunAddress == NULL)
            return NULL;
    }
    else
    {
        if (pStartAddress == NULL || !MmIsAddressValid(pStartAddress))
            return NULL;
        pFunAddress = pStartAddress;
    }
    for (dwIndex = 0; dwIndex < SerSize; dwIndex++)
    {
        __try
        {
            if (pFunAddress[dwIndex] == pFeatureCode[dwCodeNum] || pFeatureCode[dwCodeNum] == SegCode)
            {
                dwCodeNum++;
                if (dwCodeNum == FeatureCodeNum)
                    return pFunAddress + dwIndex - dwCodeNum + 1 + AddNum;
                continue;
            }
            dwCodeNum = 0;
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            return 0;
        }
    }
    return 0;
}

//win7获取函数链表头需要用到的函数(GetPsLoadedListModule用到的子函数)
PVOID GetMovPoint(PVOID pCallPoint)
{
    ULONG dwOffset = 0;
    ULONG_PTR returnAddress = 0;
    LARGE_INTEGER returnAddressTemp = { 0 };
    PUCHAR pFunAddress = NULL;

    if (pCallPoint == NULL || !MmIsAddressValid(pCallPoint))
        return NULL;

    pFunAddress = pCallPoint;
    // 函数偏移  
    RtlCopyMemory(&dwOffset, (PVOID)(pFunAddress + 3), sizeof(ULONG));

    // JMP向上跳转  
    if ((dwOffset & 0x10000000) == 0x10000000)
    {
        dwOffset = dwOffset + 7 + pFunAddress;
        returnAddressTemp.QuadPart = (ULONG_PTR)pFunAddress & 0xFFFFFFFF00000000;
        returnAddressTemp.LowPart = dwOffset;
        returnAddress = returnAddressTemp.QuadPart;
        return (PVOID)returnAddress;
    }

    returnAddress = (ULONG_PTR)dwOffset + 7 + pFunAddress;
    return (PVOID)returnAddress;
}

//获取模块链表头地址(ObGetDriverNameByPoint函数需要用到的子函数)
PVOID GetPsLoadedListModule()
{
    /*
    为什么不使用DriverObject去枚举呢 主要是win10这玩意导出了 追随步伐啊 哈哈
    RtlPcToFileHeader
    text:000000014015D6A3 48 8B 0D 86 50 0E 00                          mov     rcx, qword ptr cs:PsLoadedModuleList
    .text:000000014015D6AA 48 85 C9                                      test    rcx, rcx
    .text:000000014015D6AD 74 28                                         jz      short loc_14015D6D7
    .text:000000014015D6AF 48 8D 15 7A 50 0E 00                          lea     rdx, PsLoadedModuleList
    */
    UNICODE_STRING usRtlPcToFileHeader = RTL_CONSTANT_STRING(L"RtlPcToFileHeader");
    UNICODE_STRING usPsLoadedModuleList = RTL_CONSTANT_STRING(L"PsLoadedModuleList");
    PVOID Point = NULL;
    static PVOID PsLoadedListModule = NULL;
    UCHAR shellcode[11] =
        "\x48\x8b\x0d\x60\x60\x60\x60"
        "\x48\x85\xc9";
    if (PsLoadedListModule)
        return PsLoadedListModule;
    //win10直接就导出了
    if (*NtBuildNumber > 9600)
    {
        // win10 PsLoadedModuleList导出
        PsLoadedListModule = MmGetSystemRoutineAddress(&usPsLoadedModuleList);
        return PsLoadedListModule;
    }
    //win7未导出,相对麻烦
    Point = GetUndocumentFunctionAddress(&usRtlPcToFileHeader, NULL, shellcode, 10, 0xff, 0x60, 0, TRUE);
    if (Point == NULL || !MmIsAddressValid(Point))
        return NULL;

    Point = GetMovPoint(Point);
    if (Point == NULL || !MmIsAddressValid(Point))
        return NULL;
    PsLoadedListModule = Point;
    return PsLoadedListModule;
}

//通过某地址,获得该地址所处的模块对应的模块名(主要用于判断回调函数地址属于哪个模块)
//(EnumObRegisterCallBacks函数需要用到的子函数)
BOOLEAN ObGetDriverNameByPoint(ULONG_PTR Point, OUT WCHAR* szDriverName)
{
    PLDR_DATA_TABLE_ENTRY Begin = NULL;
    PLIST_ENTRY Head = NULL;
    PLIST_ENTRY Next = NULL;

    //获取模块链表头
    Begin = GetPsLoadedListModule();
    //开始遍历模块链表
    if (Begin == NULL)
        return FALSE;

    Head = (PLIST_ENTRY)Begin->InLoadOrderLinks.Flink;
    Next = Head->Flink;
    //遍历模块地址,判断地址是处于哪个模块
    do
    {
        PLDR_DATA_TABLE_ENTRY Entry = CONTAINING_RECORD(Next, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
        Next = Next->Flink;

        if ((ULONG_PTR)Entry->DllBase <= Point && Point <= ((ULONG_PTR)Entry->DllBase + Entry->SizeOfImage))
        {
            if (szDriverName == NULL)
                return FALSE;
            RtlZeroMemory(szDriverName, 600);
            RtlCopyMemory(szDriverName, Entry->BaseDllName.Buffer, Entry->BaseDllName.Length);
            return TRUE;
        }
    } while (Next != Head->Flink);//循环链表,如果下一个指针再次指向首节点,则遍历结束
    return FALSE;
}
```

#### 遍历回调函数

```c
//遍历所有 进程  线程  注册的ObRegisterCallBacks回调
ULONG EnumObRegisterCallBacks()
{
    ULONG c = 0;//回调个数计数
    PLIST_ENTRY CurrEntry = NULL;
    POB_CALLBACK pObCallback;
    ULONG64 ObProcessCallbackListHead = 0;
    ULONG64 ObThreadCallbackListHead = 0;
    WCHAR* szDriverBaseName = NULL;
    szDriverBaseName = ExAllocatePool(NonPagedPool, 600);
    if (szDriverBaseName == NULL)
        return FALSE;
    RtlZeroMemory(szDriverBaseName, 600);
    GetVersionAndHardCode();
    //PsProcessType和PsThreadType是导出的,直接使用   ObjectCallbackListOffset和ObjectCallbackListOffset需要自己计算出来
    ObProcessCallbackListHead = *(ULONG64*)PsProcessType + ObjectCallbackListOffset;//获取进程链表头
    ObThreadCallbackListHead = *(ULONG64*)PsThreadType + ObjectCallbackListOffset;//获取线程链表头
    //遍历进程回调
    KdPrint(("zeroko:kernel:进程对象回调:\n"));
    CurrEntry = ((PLIST_ENTRY)ObProcessCallbackListHead)->Flink;
    if (CurrEntry == NULL || !MmIsAddressValid(CurrEntry))
    {
        ExFreePool(szDriverBaseName);
        return 0;
    }
    do
    {
        pObCallback = (POB_CALLBACK)CurrEntry;
        if (pObCallback->ObHandle != 0)
        {
            //遍历所有进程回调前函数,并且打印所属驱动名
            if (ObGetDriverNameByPoint(pObCallback->PreCall, szDriverBaseName))
                DbgPrint("zeroko:kernel:>DriverName=%S ObHandle=%p  Index=%wZ PreCall=%p PostCall=%p \n",
                    szDriverBaseName,
                    pObCallback->ObHandle,
                    &pObCallback->ObHandle->AltitudeString,
                    pObCallback->PreCall,
                    pObCallback->PostCall);
            c++;
        }
        CurrEntry = CurrEntry->Flink;
    } while (CurrEntry != (PLIST_ENTRY)ObProcessCallbackListHead);
    //遍历线程回调
    DbgPrint("zeroko:kernel:->线程对象回调:\n");
    CurrEntry = ((PLIST_ENTRY)ObThreadCallbackListHead)->Flink;
    if (CurrEntry == NULL || !MmIsAddressValid(CurrEntry))
    {
        ExFreePool(szDriverBaseName);
        return c;
    }
    do
    {
        pObCallback = (POB_CALLBACK)CurrEntry;
        if (pObCallback->ObHandle != 0)
        {
            if (ObGetDriverNameByPoint(pObCallback->PreCall, szDriverBaseName))
                DbgPrint("zeroko:kernel:>DriverName=%S ObHandle=%p  Index=%wZ PreCall=%p PostCall=%p \n",
                    szDriverBaseName,
                    pObCallback->ObHandle,
                    &pObCallback->ObHandle->AltitudeString,
                    pObCallback->PreCall,
                    pObCallback->PostCall);
            c++;
        }
        CurrEntry = CurrEntry->Flink;
    } while (CurrEntry != (PLIST_ENTRY)ObThreadCallbackListHead);
    DbgPrint("zeroko:kernel:ObCallback count: %ld\n", c);
    ExFreePool(szDriverBaseName);
    return c;
}
```

遍历部分输出如下:

```c
zeroko:kernel:进程对象回调:
zeroko:kernel:>DriverName=360FsFlt.sys ObHandle=FFFFB0837FB8C960  Index=425000 PreCall=FFFFF8055984DF30 PostCall=FFFFF8055984DF90 
zeroko:kernel:>DriverName=360Box64.sys ObHandle=FFFFB0837FB8DE60  Index=382310 PreCall=FFFFF8055991BB20 PostCall=FFFFF8055991BB2C 
zeroko:kernel:>DriverName=sysdiag.sys ObHandle=FFFFB0837F8D3C90  Index=324600 PreCall=FFFFF80559E562B0 PostCall=0000000000000000 
zeroko:kernel:->线程对象回调:
zeroko:kernel:>DriverName=360FsFlt.sys ObHandle=FFFFB0837FB8C960  Index=425000 PreCall=FFFFF8055984DF30 PostCall=FFFFF8055984DF90 
zeroko:kernel:>DriverName=360Box64.sys ObHandle=FFFFB0837FB8DE60  Index=382310 PreCall=FFFFF8055991BB20 PostCall=FFFFF8055991BB2C 
zeroko:kernel:ObCallback count: 5
//遍历结果中Index越大的越早被执行
```

### 完美过掉对象保护钩子

**[[绕过回调保护思路]]**:借助于`OB_CALLBACK.CALL_BACK_INFO.AltitudeString`越大越早被执行的规则,可以通过最早执行的回调钩子记录权限,再配合最晚执行的回调钩子恢复所有权限,以此对抗权限保护.

> 前面的[注册系统回调](#注册系统回调案例)做的是让其他进程都没办法以[想要保护的进程]为目标打开进程,而此处做的是:让指定进程打开进程时,不会受到系统回调保护的限制.所以在自定义回调函数中,前者是通过OB_PRE_OPERATION_INFORMATION.Object来判断打开进程的目标进程;后者是通过PsGetCurrentProcessId获取自身pid来判断是不是我们想要绕过保护的进程.

需要用到互斥提同步相关函数:

- `ExInitializeFastMutex` 初始化快速互斥体
- `ExAcquireFastMutex` 请求使用快速互斥体
- 要同步的代码在上下之间
- `ExReleaseFastMutex` 释放

代码如下:

#### 需要用到的结构

```c
//这里字节对齐要采用默认，不要按1对齐，这样才符合32位和64位结构体
typedef struct _LDR_DATA_TABLE_ENTRY
{
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	LIST_ENTRY InInitializationOrderLinks;
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	ULONG Flags;
	USHORT LoadCount;
	USHORT TlsIndex;
	union
	{
		LIST_ENTRY HashLinks;
		struct
		{
			PVOID SectionPointer;
			ULONG CheckSum;
		};
	};
	union
	{
		struct
		{
			ULONG TimeDateStamp;
		};
		struct
		{
			PVOID LoadedImports;
		};
	};
	struct _ACTIVATION_CONTEXT* EntryPointActivationContext;
	PVOID PatchInformation;
} LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;

//自定义的记录对象信息的链表结构
typedef struct _OPERATION_INFO_ENTRY
{
	LIST_ENTRY    ListEntry;
	OB_OPERATION  Operation;
	ULONG         Flags;
	PVOID         Object;
	POBJECT_TYPE  ObjectType;
	ACCESS_MASK   AccessMask;
	ULONG32 time;
} OPERATION_INFO_ENTRY, * POPERATION_INFO_ENTRY;
```

#### 需要用到的自定义子函数以及全局变量

- `MyGetTickCount`  内核获得系统启动计数
- `IsMyProcess`  
- `Last_CallBack` 还原原权限自定义回调函数
- `First_CallBack`  记录原权限的自定义回调函数
- ntoskrnl.exe导出的PsInitialSystemProcess 是一个指向system进程的EPROCESS全局变量
- 其他在注册系统回调时需要用到的结构体

```c
//申请空间的标签
#define DRIVER_TAG 'zk14'

//链表用于记录所有被触发回调的进程或线程信息
LIST_ENTRY  g_OperationListHead;
FAST_MUTEX  g_OperationListLock;//给 g_OperationListHead链表  加的同步手段 互斥体

//内核获取系统启动计数
ULONG MyGetTickCount()
{
    LARGE_INTEGER la;
    ULONG MyInc;
    MyInc = KeQueryTimeIncrement(); //返回滴答数频率
    //下方 KeQueryTickCount 的宏的原型.
    KeQueryTickCount(&la);
    la.QuadPart *= MyInc;
    la.QuadPart /= 10000;
    return la.LowPart;

}

// 是否自己目标的进程 可以过保护(暂时写死)
#define TARGETPROCESSNAME "driverTest.exe"
BOOLEAN IsMyProcess()
{
    PEPROCESS Process = NULL;
    Process = PsGetCurrentProcess();
    //KeQuerySystemTime(1);
    if (_strnicmp(TARGETPROCESSNAME, PsGetProcessImageFileName(Process), strlen(TARGETPROCESSNAME)) == 0)
    {
        return TRUE;// OB_PREOP_SUCCESS;
    }
    else
    {
        return FALSE;
    }
}

//最后一个自定义回调函数,用于恢复权限  
//APC_LEVEL=1;
OB_PREOP_CALLBACK_STATUS Last_CallBack(IN PVOID RegistrationContext, IN POB_PRE_OPERATION_INFORMATION OperationInformation)
{
    PLIST_ENTRY ListEntry;
    UNREFERENCED_PARAMETER(RegistrationContext);

    if (IsMyProcess())
    {

        ExAcquireFastMutex(&g_OperationListLock);//获取同步所有权
        for (ListEntry = g_OperationListHead.Flink; ListEntry != &g_OperationListHead; ListEntry = ListEntry->Flink)
        {
            POPERATION_INFO_ENTRY Entry = (POPERATION_INFO_ENTRY)ListEntry;
            if (Entry->Operation == OperationInformation->Operation &&
                Entry->Flags == OperationInformation->Flags &&
                Entry->Object == OperationInformation->Object &&
                Entry->ObjectType == OperationInformation->ObjectType)
            {
                ULONG32 newAccess = OperationInformation->Parameters->CreateHandleInformation.DesiredAccess;
                ULONG32 oldAccess = Entry->AccessMask;
                KdPrint(("zeroko:kernel: Last_CallBack  PID=%d <原权限=%llX,新权限=%llX>----->time=%llX line=%d\n",
                    (ULONG64)PsGetCurrentProcessId(),
                    (ULONG64)(Entry->AccessMask),//原权限
                    (ULONG64)newAccess,
                    (ULONG64)Entry->time, (ULONG64)__LINE__)); //新权限
                //恢复权限
                OperationInformation->Parameters->CreateHandleInformation.DesiredAccess = Entry->AccessMask;    //恢复权限请求OpenProcess
                OperationInformation->Parameters->DuplicateHandleInformation.DesiredAccess = Entry->AccessMask; //恢复权限请求 DuplicateHandle
                //移出结点
                RemoveEntryList(&Entry->ListEntry);
                //释放空间
                ExFreePoolWithTag(Entry, DRIVER_TAG);
                goto Release;
            }
        }
    Release:
        ExReleaseFastMutex(&g_OperationListLock);//释放同步所有权
        //ok
    }

    return OB_PREOP_SUCCESS;
}

//第一个自定义回调,做记录信息工作,方便最后的回调恢复
OB_PREOP_CALLBACK_STATUS First_CallBack(IN PVOID RegistrationContext, IN POB_PRE_OPERATION_INFORMATION OperationInformation)
{
    POPERATION_INFO_ENTRY NewEntry = NULL;

    //ntoskrnl.exe导出的PsInitialSystemProcess 是一个指向system进程的EPROCESS,如果是他则跳过
    if (PsGetCurrentProcess() == PsInitialSystemProcess)
        return OB_PREOP_SUCCESS;

    //如果是线程回调的话跳过
    if (OperationInformation->ObjectType == PsThreadType)
        return OB_PREOP_SUCCESS;

    //判断打开进程是否为目标进程
    if (IsMyProcess())
    {
        //申请空间
        NewEntry = (POPERATION_INFO_ENTRY)ExAllocatePoolWithTag(NonPagedPool, sizeof(OPERATION_INFO_ENTRY), DRIVER_TAG);
        //记录数据
        if (NewEntry)
        {
            NewEntry->Operation = OperationInformation->Operation;
            NewEntry->Flags = OperationInformation->Flags;
            NewEntry->Object = OperationInformation->Object;
            NewEntry->ObjectType = OperationInformation->ObjectType;
            //保存请求的权限 防止被保护回调 修改 DuplicateHandle OpenProcess
            NewEntry->AccessMask = 0x1fffff;//OperationInformation->Parameters->CreateHandleInformation.DesiredAccess; /// Same for duplicate handle   1fffff表示全部权限,实际上FFFF就已经是全部全新了
            NewEntry->time = MyGetTickCount();// KeQuerySystemTime(1);

            ExAcquireFastMutex(&g_OperationListLock);//同步快速互斥体 获取所有权
            //回调的各种数据插入链表
            InsertTailList(&g_OperationListHead, &NewEntry->ListEntry);//保存节点
            KdPrint(("zeroko:kernel:First_CallBack   保存权限=%llX PID=%d time=%llX line=%lld\n",
                (ULONG64)OperationInformation->Parameters->CreateHandleInformation.DesiredAccess,//原权限 保存
                (ULONG64)PsGetCurrentProcessId(),
                (ULONG64)NewEntry->time,
                (ULONG64)__LINE__));
            ExReleaseFastMutex(&g_OperationListLock);//同步快速互斥体 释放所有权
        }
    }

    UNREFERENCED_PARAMETER(RegistrationContext);//避免未使用参数的警告,可有可无
    return OB_PREOP_SUCCESS;
}

//记录系统回调的句柄,用于卸载
PVOID       g_UpperHandle = NULL;
PVOID       g_LowerHandle = NULL;

//Last_CallBack和First_CallBack是自定义回调函数
OB_OPERATION_REGISTRATION ObUpperOperationRegistration[] =
{
    { NULL, OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE, First_CallBack, NULL },//进程的
    { NULL, OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE, First_CallBack, NULL },//线程的
};

OB_OPERATION_REGISTRATION ObLowerOperationRegistration[] =
{
    { NULL, OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE, Last_CallBack, NULL },//进程的
    { NULL, OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE, Last_CallBack, NULL },//线程的
};

// XignCode3 回调码 380800
// EAC       回调码 327530
// BE        回调码 363220
OB_CALLBACK_REGISTRATION UpperCallbackRegistration =
{
    OB_FLT_REGISTRATION_VERSION,
    2,
    RTL_CONSTANT_STRING(L"880000"),//高的
    NULL,
    ObUpperOperationRegistration
};

OB_CALLBACK_REGISTRATION LowerCallcackRegistration =
{
    OB_FLT_REGISTRATION_VERSION,
    2,
    RTL_CONSTANT_STRING(L"10000"),//低的
    NULL,
    ObLowerOperationRegistration
};
```



#### 接口函数

- 安装系统回调的 `ObRegisterCallBacksInitBreakProtect`
-  卸载系统回调的 `ObRegisterUnload`

```c
void ObRegisterUnload()
{
    if (NULL != g_LowerHandle)
        ObUnRegisterCallbacks(g_LowerHandle);
    if (NULL != g_UpperHandle)
        ObUnRegisterCallbacks(g_UpperHandle);
    while (!IsListEmpty(&g_OperationListHead))
        ExFreePoolWithTag(RemoveHeadList(&g_OperationListHead), DRIVER_TAG);
}

BOOLEAN ObRegisterCallBacksInitBreakProtect()
{
    NTSTATUS Status = STATUS_SUCCESS;
    

    ////解锁使用限制  (添加参数PDRIVER_OBJECT pDriverObject)
    // PLDR_DATA ldr;
    //ldr = (PLDR_DATA)pDriverObject->DriverSection;
    //ldr->Flags |= 0x20;

    InitializeListHead(&g_OperationListHead);//初始化链表头
    ExInitializeFastMutex(&g_OperationListLock);//初始化快速互斥体

    ObUpperOperationRegistration[0].ObjectType = PsProcessType;//针对进程回调
    //新添加的
    ObUpperOperationRegistration[0].Operations = OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE;

    ObUpperOperationRegistration[1].ObjectType = PsThreadType;//针对线程回调
    //新添加的
    ObUpperOperationRegistration[1].Operations = OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE;
    Status = ObRegisterCallbacks(&UpperCallbackRegistration, &g_UpperHandle);
    if (!NT_SUCCESS(Status))
    {
        g_UpperHandle = NULL;
        goto Exit;
    }

    ObLowerOperationRegistration[0].ObjectType = PsProcessType;//针对进程回调
    //新添加的
    ObLowerOperationRegistration[0].Operations = OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE;

    ObLowerOperationRegistration[1].ObjectType = PsThreadType;//针对线程回调
    //新添加的
    ObLowerOperationRegistration[1].Operations = OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE;
    Status = ObRegisterCallbacks(&LowerCallcackRegistration, &g_LowerHandle);
    if (!NT_SUCCESS(Status))
    {
        g_LowerHandle = NULL;
        goto Exit;
    }

Exit:
    if (!NT_SUCCESS(Status))
        ObRegisterUnload();

    return NT_SUCCESS(Status) ? TRUE : FALSE;
}
```

安装过保护后,遍历系统回调如下:

![foreach](https://raw.githubusercontent.com/che77a38/blogImage2/main/202205292047586.jpeg)

tp刚开始可以读取,但是过了一会儿又不能访问了,很可能tp有遍历句柄表,找谁打开了自己的句柄,就释放掉.

## 句柄表遍历相关

### R3句柄遍历

- `NtQuerySystemInformation`   遍历句柄
- `NtQueryInformationProcess`   句柄转pid
- `NtQueryObject`     获取句柄信息   类型   名字
- `DuplicateHandle`   把目标进程的句柄复制到当前进程,类似于内存映射

[NtQuerySystemInformation遍历句柄]: https://docs.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntquerysysteminformation

















# 完整项目参考

```c

```

# 一些名词理解

**PG/过PG/KPP/DSE/过DSE/内核越狱/免签加载驱动/API(MSG)HOOK名词理解**

- KPP：内核补丁保护，详见http://en.wikipedia.org/wiki/Kernel_Patch_Protection
- PG：基本可以认为和KPP是一个意思。PatchGuard（正名Kernel Patch Protection）相当于“哨兵”，它的功能是不定时地“巡逻”，检查重要的内核数据结构有没有被篡改，发现篡改就立刻触发蓝屏（也就是Bugcheck 109，CRITICAL_STRUCTURE_CORRUPTION）。
- 过PG：让PG无法工作，或工作无效。方法基本分为两类，动态（无需重启，重启后失效）和静态（需要重启，重启后一直生效）。
- DSE：数字签名强制。全名driver signature enforcement，可以简单理解为“驱动文件必须包含正确的交叉签名”。DSE（Driver Signature Enforcement）相当于“守门员”，在驱动加载前检查数字签名是否有效，无效则拒绝加载进内核；
- 过DSE：让DSE机制无法工作，或工作无效。方法基本分为两类，动态（无需重启，重启后失效）和静态（需要重启，重启后一直生效）。
- 免签加载驱动：就是加载一个无签名，或签名无效的驱动。
- 内核越狱：可以简单理解为｛过PG+过DSE｝。
- 关于HOOK：MESSAGE HOOK是RING3的HOOK，所有RING3的HOOK（包括RING3 IAT/EAT/INLINE HOOK）都不被PG限制。RING0里对关键模块（包括但不限于NTOSKRNL.EXE、HAL.DLL、NDIS.SYS等）以及一些关键的表（包括但不限于SSDT、IDT、PsActiveProcessLinks等）的任何修改，都不被PG所允许。

要加载驱动，需要先pass掉DSE，进了内核以后，再看情况考虑要不要干掉PG……

**不重启禁用/绕过DSE的方法：**

不支持重启的方法:

1.在内存中修改全局变量g_CiEnabled（也就是所谓的flag？）

[DSEFix - Defeating x64 Driver Signature Enforcement](https://link.zhihu.com/?target=http%3A//www.kernelmode.info/forum/viewtopic.php%3Ff%3D11%26t%3D3322)

需要一个有**任意内存读写/执行漏洞**的**有合法签名的驱动**先被加载进内核，然后可以利用漏洞完成修改。**修改完DSE就被关闭了。**

也有带合法签名的驱动直接实现了这个功能，比如WIN64AST这个小工具就有关闭DSE的功能。

缺点：修改会被不定时运行的**PatchGuard**检测到，**一旦被检测到就会立刻蓝屏**。

可以在要加载驱动时先修改flag来禁用DSE，然后抓紧时间加载驱动，加载完成后再立刻把flag改回去，这样可以大大降低蓝屏的概率。

2.不使用正常的驱动加载途径，使用自己编写的shellcode加载

[hfiref0x/TDL](https://link.zhihu.com/?target=https%3A//github.com/hfiref0x/TDL)

**同样需要一个有合法签名的驱动先被加载**，然后利用这个驱动（**可能是利用bug，也可能是驱动自己实现的功能**）来完成无签名驱动的加载。

这个方法的优点是**不会触发PatchGuard**，但缺点也很明显：被加载的驱动需要被特殊设计，加载后不支持卸载，不支持SEH，函数导入不正常……**限制很多**

[过保护更多了解]: https://www.zhihu.com/question/49451179

**VT技术过PG**

驱动开发小技巧:

```c
#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0)
//用于判断返回值
```

[驱动层真正完美的隐藏内存]: https://bbs.pediy.com/thread-265189.htm

### 签名相关

[无签名加载驱动]: https://www.freebuf.com/articles/paper/281035.html

目前默认的证书签名算法都是sha-256，通过申请的证书可以使用工具进行双签名，给应用程序或驱动签名的摘要算法就是sha1和sha256，但签发的证书本身签名算法是sha-256，可以通过所以在旧版的操作系统中会出现驱动类文件不兼容。目前在旧版操作系统的内核驱动签名不支持单证书双签名，普通应用程序则支持单证书双签名。

对于内核驱动签名，如果要实现双签名，例如同时在Windows 7 和 Windows 10 上运行，Windows 10则要求使用sha-256的签名算法创建签名，但是Windows 7的内核驱动签名则需要使用sha-1来实现。也就是说**对于内核驱动的签名，需要同时购买EV代码签名证书和标准签名证书来实现内核驱动的双签名**。对于普通的应用程序可以使用一张证书来双签名实现兼容性。

#### 签名工具使用

先添加签名规则,再给文件签名.

[签名证书原理]: https://zhuanlan.zhihu.com/p/403704980

# 64位16进制字符串操作

```c
//十六进制字符串转十六进制数字
ULONG_PTR ulModBase  = 0;
#if defined(_WIN64)
    ulModBase            = _tcstoui64(strParam,NULL,16);
#else
    ulModBase            = _tcstoul(strParam,NULL,16);
#endif
//上面的strParam是wchar*类型的
```

**[printf的64位16进制输出格式]**为 `%016I64x`  0表示用0填充空白位置,16表示16个字符,I64表示64位,%x表示输出16进制数

# 设定驱动和用户层相接数据结构

```c
//类似如下方式,统一内存对齐最稳妥
//当然也可以按照64位默认的8字节对齐,但用户层和内存层都必须是64位
#pragma pack(push)
#pragma pack(8)
typedef struct TINPUT_BUF
{
	UINT64 dwPid;
  PVOID PBase;
  UINT64 nSize;
}
#pragma pack(pop)
```

