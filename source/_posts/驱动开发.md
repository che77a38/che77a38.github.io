---
title: 驱动开发
tags: 内核相关
categories: 技术


---

# 驱动开发

## 准备工作

[环境配置参考](https://blog.csdn.net/newnewman80/article/details/90754999)

<!-- more -->

创建**Empty WDM Driver**项目，生成的Driver Files文件中的**inf后缀文件**可以直接删除

在源文件中添加的必须是.c后缀的C语言文件。

项目配置中：

1. 属性-C/C++中`将警告视为错误`选项设置为否
2. 属性-链接器中`将链接器警告视为错误`设为否

由于使用的是windowsXP作为开发环境，所以要**针对windowsXP进行项目配置，参考链接**：[开发各平台驱动的设置参考](https://blog.csdn.net/Kwansy/article/details/111051265)



**驱动的开发流程：**

编写代码->生成.sys文件->部署->启动->停止->卸载

驱动程序的测试最好在**虚拟机中**测试，因为一出问题就蓝屏

**DebugView**软件监视选项中要选上**监视核心**

驱动开发的调试：双机调试

## PDB（Program Debug Database）

什么是PDB文件？

1. PDB文件是在我们编译工程的时候产生的，它是和对应的模块(exe或dll)一起生成出来的。
2. 每个模块编译的时候都可以生成自己的PDB文件。比如.exe/.dll/.sys等等。

PDB文件对应上了位置和函数名。

**windbg如何找到PDB文件？**

```assembly
SRV*D:\Symbols\XP*http://msdl.microsoft.com/download/symbols
;上面可以在后面添加;继续添加本地地址，比如SRV*D:\Symbols\XP*http://msdl.microsoft.com/download/symbols；D:\Symbols
;D:\Symbols\XP是本地路径，
;http://msdl.microsoft.com/download/symbols是网络路径
kd>.reload
;让windbg重新加载PDB
```

**MSB8040错误**

```cpp
 error MSB8040: 此项目需要缓解了 Spectre 漏洞的库。
```

在属性-常规-输出目录-宏中搜索14：

![image-20210825204301335](https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20210825204301335.png)

确定需要的是14.29版本

![image-20210825204450485](https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20210825204450485.png)

Visual Studio Installer的单个组件中搜索14.29，将黄标全部勾选，点击修改。问题解决！

##  第一个驱动程序

```c
#include <ntddk.h>

//卸载函数
VOID DriverUnload(PDRIVER_OBJECT driver)
{
	DbgPrint("停止运行了\n");
}

//入口函数，相当于main函数
NTSTATUS DriverEntry(PDRIVER_OBJECT pdriver, PUNICODE_STRING pReg)
{
	//驱动程序的入口
	DbgPrint("hello world!\n");
	DbgPrint("pdriver:%wZ\r\n",pReg);
	DbgPrint("pReg:%X\r\n",pdriver);
	//设置一个卸载函数，用于退出
	pdriver->DriverUnload = DriverUnload;
	return STATUS_SUCCESS;
}
```

![image-20210825212547927](https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20210825212547927.png)

windbg中可以使用dt命令查看对应数据结构的数据

## 内核编程基础

### 内核API的使用

1. 在应用层编程我们可以使用WINDOWS提供的各种API函数，只要导入头文件<windows.h>就可以了，但是在内核编程的时候，我们不能像Ring3那样直接使用。微软为内核提供了专门的API，只要在程序中包含相应的头文件就可以使用了，如：#include<ntddk.h>(假设你已经正确安装了WDK)
2. 在应用层编程的时候，我们通过MSDN来了解函数的详细信息，在内核编程的时候，要使用WDK自己的帮助文档。

### 未导出函数的使用

内核函数有三种

1. 有一些是文档有写，也导出了的函数
2. 有一些是文档没写，但导出了的函数
3. 还有一些是文档没写，也没导出的函数，通过自己特征码定位CALL的位置，手动调用

WDK说明文档只包含了内核模块导出的函数，对于未导出的函数，则不能直接使用

如果要使用未导出的函数，只要自己定义一个函数指针，并且为函数指针提供正确的函数地址就可以使用了。有两种办法都可以获取为导出的函数地址：

1. 特征码搜索
2. 解析内核PDB文件

### 基本数据类型

在内核编程的时候，强烈建议大家遵守WDK的编码习惯，不要这么写：unsigned long length；

习惯使用WDK自己的类型：

| WDK的类型 | 含义           |
| --------- | -------------- |
| ULONG     | unsigned long  |
| PULONG    | unsigned long* |
| UCHAR     | unsigned char  |
| PUCHAR    | unsigned char* |
| UINT      | unsigned int   |
| PUNIT     | unsigned int*  |
| VOID      | void           |
| PVOID     | void*          |

### 返回值

大部分内核函数的返回值都是NTSTATUS类型，如：

```c
NTSTATUS PsCreateSystemThread();
NTSTATUS ZwOpenProcess();
NTSTATUS ZwOpenEvent();
```

这个值能说明函数执行的结果，比如：

| 返回宏                        | 代表数值   | 含义                                                         |
| ----------------------------- | ---------- | ------------------------------------------------------------ |
| STATUS_SUCCESS                | 0x00000000 | 成功                                                         |
| STATUS_INVALID_PARAMETER      | 0xC000000D | 参数无效(这个错误出现往往代表出现了很多错误，因此不代表任何意义) |
| STATUS_BUFFER_OVERFLOW        | 0x80000005 | 缓冲区长度不够                                               |
| STATUS_PENDING                |            | 不能算作一个错误，只是文件传输请求未决(异步)                 |
| STATUS_INSUFFICIENT_RESOURCES |            | 资源调用错误                                                 |

当你调用的内核函数，如果返回的结果不是STATUS_SUCCESS，就说明函数执行中遇到了问题，具体是什么问题，可以在ntstatus.h文件中查看。

### 内核函数中的异常处理

**意义不大，该蓝屏还是蓝屏**

在内核中，一个小小的错误就可能导致蓝屏，比如：读写一个无效的内存地址。为了让自己的内核程序更加健壮，强烈建议大家在编写内核程序时，使用异常处。

Windows提供了机构化异常处理机制，一般的编译器都是支持的，如下：

```c
__try{
    //可能出错的代码
}
__except(filter_value){
    //出错时要执行的代码
}
```

出现异常时，可根据filter_value的值来决定程序该如何执行，当filter_value的值为：

| filter_value                     | 含义                                 |
| -------------------------------- | ------------------------------------ |
| EXCEPTION_EXECUTE_HANDLER(1)     | 代码进入except块                     |
| EXCEPTION_CONTINUE_SEARCH(0)     | 不处理异常，由上一层调用函数处理     |
| EXCEPTION_CONTINUE_EXECUTION(-1) | 回去继续执行错误处的代码(基本用不到) |

### 常用的内核内存函数

对内核的使用，主要就是：申请，设置，拷贝以及释放。

| C语言            | 内核中         |
| ---------------- | -------------- |
| malloc           | ExAllocatePool |
| memset(内核可用) | RtlFillMemory  |
| memcpy(内核可用) | RtlMoveMemory  |
| free             | ExFreePool     |

ExAllocatePool已被淘汰，取而代之的是[ExAllocatePoolWithTag](https://docs.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/nf-wdm-exallocatepoolwithtag)

后又在 Windows 10 版本 2004 中被弃用，并已被[ExAllocatePool2](https://docs.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/nf-wdm-exallocatepool2)取代

### 内核字符串种类

- CHAR（char）
- WCHAR（wchar_t）
- ANSI_STRING
- UNICODE_STRING

```c
//ANSI_STRING字符串：
typedef struct _STRING
{
    USHORT Length;//当前字符串的长度
    USHORT MaximumLength;//最大长度
    PCHAR Buffer;//指针
}STRING;

//UNICODE_STRING字符串：
typedef struct _UNICODE_STRING
{
    USHORT Length;
    USHORT MaximumLength;
    PWCHAR Buffer;
}UNICODE_STRING;


UNICODE_STRING abc=RTL_CONSTANT_STRING(L"Hello World!");//要放在全局
DbgPrint("%wZ",&abc);
```

内核中字符串尽量用ANSI_STRING字符串和UNICODE_STRING字符串，通过这种方法能避免使用0结尾，读字符串的时候读Length个字符就可以了，防止访问0蓝屏。

内核字符串常用函数

| ANSI_STRING字符串            | UNICODE_STRING字符串                                    | 含义           |
| ---------------------------- | ------------------------------------------------------- | -------------- |
| RtlInitAnsiString            | RtlInitUnicodeString                                    | 创建字符串     |
| RtlCopyString                | RtlCopyUnicodeString                                    | 复制字符串     |
| RtlCpmpareString             | RtlCpmpareUnicodeString                                 | 比较字符串     |
| RtlAnsiStringToUnicodeString | RtlUnicodeStringToAnsiString                            | 字符串转换     |
| RtlAppendStringToString      | RtlAppendUnicodeToString/RtlAppendUnicodeStringToString | 字符串拼接     |
| RtlFreeAnsiString            | RtlFreeUnicodeString                                    | 销毁字符串     |
| RtlUpperString               | RtlUpcaseUnicodeString                                  | 转换成大写     |
| RtlEqualString               | RtlEqualUnicodeString                                   | 字符串是否相等 |

DbgPrint函数打印字符串：

| 符号    | 格式说明符              | 类型          |
| ------- | ----------------------- | ------------- |
| %c, %lc | ANSI字符                | char          |
| %C, %wc | 宽字符                  | wchar_t       |
| %d, %i  | 十进制有符号整数        | int           |
| %D      | 十进制_int64            | _int64        |
| %L      | 十六进制的LARGE_INTEGER | LARGE_INTEGER |
| %s, %ls | NULL终止的ANSI字符串    | char*         |
| %S, %ws | NULL终止的宽字符串      | wchar_t*      |
| %Z      | ANSI_STRING字符串       |               |
| %wZ     | UNICODE_STRING字符串    |               |
| %u      | 十进制的ULONG           | ULONG         |
| %x      | 小写字符十六进制的ULONG | ULONG         |
| %X      | 大写字符十六进制的ULONG | ULONG         |
| %p      | 指针Pointer 32/64位     |               |

根据DDK上说明,Unicode格式(%C, %S, %lc, %ls, %wc, %ws, and %wZ)只能在 IRQL = PASSIVE_LEVEL时才能使用.

### 常用的其他内核API函数

| 函数                                | 含义                                                     |
| ----------------------------------- | -------------------------------------------------------- |
| ExAcquireFastMutex                  | 获取一个快速互斥体，用于多线程环境下的同步               |
| ExReleaseFastMutex                  | 快速释放一个互斥体                                       |
| ExRaiseStatus                       | 抛出一个异常，带有一个status值的，代码很深的地方直接报错 |
| ZwCreateFile                        | 创建文件                                                 |
| ZwWriteFile                         | 写入文件                                                 |
| ZwReadFile                          | 读取文件                                                 |
| ZwQueryDirctory                     | 查询目录文件                                             |
| ZwDeviceIoControlFile               | 创建设备io文件                                           |
| ZwCreateKey                         | 创建注册表的键                                           |
| ZwQueryValueKey                     | 创建注册表的键值                                         |
| IoCreateFile                        | 创建文件，比ZwCreateFile更加底层                         |
| IoCreateDevice                      | 创建设备                                                 |
| IoCallDriver                        | 发送一个请求，实际上这个函数可能是由IofCallDriver别名    |
| IoCompleteRequest                   | 完成请求                                                 |
| IoCopyCurrentIrpStackLocationToNext | 将当前IRP请求的栈空间拷贝到下一个栈空间                  |
| IoSkipCurrentIrpStackLocationToNext | 跳过当前IRP栈空间                                        |
| IoGetCurrentIrpStackLocation        | 获得当前IRP栈空间指针                                    |

### IRQL中断请求级别

处理器在一个IRQL上执行线程代码。IRQL是帮助决定线程如何被中断的。**在同一处理器上，线程只能被更高级别IRQL的线程能中断**。每个处理器都有自己的中断IRQL。我们经常遇见的有四种IRQL级别。“Passive”, “APC”, “Dispatch” and “DIRQL”.

“DriverEntry”将会在PASSIVE_LEVEL被调用。

![image-20211109133128464](https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20211109133128464.png)

- **PASSIVE_LEVEL**

  IRQL最低级别,没有被屏蔽的中断，在这个级别上，线程执行用户模式，可以访问分页内存。

- **APC_LEVEL**

  在这个级别上,只有APC级别的中断被屏蔽，可以访问分页内存。当有APC发生时，处理器提升到APC级别，这样，就屏蔽掉其它APC，为了和APC执行 一些同步，驱动程序可以手动提升到这个级别。比如，如果提升到这个级别，APC就不能调用。在这个级别，APC被禁止了，导致禁止一些I/O完成APC， 所以有一些API不能调用。

  **阻止响应任何APC，而且线程不能被挂起（suspend），为什么不能被挂起？因为操作系统实现线程挂起的方式，就是递交 APC**

- **DISPATCH_LEVEL**

  这个级别，DPC(延迟过程) 和更低的中断被屏蔽，不能访问分页内存，所有的被访问的内存不能分页。因为只能处理分页内存，所以在这个级别，能够访问的Api大大减少。

- **DIRQL (Device IRQL)**

  通常处于高层次的驱动程序不会使用这个IRQL等级，在这个等级上所有的中断都会被忽略。这是IRQL的最高等级。通常使用这个来判断设备的优先级。
  一般的，更高级的驱动在这个级别上不处理IRQL，但是几乎所有的中断被屏蔽，这实际上是IRQL的一个范围，这是一个决定某个驱动有更高的优先级的方法。











### 驱动内核框架

#### Windows的驱动开发模型变迁

- vxd(windows98)
- kdm(windows98~windows2000)
- wdm(再之后)
- wdf(进一步原有基础上封装了一套更简单的API，现在)

#### 内核编程的主要调用源：

1. 入口函数 DriverEntry 和 卸载函数 DriverUnload（单线程环境）
2. 各种分发函数（多线程环境，可以和DriverUnload并发，无法和DriverEntry并发）
3. 处理请求时设置的完成函数（多线程环境）
4. 其他回调函数  ndis（网络相关）（多线程环境）

#### 函数的多线程安全性

1. 可能运行于多线程环境的函数，必须是多线程安全的，只运行于单线程环境的函数，则不需要多线程安全性
2. 如果函数A的所有调用源只运行于同一单线程环境，则函数A也是只运行在单线程环境下。
3. 如果函数A的其中一个调用源是可能运行在多线程环境下的，或者多个调用源可能运行于不同的可并发的多线程环境，而且调用路径上没有采取多线程序列化成单线程的强制措施，则函数A也是可能运行在多线程环境的。
4. 如果函数A所有可能运行于多线程环境的调用路径上，都有多线程序列化成单线程的强制措施，则函数A是运行于单线程环境的。
5. 只使用函数内部资源的，完全不使用全局变量，静态变量或其他全局性资源的函数是多线程安全的。
6. 如果对某个全局变量或者静态变量的所有访问都被强制的同步手段限制为同一时刻只有一个线程访问，则即使使用了这些全局变量或静态变量，对函数的多线程安全性也是没有影响的。

| 调用源                   | 运行环境 | 原因                                                         |
| ------------------------ | -------- | ------------------------------------------------------------ |
| DriverEntry/DriverUnload | 单线程   | 这两个函数由系统集成的单一线程调用。不会出现多线程同时调用的情况 |
| 各种分发函数             | 多线程   | 没有任何文档保证分发函数是不会被多线程同时调用的。此外，分发函数是不会和DriverEntry并发，但可能和DriverUnload并发 |
| 完成函数                 | 多线程   | 完成函数随时可能被未知的线程调用                             |
| 各种NDIS回调函数         | 多线程   | 同上                                                         |
|                          |          |                                                              |

#### 代码的中断级

win32编程是没有中断级这个概念的，但是在内核编程中是有中断级的概念的，我们的程序好像是并发的，但其实是有优先级的，就是中断级

- passive
- dispatch

规则：

1. 如果在调用路径上没有特殊情况（导致中断级的提高或降低），则一个函数执行时的中断和它的调用源的中断级相同
2. 如果在调用路径上有获取自旋锁，则中断级随之升高；如果调用路径上有释放自旋锁，则中断级随之下降。

| 调用源                   | 一般运行中断级 |
| ------------------------ | -------------- |
| DriverUnload/DriverEntry | Passive级      |
| 各种分发函数             | Passive级      |
| 完成函数                 | Dispatch级     |
| 各种NDIS回调函数         | Dispatch级     |

#### WDK中出现的特殊代码

##### IN和OUT

```c
#define IN
#define OUT
```

空定义，只是作为提示函数中参数时输入还是输出的

##### [#pragma alloc_text](https://blog.csdn.net/analogous_love/article/details/47274559)

有时，驱动程序的某些部分必须驻留内存而另一些可以被分页，这就需要一种能控制代码和数据是否分页的方法。通过指导编译器的段分配可以实现这个目的。

#pragma alloc_text：**把驱动程序的单独例程放到特定段中。**

使编译器把代码放到特定段的传统方法是使用alloc_text编译指示。但不是每种编译器都支持这个编译指示

```c
#pragma alloc_text(PAGE, a)
#pragma alloc_text(PAGE, b)
//表示函数a和b都运行在分页内存中，就是有可能被交换到分页池中，程序中一些高等级，例如dispatch 级别的代码当然不能运行在分页内存，这样往往出现BSOD
//如果没有上述指令，则默认位于PAGELK这个节，即不会把内存放入硬盘。
```

**\#pragma alloc_text使用注意**

1. 该编译指示必须跟在函数声明后面而不能在前面。你可以把驱动程序中的所有函数集中到一个头文件中，并在包含该头文件的源文件中，在#include语句的后面使用alloc_text。
2. 该编译指示仅能用于有C连接形式的函数。即，它不能用于类成员函数或 C++源文件中未用extern “C”声明的函数。

```c
#pragma alloc_text(INIT,DriverEntry)//某些代码在驱动程序完成初始化后不再需要，可以直接把它插入到INIT段。
```









## 内核空间与内核模块

### 内核空间

![image-20210826200041917](https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20210826200052881.png)

**内核空间中的地址在各个进程中都是一样的。**

内核模块定义全局变量：可在不同进程中查看

**windbg进入对应进程的进程空间**：

```c
kd>!process 0 0//罗列出来的进程信息枚举，将PROCESS后接的地址放入下面的命令
kd>.process XXXXXXXX(上面获取到的地址)
//转到了对应进程的内存空间
```

### 内核模块

![image-20210826200052881](https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20210826200052881.png)

1. 硬件种类繁多，不可能做一个兼容所有硬件的内核，所以，微软提供规定的接口格式，让硬件驱动人员按照规定的格式编写“驱动程序”。
2. 这些驱动程序每一个都是一个模块，称为“内核模块”，都可以加载到内核中，**都遵守PE结构**。本质上讲，任意一个.sys文件与内核文件没有区别。

#### DRIVER_OBJECT结构体

定义在wdm.h中。

每个内核模块都有一个对应的结构体，来描述这个模块在内核中的各种信息：位置、大小、名称等等。

```c
kd> dt _DRIVER_OBJECT
nt!_DRIVER_OBJECT
   +0x000 Type             : Int2B//类型
   +0x002 Size             : Int2B//大小
   +0x004 DeviceObject     : Ptr32 _DEVICE_OBJECT//设备对象，这里实际上是一个设备对象的链表的开始。因为DeviceObject中有相关链表信息
   +0x008 Flags            : Uint4B
   +0x00c DriverStart      : Ptr32 Void//驱动被加载到什么地方了，即内核模块的起始地址
   +0x010 DriverSize       : Uint4B//该驱动内核模块的大小
   +0x014 DriverSection    : Ptr32 Void//指向当前驱动的_LDR_DATA_TABLE_ENTRY结构体的指针
   +0x018 DriverExtension  : Ptr32 _DRIVER_EXTENSION//热拔插会用到的相关信息
   +0x01c DriverName       : _UNICODE_STRING//驱动的名字
   +0x024 HardwareDatabase : Ptr32 _UNICODE_STRING//注册表
   +0x028 FastIoDispatch   : Ptr32 _FAST_IO_DISPATCH//某派遣函数，快速IO分发函数
   +0x02c DriverInit       : Ptr32     long //初始化派遣函数
   +0x030 DriverStartIo    : Ptr32     void //某派遣函数
   +0x034 DriverUnload     : Ptr32     void //驱动卸载派遣函数
   +0x038 MajorFunction    : [28] Ptr32     long //包含28个派遣函数地址
       //0编号的IRP对应的派遣函数的地址就存在MajorFunction[0]的位置。
////////////////////////////////_DRIVER_EXTENSION///////////////////////////
ntdll!_DRIVER_EXTENSION//热拔插驱动相关的
   +0x000 DriverObject     : Ptr32 _DRIVER_OBJECT
   +0x004 AddDevice        : Ptr32     long 
   +0x008 Count            : Uint4B
   +0x00c ServiceKeyName   : _UNICODE_STRING
   +0x014 ClientDriverExtension : Ptr32 _IO_CLIENT_EXTENSION
   +0x018 FsFilterCallbacks : Ptr32 _FS_FILTER_CALLBACKS
```

![image-20210828154104796](https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20210828154104796.png)

![image-20210828154124934](https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20210828154124934.png)

Type，Flags，MajorFunction等等，因为他们是固有特征，尽可能隐藏特征，因为内核文件已经加载到内存里了，所以即使修改了，也不影响正常运行。

#### _LDR_DATA_TABLE_ENTRY结构体

```c
//所有内核模块的双向链表
kd> dt _LDR_DATA_TABLE_ENTRY
nt!_LDR_DATA_TABLE_ENTRY
   +0x000 InLoadOrderLinks : _LIST_ENTRY//初始化顺序双向链表
   +0x008 InMemoryOrderLinks : _LIST_ENTRY
   +0x010 InInitializationOrderLinks : _LIST_ENTRY
   +0x018 DllBase          : Ptr32 Void//内核模块的起始地址
   +0x01c EntryPoint       : Ptr32 Void
   +0x020 SizeOfImage      : Uint4B//内核模块的大小
   +0x024 FullDllName      : _UNICODE_STRING//完整的内核模块名，实际上就是全路径
   +0x02c BaseDllName      : _UNICODE_STRING//只有内核模块名，如：xxx.sys
   +0x034 Flags            : Uint4B
   +0x038 LoadCount        : Uint2B
   +0x03a TlsIndex         : Uint2B
   +0x03c HashLinks        : _LIST_ENTRY
   +0x03c SectionPointer   : Ptr32 Void
   +0x040 CheckSum         : Uint4B//校验和
   +0x044 TimeDateStamp    : Uint4B
   +0x044 LoadedImports    : Ptr32 Void
   +0x048 EntryPointActivationContext : Ptr32 Void
   +0x04c PatchInformation : Ptr32 Void
```

![image-20210828154334924](https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20210828154334924.png)

\_DRIVER_OBJECT结构可以通过DriverSection找到记录所有内核模块简单信息的双向链表，但双向链表没法找回\_DRIVER_OBJECT结构。因此即使是在双向链表中将目标驱动断链了，对于pchunter也依然能找到内核对象，原因是因为pchunter是通过特征码直接索引到\_DRIVER_OBJECT结构来遍历所有内核模块，而非通过该双向链表

### 遍历内核模块作业

**驱动对象遍历，模块隐藏（断链）**

```c
#include <ntddk.h>

unsigned int OldDriverSection= 0;//保存原DriverSection

//卸载函数
VOID DriverUnload(PDRIVER_OBJECT driver)
{
	//恢复原链和原DriverSection
	if (OldDriverSection != 0)
	{
		//恢复原DriverSection
		unsigned int DriverSectionAddr = (unsigned int)driver + 0x014;
		*(unsigned int*)DriverSectionAddr = OldDriverSection;
		//恢复原链
		unsigned int currentIndex = *(unsigned int*)DriverSectionAddr;
		unsigned int lastIndex = *(unsigned int*)(currentIndex + 0x4);
		*(unsigned int*)lastIndex = currentIndex;
		*(unsigned int*)(*(unsigned int*)(currentIndex)+0x4) = currentIndex;

	}
	DbgPrint("停止运行了\n");
}

//内核对象链表遍历
VOID forEachDriverChain(PDRIVER_OBJECT pdriver)
{
	unsigned int DriverSection = (unsigned int)pdriver + 0x014;
	//DbgPrint("DriverSection:%X\n", DriverSection);
	unsigned int beginIndex = *(unsigned int*)DriverSection;
	unsigned int currentIndex = beginIndex;
	DbgPrint("----------------------------------------\r\n");
	do
	{
		PUNICODE_STRING BaseDllName = (PUNICODE_STRING)(currentIndex + 0x02c);
		DbgPrint("%wZ\r\n", BaseDllName);
		currentIndex=*(unsigned int*)currentIndex;

	} while (currentIndex != beginIndex);
	DbgPrint("----------------------------------------\r\n");
}
//内核对象链表断链
VOID BreakDriverChain(PDRIVER_OBJECT pdriver)
{
	unsigned int DriverSectionAddr = (unsigned int)pdriver + 0x014;
	//DbgPrint("DriverSection:%X\n", DriverSection);
	unsigned int currentIndex = *(unsigned int*)DriverSectionAddr;
	unsigned int lastIndex = *(unsigned int*)(currentIndex +0x4);
	*(unsigned int*)lastIndex = *(unsigned int*)(currentIndex);
	*(unsigned int*)(*(unsigned int*)(currentIndex)+0x4) = lastIndex;
	//修正原PDRIVER_OBJECT中的DriverSection指向前一个链表
	OldDriverSection = *(unsigned int*)DriverSectionAddr;
	*(unsigned int*)DriverSectionAddr = lastIndex;
}

//入口函数，相当于main函数
NTSTATUS DriverEntry(PDRIVER_OBJECT pdriver, PUNICODE_STRING pReg)
{
	//驱动程序的入口
	DbgPrint("hello world!\n");
	DbgPrint("pdriver:%wZ\r\n",pReg);
	DbgPrint("pReg:%p\r\n",pdriver);
	DbgPrint("hello world!\n");
	DbgPrint("===============断链前==============\n");
	forEachDriverChain(pdriver);
	BreakDriverChain(pdriver);
	DbgPrint("===============断链后==============\n");
	forEachDriverChain(pdriver);

	//设置一个卸载函数，用于退出
	pdriver->DriverUnload = DriverUnload;
	return STATUS_SUCCESS;
}
```

打印如下：

```c
hello world!
pdriver:\REGISTRY\MACHINE\SYSTEM\ControlSet002\Services\HelloWorld
pReg:81DDCD18
hello world!
===============断链前==============
----------------------------------------
HelloWorld.sys
(null)
ntoskrnl.exe
hal.dll
kdcom.dll
BOOTVID.dll
ACPI.sys
WMILIB.SYS
pci.sys
isapnp.sys
compbatt.sys
BATTC.SYS
intelide.sys
PCIIDEX.SYS
MountMgr.sys
ftdisk.sys
dmload.sys
dmio.sys
PartMgr.sys
vmci.sys
VolSnap.sys
vsock.sys
atapi.sys
disk.sys
CLASSPNP.SYS
fltMgr.sys
sr.sys
KSecDD.sys
Ntfs.sys
NDIS.sys
Mup.sys
agp440.sys
i8042prt.sys
kbdclass.sys
vmmouse.sys
mouclass.sys
serial.sys
serenum.sys
imapi.sys
cdrom.sys
redbook.sys
ks.sys
vmx_svga.sys
VIDEOPRT.SYS
usbuhci.sys
USBPORT.SYS
vmxnet.sys
es1371mp.sys
portcls.sys
drmk.sys
usbehci.sys
CmBatt.sys
intelppm.sys
fsvga.sys
audstub.sys
rasl2tp.sys
ndistapi.sys
ndiswan.sys
raspppoe.sys
raspptp.sys
TDI.SYS
psched.sys
msgpc.sys
ptilink.sys
raspti.sys
rdpdr.sys
termdd.sys
swenum.sys
update.sys
mssmbios.sys
NDProxy.SYS
usbhub.sys
USBD.SYS
gameenum.sys
Fs_Rec.SYS
Null.SYS
Beep.SYS
vga.sys
mnmdd.SYS
RDPCDD.sys
Msfs.SYS
Npfs.SYS
rasacd.sys
ipsec.sys
tcpip.sys
netbt.sys
ws2ifsl.sys
afd.sys
netbios.sys
vmhgfs.sys
rdbss.sys
mrxsmb.sys
Fips.SYS
ipnat.sys
Cdfs.SYS
wanarp.sys
usbccgp.sys
hidusb.sys
HIDCLASS.SYS
HIDPARSE.SYS
BTHUSB.sys
bthport.sys
mouhid.sys
vmusbmouse.sys
dump_atapi.sys
dump_WMILIB.SYS
win32k.sys
Dxapi.sys
watchdog.sys
dxg.sys
dxgthk.sys
vmx_fb.dll
rfcomm.sys
BthEnum.sys
bthpan.sys
ndisuio.sys
wdmaud.sys
sysaudio.sys
mrxdav.sys
vmmemctl.sys
srv.sys
HTTP.sys
Dbgv.sys
----------------------------------------
===============断链后==============
----------------------------------------
Dbgv.sys
(null)
ntoskrnl.exe
hal.dll
kdcom.dll
BOOTVID.dll
ACPI.sys
WMILIB.SYS
pci.sys
isapnp.sys
compbatt.sys
BATTC.SYS
intelide.sys
PCIIDEX.SYS
MountMgr.sys
ftdisk.sys
dmload.sys
dmio.sys
PartMgr.sys
vmci.sys
VolSnap.sys
vsock.sys
atapi.sys
disk.sys
CLASSPNP.SYS
fltMgr.sys
sr.sys
KSecDD.sys
Ntfs.sys
NDIS.sys
Mup.sys
agp440.sys
i8042prt.sys
kbdclass.sys
vmmouse.sys
mouclass.sys
serial.sys
serenum.sys
imapi.sys
cdrom.sys
redbook.sys
ks.sys
vmx_svga.sys
VIDEOPRT.SYS
usbuhci.sys
USBPORT.SYS
vmxnet.sys
es1371mp.sys
portcls.sys
drmk.sys
usbehci.sys
CmBatt.sys
intelppm.sys
fsvga.sys
audstub.sys
rasl2tp.sys
ndistapi.sys
ndiswan.sys
raspppoe.sys
raspptp.sys
TDI.SYS
psched.sys
msgpc.sys
ptilink.sys
raspti.sys
rdpdr.sys
termdd.sys
swenum.sys
update.sys
mssmbios.sys
NDProxy.SYS
usbhub.sys
USBD.SYS
gameenum.sys
Fs_Rec.SYS
Null.SYS
Beep.SYS
vga.sys
mnmdd.SYS
RDPCDD.sys
Msfs.SYS
Npfs.SYS
rasacd.sys
ipsec.sys
tcpip.sys
netbt.sys
ws2ifsl.sys
afd.sys
netbios.sys
vmhgfs.sys
rdbss.sys
mrxsmb.sys
Fips.SYS
ipnat.sys
Cdfs.SYS
wanarp.sys
usbccgp.sys
hidusb.sys
HIDCLASS.SYS
HIDPARSE.SYS
BTHUSB.sys
bthport.sys
mouhid.sys
vmusbmouse.sys
dump_atapi.sys
dump_WMILIB.SYS
win32k.sys
Dxapi.sys
watchdog.sys
dxg.sys
dxgthk.sys
vmx_fb.dll
rfcomm.sys
BthEnum.sys
bthpan.sys
ndisuio.sys
wdmaud.sys
sysaudio.sys
mrxdav.sys
vmmemctl.sys
srv.sys
HTTP.sys
----------------------------------------
停止运行了
```

由上面打印可知HelloWorld.sys成功被隐藏，但pchunter依然可以查找到我们的驱动

**真隐藏（pchunter无法找到）**

```c
#include <ntddk.h>
typedef struct _LDR_DATA_TABLE_ENTRY {
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	LIST_ENTRY InInitializationOrderLinks;
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	ULONG Flags;
	USHORT LoadCount;
	USHORT TlsIndex;
	union {
		LIST_ENTRY HashLinks;
		struct {
			PVOID SectionPointer;
			ULONG CheckSum;
		};
	};
	union {
		struct {
			ULONG TimeDateStamp;
		};
		struct {
			PVOID LoadedImports;
		};
	};
	struct _ACTIVATION_CONTEXT * EntryPointActivationContext;

	PVOID PatchInformation;

} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;

HANDLE hThread;

VOID DriverUnload(PDRIVER_OBJECT pDriver)
{
	KdPrint(("卸载的了"));
}

VOID threadRun(_In_ PVOID StartContext)
{
	KdPrint(("开始执行1\n"));
	LARGE_INTEGER times;
	times.QuadPart = -30 * 1000 * 1000;
	KeDelayExecutionThread(KernelMode, FALSE, &times);
	PDRIVER_OBJECT pDriver = (PDRIVER_OBJECT)StartContext;
	//抹除特征
    pDriver->DriverSize = 0;
	pDriver->DriverSection = NULL;
	pDriver->DriverExtension = NULL;
	pDriver->DriverStart = NULL;
	pDriver->DriverInit = NULL;
	pDriver->FastIoDispatch = NULL;
	pDriver->DriverStartIo = NULL;
	ZwClose(hThread);
	KdPrint(("执行结束1\n"));
}


NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pReg)
{
	KdPrint(("驱动被加载\n"));
	PLDR_DATA_TABLE_ENTRY pList = (PLDR_DATA_TABLE_ENTRY)pDriver->DriverSection;
	PLDR_DATA_TABLE_ENTRY pCur = pList;
	pList = pList->InLoadOrderLinks.Flink;

	pList->InLoadOrderLinks.Blink = pCur->InLoadOrderLinks.Blink;
	pCur->InLoadOrderLinks.Flink = pList;

	pDriver->DriverUnload = DriverUnload;

	PsCreateSystemThread(&hThread, GENERIC_ALL, NULL, NULL, NULL, threadRun, pDriver);

	return STATUS_SUCCESS;
}
```

上面代码可让pchunter也找不到驱动，但此代码只做了抹特征隐藏，却并未恢复特征或手动调用函数卸载驱动。停止驱动的时候会因为信息缺失直接蓝屏。需要一个时间点做恢复特征（不可以在DriverUnload中，因为是还没到该函数就蓝屏了）。

64位下不能直接断链(PG的原因)

MiProcessLoaderEntry，第一个参数是当前链表，第二个参数false表示卸载，true表示插入。该函数模块从链表上移除了，但没有释放内存。

64位用这个函数不会触发PG，不会蓝屏。PG可以理解成就是保护全局变量bu不被直接修改。

**KdPrint和DbgPrint的区别：**

```c
#if DBG
	#define KdPrint(_x_) DbgPrint _x_
#else
	#define KdPrint(_x_)//把KdPrint(_x_)宏替换成什么也没有
//即如下两句在debug模式下含义相同:
KdPrint(("hello World!\n"));
DbgPrint("hello World!\n");
//但在release模式下，KdPrint不会打印。
```

### 驱动键鼠过滤

IoAttachDevice绑定设备

```c
NTSTATUS
IoAttachDevice(
IN PDEVICE_OBJECT SourceDevice,//生成的设备对象
IN PUNICODE_STRING TargetDevice,//目标串口设备名称
OUT PDEVICE_OBJECT *AttachedDevice//【返回被绑定设备指针】的指针
);
```

使用：

```c
UNICODE_STRING com_name = RLT_CONSTANT_STRING(L"\\Device\\Serial0");
NTSTATUS status = IoAttachDevice(com_filter_device,&com_device_name,&attached_device);
```









## 零环与三环通信(常规方式)

常规方式表示微软提供的正常通信方式，还有非常规通信。正常通信方式受到一定限制。

**设备对象**

我们在开发窗口程序的时候，消息被封装成一个结构体：MSG，**在内核开发时，消息被封装成另外一个结构体：IRP**（I/O Request Package输入输出请求包）

在窗口程序中，能够接受消息的只能是窗口对象。在内核中，能够接收IRP消息的只能是设备对象

![image-20210827111116147](https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20210827111116147.png)

- **驱动对象**（DRIVER_OBJECT）生成多个设备对象，
- **设备对象**（DEVICE_OBJECT）可以是硬件（硬盘等），也可以是软件，比如NTFS文件系统。它们都属于设备对象。

![image-20210829163134914](https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20210829163134914.png)

![sdsad](https://gitee.com/ZEROKO14/blog-img/raw/master/img/sdsad.jpeg)

### [创建设备对象](https://docs.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/nf-wdm-iocreatedevice)

#### 设备对象结构

```c
typedef struct DECLSPEC_ALIGN(MEMORY_ALLOCATION_ALIGNMENT) _DEVICE_OBJECT
{
    CSHORT Type;//类型
    USHORT Size;//大小
    LONG ReferenceCount;//引用计数
    /*指向驱动程序中驱动对象的指针*/
    struct _DRIVER_OBJECT *DriverObject;//设备所属的驱动对象
    /*指向下一个设备对象的指针*/
    struct _DEVICE_OBJECT *NextDevice;//下一个设备对象，在一个驱动对象中有N个设备，这些设备用这个指针连接起来作为一个单向的链表
    struct _DEVICE_OBJECT *AttachedDevice;
    /*当前IRP结构*/
    struct _IRP *CurrentIrp;
    PIO_TIMER Timer;
    /*设备对象的特性标志*/
    ULONG Flags;
    ULONG Characteristics;
    _volatile PVPB Vpb;
    /*指向设备扩展对象的指针*/
    PVOID DeviceExtension;
    /*指明设备类型*/
    DEVICE_TYPE DeviceType;
    /*堆栈的最小层数*/
    CCHAR StackSize;//IRP栈的大小,用于存放参数的
    union {
        LIST_ENTRY ListEntry;
        WAIT_CONTEXT_BLOCK Wcb;
    } Queue;
    /*内存对齐*/
    ULONG AlignmentRequirement;
    KDEVICE_QUEUE DeviceQueue;
    KDPC Dpc;
    /*
    *下列成员用于支持文件系统的互斥操作
    *以便对文件系统处理线程使用设备的计数保持跟踪
    */
    ULONG ActiveThreadCount;
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    KEVENT DeviceLock;
 
    USHORT SectorSize;
    USHORT Spare1;
 
    struct _DEVOBJ_EXTENSION  *DeviceObjectExtension;
    PVOID  Reserved;
 
} DEVICE_OBJECT;
typedef struct _DEVICE_OBJECT *PDEVICE_OBJECT;
```

#### IoCreateDevice

```c
NTSTATUS IoCreateDevice(
  PDRIVER_OBJECT  DriverObject,//驱动对象指针
  ULONG           DeviceExtensionSize,//指定要为设备对象的设备扩展分配的驱动程序确定的字节数；设备扩展内存的大小，你可以在这申请一块非分页内存，只要设备还在，就都可以用，可以用它代替全局变量。
  PUNICODE_STRING DeviceName,//可选地指向一个缓冲区，该缓冲区包含一个以空字符结尾的 Unicode 字符串，用于命名设备对象。该字符串必须是完整路径名。
  DEVICE_TYPE     DeviceType,//一般用FILE_DEVICE_UNKNOWN，#define FILE_DEVICE_UNKNOWN             0x00000022
  ULONG           DeviceCharacteristics,//基本就是填FILE_DEVICE_SECURE_OPEN
  BOOLEAN         Exclusive,//TRUE代表设备是独占的，FALSE代表该设备是共享的；独享可以防止前面的驱动拦截后面的驱动的派遣函数处理
  PDEVICE_OBJECT  *DeviceObject//【out】二级指针，目的是返回设备对象指针
);

//给某个设备发送IRP请求
NTSTATUS MyDispath(PDEVICE_OBJECT device,PIRP irp);
```

实例：

```c
//创建设备名称
UNICODE_STRING Devicename;
RtlInitUnicodeString(&Devicename,L"\\Device\\MyDevice");//\\Device尽量不要改，为了让驱动文件同一个树结构下，方便统一。该名字是给零环用的，三环通过这个名字是找不到该设备对象的。

//设备对象指针，用于接受
PDEVICE_OBJECT pDeviceObj = NULL;
//创建设备
status = IoCreateDevice(
pDriver,				//当前设备所属的驱动对象
0,
&Devicename,			//设备对象的名称
FILE_DEVICE_UNKNOWN,//不知道什么类型
FILE_DEVICE_SECURE_OPEN,
TRUE,
&pDeviceObj			//【out】设备对象指针
);
if(!NT_SUCCESS(status))//NT_SUCCESS,微软提供的，实际上就是判断status是否大于等于0
{
    DbgPrint("创建设备失败!\n");
    return status;
}
```

### 删除设备对象

```c
IoDeleteDevice(pDeviceObj);//删除设备
```

### 设置交互数据的方式

```c
//如果前面创建设备对象成功，就设置交互数据的方式
pDeviceObj->Flags |= DO_BUFFERED_IO;
```

- **缓冲区方式读写(DO_BUFFERED_IO)**：操作系统将应用程序提供缓冲区的数据复制到内核模式下的地址中。(效率不高，适合小规模数据)
- **直接方式读写(DO_DIRECT_IO)**：操作系统会将用户模式下的缓冲区锁住。然后操作系统将这段缓冲区在内核模式地址再次映射一遍。这样，用户模式的缓冲区和内核模式的缓冲区指向的是同一区域的物理内存。缺点就是要单独占用物理页面。(适合大规模数据，比较浪费物理页)
- **其他方式读写**(在调用IoCreateDevice创建设备后对pDevObj->Flags即不设置DO_BUFFERED_IO，也不设置DO_DIRECT_IO，此时就是其他方式)：在使用其他方式读写设备时，派遣函数直接读写应用程序提供的缓冲区地址。在驱动程序中，直接操作应用程序的缓冲区地址是很危险的。**只有驱动程序与应用程序运行在相同线程上下文的情况下，才能使用这种方式**。

### 创建与卸载符号链接

就是设置一个名字，让三环可以通过这个名字找到设备对象。

```c
//创建符号链接名称
UNICODE_STRING SymbolicLinkName;
RtlInitUnicodeString(&SymbolicLinkName,L"\\??\\MyTestDriver");
//两个问号代表根目录
//Ring3用CreateFile打开设备时，用"\\\\.\\MyTestDriver"(实际上就是地址要\\.\开始，但是要转义，所以为\\\\.\\)

//创建符号链接
status = IoCreateSymbolicLink(&SymbolicLinkName,&Devicename);
if(status!=STATUS_SUCCESS)
{
    DbgPrint("创建符号链接失败!\n");
    IoDeleteDevice(pDeviceObj);//删除设备
    return status;
}

//卸载符号链接
IoDeleteSymbolicLink(&SymbolicLinkName);
```

特别说明：

1. 设备名称的作用是给内核对象用的，如果要在Ring3访问，必须要有符号链接，其实就是一个别名，没有这个别名，在Ring3不可见
2. **内核模式下，符号链接是以"\??\"开头的，如C盘就是"\??\C:"**
3. **用户模式下，则是以"\\\\.\\\"开头的，如C盘就是"\\\\.\\C:"**

### IRP与派遣函数

![image-20210827114410752](https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20210827114410752.png)

驱动程序与I/O管理器通信，使用的是IRP，即**I/O请求包**。

#### IRP类型

1. 当应用层通过CreateFile，ReadFile，WriteFile，CloseHandle等函数打开，从设备读取数据，向设备写入数据，关闭设备的时候，会使操作系统分别产生出IRP_MJ_CREATE,IRP_MJ_READ,IRP_MJ_WRITE,IRP_MJ_CLOSE等不同的IRP。

2. 其他类型的IRP

   | IRP类型                                                      | 来源                                |
   | ------------------------------------------------------------ | ----------------------------------- |
   | **IRP_MJ_DEVICE_CONTROL**                                    | DeviceIoControl函数会产生此IRP      |
   | IRP_MJ_POWER                                                 | 在操作系统处理电源信息时，产生此IRP |
   | IRP_MJ_SHUTDOWN                                              | 关闭系统前会产生此IRP               |
| IRP_MJ_CREATE                                                | 生成请求                            |
   | IRP_MJ_QUERY_INFORMATION                                     | 查询请求                            |
   | IRP_MJ_CLOSE                                                 | 关闭请求                            |
   | IRP_MJ_SET_INFORMATION                                       | 设置请求                            |
   | [还有很多。。。](https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/irp-major-function-codes) | 。。。                              |
   
   IRP_MJ_DEVICE_CONTROL是我们用的最多的一种方式，比较灵活。可以拿到三环传过来的消息码，自己设定怎么处理(通过消息码确定)。

#### 派遣函数

##### 派遣函数在哪里注册呢？

```c
kd> dt _DRIVER_OBJECT
nt!_DRIVER_OBJECT
   +0x000 Type             : Int2B
   +0x002 Size             : Int2B
   +0x004 DeviceObject     : Ptr32 _DEVICE_OBJECT
   +0x008 Flags            : Uint4B
   +0x00c DriverStart      : Ptr32 Void
   +0x010 DriverSize       : Uint4B
....
   +0x030 DriverStartIo    : Ptr32     void 
   +0x034 DriverUnload     : Ptr32     void 		//卸载函数
   +0x038 MajorFunction    : [28] Ptr32     long 	//派遣函数
   //0编号的IRP对应的派遣函数的地址就存在MajorFunction[0]的位置。
```

0编号的IRP对应的派遣函数的地址就存在MajorFunction[0]的位置。

##### 注册派遣函数

```c
NTSTATUS DriverEntry( 。。。。)  
{  
    //设置卸载函数   
    pDriverObject->DriverUnload = 卸载函数;  
  
    //设置派遣函数   
    pDriverObject->MajorFunction[IRP_MJ_CREATE] 	= 派遣函数1;  
    pDriverObject->MajorFunction[IRP_MJ_CLOSE] 	= 派遣函数2;  
    pDriverObject->MajorFunction[IRP_MJ_WRITE] 	= 派遣函数3;  
    pDriverObject->MajorFunction[IRP_MJ_READ] 	= 派遣函数4;  
    pDriverObject->MajorFunction[IRP_MJ_CLEANUP] 	= 派遣函数5;  
    pDriverObject->MajorFunction[IRP_MJ_SET_INFORMATION] 	= 派遣函数6;  
    pDriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] 	= 派遣函数7;  
    pDriverObject->MajorFunction[IRP_MJ_SHUTDOWN] 		= 派遣函数8;  
    pDriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] 	= 派遣函数9;
} 
```

IRP_MJ_MAXIMUM_FUNCTION  派遣函数的最大值宏

#### 派遣函数的格式

```c
NTSTATUS MyDispatchFunction(PDEVICE_OBJECT pDevObj, PIRP pIrp)//PIRP为IRP报文数据结构指针
{
	//处理自己的业务...

	//设置返回状态,返回状态如果不设置，Ring3返回的是失败
	pIrp->IoStatus.Status = STATUS_SUCCESS;	//  三环getlasterror()得到的就是这个值
	pIrp->IoStatus.Information = 0;		//  返回给3环多少个字节的数据 没有填0
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);//表示调用方已完成所有I/O请求处理操作，并将给定的 IRP 返回给 I/O 管理器。将IRP往下派发
	return STATUS_SUCCESS;
} 
```

[IRP结构详解](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ns-wdm-_irp)

##### **IRP_MJ_DEVICE_CONTROL的派遣函数**

###### CTL操作码

IRP_MJ_DEVICE_CONTROL用到的操作码是个复合数据，微软提供了一个[宏CTL_CODE](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/d4drvif/nf-d4drvif-ctl_code)来组合这个复合数据，如下定义方式：

```c
//该宏的定义
#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \
    ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) \
)
//是个宏，按照函数讲解每个参数
void CTL_CODE(
   DeviceType,//驱动种类，一般是FILE_DEVICE_UNKNOWN
   Function,//提供一个数值，标识其独特性
   Method,//交互数据的方式(要与前面设定的一致)，METHOD_BUFFERED或METHOD_IN_DIRECT或METHOD_OUT_DIRECT或METHOD_NEITHER
   Access//权限，FILE_ANY_ACCESS表示全部权限，或FILE_READ_ACCESS或FILE_WRITE_ACCESS
);
//定义实例：
#define CODE_READ CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define CODE_WRITE CTL_CODE(FILE_DEVICE_UNKNOWN,0x900,METHOD_BUFFERED,FILE_ANY_ACCESS)
```

###### IRP_MJ_DEVICE_CONTROL的派遣函数编写

```c
NTSTATUS ControlCallBack(PDEVICE_OBJECT pDevObj, PIRP pIrp)
{
    PIO_STACK_LOCATION psl = IoGetCurrentIrpStackLocation(pIrp);
    ULONG code = psl->Parameters.DeviceIoControl.IoControlCode;//获取派遣过来的CTL操作码
    PVOID systemBuf = pIrp->AssociatedIrp.SystemBuffer;//获取缓存地址(输入输出都靠这个地址)
    ULONG inLen = psl->Parameters.DeviceIoControl.InputBufferLength;//获取输入长度
    ULONG outLen = psl->Parameters.DeviceIoControl.OutputBufferLength;//获取输出长度
    //根据不同的CTL操作码做不同的处理
    switch(code)
    {
        case CODE_READ://注意是以三环视角来看其含义，三环想要读
            //执行想做的事情
            break;
        case CODE_WRITE:
            break;

    }
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);//表示调用方已完成所有I/O请求处理操作，并将给定的 IRP 返回给 I/O 管理器。将IRP往下派发
	return STATUS_SUCCESS;
}
```

- [IoGetCurrentIrpStackLocation详解](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-iogetcurrentirpstacklocation)
- [PIO_STACK_LOCATION结构详解](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ns-wdm-_io_stack_location)

###### 三环写法

**[DeviceIoControl](https://docs.microsoft.com/zh-cn/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol)函数结构**

```c
BOOL DeviceIoControl(
  HANDLE       hDevice,//设备句柄
  DWORD        dwIoControlCode,//CTL操作码
  LPVOID       lpInBuffer,//读到哪(三环读零环)
  DWORD        nInBufferSize,//读多少
  LPVOID       lpOutBuffer,//写到哪(三环写零环)
  DWORD        nOutBufferSize,//写多少
  LPDWORD      lpBytesReturned,//实际多少
  LPOVERLAPPED lpOverlapped//异步相关，一般填NULL，略
);
```

内核通信，需要头文件#include <WinIoCtl.h>

并且**WinIoCtl.h必须定义到Windows.h的后面**

```c
#define CODE_READ CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define CODE_WRITE CTL_CODE(FILE_DEVICE_UNKNOWN,0x900,METHOD_BUFFERED,FILE_ANY_ACCESS)

//打开设备
BOOLEAN openDevice(HANDLE *handle)
{
    HANDLE _handle = CreateFileA("\\\\.\\MyTestDriver",GENERIC_READ|GENERIC_WRITE,0,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);//打开设备对象句柄
    *handle=_handle;
	return (int)_handle>0;
}

//关闭设备
CloseHandle(handle);

//发送IRP_MJ_DEVICE_CONTROL
BOOLEAN sendCode(HANDLE hDevice,DWORD code,PVOID inData,ULONG Inlen,PVOID outData,ULONG outLen,LPDWORD resultLen)
{
    return DeviceIoControl(hDevice,code,inData,Inlen,outData,outLen,resultLen,NULL);
}
```

**0-3环常规通信框架：**

```c
#include <ntddk.h>

#define CODE_CHANGE CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define CODE_RESUME CTL_CODE(FILE_DEVICE_UNKNOWN,0x900,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define CODE_READ CTL_CODE(FILE_DEVICE_UNKNOWN,0x1000,METHOD_BUFFERED,FILE_ANY_ACCESS)
UNICODE_STRING SymbolicLinkName;

//卸载函数
VOID DriverUnload(PDRIVER_OBJECT driver)
{
	DbgPrint("停止运行了\n");
}

NTSTATUS MyCreateDispatchFunction(PDEVICE_OBJECT pDevObj, PIRP pIrp)//PIRP为IRP报文数据结构指针
{
	//处理自己的业务...
	DbgPrint("三环连接成功\n");
	//设置返回状态,返回状态如果不设置，Ring3返回的是失败
	pIrp->IoStatus.Status = STATUS_SUCCESS;	//  三环getlasterror()得到的就是这个值
	pIrp->IoStatus.Information = 0;		//  返回给3环多少个字节的数据 没有填0
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);//表示调用方已完成所有I/O请求处理操作，并将给定的 IRP 返回给 I/O 管理器。将IRP往下派发
	return STATUS_SUCCESS;
}
NTSTATUS MyCloseDispatchFunction(PDEVICE_OBJECT pDevObj, PIRP pIrp)//PIRP为IRP报文数据结构指针
{
	//处理自己的业务...
	DbgPrint("三环断开连接成功\n");
	//设置返回状态,返回状态如果不设置，Ring3返回的是失败
	pIrp->IoStatus.Status = STATUS_SUCCESS;	//  三环getlasterror()得到的就是这个值
	pIrp->IoStatus.Information = 0;		//  返回给3环多少个字节的数据 没有填0
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);//表示调用方已完成所有I/O请求处理操作，并将给定的 IRP 返回给 I/O 管理器。将IRP往下派发
	return STATUS_SUCCESS;
}


ULONG current = 0;

NTSTATUS ControlCallBack(PDEVICE_OBJECT pDevObj, PIRP pIrp)
{
	PIO_STACK_LOCATION psl = IoGetCurrentIrpStackLocation(pIrp);
	ULONG code = psl->Parameters.DeviceIoControl.IoControlCode;//获取派遣过来的CTL操作码
	PVOID systemBuf = pIrp->AssociatedIrp.SystemBuffer;//获取缓存地址(输入输出都靠这个地址)
	ULONG inLen = psl->Parameters.DeviceIoControl.InputBufferLength;//获取输入长度
	ULONG outLen = psl->Parameters.DeviceIoControl.OutputBufferLength;//获取输出长度
	//根据不同的CTL操作码做不同的处理
	switch (code)
	{
	case CODE_CHANGE://注意是以三环视角来看其含义，初始化

		break;
	case CODE_RESUME://三环想要反初始化
		
		break;

	case CODE_READ:

		break;
	}
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);//表示调用方已完成所有I/O请求处理操作，并将给定的 IRP 返回给 I/O 管理器。将IRP往下派发
	return STATUS_SUCCESS;
}


//入口函数，相当于main函数
NTSTATUS DriverEntry(PDRIVER_OBJECT pdriver, PUNICODE_STRING pReg)
{
	//设置一个卸载函数，用于退出
	pdriver->DriverUnload = DriverUnload;
	//创建设备名称
	UNICODE_STRING Devicename;
	RtlInitUnicodeString(&Devicename, L"\\Device\\MyDevice");
	//设备对象指针，用于接受
	PDEVICE_OBJECT pDeviceObj = NULL;
	//创建设备
	NTSTATUS status = IoCreateDevice(pdriver,0,&Devicename,FILE_DEVICE_UNKNOWN,FILE_DEVICE_SECURE_OPEN,TRUE,&pDeviceObj	);
	if (!NT_SUCCESS(status))//NT_SUCCESS,微软提供的，实际上就是判断status是否大于等于0
	{
		DbgPrint("创建设备失败!\n");
		return status;
	}
	//如果前面创建设备对象成功，就设置交互数据的方式
	pDeviceObj->Flags |= DO_BUFFERED_IO;
	//创建符号链接名称
	RtlInitUnicodeString(&SymbolicLinkName, L"\\??\\MyTestDriver");
	status = IoCreateSymbolicLink(&SymbolicLinkName, &Devicename);
	if (!NT_SUCCESS(status))
	{
		DbgPrint("创建符号链接失败!\n");
		IoDeleteDevice(pDeviceObj);//删除设备
		return status;
	}
	//设置派遣函数   
	pdriver->MajorFunction[IRP_MJ_CREATE] = MyCreateDispatchFunction;
	pdriver->MajorFunction[IRP_MJ_CLOSE] = MyCloseDispatchFunction;
	pdriver->MajorFunction[IRP_MJ_DEVICE_CONTROL] = ControlCallBack;
	return STATUS_SUCCESS;
}
```

### 通过IRP_MJ_DEVICE_CONTROL交互数据实验

#### R0代码：

```c
#include <ntddk.h>

#define CODE_READ CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define CODE_WRITE CTL_CODE(FILE_DEVICE_UNKNOWN,0x900,METHOD_BUFFERED,FILE_ANY_ACCESS)
UNICODE_STRING SymbolicLinkName;

//卸载函数
VOID DriverUnload(PDRIVER_OBJECT driver)
{
	//删除设备对象
	if (driver->DeviceObject)
	{
		IoDeleteDevice(driver->DeviceObject);//设备对象已挂载在driver中
	}
	if (SymbolicLinkName.Length>0)
	{
		IoDeleteSymbolicLink(&SymbolicLinkName);
	}
	DbgPrint("停止运行了\n");
}

NTSTATUS MyCreateDispatchFunction(PDEVICE_OBJECT pDevObj, PIRP pIrp)//PIRP为IRP报文数据结构指针
{
	//处理自己的业务...
	DbgPrint("三环连接成功\n");
	//设置返回状态,返回状态如果不设置，Ring3返回的是失败
	pIrp->IoStatus.Status = STATUS_SUCCESS;	//  三环getlasterror()得到的就是这个值
	pIrp->IoStatus.Information = 0;		//  返回给3环多少个字节的数据 没有填0
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);//表示调用方已完成所有I/O请求处理操作，并将给定的 IRP 返回给 I/O 管理器。将IRP往下派发
	return STATUS_SUCCESS;
}
NTSTATUS MyCloseDispatchFunction(PDEVICE_OBJECT pDevObj, PIRP pIrp)//PIRP为IRP报文数据结构指针
{
	//处理自己的业务...
	DbgPrint("三环断开连接成功\n");
	//设置返回状态,返回状态如果不设置，Ring3返回的是失败
	pIrp->IoStatus.Status = STATUS_SUCCESS;	//  三环getlasterror()得到的就是这个值
	pIrp->IoStatus.Information = 0;		//  返回给3环多少个字节的数据 没有填0
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);//表示调用方已完成所有I/O请求处理操作，并将给定的 IRP 返回给 I/O 管理器。将IRP往下派发
	return STATUS_SUCCESS;
}

NTSTATUS ControlCallBack(PDEVICE_OBJECT pDevObj, PIRP pIrp)
{
	PIO_STACK_LOCATION psl = IoGetCurrentIrpStackLocation(pIrp);
	ULONG code = psl->Parameters.DeviceIoControl.IoControlCode;//获取派遣过来的CTL操作码
	PVOID systemBuf = pIrp->AssociatedIrp.SystemBuffer;//获取缓存地址(输入输出都靠这个地址)
	ULONG inLen = psl->Parameters.DeviceIoControl.InputBufferLength;//获取输入长度
	ULONG outLen = psl->Parameters.DeviceIoControl.OutputBufferLength;//获取输出长度
	//根据不同的CTL操作码做不同的处理
	switch (code)
	{
	case CODE_READ://注意是以三环视角来看其含义，三环想要读
		//把1234567传给三环读
		memcpy(systemBuf, "1234567", sizeof("1234567"));
		//把零环写入的长度传给三环
		pIrp->IoStatus.Information = sizeof("1234567");
		break;
	case CODE_WRITE:
		//打印三环写入的信息
		DbgPrint("派遣函数:三环传入的信息：%s\n",/*(char*)*/systemBuf);
		break;
	}
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);//表示调用方已完成所有I/O请求处理操作，并将给定的 IRP 返回给 I/O 管理器。将IRP往下派发
	return STATUS_SUCCESS;
}

//入口函数，相当于main函数
NTSTATUS DriverEntry(PDRIVER_OBJECT pdriver, PUNICODE_STRING pReg)
{
	//设置一个卸载函数，用于退出
	pdriver->DriverUnload = DriverUnload;
	//创建设备名称
	UNICODE_STRING Devicename;
	RtlInitUnicodeString(&Devicename, L"\\Device\\MyDevice");
	//设备对象指针，用于接受
	PDEVICE_OBJECT pDeviceObj = NULL;
	//创建设备
	NTSTATUS status = IoCreateDevice(pdriver,0,&Devicename,FILE_DEVICE_UNKNOWN,FILE_DEVICE_SECURE_OPEN,TRUE,&pDeviceObj	);
	if (!NT_SUCCESS(status))//NT_SUCCESS,微软提供的，实际上就是判断status是否大于等于0
	{
		DbgPrint("创建设备失败!\n");
		return status;
	}
	//如果前面创建设备对象成功，就设置交互数据的方式
	pDeviceObj->Flags |= DO_BUFFERED_IO;
	//创建符号链接名称
	RtlInitUnicodeString(&SymbolicLinkName, L"\\??\\MyTestDriver");
	status = IoCreateSymbolicLink(&SymbolicLinkName, &Devicename);
	if (!NT_SUCCESS(status))
	{
		DbgPrint("创建符号链接失败!\n");
		IoDeleteDevice(pDeviceObj);//删除设备
		return status;
	}
	//设置派遣函数   
	pdriver->MajorFunction[IRP_MJ_CREATE] = MyCreateDispatchFunction;
	pdriver->MajorFunction[IRP_MJ_CLOSE] = MyCloseDispatchFunction;
	pdriver->MajorFunction[IRP_MJ_DEVICE_CONTROL] = ControlCallBack;
	return STATUS_SUCCESS;
}
```

#### R3代码：

```c
#include"stdafx.h"
#include <stdio.h>
#include <stdlib.h>
#include <Windows.h>
#include <WinIoCtl.h>


#define CODE_READ CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define CODE_WRITE CTL_CODE(FILE_DEVICE_UNKNOWN,0x900,METHOD_BUFFERED,FILE_ANY_ACCESS)

//打开设备
BOOLEAN openDevice(HANDLE *handle)
{
	HANDLE _handle = CreateFileA("\\\\.\\MyTestDriver", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);//打开设备对象句柄
	*handle = _handle;
	return (int)_handle > 0;
}


//发送IRP_MJ_DEVICE_CONTROL
BOOLEAN sendCode(HANDLE hDevice, DWORD code, PVOID inData, ULONG Inlen, PVOID outData, ULONG outLen, LPDWORD resultLen)
{
	return DeviceIoControl(hDevice, code, inData, Inlen, outData, outLen, resultLen, NULL);
}

void main()
{
	HANDLE hDevice;
	char buf[30] = { 0 };
	DWORD realReaded = 0;
	if (!openDevice(&hDevice))
	{
		printf("打开设备对象失败!\r\n");
		return;
	}
    //写数据给R0！！！！！！！！！！！！！！！！！！！！！！
	memcpy(buf,"i am R3",sizeof("i am R3"));
	sendCode(hDevice, CODE_WRITE, buf, 30, NULL, 0, &realReaded);
    
	//读R0数据	！！！！！！！！！！！！！！！！！！！！！！
	//sendCode(hDevice, CODE_READ, NULL, 0, buf, 30, &realReaded);
	
	printf("读到：%s\r\n", buf);
	CloseHandle(hDevice);
	system("pause");
}
```

写数据结果如图：

![image-20210829212010210](https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20210829212010210.png)

将`写数据给R0`代码注释，放开`读R0数据`的代码，结果如图：

![image-20210829212159461](https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20210829212159461.png)

## 驱动加载

### 驱动注册/安装

#### [OpenSCManagerA函数](https://docs.microsoft.com/zh-cn/windows/win32/api/winsvc/nf-winsvc-openscmanagera)

```c
//如果函数成功，则返回值是指定服务控制管理器数据库的句柄。
//如果函数失败，则返回值为 NULL。
//打开服务管理器
SC_HANDLE OpenSCManagerA(
  LPCSTR lpMachineName,//目标计算机的名称。如果指针为 NULL 或指向空字符串，则该函数连接到本地计算机上的服务控制管理器。
  LPCSTR lpDatabaseName,//服务控制管理器数据库的名称。此参数应设置为 SERVICES_ACTIVE_DATABASE。如果为 NULL，则默认打开 SERVICES_ACTIVE_DATABASE 数据库。
  DWORD  dwDesiredAccess//权限，SC_MANAGER_ALL_ACCESS 表示所有权限
);
```

#### 创建服务[CreateServiceA函数](https://docs.microsoft.com/zh-cn/windows/win32/api/winsvc/nf-winsvc-createservicea)

```c
//如果函数成功，则返回值是服务的句柄。
//如果函数失败，则返回值为 NULL。
SC_HANDLE CreateServiceA(
  SC_HANDLE hSCManager,//服务管理器句柄
  LPCSTR    lpServiceName,//这个服务的名字
  LPCSTR    lpDisplayName,//显示给别人看的名字
  DWORD     dwDesiredAccess,//访问权限，SERVICE_ALL_ACCESS表示所有权限
  DWORD     dwServiceType,//什么服务类型，SERVICE_KERNEL_DRIVER表示内核驱动服务
  DWORD     dwStartType,//启动类型，SERVICE_BOOT_START开机启动服务，SERVICE_AUTO_START自动启动服务，SERVICE_DEMAND_START按需启动，即当进程调用StartService函数时由服务控制管理器启动的服务 。
  DWORD     dwErrorControl,//如果此服务无法启动，则错误的严重性以及采取的措施。SERVICE_ERROR_NORMAL表示启动程序在事件日志中记录错误，但继续启动操作。
  LPCSTR    lpBinaryPathName,//服务二进制文件的完全限定路径。
    //后面都为NULL就可以了
  LPCSTR    lpLoadOrderGroup,
  LPDWORD   lpdwTagId,
  LPCSTR    lpDependencies,
  LPCSTR    lpServiceStartName,
  LPCSTR    lpPassword
);
```

**关闭服务句柄**

```c
CloseServiceHandle(serviceHandle);//serviceHandle为某服务的句柄
//也可以直接调用CloseHandle(serviceHandle);CloseServiceHandle还是会调用CloseHandle
```

### 驱动启动

#### 打开服务[OpenServiceA函数](https://docs.microsoft.com/zh-cn/windows/win32/api/winsvc/nf-winsvc-openservicea)

```c
SC_HANDLE OpenServiceA(
  SC_HANDLE hSCManager,//服务管理器句柄
  LPCSTR    lpServiceName,//服务名字，根据这个服务名字找服务
  DWORD     dwDesiredAccess//权限，SC_MANAGER_ALL_ACCESS表示所有权限
);
```

#### 开始服务[StartServiceA函数](https://docs.microsoft.com/en-us/windows/win32/api/winsvc/nf-winsvc-startservicea)

```c
//如果函数成功，则返回值非零。
//如果函数失败，则返回值为零。
BOOL StartServiceA(
  SC_HANDLE hService,//服务句柄
    //服务函数的参数相关
  DWORD     dwNumServiceArgs,//参数字节数，没有填0
  LPCSTR    *lpServiceArgVectors//如果没有参数，则此参数可以为 NULL。
);
```

### 停止驱动

OpenServiceA后ControlService

#### 控制服务[ControlService函数](https://docs.microsoft.com/en-us/windows/win32/api/winsvc/nf-winsvc-controlservice)

```c
//如果函数成功，则返回值非零。
//如果函数失败，则返回值为零。
BOOL ControlService(
  SC_HANDLE        hService,//服务句柄
  DWORD            dwControl,//控制码，其中SERVICE_CONTROL_STOP表示停止服务的控制码
  LPSERVICE_STATUS lpServiceStatus//指向SERVICE_STATUS结构的指针，该结构接收最新的服务状态信息。返回的信息反映了服务向服务控制管理器报告的最新状态。仅当GetLastError返回以下错误代码之一时，服务控制管理器才会填充结构 ：NO_ERROR、ERROR_INVALID_SERVICE_CONTROL、 ERROR_SERVICE_CANNOT_ACCEPT_CTRL或 ERROR_SERVICE_NOT_ACTIVE。否则，不填充结构。
);
```

### 卸载驱动

OpenServiceA后DeleteService

删除服务[DeleteService函数](https://docs.microsoft.com/en-us/windows/win32/api/winsvc/nf-winsvc-deleteservice)

```c
//如果函数成功，则返回值非零。
//如果函数失败，则返回值为零。
BOOL DeleteService(
  SC_HANDLE hService//服务句柄
);
```

## 全局监听API实验

1. 自己加载驱动
2. 写拷贝(段页知识)
3. R3,R0通信
4. 写HOOK
5. ShellCode

写拷贝的本来流程：

> 当写一个内存的时候先判断到内存是否可写(R/W位是否为1)，若为0，则表示该内存不可写，进入异常，在异常中通过VAD进一步判断其到底是写拷贝还是只读，如果是只读报错；如果是写拷贝，则映射一份新物理页将原内容复制过来，直接写到新物理页上，不影响原物理页。因此你HOOK了一个API只影响你自己的进程，而无法影响别的进程是因为别的进程还是原物理页，并未被你修改。解决方法很简单，找到要hook API的地方将R/W位置1，根本不进异常直接hook原物理页，规避触发写拷贝。

下面代码针对2-9-9-12分页，并且事后未复原。

### R0代码

```c
#include <ntddk.h>

#define CODE_CHANGE CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define CODE_RESUME CTL_CODE(FILE_DEVICE_UNKNOWN,0x900,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define CODE_READ CTL_CODE(FILE_DEVICE_UNKNOWN,0x1000,METHOD_BUFFERED,FILE_ANY_ACCESS)
UNICODE_STRING SymbolicLinkName;

//卸载函数
VOID DriverUnload(PDRIVER_OBJECT driver)
{
	//删除设备对象
	if (driver->DeviceObject)
	{
		IoDeleteDevice(driver->DeviceObject);//设备对象已挂载在driver中
	}
	if (SymbolicLinkName.Length>0)
	{
		IoDeleteSymbolicLink(&SymbolicLinkName);
	}
	DbgPrint("停止运行了\n");
}

NTSTATUS MyCreateDispatchFunction(PDEVICE_OBJECT pDevObj, PIRP pIrp)//PIRP为IRP报文数据结构指针
{
	//处理自己的业务...
	DbgPrint("三环连接成功\n");
	//设置返回状态,返回状态如果不设置，Ring3返回的是失败
	pIrp->IoStatus.Status = STATUS_SUCCESS;	//  三环getlasterror()得到的就是这个值
	pIrp->IoStatus.Information = 0;		//  返回给3环多少个字节的数据 没有填0
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);//表示调用方已完成所有I/O请求处理操作，并将给定的 IRP 返回给 I/O 管理器。将IRP往下派发
	return STATUS_SUCCESS;
}
NTSTATUS MyCloseDispatchFunction(PDEVICE_OBJECT pDevObj, PIRP pIrp)//PIRP为IRP报文数据结构指针
{
	//处理自己的业务...
	DbgPrint("三环断开连接成功\n");
	//设置返回状态,返回状态如果不设置，Ring3返回的是失败
	pIrp->IoStatus.Status = STATUS_SUCCESS;	//  三环getlasterror()得到的就是这个值
	pIrp->IoStatus.Information = 0;		//  返回给3环多少个字节的数据 没有填0
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);//表示调用方已完成所有I/O请求处理操作，并将给定的 IRP 返回给 I/O 管理器。将IRP往下派发
	return STATUS_SUCCESS;
}

ULONG param[5] = {0,0,0,0,0};
//ULONG getESP = 0;

//shellcode写到这里
void __declspec(naked) interruptGate()
{
	__asm
	{
		//通过ESP获取MessageBoxA的参数
		pushfd;
		pushad;
		mov eax, dword ptr ds : [esp + 0x24 + 0xC] ;//获取三环esp
		//mov dword ptr ds : [getESP] , eax;
		lea ecx, param;
		add eax, 4;//跳过call的返回地址
		//获取四个参数填入param全局数组中。
		mov ebx, dword ptr ds : [eax] ;
		mov dword ptr ds : [ecx] , ebx;
		mov ebx, dword ptr ds : [eax+4] ;
		mov dword ptr ds : [ecx+4] , ebx;
		mov ebx, dword ptr ds : [eax+8] ;
		mov dword ptr ds : [ecx+8] , ebx;
		mov ebx, dword ptr ds : [eax + 0xC] ;
		mov dword ptr ds : [ecx + 0xC] , ebx;
		add dword ptr ds : [ecx + 0x10],1
		popad;
		popfd;
		iretd;
		
	}
}

ULONG current = 0;//为了防止打印重复
NTSTATUS ControlCallBack(PDEVICE_OBJECT pDevObj, PIRP pIrp)
{
	PIO_STACK_LOCATION psl = IoGetCurrentIrpStackLocation(pIrp);
	ULONG code = psl->Parameters.DeviceIoControl.IoControlCode;//获取派遣过来的CTL操作码
	PVOID systemBuf = pIrp->AssociatedIrp.SystemBuffer;//获取缓存地址(输入输出都靠这个地址)
	ULONG inLen = psl->Parameters.DeviceIoControl.InputBufferLength;//获取输入长度
	ULONG outLen = psl->Parameters.DeviceIoControl.OutputBufferLength;//获取输出长度
	UCHAR IDT[6] = { 0 };
	UCHAR GDT[6] = { 0 };
	ULONG IDT_BASE = 0;
	ULONG GDT_BASE = 0;
	//根据不同的CTL操作码做不同的处理
	switch (code)
	{
	case CODE_CHANGE://注意是以三环视角来看其含义，初始化
		//填充中断门描述符
		__asm sidt IDT;
		IDT_BASE = *(PULONG)(&IDT[2]); 
		DbgPrint("shellCode地址为:%p\n", interruptGate);
		ULONG firstPart = (((ULONG)interruptGate) & 0xFFFF0000) | 0x0000EE00;
		ULONG secondPart = (((ULONG)interruptGate) & 0x0000FFFF) | 0x00080000;
		DbgPrint("中断门描述符:%p`%p\n", firstPart, secondPart);
		*(PULONG)(IDT_BASE + 32 * 8) = secondPart;
		*(PULONG)(IDT_BASE + 32 * 8 + 4) = firstPart;
		//填充调用门
		__asm sgdt GDT;
		GDT_BASE = *(PULONG)(&GDT[2]);
		ULONG targetAddress = *(ULONG*)systemBuf;//获取三环传过来的要跳转的函数地址
		DbgPrint("targetAddress:%p\n", targetAddress);
		ULONG firstPart_gdt = (((ULONG)targetAddress) & 0xFFFF0000) | 0x0000EC00;
		ULONG secondPart_gdt = (((ULONG)targetAddress) & 0x0000FFFF) | 0x00080000;
		DbgPrint("调用门描述符:%p`%p\n", firstPart_gdt, secondPart_gdt);
		*(PULONG)(GDT_BASE + 9 * 8) = secondPart_gdt;
		*(PULONG)(GDT_BASE + 9 * 8 + 4) = firstPart_gdt;
//下面代码想在驱动中修改PTE却发现PTE是0。
		//改变messageBox所在的物理页属性R/W为1
		//判断systemBuf中是否有内容
		//ULONG targetAddress = *(ULONG*)systemBuf;//获取三环传过来的函数地址
		//DbgPrint("MessageBoxA地址为:%p\n", messageBoxAAddr);
		//ULONG PDI = (messageBoxAAddr >> 21) & 0x1FF;
		////读取PDE
		//ULONG lowPDE = *(ULONG*)(0xC0601000 + 8 * PDI);
		//ULONG highPDE = *(ULONG*)(0xC0601000 + 8 * PDI +4);
		//DbgPrint("PDE为:%p`%p\n", highPDE,lowPDE);
		////读取PTE
		//ULONG PTI= (messageBoxAAddr >> 12)& 0x1FF;
		//ULONG lowPTE = *(ULONG*)(0xC0000000 + 0x1000 * PDI + PTI * 8);
		//ULONG highPTE = *(ULONG*)(0xC0000000+ 0x1000 * PDI + PTI * 8 + 4);
		//DbgPrint("PTE为:%p`%p\n", highPTE, lowPTE);

		break;
	case CODE_RESUME://三环想要反初始化
		//恢复原样
		break;

	case CODE_READ:
		/*DbgPrint("current ESP:%p\n", getESP);
		DbgPrint("param:%p,%p,%p,%p,%p\n", param[0], param[1], param[2], param[3], param[4]);*/
		if(param[4]!= current)
		{
			memcpy(systemBuf, param, 20);
			pIrp->IoStatus.Information = 20;
			current++;
		}
		else
		{
			pIrp->IoStatus.Information = 0;
		}
		break;
	}
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);//表示调用方已完成所有I/O请求处理操作，并将给定的 IRP 返回给 I/O 管理器。将IRP往下派发
	return STATUS_SUCCESS;
}


//入口函数，相当于main函数
NTSTATUS DriverEntry(PDRIVER_OBJECT pdriver, PUNICODE_STRING pReg)
{
	//设置一个卸载函数，用于退出
	pdriver->DriverUnload = DriverUnload;
	//创建设备名称
	UNICODE_STRING Devicename;
	RtlInitUnicodeString(&Devicename, L"\\Device\\MyDevice");
	//设备对象指针，用于接受
	PDEVICE_OBJECT pDeviceObj = NULL;
	//创建设备
	NTSTATUS status = IoCreateDevice(pdriver,0,&Devicename,FILE_DEVICE_UNKNOWN,FILE_DEVICE_SECURE_OPEN,TRUE,&pDeviceObj	);
	if (!NT_SUCCESS(status))//NT_SUCCESS,微软提供的，实际上就是判断status是否大于等于0
	{
		DbgPrint("创建设备失败!\n");
		return status;
	}
	//如果前面创建设备对象成功，就设置交互数据的方式
	pDeviceObj->Flags |= DO_BUFFERED_IO;
	//创建符号链接名称
	RtlInitUnicodeString(&SymbolicLinkName, L"\\??\\MyTestDriver");
	status = IoCreateSymbolicLink(&SymbolicLinkName, &Devicename);
	if (!NT_SUCCESS(status))
	{
		DbgPrint("创建符号链接失败!\n");
		IoDeleteDevice(pDeviceObj);//删除设备
		return status;
	}
	//设置派遣函数   
	pdriver->MajorFunction[IRP_MJ_CREATE] = MyCreateDispatchFunction;
	pdriver->MajorFunction[IRP_MJ_CLOSE] = MyCloseDispatchFunction;
	pdriver->MajorFunction[IRP_MJ_DEVICE_CONTROL] = ControlCallBack;
	

	return STATUS_SUCCESS;
}
```

### R3代码

```c
#include"stdafx.h"
#include <stdio.h>
#include <stdlib.h>
#include <Windows.h>
#include <WinIoCtl.h>

#define CODE_CHANGE CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define CODE_RESUME CTL_CODE(FILE_DEVICE_UNKNOWN,0x900,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define CODE_READ CTL_CODE(FILE_DEVICE_UNKNOWN,0x1000,METHOD_BUFFERED,FILE_ANY_ACCESS)

//打开设备
BOOLEAN openDevice(HANDLE *handle)
{
	HANDLE _handle = CreateFileA("\\\\.\\MyTestDriver", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);//打开设备对象句柄
	*handle = _handle;
	return (int)_handle > 0;
}

//发送IRP_MJ_DEVICE_CONTROL
BOOLEAN sendCode(HANDLE hDevice, DWORD code, PVOID inData, ULONG Inlen, PVOID outData, ULONG outLen, LPDWORD resultLen)
{
	return DeviceIoControl(hDevice, code, inData, Inlen, outData, outLen, resultLen, NULL);
}

DWORD lowPDE,lowPTE;
DWORD highPDE,highPTE;

void __declspec(naked) callGate()
{
	_asm
	{
		pushfd;
		pushad;
		mov ecx,dword ptr ds:[MessageBoxA];
		//get pde
		mov eax,ecx;
		shr eax,21;
		and eax,0x1FF;
		shl eax,3;
		mov edx,dword ptr ds:[0xC0601000+eax];
		mov dword ptr ds:[lowPDE],edx;
		mov edx,dword ptr ds:[0xC0601000+eax+4];
		mov dword ptr ds:[highPDE],edx;
		//get pte
		mov eax,ecx;
		shr eax,12;
		and eax,0xFFFFF;
		shl eax,3;
		mov edi,dword ptr ds:[0xC0000000+eax];
		mov dword ptr ds:[lowPTE],edi;
		mov edx,dword ptr ds:[0xC0000000+eax+4];
		mov dword ptr ds:[highPTE],edx;
		//change R/W in PDE
		or edi,0x2;
		mov dword ptr ds:[0xC0000000+eax],edi
		popad;
		popfd;
		retf;
	}
}

void main()
{
	// MessageBoxA 挂物理页，不这样操作，MessageBoxA的PTE可能是无效的
	__asm
	{
		mov eax, dword ptr ds:[MessageBoxA];
		mov eax,[eax];
	}
	printf("MessageBoxA address:%p\n",MessageBoxA);
	HANDLE hDevice;
	char buf[30] = { 0 };
	DWORD realReaded = 0;
	if (!openDevice(&hDevice))
	{
		printf("打开设备对象失败!\r\n");
		system("pause");
		return;
	}
	*(DWORD*)buf=(DWORD)callGate;
	sendCode(hDevice, CODE_CHANGE, buf, 30, NULL, 0, &realReaded);
	printf("callGate address:%p\n",callGate);
	
	char callCallgate[6]={0,0,0,0,0x48,0};
	_asm
	{
		call fword ptr[callCallgate];
	}
	printf("PDE:%p`%p\n",highPDE,lowPDE);
	printf("PTE:%p`%p\n",highPTE,lowPTE);
	//hook MessageBoxA
	char hookContent[2]={0xCD,0x20};
	memcpy(MessageBoxA,hookContent,2);
	//hook succeed!
	//get R0 info from MessageBoxA
	DWORD current=0;
	while(1)
	{
		sendCode(hDevice, CODE_READ, NULL, 0, buf, 30, &realReaded);
		DWORD* p=(DWORD*)buf;
		if(realReaded>0)
		{
			printf("No.%d MessageBoxA(%p,%p,%p,%p)\n",p[4],p[0],p[1],p[2],p[3]);
			current++;
		}
		Sleep(100);
	}
	CloseHandle(hDevice);
	system("pause");
}
```

成功监听MessageBoxA结果：

![image-20210830211435935](https://gitee.com/ZEROKO14/blog-img/raw/master/img/image-20210830211435935.png)

[别人的代码参考](https://blog.csdn.net/weixin_41875267/article/details/109692389)

### 重难点

- 跟界面相关的API永远都是**懒加载**的，即没调用不加载，物理页不会挂上去。
- 但是OpenProcess这种，他自己事先就加载好了，挂上了物理页。

## Inline Hook

与R3的Inline Hook完全一样

位置的选择：

1. JMP/CALL指令至少占用5个字节
2. 绕开全局变量（每次的全局变量位置是不确定，因为模块加载的顺序不一致）
3. 根据业务来决定在哪里HOOK，过滤参数？修改返回结果？

思考：

1. 正在hook的瞬间，如何保证多核切换的稳定性
2. 如何绕过硬编码校验检测内联HOOK











